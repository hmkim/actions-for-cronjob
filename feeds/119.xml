<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/">
	<channel>
		<title>/* the devil is in the detail */</title>
		<description>김민장의 블로그 | Minjang Kim's Blog</description>		
		<link>http://minjang.github.io/</link>
		
			<item>
				<title>초등학교 덧셈 알고리즘을 코드로 써보기</title>
				        
        <description>&lt;p&gt;&lt;strong&gt;일러두기&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이 글은 순전히 저의 개인적인 의견이며 전/현직 회사와는 무관합니다.&lt;/li&gt;
  &lt;li&gt;소개된 문제는 &lt;a href=&quot;https://leetcode.com/problems/add-strings/&quot;&gt;인터넷에서 찾을 수 있는 문제&lt;/a&gt;이며 실제 면접에선 변형된 문제를 냈음을 밝힙니다.&lt;/li&gt;
  &lt;li&gt;미국 회사에서 겪은 경험에 기반해 쓴 글이므로 한국 상황과는 다를 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3줄 요약&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;코딩 면접에서 문제 해결 능력과 코딩 능력은 다릅니다.&lt;/li&gt;
  &lt;li&gt;의외로 사소해 보이는 부분에서도 코딩 능력을 꽤 많이 가늠할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;코딩 면접 준비 시 &lt;del&gt;다이나믹 프로그래밍에 시간 허비하지 말고&lt;/del&gt; 기초 코딩 능력을 한번 더 점검할 것을 추천합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;개발자, 영어로 SWE(Software Engineer)&lt;sup id=&quot;fnref:SWE&quot;&gt;&lt;a href=&quot;#fn:SWE&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 또는 SDE(Software Development Engineer)로 대표되는 직업군에 있어 코딩 인터뷰는 필수다. 굳이 이 글에서 코딩 인터뷰가 유용성까지 말하기는 벅차다. 그냥 한 문제를 예로 들면서 코딩 인터뷰의 주요 평가 요소와 실제 지원자들이 어떻게 코딩하는지 이야기를 해볼까 한다. 결국 기본적인 코딩 능력이 중요하다.&lt;/p&gt;

&lt;h2 id=&quot;코딩-인터뷰의-평가-요소&quot;&gt;코딩 인터뷰의 평가 요소&lt;/h2&gt;

&lt;p&gt;코딩 인터뷰를 통과하려면 당연히 ‘코딩’을 잘해야 하는데 이 말은 다소 모호하다. 어떤 평가 요소가 있는지 먼저 살펴봐야 한다. 가장 중요한 요소는 “문제 해결 능력”과 “코딩 능력”이다. 이 둘은 언뜻 비슷해 보이지만 확연히 구분된다. 면접관은 이 두 주요 능력에 대한 긍정적 및 부정적 신호를 코딩 면접에서 최대한 많이 찾아낸 뒤 최종적으로 당락을 결정한다.&lt;/p&gt;

&lt;h3 id=&quot;-문제-해결-능력&quot;&gt;· 문제 해결 능력&lt;/h3&gt;

&lt;p&gt;먼저, 문제 해결 능력이란, 예를 들어, “주어진 배열에서 중복된 요소를 제거하세요” 같은 문제가 있다면, 이것에 대한 해법을 논리적으로 설명할 수 있는 능력이다. 적절하고 효율적인 자료구조를 고르고, 알고리즘을 고안해내 면접관에게 설명해야 한다. 기초적인 자료구조와 알고리즘 지식, 전산학 기초 지식, 문제 해결에 대한 창의력 등을 평가할 수 있다. 이 과정에서 코딩이 필요한 것은 아니다.&lt;/p&gt;

&lt;p&gt;여기서 코딩 인터뷰에서 문제를 받았을 때 바로 코딩을 시작하는 것이 좋지 않음을 알 수 있다. 아무리 쉬운 문제라도 먼저 면접관에게 접근 방법을 명확하게 설명하는 것이 좋다. 그렇다고 해서 모든 경우를 완벽하게 코딩 전에 설명하라는 것은 아니다. 코드로 옮기다 보면 미처 생각하지 못한 예외 사항을 뒤늦게 발견할 수 있을 것이다. 괜찮다. 하지만 대략적인 접근법은 코딩에 앞서 설명을 해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;-코딩-능력&quot;&gt;· 코딩 능력&lt;/h3&gt;

&lt;p&gt;코딩 능력은 이제 제안한 알고리즘을 특정 프로그래밍 언어로 옮겨 쓸 수 있는 능력이다. 문제 해결 능력과는 분명히 다른 요소이다. 매우 기본 코딩 능력인 변수, 조건문, 반복문부터 함수/메서드의 작성 등 말 그대로 코드를 쓰는 과정에서 지원자의 코딩 경험 및 실력을 가늠할 수 있다.&lt;/p&gt;

&lt;p&gt;내 경험에 따르면 금융 회사들은 프로그래밍 언어 지식에 대해서도 깊게 평가한다. 하지만 특정 언어 지식 자체는 대게 평가 요소는 아니다. 그래도 시니어급 지원자가 주력 언어의 기본적인 작업, 숫자를 문자열로 바꾸는 방법 같은 것을 잘 모른다면 적어도 나에게는 나쁜 신호이다. 코딩 스타일도 그러하다. 사소한 스타일에서도 몇몇 신호를 찾을 수 있다.&lt;/p&gt;

&lt;p&gt;마지막으로 소통 능력, 논리적으로 자기 생각을 얼마나 잘 조리 있게 말하는 가도 중요한 요소이며, 코드를 꼼꼼하게 검증하는 능력도 소홀히 해서는 안 된다.&lt;/p&gt;

&lt;h2 id=&quot;좋은-코딩-문제란&quot;&gt;좋은 코딩 문제란?&lt;/h2&gt;

&lt;p&gt;참 어려운 질문이다. 코딩 인터뷰 준비로 널리 알려진 릿코드에 가보면 이미 &lt;a href=&quot;https://leetcode.com/problemset/all/&quot;&gt;천 개의 문제&lt;/a&gt;가 있다.&lt;sup id=&quot;fnref:LC&quot;&gt;&lt;a href=&quot;#fn:LC&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; 좋은 문제도, 이상한 문제도, 나쁜 문제도 있다. 면접관의 철학과 취향에 따라, 또는 회사의 방침에 코딩 문제의 유형이 달라질 수도 있다.&lt;/p&gt;

&lt;p&gt;내 생각에 좋은 코딩 문제는 ‘적절한’ 문제 해결 능력과 ‘적절한’ 코딩 능력을 모두 볼 수 있는 문제가 좋다. 적절한이란 단어가 좀 애매하다. 그래서 10명 이상 지원자에게 이 문제를 줬을 때 ‘적절한’ &lt;a href=&quot;https://en.wikipedia.org/wiki/The_Bell_Curve&quot;&gt;정규분포&lt;/a&gt;가 나오는 문제를 좋은 문제라고 생각한다. 중간 난이도의 문제라면 평균적으로 푸는 사람이 가장 많아야 하며, 못 푸는 사람과 잘 푸는 사람이 비슷한 빈도로 나오면 좋다. 특별히 쉽거나 어려운 문제는 어느 정도 편향이 발생할 것이고 이건 괜찮다.&lt;/p&gt;

&lt;p&gt;말이 쉽지 여전히 아리송하다. 한 예로 설명해보자. 나는 다이나믹 프로그래밍 문제를 싫어한다. 면접 문제로 적합하지 않다. 문제 해결이 지나치게 어렵기 때문이다. 미리 열심히 공부하지 않으면 아예 건드리기도 힘들 수 있다. 알더라도 점화식(recurrence)을 찾는 건 굉장한 논리적 도약이 필요하다. 이런 문제는 종형 분포가 나오지 않고 잘 풀거나 아예 못 풀거나로 나뉘어 버린다. 한마디로 A+, A0, D, F 학점만 나오는 일이 벌어진다.&lt;/p&gt;

&lt;p&gt;더욱 큰 문제는 문제 해결은 어려운데 코딩은 매우 단순하다는 것이다. 다이나믹 프로그래밍 문제는 보통 테이블에 값만 잘 설정하면 끝나므로 코딩 능력을 깊게 살펴보기 어렵다. 결국 코딩 문제가 아니라 브레인 티저 문제가 되기 쉽다. 이런 이유로 페이스북과 우버 같은 회사에서는 다이나믹 프로그래밍 문제를 내지 않도록 면접관에게 권고한다.&lt;/p&gt;

&lt;p&gt;물론 운이 정말 없다면 다이나믹 프로그래밍 문제를 내는 면접관을 만날 수 있다. 코딩 면접에서 운은 사실 굉장히 중요하다. 이럴 때도 겁내지 말고 브루트 포스로 먼저 풀고 메모이제이션 같은 걸로 최적화해도 된다.&lt;/p&gt;

&lt;p&gt;다이나믹 프로그래밍으로 태깅된 릿코드 문제는 &lt;a href=&quot;https://leetcode.com/tag/dynamic-programming/&quot;&gt;130개 넘게 있으며&lt;/a&gt;, 미국 소프트웨어 개발자들이 꽤 모이는 &lt;a href=&quot;https://www.teamblind.com/search/dynamic%20programming&quot;&gt;블라인드 익명 앱&lt;/a&gt;에서도 이 문제에 대한 한탄과 고뇌는 흔히 볼 수 있는 주제이다. 여전히 많은 코딩 면접 준비자들이 이걸로 고생하는데 참으로 안타까운 일이다. 나는 과감히 포기할 것을 &lt;del&gt;책임을 지지는 않지만&lt;/del&gt; 추천한다. 차라리 다른 기본을 충실히 하는 게 훨씬 좋을 수 있다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/2019/dp.JPG&quot; style=&quot;width: 50%; height: 50%&quot; /&gt;
&lt;small&gt;&lt;i&gt;모 회사의 어떤 회의실 이름&lt;/i&gt;&lt;/small&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;오늘의-문제-문자열로-주어진-두-숫자를-더해보세요&quot;&gt;오늘의 문제: 문자열로 주어진 두 숫자를 더해보세요.&lt;/h2&gt;

&lt;p&gt;서론이 너무 길었다. 드디어 제목과 관련 있는 이야기를 해보자. 오늘의 문제는 다이나믹 프로그래밍과 비교한다면 반대편에 있는 문제이다. 즉, 문제 해결 능력은 거의 없거나 간단한 수준이고 대신 코딩을 중점적으로 볼 수 있는 문제이다.&lt;/p&gt;

&lt;p&gt;이 문제는 &lt;a href=&quot;https://leetcode.com/problems/add-strings/&quot;&gt;릿코드에도 있으며&lt;/a&gt; 43%가 통과한 easy 등급이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given two non-negative integers &lt;code class=&quot;highlighter-rouge&quot;&gt;num1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;num2&lt;/code&gt; represented as string, return the sum of &lt;code class=&quot;highlighter-rouge&quot;&gt;num1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;num2&lt;/code&gt;.&lt;/p&gt;

  &lt;p&gt;“문자열로 표현된 두 음이 아닌 정수 &lt;code class=&quot;highlighter-rouge&quot;&gt;num1&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;num2&lt;/code&gt;가 있을 때, 이 둘의 합을 반환하시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;내 생각에 이 정도는 실력 있는 개발자에겐 쉬울 것이다. 스크리닝 인터뷰나 코딩 능력이 다소 부족할 것 같은 면접자에게 변형된 문제를 종종 낸다. 정식 코딩 인터뷰라면 이 문제는 워밍업 문제로 10-15분 내에 풀면 좋다. 그런데 쉽게 생각한 문제에서 생각보다 많은 코딩 능력 신호를 읽어낼 수 있었다. 놀랍기도 하고 한편으론 충격도 받았다. 20-30분씩 걸려서 푸는 사람들도 있었고, 끝내 제대로 완성 못한 지원자도 있었다. 물론 10분 이내에 푸는 사람도 있다.&lt;/p&gt;

&lt;p&gt;이 문제에서 문제 해결 능력은 사실상 필요하지 않다. 그렇다. 정말 초등학교 덧셈을 하라는 이야기다. 숫자를 뒤에서 하나씩 읽어 두 합을 구한 뒤 자리 올림수(carry)를 넘겨주는 매우 매우 기본적인 덧셈 이야기다 (&lt;a href=&quot;https://blog.naver.com/snoogy1/220493885819&amp;quot;&quot;&gt;그림 출처&lt;/a&gt;). 컴퓨터 구조에 나오는 ALU 기본 원리와 같긴 하지만 이 문제는 그렇게 심오한 게 아니다.&lt;sup id=&quot;fnref:ap&quot;&gt;&lt;a href=&quot;#fn:ap&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/2019/addition.png&quot; style=&quot;width: 80%; height: 80%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;그런데 문제를 이렇게만 주면 의외로 문자열 숫자를 그냥 정수형으로 바로 바꿔서 풀려는 사람이 있다!&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add_strings&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;처음 겪었을 땐 깜짝 놀랐다. 솔직히 말해 코딩 인터뷰의 대부분은 문제를 위한 문제다. 그렇다면 이렇게 간단한 문제를 낼 리는 없지 않은가? 충분히 코딩 인터뷰 연습을 했다면 이런 건 시도조차 하지 않을 것이다. 그런데 이런 시도를 하는 사람이 종종 나온다. 그래서 제약 조건을 말한다. 릿코드 문제에도 이렇게 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;You &lt;strong&gt;must not&lt;/strong&gt; use any built-in BigInteger library or convert the inputs to integer directly.&lt;/p&gt;

  &lt;p&gt;“BigInteger 라이브러리 또는 전체 숫자열을 바로 정수로 변환하는 내장 기능 쓰지 마세요.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;코딩하기&quot;&gt;코딩하기&lt;/h2&gt;

&lt;p&gt;문제 이해가 끝났으니 초등학생이 하는 그 덧셈 알고리즘을 그대로 코드로 옮기자. 차근차근 정리하면 다음과 같다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;두 숫자 문자열을 뒤에서 각각 하나씩 읽는다. (입력은 음이 아닌 정수로 가정했으므로 예외 검사는 하지 않아도 된다.)&lt;/li&gt;
  &lt;li&gt;이 두 문자를 숫자로 변환한 뒤에 (‘1’을 1로 변환하는 건 당연히 허용된다) 덧셈을 한다. 올림수를 같이 처리한다.&lt;/li&gt;
  &lt;li&gt;덧셈 결과를 최종 변수에 저장하고, 올림수를 갱신한다.&lt;/li&gt;
  &lt;li&gt;이 과정을 반복한다.&lt;/li&gt;
  &lt;li&gt;반복문이 끝났을 때 여전히 올림수가 있는지 본다. 있으면 1을 추가한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기서 까다로운 부분은 두 숫자 문자열의 길이가 다를 때이다. 상당히 재밌는 것은 이 문제를 푸는 사람마다 이 부분을 모두 제각각의 방법으로 푼다는 점이다. 여기서 여러 코딩 실력을 읽을 수 있다. 사소하다고 생각할 수도 있는데, 변수, 조건문, 반복문을 어떻게 쓰는가는 상당히 중요한 신호이다. 대부분의 코딩은 변수, 반복문, 분기문으로 이뤄진다. 이 문제에서 이런 기본기를 잘 살펴볼 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;-파이썬으로-풀기&quot;&gt;· 파이썬으로 풀기&lt;/h3&gt;

&lt;p&gt;요즘 인턴, 졸업 예정자, 특히 머신러닝 소프트웨어 엔지니어 지원자들은 대부분 파이썬을 코딩 면접에서 쓴다. 파이썬으로 먼저 생각해보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;두 입력 문자열의 길이가 다른 경우를 처리하는 것이 결국 핵심이다. 정말 다양한 방법이 있는데 나는 왠지 파이선의 &lt;code class=&quot;highlighter-rouge&quot;&gt;zip&lt;/code&gt;이 참 맘에 든다. 이 녀석으로 두 입력 문자열에서 문자 두 개를 동시에 읽고 싶다. 그러려면 두 문자열 길이를 맞춰야 한다. 짧은 숫자 앞에다 0을 채워준다. 간단한 작업 같지만, 코딩이 부족한 사람은 여기서부터 여지없이 막힌다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zip&lt;/code&gt;으로 문자 두 개를 한꺼번에 읽는 반복문을 작성한다. 거꾸로 읽어야 하는데 파이썬 문자열을 뒤집는 건 슬라이스 연산자 &lt;code class=&quot;highlighter-rouge&quot;&gt;[::-1]&lt;/code&gt;로 하는 게 &lt;a href=&quot;https://stackoverflow.com/questions/931092/reverse-a-string-in-python&quot;&gt;좋아 보인다&lt;/a&gt;. 우아하게 &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;를 동시에 읽은 뒤에 덧셈한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;를 써도 되고 아니면 아스키 코드로 생각해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;ord&lt;/code&gt;를 써도 괜찮을 것이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;여기서 올림수, &lt;code class=&quot;highlighter-rouge&quot;&gt;carry&lt;/code&gt;를 더해야 한다. 이 변수는 미리 0으로 초기회를 해야 한다. 놀라지 마시라. 이 부분 힘들어하는 면접자들이 꽤 있다. 문제 해결 능력이 부족하지는 않을 것이다. 하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;carry&lt;/code&gt;를 0으로 미리 잡지 않고 허둥대는 사람들도 있다. 코딩 경험이 부족하면 벌어질 수 있는 일.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;덧셈한 결과가 예를 들어 14라고 하자. 당연히 4만 결과 변수에 저장을 해야 하고 1을 carry로 옮겨야 한다. 자, 여기서도 다양한 코딩을 볼 수 있었다. 분기문을 써서 하던, 나눗셈을 써서 하던 뭐가 됐던 하면 된다. 그런데 모듈로 연산자를 바로 쓰지 못하는 사람도 있다. 12년 전, 굉장한 화제가 되었던 &lt;a href=&quot;https://blog.codinghorror.com/why-cant-programmers-program/&quot;&gt;FizzBuzz 문제가 떠오른다&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;결과를 저장할 때 뒤에다 붙일까(append) 아니면 앞에다 붙일까(prepend)? 그렇다, 여기서도 고민하고 실수하는 사람들이 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;보다시피 코드로 옮기는 과정이 생각보다는 조금 까다롭다. 무엇보다 구현의 자유도가 높다. 그러니 다양한 코딩 패턴을 볼 수 있고, 기초 코딩 실력을 파악할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://repl.it/repls/VisibleBisqueServer&quot;&gt;대략 이 과정을 코드로 쓰면 다음과 같다&lt;/a&gt;. (참고로 저는 파이썬 전문가가 아니니 제가 쓴 코드가 꼭 좋다는 보장은 없습니다.)&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add_strings&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'0'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'0'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;carry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[::&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[::&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]):&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;ord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;ord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;ord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'0'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;carry&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;carry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;carry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'1'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_strings&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;12345&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;987654321&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;987666666&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;코딩을 많이 해보지 않은 분들은 길이가 다른 경우 처리를 상당히 힘들어한다. 최악의 코드는 아마도 어느 한쪽이 크다고 가정하고 쓴 코드를 통째로 복사해서 붙여넣는 것이다. 이렇게 하는 분들도 봤다. 파이썬은 언어 특성상 인덱스를 변수로 하는 루프가 흔하지 않다. 그래서 두 문자열에서 동시에 문자를 읽는 것을 척척하지 못하는 면접자들도 간혹 있다.&lt;/p&gt;

&lt;h3 id=&quot;-c로-풀기&quot;&gt;· C++로 풀기&lt;/h3&gt;

&lt;p&gt;아무래도 나의 주력 언어가 C++이라서 이걸로도 풀어보자. C++ 코딩 실력을 가늠하는데도 이 문제는 꽤 유용하다.
C++은 성능과 관련된 고려가 많다. 코딩 면접 시 코드를 쓰면서도 계속 내가 왜 이 방법을 택하게 되었는지 그 이유를 설명하면 좋다. 짧은 순간마다 자신의 프로그래밍 언어 지식을 말할 수 있다. 파이썬, 자바 등 다른 언어도 마찬가지다.&lt;/p&gt;

&lt;p&gt;C++로는 거꾸로 읽는 &lt;code class=&quot;highlighter-rouge&quot;&gt;rbegin()&lt;/code&gt;을 이용해면 괜찮을 것이다. 0으로 채우는 번거로운 과정은 피하자. 추가적인 메모리 연산을 굳이 할 필요 없다. 한 쪽이 이미 끝에 다다랐을 때는 0을 주면 된다. 그리고 그냥 C++ 좀 쓴다는 티를 내고 싶어서 &lt;code class=&quot;highlighter-rouge&quot;&gt;stringstream&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;reverse&lt;/code&gt;를 써보았다. &lt;a href=&quot;https://repl.it/repls/ImperfectSuperbOpengroup&quot;&gt;코드는 이렇다&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addStrings&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stringstream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rbegin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rbegin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;carry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'0'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'0'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;carry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;carry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;carry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;생각만큼 &lt;code class=&quot;highlighter-rouge&quot;&gt;rbegin()&lt;/code&gt;을 능숙히 쓰는 사람이 많지는 않다. 그렇다면 인덱스 &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;j&lt;/code&gt;를 이용하자. 여기서 사소해 보이지만 결코 사소하지 않는 이슈가 있다.&lt;/p&gt;

&lt;p&gt;대부분 면접자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::string&lt;/code&gt;을 포함한 STL 자료구조의 크기나 인덱스를 &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;로 받는다. 코딩 인터뷰에서는 별문제는 없다. 하지만 STL 자료구조에서 32비트 범위가 넘는 원소 개수를 다뤄보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; 인덱스가 상당히 눈에 거슬린다. STL은 안타깝게도 &lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned&lt;/code&gt; 타입의 &lt;code class=&quot;highlighter-rouge&quot;&gt;size_t&lt;/code&gt;를 반환한다. 사실상 서버/데스크탑 컴퓨터는 모두 64비트이므로 64비트 부호 없는 정수가 된다. 다시 말하지만, 인터뷰에서는 그냥 &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; 써도 충분하다. 그런데 C++ 실력을 더욱 뽐내려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;size_t&lt;/code&gt;로 처리하는 것도 좋다.&lt;/p&gt;

&lt;p&gt;다만 주의할 것은 &lt;code class=&quot;highlighter-rouge&quot;&gt;size_t&lt;/code&gt;로 인덱스를 거꾸로 돌릴 때이다. -1이 되는 순간 무한 루프에 빠지기 때문이다. 그래서 나는 &lt;code class=&quot;highlighter-rouge&quot;&gt;[0, size)&lt;/code&gt; 구간에서 반복하되 쓰는 시점에서 인덱스의 역을 구해 쓴다. -1로 종료 조건을 따져야 하는 경우를 원천적으로 피한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;carry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'0'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'0'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;혹시나 수식에 포함된 &lt;code class=&quot;highlighter-rouge&quot;&gt;i++&lt;/code&gt;가 눈에 거슬릴 수 있다. 아무 생각 없이 쓰다간 &lt;a href=&quot;https://stackoverflow.com/questions/949433/why-are-these-constructs-using-pre-and-post-increment-undefined-behavior&quot;&gt;undefined behavior&lt;/a&gt;를 만날 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;이전 회사와 지금 회사에서 대략 100번에 가까운 코딩 인터뷰를 한 것 같다. 여러 코딩 문제를 써봤는데 이 문제는 기본적인 코딩 실력을 확인하는 데 좋다. 이 문제를 잘 푼다고 코딩을 잘한다고 말하기는 힘들다. 하지만 코딩 실력이 부족한 사람은 쉽게 판단할 수 있다. 반대로 말하면, 코딩을 이제 막 시작한 분들에게 이 정도 문제가 쉽게 느껴지면 초급을 넘는 코딩 실력은 갖춰줬다는 뜻이기도 하다.&lt;/p&gt;

&lt;p&gt;언제나 기본이 제일 중요하다. 주어진 알고리즘을 코드로 옮기는 기본 코딩 능력이 가장 중요하다. 문제 해결 능력은 그 뒤다. 코딩 중에서도 분기문, 반복문, 변수, 수식 같은 기본기가 탄탄해야 한다. 이런 기본기에 소홀하면 릿코드 문제를 몇백 개 풀어도 코딩 면접에서 떨어질 수 있다.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:SWE&quot;&gt;
      &lt;p&gt;SWE를 ‘스위’라고 미국인들은 보통 읽는다. 충격 받지 않도록 주의. &lt;a href=&quot;#fnref:SWE&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:LC&quot;&gt;
      &lt;p&gt;오죽하면 “나 코딩 인터뷰 준비해”를 요즘 “나 릿코드해”라고 말합니다. &lt;a href=&quot;#fnref:LC&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:ap&quot;&gt;
      &lt;p&gt;이 문제를 내 전공(컴파일러, 코드 최적화, 컴퓨터 구조) 관점에서 본다면 &lt;a href=&quot;https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic&quot;&gt;arbitrary precision&lt;/a&gt; 문제이고 매우 깊게 이야기 할 수 있는 주제이다. &lt;a href=&quot;#fnref:ap&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
				<pubDate>Sat, 02 Mar 2019 00:00:00 +0000</pubDate>
				<link>http://minjang.github.io/2019/03/02/convert-math-addition-algorithm-to-code/</link>
				<guid isPermaLink="true">http://minjang.github.io/2019/03/02/convert-math-addition-algorithm-to-code/</guid>
			</item>
		
			<item>
				<title>두 변수 값 바꾸기에 대한 고찰: 후속편</title>
				        
        <description>&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;: 스왑 함수는 임시 변수 또는 XOR 연산으로 구현할 수 있다. 이 둘의 미시적인 차이는 설명할 수 있다. 그러나 스왑 함수가 인라인 및 최적화 된다면 &lt;u&gt;(추가) 그리고 스왑된 변수가 값으로 사용되어 레지스터로 승급이 된다면&lt;/u&gt; 두 방법에는 아무런 차이가 없다.
LLVM 기준으로 인라인 후, 임시 변수 스왑에 memory to register promotion 또는 Scalar Replacement Of Aggregates (SROA) 최적화를, XOR 스왑에 instruction combine 최적화를 적용하면 이 둘의 차이는 없어진다.&lt;/p&gt;

&lt;p&gt;(추가) 한편 스왑된 변수가 메모리에 상주해야할 때는 컴파일러에 따라 XOR/임시 변수 방식에 따라 차이가 발생할 수 있고, 일반적으로 임시 변수 방식이 보다 더 &lt;a href=&quot;#followup&quot;&gt;최적화에 용이하다고 말할 수 있다.&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;두 변수 값&lt;sup id=&quot;fnref:term&quot;&gt;&lt;a href=&quot;#fn:term&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;을 서로 바꾸는 스왑 함수는 보통 임시 변수를 써서 만든다. 아래 같은 전산학 유머도 있다.&lt;/p&gt;

&lt;blockquote class=&quot;twitter-tweet&quot; data-lang=&quot;en&quot;&gt;&lt;p lang=&quot;ko&quot; dir=&quot;ltr&quot;&gt;프로그래밍 유머 해주세요 — 전산과 학생 두 명이 자리를 바꾸는 데 필요한 의자의 갯수는 세 개입니다. &lt;a href=&quot;http://t.co/M9kRPVwW5G&quot;&gt;http://t.co/M9kRPVwW5G&lt;/a&gt;&lt;/p&gt;&amp;mdash; Jeong Jinmyeong (@BaalDL) &lt;a href=&quot;https://twitter.com/BaalDL/status/506789880895393792&quot;&gt;September 2, 2014&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;p&gt;그런데 임시 변수를 쓰지 않고 &lt;a href=&quot;https://en.wikipedia.org/wiki/XOR_swap_algorithm&quot;&gt;XOR 산술 연산만으로 바꾸는 방법&lt;/a&gt;도 널리 알려져있다. 덕분에 임시 변수를 안 쓰는 스왑 함수가 더 효율적인지 종종 논쟁이 되곤 한다. 무려 9년 전, 이 두 스왑 함수의 구현 방법을 컴퓨터 구조 관점에서 &lt;a href=&quot;http://minjang.egloos.com/1241820&quot;&gt;비교하였다&lt;/a&gt;. 6년 전 출간된 拙著에서도 이 주제로 한 단원을 썼다.
긴 세월이 지난 지금, 다시 한번 임시 변수 스왑과 XOR 스왑의 차이에 대해 정리하고자 한다. 당시 제대로 이해 못 했던 것을 이제서야 알게 되었다.&lt;/p&gt;

&lt;h3 id=&quot;임시-변수-스왑과-xor-스왑-비교&quot;&gt;임시 변수 스왑과 XOR 스왑 비교&lt;/h3&gt;

&lt;p&gt;비교하고자 하는 두 스왑 함수의 C++ 구현은 다음과 같다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;temp_swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;xor_swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;!-- _includes/code_caption.html --&gt;
&lt;div class=&quot;code-wrapper&quot;&gt;
    &lt;div class=&quot;code-caption&quot;&gt;두 스왑 구현 방법&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;이전 블로그 글이나 책의 내용을 요약 정리하면 대략 이러하다. 이 부분은 건너 뛰어도 좋다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;temp_swap&lt;/code&gt;은 임시 변수 &lt;code class=&quot;highlighter-rouge&quot;&gt;temp&lt;/code&gt;를 쓰므로 메모리 접근이 더 필요할 것 같다. 하지만 매우 특수하고 예외적인 환경만 아니라면 컴파일러는 최적화를 하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;temp&lt;/code&gt; 변수를 메모리에 할당하지 않고 레지스터에서 처리한다. 추가적인 메모리 사용이나 접근은 없다.
반면, XOR 방식은 임시 변수가 없으니 빨라 보이지만 꼭 그러한 것은 아니다. 명령어 사이의 의존성을 살펴봐야 한다.&lt;/p&gt;

&lt;p&gt;라인 8-10에 있는 세 연산 사이에는 반드시 지켜야 하는 의존성이 있다. 이 의존성은 RAW(Read-After-Write), 다른 말로 흐름 의존성(flow dependency)으로 불린다. 라인 8의 연산을 끝내야만 라인 9를 수행할 수 있고, 마찬가지로 라인 10도 라인 9의 결과를 기다려야만 한다. 이 의존성으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;xor_swap&lt;/code&gt;의 세 XOR 연산은 동시에 수행될 수 없다. 전문 용어를 빌어 쓰자면 명령어 수준 병렬성(ILP, Instruction-Level Parallelism)이 없다고 말한다. 모바일을 포함한 현대 CPU는 ILP를 최대한 활용하도록 설계되어있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;xor_swap&lt;/code&gt;은 이런 CPU의 강점을 누릴 수 없다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;temp_swap&lt;/code&gt;의 연산에도 의존성이 있다. WAR(Write-After-Read), 또는 반 의존성(anti-dependency)이다.
하지만 WAR 의존성은 RAW 의존성과 다르게 회피할 수 있고 명령어 수준 병렬성을 얻을 수 있다.&lt;/p&gt;

&lt;p&gt;코드 1의 라인 2-3에 변수 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;는 WAR 의존성이 있다. 라인 2에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;를 읽은 다음 라인 3에서 쓴다.
그런데 코드 2처럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;a_&lt;/code&gt;을 바꾸면 이 WAR를 없앨 수 있다. 이렇게 하면 코드 2의 라인 1과 2는 서로 의존성이 없고 동시에 실행할 수 있다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;xor_swap&lt;/code&gt;은 세 연산이 모두 순차적으로 실행되어야 했다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;temp_swap&lt;/code&gt;은 두 연산을 한 번에 처리할 수 있으므로 임계 경로 길이를 하나 줄인다. ILP를 얻은 것이다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 라인 1과 2는 동시에 수행 가능
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// 변수 a 사용처를 모두 a_로 바꿔야 함
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;!-- _includes/code_caption.html --&gt;
&lt;div class=&quot;code-wrapper&quot;&gt;
    &lt;div class=&quot;code-caption&quot;&gt;변수 이름 바꾸기로 WAR 의존성 제거 후 명령어 수준 병렬성(ILP) 얻기&lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&quot;그런데-실제-코드에서도-차이가-있을까&quot;&gt;그런데 실제 코드에서도 차이가 있을까?&lt;/h3&gt;

&lt;p&gt;미시적인 관점에서 이 두 구현 방법은 이렇게 설명할 수 있다. 미세하지만 성능 차이도 측정 가능할 것이다. 그렇지만 실제 코드에서 두 방법에 차이가 있는지가 사실 더 중요하다. 예전 글에도 이런 의문지 있었지만 답을 제대로 찾지 못 했다. 이후 좀 더 컴파일러를 들여다 보면서 답을 찾을 수 있었다. LLVM 도구로 컴파일 최적화 과정을 하나씩 적용해가면서 살펴보자.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;llvm-도구로-컴파일-과정-이해하기&quot;&gt;LLVM 도구로 컴파일 과정 이해하기&lt;/h3&gt;

&lt;p&gt;LLVM에 대한 설명은 생략해도 될 것이다. 요즘은 그냥 clang으로 자주 접한다. 예전 글이라 오류가 있을 것 같아 두렵지만 5년 전에 쓴 LLVM에 대한 &lt;a href=&quot;http://minjang.egloos.com/2794928&quot; target=&quot;_blank&quot;&gt;짧은 소개 글&lt;/a&gt;을 참고 해도 좋다.&lt;/p&gt;

&lt;p&gt;사용자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;clang hello.c -O3 -g -o a.out&lt;/code&gt;처럼 컴파일러를 쓴다. 이 간단한 명령에 여러 과정이 숨겨져있다. 현대 컴파일러는 소스 파일 하나를 보통 세 단계로 처리하고 마지막에 링킹 또는 JIT(Just-in-time)을 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프런트 엔드: 소스 코드를 읽어 구문 분석을 한 뒤 중간 표현(IR, Intermediate Representation)으로 변환.&lt;/li&gt;
  &lt;li&gt;미들 엔드: IR에서 여러 최적화 수행.&lt;/li&gt;
  &lt;li&gt;백 엔드: 최적화된 IR를 해당 기계어로 변환. 실행파일이 목표면 오브젝트 파일 생성, JIT는 메모리에 준비.&lt;/li&gt;
  &lt;li&gt;링크: 실행파일 생성이라면 링크 시간 최적화 및 최종 실행 파일 생성, JIT는 코드 실행.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;LLVM에서는 이 과정을 &lt;a href=&quot;http://llvm.org/docs/CommandGuide/index.html&quot; target=&quot;_blank&quot;&gt;LLVM 도구&lt;/a&gt;로 하나하나 조작할 수 있다. 아래 그림은 &lt;code class=&quot;highlighter-rouge&quot;&gt;clang -O3 hello.c&lt;/code&gt;가 어떻게 내부적으로 처리되는지 보여준다. 그림 중 &lt;code class=&quot;highlighter-rouge&quot;&gt;clang&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;opt&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;llc&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;lli&lt;/code&gt;는 LLVM 도구이며 &lt;code class=&quot;highlighter-rouge&quot;&gt;as&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;ld&lt;/code&gt;는 &lt;a href=&quot;https://www.gnu.org/software/binutils/&quot; target=&quot;_blank&quot;&gt;GNU binutils&lt;/a&gt;에 있는 어셈블러와 링커이다.&lt;sup id=&quot;fnref:ld&quot;&gt;&lt;a href=&quot;#fn:ld&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
    &lt;a href=&quot;/assets/2016/llvm-flow.png&quot; title=&quot;&quot; target=&quot;_blank&quot;&gt;
    
    
        &lt;img src=&quot;/assets/2016/llvm-flow.png&quot; style=&quot;border: 0px;&quot; alt=&quot;&quot; /&gt;
    
    &lt;/a&gt;
    
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-emit-llvm&lt;/code&gt; 옵션으로 소스 코드를 LLVM IR인 비트코드 파일(.bc)로 변환한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;llvm-dis&lt;/code&gt;로 사람이 읽을 수 있는 비트코드로 해독할 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;opt&lt;/code&gt;는 비트코드 파일을 대상으로 각종 최적화를 할 수 있다. 그림에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;-O3&lt;/code&gt;처럼 간단히 줬지만 매우 세밀하게 컴파일러 최적화 옵션을 줄 수 있다. 곧 알아볼 것이다.&lt;/li&gt;
  &lt;li&gt;최적화가 끝난 비트코드를 x86이나 ARM 같은 어셈블러 코드로 변환해야 한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;llc&lt;/code&gt;라는 백엔드 컴파일러가 IR를 기계어로 낮춘다. &lt;code class=&quot;highlighter-rouge&quot;&gt;hello.s&lt;/code&gt;는 사람이 읽을 수 있는 어셈블러 코드이다.&lt;/li&gt;
  &lt;li&gt;어셈블러 코드부터는 GNU binutils가 그 임무를 수행한다. 먼저 GNU 어셈블러인 &lt;code class=&quot;highlighter-rouge&quot;&gt;as&lt;/code&gt;가 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello.s&lt;/code&gt;를 읽어 오브젝트 파일로 변환한다.&lt;/li&gt;
  &lt;li&gt;마지막으로 링커인 &lt;code class=&quot;highlighter-rouge&quot;&gt;ld&lt;/code&gt;가 필요한 시스템 라이브러리와 묶어 최종 실행 파일을 만든다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lli&lt;/code&gt;라는 LLVM JIT/인터프리터로 비트코드 파일을 바로 실행할 수도 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;관심있는 분을 위해 LLVM 도구 설치 법을 소개하자면 맥에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;brew install --with-clang llvm&lt;/code&gt;로 간편히 된다. LLVM 도구는 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/opt/llvm/bin&lt;/code&gt;에서 찾을 수 있다. 직접 컴파일하는 것도 그리 어렵지 않아서 추천한다. &lt;a href=&quot;http://llvm.org/docs/GettingStarted.html#git-mirror&quot; target=&quot;_blank&quot;&gt;LLVM 깃 미러&lt;/a&gt;에서 다운 받아 ninja로 빌드하면 좋다. 윈도우에서는 비주얼 스튜디오로도 할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;opt로-스왑-함수의-차이-확인하기&quot;&gt;opt로 스왑 함수의 차이 확인하기&lt;/h3&gt;

&lt;p&gt;준비 과정이 좀 길었다. 먼저, 테스트에 쓸 코드는 기막힌 온라인 컴파일러에서 볼 수 있다: &lt;a href=&quot;https://godbolt.org/g/LA4T1h&quot; target=&quot;_blank&quot;&gt;https://godbolt.org/g/LA4T1h&lt;/a&gt;.
스왑 함수는 템플릿으로 바꿔봤고 테스트 함수에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;temp_swap&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;xor_swap&lt;/code&gt;을 각각 한 번씩 부른다.&lt;/p&gt;

&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
    &lt;a href=&quot;/assets/2016/swap-code.png&quot; title=&quot;&quot; target=&quot;_blank&quot;&gt;
    
    
        &lt;img src=&quot;/assets/2016/swap-code.png&quot; alt=&quot;&quot; /&gt;
    
    &lt;/a&gt;
    
&lt;/div&gt;

&lt;p&gt;글 시작 요약에서 이미 말했지만 위 그림을 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;temp_swap&lt;/code&gt;이던 &lt;code class=&quot;highlighter-rouge&quot;&gt;xor_swap&lt;/code&gt;이던 &lt;code class=&quot;highlighter-rouge&quot;&gt;-O3&lt;/code&gt; 최적화에서는 아무런 차이가 없다. 심지어 스왑 함수 코드는 모두 지워졌다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;-O3&lt;/code&gt; 최적화는 &lt;a href=&quot;https://gist.github.com/minjang/89ee4cd6a040dfda0d7dc23603b3c8c3#file-gistfile1-txt-L20&quot; target=&quot;_blank&quot;&gt;185개의 최적화 패스를&lt;/a&gt; 거친다.
이제 본격적으로 LLVM 도구 &lt;code class=&quot;highlighter-rouge&quot;&gt;opt&lt;/code&gt;를 이용해 도대체 어떤 최적화가 위 같은 코드를 만들어 냈는지 찾아본다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;약간 거짓말을 했다. 최적화에 대한 아무런 사전 지식이 없다면, 185개 최적화를 이진 탐색으로 찾아가며 그 변화를 찾아야 한다. 매우 지루할 것이다. 여기서는 어느 정도 최적화 루틴에 대한 지식을 기초로 바로 찾는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;준비물-최적화-안-된-비트코드-준비하기&quot;&gt;준비물: 최적화 안 된 비트코드 준비하기&lt;/h3&gt;

&lt;p&gt;테스트 코드 &lt;code class=&quot;highlighter-rouge&quot;&gt;swap.cpp&lt;/code&gt;로부터 최적화가 전혀 안 된 비트코드 &lt;code class=&quot;highlighter-rouge&quot;&gt;swap.bc&lt;/code&gt;를 얻어 내자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;
/Users/minjang/code/llvm/build/bin
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./clang++ &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-mllvm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-disable-llvm-optzns&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-emit-llvm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; swap.bc swap.cpp
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./llvm-dis swap.bc&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;그런데 뭔가 이상한 옵션 하나가 보인다: &lt;code class=&quot;highlighter-rouge&quot;&gt;-mllvm -disable-llvm-optzns&lt;/code&gt;. 최적화 옵션을 안 줬으니 최적화 안 된 비트코드가 나와야하겠지만, 프런트 엔드에서 IR 차원의 최적화가 있을 수 있다. 이 괴상한 옵션은 모든 최적화 옵션을 끄도록 한다. 이번 스왑 코드는 간단하므로 이 옵션의 여부에 따라 결과 차이는 없다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;swap.bc&lt;/code&gt;는 바이너리 파일이라 사람이 읽을 수 없으므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;llvm-dis&lt;/code&gt;로 텍스트로 바꾼다. &lt;code class=&quot;highlighter-rouge&quot;&gt;swap.ll&lt;/code&gt;이 생성될 것이고
&lt;a href=&quot;https://gist.github.com/minjang/c971d589ab740dfb4f91db728abd7bf8&quot; target=&quot;_blank&quot;&gt;여기서&lt;/a&gt; 볼 수 있다. 길어서 직접 붙여 넣지는 않았다. 이 글에서 LLVM IR까지는 설명할 수 없지만 대충 직관적으로 이해할 수 있다. 최적화가 전혀 안 되었으므로 로컬 변수들이 모두 &lt;code class=&quot;highlighter-rouge&quot;&gt;alloca&lt;/code&gt;로 메모리 할당 되어있고 접근은 &lt;code class=&quot;highlighter-rouge&quot;&gt;load&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;store&lt;/code&gt;로 이뤄지고 있음을 볼 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;첫-번째-최적화--mem2reg-promote-memory-to-register&quot;&gt;첫 번째 최적화: &lt;code class=&quot;highlighter-rouge&quot;&gt;-mem2reg&lt;/code&gt;: Promote Memory to Register&lt;/h3&gt;

&lt;p&gt;먼저 거추장스러운 메모리 접근을 레지스터로 승급(promotion)하는 최적화인 &lt;a href=&quot;http://llvm.org/docs/Passes.html#mem2reg-promote-memory-to-register&quot; target=&quot;_blank&quot;&gt;mem2reg&lt;/a&gt;를 수행한다. 여기서 말하는 레지스터는 x86/ARM의 제한적인 레지스터가 아니라 LLVM IR의 무한한 가상 레지스터이다. 이렇게 모든 변수를 레지스터에 있다고 가정하는 것이 훨씬 쉽게 최적화 알고리즘을 구현할 수 있다.
mem2reg 최적화를 수행하면 이해하기 쉬운 코드를 얻을 수 있다.&lt;/p&gt;

&lt;p&gt;참고로 과거에는 mem2reg 최적화가 별도로 있었으나 요즘은 &lt;a href=&quot;http://llvm.org/docs/Passes.html#sroa-scalar-replacement-of-aggregates&quot; target=&quot;_blank&quot;&gt;SROA&lt;/a&gt;(Scalar Replacement of Aggregates) 최적화의 일부로 수행된다. &lt;code class=&quot;highlighter-rouge&quot;&gt;-mem2reg&lt;/code&gt; 대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;-sroa&lt;/code&gt; 옵션을 줘도 이 예에서는 같다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./opt swap.bc &lt;span class=&quot;nt&quot;&gt;-mem2reg&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; swap.opt.bc &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; ./llvm-dis swap.opt.bc&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;script src=&quot;https://gist.github.com/minjang/b6874b01eec8da032a2df511d1488e04.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;무엇보다 두 스왑 함수의 임계경로 길이가 다름을 확인할 수 있다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;temp_swap&lt;/code&gt;은 두 레지스터 &lt;code class=&quot;highlighter-rouge&quot;&gt;%0&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;%1&lt;/code&gt;에 RAW 의존성을 가진다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;xor_swap&lt;/code&gt;은 반면에 세 개의 레지스터 &lt;code class=&quot;highlighter-rouge&quot;&gt;%xor&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;%xor1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;%xor2&lt;/code&gt;에 RAW 의존성이 있다.
여기서 라인 15-16, 19-20을 보면 불필요한 중복이 보인다. 값을 저장 후 바로 다시 읽는다. 이 부분을 중복 제거한다면 보다 쉽게 RAW 의존성을 확인할 수 있다.
중복 제거의 대표적인 최적화로 &lt;a href=&quot;http://llvm.org/docs/Passes.html#gvn-global-value-numbering&quot; target=&quot;_blank&quot;&gt;GVN&lt;/a&gt;(Global Value Numbering)이 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;-gvn&lt;/code&gt;을 줘서 그 효과를 살펴볼 수 있다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./opt swap.bc &lt;span class=&quot;nt&quot;&gt;-mem2reg&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-gvn&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; swap.opt.bc &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; ./llvm-dis swap.opt.bc&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;script src=&quot;https://gist.github.com/minjang/4b41864b6081dbeba2dd8f2b37a046ca.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;보다시피 불필요한 &lt;code class=&quot;highlighter-rouge&quot;&gt;store&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;load&lt;/code&gt;를 제거하니 &lt;code class=&quot;highlighter-rouge&quot;&gt;%xor&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;%xor1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;%xor2&lt;/code&gt;의 RAW 의존성이 잘 드러난다.
이렇게 &lt;code class=&quot;highlighter-rouge&quot;&gt;temp_swap&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;xor_swap&lt;/code&gt;의 미시적인 차이를 직접 볼 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;두-번째-최적화--inline-function-integrationinlining&quot;&gt;두 번째 최적화: &lt;code class=&quot;highlighter-rouge&quot;&gt;-inline&lt;/code&gt;: Function Integration/Inlining&lt;/h3&gt;

&lt;p&gt;인라인은 매우 중요한 최적화다. 인라인은 코드 크기를 늘리는 부작용이 있을 수 있지만, 특히 객체 지향이나 JS/루비/파이썬 같은 동적 언어에서 아마도 가장 성능을 극적으로 올리는 최적화일 것이다. 스왑 코드에서도 인라인은 필수다. 인라인을 적용해보자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./opt swap.bc &lt;span class=&quot;nt&quot;&gt;-mem2reg&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-gvn&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-inline&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; swap.opt.bc &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; ./llvm-dis swap.opt.bc&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;script src=&quot;https://gist.github.com/minjang/67dc3a2eb46017ecfd9fcedc429737dd.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;인라인은 정말 함수 내용을 복사해서 붙여 넣기한다. 코드를 찬찬히 살펴보면 레지스터 이름만 밀려졌고 그대로 복사/붙이기가 된 것을 확인할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;세-번째-최적화-또-다시--mem2reg-sroa로-temp_swap-제거하기&quot;&gt;세 번째 최적화: 또 다시 &lt;code class=&quot;highlighter-rouge&quot;&gt;-mem2reg&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;-sroa&lt;/code&gt;로 &lt;code class=&quot;highlighter-rouge&quot;&gt;temp_swap&lt;/code&gt; 제거하기&lt;/h3&gt;

&lt;p&gt;인라인까지 한 결과를 보면 여전히 &lt;code class=&quot;highlighter-rouge&quot;&gt;alloca&lt;/code&gt;와 로드 스토어가 보인다. 한번 더 &lt;code class=&quot;highlighter-rouge&quot;&gt;-mem2reg&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;-sroa&lt;/code&gt;를 적용해보자. 그 결과는 약간 놀랍다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./opt swap.bc &lt;span class=&quot;nt&quot;&gt;-mem2reg&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-inline&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-mem2reg&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; swap.opt.bc &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; ./llvm-dis swap.opt.bc&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;script src=&quot;https://gist.github.com/minjang/e777d7fba3ae113592807acb9506bb42.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;보다시피 메모리 연산을 레지스터로 승급하는 과정에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;temp_swap&lt;/code&gt;은 사라지고 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;가 사용되는 곳을 바로 바꾸었다.&lt;/p&gt;

&lt;h3 id=&quot;마지막-최적화--instcombine-instruction-combine으로-xor_swap-제거하기&quot;&gt;마지막 최적화: &lt;code class=&quot;highlighter-rouge&quot;&gt;-instcombine&lt;/code&gt;: Instruction Combine으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;xor_swap&lt;/code&gt; 제거하기&lt;/h3&gt;

&lt;p&gt;이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;xor_swap&lt;/code&gt;이 어느 최적화로 사라지는지만 알아내면 된다. 정답은 &lt;a href=&quot;http://llvm.org/docs/Passes.html#instcombine-combine-redundant-instructions&quot; target=&quot;_blank&quot;&gt;instruction combine&lt;/a&gt;이라는 최적화다.
말 그대로 컴파일 시간에 같은 결과를 내는 더 간단하고 더 적은 명령어로 바꾸는 최적화이다. 이 최적화의 코드 양은 &lt;a href=&quot;https://github.com/llvm-mirror/llvm/tree/master/lib/Transforms/InstCombine&quot; target=&quot;_blank&quot;&gt;상당히 많고&lt;/a&gt; 여러 번 불린다. 대표적으로 산술 연산의 교환/결합/분배 법칙을 이용해서 최대한 줄인다.
연산의 특성도 이용한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;A ^ 0 = A&lt;/code&gt; 같은 항등식이 한 예이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;xor_swap&lt;/code&gt;의 세 XOR 연산도 이 최적화로 축약이 가능하다. 아래 코드의 주석처럼 차례차례 삭제된다. 디버거로도 이 행동을 정확하게 확인할 수 있다.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/minjang/b4e865dc88e02abe62ad79feff9763cb.js&quot;&gt;&lt;/script&gt;

&lt;!-- _includes/image.html --&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
    
    &lt;a href=&quot;/assets/2016/instcombine.png&quot; title=&quot;&quot; target=&quot;_blank&quot;&gt;
    
    
        &lt;img src=&quot;/assets/2016/instcombine.png&quot; style=&quot;border: 0px;&quot; alt=&quot;&quot; /&gt;
    
    &lt;/a&gt;
    
&lt;/div&gt;

&lt;p&gt;결과적으로 스왑 함수는 모두 사라지고 변수 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;가 최종 사용처에서 필요하다면 직접 바뀐 채로 전달된다. &lt;code class=&quot;highlighter-rouge&quot;&gt;temp_swap&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;xor_swap&lt;/code&gt;, 수백번을 부르던 아무런 상관이 없다. 홀수 번 불려지면 두 변수가 뒤 바뀌어서, 짝수 번 불려지면 그대로 전달된다.
&lt;a href=&quot;https://gist.github.com/minjang/c971d589ab740dfb4f91db728abd7bf8&quot; target=&quot;_blank&quot;&gt;최적화 이전의 코드&lt;/a&gt;와 비교하면 그 차이가 확연하다.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/minjang/35455603b1816123c017433f3dd420f5.js&quot;&gt;&lt;/script&gt;

&lt;!-- https://www.facebook.com/megayuchi/posts/1032566216775123
https://megayuchi.wordpress.com/2015/09/10/xor%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%B6%84%EA%B8%B0-%EC%97%86%EC%9D%B4-%EB%91%90-%EB%B3%80%EC%88%98%EC%9D%98-%EA%B0%92-%EA%B5%90%ED%99%98%ED%95%98%EA%B8%B0/

https://megayuchi.wordpress.com/2015/09/10/%EB%B3%80%EC%88%98%EC%9D%98-%EA%B0%92%EC%9E%84%EC%8B%9C%EB%B3%80%EC%88%98xor-%EA%B5%90%ED%99%98%EC%9D%84-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%B2%98%EB%A6%AC/ --&gt;

&lt;h3 id=&quot;추가-실험&quot;&gt;&lt;a name=&quot;followup&quot;&gt;&lt;/a&gt;추가 실험&lt;/h3&gt;

&lt;p&gt;김우승님께서 &lt;a href=&quot;http://minjang.github.io/2016/11/28/xor-temp-swap/#comment-3069886046&quot;&gt;댓글에서&lt;/a&gt; 알려주셨습니다. 앞선 실험들은 스왑된 변수 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;가 모두 값으로만 사용되어 레지스터로 승급된 경우를 가정했습니다. 하지만 이 변수가 참조 혹은 포인터로 사용되거나, 레지스터가 부족해 레지스터 승급이 안 될 때는 이 변수를 명시적으로 메모리에 할당해야 합니다. 예를 들어, 이 변수를 사용하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;process&lt;/code&gt;가 &lt;code class=&quot;highlighter-rouge&quot;&gt;process(int&amp;amp;, int&amp;amp;)&lt;/code&gt;로 되면 컴파일러에 따라 &lt;code class=&quot;highlighter-rouge&quot;&gt;xor_swap&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;temp_swap&lt;/code&gt;의 차이가 발생할 수 있음을 확인했습니다. 변수 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;를 완전히 레지스터로 승급하지 못하고 명시적으로 스택 메모리에 할당해야하므로 이 과정에서 컴파일러마다 꽤 다른 결과를 낼 수 있습니다. 확인한 결과는 이러합니다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;clang의 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;xor_swap&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;temp_swap&lt;/code&gt; 방식 모두 차이는 없었습니다만, 짝수번 불리었을 때와 스왑이 한번도 안 불렸을 때는 차이가 있었습니다: &lt;a href=&quot;https://godbolt.org/g/kAJZ1t&quot;&gt;https://godbolt.org/g/kAJZ1t&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;gcc 7.0 미만인 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;xor_swap&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;temp_swap&lt;/code&gt;에 따라 차이가 발생합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;temp_swap&lt;/code&gt; 방식이 훨씬 최적화가 잘 되고 &lt;code class=&quot;highlighter-rouge&quot;&gt;xor_swap&lt;/code&gt;은 XOR 연산을 남기기도 합니다: &lt;a href=&quot;https://godbolt.org/g/GW2uNX&quot;&gt;https://godbolt.org/g/GW2uNX&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;하지만 gcc 7.0은 가장 뛰어난 결과를 이 실험에서 보여줍니다. XOR/임시 변수 방식이던 상관이 없고, 스왑을 짝수번 하면 스왑을 전혀하지 않는 코드와 같은 결과를 냅니다: &lt;a href=&quot;https://godbolt.org/g/vaPn2I&quot;&gt;https://godbolt.org/g/vaPn2I&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;gcc 7.0 이전에서는 스왑된 변수가 메모리에 명시적으로 할당이 되어야 한다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;xor_swap&lt;/code&gt;이 보다 비효율적임을 보았습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;temp_swap&lt;/code&gt;이 최적화 기회를 더 얻을 수 있는 안전한 방법이라고 할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;결론-수정됨&quot;&gt;결론 (수정됨)&lt;/h3&gt;

&lt;p&gt;XOR 스왑 함수와 임시 변수 스왑 함수는 적어도 정적 컴파일 언어 언어에서는 &lt;strong&gt;인라인만 된다면&lt;/strong&gt; 차이가 &lt;em&gt;거의&lt;/em&gt; 없음을 보았다. 인라인 여부가 훨씬 중요하다. 이런 이유로 C++ 템플릿 기반의 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::swap&lt;/code&gt;이나 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::sort&lt;/code&gt; 같은 함수가 순수 C 함수 코드보다 더 많은 최적화 기회를 얻을 수 있다. &lt;em&gt;한편, 스왑된 변수가 메모리 할당이 반드시 필요하다면 컴파일러에 따라 XOR/임시 변수 방법에 차이가 있음을 보았고 일반적으로 임시 변수 방법이 더 낫다고 말 할 수 있다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이 글에서는 또한 LLVM 도구 사용법과 여러 컴파일러 최적화도 살펴보았다. 요즘 같이 컴퓨터 하나의 성능이 그다지 중요하지 않게된 세상에서는 너무 깊숙한 내용일 수도 있겠지만 관심있는 분에게 도움이 되었으면 좋겠다.&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:term&quot;&gt;
      &lt;p&gt;더 이상 놀랍지는 않지만 “변수 값”은 현재 맞춤법에 맞지 않다. “변숫값”으로 써야 한다. 나는 이 멍청한 사이시옷 맞춤법 개정에 항거하는 의미로 “변수 값”으로 쓴다. &lt;a href=&quot;#fnref:term&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:ld&quot;&gt;
      &lt;p&gt;링커 &lt;code class=&quot;highlighter-rouge&quot;&gt;ld&lt;/code&gt;를 별도로 실행한다면 옵션을 잘 줘야 링커 에러를 막을 수 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;clang -v hello.c&lt;/code&gt;의 출력을 살펴보면 된다. &lt;a href=&quot;#fnref:ld&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
				<pubDate>Mon, 28 Nov 2016 00:00:00 +0000</pubDate>
				<link>http://minjang.github.io/2016/11/28/xor-temp-swap/</link>
				<guid isPermaLink="true">http://minjang.github.io/2016/11/28/xor-temp-swap/</guid>
			</item>
		
			<item>
				<title>사소해 보이는 연산 뒤에 숨어있는 것</title>
				        
        <description>&lt;p&gt;이 글은 대학원 시절, 대략 2010년 정도에 인턴 전화 면접을 하면서 겪은 인상 깊었던 일에 관한 것이다. 요즘은 기가 막힌 온라인 코딩 테스팅 서비스가 여럿 있지만, 당시는 그냥 구글 닥스 같은 곳에서 구문 강조도 없이 코딩했다. 그 전화 면접에서 받았던 문제는 이러했다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“이진 탐색 트리(BST, binary search tree)에서 중위(in-order) 순회를 하는 반복자(iterator)를 구현하고 싶어요. 반복자를 만드는데 필요한 &lt;code class=&quot;highlighter-rouge&quot;&gt;begin&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt; 함수를 만들어 보세요.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;학부 알고리즘 수업을 들은 지 얼마 안 된 분이라면 금방 풀 수도 있다. 그런데 시간이 좀 지났다면 직접 트리 그려가면서 알고리즘을 찾아야 한다. 긴장하면 삽질하기 쉬운 문제이기도 하다.&lt;/p&gt;

&lt;p&gt;이진 탐색 트리에서 중위 순회는 트리에 담긴 값을 정렬된 순서로 탐색하는 것과 같다.
결국, &lt;code class=&quot;highlighter-rouge&quot;&gt;begin&lt;/code&gt; 함수는 트리의 최솟값&lt;sup id=&quot;fnref:term&quot;&gt;&lt;a href=&quot;#fn:term&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;을 찾는 것이며, &lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt;는 주어진 노드의 바로 다음 노드를 찾는 것이다.
최솟값은 트리의 제일 왼쪽 끝에 있으므로 간단하게 구현된다. 그런데 &lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt;처럼 주어진 노드의 다음 노드(successor)를 찾는 건 경우의 수를 따져야 한다. CLRS 알고리즘 책에 있는 트리 그림(Figure 12.2)으로 생각해보자.&lt;/p&gt;

&lt;div class=&quot;image-wrapper&quot;&gt;
&lt;center&gt;
  &lt;img border=&quot;1&quot; src=&quot;/assets/2016/bst-example-1.png&quot; width=&quot;311&quot; height=&quot;210&quot; alt=&quot;&quot; /&gt;
&lt;/center&gt;
&lt;/div&gt;

&lt;p&gt;주어진 노드가 루트인 15라고 하자. 15의 다음 노드는 17인데, 가만히 보면 오른쪽 자식 서브 트리의 최솟값임을 확인할 수 있다. 즉, 만약 주어진 노드에 오른쪽 자식이 있으면, 오른쪽 서브 트리의 최솟값을 구하면 된다. 간단하다.&lt;/p&gt;

&lt;p&gt;이제 오른쪽 자식이 없는 경우를 생각하자. 실수를 막으려면 약간 복잡한 트리를 놓고 추론해야 한다. 위 그림에서 노드 13을 보자. 13의 다음 노드는 15이다. 어떻게 15까지 찾아갈 수 있을까? 각 노드에 부모 정보가 없다면 더 어려운 문제가 되는데 부모 포인터는 있다고 생각하자. 나는 이렇게 답했다. (뒤에서 곧 밝혀지겠지만 여기에 사소한 실수가 있었다.)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“부모를 루트까지 쭉 타고 올라가면서 자신의 값보다 작지 않은 첫 번째 부모를 선택하면 되겠네요.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;맞는 것 같아서 이렇게 코드를 만들었다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;findMinimum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;요즘은 직접 온라인 컴파일러까지 되므로 바로 테스트 케이스도 돌려볼 수 있지만, 당시는 한 줄씩 검산했었다. 인터뷰어가 잘했다고 말하면서 하나를 지적했다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“틀린 것은 아닌데, 하나 고쳐야 할 부분이 있어요. 보이나요?”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;center&gt;. . . . .&lt;/center&gt;
&lt;center&gt;&lt;i&gt;혹시 이 글을 읽는 분들도 위 코드에서 고쳐야 할 부분을 찾아보세요.&lt;/i&gt;&lt;/center&gt;
&lt;center&gt;. . . . .&lt;/center&gt;
&lt;p /&gt;

&lt;p&gt;내가 좀 당황하자 인터뷰어가 위치를 가르쳐줬다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“부모의 값과 비교할 때 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자가 있죠? (라인 7) 무슨 문제가 있을까요?”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그제야 무얼 말하는지 알았다.&lt;/p&gt;

&lt;p&gt;지금 예에서는 노드 값 타입이 정수이므로 비교 연산이 CPU에서 가장 빠른 연산 중 하나이다. 그런데 만약 노드 값이 아주 복잡하고 큰 자료라서 비교 연산에 시간이 오래 걸린다면? 얼마든지 있을 수 있는 일이다. 
트리에 노드를 추가/삭제할 때는 반드시 이 비교 연산을 해야 한다. 하지만 단순히 순회하는데 시간이 오래 걸릴 수 있는 비교 연산을 수행하는 것은 옳지 않다. 다행히 답을 할 수 있었다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“그렇다면 어떻게 고치면 될까요?”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;잘 안 보여서 다시 약간의 삽질 끝에 드디어 답을 찾아냈다. 값을 비교하는 것이 아니라 내가 부모의 왼쪽 또는 오른쪽 자식인지 확인하면 되는 것이다. 이건 단순히 노드 포인터 - 포인터가 없는 언어라도 - 비교에 지나지 않으므로 32비트 혹은 64비트 정수 비교 연산과 같다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;findMinimum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//                       ~~~~~~~~~~~~~~~~~~~~~
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;뒤늦게 CLSR 교과서에 소개된 알고리즘을 봐도 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 연산이 아닌 오른쪽 자식이냐로 판별하고 있다. LLVM C++ 라이브러리인 libc++의 &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/master/include/__tree#L159&quot;&gt;구현을 봐도 그러하다&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&quot;image-wrapper&quot;&gt;
&lt;center&gt;
  &lt;img border=&quot;1&quot; src=&quot;/assets/2016/tree-succesor.png&quot; width=&quot;294&quot; height=&quot;171&quot; alt=&quot;&quot; /&gt;
&lt;/center&gt;
&lt;/div&gt;

&lt;p&gt;사소해 보이는 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 연산에 큰 대가가 숨어있을 수 있음을 깨닫게 해준 아주 기억에 남는 인터뷰였다. (음, 연산자 오버로딩을 탓할 수도 있겠다.) 이 이야기는 저수준에서 코드를 다뤄야 하는 C/C++ 프로그래머에게만 적용되는 이야기는 아니다. 파이썬이던 자바스크립트이던 프로그래머는 시간만 허락한다면 효율적인 코드를 만들어야 한다.&lt;/p&gt;

&lt;p&gt;그때 교훈으로 지금도 내가 숨어있는 것도 볼 수 있는 프로그래머인지 반문한다.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:term&quot;&gt;
      &lt;p&gt;오타가 아니다. ‘최소값’이 아니라 사이 시옷을 넣어 ‘최솟값’으로 써야 한다. &lt;a href=&quot;https://twitter.com/urimal365/status/258475514321313792&quot;&gt;정말이다&lt;/a&gt;. &lt;a href=&quot;#fnref:term&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
				<pubDate>Tue, 03 May 2016 00:00:00 +0000</pubDate>
				<link>http://minjang.github.io/2016/05/03/finding-subtle-mistake/</link>
				<guid isPermaLink="true">http://minjang.github.io/2016/05/03/finding-subtle-mistake/</guid>
			</item>
		
			<item>
				<title>C++로 함수형 언어 Scala 흉내 내기</title>
				        
        <description>&lt;p&gt;다음 문제를 생각해보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“주어진 문자열을 받아 알파벳 빈도 테이블을 만들어 반환하세요.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;hello&quot;&lt;/code&gt;가 주어졌다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;[['h', 1], ['e', 1],  ['o', 1], ['l', 2]]&lt;/code&gt;를 돌려주면 된다. 편의상 문자열은 소문자만 있다고 하고 테이블은 특별히 정렬될 필요가 없다고 하자. 쉬운 수준의 코딩 인터뷰 문제이기도 하다. 이번 포스팅에서는 이 문제를 함수형 언어인 Scala (스칼라)로 먼저 풀어보고 이걸 C++14를 이용해서 옮겨 보자고 한다.&lt;/p&gt;

&lt;h3 id=&quot;명령형-언어로-생각하기&quot;&gt;명령형 언어로 생각하기&lt;/h3&gt;

&lt;p&gt;바로 함수형 언어로 생각하면 머리가 아프니 지극히 명령형(imperative) 언어로 생각해보자. 편의상 C++로 써보았다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wordOccurrences&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;사실 무척 간단하다. 해시 테이블 하나면 된다.
혹시 라인 4에서 알파벳 &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;가 테이블 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;에 없으면 어떡하느냐고 물을 수 있다.
C++의 &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;(보통 이진 탐색 트리로 구현)이나 &lt;code class=&quot;highlighter-rouge&quot;&gt;unordered_map&lt;/code&gt;(일반적인 해시 테이블)에서 주어진 키가 없으면, 값 타입(여기서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;)의 기본 생성자가 불러 (키, 값) 쌍을 넣는다.
정의되지 않은 쓰레기 값으로 초기화 되는 것도 아니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;int x;&lt;/code&gt;는 그러하지만 이 경우는 &lt;code class=&quot;highlighter-rouge&quot;&gt;int x = int();&lt;/code&gt;처럼 불리므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;가 처음으로 발견되었다면 안전하게 값은 0으로 초기화된다. 관련 스택오버플로우 &lt;a href=&quot;http://stackoverflow.com/questions/2667355/mapint-int-default-values&quot;&gt;문답도 찾아볼 수 있다&lt;/a&gt;.
어쨌든 아주 직관적인 코드이다.&lt;/p&gt;

&lt;h3 id=&quot;함수형-언어로-생각하기&quot;&gt;함수형 언어로 생각하기&lt;/h3&gt;

&lt;p&gt;이번에는 함수형 언어인 스칼라, Scala로 작성해보자.&lt;/p&gt;

&lt;p&gt;사실 이 문제는 Coursera의 “&lt;a href=&quot;https://www.coursera.org/course/progfun&quot;&gt;Functional Programming Principles in Scala&lt;/a&gt;” 강좌에서 제공되는 숙제에서 힌트를 얻었다. 
숙제 자체는 이보다 훨씬 복잡한 애너그램(&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%96%B4%EA%B5%AC%EC%A0%84%EC%B2%A0&quot;&gt;anagram&lt;/a&gt;)과 관련된 문제이고, 지금 푸는 빈도 테이블은 그중 작은 문제에 지나지 않는다.
이 문제를 C++로 최대한 스칼라와 비슷하게 만들어 보았는데, 그 과정을 다 적기에는 너무 벅차니까 간단한 예 하나만 이 글에서 다룬다.
참고로 이 수업은 강력 추천한다. 함수형 언어에 대해 잘 이해할 수 있고, 무엇보다 숙제 문제가 너무 좋다. 재귀적으로 생각하는 힘을 기를 수 있는 유익한 수업이다.&lt;/p&gt;

&lt;p&gt;스칼라 문법을 몰라도 겁먹을 필요 없다. 나도 이 수업을 거의 3년 전에 들어서 솔직히 지금 스칼라 문법은 잘 모른다. 스칼라에서도 지극히 명령형으로 이 문제를 기술할 수 있지만, 함수형 언어의 철학에 따라 불변형 자료 구조와 고차원 함수 연산으로 풀어보자.&lt;/p&gt;

&lt;p&gt;썰렁하지만 스칼라에서는 한 줄로 된다. REPL에서 실행해봤다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;n&quot;&gt;scala&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;groupBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;res0&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;scala.collection.immutable.Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Char&lt;/span&gt;,&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이 무슨 흑마법 같은 코드인가 싶은데 하나하나 뜯어 보자. &lt;code class=&quot;highlighter-rouge&quot;&gt;groupBy&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt; 함수만 이해하면 된다.&lt;/p&gt;

&lt;h4 id=&quot;스칼라의-groupby-메서드&quot;&gt;스칼라의 groupBy 메서드&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;groupBy&lt;/code&gt; 메서드 벡터나 리스트의 원소들을 주어진 분류 조건으로 그룹핑 한다.&lt;sup id=&quot;fnref:python&quot;&gt;&lt;a href=&quot;#fn:python&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, 임의의 숫자가 담겨있는 리스트가 있고, 짝수와 홀수로 구분하고 싶다고 하자. &lt;code class=&quot;highlighter-rouge&quot;&gt;groupBy&lt;/code&gt;는 “주어진 숫자를 짝수 또는 홀수로 구분하는 &lt;i&gt;함수&lt;/i&gt;“를 입력 인자로 받는다. 이 함수를 &lt;code class=&quot;highlighter-rouge&quot;&gt;groupBy&lt;/code&gt;의 구별 함수(discriminator function)라고 칭한다. 이제 모든 리스트 원소에 대해 이 구별 함수를 실행해서 그 결과 값(짝수 또는 홀수)에 따라 원소들을 분류한다.&lt;/p&gt;

&lt;p&gt;코드를 써보면 이러하다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;n&quot;&gt;scala&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;groupBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//                                 ~~~~~~~~~~~~~~~
//                           주어진 e에 대해 짝/홀수 판단
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res0&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;scala.collection.immutable.Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Boolean&lt;/span&gt;,&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;1부터 5까지 숫자 리스트가 있다.
짝/홀수로 구분하는 함수는 익명 함수, 즉 람다로 주어지는데, 자세한 스칼라 문법을 몰라도 꽤나 직관적이다.
이 익명 함수는 인자 &lt;code class=&quot;highlighter-rouge&quot;&gt;e&lt;/code&gt;를 받아 짝수면 &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;를 반환한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;groupBy&lt;/code&gt;는 이 함수를 모든 원소에 대해 수행한다. 짝/홀수 결과 값은 &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;인 &lt;code class=&quot;highlighter-rouge&quot;&gt;Boolean&lt;/code&gt;이 되고, 여기에 속하는 값들은 숫자 리스트, &lt;code class=&quot;highlighter-rouge&quot;&gt;List[Int]&lt;/code&gt;가 된다.
결과 값, &lt;code class=&quot;highlighter-rouge&quot;&gt;(false -&amp;gt; List(1, 3, 5), true -&amp;gt; List(2, 4))&lt;/code&gt;이 자연스럽게 이해갈 것이다.
타입은 불변형 맵(immutable.Map)이고 키는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Boolean&lt;/code&gt;, 값은 &lt;code class=&quot;highlighter-rouge&quot;&gt;List[Int]&lt;/code&gt; 꼴이다. 
참고로 C++은 지네릭(generic) 타입을 &lt;code class=&quot;highlighter-rouge&quot;&gt;list&amp;lt;int&amp;gt;&lt;/code&gt;같이 쓰는데, 스칼라는 &lt;code class=&quot;highlighter-rouge&quot;&gt;List[Int]&lt;/code&gt;로 쓴다. 배열 원소 접근과 같아 다소 혼란스럽기는 하다.&lt;/p&gt;

&lt;p&gt;짝수/홀수를 문자열로 바꾸어서 처리하면 보기 좋다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;n&quot;&gt;scala&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;groupBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Even&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Odd&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;res0&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;scala.collection.immutable.Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;java.lang.String&lt;/span&gt;,&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Even&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Odd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;자, 다시 원래 문제로 돌아가면, 주어진 문자열을 알파벳으로 구분하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;groupBy&lt;/code&gt;의 구별 함수는 항등 함수(identify function)로 주어져있다: &lt;code class=&quot;highlighter-rouge&quot;&gt;e =&amp;gt; e&lt;/code&gt;. 좀 헷갈린다. 그런데 생각해보면, 지금 하고자 하는 일이 “알파벳 별로 구분”하는 것이므로 그냥 주어진 알파벳을 그대로 그룹핑하는 기준 키로 쓰면 된다.&lt;/p&gt;

&lt;p&gt;이제 아래 코드가 이해된다. 각 알파벳이 키가 되고 발견될 때 마다 각 리스트에 추가한다. 알파벳 리스트는 스칼라에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;과 같다. &lt;code class=&quot;highlighter-rouge&quot;&gt;l&lt;/code&gt;은 두 번 발견되었으므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;ll&lt;/code&gt;이 된다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;n&quot;&gt;scala&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;groupBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;res0&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;scala.collection.immutable.Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Char&lt;/span&gt;,&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이제 알파벳 키 마다 있는 스트링을 그 길이로 바꿔주면, 출현한 알파벳의 빈도를 얻게 된다. &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;로도 할 수 있지만, 함수형 언어에서는 보다 우아한 방법을 써야 한다.&lt;/p&gt;

&lt;h4 id=&quot;스칼라의-map-메서드&quot;&gt;스칼라의 map 메서드&lt;/h4&gt;

&lt;p&gt;Map, 우리말로 사상은 말 그대로 함수의 개념을 추상화한 것이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;를 받아서 &lt;code class=&quot;highlighter-rouge&quot;&gt;f(a)&lt;/code&gt;로 바꿔주는 셈이다. 역시 &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;도 익명 함수를 인자로 받는다. 주어진 원소를 받아 새로운 원소로 변환하는 일을 한다. 이 작업을 열거형 자료구조의 모든 원소에 대해 수행한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;n&quot;&gt;scala&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;groupBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//                                 ~~~~~~~~~~~~~~~~~~~~~~~~
//                                p(쌍)에 대해 새로운 쌍을 만들어 반환  
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res0&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;scala.collection.immutable.Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Char&lt;/span&gt;,&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;에 주어진 익명 함수를 보자. &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt;는 앞서 &lt;code class=&quot;highlighter-rouge&quot;&gt;groupBy&lt;/code&gt;의 결과인 &lt;code class=&quot;highlighter-rouge&quot;&gt;Map[Char/*키*/,String/*값*/]&lt;/code&gt;의 원소에 해당한다. 각 원소는 (키, 값) 형태의 쌍 혹은 튜플로 주어진다. &lt;code class=&quot;highlighter-rouge&quot;&gt;p._1&lt;/code&gt;는 키인 &lt;code class=&quot;highlighter-rouge&quot;&gt;Char&lt;/code&gt;에 해당하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;p._2&lt;/code&gt;는 값인 &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;에 대응된다. 알파벳 키는 그대로 가져가되 스트링을 이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;length&lt;/code&gt; 메서드로 길이로 바꾸면 된다.
비로소 얻고자 하는 최종 결과 값, &lt;code class=&quot;highlighter-rouge&quot;&gt;Map(h -&amp;gt; 1, e -&amp;gt; 1, o -&amp;gt; 1, l -&amp;gt; 2)&lt;/code&gt;을 얻을 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;c로-비슷하게-할-수-있을까&quot;&gt;C++로 비슷하게 할 수 있을까?&lt;/h3&gt;

&lt;p&gt;C++11부터 도입된 람다, 가변 인수 템플릿, &lt;code class=&quot;highlighter-rouge&quot;&gt;std::shared_ptr&lt;/code&gt;등을 잘 쓰면 상당히 함수형스럽게 코딩할 수 있다. 별로 놀랍지 않다. 이미 예전부터 STL의 구조가 상당히 함수적이기 때문이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;groupBy&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;에 해당하는 C++ 함수를 만들면 스칼라와 비슷하게 코드를 만들 수 있을 것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;일러두기: 저는 템플릿 메타 프로그래밍 전문가도 아니고, 최신 C++ 문법도 실제 현업에서는 거의 쓰지 안/못합니다. 순전히 취미 수준으로 약간 하는 것이므로 이 코드의 품질은 전혀 보증하지 아니합니다. 보다 좋은 해법이 있으면 언제든지 환영합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;c로-groupby-모사하기&quot;&gt;C++로 groupBy 모사하기&lt;/h4&gt;

&lt;p&gt;사실 스칼라의 &lt;code class=&quot;highlighter-rouge&quot;&gt;groupBy&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;이나 &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;의 메서드로 있다. 여기서는 그냥 전역 함수로 만들고, 임의의 컨테이너 &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;를 받도록 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;groupBy&lt;/code&gt;는 앞서 설명한 구별 함수인 익명 함수 하나를 받는다. 구별 함수의 인자는 컨테이너의 원소 타입이어야 하고, 반환 타입은 사용자 마음이다. 최종적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::map&lt;/code&gt;을 만들어서 돌려주면 될 것이다.&lt;sup id=&quot;fnref:dig&quot;&gt;&lt;a href=&quot;#fn:dig&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// groupBy[K](f: (A) ⇒ K): Map[K, List[A]]
// 컨테이터 C의 모든 원소에 대해 f를 실행 후, 그 결과를 map으로 저장 및 반환
// C++14 이상 필요
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*Container*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*Discriminator*/&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;groupBy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element_t&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decay_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discriminator_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)));&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;discriminator_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emplace_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;핵심은 익명 함수 &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;와 컨테이너 변수 &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;로부터 필요한 두 타입을 추출하는 것이다.&lt;/p&gt;

&lt;p&gt;먼저, 컨테이너의 원소 타입, &lt;code class=&quot;highlighter-rouge&quot;&gt;element_t&lt;/code&gt;를 얻어 낸다. 라인 7에 나와있는데, &lt;code class=&quot;highlighter-rouge&quot;&gt;decltype&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::data&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;std::begin&lt;/code&gt;을 써서 원소 타입을 얻어내는 것은 &lt;a href=&quot;/2016/01/07/python-enumerate-modern-c++/&quot;&gt;이전 포스팅&lt;/a&gt;에서 자세히 설명했다.&lt;/p&gt;

&lt;p&gt;여기서 새롭게 보는 것은 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::decay_t&lt;/code&gt;이다.&lt;sup id=&quot;fnref:decay&quot;&gt;&lt;a href=&quot;#fn:decay&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; 이것은 주어진 타입에서 참조자 기호가 있다면 먼저 모두 제거한다. 그 뒤 타입의 성격에 따라 배열은 포인터로, 함수는 함수 포인터로, 일반 타입은 cv 한정자를 없앤다. 보다 다루기 쉽도록 타입을 약화한다.
왜 &lt;code class=&quot;highlighter-rouge&quot;&gt;decay&lt;/code&gt;가 필요하냐면, 원소 타입에 참조자가 있을 수 있기 때문이다. 최종적으로 돌려주는 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::map&lt;/code&gt;의 값 타입은 &lt;code class=&quot;highlighter-rouge&quot;&gt;vector&amp;lt;element_t&amp;gt;&lt;/code&gt;로 해야 한다. 그런데 &lt;code class=&quot;highlighter-rouge&quot;&gt;element_t&lt;/code&gt;가 참조자면 컴파일부터 제대로 안 된다.&lt;/p&gt;

&lt;p&gt;라인 8에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;groupBy&lt;/code&gt;의 구분 기준이 되는 타입을 &lt;code class=&quot;highlighter-rouge&quot;&gt;discriminator_t&lt;/code&gt;로 이름 지었다. 이 타입은 익명 구별 함수의 반환형과 같으므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;decltype&lt;/code&gt;으로 간단하게 얻을 수 있다.&lt;/p&gt;

&lt;p&gt;라인 9는 이제 이 두 타입으로 최종 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::map&lt;/code&gt;을 선언한다. 나머지 코드는 굉장히 간단하다. 범위 기반 for 루프로 컨테이너의 모든 원소 &lt;code class=&quot;highlighter-rouge&quot;&gt;e&lt;/code&gt;에 대해, 구별 함수 &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;를 호출해 그 결과 값이 테이블의 키 값이 된다. 10줄도 안 되는 코드로 그럴듯하게 스칼라의 &lt;code class=&quot;highlighter-rouge&quot;&gt;groupBy&lt;/code&gt; 함수를 흉내 냈다.&lt;sup id=&quot;fnref:check&quot;&gt;&lt;a href=&quot;#fn:check&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;이제 스칼라로 했던 숫자 리스트의 짝/홀수로 구분을 C++로 해보자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// val g = List(1, 2, 3, 4, 5).groupBy(
//   e =&amp;gt; if (e % 2 == 0) &quot;Even&quot; else &quot;Odd&quot;)
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;groupBy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[](&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Even&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Odd&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;// vector/pair에 대한 ostream &amp;lt;&amp;lt; 출력을 오버라이딩 했다고 가정
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;pre&gt;
# 출력 결과
&amp;lt;Even, {2, 4}&amp;gt;
&amp;lt;Odd, {1, 3, 5}&amp;gt;
&lt;/pre&gt;

&lt;p&gt;보다시피 스칼라 코드와 굉장히 흡사하다. C++14 덕분에 익명 함수 인자 &lt;code class=&quot;highlighter-rouge&quot;&gt;e&lt;/code&gt;의 타입을 지정하지 않고 &lt;code class=&quot;highlighter-rouge&quot;&gt;auto&lt;/code&gt;로 해도 된다. 표현은 당연히 스칼라보다 군더더기가 많다. 그래도 거의 1:1 수준으로 스칼라 코드와 대응이 된다.&lt;/p&gt;

&lt;p&gt;참고로 벡터나 pair 타입 출력을 편히 하고자 아래처럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&lt;/code&gt; 연산자를 오버라이딩했다. 코드는 스택오버플로우에서 가져 온 것을 약간 손본 것이다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// 벡터 타입을 cout &amp;lt;&amp;lt; 로 출력
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Ch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Tr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;basic_ostream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;basic_ostream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;{&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;, &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// pair 타입 출력
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Ch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Tr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;basic_ostream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pair&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;basic_ostream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;, &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;c로-map-따라하기&quot;&gt;C++로 map 따라하기&lt;/h4&gt;

&lt;p&gt;스칼라 &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt; 함수도 비슷한 원리로 만들면 된다. 연관 컨테이너 원소 타입은 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::pair&lt;/code&gt;이니까 이걸 받아 새로운 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::pair&lt;/code&gt;을 돌려주는 익명 함수가 필요하다. 코드는 역시 다음처럼 간단하다. 11줄 밖에 안된다!&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// def map[B](f: (A) ⇒ B): Map[B]
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*Associative container*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*map*/&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_key_t&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_value_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_key_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_value_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mapped&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mapped&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mapped&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이제 마지막으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;groupBy&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;을 동시에 써서 문제를 풀어보자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// val f = &quot;hello&quot;.groupBy(e =&amp;gt; e).map(p =&amp;gt; (p._1, p._2.length))
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;groupBy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[](&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}),&lt;/span&gt;
              &lt;span class=&quot;p&quot;&gt;[](&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;pre&gt;
# 출력 결과
&amp;lt;e, 1&amp;gt;
&amp;lt;h, 1&amp;gt;
&amp;lt;l, 2&amp;gt;
&amp;lt;o, 1&amp;gt;
&lt;/pre&gt;

&lt;p&gt;C++ 특성상 &lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt;이나 &lt;code class=&quot;highlighter-rouge&quot;&gt;pair&lt;/code&gt;를 만드는 과정이 덜 간결하지만, 이 정도면 사실상 스칼라 코드와 완전히 일대일 대응된다고 해도 틀린 말이 아니다.
참고로 &lt;code class=&quot;highlighter-rouge&quot;&gt;fun::map&lt;/code&gt;을 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::pair&lt;/code&gt;가 아닌 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::tuple&lt;/code&gt;로도 일반화할 수 있다.
C++이 보다 함수형 언어처럼 간결하게 하려면 다음과 같은 기능 추가가 있으면 어떨까 생각한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;간단한 순수한 람다 함수 표현: 함수형 언어에서 대부분의 람다는 C++ 람다의 캡쳐 리스트가 필요 없는 순수한 람다이다. C++에서도 캡쳐리스트(&lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt;)가 없는 간단한 표기법이 도입되면 좋을 것이다. 더 나가 &lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt; 마저 없이 스칼라처럼 람다 함수 몸통이 수식 하나로 구성되는 문법도 가능은 하다. 함수 인자의 &lt;code class=&quot;highlighter-rouge&quot;&gt;auto&lt;/code&gt;도 생략하면 좋을 것이다.&lt;/li&gt;
  &lt;li&gt;간결한 튜플 문법: 이번 예는 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::pair&lt;/code&gt;를 써서 그나마 괜찮은데 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::tuple&lt;/code&gt;은 너무 거추장스럽다. 튜플의 원소 접근도 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::get&amp;lt;1&amp;gt;(t)&lt;/code&gt; 같이 솔직히 아주 못 생겼다. 튜플을 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt; 수준으로 격상하면 좋다는 생각도 든다. 초기화 리스트에 이종 타입도 지원되면 역시 좋을 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;결론&quot;&gt;결론&lt;/h3&gt;

&lt;p&gt;나는 함수형 언어 전문가가 아니다. Monad가 뭔지 아직 잘 모른다. 그래도 함수형 언어에 보다 쉽게 접근하려면 익명 함수가 뭔지만 잘 알아도 된다. 보다시피 C++로도 그럴듯하게 스칼라의 함수형 작업을 흉내낼 수 있었다.
C++17 혹은 그 이후에 추가되는 기능으로 분명히 더 함수형 언어같은 코딩을 할 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;혹시나 함수형 언어에 대해 겁먹고 있는 분이라면, 아마도 해스켈 보다 배우기 수월한 스칼라를 권장한다. 이미 소개했지만 Coursera의 아래 두 강좌를 강력히 추천한다. “함수형 언어” 그러면 복잡한 람다 대수, &lt;a href=&quot;https://xkcd.com/297/&quot;&gt;괄호 지옥&lt;/a&gt;, 모나드만 떠올렸는데 이 수업으로 훨씬 친근해졌다. 아울러 요즘 유행하는 Rx도 배울 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.coursera.org/course/progfun&quot;&gt;Functional Programming Principles in Scala&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.coursera.org/course/reactive&quot;&gt;Principles of Reactive Programming&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;“그런데 그냥 맨 처음에 썼던 명령형식의 C++ 코드가 다 쉽고 더 빠르지 않을까요?”&lt;br /&gt; “그러게요. 왼쪽 뺨에 붙어있는 밥풀을 오른손으로 머리 뒤로 감아 떼는 격 같긴 하죠.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:python&quot;&gt;
      &lt;p&gt;파이썬의 &lt;code class=&quot;highlighter-rouge&quot;&gt;itertools.groupby&lt;/code&gt;와는 그 의미가 다르니 주의해야 한다. &lt;a href=&quot;#fnref:python&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:dig&quot;&gt;
      &lt;p&gt;바로 이 코드에 도달한 것은 아니고 처음에는 여러 삽질을 하였다. 처음에는 익명 함수를 &lt;code class=&quot;highlighter-rouge&quot;&gt;K (*f)(A)&lt;/code&gt;와 같이 함수 포인터로 받으려고 했었다. 되기는 되는데 람다를 함수 포인터로 인식 시키는데 &lt;a href=&quot;http://stackoverflow.com/questions/18889028/a-positive-lambda-what-sorcery-is-this/18889029#18889029&quot;&gt;흑마법&lt;/a&gt;이 필요하고, 사용할 때도 익명 함수의 타입을 정해줘야 하는 큰 불편한 점이 있었다. &lt;a href=&quot;#fnref:dig&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:decay&quot;&gt;
      &lt;p&gt;Decay의 일반적인 영어 뜻은 썩다/붕괴 같은 뜻으로 쓰이는데, 이 문맥에서는 타입을 “약하게 한다”는 뜻으로 받아들이면 좋다. 원래 타입은 더 많은 정보, 특히 배열 같은 건 배열 크기(extent), cv 한정자 정보가 있었지만, decay된, 다시 말해, 약해진 타입은 이런 부차적인 타입 정보를 제거해서 다루기 쉽게한다. &lt;a href=&quot;#fnref:decay&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:check&quot;&gt;
      &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;static_assert&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt;를 쓰면 익명 함수의 타입을 체크할 수 있겠지만, 어차피 타입이 맞지 않으면 컴파일 에러가 난다. 다만 에러를 이해하기 어려울 뿐이다. &lt;a href=&quot;#fnref:check&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
				<pubDate>Thu, 24 Mar 2016 00:00:00 +0000</pubDate>
				<link>http://minjang.github.io/2016/03/24/scala-like-map-groupby/</link>
				<guid isPermaLink="true">http://minjang.github.io/2016/03/24/scala-like-map-groupby/</guid>
			</item>
		
			<item>
				<title>스트롭스트룹 교수님과의 대화: &quot;C++ 배우는데 C를 먼저 배울 필요 없어요&quot;</title>
				        
        <description>&lt;p&gt;2013년 여름, C++을 만드신 당시 텍사스 A&amp;amp;M(TAMU) 교수였던&lt;sup id=&quot;fnref:bs&quot;&gt;&lt;a href=&quot;#fn:bs&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 비야네 스트롭스트룹(&lt;a href=&quot;https://en.wikipedia.org/wiki/Bjarne_Stroustrup&quot;&gt;Bjarne Stroustrup&lt;/a&gt;) 교수님이 내가 일하는 그룹에 오셔서 현대 C++에 대한 강의를 하셨다.&lt;sup id=&quot;fnref:talk&quot;&gt;&lt;a href=&quot;#fn:talk&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;
보통 이런 강의가 끝나면 30분 정도의 1:1 만남을 신청할 수 있다. 언제 또 C++ 창시자님과 대화를 나눠볼까 싶어서 냉큼 신청했고 이야기를 나눴다. 우리팀이 하고 있던 프로젝트 관련 조언을 좀 구한 뒤, 일반적인 질문도 좀 드려봤다. 멍청한 질문은 아닐까 조마조마했다.
주로 C++에서 포인터 사용과 올바른 C++ 학습에 대해 의견을 나눴다. 제목이 말하듯이 C++을 배우는데 더는 C를 거칠 필요가 없다. 짧았지만 이 대화 이후에 보다 다른 시각으로 C++을 볼 수 있게 되었다.&lt;/p&gt;

&lt;h3 id=&quot;c에서-c-포인터-사용에-대해-어떻게-생각하세요&quot;&gt;C++에서 C 포인터 사용에 대해 어떻게 생각하세요?&lt;/h3&gt;

&lt;p&gt;이런 질문을 드려봤다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“구글의 C++ 코딩 가이드라인을 보면 &lt;a href=&quot;https://google.github.io/styleguide/cppguide.html#Reference_Arguments&quot;&gt;함수 인자로 포인터 아니면 상수형 참조자만 쓰라고&lt;/a&gt; 합니다. 저희 팀 역시 참조자는 잘 쓰지 않고 포인터를 자주 씁니다. 최초의 C++은 C를 발전시켜서 만든 터라 C의 포인터를 그대로 계승하고 있는데요. 혹시 포인터를 좋아하세요? 여전히 참조자가 천대받는 코딩 규칙에 대해 어떻게 생각하세요?”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;나의 예상은 포인터를 아마도 싫어 하시겠지만, 영향력 있는 발언을 하시는 분이니 비판을 하더라도 다소 완곡한 표현을 쓰지 않을까였다.&lt;/p&gt;

&lt;p&gt;아니었다.&lt;/p&gt;

&lt;p&gt;한숨을 내쉬면서 생각보다 굉장한 어조로 포인터를 싫어한다고 말씀하셨다. 가능하다면 스마트 포인터와 참조자를 쓸 것을 권유하셨다. 나 역시 포인터를 너무 C++에서 남용하는 것 같아 싫어했지만, 주요 코딩 규칙들이 포인터를 더 우선시 하니 어쩔 수가 없었다. 그런데, C++ 만드신 분조차 이렇게 확실한 태도로 포인터를 비판하시니 한편으론 위안, 한편으론 호불호를 거침없이 표현하시는 것이 무척 흥미로웠다.
리누스 투르발스의 그 유명한 “&lt;a href=&quot;https://www.youtube.com/watch?v=_36yNWw_07g&quot;&gt;엔비디아, f*** you&lt;/a&gt;” 정도는 아니었지만, 당시 내 느낌은 상당히 신선했다.&lt;/p&gt;

&lt;p&gt;생각해보면 C 스타일의 포인터를 C++에서 그렇게 쓸 필요가 없다. 무엇보다 포인터에 대한 오해가 너무 심하다.&lt;/p&gt;

&lt;p&gt;포인터, 그러니까 무엇을 가리키고 참조한다는 개념은 자바나 파이썬 같은 명시적인 포인터가 없는 언어에도 있다. 이걸 모르면 제대로 프로그래밍을 할 수 없다. C/C++가 어려운 이유로 ‘포인터’를 꼽는 것은 잘못되었다. 정확히 말하자면, 가리키는 행위가 참조자 같은 것으로 추상화되지 않았고, 고로 프로그래머가 직접 주소를 얻어 그 값을 다뤄야 하니 어려운 것이다.
C 언어는 call-by-reference도 없다. 주소 값을 담고 있는 포인터가 그냥 call-by-value로 불릴 뿐이다. 포인터는 별 이상한 녀석도 아니고 그저 주소 값을 담고 있는 완벽한 변수이다.&lt;/p&gt;

&lt;p&gt;C++의 참조자는 이런 포인터의 문제를 - 완벽하지는 않지만 - 조금이라도 쉽게 한다. C++ 참조자는 선언과 함께 반드시 초기화되어야 하며, 그때 정해진 대상은 나중에 바꿀 수 없다. 포인터와 근본적으로 다른 점이다.
C++ 참조자는 실제 변수가 아니다. 참조자를 변수처럼 쓰지만, 실제 객체가 아니어서 주소 값을 얻을 수 없다. 가리키는 대상이 포인터처럼 무제한적이지 않아서 (아마도) 최대한 참조자로만 코드를 만들면 컴파일러가 코드 최적화하기 쉬울 수도 있다.&lt;/p&gt;

&lt;p&gt;하지만 대부분의 C++ 프로그래머가 C를 먼저 배웠던터라 오히려 C++ 참조자를 헷갈려한다. 그러다 보니 함수 인자에서 상수형 참조자 외에는 쓰지 말라는 규칙이 흔하게 사용된다.&lt;/p&gt;

&lt;p&gt;다행히 다른 현대 C++ 프로젝트는 적극적으로 참조자를 쓰고 있다. LLVM은 &lt;a href=&quot;https://github.com/llvm-mirror/llvm/blob/master/include/llvm/Pass.h#L135&quot;&gt;자유롭게 참조자를 쓴다&lt;/a&gt;(물론 여전히 상수형 참조자 + 포인터 조합이 흔하지만).
Chromium의 Blink 프로젝트의 &lt;a href=&quot;https://www.chromium.org/blink/coding-style#TOC-Pointers-and-References&quot;&gt;포인터와 레퍼런스에 대한 규칙&lt;/a&gt;을 보면 참조자의 함수 인자로서의 사용을 금하지는 않는다. 페이스북의 HHVM 역시 &lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/doc/coding-conventions.md&quot;&gt;참조자 사용 금지 같은 건 없다&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;포인터는 정말 메모리 덩어리를 주소로 접근해야 할 때만 쓰면 된다. 동적 할당도 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::make_unique&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::make_shared&lt;/code&gt;로부터 얻은 스마트 포인터를 쓰면 포인터 사용을 극단적으로 줄일 수 있다. 구글 코딩 가이드라인 역시 &lt;a href=&quot;https://google.github.io/styleguide/cppguide.html#Ownership_and_Smart_Pointers&quot;&gt;스마트 포인터 사용을 적극 장려하고 있다&lt;/a&gt;. C++11에서 도입된 우측값 참조와 무브 시맨틱으로 컴파일 시간에 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::uniqe_ptr&lt;/code&gt;의 잘못된 소유권 전달은 가려낼 수 있다. 더욱더 포인터를 덜 써도 되는 환경이다.&lt;/p&gt;

&lt;p&gt;스트롭스트룹 교수님은 그래서 C++에 대한 교육 방법도 바뀌어야 한다고 역설하셨다. 제발 C++을 C의 연장선으로 가르치지 말라고. 재직하던 TAMU에서 학생들을 효과적으로 가르치고자 책까지 새로 썼다고 하셨다. 바로 &lt;a href=&quot;http://www.stroustrup.com/programming.html&quot;&gt;“Programming: Principles and Practice Using C++”&lt;/a&gt;이다. 이 책에서 포인터, 메모리, 주소는 전체 27장 중 &lt;a href=&quot;http://www.stroustrup.com/PPP2_TOC.pdf&quot;&gt;17장에서 소개한다&lt;/a&gt;.
&lt;code class=&quot;highlighter-rouge&quot;&gt;char*&lt;/code&gt; 대신에 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::string&lt;/code&gt;을, 배열보다는 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&lt;/code&gt;를 가르쳐야 한다고 하셨다. 그 당시 오래된 C 코드에서 문자열, 배열, 해시테이블의 부재로 엄청 고생하던 나로서는 진심으로 와 닿는 말씀이었다.&lt;/p&gt;

&lt;h3 id=&quot;c를-처음으로-배운다면-c를-먼저-배울-필요가-절대-없어요&quot;&gt;C++를 처음으로 배운다면 C를 먼저 배울 필요가 절대 없어요.&lt;/h3&gt;

&lt;p&gt;&lt;u&gt;오해하지 말아야 할 것은 C가 필요 없다는 것이 아니다.&lt;/u&gt; 여전히 C가 필요한 곳도 많다. 단지 C++을 배울 때 C를 거칠 필요 없이 새로운 언어로 배우라는 것이다.
2015년 cppcon (C++ 컨퍼런스)에 흥미로운 강연이 있었다. 케이트 그레고리라는 분이 “Stop Teaching C”라는 제목으로 한 강연이다(&lt;a href=&quot;https://github.com/CppCon/CppCon2015/blob/master/Presentations/Stop%20Teaching%20C/Stop%20Teaching%20C%20-%20Kate%20Gregory%20-%20CppCon%202015.pptx&quot;&gt;슬라이드&lt;/a&gt;, &lt;a href=&quot;https://www.youtube.com/watch?v=YnWhqhNdYyk&quot;&gt;동영상&lt;/a&gt;). 내가 여기서 주장하는 내용과 비슷하다.&lt;/p&gt;

&lt;p&gt;C도 아닌 C++를 배우는데 너무 빨리 포인터, &lt;code class=&quot;highlighter-rouge&quot;&gt;char*&lt;/code&gt; 기반의 문자열, 동적 배열 등을 가르칠 필요는 없다. 시작은 C++11부터 도입된 여러 기능을 적극 써서 - 거짓말 약간 보태 - 파이썬스럽게 가르쳐도 된다. 포인터나 동적 할당은 좀 뒤에서 배워도 괜찮다.&lt;/p&gt;

&lt;p&gt;“어떻게 C/C++을 하면서 포인터, 메모리 할당 등을 안 가르칠 수 있냐!”라고 반박할 수 있다. 맞는 말이다. 특히 C 언어에 한정한다면 더더욱 옳다. 21세기에 C 언어는 기계어와 가장 근접한 언어이니 C 언어에 있어 컴퓨터/시스템 구조 지식은 필수이다. C++도 아주 잘 쓰려면 결국 저수준까지 내려가야 하지만, 나의 주장은 시작부터 괜히 진입 장벽을 높일 필요가 없다는 것이다. 가뜩이나 요즘 같이 웹이 모든 것을 잡아먹은 세상에선 C++ 조차도 너무나 아랫단에 있다. 시야를 아래로만 한정할 필요는 없다.&lt;/p&gt;

&lt;p&gt;아직 C++ 입문서 중 C 언어의 확장으로 시작하는 책들이 더러 있다. 심각하게 비판하는 것은 아니지만, 현대 C++도 나왔는데 다른 교습법이 이제 필요할 때가 아닌가 생각한다. Yes24 기준으로 가장 많이 판매되는 &lt;a href=&quot;http://www.yes24.com/24/viewer/preview/3816661&quot;&gt;C++ 입문서&lt;/a&gt;를 보면 서두 부분에 “C++은 C언어를 포함한다”라는 문구가 있다. 엄밀히 말하자면 기술적으로 틀린 말이다.
대부분의 독자가 C를 공부했음을 가정했을테니 보다 쉽게 접근하고자 C 이야기를 꺼낼 수 있지만, 오히려 방해된다.
최근 저술되는 C++ 입문서는 비교적 C와 C++의 차이를 분명히 인지하고 다른 언어로서 접근하는 것 같아 다행이다.&lt;/p&gt;

&lt;h3 id=&quot;c-가볍게-추상화한-언어&quot;&gt;C++: 가볍게 추상화한 언어&lt;/h3&gt;

&lt;p&gt;C++의 시작은 C에서 시작되었고, C++이 성공한 가장 큰 이유는 분명히 C와의 호환성 때문이다. 하지만 지금은 - 아니 이미 오래전부터 - 서로 다른 길을 가고 있다.&lt;/p&gt;

&lt;p&gt;그렇다면 도대체 C++를 어떻게 봐야 할까? 흔히 C++을 객체지향 언어, 멀티패러다임 언어라고 부르는데 장님 코끼리 만지듯 일부만 짚은 표현이다.&lt;/p&gt;

&lt;div class=&quot;image-wrapper&quot;&gt;
&lt;center&gt;
  &lt;img src=&quot;/assets/2016/what-is-cpp-1.png&quot; width=&quot;493&quot; height=&quot;372&quot; alt=&quot;&quot; /&gt;
&lt;/center&gt;
&lt;/div&gt;

&lt;p&gt;정답은 스트롭스트룹 교수님의 강연 도중 찾을 수 있었다. 아래와 같이 명쾌하게 정의하였다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;b&gt;“A light-weight abstraction programming language”&lt;/b&gt;
&lt;br /&gt;“가볍게 추상화한 프로그래밍 언어”&lt;sup id=&quot;fnref:translation&quot;&gt;&lt;a href=&quot;#fn:translation&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;image-wrapper&quot;&gt;
&lt;center&gt;
  &lt;img border=&quot;1&quot; src=&quot;/assets/2016/what-is-cpp-2.png&quot; width=&quot;493&quot; height=&quot;372&quot; alt=&quot;&quot; /&gt;
&lt;/center&gt;
&lt;/div&gt;

&lt;p&gt;“가볍다”라는 점에서 C와 아주 흡사하지만 “추상화”라는 관점에선 C++이 C와 크게 다르다.
특히 현대 C++에 추가된 기능은 이 철학을 충실히 지키므로 더욱 멋진 정리이다. C++을 배울 때도, 가르칠 때도, 이 철학을 상기하면 좋지 않을까 생각한다.&lt;/p&gt;

&lt;p&gt;. . . . . . . . .&lt;/p&gt;

&lt;p&gt;시간이 다 될 무렵, “The C++ Programming Language” 책에 사인을 받으면서 마지막으로 짧은 질문을 드렸다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“왜 쓰신 책의 코딩 폰트가 고정 폭이 아니라 가변 폭으로 하셨어요?”
&lt;br /&gt;“아, 그건 가변 폭으로 하니 한 줄에 더 많이 쓸 수 있어서 그렇게 했어요.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:bs&quot;&gt;
      &lt;p&gt;지금은 뉴욕의 모건 스탠리에 재직 중. &lt;a href=&quot;#fnref:bs&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:talk&quot;&gt;
      &lt;p&gt;같은 내용으로 한 강의를 &lt;a href=&quot;https://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style&quot;&gt;여기서&lt;/a&gt;, 슬라이드는 &lt;a href=&quot;https://parasol.tamu.edu/people/bs/622-GP/C++11-style.pdf&quot;&gt;여기서&lt;/a&gt; 볼 수 있다. &lt;a href=&quot;#fnref:talk&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:translation&quot;&gt;
      &lt;p&gt;영어 그대로 “가벼운 추상화 언어”라고 쓰면 좀 모호하다. 얼핏 “추상화된”으로 옮겨야할 것 같았는데, 더 생각해보니 C++은 여러 프로그래밍 기능을 가볍게 추상화 했으므로 “추상화한”이 더 매끄러운 우리말 표현일 듯 하다. &lt;a href=&quot;#fnref:translation&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
				<pubDate>Mon, 21 Mar 2016 00:00:00 +0000</pubDate>
				<link>http://minjang.github.io/2016/03/21/talk-with-stroustrup/</link>
				<guid isPermaLink="true">http://minjang.github.io/2016/03/21/talk-with-stroustrup/</guid>
			</item>
		
			<item>
				<title>현대 C++로 Python의 enumerate 만들어보기</title>
				        
        <description>&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2015/12/03/python-range-c++11/&quot;&gt;C++11으로 파이썬의 range 흉내내기&lt;/a&gt;를 먼저 읽어 볼 것을 추천합니다.&lt;/li&gt;
  &lt;li&gt;기본적인 우측값 참조에 대한 개념은 있다고 가정합니다.&lt;/li&gt;
  &lt;li&gt;경고: 매우 긴 글입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- &lt;span style=&quot;font-size: 1.5rem; vertical-align: -0.25rem&quot;&gt;☞&lt;/span&gt;  --&gt;

&lt;p&gt;파이썬 내장 함수 중 &lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt;가 있다. &lt;a href=&quot;/2015/12/03/python-range-c++11/&quot;&gt;이전 글&lt;/a&gt;에서 유도 변수(induction variable)에 대해 설명했다. 이 파이썬 함수는 유도 변수 없이도 루프에서 순환마다 하나씩 증가하는 인덱스를 쓸 수 있게 해준다. &lt;a href=&quot;https://docs.python.org/3/library/functions.html#enumerate&quot;&gt;함수 원형&lt;/a&gt;과 사용 예는 이러하다.&lt;/p&gt;

&lt;pre&gt;
&lt;b&gt;enumerate&lt;/b&gt;(&lt;i&gt;iterable&lt;/i&gt;, &lt;i&gt;start=0&lt;/i&gt;)
&lt;/pre&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;python3
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; A &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;bar&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;i, e &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;enumerate&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;A, 1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:
...     print&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;{}: {}&quot;&lt;/span&gt;.format&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;i, e&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
...
1: foo
2: bar
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;유도 변수를 피할 수 있다면 피하는 것이 좋다는 건 이전 글에서 잘 설명하였다. 그런데 위 예 같이 순환마다 인덱스를 얻고 싶다면 결국 유도 변수를 써야 할 것 같다. 다행히 파이썬에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt;로 현재 순환 내에서만 유효한 인덱스 변수, &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;를 얻어낼 수 있다. 파이썬을 부러워만 할 필요 없다. C++11/14로 &lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt;를 얼마든지 만들 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;1-c-enumerate-요구조건-정하기&quot;&gt;1. C++ enumerate 요구조건 정하기&lt;/h3&gt;

&lt;p&gt;개념적으로 C++ &lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt;는 범위 기반 for 루프에서 주어진 컨테이너의 원소와 하나씩 증가하는 인덱스 변수를 순환마다 함께 돌려준다. 언뜻 간단해 보이지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt;는 고려할 점이 정말 많다. &lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt;가 C++ 코드에서 어떻게 쓰일지부터 생각한다.&lt;/p&gt;

&lt;p&gt;아마도 가장 기본적인 예는 아래처럼 될 것이고 출력도 파이썬의 결과와 같을 것이다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;bar&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 유도 변수를 이용한 방법
// for (size_t i = 0; i &amp;lt; A.size(); ++i)
//   std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;: &quot; &amp;lt;&amp;lt; A[i] &amp;lt;&amp;lt; '\n';
//
// Python의 &quot;for i, e in enumerate(A, 1)&quot;과 비슷하게
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pair&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;!-- _includes/code_caption.html --&gt;
&lt;div class=&quot;code-wrapper&quot;&gt;
    &lt;div class=&quot;code-caption&quot;&gt;가장 기본적인 C++ enumerate 사용 예&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;이 외에도 다양한 형태로 &lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt;를 사용할 수 있을 것이다. 자세한 논의를 하려면 다음 두 가지를 생각해야 한다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;순환마다 얻는 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::pair&amp;lt;&amp;gt;&lt;/code&gt;에 해당하는 인덱스-원소 쌍 타입.&lt;/li&gt;
  &lt;li&gt;함수 인수(argument) &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; 자리에 허용되는 컨테이너 타입.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;enumerate의-인덱스-원소-쌍의-타입&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt;의 인덱스-원소 쌍의 타입&lt;/h4&gt;

&lt;p&gt;파이썬은 동적 언어이고 복수 반환 값이 허용되므로&lt;sup id=&quot;fnref:mutiret&quot;&gt;&lt;a href=&quot;#fn:mutiret&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 우아하게 &lt;code class=&quot;highlighter-rouge&quot;&gt;for i, e in enumerate(A)&lt;/code&gt; 같이 표현된다. 가엾은 C++은 어쩔 수 없이 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::pair&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::tuple&lt;/code&gt; 같은 것으로 두 개의 다른 타입 변수를 묶어야 한다. 직접 이런 클래스를 만들 수도 있을 것이다. 이 구현에서는 간단한 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::pair&lt;/code&gt;를 선택한다.&lt;/p&gt;

&lt;p&gt;인덱스 타입은 플랫폼에서 최대 객체 크기까지 표현할 수 있는 &lt;a href=&quot;http://en.cppreference.com/w/cpp/types/size_t&quot;&gt;&lt;code&gt;size_t&lt;/code&gt;&lt;/a&gt;으로 골랐다. STL 컨테이너는 별도로 &lt;code class=&quot;highlighter-rouge&quot;&gt;container::size_type&lt;/code&gt;이라는 타입을 두는데 &lt;code class=&quot;highlighter-rouge&quot;&gt;size_t&lt;/code&gt;와 &lt;a href=&quot;http://stackoverflow.com/questions/918567/size-t-vs-containersize-type&quot;&gt;사실상  같다&lt;/a&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;size_t&lt;/code&gt;는 배열 인덱스로도 안전하게 쓰이므로 이 값을 쓰는 것이 타당해 보인다. 파이썬의 &lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt;는 시작 오프셋으로 음수 값도 줄 수 있다. 음수까지 지원하고 싶으면 부호 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;size_t&lt;/code&gt;인  POSIX의 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_types.h.html&quot;&gt;&lt;code&gt;ssize_t&lt;/code&gt;&lt;/a&gt;로 선언하면 될 것이다.&lt;/p&gt;

&lt;p&gt;코드 1에서 벡터 &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;의 원소를 참조자 형태, &lt;code class=&quot;highlighter-rouge&quot;&gt;string&amp;amp;&lt;/code&gt;로 받았다. 벡터 &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;가 상수형이 아니므로 참조자로 루프를 돌면서 직접 원솟값을 변경할 수 있다. 읽기만 한다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;const string&amp;amp;&lt;/code&gt;으로 받으면 좋다. 아니면 그냥 &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;으로 복사 받아 원 벡터에 영향 없이 변경할 수도 있다. 원소는 값, 상수 참조, - 컨테이너가 수정을 허용한다는 조건 하에 - 일반 참조가 모두 가능해야 한다. 그런데 값 형태는 얼마든지 참조자로부터 복사해서 얻을 수 있다. 결과적으로 참조자 또는 상수 참조자로만 받아도 된다.
파이썬과 다르게 이런 부분에선 C++의 자유도가 확실히 높다. 물론 실수와 어려움의 대가가 따르지만.&lt;sup id=&quot;fnref:proxy&quot;&gt;&lt;a href=&quot;#fn:proxy&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;정리하자면:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;반복자(iterator)의 인덱스 타입은 &lt;code class=&quot;highlighter-rouge&quot;&gt;size_t&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;원소 타입은 상수 참조자, 때에 따라 참조자가 되며 이 둘은 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::pair&amp;lt;IndexType, ElementType&amp;gt;&lt;/code&gt;으로 묶는다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;ElementType&lt;/code&gt;&lt;small&gt;(이하 &lt;code class=&quot;highlighter-rouge&quot;&gt;ElemType&lt;/code&gt;)&lt;/small&gt;의 상수 여부는 일반적으로 입력 컨테이너의 상수 성질이 결정한다.&lt;sup id=&quot;fnref:constkey&quot;&gt;&lt;a href=&quot;#fn:constkey&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기서 &lt;code class=&quot;highlighter-rouge&quot;&gt;for (pair&amp;lt;size_t, ElemType&amp;gt; e : enumerate(A))&lt;/code&gt; 대신에 간편한 &lt;code class=&quot;highlighter-rouge&quot;&gt;for (auto e : enumerate(A))&lt;/code&gt;로 쓰면 안 되냐라고 물을 수 있다. 당연히 된다. 다만 이럴 때는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ElemType&lt;/code&gt;에 해당하는 부분을 맘대로 조절할 수 없게 된다. 테스트 케이스에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;auto&lt;/code&gt; 사용 예를 볼 것이다.&lt;/p&gt;

&lt;h4 id=&quot;어떤-컨테이너가-가능한가-배열은-되는지&quot;&gt;어떤 컨테이너가 가능한가? 배열은 되는지?&lt;/h4&gt;

&lt;p&gt;코드 1에서는 간단하게 &lt;code class=&quot;highlighter-rouge&quot;&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt;를 컨테이너로 했는데, &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;에 올 수 있는 타입은 어떤 것일까? 가능한 타입의 상한선은 명확하다: &lt;em&gt;범위 기반 for 루프에 쓸 수 있는 모든 것이다.&lt;/em&gt;
범위 기반 루프의 &lt;a href=&quot;/2015/12/03/python-range-c++11#range-for-definition&quot;&gt;정의&lt;/a&gt;를 상기하며 하나씩 생각해보자. 최종 목표는 &lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt;가 이 모든 것을 지원하는 것이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;STL 자료구조 중 컨테이너 어댑터인 &lt;code class=&quot;highlighter-rouge&quot;&gt;stack&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;queue&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;priority_queue&lt;/code&gt;를 제외한 &lt;a href=&quot;http://en.cppreference.com/w/cpp/container&quot;&gt;모든 컨테이너&lt;/a&gt;, 예를 들어, &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;unordered_map&lt;/code&gt;을 범위 기반 루프에서 쓸 수 있다. 이 두 그룹의 표면적 차이는 컨테이너의 &lt;code class=&quot;highlighter-rouge&quot;&gt;begin()&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;end()&lt;/code&gt; 메서드를 지원 유무이다. 일례로 &lt;code class=&quot;highlighter-rouge&quot;&gt;stack&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;begin()&lt;/code&gt; 메서드가 없을뿐더러 전역 함수 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::begin&lt;/code&gt; 역시 &lt;code class=&quot;highlighter-rouge&quot;&gt;stack&lt;/code&gt; 타입을 받을 수 없다.  엄밀히 말하면 &lt;a href=&quot;http://en.cppreference.com/w/cpp/concept/ForwardIterator&quot;&gt;forward iterator&lt;/a&gt;가 있는 컨테이너는 범위 기반 for 루프에서 쓸 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;C/C++ 일반 배열도 범위 기반 for 루프에서 쓸 수 있다. 전역 컨테이너 접근 함수 &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt;과 &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt;도 배열을 받을 수 있다. 힌트를 주자면 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::begin&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::end&lt;/code&gt;는 이번 구현에서 중추적인 역할을 한다. 두 함수의 원형과 사용법을 꼭 보고 자주 쓸 것을 권장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컨테이너 &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; 타입도 될 수 있다. 이럴 때는 순회할 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;의 원소 변경을 막아야 한다. 일반적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;을 포함한 &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/cv&quot;&gt;cv qualifiers&lt;/a&gt;가 허용된다. C++ 컨테이너에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;을 쓰는 일은 거의 없긴 할 것이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이전 글에서 만든 &lt;code class=&quot;highlighter-rouge&quot;&gt;range&lt;/code&gt;처럼 사용자 정의 타입도 조건만 맞는다면 범위 기반 for 루프에 쓸 수 있다. 반드시 STL 컨테이너나 &lt;code class=&quot;highlighter-rouge&quot;&gt;std::iterator&lt;/code&gt; 인터페이스를 따를 필요가 없다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; 같은 변수를 거치지 않고 컨테이너를 &lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt; 내에서 정의할 수 있다. 함수 리턴값으로도 바로 받을 수 있다. 이 부분에서 이해하기 참 까다로운 C++11의 우측값 참조(rvalue reference), 포워딩/유니버셜 레퍼런스(뒤에서 설명), 퍼펙트 포워딩 같은 것들이 나온다. 이 글에서도 대략 이야기할 것이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;C++11부터 지원되는 초기화 리스트(&lt;a href=&quot;http://en.cppreference.com/w/cpp/utility/initializer_list&quot;&gt;initializer list&lt;/a&gt;)도 범위 기반 루프에 쓸 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이상적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt;도 이 모든 것을 지원하면 좋다. 한번에 모든 것을 구현하기 어려우니 하나씩 구현할 것이다.&lt;/p&gt;

&lt;h3 id=&quot;2-테스트-케이스-작성&quot;&gt;2. 테스트 케이스 작성&lt;/h3&gt;

&lt;p&gt;앞서 설계한 요구 조건을 검사할 수 있는 테스트 케이스부터 만든다. 각각의 예상 결과도 함께 나열하였다.&lt;/p&gt;

&lt;h4 id=&quot;테스트-케이스-1&quot;&gt;테스트 케이스 1&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// 1. Forward iterator를 얻을 수 있는 STL 컨테이너
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;[TEST 1] vector&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;bar&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;baz&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 참조자로 직접 A 내용 수정.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pair&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 수정 내역 확인: 벡터 원소를 상수 참조자로 받음.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pair&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 백터 원소를 복사해서 값으로 받음. A는 영향 없음.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pair&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// auto로도 받을 수 있음: p의 타입은 pair&amp;lt;size_t, string&amp;amp;&amp;gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;pre&gt;
[TEST 1] vector&amp;lt;string&amp;gt;
0: foofoo
1: barbar
2: bazbaz
0: foofoo
1: barbar
2: bazbaz
0: foofoofoofoo
1: barbarbarbar
2: bazbazbazbaz
0: foofoo
1: barbar
2: bazbaz
&lt;/pre&gt;

&lt;p&gt;명시적인 &lt;code class=&quot;highlighter-rouge&quot;&gt;pair&amp;lt;size_t, ElemType&amp;gt;&lt;/code&gt; 대신에 &lt;code class=&quot;highlighter-rouge&quot;&gt;auto&lt;/code&gt;를 쓴 예도 포함했다. 어떤 타입으로 추론되었는지 알려면 C++ 자체의 &lt;code class=&quot;highlighter-rouge&quot;&gt;typeid&lt;/code&gt;를 쓸 수도 있는데 참조자와 cv 한정자가 생략되는 터라 boost의 &lt;code class=&quot;highlighter-rouge&quot;&gt;type_id_with_cvr&lt;/code&gt;를 써야 정확한 타입을 알 수 있다. 자세한 내용은 &lt;a href=&quot;http://shop.oreilly.com/product/0636920033707.do&quot;&gt;Effective Modern C++&lt;/a&gt;의 Item 4를 참조하면 좋다.&lt;/p&gt;

&lt;h4 id=&quot;테스트-케이스-2&quot;&gt;테스트 케이스 2&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// 2. 일반 배열 예
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;[TEST 2] array&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;bar&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;baz&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// auto&amp;amp;&amp;amp;로 받는 것이 범위 기반 for 문에서 일반적이고 효율적인 방법
// p 타입: pair&amp;lt;size_t, string&amp;amp;&amp;gt;&amp;amp;&amp;amp;, 원소 타입이 string&amp;amp;로 추론
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;pre&gt;
[TEST 2] array
100: foofoo
101: barbar
102: bazbaz
100: foofoo
101: barbar
102: bazbaz
&lt;/pre&gt;

&lt;p&gt;라인 6을 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;auto&amp;amp;&amp;amp; p&lt;/code&gt;로 받아 쓰고 있다. 자세한 설명&lt;sup id=&quot;fnref:rangefor&quot;&gt;&lt;a href=&quot;#fn:rangefor&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;은 생략하고 요약하자면, &lt;code class=&quot;highlighter-rouge&quot;&gt;auto&amp;amp;&amp;amp;&lt;/code&gt;로 받는 것이 범위 기반 for 문에서 일반적이면서 안전하고 효율적인 방법이다.
그냥 &lt;code class=&quot;highlighter-rouge&quot;&gt;for (auto p : enumerate(A))&lt;/code&gt;로 쓰면 &lt;code class=&quot;highlighter-rouge&quot;&gt;pair&amp;lt;..&amp;gt;&lt;/code&gt; 부분이 복사되는 오버헤드가 있으나 &lt;code class=&quot;highlighter-rouge&quot;&gt;pair&lt;/code&gt; 자체는 가볍게 복사되므로 의도적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;auto&amp;amp;&amp;amp;&lt;/code&gt;를 처음부터 쓰지는 않았다. 라인 6과 8에서 p의 타입은 우측값 참조, &lt;code class=&quot;highlighter-rouge&quot;&gt;pair&amp;lt;size_t, string&amp;amp;&amp;gt;&amp;amp;&amp;amp;&lt;/code&gt;가 되며 &lt;code class=&quot;highlighter-rouge&quot;&gt;ElemType&lt;/code&gt;은 참조자로 받기로 설계했으니 &lt;code class=&quot;highlighter-rouge&quot;&gt;string&amp;amp;&lt;/code&gt; 타입으로 추론될 것이다.&lt;/p&gt;

&lt;h4 id=&quot;테스트-케이스-3&quot;&gt;테스트 케이스 3&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// 3. const 예제
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;[TEST 3] const&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;bar&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;baz&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// decltype(p) == pair&amp;lt;size_t, string const&amp;amp;&amp;gt;&amp;amp;&amp;amp;
// p 자체는 상수가 아니므로 인덱스값은 변경 가능, 배열 값은 수정 불가.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;pre&gt;
[TEST 3] const
1: foo
2: bar
3: baz
&lt;/pre&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt;는 상수 문자열 배열이므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;pair&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;ElemType&lt;/code&gt;은 상수 참조자, &lt;code class=&quot;highlighter-rouge&quot;&gt;const string&amp;amp;&lt;/code&gt;로 얻어질 것이다. 그러나 p 자체는 상수가 아니므로 인덱스는 변경 가능하다.&lt;/p&gt;

&lt;h4 id=&quot;테스트-케이스-4&quot;&gt;테스트 케이스 4&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// 4. 앞서 구현한 range 사용 예
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;[TEST 4] range&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;103&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// decltype(p) == pair&amp;lt;size_t, int&amp;gt;&amp;amp;&amp;amp;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;pre&gt;
[TEST 4] range
0: 100
1: 101
2: 102
&lt;/pre&gt;

&lt;p&gt;앞서 만든 C++ &lt;code class=&quot;highlighter-rouge&quot;&gt;range&lt;/code&gt; 객체를 &lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;로 받아 쓰는 테스트이다. 유의할 점은 원소 타입이 우리가 설계했던 참조자 형태가 아니라 &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; 값이라는 점이다. 그 이유는 &lt;code class=&quot;highlighter-rouge&quot;&gt;range_iterator&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;operator*&lt;/code&gt;가 &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;를 &lt;a href=&quot;/2015/12/03/python-range-c++11#range-iterator-class&quot;&gt;반환하기 때문&lt;/a&gt;이다. 이 글 뒤에서 이 부분에 대해 더 자세히 논의할 것이다.&lt;/p&gt;

&lt;h4 id=&quot;테스트-케이스-5&quot;&gt;테스트 케이스 5&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// 5. 변수를 거치지 않고 직접 사용
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;[TEST 5] in-place through rvalue reference&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;103&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// decltype(p) == pair&amp;lt;size_t, string&amp;amp;&amp;gt;&amp;amp;&amp;amp;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;bar&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;baz&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}))&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 함수 반환값 직접 사용
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;bar&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;baz&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// decltype(p) == pair&amp;lt;size_t, string&amp;amp;&amp;gt;&amp;amp;&amp;amp;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()))&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;pre&gt;
[TEST 5] in-place through rvalue reference
0: 100
1: 101
2: 102
0: foofoo
1: barbar
2: bazbaz
0: foo
1: bar
2: baz
&lt;/pre&gt;

&lt;p&gt;테스트 5는 컨테이너나 배열을 명시적인 변수를 거치지 않고 임시 변수를 바로 사용하는 예이다. C++11부터 도입된 우측값 참조, 무브 시맨틱(move semantics), 퍼펙트 포워딩(perfect forwarding)으로 이제 이럴 때도 효율적으로 구현할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;테스트-케이스-6&quot;&gt;테스트 케이스 6&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// 6. 초기화 리스트
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;[TEST 6] initializer list&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;bar&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;baz&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}))&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;pre&gt;
[TEST 6] initializer list
0: foo
1: bar
2: baz
&lt;/pre&gt;

&lt;p&gt;초기화 리스트 덕에 C++에서도 파이썬처럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;{&quot;foo&quot;, &quot;bar&quot;}&lt;/code&gt;로 &lt;code class=&quot;highlighter-rouge&quot;&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt;을 초기화할 수 있다. 예전에는 일일이 &lt;code class=&quot;highlighter-rouge&quot;&gt;push_back&lt;/code&gt;를 불러야만 했다.&lt;/p&gt;

&lt;p&gt;참조자, 상수 컨테이너, 배열, 우측값 등 여러 사항을 고려하니 테스트 케이스가 짧지 않았다. 코딩할 시간이다.&lt;/p&gt;

&lt;h3 id=&quot;3-enumerate-함수-인터페이스-구현&quot;&gt;3. &lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt; 함수 인터페이스 구현&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt;는 임의의 컨테이너 타입을 받는 템플릿 함수로 설계한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;range&lt;/code&gt;와 비슷하게 &lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt; 함수 얼개를 만들어보자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 컨테이너 타입 */&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 좌측값 참조자만 받는 원형으로 테스트 케이스 1~4까지만 실행가능.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enumerate_impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enumerate_impl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quo