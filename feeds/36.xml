<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>KOYO KR</title><link>https://koyo.kr/</link><description>Recent content on KOYO KR</description><generator>Hugo -- gohugo.io</generator><language>ko</language><managingEditor>koyo@koyo.kr (koyo)</managingEditor><webMaster>koyo@koyo.kr (koyo)</webMaster><lastBuildDate>Sat, 09 Jun 2018 19:22:00 +0900</lastBuildDate><atom:link href="https://koyo.kr/index.xml" rel="self" type="application/rss+xml"/><item><title>Tistory에서 Github Pages로 이사하기</title><link>https://koyo.kr/post/migration-from-tistory-to-github-pages/</link><pubDate>Sat, 09 Jun 2018 19:22:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/migration-from-tistory-to-github-pages/</guid><description>Tistory에서 tistory 블로그를 써오면서 신경쓰이는 점이 두 개 정도 있었다. 암호화 통신 글 작성 방식 암호화 통신은 http://koyo.kr보다는 http</description></item><item><title>Racket 설치하고 SICP 실습하기</title><link>https://koyo.kr/post/install-racket-and-practice-sicp/</link><pubDate>Sun, 17 Dec 2017 21:12:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/install-racket-and-practice-sicp/</guid><description>우분투 터미널 환경에서 racket을 설치하고 vim으로 코드를 작성하여 sicp 예제를 실행하기 위한 환경을 설정하는 것 vim 버전이 쫌 높아야 되는 걸루 기억 racket 설치 sudo add-apt-repository</description></item><item><title>사지방 DNS 설정</title><link>https://koyo.kr/post/sjb-dns-config/</link><pubDate>Sun, 10 Dec 2017 18:02:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/sjb-dns-config/</guid><description>DNS 서버 변경 Cloudflare Public DNS Server netsh interface ip set dns &amp;#34;로컬 영역 연결&amp;#34; static 1.1.1.1 primary netsh interface ip add dns &amp;#34;로컬 영역 연결&amp;#34; 1.0.0.1 ipconfig /flushdns IBM Public DNS Server netsh interface ip set dns &amp;#34</description></item><item><title>CS:APP - 가상 메모리 1</title><link>https://koyo.kr/post/csapp-virtual-memory-1/</link><pubDate>Thu, 08 Jun 2017 17:16:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/csapp-virtual-memory-1/</guid><description>현대 시스템은 가상 메모리(Virtual memory). VM이라고 알려진 메인 메모리의 추상화를 제공한다. 1. 가상 메모리를 왜 공부해야 하는가 가상 메모리는 중요하다. 가</description></item><item><title>CS:APP - 예외적인 제어흐름, 비지역성 점프</title><link>https://koyo.kr/post/csapp-ecf-nonlocal-jump/</link><pubDate>Sat, 27 May 2017 15:20:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/csapp-ecf-nonlocal-jump/</guid><description>1. 비지역성 점프(Nonlocal jumps) C는 setjmp와 longjmp 함수를 제공한다. #include &amp;lt;setjmp.h&amp;gt; int setjmp(jmp_buf env); int sigsetjmp(sigjmp_buf env, int savesigs); // Returns: 0 from setjmp, nonzero from longjmps setjmp 함수는 현재 &#39;호출하는 환경&#39;을 env 버</description></item><item><title>CS:APP - 예외적인 제어흐름, 시그널 2</title><link>https://koyo.kr/post/csapp-ecf-signal-2/</link><pubDate>Thu, 25 May 2017 15:34:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/csapp-ecf-signal-2/</guid><description>이 글에서는 동시성을 다룬다. 1. 시그널 블록, 블록 해제 묵시적 블록 방법 커널은 핸들러에 의해 처리되고 있는 모든 대기 시그널의 처리를 막는다. 명시적 블록 방법 si</description></item><item><title>CS:APP - 예외적인 제어흐름, 시그널 1</title><link>https://koyo.kr/post/csapp-ecf-signal-1/</link><pubDate>Tue, 23 May 2017 18:01:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/csapp-ecf-signal-1/</guid><description>Signal! 시그널은 작은 메시지 형태로, 프로세스에게 시스탬 내에 어떤 종류의 이벤트가 일어났다는 것을 알려준다. 먼저 man 7 signal을 통해 시그널에 어떤 종류가 있는</description></item><item><title>CS:APP - 예외적인 제어흐름, 프로세스 제어</title><link>https://koyo.kr/post/csapp-ecf-process-control/</link><pubDate>Sat, 20 May 2017 17:20:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/csapp-ecf-process-control/</guid><description>이번 글에선 머리 굴려서 정리할 게 없다. 예제 코드에서 include한 csapp.h는 http://csapp.cs.cmu.edu/3e/ics3</description></item><item><title>CS:APP - 예외적인 제어흐름, 프로세스</title><link>https://koyo.kr/post/csapp-ecf-process/</link><pubDate>Wed, 17 May 2017 19:02:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/csapp-ecf-process/</guid><description>이 글은 프로세스에 대해 정리한 글이다. 먼저 프로세스에 대한 정보 두 가지를 언급한다. 첫번째 프로세스(process)는 프로그램(program)의 인스</description></item><item><title>Ubuntu GCC 보안 옵션</title><link>https://koyo.kr/post/ubuntu-gcc-security-flags/</link><pubDate>Fri, 12 May 2017 14:58:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/ubuntu-gcc-security-flags/</guid><description>기준 ubuntu 16.04.2 LTS (GNU/Linux 4.4.0-77-generic x86_64) gcc 5.4.0 20160609 gcc랑 관련없는 건데 이 운영체제에서 계속 ASLR을 끄고 싶어 echo &amp;quot;kernel.randomize_va_space=0&amp;quot; &amp;gt; /etc/sysctl.d/01-disable-aslr.conf 32비트로 컴파일하고 싶어 -m32 -m32 옵션을 줬는데 이상해 sudo apt install gcc-multilib</description></item><item><title>CS:APP - 예외적인 제어흐름, 예외 상황</title><link>https://koyo.kr/post/csapp-ecf-exception/</link><pubDate>Wed, 26 Apr 2017 18:00:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/csapp-ecf-exception/</guid><description>1. 예외적인 제어흐름 (Exceptional Control Flow) 프로그램 카운터(program counter)는 아래와 같이 연속된 값들을 가정한다. \[ a_0, a_1, ..., a_{n-1} \] 인스트럭션 \(I_k\)</description></item><item><title>Hyper-V 2세대 우분투 설치하기</title><link>https://koyo.kr/post/install-ubuntu-hyper-v-generation-2/</link><pubDate>Fri, 14 Apr 2017 17:57:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/install-ubuntu-hyper-v-generation-2/</guid><description>Hyper-V에서는 가상 컴퓨터를 생성할 때 1세대와 2세대 중 선택해야 한다. 2세대는 이런 기능을 제공한다. https://msdn.microsoft.com/ko-kr/library/dn282285.aspx 1세대: 이전 버전의 Hyper-V와 동일한</description></item><item><title>Hyper-V에서 네트워크 설정하기</title><link>https://koyo.kr/post/configure-network-in-hyper-v/</link><pubDate>Fri, 14 Apr 2017 17:27:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/configure-network-in-hyper-v/</guid><description>Hyper-V를 써보기로 했다. 네트워크 설정부터 포트 포워딩까지 작업이 조금 귀찮다. 그래서 여기 적음. 1. 네트워크 설정 가상 스위치 관리자에서 &#39;내부 네트워</description></item><item><title>Hyper-V 활성화/비활성화</title><link>https://koyo.kr/post/enable-or-disable-hyper-v/</link><pubDate>Wed, 12 Apr 2017 21:25:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/enable-or-disable-hyper-v/</guid><description>관리자 권한으로 실행한다. 끄기. bcdedit /set hypervisorlaunchtype off 켜기. bcdedit /set hypervisorlaunchtype auto 명령어 실행 후 재부팅이 필요하다.</description></item><item><title>CS:APP - 링킹 2</title><link>https://koyo.kr/post/csapp-linking-2/</link><pubDate>Wed, 12 Apr 2017 21:15:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/csapp-linking-2/</guid><description>이번 글에서는 실행 파일, 라이브러리 링크, 라이브러리 삽입에 대해 정리한다. 1. 실행 가능한 목적 파일 실행 가능한 목적 파일은 완전히 링크된 상태이기 때문에 .rel 섹션</description></item><item><title>CS:APP - 링킹 1</title><link>https://koyo.kr/post/csapp-linking-1/</link><pubDate>Tue, 11 Apr 2017 18:43:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/csapp-linking-1/</guid><description>리눅스와 ELF-64 포맷 기준. 1. 컴파일러 드라이버 gcc와 같은 컴파일러 드라이버(Compiler driver)는 필요에 따라 전처리기, 컴파일러, 어셈블러,</description></item><item><title>CS:APP - 캐시 메모리</title><link>https://koyo.kr/post/csapp-cache-memory/</link><pubDate>Sun, 26 Mar 2017 22:56:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/csapp-cache-memory/</guid><description>오늘은 캐시 메모리에 대해 정리. 짧게짧게 정리함. 1. cache hit, cache miss 찾으려는 데이터가 이미 캐시돼있다면 cache hit이 발생한다. 즉 메인 메모리를 거치지 않고 빠르게 데이</description></item><item><title>CS:APP - 프로그램 최적화 2</title><link>https://koyo.kr/post/csapp-optimizing-program-2/</link><pubDate>Wed, 22 Mar 2017 17:48:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/csapp-optimizing-program-2/</guid><description>저번 글에 이어서 계속한다. 1. 예제 및 복습 여기서는 책, 강의에서 제시해주는 예제를 쓰자. vector 자료형에 대한 연산이 정의된 combine 함수를 여러 기법을 사용해 최적화시키겠</description></item><item><title>CS:APP - 프로그램 최적화 1</title><link>https://koyo.kr/post/csapp-optimizing-program-1/</link><pubDate>Tue, 21 Mar 2017 13:19:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/csapp-optimizing-program-1/</guid><description>오늘은 인강도 참고했다. 이어폰 안가져와서 교수님 목소리 못듣고 페이지만 봄ㅜㅜ https://scs.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=4b1da67c-2980-4b96-82e7-2f99139a2c0d 1. 비효율적인 함수 호출 아래 코드의 문제점은 무엇일까? void lower(char *s) { for (size_t i = 0; i</description></item><item><title>vcpkg integrate install에서 dynamic 대신 static 적용하기</title><link>https://koyo.kr/post/vcpkg-static-instead-of-dynamic/</link><pubDate>Sun, 19 Mar 2017 22:08:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/vcpkg-static-instead-of-dynamic/</guid><description>우연히 vcpkg를 알게 됐는데 그동안 내가 찾았던 기능이 여기 있었다. vcpkg integrate install를 실행하면 비주얼 스튜디오에서 일일히 프로젝트 설정으로 inclu</description></item><item><title>Visual Studio를 설치했는데 WinDbg가 없을 때</title><link>https://koyo.kr/post/not-found-windbg/</link><pubDate>Wed, 15 Mar 2017 16:02:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/not-found-windbg/</guid><description>환경 Windows 10 Redstone 1, Visual Studio 2017 문제 WinDbg는 찾아도 안나오고... 그래서 설치하려고 하면 이미 SDK가 있다면서 날 화나게 하고... 해결 &#39;프로그램 추가/제거&#39;</description></item><item><title>CS:APP - 기계어, 부동소수점</title><link>https://koyo.kr/post/csapp-machine-level-floating-point/</link><pubDate>Tue, 14 Mar 2017 15:37:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/csapp-machine-level-floating-point/</guid><description>이 내용 이전에 gdb 사용법, 버퍼 오버플로, 메모리 보호기법, 가변 크기 스택프레임에 대한 내용이 있었다. 그런데 글로 정리하려니 잘 안되서 그냥 생략하고 부동소수점</description></item><item><title>CS:APP - 기계어, 배열과 정렬</title><link>https://koyo.kr/post/csapp-machine-level-array-alignment/</link><pubDate>Mon, 13 Mar 2017 17:51:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/csapp-machine-level-array-alignment/</guid><description>1. 배열과 포인터 연산 배열에 대한 포인터 연산은 다음과 같은 어셈블리 코드로 구현된다. Expression Type Value Assembly code E int * x movl %rdx, %rax E[0] int M[x] movl (%rdx), %eax E[i] int M[x + 4i] movl (%rdx, %rcx, 4), %eax &amp;amp;E[2] int * x +</description></item><item><title>CS:APP - 기계어, 프로시저</title><link>https://koyo.kr/post/csapp-machine-level-procedure/</link><pubDate>Thu, 09 Mar 2017 18:20:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/csapp-machine-level-procedure/</guid><description>오늘은 프로시저(Procedure)에 대해 정리한다. 먼저 프로시저에 대해 알아보자. 나는 프로시저는 인자를 받을 수 있고 값을 리턴할 수 있는 코드 블럭(특정</description></item><item><title>CS:APP - 기계어, 제어문</title><link>https://koyo.kr/post/csapp-machine-level-control/</link><pubDate>Wed, 08 Mar 2017 16:35:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/csapp-machine-level-control/</guid><description>오늘은 제어문 1. 조건 코드 CF: Carry flag. 가장 최근 연산에서 가장 중요한 비트의 올림 발생 표시. ZF: Zero flag. 가장 최근 연산의 결과가 0인 것을 표시. SF: Sign flag. 가장 최근 연산이 음수인</description></item><item><title>CS:APP - 기계어, 정수 연산</title><link>https://koyo.kr/post/csapp-machine-level-integer-arithmetic/</link><pubDate>Tue, 07 Mar 2017 19:09:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/csapp-machine-level-integer-arithmetic/</guid><description>정수 산술연산과 관련된 인스트럭션 정리. 1. 정수의 산술연산 Instruction Effect Description leaq S, D D &amp;lt;- &amp;amp;S Load effective address inc D D &amp;lt;- D + 1 Increment dec D D &amp;lt;- D - 1 Decrement neg D D &amp;lt;- -D Negate not D D &amp;lt;- -D Complement add S, D D</description></item><item><title>CS:APP - 기계어, 정수</title><link>https://koyo.kr/post/csapp-machine-level-integer/</link><pubDate>Tue, 07 Mar 2017 01:09:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/csapp-machine-level-integer/</guid><description>amd x86-64 기준, 프로그램의 기계수준 표현에 대해서 알아본다. 이 글에서 정리한 것은 word, 정수 레지스터, att형식 operand 읽는 법, 그리고 mov 인스트럭션이다. 1. C 자료형의</description></item><item><title>CS:APP - 정보, 정수 오버플로</title><link>https://koyo.kr/post/csapp-information-integer-overflow/</link><pubDate>Fri, 03 Mar 2017 16:40:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/csapp-information-integer-overflow/</guid><description>정수 산술연산 중에서도 오버플로에 대해서 정리한다. 1. unsigned 덧셈에서 overflow \(0 \le x, y \lt 2^w\)인 \(x\), \(y\)에 대해서 다음이 성립한다. \(w\)는 bit 수다. \[</description></item><item><title>CS:APP - 정보, 정수 형변환</title><link>https://koyo.kr/post/csapp-information-integer-representation/</link><pubDate>Thu, 02 Mar 2017 22:02:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/csapp-information-integer-representation/</guid><description>중요한 것 중에서도 글로 적기 쉬운 것만 적음 1. signed와 unsigned 간의 변환 C에서 signed와 unsigned 간의 캐스팅은 어떻게 될까? 한가지만 명심하자. 비트상의 데이터</description></item><item><title>CS:APP - 정보, 저장</title><link>https://koyo.kr/post/csapp-information-storage/</link><pubDate>Tue, 28 Feb 2017 21:10:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/csapp-information-storage/</guid><description>2.1 정보의 저장 2.1.1 16진수 표시 2진수를 16진수로 바꿀 때, 4비트씩 쪼개서 변환하면 편하다. &amp;quot;숫자 to hex&amp;quot;를 검색하면 헥스값을 바로</description></item><item><title>PowerShell에서 Bash 같은 alias 쓰기</title><link>https://koyo.kr/post/powershell-alias-like-bash/</link><pubDate>Sun, 26 Feb 2017 22:14:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/powershell-alias-like-bash/</guid><description>bash에는 alias가 있다... 이렇게 쓸 수 있다... alias ub=&amp;#39;docker run --rm ubuntu $@&amp;#39; 파워쉘에도 Set-Alias가 있지만... 대신 function 기능을 쓰는게 유익한 것 같다.</description></item><item><title>fork - exec 대신 posix_spawn 쓰기</title><link>https://koyo.kr/post/posix_spawn-instead-of-fork-exec/</link><pubDate>Sun, 19 Feb 2017 19:01:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/posix_spawn-instead-of-fork-exec/</guid><description>fork - exec 조합으로 외부 프로그램을 실행하는 방법은 별로 권장하지 않는다고 한다. 대신 posix_spawn 함수를 추천하는데... 예전에 system 함수 대신 fork - exec를 쓴다고 한 글 system 대</description></item><item><title>Windows에서 Monitor Mode 쓰기</title><link>https://koyo.kr/post/windows-monitor-mode/</link><pubDate>Tue, 14 Feb 2017 22:49:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/windows-monitor-mode/</guid><description>개요 windows에서 wireshark로 IEEE 802.11 패킷을 잡는 것을 목표로 글을 쓴다. 글 따라하려면 필요한 것. monitor mode를 지원하는 무선 어댑터 npcap wireshark 1. monitor mo</description></item><item><title>FC4 cruel -&gt; enigma</title><link>https://koyo.kr/post/fc4-cruel/</link><pubDate>Sat, 07 Jan 2017 03:05:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/fc4-cruel/</guid><description>ret 영역 다음에 canary가 있다는 걸 생각하야 한다. fake ebp를 이용해서 stdin의 임시버퍼 영역을 공략한다. 이 영역의 주소가 계속 바뀌긴 하지만 경우의 수</description></item><item><title>FC3 evil_wizard -&gt; dark_stone</title><link>https://koyo.kr/post/fc3-evil_wizard/</link><pubDate>Fri, 06 Jan 2017 23:33:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/fc3-evil_wizard/</guid><description>dark_stone 코드 /* The Lord of the BOF : The Fellowship of the BOF - dark_stone - Remote BOF on Fedora Core 3 - hint : GOT overwriting again - port : TCP 8888 */ #include &amp;lt;stdio.h&amp;gt; // magic potion for you void pop_pop_ret(void) { asm(&amp;#34;pop %eax&amp;#34;); asm(&amp;#34;pop %eax&amp;#34;); asm(&amp;#34;ret&amp;#34;); } int main() { char buffer[256]; char saved_sfp[4]; int length; char temp[1024]; printf(&amp;#34;dark_stone : how fresh meat you are!\n&amp;#34;);</description></item><item><title>C&#43;&#43; 멀티스레드 무한루프 끝내기</title><link>https://koyo.kr/post/cpp-multi-thread-exit-infinite-loop/</link><pubDate>Fri, 06 Jan 2017 00:42:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/cpp-multi-thread-exit-infinite-loop/</guid><description>까먹을 예정이라서 저장 만약 bool을 이용해서 종료를 해왔다면... 예를 들어 이렇게 써왔다면... #include &amp;lt;thread&amp;gt; void func( bool&amp;amp; run ) { while ( run ) { // ... } } int main() { bool run{ true }; std::thread</description></item><item><title>FC3 hell_fire -&gt; evil_wizard</title><link>https://koyo.kr/post/fc3-hell_fire/</link><pubDate>Fri, 06 Jan 2017 00:15:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/fc3-hell_fire/</guid><description>pop pop ret을 어떻게 쓰는 건지 이 문제를 풀고 알게 됐다. 리턴을 이용해서 인자가 2개 필요한 함수를 호출할 때 스택에 아래와 같이 배치시킨다. [함수주소] [ㅁㄴㅇ</description></item><item><title>FC3 iron_golem -&gt; dark_eyes</title><link>https://koyo.kr/post/fc3-iron_golem/</link><pubDate>Thu, 05 Jan 2017 01:40:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/fc3-iron_golem/</guid><description>ret sleding에 대해 쓰는 글 아래는 코드 /* The Lord of the BOF : The Fellowship of the BOF - dark_eyes - Local BOF on Fedora Core 3 - hint : RET sleding */ int main(int argc, char *argv[]) { char buffer[256]; char saved_sfp[4]; if(argc &amp;lt; 2){ printf(&amp;#34;argv error\n&amp;#34;); exit(0); } // save sfp memcpy(saved_sfp, buffer+264, 4); //</description></item><item><title>The Lord of the BOF - assassin -&gt; zombie_assassin</title><link>https://koyo.kr/post/lob-assassin/</link><pubDate>Wed, 04 Jan 2017 17:14:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/lob-assassin/</guid><description>코드는 이렇다. /* The Lord of the BOF : The Fellowship of the BOF - zombie_assassin - FEBP */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; main(int argc, char *argv[]) { char buffer[40]; if(argc &amp;lt; 2){ printf(&amp;#34;argv error\n&amp;#34;); exit(0); } if(argv[1][47] == &amp;#39;\xbf&amp;#39;) { printf(&amp;#34;stack retbayed you!\n&amp;#34;); exit(0); } if(argv[1][47] == &amp;#39;\x40&amp;#39;) { printf(&amp;#34;library retbayed you, too!!\n&amp;#34;); exit(0); } // strncpy instead of strcpy! strncpy(buffer, argv[1], 48); printf(&amp;#34;%s\n&amp;#34;, buffer);</description></item><item><title>꼬리재귀로 이항계수 구현하기</title><link>https://koyo.kr/post/tail-recursion-binomial-coefficient/</link><pubDate>Mon, 26 Dec 2016 01:40:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/tail-recursion-binomial-coefficient/</guid><description>\[ {n\choose k} = \frac{n!}{k!(n-k)!} \] 이항계수의 공식. 얼추 코드로 옮기면 아래처럼 된다. \((0 \le k \le n)\) int f(int n, int k) { return factorial(n) / (factorial(k) * factorial(n - k)) } 일단 재귀로 바꿔보자... f(n, 0)은... \[ f(n,0)</description></item><item><title>re2c랑 bison으로 파서 만들기</title><link>https://koyo.kr/post/re2c-bison-parser/</link><pubDate>Tue, 29 Nov 2016 23:07:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/re2c-bison-parser/</guid><description>파서를 만들 때, lex로는 토큰을 만들고, yacc로는 토큰의 조합에 따른 행동을 만든다. 이 글에서 re2c는 lex에 대응하고, bison은 yacc에 대</description></item><item><title>ImageSafer 5.0 삭제하기</title><link>https://koyo.kr/post/uninstall-imagesafer-5-0/</link><pubDate>Thu, 20 Oct 2016 14:07:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/uninstall-imagesafer-5-0/</guid><description>윈도우 64비트, 2016-10-20 기준 관리자 권한 명령 프롬프트에서 다음 명령어를 실행한다. sc stop &amp;#34;IMGSF50_Svc&amp;#34; sc delete &amp;#34;IMGSF50_Svc&amp;#34; 위 사진대로 나오면 된 것. C:\Windows 에서 다음 파일을 삭제한다. ImageSAFERSvc.exe IMGSF50Svc.exe C:\Windows\System32 에서</description></item><item><title>Ubuntu 16.04에서 Cuckoo Sandbox 설치</title><link>https://koyo.kr/post/install-cuckoosandbox-in-ubuntu/</link><pubDate>Tue, 11 Oct 2016 00:33:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/install-cuckoosandbox-in-ubuntu/</guid><description>설치하면서 작성하는 글. 읽기 전에 최근에 이 글대로 하면 잘 안된다고 한다. 참고만... ㅎㅎ 1. 버추얼박스에 우분투 설치 윈도우 쓰는 중인데 노트북에 남은 공간이 별</description></item><item><title>Windows 가상머신 파일 다운로드</title><link>https://koyo.kr/post/download-windows-for-virtual-machine/</link><pubDate>Mon, 10 Oct 2016 16:40:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/download-windows-for-virtual-machine/</guid><description>https://developer.microsoft.com/en-us/microsoft-edge/api/tools/vms/ 위 링크에서 원하는 파일을 골라서 받으면 된다. XP 가상머신이 필요한데 저 링크에서는 안보인다. 예전에는 있었는데... 그래도 실제 다운로드 링크가 사라진 건 아</description></item><item><title>pyenv로 파이썬을 설치하기 전에 해야할 것</title><link>https://koyo.kr/post/pyenv-to-do-before-install-python/</link><pubDate>Sat, 08 Oct 2016 15:14:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/pyenv-to-do-before-install-python/</guid><description>이걸 안해주면 나중에 모듈 설치할 때 골치아프다. export CONFIGURE_OPTS=&amp;#34;--enable-shared&amp;#34; export PYTHON_CONFIGURE_OPTS=&amp;#34;--enable-shared&amp;#34;</description></item><item><title>Windows에서 Python 3.4.4, Qt 4.8.7, PySide 1.2.4 설치하기</title><link>https://koyo.kr/post/install-python-qt-pyside-in-windows/</link><pubDate>Sat, 08 Oct 2016 01:17:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/install-python-qt-pyside-in-windows/</guid><description>PySide 설치하는 방법 자세하게 적는 글 현재 PySide는 Python 3.5와 Qt5를 지원하지 않는다. PySide2는 Qt5를 지원하지만 아직 한창 개발 중인 것 같아 Qt</description></item><item><title>Ubuntu 16.04에서 Nginx, PHP, MariaDB 설치하기</title><link>https://koyo.kr/post/install-nginx-php-mariadb-in-ubuntu/</link><pubDate>Tue, 13 Sep 2016 16:33:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/install-nginx-php-mariadb-in-ubuntu/</guid><description>나중에 보려고 쓰는 글. 아래 링크 보고 많이 따라했음 https://blog.lael.be/post/2600 add-apt-repository 명령어를 쓰기 위해 software-properties-common을 설치 apt install software-properties-common nginx 저장소 추가</description></item><item><title>The Lord of the BOF - darkknight -&gt; bugbear</title><link>https://koyo.kr/post/lob-darkknight/</link><pubDate>Thu, 08 Sep 2016 17:10:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/lob-darkknight/</guid><description>return to library 개념 이해하기 아래는 문제의 코드 /* The Lord of the BOF : The Fellowship of the BOF - bugbear - RTL1 */ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; main(int argc, char *argv[]) { char buffer[40]; int i; if(argc &amp;lt; 2){ printf(&amp;#34;argv error\n&amp;#34;); exit(0); } if(argv[1][47] == &amp;#39;\xbf&amp;#39;) { printf(&amp;#34;stack betrayed you!!\n&amp;#34;); exit(0); } strcpy(buffer, argv[1]); printf(&amp;#34;%s\n&amp;#34;, buffer); } 이전 단</description></item><item><title>VirtualBox Ubuntu에서 그래픽이 깨질 때</title><link>https://koyo.kr/post/broken-graphic-in-ubuntu-on-virtualbox/</link><pubDate>Thu, 18 Aug 2016 00:08:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/broken-graphic-in-ubuntu-on-virtualbox/</guid><description>내 경우에는 qt creator랑 atom이 자꾸 그래픽이 깨지고 오류가 났다. 3d가속을 끄면 이제 그래픽이 깨지지 않는다. ㅋㅋ...ㅋ</description></item><item><title>system 대신 fork - exec 쓰기</title><link>https://koyo.kr/post/fork-exec-instead-of-system/</link><pubDate>Wed, 17 Aug 2016 02:23:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/fork-exec-instead-of-system/</guid><description>fork - exec 대신 posix_spawn 쓰기 c언어에서 기존 프로세스를 종료시키지 않고 외부 명령어를 실행하고 싶을 때가 있다. system 함수는 보안상 문제가 많아서 안쓰는 게 좋다고 하고... 그</description></item><item><title>posix aio socket server 예제</title><link>https://koyo.kr/post/posix-aio-socket-server-example/</link><pubDate>Mon, 15 Aug 2016 00:08:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/posix-aio-socket-server-example/</guid><description>열심히 코드를 작성하면서 검색하는데 aio는 소켓을 지원하지 않는다는 글이 있어서 깜짝 놀랐다 ㄷㄷ http://www.clien.net/cs2/bbs/board.php?bo_table=kin&amp;amp;wr_id=2298319 댓글 보니까 된다고... 실제로도 되서 다행이다. 비동기/</description></item><item><title>c socket 예제</title><link>https://koyo.kr/post/c-socket-example/</link><pubDate>Fri, 12 Aug 2016 00:52:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/c-socket-example/</guid><description>여러 예제를 보고 따라하면서 많은 이해가 됐다. sockaddr 구조체와 sockaddr_in 구조체는 크기가 같다는 것이 인상깊었다. 아래는 작성한 예제 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;sys/wait.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/socket.h&amp;gt;#include &amp;lt;arpa/inet.h&amp;gt;#include &amp;lt;string.h&amp;gt; int main () { int ret; pid_t pid = fork();</description></item><item><title>printf와 8바이트 정수</title><link>https://koyo.kr/post/printf-8byte-integer/</link><pubDate>Wed, 10 Aug 2016 18:43:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/printf-8byte-integer/</guid><description>int64_t는 보통 아래처럼 정의되어 있다. uint64_t는 여기에 unsigned만 붙었다. #if __WORDSIZE == 64 typedef long int int64_t #else __extension__ typedef long long int int64_t #endif long int를 pri</description></item><item><title>c 공부 정리 2</title><link>https://koyo.kr/post/c-study-2/</link><pubDate>Wed, 10 Aug 2016 02:32:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/c-study-2/</guid><description>최근에 공부한 함수들 벌써 다 까먹어서 여기다 적기로 했당 1. open (1) O_ASYNC, O_SYNC 둘이 헷갈린다. O_ASYNC는 설명을 봐도 잘 모르겠어서 나중에 보기로 했음 O_SYNC 모드 설정해주</description></item><item><title>c 공부 정리 1</title><link>https://koyo.kr/post/c-study-1/</link><pubDate>Tue, 09 Aug 2016 02:49:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/c-study-1/</guid><description>1. 자료형 크기 long은 4바이트 고정이고 int가 변동한다고 생각해왔는데 거꾸로였다. long long int는 32비트 환경에서 8바이트고, long double은 64</description></item><item><title>귀여운 비누</title><link>https://koyo.kr/post/cuty-soaps/</link><pubDate>Tue, 02 Aug 2016 02:58:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/cuty-soaps/</guid><description>코끼리랑 무당벌레가 넘 귀여워서 못쓰겠다.ㅎㅎ 나방 같이 생긴 비누부터 쓸거임</description></item><item><title>Pwnable KR - simple login</title><link>https://koyo.kr/post/pwnable-kr-simple-login/</link><pubDate>Wed, 18 May 2016 19:40:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/pwnable-kr-simple-login/</guid><description>문제 50점 문제 풀이 아이다로 열어서 main 함수를 보면 Base64Decode 함수를 거쳐서 그 글자가 12글자를 넘지 않았을 때, memcpy 함수와 auth 함수를 실행할 수 있다. auth 함수를 보면 위에 calc_md5 함</description></item><item><title>TU CTF 2016 - WoO2</title><link>https://koyo.kr/post/tu-ctf-2016-woo2/</link><pubDate>Tue, 17 May 2016 21:16:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/tu-ctf-2016-woo2/</guid><description>TU CTF 2016에서 못푼 문제 $ ./WoO2 Welcome! I don&amp;#39;t think we&amp;#39;re in Kansas anymore. We&amp;#39;re about to head off on an adventure! Select some animals you want to bring along. Menu Options: 1: Bring a lion 2: Bring a tiger 3: Bring a bear 4: Delete Animal 5: Exit Enter your choice: 5 $ 실행하면 이렇게 뜬</description></item><item><title>Pwnable KR - memcpy</title><link>https://koyo.kr/post/pwnablr-kr-memcpy/</link><pubDate>Sun, 01 May 2016 02:05:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/pwnablr-kr-memcpy/</guid><description>문제 10점 문제. // compiled with : gcc -o memcpy memcpy.c -m32 -lm memcpy.c 첫줄에 이런 주석이 있어서 가상머신 우분투에서 컴파일해서 풀기로 했다. 나는 -g 옵션도 추가로 줬다. 64비트에서 안되</description></item><item><title>Pwnable KR - uaf</title><link>https://koyo.kr/post/pwnable-kr-uaf/</link><pubDate>Wed, 27 Apr 2016 21:51:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/pwnable-kr-uaf/</guid><description>문제 8점 문제. Use After Free를 몰라서 또 찾아봐야했다. $ ls -l total 24 -rw-r----- 1 root uaf_pwn 22 Sep 25 2015 flag -r-xr-sr-x 1 root uaf_pwn 15463 Sep 25 2015 uaf -rw-r--r-- 1 root root 1431 Sep 25 2015 uaf.cpp uaf.cpp #include &amp;lt;fcntl.h&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;unistd.h&amp;gt;using namespace std; classHuman{ private: virtual void</description></item><item><title>Pwnable KR - cmd2</title><link>https://koyo.kr/post/pwnable-kr-cmd2/</link><pubDate>Mon, 25 Apr 2016 19:39:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/pwnable-kr-cmd2/</guid><description>문제 9점 문제. cmd2.c의 내용은 아래와 같다. #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt; int filter(char* cmd){ int r=0; r += strstr(cmd, &amp;#34;=&amp;#34;)!=0; r += strstr(cmd, &amp;#34;PATH&amp;#34;)!=0; r += strstr(cmd, &amp;#34;export&amp;#34;)!=0; r += strstr(cmd, &amp;#34;/&amp;#34;)!=0; r += strstr(cmd, &amp;#34;`&amp;#34;)!=0; r += strstr(cmd, &amp;#34;flag&amp;#34;)!=0; return r; } extern char** environ; void delete_env(){ char** p; for(p=environ; *p; p++) memset(*p, 0,</description></item><item><title>Pwnable KR - cmd1</title><link>https://koyo.kr/post/pwnable-kr-cmd1/</link><pubDate>Mon, 25 Apr 2016 16:36:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/pwnable-kr-cmd1/</guid><description>문제 cmd1.c 파일 내용은 아래와 같다. argv[1]에 flag나 sh나 tmp가 들어가면 안되는 듯. #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt; int filter(char* cmd){ int r=0; r += strstr(cmd, &amp;#34;flag&amp;#34;)!=0; r += strstr(cmd, &amp;#34;sh&amp;#34;)!=0; r += strstr(cmd, &amp;#34;tmp&amp;#34;)!=0; return r; } int main(int argc, char*</description></item><item><title>Pwnable KR - shellshock</title><link>https://koyo.kr/post/pwnable-kr-shellshock/</link><pubDate>Sun, 24 Apr 2016 17:39:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/pwnable-kr-shellshock/</guid><description>문제 1점 문제. $ ls -l total 960 -r-xr-xr-x 1 root shellshock 959120 Oct 12 2014 bash -r--r----- 1 root shellshock_pwn 47 Oct 12 2014 flag -r-xr-sr-x 1 root shellshock_pwn 8547 Oct 12 2014 shellshock -r--r--r-- 1 root root 188 Oct 12 2014 shellshock.c flag를 보려면 shellshock2 gid가 필요하고 shell</description></item><item><title>Pwnable KR - blackjack</title><link>https://koyo.kr/post/pwnable-kr-blackjack/</link><pubDate>Thu, 21 Apr 2016 19:08:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/pwnable-kr-blackjack/</guid><description>문제 int betting() //Asks user amount to bet { printf(&amp;#34;\n\nEnter Bet: $&amp;#34;); scanf(&amp;#34;%d&amp;#34;, &amp;amp;bet); if (bet &amp;gt; cash) //If player tries to bet more money than player has { printf(&amp;#34;\nYou cannot bet more money than you have.&amp;#34;); printf(&amp;#34;\nEnter Bet: &amp;#34;); scanf(&amp;#34;%d&amp;#34;, &amp;amp;bet); return bet; } else return bet; } // End Function `` ## 풀이 배팅할 금액을 입력하는 부분에</description></item><item><title>Pwnable KR - coin1</title><link>https://koyo.kr/post/pwnable-kr-coin1/</link><pubDate>Sun, 27 Mar 2016 22:26:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/pwnable-kr-coin1/</guid><description>문제 netcat를 이용해서 들어가보자 가짜코인을 제한 시간 내에 찾아야한다. 30초가 지나면 시간초과로 다시 도전해야 한다. 풀이 처음에는 가짜코인을 한 번만</description></item><item><title>Pwnable KR - mistake</title><link>https://koyo.kr/post/pwnable-kr-mistake/</link><pubDate>Mon, 15 Feb 2016 17:28:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/pwnable-kr-mistake/</guid><description>문제 힌트는 우선순위 mistake.c #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;fcntl.h&amp;gt; #define PW_LEN 10 #define XORKEY 1 void xor(char* s, int len){ int i; for(i=0; i&amp;lt;len; i++){ s[i] ^= XORKEY; } } int main(int argc, char* argv[]){ int fd; if(fd=open(&amp;#34;/home/mistake/password&amp;#34;,O_RDONLY,0400) &amp;lt; 0){ printf(&amp;#34;can&amp;#39;t open password %d\n&amp;#34;, fd); return 0; } printf(&amp;#34;do not bruteforce...\n&amp;#34;); sleep(time(0)%20); char pw_buf[PW_LEN+1]; int len; if(!(len=read(fd,pw_buf,PW_LEN) &amp;gt; 0)){ printf(&amp;#34;read error\n&amp;#34;); close(fd); return 0; } char</description></item><item><title>Pwnable KR - leg</title><link>https://koyo.kr/post/pwnable-kr-leg/</link><pubDate>Fri, 29 Jan 2016 16:59:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/pwnable-kr-leg/</guid><description>문제 다운로드 파일의 내용을 읽고 flag 파일을 읽기 위한 조건을 맞추면 된다. c 코드를 보면 key1()+key2()+key3() == key을 만족하는 key를 사용자가 입력해야 한다. leg.c #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;fcntl.h&amp;gt;int key1(){ asm(&amp;#34;mov r3, pc\n&amp;#34;);</description></item><item><title>notepad&#43;&#43;에서 cl.exe로 컴파일하기</title><link>https://koyo.kr/post/notepadpp-compile-using-cl-exe/</link><pubDate>Tue, 19 Jan 2016 15:29:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/notepadpp-compile-using-cl-exe/</guid><description>이 글은 notepad++에서 cl.exe를 이용해서 c언어를 컴파일하는 방법을 적는다. 왜 적냐면 나중에 보려고ㅎ 비주얼 스튜디오 2015를 설치하면 똑같</description></item><item><title>windows 파일 속성에서 파일 해시 확인하기</title><link>https://koyo.kr/post/windows-check-hash/</link><pubDate>Sun, 17 Jan 2016 22:18:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/windows-check-hash/</guid><description>http://implbits.com/products/hashtab/ 설치하면 속성 창에서 파일 해시란 이름으로 탭이 추가된다. 파일 해시값을 알고 싶을 때 간편하다.</description></item><item><title>Pwnable KR - random</title><link>https://koyo.kr/post/pwnable-kr-random/</link><pubDate>Sun, 17 Jan 2016 21:58:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/pwnable-kr-random/</guid><description>문제 문제를 풀면 1포인트를 준다. $ ls -l total 20 -r--r----- 1 random_pwn root 49 Jun 30 2014 flag -r-sr-x--- 1 random_pwn random 8538 Jun 30 2014 random -rw-r--r-- 1 root root 301 Jun 30 2014 random.c#include &amp;lt;stdio.h&amp;gt; int main(){ unsigned int random; random = rand(); // random value! unsigned int key=0; scanf(&amp;#34;%d&amp;#34;, &amp;amp;key); if( (key ^ random) == 0xdeadbeef</description></item><item><title>Peach Fuzzer 2 WinDbg 경로 설정</title><link>https://koyo.kr/post/peach-fuzzer-2-configure-windbg-path/</link><pubDate>Wed, 28 Oct 2015 23:07:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/peach-fuzzer-2-configure-windbg-path/</guid><description>퍼저가 자꾸 디버거 경로를 못잡았다. 검색해봐서 WinDbgPath로 경로 지정해주래서 따라해봤는데도 안됐었다. 3버전대 해결책은 2버전대에 안먹히나 보</description></item><item><title>Net-Force: level603 - Wanna play?!?!</title><link>https://koyo.kr/post/net-force-level603/</link><pubDate>Wed, 26 Aug 2015 13:08:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/net-force-level603/</guid><description>컵 개수를 늘려가면서 5개의 공을 넣는 경우의 수를 모두 합산하는 문제이다. 컵의 개수는 1개부터 500개까지 증가한다. 처음에 이 문제를 보고 고등학교 때 배운 순열</description></item><item><title>Net-Force: level604 - Aaarrrgghhh!!</title><link>https://koyo.kr/post/net-force-level604/</link><pubDate>Wed, 26 Aug 2015 12:45:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/net-force-level604/</guid><description>상하좌우, 대각선의 총 여덟 방향으로의 123이 몇 개 있는지를 알아내는 문제다. aap.txt를 보면 가로 100글자, 세로 100줄로 구성되어 있다. 그렇다</description></item><item><title>Net-Force: level607 - Infinite division</title><link>https://koyo.kr/post/net-force-level607/</link><pubDate>Tue, 11 Aug 2015 21:34:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/net-force-level607/</guid><description>13155187 / 13417의 소수 4995~5000번째 자리 수가 답이다. a = 13155187 b = 13417 last = &amp;#34;&amp;#34; def deviii(a): i = 0 while (a &amp;gt; b): a -= b i += 1 return [str(i), a] list = deviii(a) a = list[1] last += list[0] + &amp;#34;.&amp;#34; for i in</description></item><item><title>Net-Force: level706 - Made in Taiwan</title><link>https://koyo.kr/post/net-force-level706/</link><pubDate>Tue, 04 Aug 2015 20:49:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/net-force-level706/</guid><description>길이 13의 바코드 넘버를 알아달라고 한다. 앱으로 찍으면 된다. 답은 4710212125960. 인터넷 카테고리가 원래 쉬운 건지, 옛날에 나온 문제라 쉬운 건지는 모르겠다.</description></item><item><title>Net-Force: level704 - Chemical Stuff</title><link>https://koyo.kr/post/net-force-level704/</link><pubDate>Tue, 04 Aug 2015 20:36:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/net-force-level704/</guid><description>주기율표를 보라고 한다. 22- Ti t 90+ Th h 10+ Ne e 24- Cr c 76- Os o 86- Rn r 68+ Er r 99- Es e 21+ Sc c 69- Tm t 91 Pa pa 38- Sr s 51- Sb s 74 W w 42+ Mo o 86- Rn r 48+ Cd d 100- Fm f 8 O o 103+ Lr</description></item><item><title>Net-Force: level702 - What am I :-)</title><link>https://koyo.kr/post/net-force-level702/</link><pubDate>Tue, 04 Aug 2015 20:12:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/net-force-level702/</guid><description>문제의 페이지. 다운로드 받은 파일의 헤더는 PK이다. 난 이걸 메모장에서 확장자만 바꿔서 저장했는데 그거 때문인지 파일이 변경되서 한참을 못풀었다. 손상된 zip 복</description></item><item><title>Net-Force: level701 - Hey, where are you from?</title><link>https://koyo.kr/post/net-force-level701/</link><pubDate>Tue, 04 Aug 2015 15:40:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/net-force-level701/</guid><description>HTTP 헤더의 내용이 위 세 가지 요건을 충족하면 답을 줄 것이다. 패킷을 확인해보자. GET /challenge/level701/ HTTP/1.1 Host: net-force.nl Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.130 Safari/537.36 OPR/30.0.1835.125 Accept-Encoding: gzip, deflate, lzma, sdch Accept-Language: ko-KR,ko;q=0.8,en-US;q=0.6,en;q=0.4 Cookie: locksessionip=no; autologinid= 이렇게 패킷이</description></item><item><title>Net-Force: level705 - Hmm I don&#39;t see it...</title><link>https://koyo.kr/post/net-force-level705/</link><pubDate>Mon, 03 Aug 2015 17:12:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/net-force-level705/</guid><description>Flash Login에 이어서 2번째 문제이다. 이번 건 쉬웠다. 문제의 페이지. 점자로 써진 게 보인다. 아래 주소에서 한 글자씩 대조해 텍스트를 작성하면 점자 발명가의 이</description></item><item><title>Net-Force: level703 - Flash Login</title><link>https://koyo.kr/post/net-force-level703/</link><pubDate>Mon, 03 Aug 2015 16:37:00 +0900</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/post/net-force-level703/</guid><description>플래시 파일에서 로그인을 해야되는 것 하다. 소스는 봐도 별 거 없다. 틀리면 ACCESS DENIED가 뜬다. 카테고리가 인터넷이니까 와이어샤크로 캡쳐 뜨면 될 거라고 생각</description></item><item><title>About me</title><link>https://koyo.kr/page/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>koyo@koyo.kr (koyo)</author><guid>https://koyo.kr/page/about/</guid><description>뭐하세요 공군 정보보호병 뭐했어요 전남대학교 전자컴퓨터공학부 컴퓨터정보통신공학전공 (휴학) 전남대학교 동아리 정보보호119 준회원 차세대 보안리더 양성</description></item></channel></rss>