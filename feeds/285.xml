<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Sehwa Na on Medium]]></title>
        <description><![CDATA[Stories by Sehwa Na on Medium]]></description>
        <link>https://medium.com/@nsh235482?source=rss-78ce402e7db5------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*iJFbB_sm7VIG3TWf7vSsww.jpeg</url>
            <title>Stories by Sehwa Na on Medium</title>
            <link>https://medium.com/@nsh235482?source=rss-78ce402e7db5------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 13 May 2019 02:07:17 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@nsh235482" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[[컴퓨터구조] Cache란?]]></title>
            <link>https://medium.com/@nsh235482/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-cache%EB%9E%80-2060ca01d98?source=rss-78ce402e7db5------2</link>
            <guid isPermaLink="false">https://medium.com/p/2060ca01d98</guid>
            <dc:creator><![CDATA[Sehwa Na]]></dc:creator>
            <pubDate>Sun, 14 Apr 2019 09:55:09 GMT</pubDate>
            <atom:updated>2019-04-14T09:55:09.380Z</atom:updated>
            <content:encoded><![CDATA[<ol><li><strong>캐시 메모리</strong></li></ol><p>캐시 메모리(cache memory)는 처리 속도가 빠른 CPU와 상대적으로 느린 메인 메모리 사이에서 데이터나 정보를 저장하는 메모리이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/893/1*4eKW3Vk-vsMmXBPNbPy81w.png" /></figure><p>캐시 메모리가 가운데 위치함으로써 느린 메모리 때문에 발생하는 성능저하를 줄일 수 있다.</p><p>2. <strong>캐시의 장점</strong></p><p>캐시는 메인 메모리에서 일정 블록의 데이터를 가져온다. 이를 워드 단위로 CPU에 빠르게 전달한다. 또한 데이터가 이동할 수 있는 대역폭을 확대하여 CPU와 메모리 사이의 속도차이를 줄이는 역할을 한다.</p><p><strong>3. 캐시의 동작 원리</strong></p><p>캐시는 기본적으로 메인 메모리에서 정보를 가져와 저장할 때, ‘태그’라는 것과 ‘주소’를 같이 저장한다. 이 때 ‘태그’는 메인 메모리의 몇 번째 블록에 데이터가 위치하는지 알려주는 역할을 한다.</p><p>CPU는 메인 메모리에 접근이 필요하게 되면 먼저 캐시를 조사한다. 그 후에 캐시 태그와 메모리 주소의 태그 영역을 비교해서 원하는 블록을 찾는다. 캐시에 데이터가 존재할 경우 캐시는 CPU에서 요청한 데이터를 읽어서 CPU로 전달한다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2060ca01d98" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[맞네요 감사합니다 :)]]></title>
            <link>https://medium.com/@nsh235482/%EB%A7%9E%EB%84%A4%EC%9A%94-%EA%B0%90%EC%82%AC%ED%95%A9%EB%8B%88%EB%8B%A4-d9b90797963f?source=rss-78ce402e7db5------2</link>
            <guid isPermaLink="false">https://medium.com/p/d9b90797963f</guid>
            <dc:creator><![CDATA[Sehwa Na]]></dc:creator>
            <pubDate>Sun, 14 Apr 2019 09:39:57 GMT</pubDate>
            <atom:updated>2019-04-14T09:39:57.803Z</atom:updated>
            <content:encoded><![CDATA[<p>맞네요 감사합니다 :)</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d9b90797963f" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[JAVA] 프로그래머스 : Hash Lv1. 완주하지 못한 선수]]></title>
            <link>https://medium.com/@nsh235482/java-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-hash-lv1-%EC%99%84%EC%A3%BC%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%9C-%EC%84%A0%EC%88%98-1ddf416516ad?source=rss-78ce402e7db5------2</link>
            <guid isPermaLink="false">https://medium.com/p/1ddf416516ad</guid>
            <dc:creator><![CDATA[Sehwa Na]]></dc:creator>
            <pubDate>Sun, 11 Nov 2018 08:23:13 GMT</pubDate>
            <atom:updated>2018-11-11T08:23:13.024Z</atom:updated>
            <content:encoded><![CDATA[<h3>[JAVA] 프로그래머스 : Hash Lv1. 완주하지 못한 선수</h3><h3><strong>[문제]</strong></h3><p>수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.</p><p>마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.</p><p>제한사항</p><ul><li>마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.</li><li>completion의 길이는 participant의 길이보다 1 작습니다.</li><li>참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.</li><li>참가자 중에는 동명이인이 있을 수 있습니다.</li></ul><h3>[알고리즘]</h3><ul><li>풀이</li></ul><p>이 문제는 participant 배열과 completion 배열의 관계를 잘 생각해보면 금방 풀 수 있는 문제였다. participant에는 참여한 모든 선수들의 이름이 다 들어가있고, completion에는 완주한 선수들의 이름이 들어가 있는데, 둘의 배열 길이의 차가 1밖에 되지 않는다. (완주 못한 선수는 항상 1명) 따라서 각 배열을 순서대로 정렬하여 세로로 나란히 놓았을 때, 일치하지 않는 인덱스의 선수를 return 하면 된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*l0JnBoemM-5cC-MzrtHVPQ.png" /></figure><p>위의 예시를 보자. 위와 같이 participant 배열과 completion 배열이 주어졌다면, completion 배열에 존재하지 않는 Vinko가 완주하지 못한 선수이다. 이를 찾아내려면, 두 배열을 오름차순으로 정리하면 쉽게 찾을 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*jeVxEoaTEOTRLW7y6wp_tA.png" /></figure><p>위와 같이 오름차순으로 정리하면, 해당 인덱스끼리 비교하여 완주를 했는지 안했는지 쉽게 찾을 수 있다. 위의 예시에서는 Vinko만 일치하는 것이 없으므로 Vinko만 return 해주면 된다.</p><ul><li>전체 코드</li></ul><pre>import java.util.Arrays;</pre><pre>class Solution {<br>    public String solution(String[] participant, String[] completion) {<br>        String answer = &quot;&quot;;<br>        String temp = &quot;&quot;;<br>        <br>        Arrays.sort(participant);<br>        Arrays.sort(completion);<br>        <br>        int i = 0;<br>        <br>        while(i &lt; completion.length){<br>            if(!completion[i].equals(participant[i])){<br>                temp = participant[i];<br>                break;<br>            }else{<br>                i++;<br>            }<br>        }<br>        <br>        if(!temp.equals(&quot;&quot;)){<br>            answer = temp;<br>        }else{<br>            answer = participant[participant.length-1];<br>        }<br>        <br>        return answer;<br>    }<br>}</pre><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1ddf416516ad" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[JAVA CODING] Programmers : Stack/Queue Lv2. 쇠막대기]]></title>
            <link>https://medium.com/@nsh235482/java-coding-programmers-stack-queue-lv2-%EC%87%A0%EB%A7%89%EB%8C%80%EA%B8%B0-d3c482da3d98?source=rss-78ce402e7db5------2</link>
            <guid isPermaLink="false">https://medium.com/p/d3c482da3d98</guid>
            <category><![CDATA[java]]></category>
            <category><![CDATA[coding]]></category>
            <category><![CDATA[algorithms]]></category>
            <dc:creator><![CDATA[Sehwa Na]]></dc:creator>
            <pubDate>Fri, 26 Oct 2018 00:35:29 GMT</pubDate>
            <atom:updated>2018-11-11T08:23:39.967Z</atom:updated>
            <content:encoded><![CDATA[<h3>[JAVA] 프로그래머스 : Stack/Queue Lv2. 쇠막대기</h3><h3>[문제]</h3><p>여러 개의 쇠막대기를 레이저로 절단하려고 합니다. 효율적인 작업을 위해서 쇠막대기를 아래에서 위로 겹쳐 놓고, 레이저를 위에서 수직으로 발사하여 쇠막대기들을 자릅니다. 쇠막대기와 레이저의 배치는 다음 조건을 만족합니다.</p><pre>- 쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있습니다.<br>- 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓습니다.<br>- 각 쇠막대기를 자르는 레이저는 적어도 하나 존재합니다.<br>- 레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않습니다.</pre><p>아래 그림은 위 조건을 만족하는 예를 보여줍니다. 수평으로 그려진 굵은 실선은 쇠막대기이고, 점은 레이저의 위치, 수직으로 그려진 점선 화살표는 레이저의 발사 방향입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/512/0*5qy-LnmAu3WnI7Ea.png" /></figure><p>이러한 레이저와 쇠막대기의 배치는 다음과 같이 괄호를 이용하여 왼쪽부터 순서대로 표현할 수 있습니다.</p><pre>(a) 레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 &#39;()&#39;으로 표현합니다. 또한 모든 &#39;()&#39;는 반드시 레이저를 표현합니다.<br>(b) 쇠막대기의 왼쪽 끝은 여는 괄호 &#39;(&#39;로, 오른쪽 끝은 닫힌 괄호 &#39;)&#39;로 표현됩니다.</pre><p>위 예의 괄호 표현은 그림 위에 주어져 있습니다.<br>쇠막대기는 레이저에 의해 몇 개의 조각으로 잘리는데, 위 예에서 가장 위에 있는 두 개의 쇠막대기는 각각 3개와 2개의 조각으로 잘리고, 이와 같은 방식으로 주어진 쇠막대기들은 총 17개의 조각으로 잘립니다.</p><p>쇠막대기와 레이저의 배치를 표현한 문자열 arrangement가 매개변수로 주어질 때, 잘린 쇠막대기 조각의 총 개수를 return 하도록 solution 함수를 작성해주세요.</p><p>제한사항</p><ul><li>arrangement의 길이는 최대 100,000입니다.</li><li>arrangement의 여는 괄호와 닫는 괄호는 항상 쌍을 이룹니다.</li></ul><h3>[알고리즘]</h3><h4>-1. 풀이</h4><p>이 문제는 스택 자료구조로 해결할 수 있다. 레이저를 만나면 그 전까지 쌓인 막대기들이 잘리기 때문에, 그 전까지 쌓인 막대기들의 개수를 알면 잘린 토막의 개수를 알 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/585/1*ubKkMnldzf8TpOAkOcqVSw.png" /></figure><p>‘(‘가 쌓이다가 레이저를 만나면 해당 막대기들은 잘리기 때문에, 토막난 막대기의 수를 알 수 있다. 그러나 이대로만 가면 빠지는 부분이 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/591/1*IDxODW_2WXdu5UrxRVT2pA.png" /></figure><p>위 그림에서 초록색으로 표시한 부분, 즉 막대기의 끝 부분이 빠지게 된다. 따라서 ‘(‘ 를 만나면 +1을 해주어야 한다.</p><h4>-2. 코딩</h4><pre>String copyArray = arrangement.replace(&quot;()&quot;, &quot;0&quot;);<br>int answer = 0;</pre><p>우선 레이저를 제대로 알아보기 위해, String으로 주어진 arrangement에서 ‘()’를 ‘0’으로 바꿔준다. 그리고 반환할 값(answer, 토막난 막대기 수)을 초기화 시켜준다.</p><pre>ArrayList&lt;Character&gt; copy = new ArrayList&lt;Character&gt;();<br>        <br>for(int i = 0; i &lt; copyArray.length(); i++){              copy.add(copyArray.charAt(i)); }</pre><p>새로운 ArrayList(copy)를 만들어서 문자열을 쪼개서 값을 넣어준다.</p><pre>ArrayList&lt;Character&gt; stack = new ArrayList&lt;Character&gt;();<br>        <br>for(int i = 0; i &lt; copy.size(); i++){<br>    if(copy.get(i) == &#39;(&#39;){<br>        stack.add(copy.get(i));<br>    }else if(copy.get(i) == &#39;)&#39;){<br>        stack.remove(stack.size()-1);<br>            answer += 1;<br>        }else if(copy.get(i) == &#39;0&#39;){<br>            answer += stack.size();<br>        }<br>    }</pre><p>새로운 ArrayList(stack)를 만들고, copy ArrayList에서 ‘(‘를 만나면 stack ArrayList에 쌓는다. ‘0’을 만날 경우, 레이저이므로 그동안 쌓인 ‘(‘의 개수를 answer(토막난 막대기 수)에 더해준다. ‘)’를 만날 경우, 막대기의 끝이므로 +1을 해주고, 맨위에 쌓인 ‘(‘를 빼준다.</p><ul><li>전체 코드</li></ul><pre>import java.util.*;<br>class Solution {<br>    public int solution(String arrangement) {<br>        String copyArray = arrangement.replace(&quot;()&quot;, &quot;0&quot;);<br>        int answer = 0;<br>        <br>        ArrayList&lt;Character&gt; copy = new ArrayList&lt;Character&gt;();<br>        <br>        for(int i = 0; i &lt; copyArray.length(); i++){ copy.add(copyArray.charAt(i)); }<br>        <br>        ArrayList&lt;Character&gt; stack = new ArrayList&lt;Character&gt;();<br>        <br>        for(int i = 0; i &lt; copy.size(); i++){<br>            if(copy.get(i) == &#39;(&#39;){<br>                stack.add(copy.get(i));<br>            }else if(copy.get(i) == &#39;)&#39;){<br>                stack.remove(stack.size()-1);<br>                answer += 1;<br>            }else if(copy.get(i) == &#39;0&#39;){<br>                answer += stack.size();<br>            }<br>        }<br>        return answer;<br>    }<br>}</pre><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d3c482da3d98" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[JAVA CODING] Programmers : Hash Lv3. 베스트 앨범]]></title>
            <link>https://medium.com/@nsh235482/java-coding-programmers-hash-lv3-%EB%B2%A0%EC%8A%A4%ED%8A%B8-%EC%95%A8%EB%B2%94-278fa3ad4d9c?source=rss-78ce402e7db5------2</link>
            <guid isPermaLink="false">https://medium.com/p/278fa3ad4d9c</guid>
            <category><![CDATA[coding]]></category>
            <category><![CDATA[java]]></category>
            <category><![CDATA[programmer]]></category>
            <dc:creator><![CDATA[Sehwa Na]]></dc:creator>
            <pubDate>Thu, 18 Oct 2018 14:57:49 GMT</pubDate>
            <atom:updated>2018-11-11T08:24:19.403Z</atom:updated>
            <content:encoded><![CDATA[<h3>[JAVA] 프로그래머스 : Hash Lv3. 베스트 앨범</h3><h3>[문제]</h3><p>스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다. 노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다.</p><ol><li>속한 노래가 많이 재생된 장르를 먼저 수록합니다.</li><li>장르 내에서 많이 재생된 노래를 먼저 수록합니다.</li><li>장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다.</li></ol><p>노래의 장르를 나타내는 문자열 배열 genres와 노래별 재생 횟수를 나타내는 정수 배열 plays가 주어질 때, 베스트 앨범에 들어갈 노래의 고유 번호를 순서대로 return 하도록 solution 함수를 완성하세요.</p><p>제한사항</p><ul><li>genres[i]는 고유번호가 i인 노래의 장르입니다.</li><li>plays[i]는 고유번호가 i인 노래가 재생된 횟수입니다.</li><li>genres와 plays의 길이는 같으며, 이는 1 이상 10,000 이하입니다.</li><li>장르 종류는 100개 미만입니다.</li><li>장르에 속한 곡이 하나라면, 하나의 곡만 선택합니다.</li><li>모든 장르는 재생된 횟수가 다릅니다.</li></ul><h3>[알고리즘]</h3><p>하.. 이번 문제는 푸는데 정말 힘들었다. 해쉬맵 자체를 사용해 본 적이 별로 없을 뿐더러 효율적으로 짜려고 머리를 써보려 했지만.. 역부족이었던 것 같다. 결국 노가다로 승부 본듯 ㅜㅜ</p><p>// 고유번호를 key값으로, 장르와 플레이 횟수를 value 값으로 각각 HashMap을 만들고, HashSet으로 장르의 종류만 뽑아낸다. 그 후, 각 장르별 총 플레이횟수가 얼마나 되는지 계산한 후, 총 플레이 횟수를 key값으로 장르를 value값으로 하는 HashMap을 생성한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*JDI6c89IbdbkI-C_7l3rwg.png" /></figure><pre>//고유번호 = key값 &amp; 장르, 플레이횟수 = value값<br>        HashMap&lt;Integer, Integer&gt; pMap = new HashMap&lt;Integer, Integer&gt;();<br>        HashMap&lt;Integer, String&gt; gMap = new HashMap&lt;Integer, String&gt;();<br>        for(int i = 0; i &lt; genres.length; i++){<br>            pMap.put(i, plays[i]);<br>            gMap.put(i, genres[i]);<br>        }<br>        <br>        //HashSet으로 장르 분류<br>        HashSet&lt;String&gt; gSet = new HashSet&lt;String&gt;();<br>        <br>        for(int i = 0; i &lt; genres.length; i++){<br>            gSet.add(genres[i]);<br>        }<br>        <br>        //장르별 총 플레이 횟수<br>        HashMap&lt;Integer, String&gt; coPlay = new HashMap&lt;Integer, String&gt;();<br>        for(String x : gSet){<br>            int count = 0;<br>            for(int i = 0; i &lt; gMap.size(); i++){<br>                if(gMap.get(i).equals(x)){<br>                    count+= pMap.get(i);<br>                }<br>            }<br>            coPlay.put(count, x);<br>        }</pre><p>//총 플레이 횟수를 key값으로 장르를 value값으로 하는 HashMap을 생성한 후, 이를 key값(총 플레이 횟수)를 기준으로 정렬한다. (정렬할 때는 TreeMap 사용)</p><p>//후에, 순서대로 String형의 배열에 넣는다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/951/1*zyHmt8df1CrwShntL0Xx0A.png" /></figure><pre>//플레이 횟수 별로 정렬(키 값을 기준으로 정렬, TreeMap)<br>        TreeMap sort = new TreeMap(coPlay);<br>        String[] sortGenre = new String[gSet.size()];<br>        int index = 0;<br>        for(Object o : sort.keySet()){<br>            sortGenre[index] = sort.get(o).toString();<br>            index++;<br>        }</pre><p>//생성된 String 배열에 들어있는 역순으로 장르 별 고유번호를 찾고, 찾은 고유번호로 플레이 횟수 HashMap을 검색하여, 해당 장르의 플레이 횟수를 담은 임시 배열을 만든다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*gJyXW8w3yTR6qv4sr0YR7g.png" /><figcaption>▲ Pop 장르 탐색 예시</figcaption></figure><p>//임시 배열의 값들을 오름차순으로 정렬하고(Arrays.sort() 사용) 배열의 맨 끝과, 끝에서 두번째 값들만 뽑아낸다. 그 후, 해당 값들을 가지고 있는 key를 찾아 ArrayList에 순서대로 추가한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*wKIgjY1lAPoerDMTDwGiKg.png" /><figcaption>▲ Pop 장르 탐색 예시</figcaption></figure><p>Pop장르만 예시로 들어서 설명했지만, 코드를 보면 전체 장르를 반복문을 돌며 순서대로 fIndex에 삽입한다.</p><pre>//장르별 많이 플레이 된 노래의 고유번호 찾기<br>        ArrayList&lt;Integer&gt; fIndex = new ArrayList&lt;Integer&gt;();<br>        for(int i = sortGenre.length-1; i &gt;= 0; i--){<br>            int count = 0;<br>            for(int p1 : gMap.keySet()){<br>                if(sortGenre[i].equals(gMap.get(p1))){<br>                    count++;<br>                }<br>            }<br>            <br>            int[] temp = new int[count];<br>            int k = 0;<br>            for(int p2 : gMap.keySet()){<br>                if(sortGenre[i].equals(gMap.get(p2))){<br>                    temp[k] = pMap.get(p2);<br>                    k++;<br>                }<br>            }<br>            <br>            if(temp.length != 1){<br>                Arrays.sort(temp);</pre><pre>for(int j = temp.length - 1; j &gt;= temp.length - 2; j--){<br>                    for(int p : pMap.keySet()){<br>                        if(temp[j] == pMap.get(p)){<br>                            fIndex.add(p);<br>                            pMap.put(p, 0);<br>                            break;<br>                        }<br>                    }<br>                }                <br>            }else{<br>                for(int p : pMap.keySet()){<br>                    if(temp[0] == pMap.get(p)){<br>                        fIndex.add(p);<br>                        pMap.put(p, 0);<br>                        break;<br>                    }<br>                }                <br>            }</pre><pre>}</pre><p>//ArrayList를 일반 배열로 복사하여 return한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/670/1*YyL25TpYEPh52uBmx6E-EQ.png" /></figure><pre>int[] answer = new int[fIndex.size()];<br>        <br>        for(int i = 0; i &lt; fIndex.size(); i++){<br>            answer[i] = fIndex.get(i);<br>        }<br>        <br>        return answer;</pre><ul><li>전체 코드</li></ul><pre>import java.util.*;</pre><pre>class Solution {<br>    public int[] solution(String[] genres, int[] plays) {<br>        <br>        //고유번호 = key값 &amp; 장르, 플레이횟수 = value값<br>        HashMap&lt;Integer, Integer&gt; pMap = new HashMap&lt;Integer, Integer&gt;();<br>        HashMap&lt;Integer, String&gt; gMap = new HashMap&lt;Integer, String&gt;();<br>        for(int i = 0; i &lt; genres.length; i++){<br>            pMap.put(i, plays[i]);<br>            gMap.put(i, genres[i]);<br>        }<br>        <br>        //HashSet으로 장르 분류<br>        HashSet&lt;String&gt; gSet = new HashSet&lt;String&gt;();<br>        <br>        for(int i = 0; i &lt; genres.length; i++){<br>            gSet.add(genres[i]);<br>        }<br>        <br>        //장르별 총 플레이 횟수<br>        HashMap&lt;Integer, String&gt; coPlay = new HashMap&lt;Integer, String&gt;();<br>        for(String x : gSet){<br>            int count = 0;<br>            for(int i = 0; i &lt; gMap.size(); i++){<br>                if(gMap.get(i).equals(x)){<br>                    count+= pMap.get(i);<br>                }<br>            }<br>            coPlay.put(count, x);<br>        }<br>        <br>        //플레이 횟수 별로 정렬(키 값을 기준으로 정렬, TreeMap)<br>        TreeMap sort = new TreeMap(coPlay);<br>        String[] sortGenre = new String[gSet.size()];<br>        int index = 0;<br>        for(Object o : sort.keySet()){<br>            sortGenre[index] = sort.get(o).toString();<br>            index++;<br>        }<br>        <br>        //장르별 많이 플레이 된 노래의 고유번호 찾기<br>        ArrayList&lt;Integer&gt; fIndex = new ArrayList&lt;Integer&gt;();<br>        for(int i = sortGenre.length-1; i &gt;= 0; i--){<br>            int count = 0;<br>            for(int p1 : gMap.keySet()){<br>                if(sortGenre[i].equals(gMap.get(p1))){<br>                    count++;<br>                }<br>            }<br>            <br>            int[] temp = new int[count];<br>            int k = 0;<br>            for(int p2 : gMap.keySet()){<br>                if(sortGenre[i].equals(gMap.get(p2))){<br>                    temp[k] = pMap.get(p2);<br>                    k++;<br>                }<br>            }<br>            <br>            if(temp.length != 1){<br>                Arrays.sort(temp);</pre><pre>for(int j = temp.length - 1; j &gt;= temp.length - 2; j--){<br>                    for(int p : pMap.keySet()){<br>                        if(temp[j] == pMap.get(p)){<br>                            fIndex.add(p);<br>                            pMap.put(p, 0);<br>                            break;<br>                        }<br>                    }<br>                }                <br>            }else{<br>                for(int p : pMap.keySet()){<br>                    if(temp[0] == pMap.get(p)){<br>                        fIndex.add(p);<br>                        pMap.put(p, 0);<br>                        break;<br>                    }<br>                }                <br>            }</pre><pre>}<br>        <br>        int[] answer = new int[fIndex.size()];<br>        <br>        for(int i = 0; i &lt; fIndex.size(); i++){<br>            answer[i] = fIndex.get(i);<br>        }<br>        <br>        return answer;<br>    }<br>}</pre><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=278fa3ad4d9c" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[Android] 액티비티 생명주기]]></title>
            <link>https://medium.com/@nsh235482/android-%EC%95%A1%ED%8B%B0%EB%B9%84%ED%8B%B0-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0-893c872c72ae?source=rss-78ce402e7db5------2</link>
            <guid isPermaLink="false">https://medium.com/p/893c872c72ae</guid>
            <category><![CDATA[android]]></category>
            <dc:creator><![CDATA[Sehwa Na]]></dc:creator>
            <pubDate>Wed, 08 Aug 2018 10:16:30 GMT</pubDate>
            <atom:updated>2018-08-08T10:16:30.868Z</atom:updated>
            <content:encoded><![CDATA[<ul><li>액티비티란?</li></ul><p>안드로이드에서 액티비티(Activity)는 어플리케이션 컴포넌트이다. 쉽게 말하자면, 우리가 사용하는 스마트폰 어플리케이션에서 보이는 화면 하나 하나가 ‘액티비티’이다. 액티비티에는 사용자 인터페이스(UI)가 들어가게 된다.</p><p>사용자들이 앱을 사용할 때 화면 하나하나를 전환할 때 마다 액티비티는 실행, 일시중지, 중지의 상태를 가진다.</p><p>액티비티가 ‘실행’의 상태에 있는 경우는 스마트폰 화면 상에 액티비티가 현재 보이고 있는 상태를 의미한다. ‘일시중지’의 경우, 사용자에게 액티비티가 보이긴 하지만 다른 액티비티에 포커스가 가있는 경우이다. ‘중지’의 경우 다른 액티비티가 실행되고 있어 해당 액티비티가 보이지 않는 상태이다.</p><p>아무래도 액티비티의 상태는 사용자에게 보이는지 안보이는지에 따라 결정되는 것 같다. 그렇다면 액티비티는 어떤 구조로 사용자에게 보이게 될까?</p><p>답은 ‘스택(Stack)’이다. 스택은 특정 데이터가 메모리에 쌓이는 구조를 갖는다. 즉 먼저 들어온 순서대로 아래에서 위로 쌓이게 되어 데이터가 빠져나갈 때는 가장 나중에 쌓여서 가장 위에 있는 데이터가 가장 먼저 빠져나가게 되는 것이다. 이를 후입 선출 구조라고 한다. 액티비티는 이 스택에 열린 순서대로 쌓이게 된다.</p><p>따라서 가장 먼저 열린 액티비티가 ‘실행’ 상태에 있다가 어떤 동작에 의해 다른 액티비티가 열려서 화면에 다른 액티비티가 보이게 된다면 ‘실행’ 상태에 있던 액티비티는 ‘중지’ 상태로 바뀌게 되고 열린 액티비티가 ‘실행’ 상태로 바뀌게 된다. 메모리에는 먼저 열린 액티비티가 아래에 있고 그 위에는 현재 ‘실행’ 상태에 있는 액티비티가 쌓여서 화면 상에 보이게 되는 것이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/88/1*MKY9CJsvOB-tmAHKn6d5IA.png" /><figcaption>액티비티가 쌓인 모습</figcaption></figure><ul><li>생명주기?</li></ul><p>위에서 본 것 처럼, 액티비티는 메모리에 들어가서 소멸되기까지의 ‘생명주기’를 가지고 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/513/0*BfQEQmegVqapd5NK" /><figcaption>액티비티의 생명 주기</figcaption></figure><p>액티비티가 처음 실행되면 onCreate() 메소드가 호출된다. 이후에 onStart(), onResume() 메소드를 거치면 실행상태가 된다. 다른 액티비티가 스택에 쌓여 상위에 오게 되면 onPause()가 호출되고, onStop()이 호출되어 중지상태로 바뀐다. 이후, 액티비티가 소멸될 경우 onDestroy()가 호출되어 액티비티가 메모리에서 사라진다.</p><ul><li>onCreate()</li></ul><p>onCreate() 메소드는 액티비티가 생성될 때 호출되어, 액티비티 내의 모든 요소들을 이 메소드 내에서 초기화 시킬 수 있다. UI 레이아웃을 코드 상으로 동작하게 하기 위하여 setContentView()를 통해 정의해주는 메소드도 이 메소드이다.</p><ul><li>onStart()</li></ul><p>onStart() 메소드는 액티비티가 화면에 보이기 직전에 호출되는 메소드이다.</p><ul><li>onResume()</li></ul><p>onResume() 메소드는 액티비티가 화면 상에 보여지게 되면서 사용자로부터 어떠한 동작도 받지 않았을 때 호출 된다.</p><ul><li>onPause()</li></ul><p>사용자가 해당 액티비티를 다른 액티비티로 전환 시킬 때 보내는 첫번 째 신호이다. 만약 화면을 전환하기 전 저장되지 않은 데이터가 있다면 사용자가 이 액티비티로 돌아오지 않을 것을 우려하여 이 메소드가 호출될 때 저장할 수 있다.</p><ul><li>onStop()</li></ul><p>액티비티가 더 이상 사용자에게 보이지 않을 때 호출되는 메소드이다. 다른 액티비티로 전환 시 스택에 다른 액티비티가 쌓여 가려지게 되면 호출된다.</p><ul><li>onDestroy()</li></ul><p>액티비티가 종료될 때 호출되는 메소드이다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=893c872c72ae" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[Python] Machine Learning의 용어와 개념]]></title>
            <link>https://medium.com/@nsh235482/python-machine-learning%EC%9D%98-%EC%9A%A9%EC%96%B4%EC%99%80-%EA%B0%9C%EB%85%90-d1dada22690e?source=rss-78ce402e7db5------2</link>
            <guid isPermaLink="false">https://medium.com/p/d1dada22690e</guid>
            <category><![CDATA[machine-learning]]></category>
            <category><![CDATA[python]]></category>
            <dc:creator><![CDATA[Sehwa Na]]></dc:creator>
            <pubDate>Fri, 03 Aug 2018 07:15:06 GMT</pubDate>
            <atom:updated>2018-08-03T07:15:06.697Z</atom:updated>
            <content:encoded><![CDATA[<p><em>본 포스팅은 edwith BoostCourse에서 ‘머신러닝을 위한 파이썬’ 강의를 듣고 한 포스팅입니다.</em></p><p>머신러닝이란?</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*MYFtNJOcXM2ZXB7JwD0lyA.png" /></figure><p>머신러닝이란 기존에 있던 데이터를 어떤 알고리즘에 사용해서 모델을 만들고, 새로운 데이터를 모델에 적용시켜 예측을 하는 방법이다.</p><ol><li>Example</li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/714/0*3MvSBXFydAKptD4Q.png" /><figcaption>왓챠 ‘보고싶어요’ 수로 옥자 관객수 예측</figcaption></figure><p>왓챠의 ‘보고싶어요’ 개수를 가지고 총 관객수를 예측한 사례가 있다. 기존에 있던 데이터인 마션, 킹스맨, 시빌 워, 인터스텔라의 ‘보고싶어요’ 개수와 새로운 데이터인 옥자의 ‘보고싶어요’수로 옥자의 총 관객 수를 머신러닝 기법 중 하나인 ‘회귀 분석’으로 예측했다. 위 그래프를 보면 선형인 것을 알 수 있는데, 흔히 선형이라고 하면 y = ax + b와 같은 형태로 표현할 수 있다. 여기서 x는 ‘보고싶어요’ 수일 것이고, y는 총 관객수 일 것이다. 우리는 여기서 a와 b가 궁금한 것이다.</p><p>2. Key concepts</p><p>Model?</p><p>모델이라는 것은 예측을 위한 수학 공식, 함수, 1차 방정식, 확률분포 등등을 말한다. 위에서 본 y = ax + b와 같은 것이 모델이다.</p><p>Algorithms?</p><p>알고리즘은 어떠한 문제를 풀기 위한 과정인데, 모델을 생성하기 위한 과정이라고도 볼 수 있다.</p><p>3. 모델을 학습할 때 영향을 주는 것들</p><p>y = ax + b에서 x는 주어진 x 값, 즉 독립 변수이고 y는 주어진 y값, 즉 종속변수이다. 우리는 a와 b를 알고리즘을 통해 최적값을 찾아야한다.</p><p>4. Y값에 영향을 주는 X값은 하나인가?</p><p>실제로 y = ax + b 그 자체를 보면 x값 하나에 따라서 y의 값은 변화한다. 그러나 실제로 데이터를 가지고 모델을 만들 때는, y값에 영향을 주는 x값은 하나가 아닐 수 있다. 보통은 여러 개의 x값에서 영향을 받아 y값에 영향을 주게 된다. 예를 들어, 영화의 흥행을 예측한다고 생각하면 영화의 흥행 요소는 여러 가지 일 수 있다. 배우가 얼마나 유명하 배우인지, 마케팅을 얼마나 잘 했는지, 감독이 유명한 감독인지 등등 흥행값에 영향을 주는 요소는 상당히 많다. 우리는 실제로 데이터 분석을 할 때 이런 요인들과 많이 마주칠 것이다. 그래서 1 이상의 x 변수, 1개의 y 변수가 있다고 하면 x변수의 실제 데이터를 feature라고 한다. feature는 머신러닝에서 데이터의 특징을 나타내는 변수이다. 통계에서는 feature를 독립변수라고 부르기도 하고, 컴퓨터공학에서는 input 변수라고 부르기도 한다. 이들은 모두 동일한 의미로 사용된다. 일반적으로 데이터 테이블 상에 column을 feature라고 보면 된다.</p><p>5. Feature Vector</p><p>그래서 결국 우리가 컴퓨터로부터 알아내고자 하는 것은, 여러개의 x 변수와 하나의 y변수가 있을 때, 그 앞에 계수를 알아내는 것이다. 앞에서 봤던 y = ax + b에서 a와 b를 알아내는 것이다. 이것은 feature vector로 컴퓨터가 알아내서 모델을 만들어내게 된다. 그래서 우리가 x와 x 앞의 계수들을 리스트 형태로 넣어줄 수 있으면 y의 값을 알아 낼 수 있다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d1dada22690e" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[Python] 문자의 벡터화와 유사성]]></title>
            <link>https://medium.com/@nsh235482/python-%EB%AC%B8%EC%9E%90%EC%9D%98-%EB%B2%A1%ED%84%B0%ED%99%94%EC%99%80-%EC%9C%A0%EC%82%AC%EC%84%B1-5a45bdf8d918?source=rss-78ce402e7db5------2</link>
            <guid isPermaLink="false">https://medium.com/p/5a45bdf8d918</guid>
            <category><![CDATA[python]]></category>
            <category><![CDATA[machine-learning]]></category>
            <dc:creator><![CDATA[Sehwa Na]]></dc:creator>
            <pubDate>Fri, 03 Aug 2018 06:49:04 GMT</pubDate>
            <atom:updated>2018-08-03T06:49:04.386Z</atom:updated>
            <content:encoded><![CDATA[<blockquote>본 포스팅은 edwith BoostCourse에서 ‘머신러닝을 위한 파이썬’ 강의를 듣고 한 포스팅입니다.</blockquote><p>사실, 컴퓨터는 문자를 그대로 이해하지 못한다. 그래서 문자를 컴퓨터에게 알맞은 방식으로 알려줘야한다. 보통은 컴퓨터에게 문자를 숫자로 바꿔서 알려주게된다. 그 숫자를 컴퓨터에게 알려주는 방법은 많다. 그렇다면 컴퓨터에게 ‘유사하다’라는 표현을 어떻게 숫자로 알려줄 수 있을까?</p><p>‘유사하다’라는 것은 좌표평면 상에서 봤을 때 ‘가깝다’고 말할 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/532/1*NzBkWEcvU6T8uf8JXV66ZA.png" /></figure><p>위 그림에서 보았을 때, (1,2)에 있는 점은 거리 상으로 (2,1)에 있는 점과 거리상으로 가장 가깝다. 그러므로 컴퓨터는 위의 점들을 인식 했을 때, (1,2)와 가장 유사한 점은 (2,1)일 것이라고 생각할 것이다.</p><p>‘가깝다’라고 말하기 위해서는 숫자를 좌표평면에 올려놨듯이, 숫자를 벡터화를 시켜주어야 가까운지 안가까운지를 알 수 있다. 사실 위에서도 (1,2)라는 벡터와 (2,1)이라는 두 2차원 벡터상에서 계산하여 두 점이 가깝다고 이야기 한 것이다.</p><ol><li>문자를 Vector로 바꾸기 — One hot Encoding</li></ol><p>일반적으로 많이 쓰는 방법은 One hot Encoding이다. 하나의 단어를 Vector의 인덱스로 인식하고 단어가 존재하면 1, 없으면 0으로 넣는 방식이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/707/1*lG6_Wpql_Jby6sMQTJEkJg.png" /></figure><p>각 문서마다 글자가 얼마나 있는지 벡터 표현을 만들어 주는 것이다.</p><p>2. 문자를 Vector로 바꾸기 — Bag of words</p><p>Bag of words는 단어별로 인덱스를 부여해서, 한 문장(또는 문서)의 단어의 개수를 vector로 표현하는 것이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/602/1*yowigeTvbSCmWAv2024MNw.png" /></figure><p>위 사진에서 are, cat, dog, is… 등등을 우리는 corpus라고 부른다. corpus는 문서에서 나오는 모든 단어들을 갖고 있고, 이 단어들의 인덱스들도 가지고 있다. 위 사진에서는 0 : are, 1: cat, 2: dog와 같은 dict형식으로 가지고 있게 된다. 그러므로 Bag of words 방식에서는 하나의 문장이나 문서에 대해서 단어들이 얼마나 출현했는지를 알 수 있다.</p><p>3. 유사성 측정</p><p>유사성을 재는 방법도 여러가지가 있다. 위에서도 언급했듯이 컴퓨터에게 ‘유사하다’라는 것은 ‘가깝다’라는 뜻이기 때문에 여러 element 사이의 거리를 재는 방법이 곧 유사성을 측정하는 방법이 될 것이다.</p><p>1)Euclidian distance</p><p>가장 대표적인 것으로 우리가 중학교 때부터 배웠던 두 점사이의 직선이 거리를 재는 피타고라스의 정리가 있다. 사실 이거는 말 안해도 대부분 아는 내용일 것이다.</p><p>2)Cosine distance</p><p>유클라디안 거리가 두 점사이의 거리를 구하는 것이었다면, 코사인 거리는 두 점 사이의 ‘각도’를 재는 것이다. 두 점사이의 각도를 구해서 각도가 얼마나 벌어졌는지를 cos으로 구해서 얼마나 가까운지 구하는 것이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/963/1*Z1cf5vqDUV-JFqSahnlpZQ.png" /></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5a45bdf8d918" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[Python] Linear algebra codes]]></title>
            <link>https://medium.com/@nsh235482/python-linear-algebra-codes-5e45592cdcaa?source=rss-78ce402e7db5------2</link>
            <guid isPermaLink="false">https://medium.com/p/5e45592cdcaa</guid>
            <category><![CDATA[python]]></category>
            <dc:creator><![CDATA[Sehwa Na]]></dc:creator>
            <pubDate>Fri, 03 Aug 2018 06:15:34 GMT</pubDate>
            <atom:updated>2018-08-03T06:23:39.821Z</atom:updated>
            <content:encoded><![CDATA[<blockquote>본 포스팅은 edwith BoostCourse에서 ‘머신러닝을 위한 파이썬’ 강의를 듣고 한 포스팅입니다.</blockquote><p>간단한 선형대수의 여러가지 기법들을 파이썬 코드로 표현할 수 있다.</p><ol><li>Vector representation of python</li></ol><p>파이썬에서 Vector를 표현하는 방법은 다양하다. 대표적으로 list, tuple, dict 타입이 있다. 기본적으로는 list로 표현한다. 그래서 list로 vector 연산을 실시해본다.</p><p>Vector의 덧셈</p><pre>u = [2, 2]<br>v = [2, 3]<br>z = [3, 5]<br><br>result = [sum(t) in zip(u, v, z)]<br>print(result)</pre><p>zip을 사용해 같은 인덱스에 있는 값들을 덧셈을 하여 출력을 해주는 코드다.</p><p>Vector의 계산 : Scala-Vector product</p><pre>u = [1, 2, 3]<br>v = [4, 5, 6]<br>alpha = 2<br><br>result = [alpha*sum(z) for z in zip(u, v)]<br>print(result)</pre><p>스칼라와 벡터가 같이 나왔을 경우에는 벡터 값을 계산해 준 후에 스칼라 값을 연산해주는 방식으로 계산할 수 있다. 위의 코드에서 보면 u벡터와 v 벡터를 zip으로 값을 꺼내와서 더한 값에 alpha, 즉 2를 곱해준 값을 출력하게 된다. 처음에는 1,4가 꺼내져서 더한 값인 5가 나오고 거기에 alpha인 2가 곱해져 10이 출력될 것이다. 그 다음도 똑같이 연산되어 출력될 것이다.</p><p>2. Matrix representation of python</p><p>Matrix 역시 파이썬으로 표시하는 다양한 방법이 존재한다.</p><p>Matrix의 덧셈</p><pre>matrix_a  = [[3, 6], [4, 5]]<br>matrix_b  = [[5, 8], [3, 7]]<br><br>result = [[sum(row) for row in zip(*t)] for t in zip(matrix_a, matrix_b)]<br><br>print(result)</pre><p>위의 zip을 사용해서 matrix끼리 덧셈을 하는 코드이다. 처음 zip으로 묶이는 애들은 ([3,6], [5,8])로 묶인다. 그런데 *t이므로 unpacking이 되서 [3,6]과 [5,8]로 나누어진다. 이후 unpacking된 값끼리 연산을 하게 된다.</p><p>Matrix Transpose</p><pre>matrix_a = [[1, 2, 3], [4, 5, 6]]<br>result = [[element for element in t] for t in zip(*matrix_a)]<br><br>print(result)​</pre><p>matrix_a에 *를 붙여주고 그 부분을 zip으로 묶으면 처음에 1과 4가 들어간다. 그리고 2,5가 들어가고 마지막에 3,6이 들어간다. 따라서 element가 Transpose되서 들어가게 된다.</p><p>Matrix Product</p><pre>matrix_a = [[1, 1, 2], [2, 1, 1]]<br>matrix_b = [[1, 1], [2, 1], [1, 3]]<br>result = [[sum(a * b for a, b in zip(row_a, column_b))<br>          for column_b in zip(*matrix_b)] for row_a in matrix_a]<br>print(result)​</pre><p>행렬의 곱셈은 왼쪽 행렬의 row와 오른쪽 행렬의 column의 element들을 곱해서 그 값들을 모두 더해주는 연산이다. 따라서 이걸 구현할때도 먼저 matrix_a에서 row값을 가져오고 B의 column값을 가져오려면 zip을해서 가져오면 된다. 그래서 각각 가져온 값들을 또 zip하여 element들을 뽑아서 각각 곱한 후에 sum으로 더해준다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5e45592cdcaa" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[Python] Data Structure — Collections]]></title>
            <link>https://medium.com/@nsh235482/python-data-structure-collections-70b8bf5660af?source=rss-78ce402e7db5------2</link>
            <guid isPermaLink="false">https://medium.com/p/70b8bf5660af</guid>
            <category><![CDATA[python]]></category>
            <dc:creator><![CDATA[Sehwa Na]]></dc:creator>
            <pubDate>Thu, 02 Aug 2018 18:04:55 GMT</pubDate>
            <atom:updated>2018-08-03T06:22:54.556Z</atom:updated>
            <content:encoded><![CDATA[<blockquote>본 포스팅은 edwith BoostCourse에서 ‘머신러닝을 위한 파이썬’ 강의를 듣고 한 포스팅입니다.</blockquote><p>파이썬 코드에서 제공해주고 있는 자료구조에 대한 기본적인 모듈들을 파이썬에서는 Collection에서 다 포함을 하고 있다.</p><ul><li>from collections import deque</li><li>from collections import Counter</li><li>from collections import OrderedDict</li><li>from collections import defaultdict</li><li>from collections import namedtuple</li></ul><ol><li>deque</li></ol><p>deque는 스택과 큐를 지원하는 모듈이다. List에 비해서 효율적인 자료 저장 방식을 지원한다. 속도면에서 확실히 빠르다. 효율적 메모리 구조로 처리 속도가 향상 되었다.</p><pre>deque_list.appendleft(10)<br>deque_list.rotate(2)<br>reversed(deque_list)<br>deque_list.extend([5,6,7])<br>deque_list.extendleft([5,6,7])</pre><p>위는 deque 모듈에서 지원해주는 함수들이다.</p><p>2. OrderedDict</p><p>Dict와는 다르게 데이터를 입력한 순서대로 Dict를 반환한다. Dict 타입은 데이터를 저장한 순서대로 저장하지 않기 때문에 순서대로 출력하지 않는다. OrderedDict를 사용하면 순서대로 저장하여 출력한다. value 혹은 key값으로 정렬할 때 Dict 보다는 OrderedDict를 쓰는게 좋다.</p><p>3. DefaultDict</p><p>Dict 타입에 기본 값을 지정해준다. 아무것도 없는 신규값을 생성시 사용하는 방법이다.</p><pre>d = defaultdict(lambda: 0) #Default 값을 0으로 설정함</pre><p>초기값이 없이 뭔가를 사용하게 될 때, DefaultDict를 사용하면 좋다.</p><p>4. Counter</p><p>Counter는 시퀀스형 자료형에 있는 element 갯수를 세서 dict 형태로 반환한다.</p><pre>c = Counter()<br>c = Counter(&#39;gallahad&#39;)<br>print(c)</pre><p>각 키마다 몇개가 있는지 세주고, 정렬까지 한다. 위 코드의 결과는 다음과 같다.</p><pre>Counter({&#39;a&#39;: 3, &#39;l&#39;:2, &#39;g&#39;:1, &#39;d&#39;:1, &#39;h&#39;:1})</pre><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=70b8bf5660af" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>