<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Kim, min tae on Medium]]></title>
        <description><![CDATA[Stories by Kim, min tae on Medium]]></description>
        <link>https://medium.com/@ibare?source=rss-e1f2be6f801------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/0*suWfRdGPcwiq48hE.jpeg</url>
            <title>Stories by Kim, min tae on Medium</title>
            <link>https://medium.com/@ibare?source=rss-e1f2be6f801------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Tue, 14 May 2019 09:02:55 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@ibare" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[프로그래밍 — 단순한 기능, 기능의 결합, 의미의 부여]]></title>
            <link>https://medium.com/ibare-story/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%8B%A8%EC%88%9C%ED%95%9C-%EA%B8%B0%EB%8A%A5-%EA%B8%B0%EB%8A%A5%EC%9D%98-%EA%B2%B0%ED%95%A9-%EC%9D%98%EB%AF%B8%EC%9D%98-%EB%B6%80%EC%97%AC-1d4ab9d59415?source=rss-e1f2be6f801------2</link>
            <guid isPermaLink="false">https://medium.com/p/1d4ab9d59415</guid>
            <dc:creator><![CDATA[Kim, min tae]]></dc:creator>
            <pubDate>Mon, 01 Sep 2014 01:54:32 GMT</pubDate>
            <atom:updated>2015-01-09T01:52:31.546Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/794/1*Vbv0y2AvLsL7mTAvvf7A2Q.png" /></figure><h2>프로그래밍 — 단순한 기능, 기능의 결합, 의미의 부여</h2><p>쉬운 설명을 위해 사칙연산을 하는 함수를 하나씩 만들어볼께요.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/986fc3e53d388e9da83d419e3bcb29f4/href">https://medium.com/media/986fc3e53d388e9da83d419e3bcb29f4/href</a></iframe><p>두 수를 입력으로 받고 덧셈(add), 뺄셈(sub), 곱셈(multi), 나눗셈(div)을 하여 그 결과를 반환(return)하는 아주 간단한 함수들을 만들었어요. 한번 사용해볼까요?</p><p>3과 4를 더하고 싶다면?</p><pre>add(3, 4); // 결과는 7</pre><p>3에서 4를 빼고싶다면?</p><pre>sub(3, 4); // 결과는 -1 이되겠죠?</pre><p>이렇게 너무나 간단한 일만하는 함수(기능)들은 서로 연관성이 전혀 없고 그 자체로는 어떠한 유연성도 제공하지 못합니다.</p><p>3+10+100 을 add 함수를 사용해서 수행할 수 있을까요? add 함수는 입력으로 두 개의 수 만을 받습니다. 3+10+100은 세 개나 되네요? 이런, 멍청한 함수 덕분에 저런 간단한 작업도 할 수 없네요. 어떻게 하면 될까요?</p><p>add 함수가 세개의 입력을 받도록 수정해봅시다.</p><pre>function add(a, b, c) { return a + b + c; }</pre><p>자, 이제 3+10+100을 add 함수로 해볼까요?</p><pre>add(3, 10, 100) // 결과는 당연히 113이 나오겠지요?</pre><p>그럼 다시 3+4를 해볼까요?</p><pre>add(3, 4, 0);</pre><p>두 개의 값 만을 더하려하니 세 개의 입력을 받도록 수정된 add 함수의 세 번째 인수에 0을 넣는 트릭을 써야만하네요. 영 마음에 들지 않습니다. 그렇죠?</p><p>이번엔 3+10+100+200+300 을 해볼까요? 이번엔 3개가 아니라 다섯개의 숫자를 더해야합니다. add 함수를 다시 수정해야할까요? 그런 방법도 있겠지만 적은 수의 합을 구할 때는 안쓰는 자리수에 0을 채워넣는 지저분한 문제가 더 크게 부각되겠죠?</p><p>이렇게 특정한 요구사항에 정확히 일치하는 기능은 작은 요구사항 변경에도 대응하기 힘든 문제점을 가지고 있습니다. 무수히 많은 기능을 만들거나 다른 방법을 찾거나 해야합니다.</p><p>새로운 방법으로 이 문제를 해결해 봅시다. 문제 해결의 실마리는 바로 기능의 “조합”입니다.</p><p>add 함수는 원래 대로 두 개의 값을 더하는 기능으로 변경해 놓도록 하겠습니다. 그리고 add 와 add 를 조합하여 원하는 결과를 얻어보는 것이지요.</p><p>3+10+100 을 해볼까요? add 는 값을 두개만 받지요?</p><pre>add(3, 10); </pre><p>100을 더하지 못했습니다. 어떻게 할까요?</p><pre>add( add(3, 10), 100 );</pre><p>코드를 잘 보세요. 바깥쪽 add의 인수는 두개입니다. 첫 번째 인수는 add(3, 10)이고 두 번째 인수는 100 입니다. 첫 번째 인수인 add 함수의 결과가 먼저 실행되어 결과 13을 반환합니다. 반환된 13을 바깥쪽 add 함수의 첫번째 인수로 사용하는 것이지요.</p><p>이건 사실 이렇게 표현한것과 동일합니다.</p><pre>add(3+10, 100);</pre><p>다만 사칙 연산자가 아니라 함수라는 것으로 표현한 것 뿐이죠.</p><p>이 간단한 규칙. 두 수를 합하여 결과를 반환하는 함수를 조합할 수 있다는 것 만으로 모든 가변 인수의 처리가 가능합니다. add 함수의 수정 없이 말이죠.</p><p>3+10+100+200+300 을 해볼까요?</p><pre>add( add( add( add(3, 10), 100 ), 200), 300 );</pre><p>좀 길어보일 뿐이지 같은 원리입니다.</p><p>이제 좀더 문제를 확장하여 3+10*100–5 를 해봅시다.</p><p>덧셈 뿐만 아니라 곱셈과 뺄셈까지 조합되어있네요? 우리에겐 같은 방식으로 만들어 놓은 각각의 함수들이 있습니다. (맨 위 참조) 조합할 수 있다는 원칙을 그대로 적용해 문제를 풀어봅시다.</p><pre>sub( multi( add(3, 10), 100), 5);</pre><p>이렇게 되겠지요? 코드를 찬찬히 잘 살펴보시면 같은 방식이라는걸 아실 수 있습니다. 재미있는건 덧셈 함수와 뺄셈 함수, 곱셈 함수들은 서로 전여 연관성이 존재하지 않습니다.</p><p>이를 의존성이 없다고 얘기하기도 해요. 서로 완전히 독립적이지요. 이렇게 의존성 없는 독립된 녀석들을 조합(결합)하여 새로운 일을 해결하는 방식을 “직교성”이라고 합니다.</p><p>직교성을 이용하면 굉장히 유연하게 원하는 일들을 할 수 있어요. 어떤 요구사항에 맞춘 새로운 기능을 만드는 것이 아닌, 독립되게 작동하지만 기능들을 조합할 수 있다면 원하는 목적을 달성할 수 있는 것이죠.</p><p>10+10*100/2, 100*100/2 … 뭐든 사칙연산은 다 처리가 가능하게 되었습니다. 즉, 요구 사항이 계속 바뀐다해도 add, sub, multi, div 함수는 변경하지 않아도 되는 것입니다. 규칙은 연산을 위한 최소한의 입력만을 받고, 그 결과를 돌려준다. 그리고 그 이상의 확장이 필요하면 조합하여 문제를 해결한다로 정리할 수 있겠습니다.</p><p>지금 까지의 내용으로 우리가 알 수 있는 사실 한가지는 함수에 기능이 추가될 수록 즉, 하는 일이 많아질 수록 아이러니하게도 유연성은 떨어지게 되어있습니다. 함수는 가능하다면 한가지 일만 하도록 만들어야하는 이유가 여기에 있습니다.</p><p>자, 그런데 문제가 하나 있습니다. 사람은 단순한 원리로 동작된다고 해도 시각적으로 복잡해 보이면 어려워하는 경향이 있습니다.</p><pre>add( add( add( add(3, 10), 100 ), 200), 300 );</pre><p>이 코드가 원리는 단순하지만 굉장히 난해해 보이고 복잡해 보이고 그렇지요? 눈에도 잘 들어오지 않습니다. 이건 학습자의 수준 문제가 아닙니다. 그저 인간의 특성입니다.</p><p>어떻게 해야할까요?</p><p>작은 기능들을 조합하여 조금 더 복잡해 보이는 기능을 만드는 방식을 사용해봅시다. 여기서 중요한 것은 조금 더 <strong>인간다움을 더한다</strong>는 것입니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/4ec10ca64f619616e128c968176f9b62/href">https://medium.com/media/4ec10ca64f619616e128c968176f9b62/href</a></iframe><p>입력값 하나를 받고 그 값의 두배가 되는 값을 반환하는 함수 double 을 만들었습니다. 10 의 두배 값을 얻으려면 다음과 같이 사용하면 되겠죠?</p><pre>double(10);</pre><p>double함수 내부는 기존에 만들어놓은 add 함수를 그대로 사용합니다. 물론 add를 사용하여 똑같이 해도 되겠지요?</p><pre>add(10, 10);</pre><p>두개를 비교해 보세요. 어떤 방식이 10의 두 배 값을 구한다는 의미를 좀 더 잘 전달하나요?</p><p>입력값의 1/4 값을 반환하는 함수를 만들어볼까요?</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/a6cc715bd6c4bc6ad376035e62812981/href">https://medium.com/media/a6cc715bd6c4bc6ad376035e62812981/href</a></iframe><p>12달의 1분기 값 즉, 1쿼터를 구해볼까요?</p><pre>quarter(12); // 3이 되겠지요?</pre><p>나눗셈 함수를 사용해볼까요?</p><pre>div(12, 4);</pre><p>어떤가요? 결과는 같지만 의미 관점에선 quarter 함수가 훨씬 이해하기 쉽지요?</p><p>이렇게 조금 더 의미를 더하여 이해할 수 있는 방식으로 단순화 시키는 것을 “추상화”라고 합니다. 추상화의 단계도 같은 방식으로 여러 겹을 만들어 낼 수 있습니다. div 를 감싸서 quarter 란 함수로 추상화 한 것 처럼 말이죠. quarter 함수를 감싸서 더 높은 수준의 추상화된 함수를 만들 수 있습니다.</p><p>매우 단순하지만 이렇게 단순한 방식을 계속 발전시켜 나아가는 것. 그것이 프로그래밍이라는 것입니다. 이런 방식이 계속 발전되어 객체지향이라는 것도 나오고, 디자인 패턴이라는 것도 나오게됩니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1d4ab9d59415" width="1" height="1"><hr><p><a href="https://medium.com/ibare-story/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%8B%A8%EC%88%9C%ED%95%9C-%EA%B8%B0%EB%8A%A5-%EA%B8%B0%EB%8A%A5%EC%9D%98-%EA%B2%B0%ED%95%A9-%EC%9D%98%EB%AF%B8%EC%9D%98-%EB%B6%80%EC%97%AC-1d4ab9d59415">프로그래밍 — 단순한 기능, 기능의 결합, 의미의 부여</a> was originally published in <a href="https://medium.com/ibare-story">ibare story</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[자바스크립트의 함수]]></title>
            <link>https://medium.com/ibare-story/e252506f8525?source=rss-e1f2be6f801------2</link>
            <guid isPermaLink="false">https://medium.com/p/e252506f8525</guid>
            <dc:creator><![CDATA[Kim, min tae]]></dc:creator>
            <pubDate>Fri, 25 Jul 2014 07:42:19 GMT</pubDate>
            <atom:updated>2014-09-02T00:45:23.653Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/697/1*mHuQf9yDePLzAfmoIGaIhQ.png" /></figure><blockquote>자바스크립트는 유연함, 모호함, 이상한, 흥미로움 등이 극적으로 뒤섞인 언어다. 가장 많이 쓰이면서도 가장 많은 불평을 듣는 언어이기도 하고 가장 빠르게 변화하고 있는 언어이기도 하다. <strong>이 글은 그러한 자바스크립트의 많은 요소 중 특히 흥미로운 “함수”에 대한 개인적인 정리다.</strong></blockquote><h3><strong># 함수 정의</strong></h3><p>함수는 다음과 같이 작성한다. 보통의 프로그래밍 언어와 마찮가지로 함수명과 인수 그리고 함수가 실행할 코드 블럭으로 구성된다. return 문으로 값을 반환할 수 있다. 명시적 return 문이 없을 경우 undefined를 반환한다. 따라서 모든 함수는 값을 반환한다.</p><pre>function foo (x, y) {<br>  var z = x + y;<br>  <br>  return z; // 생략시 undefined 반환<br>}</pre><p>함수 호출시 자바스크립트는 함수의 인수 전달을 느슨하게 처리하며 호출 자체는 언제나 성공한다. 이는 함수 호출 순간 런타임 오류를 발생시키지 않음을 의미한다.</p><pre>function foo(x, y) { … }<br> <br>foo(10, 20); // 성공<br>foo(10); // 성공<br>foo(); // 성공<br>foo(10, 20, 30, 40); // 성공</pre><p>사양에 명시된 인수가 호출시 전달되지 않을 경우 undefined 값이 할당된다. 이런 느슨한 인수 전달 메커니즘을 이해하고 전달된 인수의 값 검증을 습관화하면 런타임 오류 가능성을 줄일 수 있다.</p><pre>function(x, y) {<br>  if(x === undefined || y === undefined) {<br>    throw new Error(“인수 x, y 필요”);<br>  }<br> <br>  return x + y;<br>}</pre><h3><strong># 가변 인수</strong></h3><p>함수의 사양보다 많이 전달된 인수는 함수 호출과 함께 유사 배열 arguments 에 담겨 전달된다. arguments 에는 언제나 전달된 모든 인수가 왼쪽부터 오른쪽 순서대로 담겨진다.</p><pre>function foo(x, y) {<br>  (x === arguments[0]); // true<br>  (y === arguments[1]); // true<br>  <br>  return arguments.length;<br>}<br> <br>foo(10, 20); // 2<br>foo(); // 0<br>foo(10, 20, 30, 40); // 4</pre><p>함수 호출시 언제나 제공되는 arguments로 매우 유연하게 가변 인수를 처리 할 수 있다.</p><pre>// 전달된 인수의 합을 반환하는 함수<br>function add() {<br>  var sum= 0; <br>  <br>  for(var i=0; i&lt;arguments.length; i++) {<br>    sum += (typeof arguments[i] === ‘number’) ?<br>            arguments[i] : 0;<br>  }<br> <br>  return sum;<br>}<br> <br>add(); // 0<br>add(10, 20, 30); // 60<br>add(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); // 55<br>add(1, 2, ‘3&#39;); // 3</pre><h3><strong># 객체로서의 함수</strong></h3><p>자바스크립트에서 원시 데이타 타입을 제외한 거의 모든 것은 객체다. 함수 또한 객체이며 객체와 같이 속성과 메소드를 가질 수 있다.</p><pre>// 아무것도 하지 않는 함수<br>function empty(x, y) { }<br>console.log(empty.length); // 2</pre><p>아무것도 하지 않는 함수 empty 는 인수 x, y를 가지며 아무일도 하지 않는다. 호출되면 undefined 를 반환하는 쓸모없는 함수다. 그런데 함수 호출이 아닌 empty.length 는 무엇일까? empty 함수의 속성 length 에 접근한다. 함수의 length 속성은 함수 인수 사양의 인수 갯수를 가진다. 함수는 length 속성 외에도 apply, call, bind, name, prototype, toString 등 다양한 속성과 메소드를 가지고있는 완벽한 객체다. 자바스크립트의 함수는 호출되거나 인스턴스를 만들거나 하는 특별한 기능을 가진 객체임을 알 수 있다.</p><h3><strong># 함수의 속성 및 메소드</strong></h3><p>원한다면 언제든 함수에 속성을 추가할 수 있다.</p><pre>function foo() { }<br> <br>foo.location = ‘seoul’;<br>console.log(foo.location); // seoul;</pre><p>속성을 추가할 수 있는 것을 이용하여 단 한번만 실행되는 신기하지만 쓸데없는 함수를 만들어 보자. 아래 double 함수는 단 한번만 자신이 할 일을 수행하고 그 이후에 모든 호출시 할 일을 하지 않는다.</p><pre>// 단 한번만 할 일을 하는 게으른 함수 double<br>function double(x) {<br>  if(!double.isCall) {<br>    double.isCall = true;<br>  } else {<br>    return undefined;<br>  }<br> <br>  return x * x;<br>}<br> <br>double(10); // 100<br>double(20); // undefined<br>double(30); // undefined</pre><p>좀더 파괴적인(?) 방법으로 단 한번만 할 일을 하는 게으른 double 함수를 바꿔보자.</p><pre>function double(x) {<br>  double = function() {};<br> <br>  return x * x;<br>}<br> <br>double(10); // 100<br>double(20); // undefined<br>double(30); // undefined</pre><p>호출되는 순간 double 함수를 재정의한 후 반환한다. 이 쓸모없는 예제는 함수가 스스로를 재정의 할 수 있는 유연성을 제공한다는 것 하나 만큼은 확실히 알려준다.</p><p>이제 조금 쓸모있을 것 같은 예제를 하나 보자. 몇 번 호출됐는지 스스로 기억하는 함수다.</p><pre>function double(x) {<br>  if(!double.callCount) {<br>    double.callCount = 1;<br>  } else {<br>    double.callCount++;<br>  }<br> <br>  return x * x;<br>}<br> <br>for(var i=1; i&lt;=100; i++) {<br>  double(i);<br>}<br> <br>console.log(double.callCount); // 100</pre><h3><strong># 함수에 포함된 함수</strong></h3><p>자바스크립트의 함수는 함수 또한 포함할 수 있다. 아래 코드와 같이 foo 함수 안쪽의 get 함수는 foo 함수 내에서 사용될 수 있다.</p><pre>// 함수 get을 포함하고 있는 foo 함수<br>function foo() {<br>  function get() {<br>    return 100;<br>  }<br> <br>  return get();<br>}<br> <br>foo(); // 100</pre><h3><strong># 인스턴스 생성</strong></h3><p>그렇다면 foo 함수 내의 get 함수를 외부에서 호출할 수 있을까?</p><pre>foo.get(); // undefined is not a function</pre><p>접근할 수 없으며 런타임 오류가 발생한다. 보통의 OOP 언어와 달리 자바스크립트는 객체의 청사진인 클래스를 제공하지 않는다. 그러나 함수가 클래스와 유사한 역할을 제공하며 함수로부터 인스턴스를 생성할 수 있다. 이를 위하 자바스크립트는 new 구문을 제공한다.</p><pre>function Foo(x) {<br>  this.x = x;<br>  this.getX = function () {<br>    return this.x;<br>  };<br>}<br> <br>var foo = new Foo(10);<br> <br>foo.getX(); // 10</pre><p>new 와 함께 호출된 함수는 보통의 함수 호출과는 약간 다르게 작동된다. 호출된 이후 함수는 완료되며 암묵적으로 만들어진 함수의 인스턴스를 반환한다. 클래스와 유사한 목적으로 설계된 함수는 보통의 함수와 구분하기 위해 이름을 대문자로 시작하는 관례를 따른다.</p><h3><strong># this</strong></h3><p>함수 안쪽에서 만들어진 지역 변수들은 함수가 종료되면 함께 삭제된다. 다음의 예제에서 두 함수 foo1 과 foo2 의 차이점을 눈여겨보자.</p><pre>function Foo1() {<br>  var x = 10;<br>}<br> <br>function Foo2() {<br>  this.x = 10;<br>}<br> <br>var foo1 = new Foo1();<br>var foo2 = new Foo2();<br>foo1.x; // undefined<br>foo2.x; // 10</pre><p>Foo1 안쪽의 지역 변수 x 는 인스턴스 생성 시간 동안 존재하며 반환과 함께 사라진다. 이는 함수 호출 동작 방식과 동일하다. 당연히 생성된 인스턴스 foo1 에선 참조할 수 없다. 이미 제거되었기 때문이다. 반면 Foo2의 인스턴스 foo2 에선 x 를 참조할 수 있다. 자바스크립트가 제공하는 인스턴스의 실행 컨텍스트를 가르키는 this 에 생성되었기 때문이다.</p><p>컨텍스트에 작성된 값들은 컨텍스트의 라이프 사이클 동안 유지된다. 따라서 Foo2 의 인스턴스 foo2가 메모리에서 제거되기 전까지 x 값은 유지되며 이것은 보통의 마치 public 멤버 변수와 유사하게 작동된다.</p><h3><strong># 메소드</strong></h3><p>함수의 멤버 함수 즉, 메소드도 같은 원리로 this 에 추가되어야 인스턴스에서 사용할 수 있다.</p><pre>function Foo() {<br>  this.getX = function() {<br>    return 10;<br>  };<br> <br>  function getY() {<br>    return 20;<br>  };<br>}<br> <br>var foo = new Foo();<br> <br>foo.getX(); // 10<br>foo.getY(); // Error!</pre><p>this 에 추가된 멤버 함수 getX 를 인스턴스에서 호출하고 참조할 수 있다는 것을 알 수 있다. 하지만 this에 추가되지 않은 Foo 함수의 안쪽 함수 getY 는 인스턴스에서 참조시 런타임 오류가 발생한다. 지역 변수와 마찮가지로 생성 시점에 함수 안쪽에서만 존재하며 반환과 함께 사라지기 때문이다.</p><h3><strong># prototype</strong></h3><p>함수에 포함된 속성 중 prototype 이라는 특수한 객체가 있다. 함수의 prototype 에 동적으로 속성이나 메소드를 추가할 수 있는데 추가의 영향력은 함수의 모든 인스턴스에 즉시 반영된다. 다음 코드를 보자.</p><pre>function Foo(x) {<br>  this.x = x;<br>}<br> <br>var foo1 = new Foo(10);<br>var foo2 = new Foo(20);<br> <br>foo1.x; // 10<br>foo2.x; // 20<br>foo1.y = 100;<br>foo1.y; // 100<br>foo2.y; // undefined<br> <br>Foo.prototype.z = 1000;<br> <br>foo1.z; // 1000<br>foo2.z; // 1000</pre><p>객체의 인스턴스에 동적으로 추가된 속성은 만들어진 인스턴스에서만 존재하며 prototype 으로 추가된 속성은 이미 만들어진 인스턴스 모두에 실시간으로 반영되는 것을 알 수 있다.</p><blockquote>함수에 직접 추가된 속성은 함수의 생성자로 만들어진 인스턴스에서는 사용할 수 없음을 주의해야한다. 생성자가 만들어낸 인스턴스에서 재새용될 메소드나 속성은 반드시 prototype에 추가한다.</blockquote><h3><strong># 다양한 함수 호출 방식</strong></h3><p>지금까지 보아왔던 것 처럼 함수를 만들고 호출하는 방법은 간단한다.</p><pre>function foo() { };<br> <br>foo(); // 호출!</pre><p>자바스크립트는 몇 가지의 다른 함수 호출 방법을 제공하며 그것은 실행 컨텍스트인 this와 밀접한 관련이 있다.</p><h3><strong># call</strong></h3><p>자바스크립트의 모든 함수는 call, apply 라는 메소드를 가지고 있다. 이 두개의 메소드는 함수를 조금 다른 방식으로 호출할 수 있도록 한다.</p><pre>function foo(x) { };<br> <br>foo(10); // 호출<br>foo.call(this, 10); // 호출<br>foo.apply(this, [10]); // 호출</pre><p>함수 foo 를 호출하는 세 가지 방식 모두 결과는 동일한다. 다른 점은 call과 apply의 첫 번째 인수 this 가 함수에게 전달되는 방식이다. 보통의 OOP 언어와 달리 자바스크립트의 this 는 객체 자체를 가르키는 지시어가 아니다. 지금까지 보아왔던 this 는 마치 그렇게 보였을 뿐이다. 함수가 호출될 때 함수에게 전달되는 모든 인수를 담은 arguments 유사 배열과 함께 this 도 암시적으로 전달된다. this 는 함수를 호출한 컨텍스트를 가르키며 전역 공간에서 호출될 땐 전역 객체를 가르킨다. 브라우저 환경이라면 window 객체와 같다. 객체의 메소드로서 함수가 호출되면 this 는 객체를 가르킨다. 다음 예제를 보자.</p><pre>var person = {<br>  age: 10,<br>  addAge: function(n) {<br>    this.age += n;<br>  }<br>};<br> <br>person.addAge(1);<br>console.log(person.age); // 11</pre><p>객체 person의 메소드인 addAge가 호출되었다. addAge의 this는 암묵적으로 함수 호출시 전달된 객체이며 객체의 메소드인 경우 객체 그 자체가 된다. 이렇게 복잡하게 설명하는 이유는 뭘까? this 는 person이다 라고 설명해도 전혀 문제 없지 않은가? 맞다. 하지만 자바스크립트는 this가 지시하고 있는 대상을 변경할 수 있는 유연성을 제공한다. 다음 코드를 보자.</p><pre>var person = {<br>  age: 10,<br>  addAge: function(n) {<br>    this.age += n;<br>  }<br>};<br> <br>var monkey = {<br>  age: 1<br>};<br> <br>person.addAge.call(monkey, 1);<br> <br>console.log(person.age); // 10;<br>console.log(monkey.age); // 2</pre><p>자바스크립트의 함수라면 모두 가지고 있는 call 메소드로 addAge 함수를 호출했다. 첫 번째 인수는 this 가 아닌 monkey 객체를 넘겨줬다. 무슨일이 일어날까? addAge 함수의 코드는 변경된 것이 없다. 단지 호출 방식을 달리했을 뿐이다. 결과적으로 person 객체의 age 는 변경되지 않고 monkey 객체의 age 가 1 증가하여 2가 되었다. 객체 내부에서 사용하는 this 가 호출시점의 실행 컨텍스트를 가르키며 이는 함수가 어떻게 호출되는가에 따라 this 가 달라질 수 있다는 점을 항상 고려해야한다는 것을 의미한다. this 의 유연함이 가져다 주는 여러가지 장점과 혼란스러운 상황은 함수의 다른 면을 설명하면서 좀 더 다루어 보도록 하자.</p><h3><strong># apply</strong></h3><p>call 과 똑같이 동작하는 apply는 두번째 인수. 즉, 호출할 함수에게 전달할 인수 목록을 배열로 받는다. 호출할 함수가 가변 인수를 받는 함수라면 배열을 전달하는 apply를 사용하면 손쉽게 처리할 수 있다.</p><h3><strong># bind</strong></h3><p>ECMAScript 5 스펙에 추가된 bind 메소드는 함수와 객체를 연결시킨다.</p><h3><strong># 1급 함수</strong></h3><p>자바스크립트는 함수도 변수에 할당할 수 있다. 변수에 담긴 함수는 당연하게도 함수의 인수로 전달될 수 있으며 함수의 반환값이 될 수도 있다. 변수에 할당된 함수의 호출은 일반적인 함수의 호출과 같은 방식으로 작동한다. 대입문으로 생성된 함수는 대입문의 오른쪽에 위치하며 이는 곧 수식으로 평가됨을 의미한다. 따라서 함수의 마지막은 구문 종료 문자 세미콜론이 되어야한다.</p><pre>// 변수에 할당한 함수<br>var foo = function foo() { … };<br> <br>// 변수에 할당된 foo 함수 호출.<br>foo();</pre><h3><strong># 이름 없는 익명 함수</strong></h3><p>자바스크립트에서 함수의 이름의 유무는 선택이다. 함수의 이름이 필요 없다면 기술하지 않아도 된다. 아래 코드는 이름 없는 함수다.</p><pre>// 익명 함수 생성 후 foo 변수에 할당<br>var foo = function(x) {<br>  return x * x;<br>};<br> <br>foo(10); // 100</pre><p>이름 없는 익명 함수를 참조하고 있는 foo 를 이용하여 마치 foo 라는 함수를 호출하는 것과 같은 방식으로 익명 함수를 호출할 수 있다. 함수는 length 속성 이외에 name 속성도 제공한다. name 속성은 함수의 이름을 담고 있다.</p><pre>var foo1 = function orgFoo() { };<br>var foo2 = function() { };<br> <br>console.log(foo1.name); // orgFoo<br>console.log(foo2.name); // 빈문자열</pre><p>위 코드를 보면 익명 함수는 정말로 이름이 없다는 것을 알 수 있다. 익명 함수는 할당된 변수를 통해서만 호출될 수 있다. 익명 함수는 객체의 메소드를 만들 때 많이 사용된다.</p><pre>var foo = {<br>  age: 10,<br>  addAge: function() {<br>    this.age++;<br>  }<br>};</pre><p>위 코드는 객체 foo를 생성하며 addAge 메소드를 작성하며 익명 함수를 사용한다. 이 경우 addAge 속성이 존재함으로 함수의 이름이 불필요하기 때문에 이름이 없는 익명 함수를 사용한다.</p><h3><strong># 즉시 실행 함수</strong></h3><p>간단하게 익명 함수를 생성과 동시에 즉시 실행시킬 수 있다.</p><pre>(function() {<br> …<br>})();</pre><p>이런 형태의 즉시 실행 익명 함수는 단 한번만 수행되며 다시 사용할 수 있는 참조가 없기 때문에 다시는 실행되지 않는다. 단 한번만 수행되는 초기화 작업 등, 전역 공간의 오염 없이 수행하기 위한 방법으로 많이 사용된다.</p><h3><strong># 지역 유효 범위 생성자로서의 함수</strong></h3><p>자바스크립트의 함수는 지역 유효 범위를 만들어낸다. 함수가 생성한 지역 스코프에서 생성된 변수들은 모두 지역 변수가 되어 함수의 라이프 사이클과 함께 유지된다. 함수 내에서 var 구문 없이 생성된 변수는 전역 변수로 생성되며 지역 스코프에 존재하지 않고 함수의 수행이 종료된 후에도 전역 스코프에 잔류한다. 이것이 의도된 설계가 아니라면 메모리는 낭비된다.</p><pre>function foo(x) {<br>  sum = x * x;<br>}<br> <br>foo(10);<br> <br>console.log(sum); // 100</pre><p>함수 안쪽의 함수 또한 지역 스코프를 만들어 내며 이는 지역 스코프가 중첩될 수 있음을 의미한다. 식별자(변수, 함수 등)를 탐색하기 위한 스코프 탐색 메커니즘에 따라 포함된 스코프는 자신을 포함한 상위 스코프의 변수에 접근할 수 있다.</p><pre>function foo() {<br>  var x = 10;<br>  <br>  function getx() {<br>    return x; // 상위 지역 스코프 변수 x를 참조. 10을 반환한다.<br>  }<br>  <br>  return getx();<br>}<br> <br>foo(); // 10</pre><h3><strong># 클로저</strong></h3><p>자바스크립트는 클로저라는 특별한 메커니즘을 제공한다. 클로저는 함수와 함수가 접근 할 수 있는 주변 환경으로 구성된 특별한 개념이다. 클로저를 이해하기 위해 함수 자체를 반환하는 함수를 만들어보자.</p><pre>function multiple() {<br>  var x = 10;<br>  <br>  return function(y) {<br>    return y * x;<br>  };<br>}<br> <br>var mul = multiple();<br> <br>mul(10); // 100<br>mul(5); // 50</pre><p>함수 multiple 는 익명 함수를 반환한다. 반환되는 익명 함수의 바깥 함수 multiple 를 걷어내면 보통의 익명 함수를 할당하는 대입문과 다르지 않다는 것을 알 수 있다.</p><pre>var mul = function(y) {<br>  return y * x;<br>};</pre><p>이 경우 변수 x는 전역 변수다. multiple 함수로 감싼 익명 함수 내의 변수 x는 스코프 체인 메커니즘에 의해 multiple 의 지역 변수 x가 된다. 그런데 multiple 를 호출하고 반환하며 지역 변수 x 는 당연히 소멸되어야한다. 그렇다면 반환된 익명 함수를 호출하여 실행될 때 익명 함수의 안쪽에서 변수 x는 존재할까? 변수 x는 존재하며 그 값은 익명 함수가 반환되는 시점의 x 값인 10이다. 이것을 클로저라한다.</p><p>클로저 패턴을 사용하면 새로운 함수를 동적으로 만들어 낼 수 있다.</p><pre>function multiple(x) {<br>  return function(y) {<br>    return y * x;<br>  };<br>}<br> <br>var mul10 = multiple(10);<br>var mul5 = multiple(5);<br>var mul100 = multiple(100);<br> <br>mul5(10); // 50<br>mul10(10); // 100<br>mul100(10); // 1000</pre><p>클로저를 이용하여 입력한 값의 5배, 10배, 100배 값을 반환하는 함수 mul5, mul10, mul100 이 만들어진 것을 알 수 있다. 바깥 함수의 지역 변수에 접근할 수 있는 클로저의 특징을 이용하면 외부에 노출되지 않는 보호된 변수, private 변수를 흉내 낼 수 있다.</p><pre>function Person(name, age) {<br>  this.getName = function() {<br>    return name;<br>  };<br>  <br>  this.getAge = function() {<br>    return age;<br>  };<br> <br>  this.addAge = function() {<br>    age++;<br>  };<br>}<br> <br>var person = new Person(‘홍길동’, 5);<br> <br>person.getName(); // 홍길동<br>person.getAge(); // 5<br>person.name; // undefined<br>person.addAge();<br>person.getAge(); // 6</pre><h3><strong># 콜백 함수</strong></h3><p>자바스크립트의 함수는 1급 함수로서 변수에 할당될 수 있다. 이는 함수를 함수의 인수로 전달할 수 있다는 것을 의미한다. 함수의 호출이 비동기 방식으로 작동되어야 할 때 이 콜백 함수를 이용할 수 있다. 타이머에 의한 함수 호출이 대표적인 경우다.</p><pre>var count = 1;<br> <br>function sayHello() {<br>  console.log(“Hello?”, count);<br>  count++;<br>}<br> <br>// 첫번째 인수로 함수를 전달한다.<br>// setTimeout은 호출과 함께 즉시 제어권을 반환하고<br>// 10000ms 후에 sayHello를 호출한다.<br>setTimeout(sayHello, 10000);<br> <br>sayHello(); // “Hello? 1&quot; 출력. 10초 후 “Hello? 2&quot; 출력.</pre><p>인수로 받은 함수를 콜백 함수라 한다. 특정 시간 이후에 호출되어야 하거나, 네트워크 자원을 호출하여 반환값을 받는 것, 특정 이벤트가 발생했을 때 호출되어야 하는 함수(이벤트 핸들러)와 같이 함수 호출의 시기를 호출하는 시점에 특정할 수 없을 때 콜백 함수 패턴이 유용하게 쓰일 수 있다.</p><pre>var saveButton = document.getElementById(“save”);<br> <br>// click 이벤트가 발생했을 때 saveDocument 함수가 호출된다.<br>saveButton.addEventListener(“click”, saveDocument);</pre><h3><strong># 콜백 지옥</strong></h3><p>간단한 비동기 작업을 콜백 패턴으로 작성하는 것은 매우 깔끔하고 괜찮은 아이디어지만 비동기 작업이 중첩되는 상황에선 그리 훌륭한 방식이 아니다. 백앤드 자바스크립트인 node 어플리케이션에서 특히 콜백과 콜백이 중첩되는 상황은 자주 발생한다. 비동기가 중첩된 흐름 제어는 코드의 가독성을 떨어뜨리고 테스트를 어렵게 만든다.</p><pre>// 3개의 비동기 콜백이 중첩된 코드 <br>ayncJob(function(err, step1Data) { <br>  ayncJobInner(function(err, step2Data) { <br>    ayncJobDeepInner(function(err, step3Data) { <br>      // create step4Data<br>    });<br>  });<br>});</pre><p>만약 데이타베이스에 3개의 쿼리를 요청한 후 응답 데이타를 가공하여 4번째 데이타를 생성하고 이를 응답으로 보내야한다면 어떤 일이 발생할까? 3개의 쿼리 모두 비동기로 응답이 돌아오며 이는 콜백 함수로 처리해야 한다는 의미다. 실제 수행할 작업은 순서가 필요한 작업이다. 따라서 3개의 비동기 응답을 모두 받기 전까지 대기해야만 4번째 데이타를 받을 수 있고 이는 비동기 방식의 장점을 희석시킨다. 이 간단한 적업을 위해 상당한 노력의 코드를 작성해야한다. 물론 가독성 높은 코드를 작성하기는 더욱 힘들다.</p><h3><strong># 흐름 제어 라이브러리</strong></h3><p>비동기 콜백과 흐름 제어(병렬 실행, 순차 실행)를 구현하기 위해 중첩된 콜백을 사용하지 않아도 되는 여러가지 대안 라이브러리가 존재한다.</p><ul><li>async <a href="https://github.com/caolan/async">https://github.com/caolan/async</a></li><li>step <a href="https://github.com/creationix/step">https://github.com/creationix/step</a></li><li>q <a href="https://github.com/kriskowal/q">https://github.com/kriskowal/q</a></li><li>when <a href="https://github.com/cujojs/when">https://github.com/cujojs/when</a></li><li>RSVP <a href="https://github.com/tildeio/rsvp.js">https://github.com/tildeio/rsvp.js</a></li></ul><h3><strong># Promise &amp; Generator</strong></h3><p>promise 와 generator는 비동기 흐름 제어 코드를 직관적이고 아름답게(?) 작성할 수 있도록 지원하는 자바스크립트의 네이티브 구현이다. ES 6 스펙으로 구현되었으며 극히 일부의 최신 브라우저와 node 에서 동작된다. (ex: chrome 36+, node —harmony) 자세한 내용은 아래 링크를 참조하자.</p><p><strong>JavaScript Promises</strong></p><ul><li><a href="http://www.html5rocks.com/en/tutorials/es6/promises/">http://www.html5rocks.com/en/tutorials/es6/promises/</a></li><li><a href="http://www.html5rocks.com/ko/tutorials/es6/promises/">http://www.html5rocks.com/ko/tutorials/es6/promises/</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e252506f8525" width="1" height="1"><hr><p><a href="https://medium.com/ibare-story/e252506f8525">자바스크립트의 함수</a> was originally published in <a href="https://medium.com/ibare-story">ibare story</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[조금 색다른 오픈소스 Javascript library “bsJS”]]></title>
            <link>https://medium.com/ibare-story/%EC%A1%B0%EA%B8%88-%EC%83%89%EB%8B%A4%EB%A5%B8-%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-javascript-library-bsjs-bd9c2da6954e?source=rss-e1f2be6f801------2</link>
            <guid isPermaLink="false">https://medium.com/p/bd9c2da6954e</guid>
            <dc:creator><![CDATA[Kim, min tae]]></dc:creator>
            <pubDate>Fri, 23 May 2014 07:07:44 GMT</pubDate>
            <atom:updated>2014-05-23T07:25:26.733Z</atom:updated>
            <content:encoded><![CDATA[<p>열거하기도 힘들고 이젠 그 자체가 진부하다 느껴질 만큼 수 많은 자바스크립트 라이브러리가 있다. DOM을 다루는 간단한 라이브러리부터 MVC, MVVM 등 디자인 패턴을 기반으로 UI 컴포넌트까지 모든 것을 제공하는 프레임웍까지 웹 프론트앤드 분야의 뭐시기JS 는 너무 많고, 지금도 계속 만들어지고 있다. 그럼에도 불구하고 시장을 제패한 압도적인 녀석들은 있게 마련이다. jQuery, AngularJS, Bootstrap 등이 그들이다. 이 녀석들 중 특히 독보적인 녀석 <strong>jQuery.</strong> 그 자체로는 DOM 과 Ajax 관련 기능을 제공하는 작고 유용한 라이브러리로 시작했지만 지금은 jQuery 플러그인을 기반으로 광범위한 생태계와 커뮤니티로 무장되어있다. jQuery 와 자바스크립트를 동일시하는 사람이 있을 정도다. jQuery의 아성이 너무 대단하다 보니 상대적으로 이 분야에 도전하는 솔루션은 별로 보이지 않는다. 그야말로 업계에선 천상천하유아독존이다.</p><p>그런데 최근 우연찮게 새로운 녀석을 하나 발견했다. projectBS 라는 오픈소스 프로젝트의 결과물인 bsJS다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/678/1*eN-LvjSgdv7kGScgXMb4pA.png" /><figcaption>github 저장소 상황. 저 유명한 jQuery와의 비교라 bsJS에게는 조금 미안하지만 어쨌든 이런 거다</figcaption></figure><p>bsJS 를 알기위해선 <a href="https://github.com/projectBS/bsJS">bsJS Github 저장소</a>를 방문해야한다. 이 프로젝트의 커미터 대부분이 한국인이기 때문에 저장소의 README 도 한국어로 되어있다. 한글을 쓰는 한국인으로서 이렇게 반가울 수 가 없다. 한국어로 되어있는 JS 라이브러리라니!!</p><p>하지만 기쁨은 거기까지다. 우리가 흔히 새롭게 등장한 뭐시기JS를 볼 땐 늘 아름답거나 센스 넘치는 소개 웹사이트와 손쉽게 시작할 수 있는 Getting Started, 그리고 상세한 API 설명 문서가 동반된다. (이 넘들은 돈이 어디서 나서 밥상이 이렇게 화려하지?? 라는 의문 멈출 수 없다) 하지만 bsJS는 그 흔한 Getting Started 문서 하나 찾기 힘들다. 참조할 수 있는 정보는 github 저장소의 <a href="https://github.com/projectBS/bsJS">README</a> 와 <a href="http://projectbs.github.io/bsShowCase/">Showcase</a> 의 몇 몇 셈플들을 소스 보기 해서 봐야 한다. 물론 저장소에 <a href="https://github.com/projectBS/bsJS/wiki">Wiki</a>가 있긴 하다. 하지만 열정적인 커미터들의 커밋 물량을 이 문서가 따라가질 못하고 있다. 내용이 모호하거나, 현행화 되지 못한 부분들이 매우 많고 셈플 코드도 아직 많이 부족하다.</p><p>상황이 이런데, 왜 bsJS를 사용해볼 마음이 생겼을까? 흔치 않은 bsJS 에 대한 소개 자료의 내용이 흥미를 가지게 만들었기 때문이다.</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.slideshare.net%2Fslideshow%2Fembed_code%2F31240124&amp;url=http%3A%2F%2Fwww.slideshare.net%2Fdeview%2Fd2-project-bs&amp;image=http%3A%2F%2Fcdn.slidesharecdn.com%2Fss_thumbnails%2Fd2projectbs-140215072706-phpapp02-thumbnail-4.jpg%3Fcb%3D1392470849&amp;key=d04bfffea46d4aeda930ec88cc64b87c&amp;type=text%2Fhtml&amp;schema=slideshare" width="425" height="355" frameborder="0" scrolling="no"><a href="https://medium.com/media/5994aa0720c66921874ca06bd31825c4/href">https://medium.com/media/5994aa0720c66921874ca06bd31825c4/href</a></iframe><p>소개자료에서 말한 것 처럼 jQuery 보다 쉽고, 간편하며, 생산성이 정말로 올라가는지 한번 살펴보기로 하자.</p><h3>Getting Started</h3><p>bsJS 는 UI 관련 컴포넌트를 지원하지 않는다. 따라서 bsJS 라이브러리만 로딩하면 바로 사용할 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/955/1*_GGo3X7KSqf5P9gYFKfC6w.png" /><figcaption><a href="http://projectbs.github.io/bsJS/bsjs.0.4.js">http://projectbs.github.io/bsJS/bsjs.0.4.js</a></figcaption></figure><h4>직접 bsJS 저장소를 Clone하여 사용하는 방법</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/829/1*h_UHjzxRvZ30UctAsRN6HA.png" /><figcaption><a href="https://github.com/projectBS/bsJS.git">https://github.com/projectBS/bsJS.git</a></figcaption></figure><h4>Bower 저장소에서 설치하는 방법</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/836/1*b7o8xg2K40E-xwEpHwZz6Q.png" /><figcaption>bower 는 트위터에서 공개한 웹 프론트앤드 패키지저장소 서비스이다.</figcaption></figure><p>bsJS 는 실제 node 에서도 사용 가능하여 <a href="https://www.npmjs.org/package/bsjs">npm</a> 으로 설치하여 사용할 수 도 있지만 이 글에선 웹 프론트앤드만을 범위로 하며 다루지 않겠다. (사실 node에선 써본적이 없다.)</p><h4>기본 사용법</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/851/1*AxUk0mOEMHGbt9IjXTypVQ.png" /><figcaption>bsJS 앱의 기본 사용 형태</figcaption></figure><p>bsJS 스크립트가 포함되어 로딩되면 bs 전역 객체가 생성된다. jQuery 의 $(function() { … }) 형태와 동일하게 html 문서의 onload 이벤트에 바인딩되어 실행된다. myapp 내에서 bs 객체를 사용할 수 있게 된다.</p><h4>간단한 DOM 조작</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/835/1*BfIALdHAHIJPXruylaGxNw.png" /><figcaption>h1 태그를 동적으로 생성하여 body에 추가하는 셈플 코드 jQuery 와 bsJS 의 사용법 차이를 볼 수 있다.</figcaption></figure><p>위 셈플 코드는 동적으로 h1 태그를 생성한 후 body 태그에 추가한다. jQuery 와 bsJS 를 사용하여 작성된 간단한 코드이다. bsJS 와 jQuery 모두 문자열을 기반으로 DOM 객체를 생성할 수 있다. 스타일이 약간 다를 뿐 크게 차이나는 부분이 없는 것을 확인 할 수 있다.</p><p>다음 코드를 보자.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/812/1*pRW3-RTRzUnq50zWSe_vjg.png" /></figure><p>반환된 DOM 객체를 DOM API 를 이용하여 body 에 추가한 이전 셈플과 달리 이번엔 bsJS 와 jQuery 에서 제공하는 기능을 이용하여 직접 body 에 생성된 h1 을 추가해 보았다. 이제 좀 확연한 스타일 차이가 보인다.</p><p>먼저 익숙한 jQuery 방식을 살펴보면 $(‘&lt;h1&gt;jquery&lt;/h1&gt;’) 부분이 $(‘body’) 로 변경된 것을 알 수 있다. append로 추가될 문자열 ‘&lt;h1&gt;jquery&lt;/h1&gt;’을 취한다. 이 코드로 jQuery 는 전달된 문자열에 따라 <strong>DOM 노드를 생성</strong>하기도 하고 <strong>DOM 셀렉터로 작동</strong>되기도 한다는 것을 알 수 있다.</p><p>bsJS를 보자. jQuery 와 달리 선 후 관계가 달라지지 않고 S 라는 함수로 확장된 것을 볼 수 있다. S() 파라메터로 bs 연산자<em>(공식 명칙은 아니다. 이 글에선 이해를 돕기위해 임의로 그렇게 부르도록 하겠다)</em>와 연산값이 짝을 이루는 형태로 사용된다. 위 예제 S(‘&lt;’, ‘body’) 의 의미는 bs.Dom 이 만들어낸 노드를 body 태그의 자식 노드로 추가하라는 것으로 평가된다. 결과적으로 jQuery의 append 와 동일한 동작을 수행한다. 조금 복잡한가? 그렇다면 jQuery 방식으로 코드를 전개시킬 수 도 있을까?</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/799/1*kY50jof_eOwBgvxLsSqcew.png" /></figure><p>약간 다르지만 jQuery 와 동일한 전개 방식으로도 가능하다는 것을 알 수 있다. 즉, bs.Dom() 도 jQuery 와 동일하게 전달된 문자열에 따라 DOM 노드를 생성하기도 하며 DOM 셀렉터로도 동작된다는 것이다.</p><p>하지만 코드의 방식은 jQuery 방식이 훨씬 익숙하고 직관적으로 보인다. <strong>body 를 찾은 후 추가(append) 한다.</strong> 간결하고 직관적이다. bsJS 는 상대적으로 난해해 보인다. body 를 찾은 후 그 뒤는 암호같다. ‘&gt;’ 문자열이 body 의 <strong>하위요소로 추가를 </strong>의미한다는 것을 알기전까진 암호에 가깝다. 이런 방식을 취한 이유는 무엇일까? 분명 어떤 장점이 있으니 직관성을 포기했을 것이라 추측할 수 있다. 그럼 다음 코드를 보자.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/956/1*4lEV0B0v3gCoRhPVhE7YMw.png" /></figure><p>앞서 S() 로 전달하는 파라메터는 bs연산자와 연산값 쌍으로 이루어져있다. 그리고 그 쌍은 원하는 수 만큼 전달 할 수 있다. 위 코드를 보면 .container 노드에 h1 태그를 추가하고 p 태그를 추가한 후 .container 에 인라인 color 스타일이 연속되어 설정된다. 자식 노드 뿐만 아니라 css 스타일도 지정할 수 있다는 것을 알 수 있는데 뿐만 아니라 click 이벤트도 즉시 바인딩 시킬 수 있다. 마지막에 bs.Dom 으로 button 을 추가했다. 당연히 bs.Dom 의 S() 를 이용하여 추가된 button 태그에도 동일한 작업을 반복 수행할 수 있다.</p><p>만약 bs.Dom() 으로 <strong>선택된 노드를 삭제하려 한다면</strong> 어떻게 하면 될까?</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/768/1*XY1naN9wZC8IlZ0zrTCIxQ.png" /></figure><p>그렇다. bs.Dom(‘selector’).remove() 가 아니고 bs.Dom(‘selector’).S(null) 이다. 하나만 더 보자. 만약 선택한 노드가 input[type=text] 이거나 select 같은 <strong>값을 가지고 있는 태그인 경우</strong> 해당 값을 가져오려면 어떻게 해야할까?</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/837/1*vXA4EDeetu3N19jAbU_wxg.png" /></figure><p>S(‘@value’) 로 폼 요소의 값을 가지고 올 수 있다. @value 라는 특이한 형식이 등장했다. S(‘@value’) 는 해당 요소의 타입을 인식하여 값을 반환하는 처리를 일원화해준다. 사용자는 선택된 요소가 콤보박스거나 텍스트박스거나 모두 동일한 인터페이스로 폼 요소의 값에 접근할 수 있다.</p><p>이제 조금 bsJS 에서 말하는 간편함, 생산성 이라는 표현이 어떤 관점에서 사용된 것인지 그 의미를 알 수 있는 것 같다. 개인적으론 <strong>“개발자에 따라 호불호가 갈릴 수 있는 형태&quot;</strong> 라고 생각된다. bsJS 는 bs 의 기본 구조를 정의한 <a href="https://github.com/projectBS/bsJS/wiki/doc1-core">bs core</a>, 템플릿 등 유틸리티 함수를 제공하는 <a href="https://github.com/projectBS/bsJS/wiki/doc2-base-function">bs base function</a>, 지금까지 알아본 <a href="https://github.com/projectBS/bsJS/wiki/doc3-Dom">bs dom</a> 이외에도 애니메이션을 다루는 플러그인 (<em>bs 는 단위 모듈이 대부분 bs core 가 제공하는 플러그인 구조를 따르는 개별 플러그인으로 작성되어있다</em>) 등 초기 버전임에도 불구하고 상당히 광범위한 구성을 제공한다.</p><p>웹 개발 실무를 오랜시간 해온 커미터들의 코드 생산성에 대한 관점이 기존의 유명 라이브러리들과 차별화된 개성을 보여주는 원인인 것 같다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*oFpLO6MAJBAcqJkd9jEUBw.png" /><figcaption>bs.Dom().S()에 미리 정의된 다양한 bs 연산자들.<br>bs의 생산성이 바라보는 방향을 가늠해 볼 수 있다.</figcaption></figure><h3>DOM 셀렉터 엔진 bsSelector</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/300/1*YAtJhyxt4t60Z0FKySXF_g.png" /></figure><p>아무래도 이런류의 라이브러리들(DOM을 다루는)을 선택할 때 고려해야할 것들이 매우 많지만 DOM 을 다루는 부분의 성능은 선택에 있어 중요한 척도가 될 것 같다. bsJS는 DOM 셀렉터 엔진을 자체 개발했다. <a href="https://github.com/projectBS/bsSelector">bsSelector</a>가 그것인데 jQuery 의 셀렉터 엔진으로 유명한 <a href="http://sizzlejs.com/"><strong>Sizzle</strong></a> 같은 역할을 한다고 볼 수 있다. bsJS 와 마찬가지로 projectBS의 서브 프로젝트인 <a href="https://github.com/projectBS/bsSelector">bsSelector</a> 의 저장소에는 (<em>bsJS 와 마찮자기로 소개 웹페이지는 없다</em>.) 눈에 띄는 문구가 있다.</p><blockquote><strong>Beyond the Sizzle.js</strong></blockquote><p>아마도 sizzle 을 경쟁 프로젝트로 보고 있는 것 같다. 셀렉터 엔진은 일반적인 웹 개발자가 평가할만한 요소가 많지는 않다. 어쩌면 딱 세가지 밖에 없을것 같다. “속도&quot; 와 “지원 셀렉터&quot; 그리고 “브라우저별 동작 일관성&quot;. bsSelector는 sizzle 의 벤치마크 페이지를 수정하여 bsSelector 의 성능 측정 지표를 볼 수 있도록 링크를 제공하고 있다.</p><p><a href="http://projectbs.github.io/bsSelector/0.2/speed">http://projectbs.github.io/bsSelector/0.2/speed</a></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*PcSrg1s2LEbofywrcPp9_g.png" /><figcaption>Chrome 34.0 버전에서 돌려본 벤치마크 결과 오른쪽 끝이 bsSelector</figcaption></figure><h3>소개를 마치며</h3><p>bsJS의 존재를 알게된건 몇 달 되었지만, 제대로 만져본건 최근의 일이다. 그렇다고 bsJS 의 대부분을 다뤄본 것 도 아니고 간단한 아이디어의 셈플앱을 만들 때 사용했던 경험이 전부여서 잘못 이해하고 표현한 부분이 있을 수 도 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*gKMu0V9ftpLnQ-psfzXJ1A.png" /><figcaption>bsJS를 사용한 CSS 레이아웃 배치 테스트 웹앱<br><a href="http://codepen.io/ibare/pen/kgaod">http://codepen.io/ibare/pen/kgaod</a></figcaption></figure><p>개인적 성향은 한국인이 만든 오픈소스라고해서 특별히 더 애착을 느끼고 하는건 없는 편이다. 개발자로서 잘 만들어진, 스스로 존재의 객관적 가치를 가지는 것이 옳다고 믿는다. 개인적으로 bsJS는 첫 인상과 다르게 직접 다루어보니 상당히 괜찮은 느낌을 받았고, 웹앱을 만든다면 특히나 애니메이션이나 인터렉션이 강한 웹앱을 만든다면 상당히 훌륭한 도구가 되지 않을까 싶다. (쇼케이스의 데모들도 대부분 애니메이션과 그래픽 관련 셈플들이다.) 커뮤니티도 아직은 규모가 작지만 꽤 활발한 편이고 열정이 느껴진다. 다만 얼마나 많은 사용자와 개발자들이 참여하는가는 오픈소스가 발전할 수 있는 거의 유일한 척도다. 특히나 브라우저와 표준 스펙의 변화가 심한 웹 프론트앤드 시장은 호환성 이슈가 끊없이 발생한다. 커뮤니티의 도움 없이 발전한다는건 불가능에 가깝다. 더 많은 개발자와 사용자들이 참여하여 시장의 한부분 자리를 차지하는 멋진 녀석이 됐으면 좋겠다는 바램이다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=bd9c2da6954e" width="1" height="1"><hr><p><a href="https://medium.com/ibare-story/%EC%A1%B0%EA%B8%88-%EC%83%89%EB%8B%A4%EB%A5%B8-%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-javascript-library-bsjs-bd9c2da6954e">조금 색다른 오픈소스 Javascript library “bsJS”</a> was originally published in <a href="https://medium.com/ibare-story">ibare story</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Architect 기반 Node 앱 개발하기]]></title>
            <link>https://medium.com/ibare-story/architect-%EA%B8%B0%EB%B0%98-node-%EC%95%B1-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0-52c6e5558a6e?source=rss-e1f2be6f801------2</link>
            <guid isPermaLink="false">https://medium.com/p/52c6e5558a6e</guid>
            <dc:creator><![CDATA[Kim, min tae]]></dc:creator>
            <pubDate>Mon, 12 May 2014 07:56:39 GMT</pubDate>
            <atom:updated>2014-05-12T08:09:12.556Z</atom:updated>
            <content:encoded><![CDATA[<h4>클라우드 IDE 서비스인 c9.io 의 오픈소스 버전인 cloud9 IDE. Architect를 이용하여 Node앱의 구조를 Plugin 방식으로 개발하는 방법에 대하여 알아보자.</h4><p>어플리케이션의 규모가 커지고 단일 프로젝트에 참여하는 협업 개발자의 수가 많아 질 수록 코드의 구조에 따른 생산성은 큰 차이를 보일 수 있다. 규모가 커질수록 단위 모듈들은 많아질 수 밖에 없다. 협업자가 많아지면 모듈과 모듈간의 분리가 잘 되어있고 모듈간의 종속 관계 정리가 잘 되어있을 수록 생산성이 올라가는 것은 당연한 일이다. 그러나 쓸만한 아키텍처를 설계하고 발전시켜나간다는 것은 결코 쉬운일이 아니다. 잘못 설계된 아키텍처인 경우 너무 복잡하여 오히려 생산성을 떨어뜨릴 수 있고, 유연성이 부족하여 미래에 문제를 발생시킬 수 있는 위험을 내재할 수 있는 것이다.</p><p>Node.js로 만들어진 어플리케이션의 경우 유연성이 매우 뛰어난 Javascript라는 언어적 특성에 기인하여 다양한 아키텍처를 만들어 낼 수 있다. 그 중 대표적인 클라우드 IDE인 <a href="https://c9.io/">c9.io</a>의 plugin 아키텍처를 셈플과 함께 살펴보고, 간단하지만 확장성 높은 구조의 어플리케이션 개발 방법에 대하여 알아보자.</p><h3>Architect</h3><p><a href="https://github.com/c9/architect">architect</a> 는 오픈소스인 <a href="https://github.com/ajaxorg/cloud9">cloud9 ide</a> 의 플러그인 아키텍처를 구현하기 위한 기반 모듈이다. 여느 node 모듈과 같이 npm 을 통하여 배포되며 만들고자 하는 앱을 plugin 구조로 구성하기 위하여 다음과 같이 간단한 규약을 가지고 있다.</p><h4>단위 plugin</h4><p>각각의 plugin 은 플러그인 정보와 함께 플러그인 소스 파일이 포함된 디렉토리에 존재해야한다. 플러그인의 이름, 버전정보, 종속성 등의 정보는 해당 플로그인 디렉토리내 package.json 으로 존재해야하며 주된 내용은 다음과 같다.</p><p><em>*(주의) npm 의 package.json 과 다른 버전이다. 이름이 같지만 다른 것이라는 것에 주의하자.</em></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/623/1*PC1EBOQ2uMuV-QsJZg5cDw.png" /><figcaption>plugin package.json</figcaption></figure><p><strong>name</strong>은 플러그인의 이름이다. <strong>main</strong> 은 플러그인 본체 소스 파일명이며, <strong>plugin</strong>은 플러그인 실행시 전달될 옵션과 종속성 (Consumes, Providers) 정보를 포함하고 있다.</p><p><strong>main</strong>에 지정된 플러그인 본체는 반드시 <strong>setup</strong> 함수를 구현하고 exports 로 노출해야한다. <strong>setup</strong> 함수는 세개의 파라메터가 전달되며 각각 <strong>options</strong>, <strong>imports</strong>, <strong>register</strong> 이다.</p><p>options 은 package.json 의 plugin 에 기술한 필드가 전달된다. 아래 코드에서와 같이 package.json 의 plugin 에 path 를 기술했다면 해당 플러그인에선 options.path 와 같이 접근할 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/869/1*KOrFWhhQTWt99TzpagzW5Q.png" /><figcaption>plugin 코드 본체 예시</figcaption></figure><p>두번째 파라메터인 imports 에는 package.json 의 plugin 기술 내용 중 consumes 로 정의한 모듈을 imports로 접근할 수 있다. consumes 는 이름에서도 알 수 있듯 arthitect 규약으로 생성한 플러그인 이어야 하며 A 플러그인에서 B 플러그인을 사용할 수 있도록 해주는 방법을 제공한다. A 플러그인이 B 플러그인에서 사용되게 하려면 A는 스스로를 제공(provides) 해야하며, B 플러그인에선 A를 소비(consumes) 한다고 등록해야 한다.</p><p>다른 플러그인에게 기능을 제공하기 위해서 package.json 의 plugin 에 provides 로 해당 플러그인을 명시한다고 다 되는건 아니다. 실제 제공될 모듈 명과 기능(함수)를 구현해야하는데 이는 setup 의 마지막 파라메터인 <strong>register</strong> 를 통해서 할 수 있다. <strong>register</strong>의 두번째 파라메터로 제공될 모듈과 함수를 구현하여 반환하면 cunsumes 한 플러그인 모듈에서 제공된 기능을 사용할 수 있게된다.</p><h4>config.js</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/778/1*6Xvopnq_Iknm-RA2ODMxtw.png" /><figcaption>config.js 예시</figcaption></figure><p>위 예제 config.js 는 architect의 데모 셈플 코드 중 하나인 <a href="https://github.com/c9/architect/tree/master/demos/calculator">Calculator</a>의 config.js 내용이다. node 의 표준 모듈 이며 실행될 플러그인의 목록과 플러그인 실행시 전달될 options 이 기술된다. 프로젝트에 포함된 플러그인이라면 해당 경로를 문자열로 지정한다. 다운로드되어 node_modules 에 존재하는 플러그인이라면 패키지 경로와 전달할 옵션등을 기술하면 된다. 플러그인인 config.js 에 기술된 순서와 동일하게 실행되므로 실행 순서의 의존성이 있는 플러그인이라면 순서에 주의를 기울여야한다.</p><h4>plugin 로딩</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/748/1*Yf40EQsvBbopX9zQnrZLVw.png" /></figure><p>architect.loadConfig 에 config.js 파일을 지정하여 플러그인 카탈로그를 생성하고 architect.createApp에 생성된 카탈로그를 전달하여 플러그인을 실행한다. 예제 코드에서와 같이 architect는 플러그인의 묶음을 App 이라 정의하고 있는 것을 알 수 있다.</p><h3>Architect Express Sample App</h3><p>architect 기반의 플러그인 구조로 작동되는 간단한 셈플앱을 한번 살펴보자. 이 셈플 앱의 코드는 github 저장소에서 다운로드할 수 있다.</p><p><a href="https://github.com/ibare/architect-express-sample#">https://github.com/ibare/architect-express-sample</a></p><p>셈플앱의 동작은 지극히 단순하다. express 4.0 으로 작성된 server 플러그인은 실행 즉시 3000번 TCP 포트를 오픈하고 클라이언트 요청을 대기한다. /users 요청을 처리할 users 플러그인과 /users/:id/photos 의 업로드 요청을 처리할 photos 플러그인으로 구성되어있다. 마지막으로 플러그인 실행을 처리할 index.js 가 존재한다. 코드를 보며 하나씩 살펴보자.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/709/1*TV_KlfSJ2e9IfIc_rcpQMQ.png" /></figure><p>최초 실행될 index.js 이다. 위에서 설명한 셈플 코드와 다른 내용 없이 단순하게 구성되어있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/749/1*4-ogObDCDlY36iQZ3CKu1A.png" /></figure><p>config.js 이다. 이 셈플 앱은 외부에서 개발된 architect 플러그인을 사용하지 않기 때문에 모두 로컬 플러그인만 기술되어 있다. 4개의 플러그인으로 구성되어있다는 것을 알 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Jn-LHshYVJ7xlE7twAOA_w.png" /></figure><p>server.js 와 server.js의 package.json 파일을 보자. 플러그인 코드는 전형적인 express 어플리케이션인걸 알 수 있다. 한가지 다른점이 있다면 생성된 express 앱의 app.route가 register를 통하여 server.route로 외부에 노출하고 있을 뿐이다. server 는 package.json 에서 명명한 provides 의 이름이며 다른 플러그인에서 consumes하여 사용될 수 있게된다</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*mJw1H0oacZeGaG0ca5WEMA.png" /></figure><p>주된 로직이 포함되어있는 users 플러그인을 보자. plugin 에 path 와 consumes 를 확인할 수 있고, user.js 를 보면 각각 options 과 imports 를 통하여 접근하는 것을 알 수 있다. expressjs 로 앱을 개발해본 개발자라면 이 코드가 express 의 라우팅 처리를 코드와 config로(package.json) 자연스럽게 분리하여 처리하는 구조라는 것을 알 수 있을 것이다. 당영히 어떤 방식으로 plugin 구조를 만들어가느냐는 각각의 스타일이고 수 많은 방식이 존재할 것이며 여기서 중요한 것은 그 각각의 방식을 architect를 이용하면 보다 쉽고 명확하게 만들수 있다는 것이다.</p><p>왼쪽의 디렉토리 목록을 보면 users 플로그인 디렉토리 하위에 photos 디렉토리가 있는 것을 알 수 있다. photos 는 독립된 plugin 이며 이 셈플앱의 클라이언트 요청 구조인 /users/:id/photos 와 동일하게 구성하고 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*VB7kG3xDr_7JCdjnV8fTvg.png" /></figure><p>마지막으로 photos 플러그인이다. 실제로 users 플로그인과 거의 동일한 구주임을 알 수 있다. 셈플 앱이라 실제론 별로 하는일이 없다.</p><h3>실행</h3><p>셈플 앱을 실제로 실행해보자. 다음과 같은 화면을 볼 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/608/1*MtHdJhb2ptKiEjEM1sFMyw.png" /></figure><p>로그를 살표보면 플러그인이 config.js 에 나열된 순서대로 실행된다는 것을 확인할 수 있다. curl 로 요청을 보내 보면 당연하게도 잘 동작한다는 것도 알 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/587/1*XyK-Ie69406gLaHsNm4H-w.png" /></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=52c6e5558a6e" width="1" height="1"><hr><p><a href="https://medium.com/ibare-story/architect-%EA%B8%B0%EB%B0%98-node-%EC%95%B1-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0-52c6e5558a6e">Architect 기반 Node 앱 개발하기</a> was originally published in <a href="https://medium.com/ibare-story">ibare story</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[점진적 개발 방법은 정말 효과적인가?]]></title>
            <link>https://medium.com/ibare-story/%EC%A0%90%EC%A7%84%EC%A0%81-%EA%B0%9C%EB%B0%9C-%EB%B0%A9%EB%B2%95%EC%9D%80-%EC%A0%95%EB%A7%90-%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9D%B8%EA%B0%80-f04c38212066?source=rss-e1f2be6f801------2</link>
            <guid isPermaLink="false">https://medium.com/p/f04c38212066</guid>
            <dc:creator><![CDATA[Kim, min tae]]></dc:creator>
            <pubDate>Wed, 29 Jan 2014 04:10:04 GMT</pubDate>
            <atom:updated>2014-01-29T14:01:05.385Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*ftmhaKSRE7UJ74UsNDRahw.jpeg" /></figure><p>서비스를 개발할 때 사용할 수 있는 많은 방법론이 있습니다. 특히, 변화의 속도와 대응이 중요한 현대의 모바일 서비스를 개발하는데 있어 방법론은 매우 중요한 요소입니다. 빠르게 컨셉을 실험하고 최소한의 가치있는 기능을 포함하여 서비스를 배포하는 것은 서비스 성공과 실패에 매우 큰 영향을 주게됩니다. 이 글에선 단기간에 점진적 개발 방법을 활용하여 모바일 서비스를 개발한 경험을 공유합니다.</p><h3><strong>페르소나</strong></h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ubel2Q3XA6MkMhopqqA5yA.png" /></figure><p>서비스 컨셉이 결정되었다면 페르소나(Persona)를 정의하는 일이 첫번째 입니다. 프로젝트 멤버들과 페르소나를 만들고 합의하는 것은 매우 중요합니다. 모든 아이디어는 페르소나에서 출발하고 페르소나를 통해 검증해야하기 때문입니다. 한 팀의 규모가 적은 것을 선호하는 최근의 경향은 페르소나를 멤버 전원이 동일한 수준으로 이해할 수 있는 확률이 높기 때문 아닐까? 라고 생각하고 있습니다. 멤버간에 페르소나를 이해하는 격차가 크면 클 수록 최종 결과물의 완성도는 떨어질 수 밖에 없습니다. 아래에서 이야기하게될 사용자 컨텍스트와 관련하여 페르소나는 절대적인 영향을 미칩니다. 프로젝트 진행 중에 회고를 한다면 진행된 내용과 페르소나의 정합성을 평가하는 방법을 추천합니다.</p><h3>아이디어의 참신함을 유지하기 위한 노력</h3><p>하나의 서비스를 실현하기위해 많은 아이디어가 필요합니다. 각각의 아이디어는 모호하지만 참신한 형태로 시작하여 여러 사람의 관점에서 다듬어지게 마련입니다. 다듬에 지는 과정에 운 나쁜 경우 초기의 참신함은 사라져 버릴 수 있습니다. 운 나쁜 경우라 했지만 사실 실무에선 이상하게도 운 나쁜 경우가 너무 많았습니다. 참신함이 사라지는 원인은 여러가지가 있을 수 있지만 저의 경험으론 머리속의 생각을 <strong>“시각화 할 때”</strong> 가장 많은 것을 잃어버렸던 것 같습니다.</p><p>시각화할 때 참신함을 최대한 유지할 수 있는 방법이 있을까요? 공상과 같이 아이디어를 형상화 하는 것 만큼 자유로울 수는 없겠지만 그와 비슷할 정도로 유연한 도구가 있다면 가능하지 않을까요? 그래서 저희는 <strong>핸드 스케치</strong>를 선택했습니다. 스케치는 그림 실력이 형편없는 사람일지라도 충분히 활용할 수 있다는 장점이 있습니다. 네모와 동그라미만 그릴 수 있다면 오케이입니다. 오히려 그림 실력이 뛰어난 사람의 스케치는 본질이 훼손될 수 있어 위험합니다. <strong>스케치를 할 때 가능하면 이쁘게 그리지 않는것이 좋습니다.</strong> 스케치의 목적은 아이디어의 참신함을 최대한 유지하며 함께 개발할 멤버들과 커뮤니케이션하기 위해서입니다. 그림 실력을 뽑낼 기회는 다른곳에서 찾는게 좋습니다.</p><p>아이디어 스케치가 빠르게 그려지면 세 가지 작업이 동시에 진행됩니다.</p><ol><li>디자인</li><li>앱 프로토타입</li><li>프로토타입용 API</li></ol><p>어떤 경우 3번은 없을 수 도 있습니다. 애니메이션 등의 인터렉션 요소가 강한 아이디어라면 2번의 네이티브앱 구현보단 다른 방법을 활용하는 것이 좋습니다. 예를 들면 플래쉬나 웹앱 같은 도구는 네이티브앱 개발보다 빠르고 효과적으로 결과물을 검증할 수 있습니다. <strong>도구에 집착하지 말아야합니다</strong>. 최종 버전의 플랫폼은 정해져있지만 모든 아이디어를 최종 결과물로 만드는 것은 지불해야할 비용이 너무 크고 프로젝트를 위험에 빠드릴 수 있습니다.</p><p>디자인 또한 과도한 디테일에 집착하지 않아야합니다. 어차피 끊임없이 변화해야하고 <strong>수정은 가장 중요하고 빈번한 일</strong>이기 때문입니다. 작고 어설프게 시작하여 크고, 디테일을 높이는 방식은 모든 파트에 동일하게 적용됩니다. 여기서 <strong>항상 생각해야하는 점은 초기 아이디어의 참신함을 잃지 않는 것입니다.</strong></p><h3>나무가 많아지면 숲이 되는 법</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*KoLeM_QjGofkBc12ZobJ5Q.jpeg" /></figure><p>아이디어 스케치가 하나 하나 많아지고 연결되기 시작하면 컨텍스트가 중요해 집니다. <strong>컨텍스트는</strong> 실제 앱을 사용하는 <strong>사용자의 환경에 따라 매우 다르게 작동</strong>될 수 있다는 것을 생각해야합니다. 너무나 다양한 컨텍스트에 모두 논리적으로 합당한 흐름을 제공하는 것은 불가능할지 모르겠습니다. 이 불가능한 목표를 이루기위한 첫 번째 방법은 모든 화면을 한눈에 볼 수 있도록 하는 것입니다. 바로 숲을 볼 수 있는 방법을 만들어야합니다.</p><h3>모든 화면을 인쇄하든, 가위로 잘라 붙이든, 어떤 방법을 사용해도 좋습니다. 하나의 캔버스위에 모두 올려놓고 볼수 있다면 말이죠.</h3><p>지금까지 얘기했던 방법들을 끊임없이 반복하여 점진적으로 서비스를 만들었고 지금도 진행중입니다. 반복하는 중간 중간 CBT 이벤트가 있었고, OBT 이벤트가 있었습니다. 많은 전문가들이 조언한 “<strong>최대한 빠르게 최초의 사용자의 피드백을 수집하라”</strong> 는 서비스를 제대로 만들기위해 가장 확실한 방법이고 서비스 페르소나를 검증하기 위한 유일한 길임에 틀림없습니다.</p><h3>빠진 것들</h3><ol><li><strong>파워포인트를 사용하지 않습니다.</strong><br>저희팀은 일반적으로 많이 사용하는 도구인 파워포인트를 사용하지 않습니다. 스토리 보드는 앞서 얘기한 스캐치한 종이를 오려 커다란 보드위에 붙여 완성해 나갑니다. 디지털화된 제품을 만들지만 때론 아날로그적인 도구들이 훨씬 효과적일때가 많습니다.</li><li><strong>위키보단 구글 문서도구를 활용합니다.</strong><br>언제 어디서나 협업이 가능한 웹 기반의 클라우드 문서 도구인 구글 드라이브를 사용합니다. 아날로그적인 데이타와 디지털적인 결과물을 효과적으로 결합할 수 있는 유연성을 제공합니다. 최종 완성본에 대한 문서는 위키를 사용하기도 합니다. 그러나 태생적인 한계로 협업이 불편한 위키는 지속적으로 수정되어야할 문서인 경우 사용을 지양하고 있습니다.</li><li><strong>보고서를 작성하지 않습니다.</strong><br>일 단위, 주 단위, 월 단위의 흔한 보고서를 작성하지 않습니다. 매일 아침 짧은 데일리 미팅을 Trello 보드에 기록하고 이터레이션 계획 문서를 주단위로 업데이트 합니다. 보고가 필요한 경우 해당 시점의 결과물로 커뮤니케이션 합니다. 가장 선명한 의사소통 방법이기 때문입니다.</li></ol><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f04c38212066" width="1" height="1"><hr><p><a href="https://medium.com/ibare-story/%EC%A0%90%EC%A7%84%EC%A0%81-%EA%B0%9C%EB%B0%9C-%EB%B0%A9%EB%B2%95%EC%9D%80-%EC%A0%95%EB%A7%90-%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9D%B8%EA%B0%80-f04c38212066">점진적 개발 방법은 정말 효과적인가?</a> was originally published in <a href="https://medium.com/ibare-story">ibare story</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Chekit은 어떤 서비스인가?]]></title>
            <link>https://medium.com/ibare-story/chekit%EC%9D%80-%EC%96%B4%EB%96%A4-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%9D%B8%EA%B0%80-535793ac6550?source=rss-e1f2be6f801------2</link>
            <guid isPermaLink="false">https://medium.com/p/535793ac6550</guid>
            <dc:creator><![CDATA[Kim, min tae]]></dc:creator>
            <pubDate>Thu, 09 Jan 2014 07:57:09 GMT</pubDate>
            <atom:updated>2014-01-09T08:30:06.118Z</atom:updated>
            <content:encoded><![CDATA[<h4>정보를 소비하기 위한 포맷으로 우리에게 익숙한 형식인 체크리스트를 모바일로 재 해석한 서비스 chekit. 그 정보 형식에 대한 이야기.</h4><p>너무나 많은 정보들이 흘러 넘치는 시대에 살고있습니다. 반복되는 질문과 반복되는 답변들. 정적 콘텐츠의 소비 패턴에서 스트림 형태로 변화되며 정보의 생명 주기는 극단적으로 짧아졌습니다. 정보를 소비하는 습관 또한 많이 달라져 긴 글을 읽기 힘들어하는 사람들이 늘어나며 짧은 단문의 정보만을 선호하고 소비하는 현상이 고착화되어가고 있습니다. 이 극단적 변화를 만들어내고 부추기는 많은 서비스들이 있습니다.</p><p>이런 현상은 언제까지 지속될까요?</p><p>chekit은 이런 변화와 콘텐츠 소비 흐름에 대한 의문에서 시작한 서비스입니다. chekit팀이 가장 먼저 주목한 것은 정보의 가공 형식(Format)입니다. 온라인에서 소비되는 텍스트, 이미지, 영상등은 정보를 구성하는 기본적의 요소들입니다. 정보가 전달되기 위한 많은 방법들이 있습니다. 하지만 <strong>개인화되고 일상 생활에 도움을 주며 쉽게 공유하고 소비될 수 있는</strong> 형식은 존재할까요?</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/378/1*0FWHeI3HMEFWQbPI_nnVzQ.jpeg" /></figure><p>의식적이든 무의식적이든 오래전부터 사람들이 사용해온 형식이 있습니다. <strong>“체크리스트”</strong>가 그것입니다. 아마도 체크리스트는 정보를 정리하고 개인화할 수 있는 효과적인 방법으로 가장 많이 사랑받는 형식일 것입니다.</p><p>거의 모든 정보 형태를 체크리스트로 담을 수 있을 것입니다. 하지만 몇가지 문제를 해결해야 한다는걸 프로토타이핑 과정에서 알게되었습니다.</p><ol><li>단순해야한다.</li><li>함께 만들 수 있어야한다.</li><li>만든 사람은 충분히 존중되어야한다.</li><li>손쉽게 개인화할 수 있어야한다.</li><li>일상 생활에 유용해야한다.</li><li>아름다워야한다.</li></ol><h3>함께 만드는 체크리스트</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/634/1*YC5YraY-8ev2aztq2Dlhug.jpeg" /></figure><p>chekit은 체크리스트를 함께 만들어 갈 수 있습니다. 물론 원한다면 혼자서 만들 수 도 있습니다. 체크리스트를 생성하고 주제를 발의한 사람을 에디터라합니다. 누구나 주제를 발의할 수 있으며 누구나 아이디어를 생성된 체크리스트에 등록할 수 있습니다. 하지만 최종적으로 아이디어를 선택하고 체크리스트를 완성<strong>(Brewed Up)</strong> 하는 권한은 에디터에게만 주어집니다. 체크리스트에 노하우를 제출하여 채택된 기여자들을 chekit 에선 컨트리뷰터라고 합니다. 에디터와 컨트리뷰터는 체크리스트가 사용되는 어떤 곳에서라도 항상 노출되어 서비스 내에서 충분한 존중을 받을 수 있습니다.</p><h3><strong>손 쉬운 개인화</strong></h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/755/1*4cJB6vAks1TuWRzeQtdX4g.jpeg" /></figure><p>완성된 체크리스트는 테이크아웃이란 형태로 개인 체크리스트함에 담아올 수 있습니다. 테이크아웃된 체크리스트는 마치 TO DO 를 완성해 나가듯 체크할 수 있으며 향후 프린트하여 종이 형식의 체크리스트를 만든다던지 하는 다양한 활용 기능으로 확장하려고 합니다.</p><h3>2014년 1월 6일 시작</h3><p>서비스가 세상에 나온지 이제 4일째 되는 날입니다. 아직 상용 단계는 아니며 chekit의 실험을 사용자와 함께 해나갈 생각입니다. 처음 생각했던 만큼 단순화 되지 못하여 복잡한 부분들을 좀더 다듬어 나아가고 있습니다. 최소한의 기본 기능만을 탑재한 첫번째 버전이 안드로이드 플레이 마켓에 등록되어있습니다.</p><p>빠른 시간내에 웹 서비스와 iOS 그리고 기타 다양한 플랫폼으로 확대해 나갈 계획입니다. chekit 개발에 참여한 한 명으로서 이 새로운 시도가 어떻게 발전해 나갈지 흥미롭고 기대됩니다. 이 기대감을 좀더 많은 분들과 함께하길 기대해봅니다.</p><p><strong>Google Play</strong><br><a href="https://play.google.com/store/apps/details?id=com.ncsoft.goldberg">https://play.google.com/store/apps/details?id=com.ncsoft.goldberg</a></p><p><strong>Twitter</strong><br><a href="https://twitter.com/chekitus">https://twitter.com/chekitus</a></p><p><strong>Email</strong><br>nc.mobilea.team@gmail.com</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=535793ac6550" width="1" height="1"><hr><p><a href="https://medium.com/ibare-story/chekit%EC%9D%80-%EC%96%B4%EB%96%A4-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%9D%B8%EA%B0%80-535793ac6550">Chekit은 어떤 서비스인가?</a> was originally published in <a href="https://medium.com/ibare-story">ibare story</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AWS 기반 백앤드 구축]]></title>
            <link>https://medium.com/ibare-story/aws-%EA%B8%B0%EB%B0%98-%EB%B0%B1%EC%95%A4%EB%93%9C-%EA%B5%AC%EC%B6%95-ee935a232774?source=rss-e1f2be6f801------2</link>
            <guid isPermaLink="false">https://medium.com/p/ee935a232774</guid>
            <dc:creator><![CDATA[Kim, min tae]]></dc:creator>
            <pubDate>Wed, 18 Dec 2013 08:07:35 GMT</pubDate>
            <atom:updated>2013-12-20T03:37:12.208Z</atom:updated>
            <content:encoded><![CDATA[<h4>모바일 서비스의 백앤드 개발을 위해 AWS가 제공하는 다양한 서비스를 이용한 인프라 구축 경험을 공유합니다</h4><h3>팀 구성, 그리고 개발 시작</h3><p>약 5개월 전 최소한의 구성원(5명)으로 조직된 서비스 개발팀은 개발할 서비스의 컨셉을 확정하고 본격적인 개발을 진행했습니다. 팀의 목표는 명확했습니다. 애자일과 프로토타이핑 개발 방식을 기반으로 단기간에 <a href="http://en.wikipedia.org/wiki/Minimum_viable_product">MVP</a>를 구현하는 것이었습니다. 2주 이터레이션 주기마다 실행되는 결과물이 나와야했고 개발된 기능은 다음 이터레이션에 완전히 다른 형태가 될 수도 있었습니다.</p><p>한 명의 개발자가 백앤드와 웹 프론트앤드 모두를 개발해야하는 상황에서 이런 조건을 충족시킬 수 있는 방법이 필요했고 웹과 백앤드 모두 같은 언어인 Javascript로 빠르게 개발할 수 있는 <a href="http://nodejs.org/">NodeJS</a>와 인기있는 NoSQL DB 솔루션인 <a href="http://www.mongodb.com/">MongoDB</a> 를 선택했습니다.</p><p><strong>최소한의 자원으로</strong> 빠르고 다양한 실험을 위해<strong> 불필요한 시간낭비를 줄이는 방법이 필요했습니다.</strong> 예를 들면 서버를 세팅하고, 패키지를 설치하는 등의 일 말이죠. 조직 규모가 일정 수준 이상의 기업이라면 내부 인프라를 할당받고 사용하는 일도 개발자에게는 꽤나 고단한 일이 될 수 있습니다.</p><p>그래서 개발 단계에서 사용할 적절한 <a href="http://en.wikipedia.org/wiki/PaaS">PaaS</a> 서비스를 찾았고, Ruby on Rails 를 시작으로 Node 등 많은 플랫폼을 지원하는 Heroku 를 선택했습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/630/1*y1_UksFoeV2oNexOV7S7FQ.jpeg" /><figcaption><a href="http://www.heroku.com/">http://www.heroku.com</a></figcaption></figure><p>Heroku는 계정을 만들고 <a href="https://toolbelt.heroku.com/">Heroku Toolbelt</a> 을 설치하면 즉시 무료 프로젝트를 구성하고 사용할 수 있습니다. 최소한의 무료 인스턴스만 사용한다면 돈 한푼 쓰지 않고도 충분한 프로토타이핑 환경을 제공합니다.</p><blockquote><a href="https://devcenter.heroku.com/articles/quickstart">Getting Started with Heroku</a></blockquote><p>간단한 Node 앱을 만들고 Heroku Toolbelt 설치후 터미널에서 다음과 같은 명령 만으로 순식간에 앱이 배포됩니다.</p><pre><strong>(~/myapp) $ heroku create my-first-app</strong></pre><p>이렇게 만들어진 앱은 http://my-first-app.herokuapp.com 으로 접근할 수 있습니다. 무료 MongoDB 데이타베이스가 필요하다면 다음과 같이 입력합니다.</p><pre><strong>(~/myapp) $ heroku addons:add mongolab</strong></pre><p>즉시 MongoDB 를 연결하여 사용할 수 있게됩니다. Heroku 가 제공하는 수 많은 에드온들은 다음의 링크에서 확인해 볼 수 있습니다. 거의 대부분의 에드온들이 최소 자원의 무료 플랜을 지원합니다. 개발 단계에서 어지간한 규모의 프로젝트라면 충분히 활용해서 테스트 해볼 수 있고, 개발 시간을 단축할 수 있습니다.</p><blockquote><a href="https://addons.heroku.com/">https://addons.heroku.com</a></blockquote><p>저희 팀에선 최종적으로 AWS 에 인프라를 구성하기 전인 프로젝트 막바지까지 Heroku 를 사용했습니다. Close BETA 서비스를 위해 제한된 사용자에게 오픈했을 때도 beta1.herokuapp.com, beta2.herokuapp.com, dev.herokuapp.com 등으로 세분화하여 배포판을 유지했습니다. 모두 무료로 말이지요.</p><h4><strong>Heroku</strong> 사용시 주의사항</h4><ol><li>PaaS 서비스는 앱이 배포될 때 배포판의 스냅샷 이미지를 생성합니다. 이는 마치 읽기 전용의 CD를 굽는 것과 유사합니다. 즉, Heroku 앱은 파일을 쓸 수 없다는 얘기입니다. 파일 업로드 등을 구현하여 배포했을 경우 파일 시스템에 Write 할 때 오류가 발생합니다. 이를 해결하기 위해 클라우드 저장소를 활용하는 방법이 필요합니다. 예를 들면 AWS 의 S3나 Dropbox 등과 연동시키는 부가작업이 필요할 수 도 있습니다. 테스트 목적이라면 연동이 손쉽고 적당한 무료 용량을 제공하는 S3 사용을 추천합니다.</li><li>서버에서 무언가 필요한 리소스가 있을 때 (예를 들면 한글 폰트) 특별한 작업이 필요합니다. 저희가 개발하는 프로젝트에서는 웹사이트의 스크린샷을 생성하여 저장하는 모듈이 있는데 Heroku 에서 실행할 경우 한글 폰트가 없어 한글이 랜더링되지 못하는 현상이 발생했습니다. 이 경우 Heroku는 BuildPack 을 추가로 지정하여 해결할 수 있는데 다음의 링크를 참조하세요.<br><a href="https://github.com/nanha/heroku-buildpack-nodejs-phantomjs">https://github.com/nanha/heroku-buildpack-nodejs-phantomjs</a></li></ol><h3>AWS 인프라 구축 계획</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/700/1*GPTtpQxRq7ufgxvE8iCBRg.jpeg" /></figure><p>위 그림은 일반적으로 서비스를 아마존에 구축하게될 때 기본적으로 참조할 수 있는 구성입니다. AWS는 실제 200여개가 넘는 서비스를 제공하고 있어 매우 복잡해 보일 수 있으나 최소한의 필요한 형태로 구성한 후 상황에 따라 하나씩 확장해 나가면 비교적 손 쉽게 인프라를 구축할 수 있습니다.</p><p>저희 팀에서 사용하는 AWS 서비스는 다음과 같습니다.</p><ol><li>EC2 (가상 머신 서비스)</li><li>Elastic Load Balancing (트래픽 분산 서비스)</li><li>Auto Scaling</li><li>Route 53 (DNS 서비스)</li><li>S3 (클라우드 스토리지 서비스)</li></ol><h3>계획</h3><p>B2C 서비스가 대부분 같은 문제를 지니고 있습니다. 서비스 사용자의 증가가 어떤 패턴으로 늘어날지 전혀 예측할 수 없다는 것입니다. 그리고 예상을 넘어서 과도한 트래픽이 집중되면 환호는 잠시 뿐, 서버의 응답은 하염없이 늦어질 수 있습니다. 서비스 초기 응답 품질 문제는 서비스가 성장할 수 있는데 결정적인 장애요소이기도 합니다. 따라서 다음의 목표는 최소 필요 조건이 됩니다.</p><ol><li>서비스 시작은 최소의 자원으로</li><li>트래픽이 증가하면 자동으로 서버 확장</li></ol><p>이 두 가지 목표는 AWS 가 제공하는 ELB와 Auto Scaling 서비스로 아주 간단하게 해결할 수 있습니다.</p><h3><strong>EC2</strong></h3><p>AWS의 계정을 생성한 후 아마도 제일 처음 하는 일은 EC2 인스턴스를 생성하는 일일 것입니다. 많은 인스턴스 타입이 있지만 t1.micro 타입은 한달간 무료로 사용해 볼 수 있기 때문에 즉시 생성하여 여러가지 테스트를 해볼 수 있습니다.</p><p>EC2 인스턴스도 다른 서비스와 마찮가지로 손쉽게 생성하고 삭제할 수 있습니다만 인스턴스의 종류와 Zone 의 위치 그리고 시간당 비용이 청구되기 때문에 다른 서비스와 달리 생성에 신중을 기해야합니다. 비용 관련해서 아래 awsnow.info 사이트에서 비교적 간단히 참조해볼 수 있습니다.</p><blockquote><a href="http://www.awsnow.info/">http://www.awsnow.info/</a></blockquote><p>아래 그림을 통해 전체 구성중 EC2 인스턴스가 금액적으로 차지하는 비중이 압도적으로 크다는 것을 알 수 있습니다. (이는 서비스의 특성에 따라 차이가 클 수도 있습니다.)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/471/1*wz3uuL-iY5ICCJ97dDaMbQ.jpeg" /></figure><p>EC2 인스턴스 생성시 가장 중요한 포인트는 어떤 운영 플랫폼을 선택하는가 일 것입니다. 흔히 알고 있는 Linux 계열, Amazon Linux, Windows 등을 기본으로 다양한 소프트웨어가 이미 설치되어 세팅까지 되어있는 이미지들 중에 선택하여 EC2 인스턴스를 만들수 있습니다. Amazon Linux 는 AWS 서비스를 구성하는데 있어 필요한 다양한 도구들이 비교적 잘 정리되어 설치되어 있는 AMI 입니다. 구성 요구사항에서 운영체제 환경이 크리티컬하지 않다면 Amazon Linux AMI 선택은 환결 설정의 스트레스에서 조금이나마 벗어날 수 있게 해 주는 것 같습니다. 저희는 MongoDB 인스턴스들이 Amazon Linux 로 구성되어 있습니다.</p><p>인스턴스 생성시 생각하고있어야하는 것은 AMI라는 인스턴스 이미지와 CPU, RAM 등 서버의 자원 크기를 결정하는 t1.micro, m1.small, m1.large 등의 인스턴스 타입은 분리되어있다는 것입니다. <strong><em>[1]생성된 EC2 인스턴스의 인스턴스 타입을 변경하지는 못합니다.</em></strong> 대신 동일한 AMI 를 기반으로 원하는 인스턴스 타입으로 인스턴스를 새로 생성할 수 있습니다. 여기서 중요한 점은 실행중인 인스턴스를 사용자 AMI 로 만들어 놓는다는 것입니다.</p><p>[1] <strong>#수정</strong> 인스턴스의 실행을 Stop 시킨 후 인스턴스 타입을 변경할 수 있습니다. EBS-optimized 옵션 지정과 함께 수정 가능하네요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/539/1*veGnR-s8HKVk4zF0j_TR9A.jpeg" /><figcaption>사용자의 EC2 인스턴스를 AMI 로 만들기</figcaption></figure><p>설정이 끝난 인스턴스를 사용자 AMI 로 만들어 놓으면 향후 Scale Up (인스턴스 타입 변경)을 하거나 Auto Scaling 할 때의 확장 단위로 활용할 수 있는 등 여러모로 편리하고 필수적인 요소입니다. 초기에는 가격이 저렴한 t1.micro 인스턴스에서 작업 후 실제 운영할 땐 만들어 놓은 AMI 를 기반으로 적절한 인스턴스 타입을 선택하시면 됩니다.</p><h4>Elastic IP</h4><p>인스턴스가 생성되면 Public IP 와 Private IP 가 할당됩니다. Public IP 는 AWS 외부에서 해당 인스턴스로 접속하기 위한 용도이고 Private IP 는 AWS 서브넷 안쪽에서 통신하기위한 사설 IP 입니다. 인스턴스가 켜져있는 동안 특별한 경우를 제외하면 IP 가 변경되지는 않습니다. 하지만 인스턴스가 리부팅 되면 동일한 IP 를 보장받지 못합니다. 터미널로만 접속하는 서버라면 문제 없겠지만 동일한 IP 를 유지해야하는 서버라면 변경되지 않는 고정 IP 가 필요합니다. 예를 들면 DB 서버 같은 경우겠죠. 이런 서버는 Elastic IP 를 생성하여 할당해 주시면 됩니다. Elastic IP 도 비용이 청구되기 때문에 꼭 필요한 서버에만 할당하는 것이 좋습니다.</p><p>그 외에 AWS의 다른 서비스와 연동은 실제 IP 가 아닌 Instance ID로 이루어지기 때문에 IP 가 변경된다해도 연결을 보장합니다.</p><h3><strong>ELB (Elastic Load Balancing)</strong></h3><p>ELB는 클라이언트의 트래픽을 여러대의 서버로 분산시키는 기능을 제공하는 서비스입니다. L4 스위치와 유사한 기능을 제공하는 서비스입니다. ELB는 AWS Console(Web GUI) 의 좌측 메뉴에 존재합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/695/1*jSr30hF2x9BCSWU3lPvKoQ.jpeg" /></figure><p>ELB에 트래픽을 분산시킬 타겟 인스턴스를 포함시킬 수 있습니다. 포함된 인스턴스 중 Health Check 하여 서비스 가능한 인스턴스를 대상으로 요청을 전달합니다. 타겟 인스턴스는 여러대의 분리된 인스턴스가 될 수 도 있고, 단일 인스턴스 내에 서로 다른 TCP PORT로 실행중인 서비스일 수 있습니다.</p><p>트래픽의 정도에 따라 자동으로 인스턴스의 수를 증감하는 Auto Scaling 은 ELB가 제공하는 기능이 아닙니다. 서비스 구조상 ELB에 옵션으로 Auto Scaling 이 포함되어 있다면 훨씬 직관적이고 편리하겠다고 생각할 수 도 있으나 실제 Auto Scaling 은 별개의 서비스로 제공되며 Inbound 트래픽 소스로 ELB 를 통하여 제공받을 수 있는 옵션을 제공합니다.</p><h3>Route 53</h3><p>서비스 진입의 첫 단추는 DNS 일 것입니다. AWS 에서는 Route 53 이라는 DNS 서비스를 제공합니다. 다른 DNS 서비스를 사용해도 문제될 것은 없지만 Route 53 을 사용한다면 AWS 의 다른 서비스와 유기적으로 손쉽게 연결할 수 있습니다. 네임 서버 설정 후 20여분이 되지 않아 해당 도메인에 연결되는 것을 확인했을 땐 조금 놀라기도 했습니다. 보통 짧게는 6시간에서 24시간 넘게 걸리는 경우도 자주 봤었기 때문입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/349/1*Em5w0O181cOR0UK2KUfpzA.jpeg" /><figcaption>서비스할 DNS 를 생성한 후 Hosted Zone Details</figcaption></figure><p>서비스의 도메인을 Route 53 콘솔에서 등록하면 위 그림과 같은 Hosted Zone Details 을 보실 수 있습니다. Delegation Set 의 4개 주소를 구입한 도메인 서비스의 네임서버에 각각 등록하면 간단히 처리됩니다.</p><p>서비스할 도메인이 설정되면 호스트별로 A 레코드를 생성해야합니다. A 레코드는 특정 EC2 에 직접 연결시킬 수 도 있으나 이런 경우 고정 IP 가 필요하기 때문에 ELB 를 중간 브리지로 구성하면 쉽게 연결시킬 수 있는 등 많은 장점이 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/408/1*fkGsBLcS82LpHtuBMB3nSQ.jpeg" /><figcaption>sentry.foo.com A 레코드가 sentryLB 라는 이름의 EBL에 연결시킨 모습</figcaption></figure><h3>Auto Scaling</h3><p>서버의 상황에 따라 다양한 조건의 룰을 세팅하여 해당 조건이 충족되면 인스턴스의 수를 증가시키거나 감소시키는 것을 가능하게 해 주는 서비스입니다. Auto Scaling 은 얼마 전까진 AWS CLI 라는 커맨드라인 도구로만 설정이 가능했으나 이제 웹 콘솔에서도 다른 서비스와 마찮가지로 간단하게 설정하고 구성할 수 있습니다.</p><p>Auto Scaling 구성을 하기 위해선 먼저 준비해야하는 것이 있습니다. 앞서 잠깐 언급했던 사용자 AMI 입니다. Auto Scaling 해야할 대상이 API 서버라면 부팅과 동시에 API 서버가 동작하기위한 모든 구성이 완료된 AMI 를 만들어 놓아야 합니다. 이 AMI 를 기반으로 다음 두 가지 단계를 거쳐 Auto Scaling 구성을 할 수 있습니다.</p><ol><li><strong>Auto scaling Launch Configurations</strong><br>사용자 AMI 를 어떤 인스턴스 타입으로 생성할지에 대한 구성 정보를 담고있습니다. Auto Scaling 그룹을 만들게 될 때의 상위 구성 정보입니다.</li><li><strong>Auto scaling groups</strong><br>구성하고자 하는 Launch Configrations 을 선택한 후 Scaling Group 명, 최소 인스턴스 수, 최대 인스턴스 수, 증감 조건 등을 설정합니다. 요청을 수신할 ELB를 지정할 수 도 있습니다. 설정이 완료되면 조건에 맞는 EC2 인스턴스가 생성됩니다. 증감 인스턴스의 정수와 % 로 지정할 수 있습니다.<br>인스턴스의 증감 룰을 결정하는 변수는 몇 가지가 있습니다. 아래 그림을 참고하세요. “해당 조건이 몇 분간 지속되면 인스턴스를 2개 증가시키고, 해당 조건이 몇 분간 지속되면 1개 감소시킴” 과 같이 설정합니다.</li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/856/1*R4GYy_noEGVL-1M22HMHqg.jpeg" /></figure><h3>남은 일, 그리고 계획</h3><p>남아있는 일이 아주 많이 있습니다. 서비스가 아직 정식으로 오픈하지 않았기 때문에 이 구성상에서 어떤 예상치 못한 일이 발생할지 감이 잘 안오고, 선택한 인스턴스 타입은 적절한지도 아직 판단이 잘 서지 않습니다. 다만 앞으로 할 일들을 최대한 예측해보고 필요한 시스템을 구축해 나가야겠지요.</p><blockquote>참고로 저는 프론트앤드 기반의 개발자입니다. 그래서 더 힘들게 느껴지는지도 모르겠습니다. :-)</blockquote><h4><strong>To do list</strong></h4><ol><li><strong>Log Monitoring</strong><br>API 서버, Web 서버, Push 서버 등 이것 저것 많은 서비스가 있기 때문에 통합적으로 로그를 모니터링할 필요가 있습니다. 매번 터미널에 들어가 볼 수 없기 때문이죠. 현재는 <a href="https://getsentry.com/welcome/">Sentry</a> 로 구축을 해 놓았는데 굉장히 느리네요. 무언가 문제가 있는듯 하여 튜닝이 필요한 것 같습니다.</li><li><strong>Redis</strong><br>현재 서비스가 소셜을 기반으로 하고 있기 때문에 사용자의 활동 로그가 매우 많이 쌓입니다. 이 로그를 빠르게 저장할 솔루션으로 Redis 를 생각하고 있는데 AWS 에선 ElastiCache 서비스가 이것을 제공합니다.</li><li><strong>Deploy</strong><br>Auto Scaling Group 으로 배포되는 API 서버는 PaaS 서비스와 마찮가지로 한번 배포되면 내용 변경을 할 수 없습니다. (할 수 는 있지만 영구적이지 않지요) 운영중인 배포판과 개발중인 배포판사이의 빠른 전환, 그리고 문제 발생시 빠르게 롤백할 수 있는 Deploy Workflow 를 고민중에 있습니다. 여러가지 모델이 있어서 가장 효과적인 것을 선택해야할 것 같습니다.</li><li><strong>MongoDB Shared 구축</strong><br>현재는 기본적인 Replica set 으로 되어있습니다. 서비스가 많이 성공한다면 Shared 구축을 해야겠지요. 이 작업은 서비스가 흥했다는 거니까 기분좋은 작업이 될 것 같습니다. ^^</li></ol><h3>에필로그</h3><p>서비스 오픈전에 잠시 짬이나 그동안 했던 작업들을 개인적으로 정리할 겸 오랜만에 긴 글을 작성해봤습니다. 사실 기초적인 내용들이고 검색하면 모두 나오는 내용입니다만 처음 해보시는 분들에겐 한번에 파편화되지 않은 글이 도움이 될까하여 공유해봅니다.</p><p><strong>“프론트앤드 개발자의 백앤드 구축 삽질담”</strong> 정도로 가볍게 읽어주시고, 혹시 제가 잘못 생각하고 있거나 이해하고 있는 내용은 언제든 피드백 주시면 감사드리겠습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ee935a232774" width="1" height="1"><hr><p><a href="https://medium.com/ibare-story/aws-%EA%B8%B0%EB%B0%98-%EB%B0%B1%EC%95%A4%EB%93%9C-%EA%B5%AC%EC%B6%95-ee935a232774">AWS 기반 백앤드 구축</a> was originally published in <a href="https://medium.com/ibare-story">ibare story</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
    </channel>
</rss>