<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Yong Ho Kim on Medium]]></title>
        <description><![CDATA[Stories by Yong Ho Kim on Medium]]></description>
        <link>https://medium.com/@kimyh1981?source=rss-dde95c17315b------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*KivpMv3C3q7HAY_DArsnBA.jpeg</url>
            <title>Stories by Yong Ho Kim on Medium</title>
            <link>https://medium.com/@kimyh1981?source=rss-dde95c17315b------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 13 May 2019 19:57:11 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@kimyh1981" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[To explain “명당” in English.]]></title>
            <link>https://medium.com/@kimyh1981/to-explain-%EB%AA%85%EB%8B%B9-in-english-ecbb827f59b9?source=rss-dde95c17315b------2</link>
            <guid isPermaLink="false">https://medium.com/p/ecbb827f59b9</guid>
            <dc:creator><![CDATA[Yong Ho Kim]]></dc:creator>
            <pubDate>Thu, 04 Oct 2018 12:06:49 GMT</pubDate>
            <atom:updated>2018-10-04T12:06:49.129Z</atom:updated>
            <content:encoded><![CDATA[<p>To explain “명당” in English.</p><p>This is a test.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ecbb827f59b9" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[어떠한 일이 있더라도 당신의 최고의 삶을 위한 변치 않을 14가지 조언]]></title>
            <link>https://medium.com/@kimyh1981/%EC%96%B4%EB%96%A0%ED%95%9C-%EC%9D%BC%EC%9D%B4-%EC%9E%88%EB%8D%94%EB%9D%BC%EB%8F%84-%EB%8B%B9%EC%8B%A0%EC%9D%98-%EC%B5%9C%EA%B3%A0%EC%9D%98-%EC%82%B6%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%B3%80%EC%B9%98-%EC%95%8A%EC%9D%84-14%EA%B0%80%EC%A7%80-%EC%A1%B0%EC%96%B8-7c674feca9f7?source=rss-dde95c17315b------2</link>
            <guid isPermaLink="false">https://medium.com/p/7c674feca9f7</guid>
            <category><![CDATA[wisdom]]></category>
            <category><![CDATA[advice]]></category>
            <category><![CDATA[life]]></category>
            <dc:creator><![CDATA[Yong Ho Kim]]></dc:creator>
            <pubDate>Sat, 18 Aug 2018 09:56:16 GMT</pubDate>
            <atom:updated>2018-08-18T09:56:16.744Z</atom:updated>
            <content:encoded><![CDATA[<h4>14 Timeless Pieces of Advice for Living Your Best Life No Matter What Happens</h4><p><a href="https://medium.com/swlh/14-timeless-pieces-of-advice-for-living-your-best-life-no-matter-what-happens-96698d4d8e9e">14 Timeless Pieces of Advice for Living Your Best Life No Matter What Happens</a></p><h4>삶은 때론 공평치 않아 보이기도 합니다.</h4><p>There are circumstances that are outside of our control that can affect us in a negative way. People can be rude, dishonest, and mean. The people closest to us can betray us. We have a tendency to resist the true nature of the world, and it causes us great pain to have unfavorable situations arise. 부정적인 방법으로 우리에게 영향을 줄 수 있는 우리의 통제 밖의 상황들이 있습니다. 사람들은 누구나 무례해지고, 솔직하지 않고, 비겁해 질 수 있습니다. 심지어 우리와 가장 가까웠던 사람도 우리를 배신할 수 있습니다. 우리는 세상의 진정한 본성에 저항하려는 경향이 있으며, 이로 인해 불운한 상황 발생을 겪는 커다란 고통을 야기하기도 합니다.</p><p>I’m reading the book Meditations by Marcus Aurelius, and he talks in detail about how to deal with unfortunate circumstances. I will include some passages from the book and elaborate on his thoughts. Hopefully, this will help you deal with the unfairness of the world. 저는 마커스 오렐리우스 저자의 Meditations를 읽고 있는데요, 그는 그 책에서 불운한 상황을 이겨내는 방법에 대해서 자세히 이야기 하고 있습니다. 저는 이 책에서 일부 인용을 하여 그의 생각을 잘 표현해 보겠습니다. 희망적이게도 세상의 불공정한 상황을 헤쳐 나가시는데에 도움이 될 것입니다.</p><blockquote>“You have power over your mind — not outside events. Realize this, and you will find strength.” 당신은 바깥의 사건들이 아닌, 당신의 마음을 뛰어넘는 힘을 가지고 있습니다. 그리고 장점을 찾게 되실 겁니다.</blockquote><p>Although it seems incredibly difficult at times, realize that you do possess the strength to overcome anything that happens to you. People are able to find strength after dramatically life-altering evens from the power of their mind. 때론 굉장히 힘들어 보일지라도, 당신은 당신에게 일어나는 어떠한 것도 극복하기 위한 장점을 갖게 될 것임을 인지 하십시오. 사람들은 극적으로 삶이 개조되는 사건을 그들의 마음 속의 힘으로부터 겪고 난 뒤에 스스로의 장점을 발견 할 수 있는 능력이 생깁니다.</p><blockquote>“The happiness of your life depends upon the quality of your thoughts.” 당신의 삶의 행복은 당신이 하는 생각의 질에 달려 있습니다.</blockquote><p>We may look at the lives of people who are seemingly less fortunate than us and wonder how they are able to find happiness and contentment. Happiness comes from your thinking. People less fortunate can find meaning and gratitude in several different ways. So can you. 우리는 때론 우리보다 덜 부유해 보이는 사람들의 삶을 바라보면서, 그들은 어떻게 행복과 마음의 평안을 찾을 수 있는 것인지 궁금해 합니다. 행복은 당신의 생각으로부터 오죠. 덜 부유한 사람들은 여러 다른 방법을 통해서 의미와 감사를 찾을 수 있습니다. 그렇다면 당신은요?</p><blockquote>“I have often wondered how it is that every man loves himself more than all the rest of men, but yet sets less value on his own opinion of himself than on the opinion of others.” 저는 종종 모든 남자들이 나머지 남자들보다도 더 자기 자신을 사랑하는 것인지 궁금했었습니다. 하지만 그들 자신의 의견을 다른 사람들의 의견보다 더 작은 가치를 부여하지는 않습니다.</blockquote><p>When we take things personally, we are in essence saying that we agree with what was said. We may feel hurt by negative comments made about us by other people, even though they aren’t true and don’t align with the opinion we have of ourselves. We have to remember to value ourselves and know that the comments people make about us are a reflection of their character, not ours. 우리는 개인적으로 어떤 것을 얻을 때, 우리는 나온 말에 동의한다고 본질적으로 이야기 합니다. 우리는 우리에 대해서 다른 사람들이 부정적인 말을 달면 상처 받은 느낌을 받습니다, 그들이 사실이 아니고, 우리가 가진 의견과 일치 않을 지라도요. 우리는 우리 스스로에 가치를 부여하여야 함을 반드시 기억하여야 하며, 또한 사람들이 만드는 우리에 대한 말들은 우리가 아닌 그들의 성격을 반영한다는 것도 꼭 알아야 합니다.</p><blockquote>“When another blames you or hates you, or people voice similar criticisms, go to their souls, penetrate inside and see what sort of people they are. You will realize that there is no need to be racked with anxiety that they should hold any particular opinion about you.” 다른 사람들이 당신을 비난하거나 또는 혐오하거나, 아니면 유사한 비평의 목소리를 낼 때에는 그들의 영혼으로 가서 내면을 꿰뚫어 그들이 어떠한 종류의 사람인지 보십시오. 아마도 당신은 그들이 당신에 대한 어떠한 특정 의견을 가져야 할 정도라고 걱정하며 괴로워 할 필요가 없다고 깨달으실 겁니다.</blockquote><p>The more you pay attention, the more you realize that the way people treat you has much more to do with them that it does with you. Why should you care if a shitty person says shitty things about you? It’s in their nature to act immaturely, so this sort of behavior shouldn’t surprise you or bother you. 여러분이 주의를 기울일 수록, 사람들이 당신을 대하는 방식이 당신이 그들에게 하는 것보다 훨씬 더 많음을 알게 될 것입니다. 왜 싫은 사람들이 당신에 대해서 싫은 소리를 하는지를 굳이 신경써야 하나요? 이것은 즉각적으로 반응하는 그들의 본성에 있지, 이러한 종류의 행동은 당신을 놀라게 하거나 괴롭혀서는 안됩니다.</p><blockquote>“How much time he gains who does not look to see what his neighbor says or does or thinks, but only at what he does himself, to make it just and holy.” “자기의 이웃이 하는 이야기나 또는 생각을 알고자 보려고 하지 않음으로 시간을 벌어, 오직 스스로 행하는 때 꼭 성스러이 성공한다.”</blockquote><p>An even better method to deal with ignorant people is to ignore them altogether. Be too busy doing you that you don’t even have the time to notice what others are saying about you. 무지한 사람을 대처하기 위한 보다 나은 방법은 같이 함께 그들을 무시하는 것이다. 당신에 대해 다른 사람이 말하는 것을 알아차릴 시간도 없을 정도로 매우 바빠 지세요.</p><blockquote>“Never let the future disturb you. You will meet it, if you have to, with the same weapons of reason which today arm you against the present.” “미래가 결코 당신을 방해하게 두지 마세요. 현재에 맞서 당신을 무장시키는 것은 오늘이라는 이유의 동일한 무기로 꼭 행하다 보면 미래는 결국 만나게 되어 있습니다.”</blockquote><p>Develop and fortify your reasoning capabilities so that you won’t be blindsided by unfortunate circumstances in the future. Decide that no matter what happens to you, you will deal with it in an emotionally intelligent way. 당신이 미래에 불행한 상황으로 불시에 공격당하지 않기 위해서 당신의 이성적 능력을 개발하고 강화하세요. 당신에게 무슨 일이 일어나든지 간에, 감정적으로 총명한 방법으로 해쳐나갈 것임을 결심하세요.</p><blockquote>“Reject your sense of injury and the injury itself disappears.” “상처에 대한 당신의 감정과 사라지는 상처 그자체를 거부 하세요.”</blockquote><p>People can only hurt you if you allow them to. No one has the permission to cause you pain unless you give it to him or her. 오직 당신이 허락 할때만 사람들이 당신을 상처 줄 수 있습니다. 당신이 누군가에게 상처 주지 않는 한 그 누구도 당신을 고통 받게 할 수 없습니다.</p><blockquote>“The best revenge is not to be like your enemy.” “최고의 복수는 당신의 적과 같이 되지 않는 것입니다.”</blockquote><p>Take the high road. When people try to get you to stoop to their level, don’t give them the pleasure. Let success be your greatest revenge. Refusing to respond to other peoples attacks will take the wind out of their sails and you be victorious by simply choosing to be the bigger person. 높은 길을 가세요. 사람들이 당신을 그들의 수준으로 굽히려고 시도할 때, 그들에게 기쁨을 주지 마세요. 성공이 당신의 최고의 복수가 되게 하세요. 다른 사람들이 공격하는 것에 반응하지 않으면, 그들이 항해에서 바람을 없애는 것이며, 더 큰 사람이 되기 위한 간단한 선택으로 당신을 승리하게 할 것입니다.</p><blockquote>“Whenever you are about to find fault with someone, ask yourself the following question: What fault of mine most nearly resembles the one I am about to criticize?” “누군가의 잘못을 발견하고자 할 때마다, 다음과 같은 질문을 스스로에게 던져 보세요 : 내가 비판하려고 하는 잘못이 나의 어떤 잘못과 가장 닮았는가?</blockquote><p>Have you ever been in a foul mood and taken it out on someone that didn’t deserve it? Have you ever been rude to someone? Have you ever gossiped or criticized someone behind his or her back? We all have done things in the heat of the moment that we come to regret later. Keep this in mind when you’re feeling slighted by someone else. 불쾌한 분위기에 있었던 적이 없으신가요? 그리고 이런 분위기를 받지 않아도 되어야 할 누군가에게 전가한적이 없으신가요? 누군가의 뒤에서 수근대거나 비판한적이 없으신가요? 우리 모두 나중에 후회하는 순간이 되는 것을 저질러 왔습니다. 다른 누군가가 얕본다고 느낀다고 느껴질 때 위와 같은 것을 마음속에 간직해 보세요.</p><blockquote>“Here is a rule to remember in future, when anything tempts you to feel bitter: not ‘This is misfortune,’ but ‘To bear this worthily is good fortune.’” “무언가 당신을 씁쓸하게 하려는것이 있다면, 미래에 명심해야할 규칙이 여기 있습니다: ‘이것은 불운이야’할 것이 아니라, ‘훌륭히 이겨 내는 것이 좋운 운이 되겠습니다.’”</blockquote><p>Life is too short to remain bitter about the negative things that occur in your life. Instead of feeling sorry for yourself, take what happens to you in stride and take pride in your ability to move forward with dignity. 당신의 삶에서 일어난 부정적인 일들에 대한 씁쓸함을 간직하기에는 삶은 너무 짧습니다. 스스로 미안함을 가지는 대신, 성장속에 당신에게 일어날 일들을 보고, 존엄성으로 앞으로 나가는 당신의 능력에 자부심을 가지세요.</p><blockquote>“Accept whatever comes to you woven in the pattern of your destiny, for what could more aptly fit your needs?” “당신에게 무슨일이 일어나더라도 당신의 운명이라는 패턴에 짜여진 것들을 받아들이세요, 당신에게 필요한 것을 더욱 알맞게 맞춰줄 수 있는 것이 있을까요?”</blockquote><p>Everything happens for a reason. It may not be a reason that suits your preferences, but nonetheless, things happen according to what nature dictates. The minute you stop resisting what happens to you and realize that you might as well take things as they come, the freer you’ll feel. 모든것은 한 가지 이유로 일어납니다. 아마도 당신이 선호하는 것과 다른 이유일 수도 있지만, 그럼에도 불구하고 자연이 결정하는 데로 일은 일어나는 법입니다. 당신에게 일어나는 것에 저항하는 것을 멈추는 순간, 아마도 당신은 그러한 일들이 다가오는 데로 받아들이고 더 자유로워 짐을 느끼는 것을 알게 될 것입니다.</p><blockquote>“Do not waste what remains of your life in speculating about your neighbors, unless with a view to some mutual benefit. To wonder what so-and-so is doing and why, or what he is saying, or thinking, or scheming — in a word, anything that distracts you from fidelity to the ruler within you — means a loss of opportunity for some other task.” “상호 득이 될 것이 없는 한, 당신의 이웃에 대해 신경쓰는 것에 당신의 삶을 낭비하지 마세요. 무엇무엇을 궁굼해 하는 것은 행동, 이유 또는 그가 뭇엇을 이야기 하는가 또는 생각하는가 또는 계획하는가 이며, 한마디로 말해서, 줄자가 정확한지 뭐가 정확한지 당신을 혼란스럽게 하는 것이라는 것이며, 그저 당신이 다른 것을 할 수도 있는 기회조차 잃어 버리게 한다는 것을 의미한다.”</blockquote><p>Worrying about what other people are thinking and saying about you not only causes pain, but it keeps you from focusing your energy on what truly matters. The more attention you give to them, the less time you have to make a positive impact on your own life. 다른 사람들이 당신에 대해서 생각하는 것과 이야기하는 것에 대해서 걱정하는 것은 그저 고통을 야기하고, 진짜 문제에도 집중하지 못하게 할 뿐이다. 그런 것에 집중할 수록, 당신의 삶에 긍정적 영향을 만들어낼 시간만 줄어들 뿐이다.</p><blockquote>“Whoever does wrong, wrongs himself; whoever does injustice, does it to himself, making himself evil.” “잘못을 저지르는 누구든지 간에 그저 그자신을 잘못되게 함이며; 정의롭지 못하게 행동하는 것도 그 자신에게 정의롭지 않음이고, 그 자신을 악으로 만드는 것이다.”</blockquote><p>Remember this sentence when people betray you and do you harm. They are truly only doing harm to themselves. When considering retaliation, realize that you’re only going to cause yourself harm in the process. 사람들이 당신을 배신하거나 해를 끼치는 경우 이문장을 기억하세요. 그저 그들은 그 자신들을 해롭게 하고 있음임을. 앙갚음을 고민한다면, 그저 그 과정에서 당신 스스로를 해롭게 하고 말 것임을 깨달으십시오.</p><blockquote>“Accept whatever comes to you woven in the pattern of your destiny, for what could more aptly fit your needs?” “당신에게 무슨일이 일어나더라도 당신의 운명이라는 패턴에 짜여진 것들을 받아들이세요, 당신에게 필요한 것을 더욱 알맞게 맞춰줄 수 있는 것이 있을까요?”</blockquote><p>Shit happens. 제길 일어나기도 하죠, 어쩌겠어요 받아 들여야지.</p><p><strong>Note</strong> : 본 기사는 <a href="https://medium.com/@Chef_BoyarDEJI">Ayodeji Awosika</a> 님이 제공하는 기사이며, 상단의 링크를 통하여 원래 기사를 확인하세요. 기사에 대한 소유권한은 <a href="https://medium.com/@Chef_BoyarDEJI">Ayodeji Awosika</a>에 있습니다. Any right of the original article linked and translated even in Korean is owned by <a href="https://medium.com/@Chef_BoyarDEJI">Ayodeji Awosika</a>, it is clearly mentioned that this article can be accessed by original article link on the top of this article. This blog is aiming to share good information or saying, but it is translated in Korean.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7c674feca9f7" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Very inspired article for me, let me translate this article and share it with readers in Korea.]]></title>
            <link>https://medium.com/@kimyh1981/very-inspired-article-for-me-let-me-translate-this-article-and-share-it-with-readers-in-korea-e2efdff79334?source=rss-dde95c17315b------2</link>
            <guid isPermaLink="false">https://medium.com/p/e2efdff79334</guid>
            <dc:creator><![CDATA[Yong Ho Kim]]></dc:creator>
            <pubDate>Mon, 09 Jul 2018 05:27:16 GMT</pubDate>
            <atom:updated>2018-07-09T05:27:16.192Z</atom:updated>
            <content:encoded><![CDATA[<p>Very inspired article for me, let me translate this article and share it with readers in Korea.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e2efdff79334" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Segue Types / iOS Swift]]></title>
            <link>https://medium.com/@kimyh1981/segue-types-ios-swift-ace20d6edfef?source=rss-dde95c17315b------2</link>
            <guid isPermaLink="false">https://medium.com/p/ace20d6edfef</guid>
            <category><![CDATA[apple]]></category>
            <category><![CDATA[ios]]></category>
            <category><![CDATA[iphone]]></category>
            <category><![CDATA[swift]]></category>
            <category><![CDATA[segue]]></category>
            <dc:creator><![CDATA[Yong Ho Kim]]></dc:creator>
            <pubDate>Tue, 03 Jul 2018 10:36:05 GMT</pubDate>
            <atom:updated>2018-07-03T10:36:05.866Z</atom:updated>
            <content:encoded><![CDATA[<h4>Segue(세그)의 타입별 정의</h4><p><strong>Show : </strong>새로운 view controller를 navigation 영역으로 푸쉬함으로써, 그 새로운 view controller가 navigation 영역에서 가장 상위에 올 수 있게 합니다. 또한 직전의 view controller로 돌아 가는 돌아가기 버튼을 제공합니다. 만일 그 직전 view contorller들이 navigation controller에 결합되어 있지 않은 경우, 그 새로운 view controller는 modally(아래 Present Modally에서 의미를 확인하세요.)로 나타날 것입니다. 예) 메일 앱에서 경로를 잡아주는 폴더</p><p><strong>Show Detail : </strong>view controller를 나누는데에 사용됨. 새로운 view controller는 확장된 2개의 column 인터페이스에서 나눠진 view의 상세한 view controller로 대체합니다. 그렇지 않으면, single column 모드에서는, navigation controller 상에서 푸쉬 할 것입니다. 예) <em>Messages</em>에서 대화를 탭하면, 2개의 column 레이아웃일 경우에는 우측에 view controller를 대체하여 상세한 대화 내용을 보여 주며, 또는 single column 레이아웃에서는 대화를 푸쉬 할 것입니다.</p><p><strong>Present Modally : </strong>직전 view controller를 새로운 view controller로 덮어서 나타내며, 아이폰 또는 아이패드 화면 전체를 덮는 view controller를 나타내기 위해 가장 흔히 사용되는데, 대게 나타나는 view controller를 어두워지게 하는 가운데 박스로서 나타내기 위한 것입니다. 보통 navigation bar를 상위 또는 하위에 놓았을 경우, 이런 경우도 modal view controller로 역시 덮힙니다. 예) 설정에서 Touch ID 및 Passcode를 선택할때</p><p><strong>Present as Popover : </strong>아이패드에서 실행하는 경우, 그 새로운 view controller는 popover로 나타나며, 이 popover의 바깥 아무곳에나 탭을 하면 사라집니다. 아이폰에서는 전체 화면 넘어로 새로운 view controller가 modally로 나타날 것입니다. 예) <em>Calendar</em>에서 + 버튼을 눌러보기</p><p><strong>Custom : </strong>여러분의 커스텀 세그를 실행할 수 있으며, 어떠한 행위를 할것인지 컨트롤 할 수 있습니다.</p><p><strong>참고링크</strong></p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FrOgJDQUNrJg%3Ffeature%3Doembed&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DrOgJDQUNrJg&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FrOgJDQUNrJg%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="640" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/6e005549dd933ddc9f12ae288de203cb/href">https://medium.com/media/6e005549dd933ddc9f12ae288de203cb/href</a></iframe><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FvjlP6LzK-zQ%3Ffeature%3Doembed&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DvjlP6LzK-zQ&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FvjlP6LzK-zQ%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="640" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/174fbef525691ff86a57eac00a71a470/href">https://medium.com/media/174fbef525691ff86a57eac00a71a470/href</a></iframe><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FeYfXzfnOQ_8%3Ffeature%3Doembed&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DeYfXzfnOQ_8&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FeYfXzfnOQ_8%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="640" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/15224c17a8d37c35388bc787d2f9ff00/href">https://medium.com/media/15224c17a8d37c35388bc787d2f9ff00/href</a></iframe><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ace20d6edfef" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Classes and Structures 클래스와 구조체]]></title>
            <link>https://medium.com/@kimyh1981/classes-and-structures-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EA%B5%AC%EC%A1%B0%EC%B2%B4-97e390574476?source=rss-dde95c17315b------2</link>
            <guid isPermaLink="false">https://medium.com/p/97e390574476</guid>
            <category><![CDATA[apple]]></category>
            <category><![CDATA[swift]]></category>
            <category><![CDATA[ios]]></category>
            <category><![CDATA[class]]></category>
            <category><![CDATA[struct]]></category>
            <dc:creator><![CDATA[Yong Ho Kim]]></dc:creator>
            <pubDate>Sun, 20 May 2018 02:31:03 GMT</pubDate>
            <atom:updated>2018-05-20T02:31:03.862Z</atom:updated>
            <content:encoded><![CDATA[<p>클래스와 구조체(이하 class / struct로 통일)은 통삭적인 목적의 유연한 구조체로서 여러분의 프로그램 코드 블럭을 구축합니다. 여러분은 상수, 변수 및 하수에 대한 정확히 동일한 문법을 사용하여 여러분의 class와 struct에기능을 부여하고자 여러분은 property(속성), method(함수) 를 정의하게 됩니다.</p><p>다른 프로그래밍 언어와 다르게, Swift는 커스텀 class와 struct를 위한 별도의 인터페이스와 실행 파일 생성을 요구하지 않습니다. Swift에서 여러분은 class 또는 struct를 하나의 파일에서 정의하며, 그 class 또는 struct에 대한 외부 인터페이스는 다른 코드와 사용이 가능하도록 자동으로 만들어 집니다.</p><p><strong>NOTE</strong> : class의 인스턴스는 전에는 주로 객체로서 알려져 있었죠. 하지만, Swift의 class와 struct는 다른 언어들 보다는 기능에 훨씬 가까우며, 이 장에서의 대부분도 class 또는 struct 타입 모두의 인스턴트에 적용할 수 있는 기능에 대해서 다루고 있습니다. 그 이유는 보다 보편적인 조건으로서 인스턴스가 사용되기 때문입니다.</p><h4>class와 struct 비교하기</h4><p>Swift에서 Class와 struct는 많은 공통점이 있으며, 양쪽 모두 아래 사항이 가능 합니다:</p><ul><li>값을 저장하기 위한 속성에 대한 정의하기</li><li>기능을 제공하기 위한 method 정의하기</li><li>서브스크립트 문법을 사용하여 자신들의 값에 접근할 수 있는 서브스크립트(class, struct, enum은 서브스크립트를 정의할 수 있는데, 이는 collection, list 또는 sequence 인자들의 멤버 요소에 접근 하기 위한 단축키 입니다. 서브스크립트를 이용하여 인스턴스의 이름 뒤에 “대괄호[]”안에 하나 또는 여러개의 값을 입력함으로서 타입 인스턴스 접근 함.) 정의하기</li><li>초기 상태를 설정하기 위한 이니셜라이저 정의하기</li><li>기본 구현을 넘어 자체 기능을 확장 가능</li><li>특정 종류의 표준 기능을 제공하는 프로토콜 수행하기</li></ul><p>더 자세한 정보는 우측 링크를 확인 바랍니다. <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID254">Properties</a>, <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Methods.html#//apple_ref/doc/uid/TP40014097-CH15-ID234">Methods</a>, <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Subscripts.html#//apple_ref/doc/uid/TP40014097-CH16-ID305">Subscripts</a>, <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID203">Initialization</a>, <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151">Extensions</a>, <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID267">Protocols</a>.</p><p>class의 경우는 struct가 하지 못하는 추가 기능들이 있습니다 :</p><ul><li>하나의 class가 다른 class의 특성을 상속받을 수 있음</li><li>실행되는 때에, class인스턴의 타입을 확인하고 변환하하게 해주는 타입캐스팅 가능</li><li>classd의 인스턴스가 자신이 할당 받은 어떠한 리소스로부터도 해제 될 수 있는 Deinitializer 기능 가능</li><li>class 인스턴스를 한번 참조하는 것보다 더 많은 참조를 가능하게 해주는 Reference 카운팅 가능</li></ul><p>더 자세한 정보는 우측 링크를 확인 바랍니다. <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Inheritance.html#//apple_ref/doc/uid/TP40014097-CH17-ID193">Inheritance</a>, <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TypeCasting.html#//apple_ref/doc/uid/TP40014097-CH22-ID338">Type Casting</a>, <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Deinitialization.html#//apple_ref/doc/uid/TP40014097-CH19-ID142">Deinitialization</a>, and <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID48">Automatic Reference Counting</a>.</p><p><strong>NOTE : </strong>struct는 여러분의 코드에서 사라질 때, 항상 복사가 되며, reference 카운팅을 사용하지 않습니다.</p><p><strong>문법 정의</strong></p><p>class와 struct의 문법 정의는 유사하지만, class 키워드와 struct 키워드를 사용하고, 각각 한쌍의 중괄호 안에 내용을 정의합니다 :</p><pre>class SomeClass {</pre><pre>// class definition goes here</pre><pre>}</pre><pre>struct SomeStructure {</pre><pre>// structure definition goes here</pre><pre>}</pre><p><strong>NOTE : </strong>여러분이 새로운 class 또는 struct를 정의 할 때마다, 최신의 Swift 타입을 효율적으로 정의하게 됩니다. 타입에는 표준 Swift 타입(예, String, Int, and Bool )의 대문자화를 맞추어 주기 위하여 이름에 UpperCamelCase (위에 보이는SomeClass and SomeStructure 와 같이)를 부여 합니다. 반대로, 타입 이름과 차별을 주기 위해서property와 method에는 항상 이름에 lowerCamelCase (위에 보이는frameRate and incrementCount )을 부여 합니다.</p><p>아래 class와 struct 정의에 대한 예시입니다 :</p><pre>struct Resolution {</pre><pre>    var width = 0</pre><pre>    var height = 0</pre><pre>}</pre><pre>class VideoMode {</pre><pre>    var resolution = Resolution()</pre><pre>    var interlaced = false</pre><pre>    var frameRate = 0.0</pre><pre>    var name: String?</pre><pre>}</pre><p>위는 픽셀기준 해상도를 표현하기 위하여 Resolution 으로 불리는 새로운 struct를 정의한 예시입니다. 본 struct는 width 와 height 로 불리는 2개의 저장 property를 가집니다. 저장 property는 class 또는 struct의 일부로서 묶여서 저장되는 상수 또는 변수를 말합니다. 이 2개의 property는 초기 정수 값을 0으로 설정함으로서 Int 타입으로 추론 됩니다.</p><p>위의 예시에서 또한 VideoMode 로 불리는 새로운 class도 정의를 하는데, 비디오 디스플레이를 위한 특정 비디오 모드를 표현하고자 합니다. 이 class는 4개의 변수 저장 property를 가집니다. 첫번째는 resolution 으로 resolution property 타입을 추론하는 새로운 resolution struct 인스턴스와 함께 초기화 됩니다. 다른 3개의 property를 갖는데,새로운VideoMode 인스턴스는 false ( “noninterlaced video”를 의미하는) 설정을 갖는 interlaced , 0.0의 재생 프레임 레이트를 및 name으로 불리는 옵셔널 String으로 초기화가 될 것입니다. name property는 옵셔널 타입이기 때문에nil 을 기본 값으로 자동 할당 되거나, 또는 “no name value”가 됩니다.</p><p><strong>class와 struct 인스턴스</strong></p><p>Resolution struct 정의와 VideoMode class 정의는 Resolution 또는VideoMode 가 보여지는 부분 만을 표현합니다. class와 struct가 특정한 해상도나 비디오 모드를 표현하지는 않습니다. 그러기 위해서는 struct 또는 class의 인스턴스를 만들 필요가 있습니다.</p><p>인스턴스를 만드는 문법은 양쪽 모두 매우 유사합니다:</p><pre>let someResolution = Resolution()</pre><pre>let someVideoMode = VideoMode()</pre><p>struct와 class 양쪽 모두 initializer 문법을 사용하여 새로운 인스턴스를 생성합니다. initializer 문법의 가장 간편한 양식은 class 또는 struct 의 타입 이름 뒤에 빈 괄호를 붙이는 것으로, 예를 들면 Resolution() or VideoMode() 와 같습니다. 이렇게 하면, class와 struct의 기본 값으로 초기화된 property를 갖는 class와 struct의 인스턴스가 생성되게 됩니다.</p><p><strong>property로의 접근</strong></p><p>여러분은 dot 문법(점을 찍어 접근)을 사용하여 인스턴스의 property에 접근 할 수 있습니다. dot 문법에서는 인스턴스 이름 뒤에 바로 property 이름을 기입할 수 있는데, 빈공간 없이 period (.)로 구분 합니다.</p><pre>print(&quot;The width of someResolution is \(someResolution.width)&quot;)</pre><pre>// Prints &quot;The width of someResolution is 0&quot;</pre><p>본 예시에서, someResolution.width 는 someResolution의 width property를 참조 하며 초기 값으로 0 을 반환합니다.</p><p>여러분은 또한 하위 property로 드릴다운(<strong>더 많은 정보를 찾기 위해 관련 텍스트나 아이콘 등을 클릭하여 마치 뚫고 들어가듯이 검색하는 것) 할 수도 있는 데요, 예를 들면 </strong>VideoMode의 resolution property에서 width property 가 되겠습니다:</p><pre>print(&quot;The width of someVideoMode is \(someVideoMode.resolution.width)&quot;)</pre><pre>// Prints &quot;The width of someVideoMode is 0&quot;</pre><p>또한 변수 property에 새로운 값을 할당하기 위하여 dot 문법을 사용할 수도 있습니다:</p><pre>someVideoMode.resolution.width = 1280</pre><pre>print(&quot;The width of someVideoMode is now \(someVideoMode.resolution.width)&quot;)</pre><pre>// Prints &quot;The width of someVideoMode is now 1280&quot;</pre><p><strong>NOTE : </strong>Objective-C와 다르게, Swift는 struct property의 하위 property를 바로 설정 하는 것이 가능합니다. 위 마지막 예시에서, someVideoMode 의 resolution property에 width property는 전체 resolution property에 새로운 값을 설정할 필요 없이 바로 설정이 되었습니다.</p><p><strong>struct 타입을 위한 Memberwise Initializers</strong></p><p>모든 struct는 자동 생성되는 <em>memberwise initializer</em>를 가지는데, 새로운 struct 인스턴스의 멤버 property를 초기화 하는데에 사용할 수 있습니다. 새로운 인스턴스의 property를 위한 초기 값은 이름을 통해서 memberwise initializer로 전달 될 수 있습니다.</p><pre>let vga = Resolution(width: 640, height: 480)</pre><p>struct와 다르게, class 인스턴스는 기본 memberwisw initializer를 받지 않습니다. Initializer는 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID203">Initialization</a>링크에서 보다 자세히 다루어 집니다.</p><h4>struct와 enum은 값 타입</h4><p>값 타입이란 변수 또는 상수에 할당이 되거나 또는 함수로 넘어 갈때, 값이 복사가 되는 타입을 말합니다.</p><p>여러분은 사실 앞에 챕터에서 광범위하게 값타입을 사용하신 겁니다. 사실 Swift의 모든 기본 타입들(integers, floating-point numbers, Booleans, strings, arrays, dictionaries)이 값타입이며, 씬의 이면에서 구조체처럼 실행이 됩니다.</p><p>모든 struct와 enum은 Swift에서는 값타입 입니다. 의미인 즉, 여러분이 생성하는 모든 struct와 enum의 인스턴스 및 property로서 가지는 모든 값타입은 여러분의 코드를 통과할 때 항상 복사가 된다는 것입니다.</p><p>아래 예시를 고려해보세요, 앞에 예제에서 Resolution struct를 사용한 것입니다:</p><pre>let hd = Resolution(width: 1920, height: 1080)</pre><pre>var cinema = hd</pre><p>본 예제에서는, hd 로 불리는 상수를 Resolution 인스턴스로 full HD video의 width와 heigt로 초기화를 선언하고 있습니다. (1920 pixels wide by 1080 pixels high).</p><p>그런다음, cinema 로 불리는 변수에 현재 값을 hd 를 넣어 선언하였습니다. Resolution 는 struct이기 때문에, 기존 존재하는 인스턴스의 복사본이 만들어 지는 것이며, 이렇게 새로이 복사된 것이 cinema 에 할당이 되는 것입니다. hd 와cinema 가 현재는 동일한 width와 height를 가지고 있을 지라도, 씨을 넘어선 뒤에서는 완전히 다른 두개의 인스턴트 입니다.</p><p>다음은, cinema 의 width property를 디지털 시네마 투영기(2048 pixels wide and 1080 pixels high)에 사용하기 위하여 약간 더 널은 2K 표준의 width로 수정되게 됩니다 :</p><pre>cinema.width = 2048</pre><p>Checking the width property of cinema shows that it has indeed changed to be 2048:</p><p>cinema 의 width property를 확인해 보시면, 실제로 2048 로 변경된것이 보입니다.</p><pre>print(&quot;cinema is now \(cinema.width) pixels wide&quot;)</pre><pre>// Prints &quot;cinema is now 2048 pixels wide&quot;</pre><p>하지만, 원래hd 인스턴스의 width property는 여전히 기존 값인 1920 를 가지고 있습니다 :</p><pre>print(&quot;hd is still \(hd.width) pixels wide&quot;)</pre><pre>// Prints &quot;hd is still 1920 pixels wide&quot;</pre><p>cinema 에 주어진 현재 값인 hd 가 주어졌을때, hd 에 저장된 값은 새로운 cinema 인스턴스에 복사가 되었습니다. 끝에 결과는 2개의 완전히 분리된 인스턴스로서, 동일한 숫자 값을 담기 위해 단지 생겨났을 뿐입니다. 왜냐하면, 이 2개는 분리된 인스턴스이기 때문에 cinema 의 width를2048 로 셋팅해도 hd 에 저장된 width에는 영향을 주지 않습니다.</p><p>enum에도 동일한 행위가 적용 됩니다:</p><pre>enum CompassPoint {</pre><pre>    case north, south, east, west</pre><pre>}</pre><pre>var currentDirection = CompassPoint.west</pre><pre>let rememberedDirection = currentDirection</pre><pre>currentDirection = .east</pre><pre>if rememberedDirection == .west {</pre><pre>    print(&quot;The remembered direction is still .west&quot;)</pre><pre>}</pre><pre>// Prints &quot;The remembered direction is still .west&quot;</pre><p>When rememberedDirection is assigned the value of currentDirection, it is actually set to a copy of that value. Changing the value of currentDirection thereafter does not affect the copy of the original value that was stored in rememberedDirection.</p><p>rememberedDirection 가 currentDirection 의 값에 할당이 될때, 사실 값이 복사가 되는 설정이 되는 것입니다. currentDirection 의 값을 변화하는 것이 이후에 rememberedDirection 에 저장된 원래 값으로부터 복사되었던 값에는 영향을 주지 않습니다.</p><h4>class는 참조 타입</h4><p>값타입과 다르게, 참조 타입은 상수 또는 변수에 할 당 될때 또는 함수로 넘어갈때 값이 복사가 되지 않습니다. 복사를 하는 것보다는, 기존 동일한 인스턴스에 대한 참조가 대신 사용됩니다.</p><p>Here’s an example, using the VideoMode class defined above:</p><p>아래 예시 드립니다. 위에 정의 내려논 VideoMode class를 이용한 것입니다:</p><pre>let tenEighty = VideoMode()</pre><pre>tenEighty.resolution = hd</pre><pre>tenEighty.interlaced = true</pre><pre>tenEighty.name = &quot;1080i&quot;</pre><pre>tenEighty.frameRate = 25.0</pre><p>본 예시에서는 tenEighty 라는 새로운 상수를 선언하여, VideoMode class의 새로운 인스턴스로 참조되게 끔 설정이 됩니다. video mode가 전부터 1920 by 1080 의 HD resolution에 복사본으로 할당이 됩니다. 이리저리 뒤섞인 설정인데요, &quot;1080i&quot; 로 name이 주어집니다. 마지막으로, 초당 25.0 프레임으로 프레임 레이트를 설정합니다.</p><p>다음으로는 tenEighty 를 alsoTenEighty로 불리는 새로운 상수에 할당 합니다. 그리고 alsoTenEighty 의 프레임 레이트가 수정 됩니다:</p><pre>let alsoTenEighty = tenEighty</pre><pre>alsoTenEighty.frameRate = 30.0</pre><p>왜냐하면 class는 참조 타입이기 때문에, tenEighty and alsoTenEighty 는 사실 둘다 동일한 VideoMode 인스턴스를 참조합니다. 효율적으로 하나의 동일한 인스턴스를 위해서 두개의 다른 이름을 사용한 것 뿐입니다.</p><p>tenEighty 의 frameRate property를 확인해 보시면, 내재된 VideoMode 인스턴스로부터 새로운 프레임 레이트 30.0 를 옳바로이 보여주고 있습니다:</p><pre>print(&quot;The frameRate property of tenEighty is now \(tenEighty.frameRate)&quot;)</pre><pre>// Prints &quot;The frameRate property of tenEighty is now 30.0&quot;</pre><p>tenEighty and alsoTenEighty 는 변수보다는 상수로 선언된 것을 명심하세요. 하지만, 여러분은 tenEighty.frameRate and alsoTenEighty.frameRate 는 그래도 변경할 수 있습니다, 왜냐하면 tenEighty and alsoTenEighty 상수 자신의 값이 실제로 변경하지는 않기 때문입니다. tenEighty and alsoTenEighty 자신은 대신에 VideoMode 인스턴스에 저장하지 않으며, 양쪽 모도 씬 너머의 VideoMode 인스턴스를 참조 합니다. 내재된 VideoMode 의 frameRate property는 변하지만, VideoMode 에 대한 상수 참조들의 값들은 변하지 않습니다.</p><p><strong>항등 연산자</strong></p><p>class는 참조 타입이기 때문에, 씬 넘어의 class에 동일한 하나의 인스턴스를 참조하는 여러개의 상수와 변수가 가능합니다. (struct와 enum은 다릅니다. 왜냐하면 이 두가지는 상수 또는 변수에 할당 될 때 또는 함수로 전달될 때, 항상 복사가 되기 때문입니다.)</p><p>2가지 상수 또는 변수가 class의 완전히 동일한 인스턴스를 참조하는지 알아내기 위해서 아래 방법이 때론 유용할 수 있습니다.</p><ul><li>동일 (===)</li><li>안동일 (!==)</li></ul><p>하나의 동일한 인스턴스를 2개의 상수 또는 변수가 참조하는지 아닌지를 확인하기 위해서 위에 연산자를 사용해 보세요:</p><pre>if tenEighty === alsoTenEighty {</pre><pre>    print(&quot;tenEighty and alsoTenEighty refer to the same VideoMode instance.&quot;)</pre><pre>}</pre><pre>// Prints &quot;tenEighty and alsoTenEighty refer to the same VideoMode instance.&quot;</pre><p>“identical to_동일한” (3개의 =기호로 대표되는 또는 === )는 “equal to_같은” (2개의 =기호로 대표되는 또는 == )과 같은 것을 의미하지 안음을 명심하세요:</p><ul><li>“Identical to”는 class 타입의 2개의 상수 또는 변수가 정확히 같은 class 인스턴스를 참조하는 것을 의미합니다.</li><li>“Equal to”는 2개의 인스턴스가 값에서 “equal” 또는 “equivalent_동등한” 로 고려되는 것을 의미하는 것으로서, 타입의 설계자가 정의한 “equal”의 어떤 적합한 의미를 위한 것입니다.</li></ul><p>여러분이 여러분의 커스텀 class와 struct를 정의하실때에, “equal”이 되는 2개의 인스턴스로서 무엇을 충족해야 하는지에 대한 결정을 하여야 하는 것은 여러분의 몫입니다. “equal to”와 “not equal to” 연산자를 실행하는 여러분의 고유 정의 과정은 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID45">Equivalence Operators</a>에 설명되어 있습니다.</p><p><strong>포인터(Pointers)</strong></p><p>여러분이 C, C++ 또는 Objective-C에 대한 경험이 있으시다면, 본 언어들이 메모리에서 주소를 참조하기 위해 pointers를 이용한다라는 것을 아실 겁니다. 어떤 참조 타입의 인스턴스를 참조하는 Swift의 상수 또는 변수는 C 언어의 pointer와 유사하지만, 메모리 주소에 대한 직접적인 pointer는 아니며, 여러분이 참조를 생성하였다고 표시하는 별표(*)를 작성하지 않아도 됩니다. 대신에, Swift에서는 다른 상수 또는 변수 처럼 이러한 참조들이 정의가 됩니다.</p><p><strong>class와 struct 중 사용 선택 하기</strong></p><p>여러분은 여러분의 프로그램 코드의 블록을 구축하는데 있어서 사용할 목적으로 커스텀 데이터 타입을 정의하기 위해 class 및 struct 모두를 사용할 수 있습니다.</p><p>하지만 struct 인스턴스는 항상 value에 영향을 받으며, class 인스턴스는 항상 참조의 영향을 받습니다. 서로 각기 다른 종류의 일에 적합하다는 의미 입니다. 여러분이 프로젝트를 위해 필요한 데이터 구성과 기능을 고려 하는 것처럼, 각 데이터 구성이 class 또는 struct로서 정의가 되어야 할지 결정을 하여야 합니다.</p><p>전반적인 가이드라인으로서, 아래 조건중에 하나 또는 그 이상이 적용되는 경우 struct 생성을 고려하세요:</p><ul><li>struct의 최우선 목적이 비교적 단순한 몇몇 데이터 값을 캡슐화 하는 것이다.</li><li>여러분이 struct의 인스턴스에 할당하거나 또는 배포하는 경우, 캡슐화된 값이 참조보다는 복사되는 것을 예상하는 것이 적합하다.</li><li>struct로 저장된 모든 property는 그자체로 값타입이며, 참조보다는 복사되는 것이 또한 예상되어진다.</li><li>struct는 다른 기존 타입으로부터 property 또는 행위를 상속할 필요가 없다.</li></ul><p>struct를 위해 좋은 대상이 되는 예시는 다음을 포함한다:</p><ul><li>도형의 크기, 아마도 양쪽 모두Double 타입인 캡슐화되는 width property와 width property.</li><li>연속되는 것 내에 범위를 참조하기 위한 방법, 아마도 양쪽 모두 Int 타입인 캡슐화되는 start propery와 length property.</li><li>3D 좌포에서의 좌표 포인트, 모두 Double 타입인 캡슐화되는 x, y 와z property.</li></ul><p>그 밖에 모든 경우에서는 class를 정의하며, 참조로 관리 및 배포하기위해 그 class의 인스턴스를 생성합니다.</p><p><strong>String, Array 및 Dictionary를 위한 할당 및 복사 행위</strong></p><p>Swift에서는 String, Array, 와 Dictionary 같은 많은 기본 자료형식이 struct로서 실행이 됩니다. 의미인즉, String, Array, and Dictionary 와 같은 데이터의 경우 새로운 상수 또는 변수로 할당이 되거나, 또는 함수 또는 메서드에 할당이 되는 경우 복사가 됩니다.</p><p>이런 행위가 Foundation에서 다릅니다 : NSString, NSArray, and NSDictionary 는 struct가 아닌 class로서 실행이 됩니다. Foundation에서 String, array 및 dictionary는 복사가 되는 것보다는 기존 인스턴스에 대한 참조로서 항상 할당 되며, 배포가 됩니다.</p><p><strong>NOTE</strong></p><p>위의 설명은 string, array 및 dictionary의 “copying”을 참조 합니다. 여러분의 코드에서 여러분이 보는 행위는 항상 마치 복사가 일어난 것처럼 될 것입니다. 하지만 Swift는 실행이 정말 필요한 경우에야 씬의 이면에서 실제 복사를 수행 합니다. Swift는 최상의 성능을 보장하기 위하여 복사되는 모든 값을 관리하며, 이러한 최적화를 선점하한 할당은 피해야 합니다.</p><p><strong>Note</strong> <strong>:</strong> 본 내용은 Apple공식 문서 내용입니다.저는 iOS와 Swift와 관련된 좋은 기사 또는 공식 문서를 한글로 번역하여 공유하고 있습니다. This article is originally from Apple. This blog is aiming to share good information with those who are interested in Swift programing language and iOS development, but it is translated in Korean.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=97e390574476" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Start Developing iOS Apps (Swift)]]></title>
            <link>https://medium.com/@kimyh1981/start-developing-ios-apps-swift-70e8faac300?source=rss-dde95c17315b------2</link>
            <guid isPermaLink="false">https://medium.com/p/70e8faac300</guid>
            <category><![CDATA[swift]]></category>
            <category><![CDATA[developing-ios-app]]></category>
            <category><![CDATA[build-ui]]></category>
            <category><![CDATA[ios]]></category>
            <category><![CDATA[apple-basic-ui]]></category>
            <dc:creator><![CDATA[Yong Ho Kim]]></dc:creator>
            <pubDate>Sat, 12 May 2018 04:55:40 GMT</pubDate>
            <atom:updated>2018-05-15T08:09:21.224Z</atom:updated>
            <content:encoded><![CDATA[<h3>Swift를 통한 iOS 앱 개발 시작하기</h3><p>이번 article은 Part1, 2로 나누어서 UI 구축과 Table Views 생성 작업을 연재하고자 합니다. 상단의 타이틀을 클리하시면, 원문 애플 공식 홈페이지로 연결 됩니다. 그 첫번째 순서로 Part1 중 기본 UI 구성하기 입니다. (<strong>번역의 변</strong> : 실제 Xcode(iOS 어플리케이션을 제작하기 위한 애플의 공식 툴)에서 사용되는 용어와 Xcode 툴(모든 것이 영어로 되어 있음)에서 보이는 용어는 영어 그대로 하여 따로 번역하지 않았습니다, 실제 사용하실 때에 직관적으로 보이는 것이 도움이 되실 듯 하며, 한번씩 직접 단어를 찾아 의미를 확인하여 뜻을 알고 사용하시는 것을 추천 드립니다.)</p><h3>Part 1 : Building the UI</h3><ul><li><strong>Building a Basic UI : 기본 UI 구성하기</strong></li><li>Connect the UI to Code : 코드와 UI를 연결하기</li><li>Work with View Controllers : View Controller와 작업하기</li><li>Implement a Custom Control : 커스텀 조작 실행하기</li><li>Define your Data Model : Data Model 정의 하기</li></ul><h3>기본 UI 구성하기</h3><p>본 과정에서는 앱 개발을 위해 사용하게 될 툴인 Xcode와 익숙해지는 것이 목적입니다. Xcode에에서 프로젝트의 구조에 익숙해 질 것이며, 기본 프로젝트 구성요소들을 사용하고 그 사이에 상관관계를 알고 어떻게 조정하여야 하는지를 배우게 될 것입니다. 또한 본 과정에서는 FoodTracker 앱을 위한 간단한 <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW18">user interface (UI)</a> 을 만들어보는 것으로 시작하여, 직접 시뮬레이터로 구동하여 보도록 하겠습니다. 본 과정을 마칠 때가 될때면, 음식의 이름, 음식 이름을 변경할 텍스티 필드 그리고 이름을 재설정 하기 위한 버튼을 구성한 앱이 탄생될 것입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/774/1*3KxqT5AAaKRD04hkxzSJbQ.png" /></figure><h4>객체 배우기</h4><p>본 과정을 마치시면, 아래의 사항을 하실 수 있을 거에요:</p><ul><li>Xcode에서 프로젝트 생성하기</li><li>Xcode 프로젝트 템플릿을 이용하여 생성되는 주요 파일들의 목적을 구별하기.</li><li>프로젝트에서 파일들과의 사이에서 오픈하고 위치 변환하기.</li><li>iOS 시뮬레이터를 통해서 앱을 실행하기.</li><li>UI 구성 요소들을 스토리보드 상에서 추가하고, 움직이고, 사이즈를 변경하기.</li><li>Attributes inspector를 사용하여 스토리보드 상에서 UI 구성요소들의 속성을 편집하기.</li><li>outline view를 이용하여 UI 구성 요소들을 보여주고, 재 정렬하기.</li><li>Assistant editor의 Preview 모드를 이용하요 스토리보드 UI를 미리 보기.</li><li>사용자의 기기 사이즈에 맞추어 자동으로 UI를 적용할 수 있도록 레이아웃을 잡아주는 Auto Layout 사용하기.</li></ul><h4>새로운 프로젝트 생성하기</h4><p>Xcode는 게임, 텝 기반 네비게이션(차량운행 네비게이터 아님,,,), 및 테이블뷰 기반 등 기본적인 iOS 앱 타입을 개발하기 위해 사용할 수 있는 여러가지 기본 제공 앱 템플릿을 포함하고 있습니다. 대다수의 템플릿이 인터페이스와 소스코드 파일을 미리 구성하고 있습니다. 본 과정에서는 가장 기본 템플릿을 이용하여 시작하도록 하겠습니다(Single View Application_View가 하나인 앱).</p><p><strong>새로운 프로젝트 생성하기</strong></p><ol><li>Xcode를 실행하십시오.</li></ol><p>Xcode 실행이 처음 이신경우, 사용자 동의와 추가 구성에 대한 다운로드를 요청 받으실 겁니다. Xcode 설정이 완료되어 실행이 완전히 준비가 될 수 있도록 아래 스크린샷을 통한 지시사항을 따라주시기 바랍니다. Xcode가 실행이 되면 바로 아래 Welcome to Xcode화면이 나타날 것입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Kk8fMtOWmWObIZFfTpjM_Q.png" /></figure><p>만일 위에 화면이 아닌 프로젝트 화면이 나타나더라도 걱정마세요, 아마도 이전에 이미 프로젝트 파일을 생성하여 열었을 겁니다. 프로젝트 생성을 위하여 다음 단계에서 메뉴 아이템을 이용하시면 됩니다.</p><p>2. Welcome 화면에서, Create a new Xcode project 또는 (File 선택 &gt; New &gt; Project)를 클릭하세요. 새로운 화면이 열리고, 선택할 템플릿이 보일거에요.</p><p>3. 화면 가장 위에 iOS를 선택하세요.</p><p>4. Application 부분에서, Single View Application을 선택하시고, Next 버튼을 클릭하세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*wkCeQ9RELJ9AaBmYZ-YELQ.png" /></figure><p>5. 다음에 나타나는 창에서, 프로젝트에 대한 사항으로 앱 이름 및 추가 옵션사항들을 아래 내용에 따라 진행 바랍니다:</p><ul><li>Product Name: FoodTracker</li><li>Xcode는 product name에 기입하신 이름을 프로젝트와 앱의 이름으로 사용합니다.</li><li>Team: If this is not automatically filled in, set the team to None.</li><li>Team: 자동으로 채워지는게 없으면, 그냥 아무것도 없는 것으로 설정하세요.</li><li>Organization Name: 조직의 이름 또는 본인 이름을 넣으시면 되고요, 그냥 빈칸으로 두셔도 됩니다.</li><li>Organization Identifier: 조직 식별자가 있으시면 넣으시고요, 없으시면, com.example을 이용하세여요.</li><li>Bundle Identifier: 이부분은 프로젝트의 이름과 조직 식별자를 바탕으로 하여 자동생성 됩니다.</li><li>Language: Swift</li><li>Devices: Universal</li><li>유니버셜 앱은 iPhone과 iPad 양쪽에서 구동이 되는 앱입니다.</li><li>Use Core Data: Unselected.</li><li>Include Unit Tests: Selected.</li><li>Include UI Tests: Unselected.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*BdyDQkdD49BNo1V0ZNrVeQ.png" /></figure><p>6. Next를 클릭하세요.</p><p>7. 다음에 나타나는 창에서는 프로젝트파일을 저장할 위치를 선택하시고, Create를 클릭하세요. Xcode는 <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW9">workspace window</a>에서 여러분의 새로운 프로젝트를 열게 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*wtKeV5fpvnFQ58_NF_BSxw.png" /></figure><p>workspace 창에서 “Signing for FoodTracker requires a development team.”라는 메세지를 보이는 에러 아이콘이 보일겁니다. 아직 iOS 개발을 위해서 Xcode 설정을 하지 않으셔서 인데요, 걱정하지 마시고요, 이부분 없이도 본 과정을 완료하는데 문제 없습니다. 시뮬레이터에는 앱을 구동해보는데 development team필요하지는 않습니다.</p><blockquote><strong>추가로 더 알아보기</strong></blockquote><blockquote>iOS 기기에서 앱을 실행 시킬수 있게 하려면, 유효한 팀을 설정하셔야 앱이 서명이 될 수 있습니다. 만일 여러분이 Apple Developer Program의 회원인 조직의 일원이거나 또는 개인인 경우, 팀을 선택하시면 됩니다. 그렇지 않으면, 여러분의 Apple ID는 기기에서 앱을 실행하기위해 사용할 수 있는 개인 팀으로 할당이 됩니다. 하지만, 앱을 앱스토어에 제출하시기 전에는 Apple Developer Program에 가입을 하셔야 합니다.</blockquote><blockquote>더많은 정보를 위해서는 상단에서 Help &gt; Xcode Help and search for “Signing workflow.”을 선택하여 확인바랍니다.</blockquote><h4>Xcode에 익숙해 지기</h4><p>Xcode는 앱을 개발하기 위해 필요한 모든것이 있습니다. 앱 생성을 위한 모든 파일과 리소스를 구성하고 있습니다. 개발자의 코드와 사용자 인터페이스 모두를 위한 편집기를 제공할 뿐만 아니라, Xcode는 iOS 기기에 대한 시뮬레이터와 강력한 통합 debugger를 제공함을로써, 앱의 구축, 구동 및 디버깅 모두가 가능하게 합니다.</p><p>Xcode의 workspace의 주요 부위별로 직접 익숙해 질 수 있도록 몇가지를 살펴주시기 바랍니다:</p><ul><li><strong>Navigator area.</strong> 프로젝트의 다양한 부분에 빠르게 접근할 수 있도록 해줍니다.</li><li><strong>Editor area.</strong> 소스코드, 유저인터페이스 및 그 밖에 리소스를 편집할 수 있도록 해줍니다.</li><li><strong>Utility area.</strong> 선택된 아이템에 관한 정보와 맞춤형 리소스에 대한 접근을 제공합니다. 본 부분은 두 파트로 나뉘는데요, 상단 부분은 <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW46">inspector pane</a>로서, navigator 또는 edit 부분에서 선택한 아이템에 대한 정보를 검토 및 편집 할 수 있습니다. 아래부분은 <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW126">library pane</a>로서 유저 인터페이스 요소, 코드 단축기 및 그 밖에 리소스에 접근할 수 있습니다.</li><li><strong>Toolbar.</strong> 앱을 구축하고, 실행하는데 사용되기도 하며, 작업물 구동의 진행상황 및 작업 환경을 파악할 수도 있습니다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*n1wYPoy0juPiTgPIVPPQAw.png" /></figure><p>이것 저것 엄청 많다고 기죽지 마시기 바랍니다. 다 필요하면 그 때마다 자세한 설명을 보시면 되니까요.</p><h4>iOS 시뮬레이터 구동하기</h4><p>분의 프로젝트는 Xcode 템플릿을 기반으로 하고 있기 때문에, 기본 앱 환경은 자동으로 설정이 됩니다. 아무런 코드를 작성하시지 않으셨을 지라도, 추가 구성 없이도 Single View Application 템플릿만으로도 구축 및 구동이 가능합니다.</p><p>앱을 구축하고 구동하기위해서는 Xcode에 이미 장착되어 있는 iOS <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW48">Simulator</a> 앱을 이용하면 됩니다. 실제 기기에서 앱이 구동 되면 어떤 모습일지, 동작은 어떨지 아이디어를 줄 것입니다.</p><p>iOS 기반의 다양한 기기별로도 커버가 가능한데요, iPad와 iPhone 에 대한 모든 스크린 사이즈와 해상도를 제공하여, 개발하는 타겟 기기 모두에 앱을 테스트 해 볼 수가 있습니다. 본 과정에서는 아이폰 7을 선택하여 사용바랍니다.</p><p><strong>시뮬레이터에서 앱을 실행하기 위해서는</strong></p><ol><li>Xcode toolbar의 Scheme pop-up에서 아이폰 7을 선택하세요. Scheme pop-up메뉴에서 앱을 구동하고자 하는 기기 또는 시뮬레이터를 선택 할 수 있습니다. 아이폰 7 시뮬레이트 선택을 정확히 해주세요.</li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/842/1*U7XX_11HegBHIRMN80EcPA.png" /></figure><p>2. Run 버튼을 클릭하세요. (왼쪽 상단 코너를 확인 바랍니다.)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*YrdQk1gxbGWLKHR63xNgbQ.png" /></figure><p>다른 방법으로도 가능한데요, Product&gt;Run을 선택 하셔도 됩니다. (또는 Command-R을 누르셔도 됩니다.)</p><p>앱을 처음 실행 해보시는 경우, Xcode는 이의 맥에서 개발자 모드를 활성화 할 지 요청합니다. 개발자 모드를 활성화 하게 되면 매번 여러분의 비밀번호를 넣는 것을 요구받지 않고 특정 디버깅 기능에 Xcode가 접근할 수 있습니다. 개발자 모드를 활성화 할 것인지 결정하셨다면, 지시를 따르시면 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/928/1*ni3MZWTzEioV-i2bUvUdrw.png" /></figure><p>개발자 모드 활성화를 선택하지 않으신다면, 추후에 비밀번호를 요청 받으실 거에요. 본 레슨에서는 개발자 모드 활성화를 가정하여 진행 됩니다.</p><p>3. 빌드 프로세스가 완료되는지 Xcode 툴바를 지켜보시기 바랍니다. Xcode는 툴바의 가운데에 위치한 <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW24">activity viewer</a>에서 빌드 과정에 대한 메세지를 보여 줍니다.</p><p>여러분의 프로젝트 구축(빌드)가 완료 되면, 시뮬레이터가 자동으로 시작됩니다. 처음 시작하게 되면, 다소 시간이 걸리기도 합니다.</p><p>시뮬레이터는 여러분이 선택한 아이폰 모드를 실행 시키면서 앱을 구동합니다. 초기에는 시뮬레이터가 여러분의 앱의 런치 스크린을 보여 주며, 이내 앱의 메인 인터페이스로 변경됩니다. 변경된 사항이 전혀 없는 Single View Application 템플릿에서는 런치 스크린과 메인 인터페이스가 동일합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/774/1*cZEkTUNGujqBixUeV6ze2A.png" /></figure><p>지금 당장은 Single View Application 템플릿이 많은 것을 실행하지는 않습니다, 그저 하얀 화면을 보여줄 뿐입니다. 그 밖에 다른 템플릿은 좀더 복잡한 동작을 가지고 있습니다. 템플릿을 여러분의 앱에 확장 적용하기 전에 템플릿의 사용에 대한 이해가 중요합니다. 수정 사항 없이 시뮬레이터에서 여러분의 앱을 구동하는 것이 이해하고 개발하는 것을 시작하는데 좋은 방법입니다.</p><p>Simulator&gt;Quit Simulator를 선택하여 시뮬레이터를 멈추시면 됩니다. (또는 Command-Q를 누르세요)</p><h4>소스코드 살펴보기</h4><p>Single View Application 템플릿은 앱 환경을 설정하는 몇가지 소스코드를 가지고 있습니다. 우선 AppDelegate.swift file을 살표보도록 하겠습니다.</p><p><strong>AppDelegate.swift 소스파일 살펴 보기</strong></p><ol><li>project navigator를 navigator 영역에서 열어 주세요. <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW57">project navigator</a>는 여러분의 프로젝트에 있는 모든 파일을 보여 줍니다. project navigator가 열려 있지 않으면, navigator selector bar에서 가장 왼쪽 버튼을 클릭하여 주세여요. (View &gt; Navigators &gt; Show Project Navigator를 선택하여 할 수도 있습니다.)</li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/957/1*BGSXtzrhCqsDKE009GVM6Q.png" /></figure><p>2. 필요한 경우, project navigator 내에 FoodTracker 폴더에 돌출된 삼각형을 클릭하십시오.</p><p>3. AppDelegate.swift 를 선택하세요. Xcode가 주 편집 창에서 소스 코드를 엽니다.</p><p><strong>App Delegate Source File</strong></p><p>ApplDelegate.swift 소스 파일은 2가지의 주요한 기능이 있습니다 :</p><ul><li>AppDelegate 클래스에 대한 정의가 되어 있습니다. <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW27">app delegate</a> 는 여러분이 만드는 앱의 내용물이 그려지는 window를 생성하며 또한 앱 내에서 상태 변화가 잃어 날 경우 그에 대한 응답으로 장소를 제공합니다.</li><li>또한 앱에 <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW37">entry point</a>(시작점)을 생성하며, 입력되는 이벤트들을 앱으로 전달하는 <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW61">run loop</a>도 생성을 합니다. 파일의 최상단으로 나타나는 UIApplicationMain 속성인 (@UIApplicationMain)를 통해 본 작업이 완료되게 됩니다.</li><li>UIApplicationMain 속성을 이용하는 것은 UIApplicationMain 기능을 호출하고, 이의 AppDelegat 클래스의 이름을 delegate 클래스의 이름으로서 전달하는 것과 동등합니다. 이에 대한 반응으로 시스템에서는 <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW75">application object</a>를 생성합니다. 이 application 객체는 앱의 생명주기를 관리하는 일을 합니다. 또한 시스템에서는 여러분의 AppDelegate 클래스 인스턴스를 생성하여, 이것을 application 객체에 할당합니다. 마지막으로 시스템은 앱을 실행합니다.</li></ul><p>AppDelegate클래스는 새로운 프로젝트가 생성 될 때마다 자동으로 생성이 됩니다. 개발자가 뭔가 하지 특별히 하지 않는한, 앱을 실행시키고, 앱단에서 이벤트에 잘 반응이 될 수 있도록 Xcode에서 제공하는 상태로 이 클래스를 사용하는 것이 좋습니다. AppDelegate 클래스는 UIApplicationDelegate 프로토콜을 적용합니다. 이 프로토콜로 말하자면, 앱을 설정하고, 앱 상태 변화에 대응하고, 그 밖에 앱단에서의 이벤트를 처리하기 위하여 여러분이이사용하는 수많은 methods를 정의하고 있습니다.</p><p>AppDelegate 클래스는 하나의 property를 포함하고 있는데요 : window.</p><blockquote>var window: UIWindow?</blockquote><p>본 프로퍼티는 앱의 window에 대한 레퍼런스를 저장합니다. 이 window는 앱의 view 하이라키의 루트(Root)를 대표합니다. 이게 바로 앱의 모든 내용이 작성되는 곳입니다. window 프로퍼티는 어떤 부분에서는 값을 가지지 않는(<a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW5">nil</a>이되는) 것을 의미하는 <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW11">optional</a>임을 명심하시기 바랍니다.</p><p>AppDelegate 클래스는 또한 아래delegate <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW12">methods</a>의 <a href="https://blog.naver.com/dragmove/220199498169">스텁구현</a>을 포함하고 있습니다.</p><blockquote>func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool</blockquote><blockquote>func applicationWillResignActive(_ application: UIApplication)</blockquote><blockquote>func applicationDidEnterBackground(_ application: UIApplication)</blockquote><blockquote>func applicationWillEnterForeground(_ application: UIApplication)</blockquote><blockquote>func applicationDidBecomeActive(_ application: UIApplication)</blockquote><blockquote>func applicationWillTerminate(_ application: UIApplication)</blockquote><p>이 method들을 통해서 앱 delegate와 application 객체와 소통이 가능합니다. 앱이 상태 변화가 일어나는 동안, 예를 들면, 앱이 시작되고 background로 들어가고, 앱미 종료가 되는 경우, application 객체는 그에 상응하는 delegate method를 호출하여, 앱이 반응할 수 있도록 하게 합니다. 이 method들이 필요한 정확한 시간에 호출이 되도록 하게 하기 위해서 딱히 하셔야 하는 일은 없습니다. application 객체가 그일을 해주기 때문입니다.</p><p>각각의 delegate method들은 기본 행동을 가지고 있습니다. 만약 템플릿 실행부를 비우거나 또는 AppDelegate 클래스에서 이것을 삭제를 하는 경우, method가 호출이 될 때마다 기본 동작을 얻게 됩니다. 반대로, method들이 호출 될때 실행 되는 커스텀 행동을 정의하는 여러분의 코드를 methods 꾸러미에 추가 할 수도 있습니다.</p><p>템플릿은 또한 각각의 method 꾸러미에 대한 코멘트도 제공합니다. 이 코멘트를 통해 이 method들이 앱에서 어떻게 사용이 되는지 알수 있습니다. 여러분은 본 method꾸러미와 코멘트를 가장 일반적인 앱단의 행동을 설계하는 청사진으로서 사용할 수도 있습니다.</p><p>본 과정에서는 커스텀 app delegate 코드는 전혀 사용하지 않을 것이며, 따라서 AppDelegate.swift 파일을 변경시킬 필요가 전혀 없습니다.</p><p><strong>View Controller Source File</strong></p><p>Single View Application 템플릿 안 에는 또 다른 소스 코드 파일인 ViewController.swift가 있습니다. ViewController.swift를 선택하여 주십시오.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*abZJlpQQojpKdnMDIStjZA.png" /></figure><p>이 파일에서는 ViewController로 이름 지어진 UIViewController의 커스텀 <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW14">subclass</a>를 정의하고 있습니다. UIViewController에 의해서 정의된 모든 행동을 바로 여기 이 클래스에서 간단히 상속받고 있습니다. 본 행동을 재정의하거나 또는 확장하고자 할 때에는 UIViewController상에 정의된 methods를 재정의 하셔야 합니다.</p><p>ViewController.swift 파일에서 보시는 것처럼, 템플릿의 실행함으로서viewDidLoad()와 didReceiveMemoryWarning() methods 양쪽 모두를 재정의하고 있습니다. 하지만, 템플릿의 <a href="https://blog.naver.com/dragmove/220199498169">스텁구현</a>에서는 이 methods의 UIViewController 버전을 호출하는 것을 제외하고는 아직 아무런 것도 진행하지 않습니다. 이러한 이벤트들에 대한 view controller의 대응을 다른 사용목적에 맞춰 바꾸기 위하여 여러분의 코드를 추가 하셔도 됩니다.</p><p>템플릿에 didReceiveMemoryWarning() method를 수반하고 있을지라도, 이번 과정에서는 본 method를 실행할 필요는 없을 것이며, 따라서 그냥 진행하시고, 삭제하시기 바랍니다.</p><p>자 이 부분에서, ViewController.swift 코드를 보자면, 아래와 같아야 합니다. (Medium에서 Xcode의 코드 실제 모습과 동일하게 작성하기가 어려워 실제와는 코드의 줄 당 들여쓰기의 형태 및 코드의 컬러등이 다름을 알려 드립니다.)</p><ol><li>import UIKit</li><li>class ViewController: UIViewController {</li><li>override func viewDidLoad() {</li><li>super.viewDidLoad()</li><li>// Do any additional setup after loading the view, typically from a nib.</li><li>}</li><li>}</li></ol><p>본 과정에서는 본 소스코드에 여러분이 코드 작성을 시작 할 것입니다.</p><h4><strong>Storyboard 열기</strong></h4><p>앱 개발을 위해 스토리보드 작업을 시작할 준비가 되셨을 텐데요, <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW8">storyboard</a>란 내용물(컨텐츠)의 스크린과 스크린 사이에서의 변화를 보여주는 앱의 유저인테페이스로서 보여주는 것을 대표한다고 보시면 되겠습니다. 여러분은 여러분의 앱을 구동하는 흐름 또는 스토리를 배치하기 위하여 스토리보드를 이용하게 됩니다. 앱을 구축 하실 때에 여러분이 무엇을 구축하고 있는지 확실히 눈으로 확인할 수 있으며, 무엇이 작동이 되고 무엇이 작동이 되지 않는지 즉각적인 피드백을 받을 수 있으며, 유저 인터페이스를 눈으로 직접 확인하면서 곧바로 변경 할 수 있습니다.</p><p><strong>스토리보드를 열기 위해서는</strong></p><p>project navigator에서 Main.storyboard를 선택하십시오. Xcode에서는 <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW47">Interface Builder</a> (editor 영역에 있는 visual interface editor)상에서 스토리보드를 엽니다. 스토리보드의 뒷배경은 <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW6">canvas</a>입니다. 여러분은 이 캔버스 위에 유저 인터페이스 요서들을 추가하고 정렬하게 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*MyBSdD9bKbA4FLL8RYIc_w.png" /></figure><p>이 시점에서, 여러분의 앱상에서 스토리보드는 여러분의 앱에 내용물의 스크린을 대표하는 하나의 씬(<a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW62">scene</a>)을 포함합니다. 캔버스 왼쪽으로 가리키는 화살표는 <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW66">storyboard entry point</a>(스토리보드의 시작점)이며, 의미인 즉, 앱이 시작할 때에 처음 불리어지는 화면이라는 뜻입니다. 이 씬은 view controller가 컨트롤 하는 single view하나를 가지고 있습니다. views와 view controller가 하는 역할이 무엇인지 곧 더 배우게 될 것입니다.</p><p>아이폰 7 시뮬레이터 앰에서 여러분의 앱을 구동을 할 시에, 씬의 view는 기기 스크린에서 볼 내용이 되겠습니다. 하지만, 캔버스에 씬이 시뮬레이터의 스크린과 동일한 사이즈를 가지지 않을 수도 있습니다. 캔버스의 아래부분을 보면 스크린 사이즈와 화면의 방향을 선택할 수 있습니다. 우리 과정의 경우, 세로 방향으로 아이폰 7을 설정하여, 캔버스와 시뮬래이터가 동일하게 되도록 맞춰주도록 합시다.</p><p>캔버스가 특정 기기와 방향을 부여줄 지라도, <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW25">adaptive interface</a>(자동으로 조정해 주는 인터페이스)를 생성해 주는 것이 중요합니다, 그래야 어떠한 기기와 어떠한 방향에서도 화면이 알맞게 나올 수 있습니다. 인터페이스를 개발해 봄으로서, 캔버스의 view를 변경할 수도 있고, 여러분의 인터페이스가 다른 사이즈의 스크린에 어떻게 적용되는지 볼 수도 있습니다.</p><h4>기본 UI 구축하기</h4><p>자 이제 기본 인터페이스를 구축해보도록 하겠습니다. 여러분의 음식 추적 앱인 FoodTracker에 새로운 음식을 추가 할 수 있도록 씬에 유저 인터페이스 작업을 시작해보도록 하겠습니다.</p><p>Xcode에서는 여러분이 스토리보드 파일에 추가할 수 있는 객체 라이브러리를 제공합니다. 이중에 몇가지 예를 들면 버튼이나 텍스트필드와 같은 것은 유저 인터페이스에 보이는 요소 드립니다. 그 밖에 view controller와 gesture recognizer와 같이 스크린에 나타나지는 않지만 여러분 앱의 행동을 정의하는 것들도 있습니다.</p><p>유저 인터페이스에 나타나는 요소는 view라고 알고 계실텐데요, <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW16">Views</a>는 유저에게 내용물(컨텐츠)을 디스플레이 합니다. Views은 깔끔하고, 유려하고, 유용한 방법으로 여러분의 내용물을 표현하고 또한 유저 인터페이스를 구성하기 위해 구축되는 블록입니다. Views는 스크린에서 자기들을 표시하고 유저의 입력에 반응하는것을 포함하여 다양하고 유용한 행동들을 이미 가지고 있습니다.</p><p>iOS에 있는 모든 view 객체는 UIView 타입 또는 UIView의 subclasses 중에 하나 입니다. 많은 UIView subclasses 들이 외관과 행동에 매우 특화 되어 있습니다. 여러분의 씬에 텍스트필드(UITextField)를 추가하는 것으로 시작을 해봅시다, 바로 이게 UIView의 subclasses 중의 하나 입니다. 유저는 텍스트필드에서 한줄의 텍스트를 기입할 수 있으며, 여러분은 이부분을 음식의 이름으로 사용하도록 하겠습니다.</p><p><strong>텍스트필드 추가하기</strong></p><p>1. Editor &gt; Canvas를 차례로 선택 하시고, Show Bounds Rectangles가 선택되도록 하세요. 이렇게 설정하시면, 인터페이스 빌더로 하여금 캔버스 상에 모든 view들 주위로 파란색 바운딩된 박스를 그릴 수 있게 합니다. 많은 view들과 조작들이 투명한 배경을 가지고 있어서 실제 사이즈를 확인하기가 어렵습니다. 시스템에서 view의 사이즈를 재조정할때, 레이아웃 버그가 발생이 되는데요, 그래서 여러분이 예상했던 것보다 사이즈가 크거나 작을수 있습니다. 그래서 셋팅을 활성화 시키면, view 하이라키를 통해서 어떻게 진행되고 있는지를 정확하게 이해하는데 도움이 될 것입니다.</p><p>2. 객체 라이브러리를 여세요.</p><p>3. <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW54">Object library</a>는 Xcode 우측에 <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW72">utility area</a> 하단에 나타납니다. 만일 Object 라이브러리가 보이지 않으시면, 라이브러리 선택바의 왼쪽에서 3번째 버튼을 누르시면 됩니다. (우측과 같은 순서로 선택하셔도 됩니다. View &gt; Utilities &gt; Show Object Library.) 그러면 아래 그림과 같이 각 객체의 이름, 설명 그리고 각기 모양을 보여주는 리스트가 뜹니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/876/0*mmuQCEmWANcvJ2MU.png" /></figure><p>4. Object 라이브러리에서, filter field에 text field 를 타이핑하여 Text Field 객체를 빠르게 찾을수 있습니다.</p><p>5. Text Field 객체를 Object 라이브러리에서 드래그하여 씬으로 가져가세요. 캔버스가 작게 보이면, Editor &gt; Canvas &gt; Zoom를 선택하여 더 키울 수 있습니다. (맥북의 경우, 트랙패드에서 두손가락으로 터치하여 벌려주시면 커집니다.)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/893/0*LH9y9Z3JUODhIciv.png" /></figure><p>6. Text Field를 씬의 위쪽 반쯤에 위치하도록 가져간 다음 씬의 왼쪽 마진에 맞추어 정렬해 주세요. 왼쪽 마진에 맞으면 드래그를 멈춥니다. 파란색 레이아웃 가이드의 도움을 받아 text field를 위치 하면 됩니다. 레이아웃 가이드는 객체를 드레그 하거나 레이아웃 가이드 옆에서 객체의 사이즈를 변경 할때만 보이며, text field를 놓으면 사라 집니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/836/0*hcaqblW3lB4axB8F.png" /></figure><p>7. 필요하면 리사이즈 핸들을 드러내기 위해서 text field를 클릭합니다. 유저 인터페이스 요소(여기서는 text field)를 <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW60">resize handles</a>를 드래그하여 사이즈를 조정합니다, text field의 경계선에 하얀색 작은 사각형이 나타나는데요, 그부분을 잡고 드래그 합니다. 언제든지 text field를 클릭하면 resize handles가 나타납니다. 드래그 하다가 멈출 시에는 text field가 이미 선택된 상태가 됩니다. text field가 아래 그림과 같이 보인다면, 사이즈 조정이 가능한 상태가 된것이며, 아래와 같이 보이지 않는다면, 다시한번 클릭하세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/831/0*6fIxKos8ndlZ-zJQ.png" /></figure><ol><li>text field의 왼쪽 오른쪽 모서리를 세로로된 3개의 레이아웃 가이드(점선)가 보일때 까지 사이즈를 조정해 줍니다: 왼쪽 마진 정렬, 수평 가운데 정렬 그리고 오른쪽 마진 정렬. 여러분의 씬에 text field를 가지고 있는데도 불구하고, field에 무엇을 입력하여야 하는지 사용자에게 가르쳐 주는 지침이 없습니다. 이럴 경우, text field의 placeholder text를 사용하는데요, 사용자가 새로운 음식의 이름을 입력하도록 알려 줄 수 있습니다.</li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/829/0*dNK7Sfh5sF2YmxLd.png" /></figure><p><strong>text field의 키보드 구성 하기</strong></p><ol><li>text field가 선택된 상태로 유지 시켜 주세요.</li><li>Attributes inspector 영역에서, Return Key를 찾아 Done을 선택하세요. (안보이시면 스크롤을 아래로 내려서 찾아보세요.) 이렇게 변경하면 키보드의 Return key 초기 설정을 Done key로 하였기 때문에 사용자에게 보다 명확하게 보여줄 수 있습니다.</li><li>Attributes inspector영역에서, “Auto-enable Return Key의 체크박스를 선택해 주세요. (안보이시면 다시 스크롤을 아래로 내려서 찾아보시기 바랍니다.) 이렇게 하면, text field에 입력을 하기 전에는 Done 키를 탭할 수가 없어서, 사용자로 하여금 음식 이름과 같은 string(문자)을 입력하지 않을 수 없게 합니다.</li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/544/0*pWEfWnn_7GTFyPYs.png" /></figure><p>다음으로는 label(UILabel)을 씬의 상단에 추가해 주세요. label은 정보를 입력하는 곳이 아니고, 유저 인터페이스에 정적인 텍스트를 표시해주는 기능을 합니다. 유저 인터페이스의 요소들 사이에 상호작용을 어떻게 정의하는지 이해를 돕고자, text field에 사용자가 입력하게 되는 텍스트를 보여주기 위해 이 라벨을 이용하도록 하겠습니다. 이렇게 해보는 것이 text field에 사용자들이 입력을 하게 만들고 적합하게 처리가 되는 것을 시험해 보는 좋은 방법이 될 것입니다.</p><p><strong>씬에 라벨 추가하기</strong></p><ol><li>Object 라이브러리에서, Label 객체를 빠르게 찾기 위해 필터에서 label 타이핑 하세요.</li><li>Label 객체를 라이브러리에서 여러분의 씬으로 드레그 하세요.</li><li>label을 앞서 놓은 text field의 바로 위에 위치하고 씬의 왼쪽 마진에 맞추어 드레그 하세요. 가이드라인에 label이 맞으면 드래그를 멈추세요.</li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/841/0*eNdtyqjnCJt0lbwx.png" /></figure><p>4. label을 더블 클릭하고 Meal Name이라고 타이핑해 넣으세요.</p><p>5. label에 새로운 텍스트를 보여 주도록 Return을 누르세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/833/0*0QBrntvxQ-g_9LDf.png" /></figure><p>이제, 버튼(UIButton)을 씬에 추가하세요. 버튼은 상호작용을 하는 객체로서, 사용자가 탭하여 여러분이 정의하신 행동이 일어나도록 하게 합니다. 나중에, label 텍스트를 초기 값으로 리셋하는 행동을 만들어 볼 것입니다.</p><p><strong>씬에 버튼 추가 하기</strong></p><ol><li>Object 라이브러리에서, Button 객체를 빠르게 찾기 위해 필터에서 button을 타이핑 하세요.</li><li>Button 객체를 씬으로 드래그 하세요.</li><li>button을 text field의 바로 아래에 위치시키고, 씬의 왼쪽 마진에 맞추어 정렬 되도록 드래그 하세요. button이 가이드라인에 맞게 들어오면 드래그를 멈추세요.</li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/844/0*HWkAOeftoGwIQTzc.png" /></figure><p>4. button을 더블클릭하고 Set Default Label Text라고 타이핑 하세요.</p><p>5. button에 새로운 텍스트가 보이도록 Return을 누르세요.</p><p>6. 필요하면, button의 위치를 변경하세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/834/0*vsZg6RVTakUUdJSj.png" /></figure><p>여러분이 추가하신 요소 들이 실제로 씬에서 어떻게 정렬이 되는지 이해하는데 좋았네요. 자 여러분의 씬에 어떤 유저 인터페이스 요소들이 추가가 되었는지 아웃라인 뷰를 봅시다.</p><p><strong>아웃라인 뷰 검토하기</strong></p><ol><li>스토리보드에서 outline view toggle을 찾아 보세요.</li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*-Y_HMees_2fg_W7J.png" /></figure><p>2. outline view가 열리면, 토글을 클릭하여 outline view를 확장합니다. 필요에 따라서 outline view를 열거나 확장하기 위해서 outline view toggle을 사용할 수 있습니다.</p><p>캔버스의 왼쪽 편에 나타나는 <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW56">outline view</a>는 여러분의 스토리보드에서 객체를 계층 구조로 보여주는 기능을 제공합니다. 여러분은 하이라키 리스트에 올라와 있는 여러분이 추가한 text field, label 그리고 button을 확인하실 수 있어야 합니다. 여기서 질문 드립니다. 왜 여러분이 추가한 유저 인터페이스 요소들은 View아래 중첩되어 있을 까요?</p><p>Views는 자기 자신을 스크린에 표시하기도 하지만 사용자의 입력에 대한 반응도 하게되며, 다른 view들에 대한 용기 역할을 할 수도 있는 겁니다. Views는 뷰 하이라키로 불리는 계층적 구조로 정렬이 됩니다. <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW21">view hierarchy</a> 는 다른 views과 연관되는 views의 레이아웃을 정의 합니다. 이 하이라키(계층) 내에서, view안에 포함된 view들을 <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW22">subviews</a>라고 부르며, 이러한 view를 포함하는 부모 view를 <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW67">superview</a> 라고 부릅니다. 하나의 view는 여러개의 subview를 가질 수 있지만, superview는 오직 하나만 가질 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/486/0*yfcHpZojRhKNM-dZ.png" /></figure><p>일반적으로, 각각의 씬은 서로 자체 view 하이라키를 가집니다. 각 view 하이라키의 상단이 <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW34">content view</a>입니다. 현재 씬에서는 content view가 View Controller 내부의 상위 단 view인 View로 명명되어 집니다. text field, label 그리고 button이 이 content view의 subview들이 되겠습니다. 여러분이 여러분의 씬에 올리는 모든 그 밖의 view들도 이 content view의 subview가 되는 것입니다. (자체적으로 중척 subview를 자질 지라도요..)</p><h4>인터페이스 미리보기</h4><p>모든것이 예상하고 의도하는데로 보이는지 주기적으로 확인 하기 위해서 여러분의 앱을 미리보기 하세요. <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW76">assistant editor</a>를 이용하여 여러분의 앱 인터페이스를 미리보기 할 수 있습니다. 여러분의 주 편집기와 보조 편집기를 나란히 옆으로하여 보여 줍니다.</p><p><strong>인터페이스 미리보기</strong></p><ol><li>Assistant editor를 열기 위해서 Xcode 상단 오른쪽 모서리 근처 Xcode 툴바에 있는 Assistant button을 클릭하세요.</li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/614/0*OpBew0qtyeXx8DLL.png" /></figure><p>2. 작업하시는데 공간이 더 필요하시면, Xcode 툴바에 있는 Navigator와 Utilities 버튼을 클릭하여 project navigator와 utility 영역을 없애 줍니다. outline view도 마찬가지로 없앨 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/745/0*G05OjS12UTRXDrYO.png" /></figure><p>3. Assistant editor 상단에 나타나는 editor(편집기) 선택바에서, assistant editor를 Automatic to Preview &gt; Main.storyboard (Preview)로 변경하세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*WxSoLk2i4AV1dJR8.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*7V4C7g-tc8D9OLjU.png" /></figure><p>Assistant editor에서 보시는 것처럼, Preview가 캔버스와 거의 동일하게 보입니다. 하지만, 이게 새로운 뭔가를 이야기 하는 것은 아닙니다. 캔버스와 Preview 양쪽 모두 동일한 사이즈의 스크린(아이폰 7)과 동일한 방향(세로)를 보여 주고 있습니다. 만약 여러분의 인터페이스가 잘 적용 되는지 확인해 보고 싶으시다면, 다른 사이즈와 다른 방향으로 preview를 하여야 합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*CIK673nEXpX5pDQw.png" /></figure><p>4. 가로 방향으로 미리보기를 하기 위해서는 preview의 밑부분에 있는 Rotate 버튼을 클릭 하세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/778/0*cBnH4hn2hi5XstKf.png" /></figure><p>안타깝지만, 인터페이스들이 더이상 상당히 올바르게 보이지는 않네요. text field, label 그리고 button가 동일한 사이즈와 비교적 스크린의 좌측 코너 상단을 유지 하고 있지만. 스크린의 마진에서 마진으로 text field가 더이상 채우고 있지는 않다는 것을 의미합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*npgn-Cv4t0j7wo8o.png" /></figure><p>5. 다른 스크린 사이즈로 미리 보기 하기 위해서는, assistant editor의 아래 아래 부분에 버튼을 추가하여 아이폰 SE를 선택하세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*DMlCAuLLAUWw91Fj.png" /></figure><p>다시 text field, label 및 button은 동일한 사이즈를 유지하고, 위치도 스크린의 좌측 모서리 상단에 비교적 자리하고 있습니다. 하지만 이번에는 text field가 스크린의 오른쪽 모서리를 넘어 확장 되었습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/668/0*YMQDtTCygKUcyRRE.png" /></figure><p>어떠한 사이즈의 스크린에도 적용가능한 인터페이스를 생성하기 위해서는 어떻게 하면 인터페이스를 다른 스크린 사이즈마다 조정이 되어야 하는 명확히 할 필요가 있을 것입니다. 예를 들면, 인퍼페이스가 가로 방향으로 회전을 하는 경우, text field도 그에 맞추어 커져야 합니다. 인터페이스가 아이폰 SE에서 보여 질 때에는 text field가 줄어들어야 합니다. 여러분은 이러한 종류의 인터페이스 규칙을 Auto Layout을 사용하여 쉽게 명확히 할 수 있습니다.</p><h4>오토레이아웃 적용하기</h4><p><a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW77">Auto Layout</a>은 씬의 사이즈에 어떠한 변경이 생기더라도 다이나믹 하게 반응 할 수 있는 능동형 레이아웃을 디자인 하도록 도와주는 강력한 레이아웃 엔진입니다. 여러분은 여러분의 레이아웃을 <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/GlossaryDefinitions.html#//apple_ref/doc/uid/TP40015214-CH12-SW78">constraints</a> 규칙 (하나의 요소가 다른 하나와 연관지어서 어디에 위치해야 하는지 설명하거나 요소의 사이즈가 얼만큼이 되어야 하는지)을 이용하여 만들수 있습니다. 오토레이아웃은 이러한 constraints를 기반으로 하여 각각의 요소의 사이즈와 위치를 다이나믹하게 계산합니다.</p><p>여러분의 레이아웃을 정의하기 위한 가장 쉬운 방법중에 하나는 stack view를 사용하는 것입니다.(UIStackView) stack view는 수직 또는 수평으로된 모든 view들을 모아서 레이아웃을 잡을 수 있도록 간소화된 인터페이스를 제공합니다. stack view는 모든 view의 위치와 사이즈를 계산하기 위해 hood(덮개)아래 놓아 오토레이아웃을 이용합니다. 이렇게 함으로써 오토레이아웃의 모든 역량을 쉽게 이용할 수 있으며, 반면에 여러분의 복잡한 레이아웃을 엄청나게 간추려 줄수 있습니다.</p><p>오토레이아웃을 적용하기 위해서는, stack view에 있는 기존 인터페이스 요소들을 랩핑하아시고, 씬 안에서 stack view를 위치시키기 위해 필요한 constraints(제약)을 추가하세요.</p><p><strong>씬(지금 작업하고 있는 meal)에 오토레이아웃 제약 추가 하기</strong></p><ol><li>Standard 버튼을 클릭하여 standard editor로 돌아 가세요.</li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/743/0*KANwlSPpi2FNMdy4.png" /></figure><p>project navigator와 utility 을 클릭하여 영역을 확장하세요.</p><p>2. 키보드의 shift 키를 누르면서, text field, label 과 버튼은 선택하세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*Al04tvh0MDKf0yuB.png" /></figure><p>3. 캔버스 우측 하단에, Embed In Stack 버튼을 클릭하세요. (Editor &gt; Embed In &gt; Stack View 순서로 선택해서 하셔도 됩니다.)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*UhX9eTiSnx0tJmLt.png" /></figure><p>stack view에서 유저 인터페이스 요소들을 함께 쌓아서 Xcode가 묶습니다. Xcode는 아이템들이 수평이 아닌, 수직으로 쌓여야 하는 것을 인지 하기 위하여 기존 레이아웃을 분석합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*wVrZXNrOIRHnD_yH.png" /></figure><p>4. 필요하면, outline view를 열어서 Stack View 객체를 선택 하시기 바랍니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/486/0*PY_Go6L56cuM4pbZ.png" /></figure><p>5. Attributes inspector에서 Spacing field에 8을 타이핑하여 넣으시고, Return을 누르세요. 유저 인터페이스 요소로 하여금 수직으로 공간이 이루어짐을 통보받게 하고, stack view는 이 공간을 통해 크기가 커지게 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/836/0*GRSG3ASUDoC-LEGy.png" /></figure><p>6. 캔버스의 우측 하단에서 Add New Constraints를 여세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*TN8DWYErEzAanom3.png" /></figure><p>7. 아래 “Spacing to nearest neighbor,”에, 2개의 수평 constraint와 top 수직 constraint 을 선택하기 위해 클릭하세요. 그러면 선택되었다는 의미로 흐린 빨간색 점선이 진한 빨간색 선으로 변합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/568/0*h5KHc973mjGe4lA2.png" /></figure><p>위에서 선택한 constraints는 가장 가까운 쪽 leading(앞), trailing(뒤) 및 top(위)의 것들과의 공간을 가리킨다. 이 부분에서, 가장 가까운 것들의 조건이란 가장 가까운 유저 인터페이스 요소들의 바운더리를 의미하는데, 어떠한 것들이냐하면, Superview가 될 수 있는 것들, 그 밖에 다른 유저 인터페이스 요소 또는 마진 입니다. “Contstraint to margins” 체크박스가 선택되어 있기 때문에, 이번 경우에서 stack view는 superview의 왼쪽과 오른쪽 마진에 제약이 걸릴 것입니다. 이렇게 하면 stack view와 씬의 모서리 사이에 공간을 주게 됩니다.</p><p>다른 한편으로, stack의 상위가 씬의 상위 레이아웃 가이드에 걸려 제약이 됩니다. 상태바가 보일 경우, 상위 레이아웃 가이드는 상태바의 하단에 위치합니다. 그렇지 않으면, 씬의 상위에 위치합니다. 따라서 stack view와 레이아웃 가이드 사이에 약간의 공간을 추가 해 줄 필요가 있습니다.</p><p>8. 좌측 우측 박스에 0을 넣으시고, 위에 박스에는 20 공간을 넣으세요.</p><p>9. Update Frames 옆에 있는 팝업 메뉴에서, Items of New Constraints을 선택하세요. 이렇게 하면, 여러분이 constraints를 생성할 시에 영향 받는 view들의 프레임을 인터페이스 빌더가 자동으로 업데이트 하는 것이 가능 합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*KMwA_0TfjlfkRAMP.png" /></figure><p>10. Add New Constraints 메뉴에서 Add 3 Constraints 버튼을 클릭하세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/784/0*MPLjd0j4Q8IP2C1L.png" /></figure><p>label, text field 와 버튼이 현제 왼쪽으로 일직선상에 놓이며, 적당한 공간으로 놓입니다. 하지만 text field는 여전히 스크린의 폭에 맞춰 채워지기 위해 늘어나지는 않습니다. 늘어나게 하려면, 별도의 constraint를 추가해야 합니다.</p><p><strong>stack에서 text field 가로폭을 조정하기.</strong></p><ol><li>스토리보드에서 음식 씬에 있는 text field를 선택하세요.</li></ol><p>2. 캔버스의 우측 하단에서 Add New Constraints 메뉴를 다시 여세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/258/0*4hOYVnEFyLl_dbcK.png" /></figure><p>3. “Spacing to nearest neighbor,”위에 있는 우측 수평 constraint를 선택하기 위해 클릭해주세요, 선택되면 빨간색으로 변경됩니다.</p><p>4. 오른쪽 박스에 0을 넣으세요.</p><p>5. Update Frames 옆에 있는 팝업 메뉴를 열어 Items of New Constraints를 선택하세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*vtZ5WQpQP5p9Y_rV.png" /></figure><p>6. Add New Constraints menu에서 Add 1 Constraint button을 클릭하세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*qt1TR2lYZNx6ag0Y.png" /></figure><p><em>확인사항: </em>iOS 시뮬레이터로 앱을 실행시켜 보세요. Hardware &gt; Rotate Left and Hardware &gt; Rotate Right (또는 Command누르고 왼쪽 화살표 또는 오른쪽 화살표를 눌러도 됩니다.) 순으로 선택하여 시뮬레이터를 회전해 보세요. 어떤가요? 기기의 방향과 스크린 사이즈에 따라서 text field의 사이즈가 어떻게 적합하게 커지거나 작아지는지 보세요. 또한 가로 화면 방행에서 상태바가 사라지는지 보시기 바랍니다.</p><p>text field 안쪽을 클릭하고 화면상의 키보드를 이용하여 텍스트를 입력하여 보세요.(원하시면, 맥의 키보드를 사용할 수 도 있습니다. Hardware &gt; Keyboard &gt; Connect Hardware Keyboard 순서로 선택해 보세요.)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/774/0*ca0HDIBezuwl1y9i.png" /></figure><h4>오토레이아웃 디버깅 하기</h4><p>여러분이 의도하였던데로 잘 되지 않으면, Auto Layout 디버깅 기능을 이용하여 도움을 받아보세요. Update Frames 버튼과 Resolve Auto Layout Issues 메뉴를 사용하여 디버깅 기능에 접근할 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*ph5RkOcYOIowg58I.png" /></figure><p>views를 잘 못 놓아서, 경고가 떧나요? Update Frames 버튼을 사용하세요. 이버튼을 누르면 선택된 view와 그 view의 모든 subview의 프레임이 업데이트 됩니다. 씬에 있는 모든 view들을 업데이트 하기 위해서는 씬의 view controller를 선택하세요. 선택된 view만을 업데이트 하기 위해서 Update Frames 버튼을 옵션 클릭 할 수도 있습니다.</p><p>레이아웃이 여러분이 의도한 데로 동작하지 않는다면, Resolve Auto Layout Issues 버튼을 클릭하여 디버그 명령어 메뉴를 가져오세요. 이메뉴에 모든 명령어들이 두가지 형태를 가지고 있습니다. 하나는 현재 선택된 view에만 영향을 주는 것이며, 다른 하나는 현재 view controller에 있는 모든 view에 영향을 줍니다. 모든 명령어가 흐린 회색으로 보이면, 씬의view controller 또는 views를 선택하시고서 메뉴를 다시 열어 보세요.</p><p>constraints의 유효한 셋팅으로 여러분의 인터페이스를 Xcode가 업데이트 하게 하기 위해서는 Reset to Suggested Constraints를 선택하세요. 유저 인터페이스 요소에 있는 모든 constraint를 삭제하고 싶은 경우 Clear Constraint를 선택 하세요, 그러고 나서 constraints 셋팅을 다시 하기 위해서 앞서 보여 드린 지침에 따라 다시 시도해 보세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/514/0*EqKVYXNUqeEviiOJ.png" /></figure><h4>마무리</h4><p>자 이번 과정에서는, 여러분이 Xcode 프로젝트의 여러 내용물과 iOS 앱을 설계하고 구동하기 위해 사용하는 많은 툴에 여러분 스스로 익숙해 졌습니다. 또한 간단하지만 유저 인터페이스를 직접 구축도 해보셨고요.</p><p>프로젝트의 씬이 아직은 대단해 보이지는 않아도, 기본 유저 인터페이스가 있고 기능을 갖추고 있습니다. 여러분의 레이아웃을 시작점에서부터 잘짜여져 있고 확장 가능토록 꼭 해보시는 것이 견고한 밑바탕으로 앱을 구축할 수 있도록 해줄 것입니다.</p><blockquote><strong>NOTE</strong></blockquote><blockquote>이번 과정의 완성된 샘플 프로젝트를 보시고 싶으시면 아래 파일을 다운로드 받으셔서 Xcode 프로그램으로 보시기 바랍니다.</blockquote><blockquote><a href="https://developer.apple.com/sample-code/swift/downloads/01_BuildABasicUI.zip">Download File</a></blockquote><p><a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/ConnectTheUIToCode.html#//apple_ref/doc/uid/TP40015214-CH22-SW1"><strong>다음편은 Connect the UI to Code(UI와 코드 연결하기) 입니다.</strong></a></p><p><strong>Note</strong> <strong>:</strong> 본 내용은 Apple공식 문서 내용입니다.저는 iOS와 Swift와 관련된 좋은 기사 또는 공식 문서를 한글로 번역하여 공유하고 있습니다. This article is originally from Apple. This blog is aiming to share good information with those who are interested in Swift programing language and iOS development, but it is translated in Korean.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=70e8faac300" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[The App Life Cycle]]></title>
            <link>https://medium.com/@kimyh1981/the-app-life-cycle-3993e7b9b008?source=rss-dde95c17315b------2</link>
            <guid isPermaLink="false">https://medium.com/p/3993e7b9b008</guid>
            <category><![CDATA[xcode]]></category>
            <category><![CDATA[swift]]></category>
            <category><![CDATA[app-life-cycle]]></category>
            <category><![CDATA[apple]]></category>
            <category><![CDATA[ios]]></category>
            <dc:creator><![CDATA[Yong Ho Kim]]></dc:creator>
            <pubDate>Thu, 10 May 2018 10:51:49 GMT</pubDate>
            <atom:updated>2018-05-10T10:51:49.150Z</atom:updated>
            <content:encoded><![CDATA[<p>앱은 개발자의 커스텀 코드와 시스템 프레임워크 사이의 정교한 상호작용이라고 할 수 있습니다. 시스템 프레임워크란 모든 앱들이 구동되기 위해 필요한 기본 구조이며, 개발자는 이런 기본 구조를 필요에 따라 변형하는 코드를 제공하게 됩니다. 또한 개발자가 원하는 디자인(외관)과 느낌을 줍니다. 효과적으로 이를 구현하기 위해서는 iOS 기본구조와 이것이 어떻게 작동하는지에 대해서 이해하시는데 약간의 도움을 드립니다.</p><p>iOS 프레임워크는 “model-view-controller &amp; delegate”와 같은 디자인 패턴에 따라 구동이 됩니다. 성공적인 앱 완성을 위해 이러한 디자인 패턴을 이해하는 것은 매우 중요합니다. Objective-C 언어와 특성을 이해하시는데에도 도움이 될 것입니다. iOS 프로그래밍이 처음이신 경우, iOS 앱과 Objective-C 언어에 대해 소개 되어 있는 <a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/index.html#//apple_ref/doc/uid/TP40015214"><em>Start Developing iOS Apps (Swift)</em></a><em> </em>를 읽어보시기 바랍니다.</p><h4>The Main Function</h4><p>모든 C 기반 앱은 “main” 으로 시작 되는데, iOS 앱 또한 다르지 않습니다. 다른것이 있다면, iOS앱에는 “main”을 쓰지는 않죠. 대신에, Xcode에서 본 기능을 개발자의 기본 프로젝트에 일부로서 생성을 해줍니다. 아래 The main function of an iOS app에 본 기능에 대한 예시입니다. 아주 일부 예외 사항으로 Xcode에서 제공하는 “main” 기능의 실행을 절대 변경하지 않지 않아야 합니다.</p><pre>#import &lt;UIKit/UIKit.h&gt;</pre><pre>#import &quot;AppDelegate.h&quot;<br></pre><pre>int main(int argc, char * argv[])</pre><pre>{</pre><pre>    @autoreleasepool {</pre><pre>        return UIApplicationMain(argc, argv, nil, SStringFromClass([AppDelegate class]));</pre><pre>    }</pre><pre>}</pre><p>“main”기능에 대하여 언급드릴 유일한 것은 UIKit framework를 수동으로 조작하여 off시키는 것이 “main”의 기능입니다. UIApplicationMain 기능은 앱의 주요 객체를 생성하고, 가용되는 스토리보드 파일로부터 앱의 유저 인터페이스를 불러오고, 몇몇 초기 설정을 진행 할 수 있도록 개발자의 커스텀 코드를 호출하며, 앱의 run loop을 실행하도록하여 본 프로세스를 처리하는 일입니다. 개발자가 제공하여야 하는 유일한 것은 스토리보드 파일과 커스텀 초기화 코드 입니다.</p><h4>The Structure of an App(앱의 구조)</h4><p>구동이 되는 동안, UIApplicationMain 기능에서는 몇몇 주요 핵심 객체를 구성하고 App의 구동을 시작합니다. 모든 iOS app의 심장 역할을 하는 것은 시스템과 앱의 객체들 사이에 상호 작용을 돕는 역할을 하는 UIApplication 객체 입니다. 아래 그림에서 대부분의 앱에서 공통적으로 보이는 객체들을 보여 줍니다. 객체 각각이 하는 역할에 대하여 아래 그림 밑 내용을 참조 바랍니다. iOS 앱은 “model-view-controller” 구조를 이용함을 우선 말씀 드립니다. 이 패턴으로 하여금 앱의 데이터와 그 데이터의 시각적인 표현으로부터 Business Logic(데이터 처리를 수행하는 응용프로그램의 일부로서, 보이는 것의 뒤에서 일어나는 각종 처리를 의미한다.)을 나눕니다. 본 구조는 다른 스크린 사이즈를 가진 다른 기기에서도 구동될 수 있는 앱을 제작하는데에 매우 중요 합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/proxy/1*n8zDfF0RCd3keeFqAqWBGA.png" /></figure><p><strong>UIApplication object : </strong>UIApplication 객체는 event loop(프로그램속에서 반복 사용되는 일련의 명령이 일어나는 것)과 그 밖에 앱의 고차원 행위를 관리 합니다. 또한 앱의 핵심 변동 사항 및 몇몇 특별한 이벤트(예를 들면, incoming push notification와 같은)를 당신이 만든 커스텀 객체인 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html">delegate</a>에 보고를 합니다. UIapplication 객체는 subclassing 하지 않고 있는 그대로 사용하는 것입니다.</p><p><strong>APP Delegate object :</strong> App delegate는 당신이 작성한 커스텀 코드의 심장입니다. 본 객체는 UIApplication 객체와 앞뒤로 연결되어서, 앱의 시동, 상태변화 및 고차원의 앱 이벤트를 처리합니다. 본 객체는 또한 모든 앱에 오직 하나(one!, 1, uno)만 존재합니다. 그래서 때때로 앱의 초기 데이터 구조를 설정 할 때 사용되기도 합니다.</p><p><strong>Document and data model objects : </strong>Data model 객체는 앱의 내용을 저장하고, 앱의 구체적인 부분이라고 하겠습니다. 예를 들면, 은행관련 앱은 아마도 금융 거래를 포함하는 데이터베이스를 저장해야 할 텐데, 반면 그림그리기 앱은 이미지 객체 또는 이미지 생성 명령어들을 저장합니다. (후자의 경우, 이미지 객체는 여전히 데이터 객체입니다, 왜냐면 단지 이미지 데이터를 담기 위한 용기일뿐이기 때문입니다.) 앱은 데이터 모델 객체의 일부 또는 전부를 관리하기 위하여 document 객체(UIDocument의 커스텀 서브클래스)를 또한 사용합니다. Document 객체가 필수는 아니지만, 하나의 파일 또는 파일 꾸러미에 소유 될 수 있도록 데이터를 그룹짓기에 편리한 방법을 제공합니다. Document에 대하여 더 많은 정보는 <a href="https://developer.apple.com/library/content/documentation/DataManagement/Conceptual/DocumentBasedAppPGiOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011149"><em>Document-Based App Programming Guide for iOS</em></a>를 참조 바랍니다.</p><p><strong>View controller object : </strong>View controller 객체는 앱의 내용물을 스크린에 보여주는 것을 컨트롤 합니다. 하나의 View controller 는 하나의 view와 view의 subview들의 집합을 관리 합니다. view가 보여 질 때는, view controller가 앱의 윈도우에 view를 설치함으로써 view들이 보여질 수 있도록 합니다. UIViewController 클래스는 모든 view controller 객체들에 대한 기초 클래스입니다. 이는 view를 로딩하고, 보여주고, 기기의 회전에 따라 반응하여 화면을 회전시키며, 또한 그 밖에 몇몇 표준 시스템 행위를 하는 등의 기본 기능을 제공합니다. UIKit와 그 밖에 프레임워크는 image picker, tab bar interface 및 navigation interface와 같은 표준 시스템 인터페이스를 실행하기 위하여 별도의 view controller 클래스들을 정의 합니다. view controller에 대한 상세한 사용 방법 등 정보는 <a href="https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457"><em>View Controller Programming Guide for iOS</em></a>를 참조 바랍니다.</p><p><strong>UIWindow object : </strong>하나의 UIWindow 객체는 스크린에서 하나 또는 여러개의 view를 보여주는 것을 조정합니다. 대부분의 앱은 매인 스크린에 내용물을 보여주는 오직 하나의 윈도우만을 가지지만, 외부 디스플레이 표기되는 내용을 위해 별도의 윈도우를 가지기도 합니다. 앱의 내용을 변경하기 위해서는 해당 윈도우에 표기되는 view를 변경 하기 위하여 view controller를 사용합니다. 윈도우 자체를 절대로 대체할 수는 없습니다. view를 갖는 것에 더하여, 윈도우는 UIApplication 객체와 더불어 이벤트를 view와 view controller에 전달하는 일을 하기도 합니다.</p><p><strong>View object, control object, and layer objects : </strong>views와 controls은 앱의 내용물에 대한 시각적 표현을 제공합니다. 하나의 <em>view</em>는 지정된 직사각형 공간에서 내용을 그리는 객체이며 또한 그 공간에서 일어나는 이벤트에 응답합니다. <em>controls</em>는 button, text fields 및 toggle switches와 같은 흔한 인터페이스 객체를 실행하는 책임을 가지는 특화된 view의 타입입니다. UIKit 프레임워크는 많은 각기 다른 타입의 내용을 보여주기 위하여 표준 views을 제공합니다. 또한 UIView(또는 UIView의 파생)의 subclassing을 통하여 개발자 의도의 자체 커스텀 views를 직접 정의 할 수도 있습니다.views와 controls를 포함하는것에 더하여, 앱은 view와 control 하이라키에 Core Animation 층들을 포함 할 수도 있습니다. <em>Layer(층) 객체</em>는 사실 시각적인 내용을 나타내는 데이터 객체입니다. views는 내용물을 나타내기 위하여 장면 넘어 집중적으로 layer 객체를 사용합니다. 물론 복잡한 애니메이션 및 그 밖에 정교한 시각적 효과 타입을 실행 하기 위한 인터페이스에 커스텀 layer 객체를 추가 할 수도 있습니다.</p><p>하나의 iOS 앱과 다른 앱을 구별 하는 것은 앱이 관리하는 데이터(그리고 해당 business logic)와 데이터를 사용자에게 어떻게 보여주는가 입니다. UIKit 객체를 통한 거의 대부분의 상호작용이 앱을 정의하지는 않지만, 앱의 행위를 세밀히 구분짓는데에 도움을 줍니다. 예를 들면, 앱 delegate의 methods는 개발자의 커스텀 코드가 적절하게 반응 할 수 있도록 앱이 상태 변화를 할 때 이를 개발자에게 알려 줍니다.</p><h4>The Main Run Loop(주요 구동 반복)</h4><p>하나의 앱의 main run loop는 모든 유저관련 행위(이벤트)를 처리 합니다. UIApplication객체는 구동 되는 시점에 main run loop를 설정하며, 이벤트 처리와 view 기반 인터페이스 업데이트를 하기 위해 사용됩니다. 그 이름에서 제안 하는 것처럼, main run loop는 앱의 mian thread에서 실행 합니다. 이러한 행위로서 사용자 관련한 이벤트가 접수된 순서대로 연속적으로 처리가 되는 것을 보장합니다.</p><p>아래 그림은 main run loop의 구조와 사용자 이벤트를 앱에서 어떻게 처리 하는지를 보여줍니다. 사용자는 디바이스와 반응하기 때문에, 그러한 반응과 관련한 이벤트는 시스템에서 생성을 하고, UIKit으로 구성된 특수 포트를 통하여 앱으로 전달이 됩니다. 이벤트는 앱에 의해서 내부적으로 정렬이 되고, 실행을 위해 main run loop로 하나씩 하나씩 보내 집니다 . UIApplication 객체는 이벤트를 접수하고, 무엇을 해야 하는지 결정을 내리는 첫번째 객체 입니다. 터치 이벤트는 보통 main window 객체로 보내 지는데요, 터치가 일어 날 때마다 본 객체가 차례로 터치 이벤트를 view로 보냅니다. 그 밖에 이벤트들은 약간 다른 경로로 다양한 앱 객체를 통하여 전달 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/proxy/1*oDckiqvUj_95hNrFliDisw.png" /></figure><p>이벤트의 많은 타입이 iOS 앱에서 전달이 되는데요, 가<a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html">장 많이 사용되는 이벤트 타입을 링크</a> 드립니다. 많은 이런 이벤트 타입은 사용자의 앱의 main run loop를 이용하여 전달이 되지만, 몇몇은 다르게 전달이 되기도 합니다. 몇몇 이벤트는 delegate 객체로 전송이 되거나 또는 개발자가 제공하는 블록으로 지나가기도 합니다. touch, remote control, motion, accelerometer, gyroscopic 이벤트를 포함한 다양한 이벤트 타입별 처리 방법에 대해서는 <a href="https://medium.com/@audrl1010/event-handling-guide-for-ios-68a1e62c15ff">Event Handling Guide for iOS</a>를 참조하시기 바랍니다. (아래는 iOS 앱의 일반적인 이벤트 타입에 대한 정의 입니다.)</p><p><strong>Touch -&gt; 이벤특 일어나는 view 객체로 전달 됩니다 : </strong>views는 응답형 객체 입니다. view에서 처리하지 않는 모든 터치 이벤트도 처리를 위해서 응답 체인으로 전송됩니다.</p><p><strong>Remote control, Shake motion events -&gt; First responder 객체로 전달 됩니다 : </strong>Remote control 이벤트는 미디어 재생을 컨트롤 하는 용도 이며, 헤드폰이나 다른 악세사리에 의하여 생성됩니다.</p><p><strong>Accelerometer, Magnetometer, Gyroscope -&gt; 개발자가 지정한 객체로 전달 됩니다 : </strong>Accelerometer, Magnetometer, Gyroscope 하드웨어와 관련된 이벤트는 개발자가 지정한 객체로 전달 됩니다.</p><p><strong>Location -&gt; 개발자가 지정한 객체로 전달 됩니다 : </strong>개발자는 Core Location 프레임워크를 사용하여 location 이벤트를 받도록 등록 합니다. Core Location을 사용하는 것에 대한 자세한 정보는 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/LocationAwarenessPG/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009497"><em>Location and Maps Programming Guide</em></a> 를 참조 바랍니다.</p><p><strong>Redraw -&gt; view가 업데이트 되어야 합니다 : </strong>Redraw 이벤트는 이벤트 객체를 포함하고 있지는 않지만, draw 자체에 view를 간단히 호출 합니다. iOS에 대한 drawing 구조에 대해서는 <a href="https://developer.apple.com/library/content/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010156"><em>Drawing and Printing Guide for iOS</em></a>의 설명을 참고 바랍니다.</p><p>touch 와 remote control 이벤트와 같은 몇몇 이벤트들은 앱의 응답 객체들이 처리를 합니다. 응답 객체들은 앱의 모든 곳에 있습니다. (UIApplication 객체, view 객체, view controller 객체는 응답 객체의 모든 예시들입니다.) 대부분의 이벤트들은 특정한 응답 객체를 타겟으로 하고 있지만, 이벤트 처리가 필요한 경우 다른 응답 객체(응답 체인을 통하여)로 전달 되기도 합니다. 예를 들면, 이벤트를 처리하지 않는 view는 자신의 상위인 superview 또는 view controller로 이벤트를 전달 할 수 있습니다.</p><p>조작시에(버튼과 같은) 일어나는 touch 이벤트는 views의 많은 다른 타입에서 일어나는 touch 이벤트와는 다르게 처리가 됩니다. 전형적으로 조작이 가능한 상호작용의 수는 제한적이며, 따라서 이러한 상호작용은 action messages로 묶이거나, 적절한 목표 객체로 전달됩니다. 이러한 target-action 디자인 패턴으로 하여금, 앱에서 개발자의 커스텀 코드의 실행을 내리는데 조작 하기가 쉽도록 합니다.</p><h4>Execution States for Apps(앱의 실행 상태)</h4><p>항시, 앱은 아래 나열된 상태중에 하나에는 있게 됩니다. 시스템은 시스템 처음부터 마지막까지 일어나는 actions에 대한 응답으로 수시로 어떤 상태에서 어떤 상태로 계속 앱을 움직입니다. 예를 들면, 사용자가 홈버튼을 누르거나, 전화가 걸려오거나, 또는 어떠한 몇몇 중지가 일어나는 경우, 현재의 작동 상태의 앱은 그 상태를 이에 대응하여 변경 합니다. 아래는 앱이 어떤 상태에서 어떤 상태로 이동 할 시에 앱이 취하는 경로를 보여 줍니다.</p><p><strong>Not running : </strong>앱은 실행이 되지 않았거나 또는 작동은 하고 있었지만, 시스템에서 종료를 시킨 상태</p><p><strong>Inactive : </strong>앱이 전면에서 동작은 하지만, 현재 이벤트를 받고 있지 않는 상태. (아마도 다른 코드를 실행 하였테지만.) 오직 잠깐만 다른 상태로 변화하는 순간을 빼고는 앱은 보통 이상태를 유지합니다.</p><p><strong>Active : </strong>앱이 전면에서 동작이되며, 이벤트를 받는 상태입니다. 전면의 앱들이 정상적인 모드가 되겠습니다.</p><p><strong>Background : </strong>앱은 background에 있으며, 코드를 실행하는 상태입니다. 대부분의 앱은 지연되는 중에 잠시 이 상태에 접어 들게 됩니다. 하지만, 앱은 일정 기간의 시간 동안 이상태를 유지할 수도 있는 추가 실행 시간을 요청하기도 합니다. 추가로, background 상태로 직접 실행되어지는 앱은 inactive 상태 대신에 background 상태로 들어갑니다. Background 상태인 동안 어떻게 코드를 실행하는지에 대한 자세한 정보는 <a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html#//apple_ref/doc/uid/TP40007072-CH4-SW1">Background Execution</a>를 참조 바랍니다.</p><p><strong>Suspended : </strong>앱이 background 상태에 있지만, 코드를 실항하지는 않는 상태입니다. 시스템은 앱을 이상태로 자동으로 이동을 시키며, 작동하기 전에는 앱에 알리지 않습니다. suspended(지연) 되는 동안, 앱은 메모리에 들어있는 상태를 유지하지만, 어떠한 코드도 실행하지는 않습니다. 메모리가 부족한 상태가 발생이 되면, 시스템에서는 전면에서 실행되는 앱을 위하여 더 많은 메모리를 확보하기 위하여 suspended 앱을 통보없이 제거 합니다.</p><p><strong>&lt;iOS 앱의 상태 변화도&gt;</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/697/0*WO5ZSjtCu_jvApBr.png" /></figure><p>대부분의 상태 변화는 앱의 delegate 객체의 methods에 대한 관련한 호출을 수반합니다. 이러한 methods는 적절한 방법으로 상태 변화에 대응하기 위한 방법입니다. 아래 이러한 methods들이 어떠한 것이 있는지, 어떻게 사용을 하여야 하는지 간략한 내용입니다.(이어서 그림 참조)</p><ul><li><a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623032-application">application:willFinishLaunchingWithOptions:</a>— This method is your app’s first chance to execute code at launch time. 본 method는 앱의 실행시 코드를 실행하기 위한 앱의 첫번째 단계 입니다.</li><li><a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622921-application">application:didFinishLaunchingWithOptions:</a>—This method allows you to perform any final initialization before your app is displayed to the user. 본 method는 앱이 사용자에 표시되기 전에 모든 최종 초기화를 실행 할 수 있도록 해줍니다.</li><li><a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622956-applicationdidbecomeactive">applicationDidBecomeActive:</a>—Lets your app know that it is about to become the foreground app. Use this method for any last minute preparation. 앱이 전면 앱이 될 것이라고 앱이 인식하게 해줍니다. 본 method를 모든 최종 준비를 위하여 사용바랍니다.</li><li><a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622950-applicationwillresignactive">applicationWillResignActive:</a>—Lets you know that your app is transitioning away from being the foreground app. Use this method to put your app into a quiescent state. 앱이 전면 앱에서 변경될 것이라고 개발자에게 알려 주는 method입니다. 앱을 정지 상태로 놓도록 할 때, 이 method를 사용바랍니다.</li><li><a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622997-applicationdidenterbackground">applicationDidEnterBackground:</a>—Lets you know that your app is now running in the background and may be suspended at any time. 앱이 background에서 현재 작동하고, 언제든지 suspended(지연) 될 수 있다고 개발자에게 알려주는 method입니다.</li><li><a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623076-applicationwillenterforeground">applicationWillEnterForeground:</a>—Lets you know that your app is moving out of the background and back into the foreground, but that it is not yet active. 앱이 background 상태에서 나와 전면으로 다시 복귀하지만, 아직 활성화 상태는 아님을 개발자에게 알려주는 method입니다.</li><li><a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623111-applicationwillterminate">applicationWillTerminate:</a>—Lets you know that your app is being terminated. This method is not called if your app is suspended. 앱이 종료 되었음을 개발자에게 알려주는 method입니다. 앱이 suspended(지연) 상태인 경우에는 이 method가 호출되지 않습니다.</li></ul><p><strong>&lt;앱을 전면으로 실행하기&gt;</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/proxy/1*0XS9grFLWcz6Quzdu5syGw.png" /></figure><p><strong>&lt;앱을 background로 실행하기&gt;</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/proxy/1*5LKm3FR67tuGYEeh_eDgIA.png" /></figure><p><strong>&lt;앱을 전면에서 backround로 이동하기&gt;</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/proxy/1*xPCYq-6QcCR8FvB1L1_jfw.png" /></figure><h4>App Termination (앱 종료)</h4><p>앱은 반드시 언제든지 종료가 일어날 것에 대비 되어있어야 하며, 사용자의 데이터를 저장하는데 지연이 있어서도 안되며 또는 그 밖의 중대한 일을 수행하는데에도 지연이 있어서도 안됩니다. 시스템이 종료를 시행하는 것은 앱의 생명 주기의 정상적인 일부 입니다. 시스템은 보통 앱을 종료함으로서, 메모리를 회수할 수 있고 또한 사용자가 실행한 다른 앱을 위한 메모리를 확보할 수 있게 합니다. 하지만 앱의 동작이 올바르지 않거나 이벤트에 적절히 응답하지 않을 경우에도 앱을 종료시키기도 합니다.</p><p>Suspended 앱은 앱이 종료 되었을때, 통보를 받지 않습니다. 시스템에서 프로세스를 죽이고 관련 메모리를 회수하기 때문입니다. 만일 앱이 현재 background에서 구동이 되고 있거나 suspended 된 상태가 아니라면, 시스템에서는 <a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623111-applicationwillterminate">applicationWillTerminate:</a> 종결에 앞서 앱의 delegate 를 호출 합니다. 시스템은 기기가 재부팅 될 시에는 본 method를 호찰 하지 않습니다.</p><p>앱을 시스템이 종료 시키는것에 더하여, 사용자는 멀티테스킹 UI를 사용하여 앱을 명시적으로 종료 시킬 수도 있습니다. 사용자가 진행한 종료는 suspended app을 종료하는 것과 동일한 효과를 갖습니다. 앱의 프로세스가 죽으면서, 앱으로 통보가 전달되지는 않습니다.</p><h4>Thread and Concurrency</h4><p>시스템은 앱의 main thread를 만들며, 개발자는 다른 일을 수행하기 위하여 필요하면 추가로 thread를 만들수도 있습니다. iOS 앱에서는 개발자가 threads를 직접 생성 및 관리하는 것보다는 GCD(Grand Central Dispatch), operation 객체 및 그 밖에 비동기식 프로그래밍 인터페이스를 사용하는 것이 선호됩니다. GCD와 같은 기술을 통해 진행하고 싶은 작업을 정의하고 순서를 정할 수 있게 할 수 있습니다. 하지만 유용가능한 CPU에서 작업을 최상으로 실행하는 데에 대한 결정은 시스템이 하도록 하여야 합니다. 시스템이 thread 관리를 처리하게 함으로서 개발자가 반드시 작성하여하는 코드를 간소화 할 수 있으며, 코드의 정확성을 보장하는 것이 쉽고 또한 전반적으로 보다 나은 성능을 제공하게 할 수 있습니다.</p><p>Thread와 동시 실행에 대해서 생각할 때에는 아래 사항을 고려하시기 바랍니다.</p><ul><li>view를 포함하는 작업, core animation 및 그 밖의 많은 UIKit 클래스들은 주로 반드시 앱의 main thread에서 일어납니다. 하지만 이 규칙에도 몇몇 예외 사항은 있는데요, 예를 들면, 이미지 기반 취급의 경우에는 background에서 종종 일어납니다, 하지만 확실치 않으면, 그 작업도 main thread에서 발생이 필요하다고 생각하시기 바랍니다.</li><li>시간이 오래 걸리는 작업(또는 잠재적으로 오랜 시간이 걸리는 작업)은 항상 background thread에서 실행되어야 합니다. 네트워크 접속, 파일 접속 또는 대용량의 데이터를 처리 등을 포함하는 모든 작업도 GCD 또는 operation object를 이용하여 모두 비동기로 실행이 되어야 합니다.</li><li>실행 시에는, 가능하면 작업들을 main thread에서 이동시켜 주세요. 실행 시에는, 앱이 앱의 유저 인터페이스를 가능한 빠르게 설정하기 위하여 가용시간을 사용하여야 하기 때문입니다. 유저 인터페이스를 설정하는데에 기여하는 작업만 main thread에서 실행시켜 주세요. 그 밖에 다른 모든 작업들은 작업이 준비되는 순간 사용자에게 보여준 결과와 함께 비동기로 실행 되어야 합니다.</li></ul><p>작업 실행을 위한 GCD와 operation 객체에 대한 자세한 내용은 <a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091"><em>Concurrency Programming Guide</em></a><em> </em>을 참조하시기 바랍니다.</p><p><strong>Note :</strong> 본 내용은 Apple공식 문서 내용입니다.저는 iOS와 Swift와 관련된 좋은 기사 또는 공식 문서를 한글로 번역하여 공유하고 있습니다. This article is originally from Apple. This blog is aiming to share good information with those who are interested in Swift programing language and iOS development, but it is translated in Korean.</p><p>Kim Yong Ho</p><p>iOS developer and Swift programmer</p><p><a href="https://mail.google.com/mail/u/0/?tab=wm#inbox?compose=new">kimyh1981@gmail.com</a></p><p>Github : <a href="https://github.com/kimyh1981">https://github.com/kimyh1981</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3993e7b9b008" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2018년 스위프트 오픈 소스]]></title>
            <link>https://medium.com/@kimyh1981/2018%EB%85%84-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-%EC%98%A4%ED%94%88-%EC%86%8C%EC%8A%A4-f2113dab3caa?source=rss-dde95c17315b------2</link>
            <guid isPermaLink="false">https://medium.com/p/f2113dab3caa</guid>
            <category><![CDATA[swift]]></category>
            <category><![CDATA[ios-swift-libraries]]></category>
            <category><![CDATA[ios]]></category>
            <category><![CDATA[open-source]]></category>
            <category><![CDATA[apple]]></category>
            <dc:creator><![CDATA[Yong Ho Kim]]></dc:creator>
            <pubDate>Sat, 05 May 2018 06:05:54 GMT</pubDate>
            <atom:updated>2018-05-05T06:13:43.636Z</atom:updated>
            <content:encoded><![CDATA[<p><a href="https://medium.mybridge.co/30-amazing-ios-swift-libraries-for-the-past-year-v-2018-7cf15027eee9">30 Amazing iOS Open Source Libraries in Swift for the Past Year (v.2018)</a></p><h3><strong>2018년 놀랄만한 iOS Swift Libraries 30선 입니다.</strong></h3><p>지난해 동안 사용되었던 스위프트 오픈 소스 라이브러리 약 6천개를 비교하여 Top 30(0.5% 확률)을 선정하였습니다.</p><p>이는 굉장히 경쟁력있는 리스트가 될것이며, 2017년 1월부터 12월까지 기간 동안 나온 최고의 오픈 소스 스위프트 라이브러리, 툴, 그리고 프로젝트를 신중하게 담고 있습니다. Mybridge AI(<a href="https://www.mybridge.co">https://www.mybridge.co</a>)(마이브릿지는 샌프란시스코에 위치한 프로그래밍 전문가를 위하여 관련 기사의 순위를 매겨주어, 전문가들의 양질의 컨텐츠에 쉽게 접근할 수 있도록 하고 또한 업무 향상을 돕도록 하게하는 기업)에서는 소스의 인기도, 사용도 및 최신형을 고려하여 평가 합니다. 그 질을 평가 함에 있어 기준을 드린다면, Github start가 평균 3,727개가 되겠습니다.</p><ul><li>Amazing Swift UI Libraries (avg. 4,010 star)</li><li>Amazing Swift Apps (avg. 2,781 star)</li><li>Amazing Swift Source Android Apps (avg. 3,874 star)</li></ul><p>오픈 소스 라이브러리는 프로그래머가 굉장히 빠른 속도로 개발을 과정을 수행하여 목적을 달성하는데 도움을 줍니다. 물론 여러분도 소스코드를 읽어본다든지 아니면 그 프로젝트 자체에 뭔가를 구축해본다든지하여 얻어가실 수 도 있습니다. <strong>지난해 놓쳤던 iOS libraries와의 놀이에 많은 시간을 투자해 보세요.</strong></p><p><strong>Note</strong> : 본 기사는 Mybridge에서 제공하는 기사이며, 상단의 링크를 통하여 <strong>Swift Open Source 30선</strong>에 대한 상세한 Rank를 확인하세요. 기사에 대한 소유권한은 Mybridge에 있습니다. Any right of the original article linked and translated in Korean even is owned by Mybridge, it is clearly mentioned that this article can be accessed by original article link on the top of this article. This blog is aiming to share good information with those who are interested in Swift programing language and iOS development, but it is translated in Korean.</p><p>Kim Yong Ho</p><p>iOS developer and Swift programmer</p><p><a href="https://mail.google.com/mail/u/0/?tab=wm#inbox?compose=new">kimyh1981@gmail.com</a></p><p>Github : <a href="https://github.com/kimyh1981">https://github.com/kimyh1981</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f2113dab3caa" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[감사합니다. 당신의 조언이 좋은 지침서가 되었습니다.]]></title>
            <link>https://medium.com/@kimyh1981/%EA%B0%90%EC%82%AC%ED%95%A9%EB%8B%88%EB%8B%A4-%EB%8B%B9%EC%8B%A0%EC%9D%98-%EC%A1%B0%EC%96%B8%EC%9D%B4-%EC%A2%8B%EC%9D%80-%EC%A7%80%EC%B9%A8%EC%84%9C%EA%B0%80-%EB%90%98%EC%97%88%EC%8A%B5%EB%8B%88%EB%8B%A4-9d7673b4e8a8?source=rss-dde95c17315b------2</link>
            <guid isPermaLink="false">https://medium.com/p/9d7673b4e8a8</guid>
            <dc:creator><![CDATA[Yong Ho Kim]]></dc:creator>
            <pubDate>Sun, 25 Mar 2018 04:29:40 GMT</pubDate>
            <atom:updated>2018-03-25T04:29:40.494Z</atom:updated>
            <content:encoded><![CDATA[<p>감사합니다. 당신의 조언이 좋은 지침서가 되었습니다.</p><p>Thanks for your article, it gonna be helpful for my direction to be a iOS developer. I am learning it now since last Jan.</p><p>Best regards.</p><p>Kim Yong Ho</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9d7673b4e8a8" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[개발자의 툴 모음]]></title>
            <link>https://medium.com/@kimyh1981/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98-%ED%88%B4-%EB%AA%A8%EC%9D%8C-8856e2459011?source=rss-dde95c17315b------2</link>
            <guid isPermaLink="false">https://medium.com/p/8856e2459011</guid>
            <category><![CDATA[apple]]></category>
            <category><![CDATA[tools]]></category>
            <category><![CDATA[development]]></category>
            <category><![CDATA[swift]]></category>
            <category><![CDATA[ios]]></category>
            <dc:creator><![CDATA[Yong Ho Kim]]></dc:creator>
            <pubDate>Wed, 28 Feb 2018 12:01:01 GMT</pubDate>
            <atom:updated>2018-05-24T10:31:28.907Z</atom:updated>
            <content:encoded><![CDATA[<p><a href="https://medium.com/mobile-quality/the-developers-toolbox-daaaa875081e">The Developer&#39;s Toolbox</a></p><h3>개발자의 툴 모음</h3><p>개발 제품의 품질을 높이는 것이 우리가 사용하는 툴의 목적입니다. 그러한 툴에 익숙해 지면 질 수록 더 나은 또는 더 빠른 결과가 나올 것입니다. 물론 최소한의 툴 사용으로도 많은 것을 달성 할 수 있습니다, 하지만 보다 생산적인 수확을 얻기 위해서는 이미 가지고 계신 툴을 마스터하기 위하여 항상 노력해야 할 뿐만아니라, 우리 작업 흐름을 보다 개선해 줄 수 있는 새로운 툴의 발굴에도 노력해야 하겠습니다. 저는 늘 새로운 툴을 찾고 있으며, 혹시 여러분이 제가 아직 사용해보지 않은 툴을 가지고 계시다면, 알려 주세요.</p><p>자 거두절미 하고 아래부터 저의 툴박스를 소개 합니다:</p><h4>GUI Tools</h4><p><a href="https://1password.com/"><strong>1Password</strong></a></p><figure><img alt="" src="https://cdn-images-1.medium.com/proxy/1*5PhOklWAO8D53I-xFnxDqQ.jpeg" /></figure><p>패스워드를 저장할 때 사용합니다. 전에 다른 패스워드 매니저를 사용해봤지만, 지난 10년간 1Password를 사용하고 있습니다.</p><p><a href="https://kapeli.com/dash"><strong>Dash</strong></a></p><figure><img alt="" src="https://cdn-images-1.medium.com/proxy/1*HKx-0NGHu8AomTG36GB40Q.jpeg" /></figure><p>무언가를 위해 서류를 뒤져봤어야 했던 적이 없었나요? 저는 이럴때 Dash를 사용합니다. 문서가 거기 아직 없으면 끌어올 것입니다. 이방법을 통하면, 오프라인에서도 사용이 가능하고 모든 통합물의 사용을 보다 쉽게 해줍니다.</p><p><a href="https://www.obdev.at/products/littlesnitch/index-de.html"><strong>Little Snitch</strong></a></p><figure><img alt="" src="https://cdn-images-1.medium.com/proxy/1*vo2WTgRVxeTAHUVakghjyw.png" /></figure><p>어떤 앱이 네트워크 요청을 시도하고 있는지 알고 싶나요? 그리고 그러한 앱을 관리하고 싶나요? 이게바로 당신이 찾던 툴입니다. 현재까지 몇년이나 쓰고 있는데 한번도 저를 실망 시킨 적이 없습니다.</p><p><a href="https://developer.apple.com/download/more/?q=Additional%20Tools"><strong>Network Link Conditioner</strong></a></p><p>모바일 개발자로서, 우리들은 우리 앱이 안정적인 인터넷 연결 상태에서 사용되지 않는다는 것을 종종 잊어버립니다. 우리 맥북에서 앱을 응답하게 하기 위해서 우리는 Apples Network Link conditioner를 사용할 수 있습니다. 그저 여러분이 사용하고자하는 방식으로 네트워크 설정을 변경하시면, 여러분의 전체 맥이 설정대로 움직일 것입니다(그런데, 인터넷 설정 변경시 어떤 일이 벌어지는지 학인코자 모든 설정을 끄게 되면, 기다리는 동안 인터넷 사용이 안된다는 점!).</p><p><a href="https://paw.cloud/"><strong>Paw</strong></a></p><p>HTTP 리퀘스트를 보낼 때 사용하는 앱은 너무도 많습니다. 그 중에 저는 Paw를 사용합니다. 포스트맨 &lt;Link&gt;보다 더 나은 주요 기능은 리퀘스트를 연속으로 연결해 주는것 입니다. 그러면 매번 인증할 필요가 없습니다. 대신에 저는 하나의 명령어만 실행을하며, 제가 필요한 것은 이게 다입니다.</p><p><a href="http://happenapps.com/"><strong>Quiver</strong></a></p><figure><img alt="" src="https://cdn-images-1.medium.com/proxy/1*f8ZBlmElvy3NqpeAFMIR4w.jpeg" /></figure><p>이 툴은 여러 툴을 모아 주는 현재까지 제가 제일 선호하는 노트 입니다. 콜렉션에 따라 여러분의 노트들의 순서를 나열할 수 있고, 심지어 하나의 셀 안에 코드, 마크다운, 텍스트 등을 담고 있는 다른 셀을 사용할 수 도 있습니다. 전체 노트를 pdf로 변환할 수도 있습니다.</p><p><a href="http://reederapp.com/"><strong>Reeder</strong></a></p><figure><img alt="" src="https://cdn-images-1.medium.com/proxy/1*i4V_2X7oj2eJ-AnYFAocwA.jpeg" /></figure><p>개발자로서(그리고 특히 모바일 개발자로서) 우리는 새로운 개발들과 함께 항상 최신 정보에 빨라야 합니다. 거의 블로그를 뒤져보면서 정보를 좆곤 하는 데요, 저는 Reeder를 사용하여 그러한 정보를 얻습니다. RSS 피드를 총집합한 괜찮은 작은 툴입니다.</p><p><a href="https://revealapp.com/"><strong>Reveal</strong></a></p><figure><img alt="" src="https://cdn-images-1.medium.com/proxy/1*SR1NPour_LCi2KITo8gJAQ.jpeg" /></figure><p>비주얼 버그가 난 적은 없었나요? UX 디자이너와 작업했어야 했나요? 저는 Reveal을 선택했습니다. 새로운 코드베이스에서 바로 끝내버릴수도 있고, 버그랑 함께 교정된 뷰를 찾을 수도 있고, 클래스의 이름을 찾고 어디서 시작하는지도 알수 있어요. 한편으론 UX 디자이너와 마주앉아서 실시간으로 객체(오토레이아웃을 포함하여) 변경할수도 있습니다. 완전 꿀템이죠.</p><p><a href="https://www.sketchapp.com/"><strong>Sketch</strong></a></p><figure><img alt="" src="https://cdn-images-1.medium.com/proxy/1*nnOFEXueiceL2wEB29elHA.jpeg" /></figure><p>저는 UI 작업할 때마다, Sketch를 사용합니다. 사용이 아주 쉽고, 사용안할 이유가 없어요. 근데 오직 벡터라는 것 아셔야 하고요, 그래서 혹시 이미지를 변경하고 싶으시면, 다른거를 사용하셔야 할 거에요.</p><p><a href="https://www.sourcetreeapp.com/"><strong>Sourcetree</strong></a></p><p>Sourcetree는 git의 GUI에요. 엄청 많은 것을 심플하게 해줘서 사용을 꼭해요. 동시에 전체적으로 여기에만 의존해서는 안됩니다. 순수하게 git이 어떻게 작동되는지 배워야 합니다. git이 어떻게 작동하는지 이해함으로서 스스로를 향상시킬수 있습니다. <a href="https://medium.com/mobile-quality/git-hooks-1684b1502661">setup hooks</a>를 하는 법을 아셔야 합니다. <a href="https://www.git-tower.com/mac/">Tower</a>도 있는데, 저는 잘 쓰지는 않습니다.</p><p><a href="https://www.sublimetext.com/"><strong>Sublime Text</strong></a></p><figure><img alt="" src="https://cdn-images-1.medium.com/proxy/1*s0MpH-lMKzGXs8CIV4-hbQ.png" /></figure><p>우리 모두 텍스트 편집기는 다 필요하죠. 저같은 경우 Sublime Text를 사용합니다. 어마어마한 이득이 뭐냐면 플러그인 시스템이라는 겁니다. 알기로는 <a href="https://atom.io/">Atom</a>같은게 있는걸로 아는데, 이거랑 바꿀 필요가 없으시면, 그냥 쓰세요.</p><p><a href="https://toggl.com/"><strong>toggle</strong></a></p><p>저는 internal billing(내부 청구?)를 하는 회사에서 일하고 있는데요. 그래서 횟수를 추적해야 하는데요. 저는 이 작업을 토글로 합니다. 왜냐면 macOS와 iOS 앱 모두를 제공하기 때문이죠. 게다가 동료가 우리 billing 앱으로 임포트하는 <a href="https://tampermonkey.net/">Tampermonkey</a> 스크립트를 썼는데, 꽤 유용하죠.</p><p><a href="http://www.apptorium.com/workspaces"><strong>Workspaces</strong></a></p><p>혹시 동시에 여러개의 프로젝트를 진행해보신적이 있으신가요? 파인더에서 열고 싶은 디렉토리가 무엇인지, 시작할 개발서버가 뭔지 등 어떻게 설정하시는지에 따르는데요, Workspaces가 이걸 다 해줍니다.</p><p><a href="https://developer.apple.com/xcode/"><strong>Xcode</strong></a></p><figure><img alt="" src="https://cdn-images-1.medium.com/proxy/1*8-Oiq0ZsU5FpJOOT30jNUw.png" /></figure><p>말해 뭔들. 그냥 씁시다 iOS 개발자님들…ㅠㅠ</p><h4>Terminal Tools</h4><p><a href="https://brew.sh/index_de"><strong>brew</strong></a></p><p>macOS에서 패키지 관리를 위한 선택 툴이죠. <a href="https://www.macports.org/">MacPorts</a>도 있긴 한데요, 저는 이것 보다는 느낌이 덜 오더라고요, 그리고 적용 지원도 적고요.</p><p><a href="http://bundler.io/"><strong>Bundler</strong></a></p><p>Bundler는 Ruby Gems 관리 방식인데요. 모든 프로젝트들이 고유의 gem 세트를 가질 수가 있고 여러분의 레파지토리에 있는 것 중에 어떤 것을 저장하기도 하고요. 여러분의 Ruby version을 변경해야 하지 않는한, 상당한 도움이 될 것입니다.</p><p><a href="https://github.com/Carthage/Carthage"><strong>Carthage</strong></a></p><p><a href="http://cocoapods.org/">CocoaPods</a>을 많이 사용해 온 만큼, 더욱 이게 싫어지기 시작했습니다. workspace를 생성하고 여러분의 프로젝트 imports를 수정하고, 특정 Ruby version을 요구하고 그리고 매번 Podfile에서 signing을 반드시 변경 해줘야 하는데 그 주요 버전을 Xcode가 업데이트 하게 됩니다. 저는 대신 Carthage를 사용합니다. 그냥 framework만 생성하고, 수동으로 import만 해주면 됩니다. 여러분의 프로젝트에 변경할 것도 없고 여러분은 아무것도 안하고요. 그리고 만일 여러분이 커스텀 xconfig를 제공하는 커스텀 framework를 기반으로 하는 기존의 어머어마한 코드베이스를 작업하고 계시다면, Carthage가 import도 더 쉽게 할수 있도록 만들어 줍니다(예~~슬프지만 이런게 존재하는 군요, 저는 그냥 했었는데요…). 이러한 이유로 Carthage는 저의 Dependency Management를 위한 툴이 되겠습니다.</p><p><a href="https://fastlane.tools"><strong>fastlane</strong></a></p><p>모두 다 아시죠? CI 설정을 쉽게 해주는 툴이죠. 근데 모바일 개발에만 된다는거!</p><p><a href="https://github.com/mas-cli/mas"><strong>mas</strong></a></p><p>mas는 앱스토어에서 앱을 설치하고, 설정 스크립트 작성하는 것을 수동으로 반드시 하지 않아도 되게끔 해줌.</p><p><a href="https://www.neo-layout.org/"><strong>Neo2</strong></a></p><p>이건 툴은 아니고요, 키보드 레이아웃이에요. 터치시스템은 한번도 써본적은 없어서, 기존 키보드랑은 다른 프로그래밍을 위해 설계된 레이아웃을 써보기로 결정했어요. 그게 Neo2 입니다. 가끔 macOS 최신으로 업그레이드 되기 전에 기다려야 하긴 하는데, 그정도는 충분히 감내하고도 남죠, “{}”를 치려고 손가락 운동을 하지 않아도 되니까요(german 키보드 함 보세요, 제가 뭔소리 하는지 아실꺼에요.)</p><p><a href="https://github.com/rbenv/rbenv"><strong>rbenv</strong></a><strong> (</strong><a href="https://github.com/syndbg/goenv"><strong>goenv</strong></a><strong>, </strong><a href="https://github.com/pyenv/pyenv"><strong>pyenv</strong></a><strong>)</strong></p><p>모든 프로젝트마다 관리해줘야 하는 환경이 다르죠. fastlane 버전에 따라서 Ruby 버전도 달라야 하고. 다른 툴들도 아마도 Python 등 요구할 테죠. 제가 이런 경우를 위한 툴을 찾았는데요. 설정이 쉽고 동일한 인터페이스를 가지죠. 동시에, 경로 변경이 되어서, 어떻게 작동되는지 정확하게 알 수 있어요. 그리고 기존 툴은 하나도 바꾸지 않고요.</p><p><a href="https://github.com/xcodeswift/sake"><strong>sake</strong></a></p><p>이건 파일을 swift에서 파일을 만들어 대체하기 위한 작지만 좋은 툴인데요, 아직 개발이 활발히 진행중이긴 합니다. 그래도 나중에 저의 macOS에서 제 GI 구동 시킬 툴이 될 것입니다.</p><p><a href="https://github.com/realm/SwiftLint"><strong>SwiftLint</strong></a></p><p>코드베이스가 깔끔해야 개발이 쉽게 가죠. 그래서 여러분의 코드를 깔끔하게 해주세요. 저는 SwiftLint(그리고 커스텀 pre-commit hook)로 해줍니다. <a href="https://tailor.sh/">Tailor</a>라고 있는걸로 아는데, Swiftlint가 Swift 기반으로 되어 있기 때문에 Swiftlint를 더 선호 합니다.</p><h4>추천 코멘트</h4><p>아래 툴들은 테스트 해보고 싶은 것들인데 아직 해보지를 못했습니다. 그래도 여기에 알려 드려도 충분할 것 같습니다.</p><p><a href="https://www.alfredapp.com/"><strong>Alfred</strong></a></p><p>아직까지는 Spotlight 만 사용하는 거로도 완전 만족합니다만, 제 동료중 한명이 Alfred로 하는 걸 저에게 보여주고 나서, 이제 저도 꼭 해보려고요. 단지 시간이 없어서…</p><p><a href="https://flawlessapp.io/"><strong>FlawlessApp</strong></a></p><p>여러분이 실행하시는게 제공받은 디자인에 잘 맞는지 꼭 확인해야 하나요? 하셔야 한다면, 당신을 위해 이 툴이 있습니다. 최근에 UI 작업을 하지를 않아서 테스트할 기회가 없었는데, 들어보면 엄청나더군요!</p><p><a href="https://nixos.org/nix/"><strong>Nix</strong></a></p><p>위에 말씀 드렸다 시피, 저는 패키지 관리를 위해 brew를 사용하고 있습니다. 프로젝트가 많아지면 많아 질수록 프로젝트에 상태도 많아 지죠. Nix는 변경불가의 객체로서 여러분의 패키지의 각 버전을 취급함으로서 구성 상태를 줄이고자 시도 합니다. Nix는 모든 것들을 그 자체 디렉토리에 저장하며, 여러분이 사용하는 것을 관리해 줍니다. 흥미가 생기죠!</p><p><a href="https://eternalstorms.at/yoink/"><strong>Yoink</strong></a></p><p>Drag와 Drop을 간소화 시켜주는 툴입니다. 항상 윈도우를 이리저리 왔다갔다 하는게 성가시죠, 그래서 저도 이툴을 좀 자세히 봐야할 것 같습니다.</p><p><em>Originally published at </em><a href="https://medium.com/@jan_olbrich?source=post_header_lockup">Jan Olbrich</a> ‘s Medium blog <em>on February 28, 2018.</em></p><p><strong>Note</strong> : 본 기사는 <a href="https://medium.com/@jan_olbrich?source=post_header_lockup">Jan Olbrich</a> 님이 제공하는 기사이며, 상단의 링크를 통하여 원래 기사를 확인하세요. 기사에 대한 소유권한은 <a href="https://medium.com/@jan_olbrich?source=post_header_lockup">Jan Olbrich</a>에 있습니다. Any right of the original article linked and translated in Korean even is owned by <a href="https://medium.com/@jan_olbrich?source=post_header_lockup">Jan Olbrich</a>, it is clearly mentioned that this article can be accessed by original article link on the top of this article. This blog is aiming to share good information with those who are interested in Swift programing language and iOS development, but it is translated in Korean.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8856e2459011" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>