<?xml version="1.0" encoding="UTF-8"?> 
  <rss xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title><![CDATA[ LazyGyu ]]></title>
      <link>https://lazygyu.net/blog</link>
      <language>Ko-kr</language>
      <pubDate>Wed, 23 Jan 2019 19:00:00 +0900</pubDate>
      <category>blog</category>
      <docs>http://blogs.law.harvard.edu/tach/rss</docs>
      <description><![CDATA[ About some useless stuff ]]></description>
      <atom:link href="https://lazygyu.net/rss/blog.xml" rel="self" type="application/rss+xml" />
      <image>
        <url>http://www.gravatar.com/avatar/6b4b3dbac53a5d034939b15497d04f3a?s=195</url>
        <link>https://lazygyu.net/blog</link>
        <title>LazyGyu</title>
      </image>
      <item>
<title><![CDATA[ 문서화에 대해 아무도 말해주지 않는 것들 ]]></title>
<description><![CDATA[ 이 글은 What nobody tells you about documentation 을 번역한 글입니다. 오타 및 오역 지적 환영합니다. ]]></description>
<content:encoded><![CDATA[ 
<h1 id="문서화에-대해-아무도-말해주지-않는-것들">문서화에 대해 아무도 말해주지 않는 것들</h1>
<blockquote>
<p>역주 : 이 글은 <a href="https://www.divio.com/blog/documentation/">What nobody tells you about documentation</a> 을 번역한 글입니다. 오타 및 오역 지적 환영합니다.</p>
</blockquote>
<p>아무리 문서 작업에 노오력을 쏟아봤자 방향을 잘못 잡으면 소프트웨어의 품질에는 전혀 도움이 되지 않습니다.</p>
<blockquote>
<p>좋은 문서 작업을 위해서는 반드시 알아두어야 할 비결이 있습니다. 바로 문서를 단순히 그냥 '문서’로 퉁치는 인식이 바르지 않다는 겁니다. 문서에는 네 가지 종류가 있습니다.</p>
</blockquote>
<p>튜토리얼, 하우-투 가이드, 해설, 기술 레퍼런스가 바로 그 네 가지입니다. 이 네 가지는 각기 다른 목적이나 기능을 가지고 있고 각각의 작성을 위해서 서로 다른 접근법이 요구됩니다. 이것들이 뭘 의미하는지를 이해하는 것은 문서화의 질을 향상시키는 데에 큰 도움이 됩니다.</p>
<h2 id="서론">서론</h2>
<p>문서화가 똑바로 되어있지 않으면 소프트웨어가 <strong>아무리 잘 만들어져 있더라도 사람들은 사용하지 않습니다.</strong></p>
<p>행여 다른 선택지가 없어서 강제로 그 소프트웨어를 써야 하는 상황이라 해도 제대로 된 문서가 없으면 유저들은 소프트웨어를 당신의 의도와는 전혀 다르거나 비효율적인 방법으로 사용하게 될 것입니다.</p>
<p><strong>대다수의 사람들은</strong> 유저에게 좋은 문서가 필요하다는 것을 알고 있고, <strong>좋은 문서를 만들기 위해 노력합니다.</strong></p>
<p>그리고 <strong>대부분 실패합니다.</strong></p>
<p>노력이 부족해서 실패하는 경우는 별로 없습니다. 그보다는 노력을 했으나 그 노력의 방향이 잘못되었기 때문에 망하는 경우가 일반적이죠.</p>
<p>이 포스팅을 통해서 필자는 어떻게 하면 문서화를 더 잘 할 수 있는지를 설명하고자 합니다. 무작정 노오력을 하는 것 보다는 제대로 된 방향을 잡을 수 있게요. <strong>올바른 방법은 사실 더 쉬운 방법이기도 합니다.</strong> 작성하기에도 더 쉽고 관리도 더 용이하죠.</p>
<p>잘 언급되지는 않지만 문서화를 지배하는 몇 가지 단순한 원칙이 존재합니다. 별로 비밀도 아닌데도 자주 비밀스럽게 묻혀있는 것들이죠.</p>
<p>이 원칙들에 숙달 되기만 한다면 당신의 문서와 프로젝트는 한결 나아질 것입니다. 더 나아가서 당신의 제품과 당신의 팀도 발전하게 될 겁니다. 두고 보세요.</p>
<h2 id="비결">비결</h2>
<p>문서화는 튜토리얼Tutorial/하우-투 가이드How-to guide/해설Explanation/기술 레퍼런스Technical reference 등 <strong>네 가지의 역할 중 하나</strong>에 속해야 하며 거기에 알맞는 구조를 가져야 합니다. 각각의 기능은 <strong>서로 완전히 다른 접근 방법으로 작성 되어야</strong> 합니다. 유저들은 서로 다른 상황과 서로 다른 시점에 이들 문서를 찾게 되기 때문에 대부분의 소프트웨어는 저 네 가지 종류의 문서를 모두 갖출 필요가 있습니다.</p>
<p>문서는 명시적으로 이들 중 한 가지의 구조를 가져야 하고, 다른 종류의 문서들과 명확하게 구분되어야 합니다.</p>
<h3 id="튜토리얼">튜토리얼</h3>
<p>튜토리얼은</p>
<ul>
<li>학습 위주로 이루어져 있고</li>
<li>뉴비가 제품 사용을 시작할 수 있도록 해주는</li>
<li>강좌입니다.</li>
</ul>
<p><em>비유하자면, 어린 아이에게 요리법을 가르치는 것과 비슷합니다.</em></p>
<h3 id="하우-투-가이드">하우-투 가이드</h3>
<p>하우-투 가이드는</p>
<ul>
<li>목표 지향적이고</li>
<li>특정한 문제를 해결하는 방법을 보여주며</li>
<li>여러 단계로 이루어져 있습니다.</li>
</ul>
<p><em>요리책에 쓰여진 조리법을 떠올려보세요.</em></p>
<h3 id="해설-문서">해설 문서</h3>
<p>해설 문서는</p>
<ul>
<li>이해를 기반으로 하며</li>
<li>설명하고</li>
<li>배경 지식과 맥락을 제공합니다.</li>
</ul>
<p><em>요리의 역사에 대한 기사를 생각해보세요.</em></p>
<h3 id="레퍼런스">레퍼런스</h3>
<p>레퍼런스는</p>
<ul>
<li>정보를 중점으로</li>
<li>동작을 기술하며</li>
<li>정확하고 완전한 내용을 담고 있습니다.</li>
</ul>
<p><em>백과사전 항목을 떠올려 보시면 됩니다.</em></p>
<p>이러한 구분은 작성자와 독자 양측에게 정보의 향방에 대한 분명한 예측을 가능하게 합니다. 작성자 입장에서는 무엇을, 어디에, 어떻게 써야 하는지에 대한 지침이 됩니다. 그럴싸한 문서를 만들어내기 위해 수많은 정보들과 씨름하는 고통에서 작성자를 구해주는 것이죠. <strong>각 종류의 문서는 각각 단 하나의 목적만을 가지고 있으니까요.</strong></p>
<p>사실, 명시적으로든 암시적으로든 이 네 가지 중 하나로 분류되지 않는 문서는 관리하기 어렵습니다. 각각의 문서는 다른 문서들과 완전히 다른 요구사항을 가지고 있기 때문에, <strong>이러한 분류 체계를 유지하지 못하는 문서를 관리하는 것은 마치 한 번에 사방팔방으로 줄을 모두 당기려는 것과 같습니다.</strong></p>
<p>일단 이 분류 체계를 이해하게 되면, 이미 존재하는 문서들을 분석하고 어떻게 그 문서들을 향상시킬 수 있는지 이해하는 데에도 아주 유용한 지식이 될 것입니다.</p>
<h3 id="프로젝트-문서">프로젝트 문서</h3>
<p>변경사항change logs이나 기여 정책contribution policy이나 기타 프로젝트에 관련된 이런 저런 문서들은 어떤 분류에 해당하는지 아마 의문이 들텐데요, 정답은 저 문서들이 그 중 어디에도 해당하지 않는다는 것입니다. 엄밀히 말해서 저 문서들은 <em>‘소프트웨어’ 자체에 대한 문서가 아니라 프로젝트에 관한 문서들이기 때문</em>입니다.</p>
<p>저것들은 그냥 소프트웨어의 다른 것들과 섞이지 않는 선에서 적당한 곳에 적당히 보관하면 됩니다.</p>
<p>프로젝트 문서에 관한 위 사항을 기억해두고 이제부터 네 가지 문서 종류 각각에 대해 살펴보도록 하겠습니다.</p>
<h2 id="튜토리얼-1">튜토리얼</h2>
<p>튜토리얼은 어떤 프로젝트를 달성하는 데까지 독자를 단계적으로 이끌어가는 강좌입니다. 이를 통해 이 프로젝트로 무언가를 달성하는 방법과 순서를 초보자에게 보여줄 수 있습니다.</p>
<p>이는 전체적으로 <strong>학습 지향적</strong>인 문서이며, 특히 프로젝트 자체에 대해 배우기보다는, 프로젝트를 통해 무언가를 이루는 방법을 배우는 데에 중점을 두고 있습니다.</p>
<p><strong>당신은 선생님이 되어</strong>, <strong>책임을 가지고</strong> 학생들을 가르쳐야 합니다. <strong>당신의</strong> 설명을 따라서 학생들은 어떤 <strong>목표</strong>를 이루기 위한 일련의 행동을 실행하게 됩니다.</p>
<p>학생들의 행동과 목표는 당신이 결정해야 합니다. 하지만 목표를 결정하는 것은 쉬운 일이 아닙니다. 제시되는 목표는 충분히 의미있으면서도, 완전 초보자까지도 달성할 수 있음직한 것이어야 합니다.</p>
<p><em>아이에게 요리를 가르친다고 가정해 봅시다</em></p>
<p><em>어떤</em> 요리를 가르칠 것인지는 사실은 별로 중요한 게 아닙니다. 진짜 중요한 것은 아이가 요리의 즐거움을 깨닫고 자신감을 갖게 되는 것, 더욱 도전하고 싶은 마음을 심어주는 것입니다.<br>
요리하는 과정을 통해서 아이는 요리에서 중요한 것들이 무엇인지 배우게 됩니다. 주방에 있는 게 어떤 느낌인지, 식기들을 어떻게 사용하는지, 음식을 어떻게 다뤄야 하는지를 배우는 것이죠.</p>
<p><strong>소프트웨어를 사용하는 것은 요리를 하는 것처럼 기능적인 작업입니다</strong>. 지식이긴 하지만 이론적인 지식이라기보다는 실제로 겪어봐야 하는 종류의 지식이죠. 우리는 이런 류의 새로운 기술이나 재주를 처음 배울 땐 늘 우선 직접 해보는 데서 시작하곤 합니다.</p>
<p>중요한 점은, 튜토리얼을 모두 완료한 학습자가 나머지 다른 문서들과 해당 소프트웨어 자체를 이해할 수 있는 위치에 선다는 것입니다.</p>
<p>대부분의 소프트웨어 프로젝트는 튜토리얼이 아예 없거나 있더라도 아주 구질구질합니다. 튜토리얼이란 건 '학습자’를 '사용자’로 탈바꿈시켜주는 문서입니다. <strong>튜토리얼이 후지거나 아예 없다는 건, 새로운 사용자가 프로젝트에 유입되는 것을 가로막는 장벽이 됩니다.</strong></p>
<p>좋은 튜토리얼을 작성하는 것은 아주 어렵습니다. 초보자에게도 유용해야 하고, 따라가기에도 쉬워야 하며, 의미있게 잘 짜여져있어야 하니까요.</p>
<h3 id="튜토리얼을-잘-쓰는-방법">튜토리얼을 잘 쓰는 방법</h3>
<h4 id="직접-시도해-보면서-배우게-하세요">직접 시도해 보면서 배우게 하세요</h4>
<p>우리는 뭐든 <strong>처음에는 직접 해보면서 배웁니다</strong>. 옹알이나 걸음마처럼요.</p>
<p>소프트웨어 튜토리얼에서 학습자는 무언가를 <em>직접 실행해야</em> 합니다. 튜토리얼에서 요구하는 행동들은 가능한 여러가지 도구와 조작을 접하도록 해주는 것이 좋습니다. 처음에는 단순한 것을 만들고 점진적으로 복잡한 것들을 다루게 해야 하고요.</p>
<h4 id="일단은-어쨌든-시도를-하게-만드세요">일단은 어쨌든 시도를 하게 만드세요</h4>
<p>초보자의 첫 걸음은 손을 잡고 이끌어주는 걸음마여도 충분합니다. 마찬가지로 초보자에게 처음 알려주는 방법이 ‘경험자라면 절대 하지 않을’ 방법이거나 ‘올바르지 않은’ 방법이어도 괜찮습니다. 튜토리얼은 모범 사례 설명서가 아니니까요.</p>
<p>튜토리얼의 중요한 점은 학습자가 <strong>여정을 시작하게 하는</strong> 데에 있는 것이지 그들을 목적지에 데려다 주는 데에 있는 것이 아닙니다.</p>
<h4 id="튜토리얼은-반드시-잘-작동해야-합니다.">튜토리얼은 반드시 잘 작동해야 합니다.</h4>
<p>선생님으로서 해야 할 일 중 하나는 초보자의 자신감을 복돋아주는 것입니다. 소프트웨어, 튜토리얼, 학습 과정 자체에 대한 자신감도 그렇고, 튜토리얼이 제시하는 과제를 달성할 수 있다는 자신감까지 불어넣어 주어야 합니다.</p>
<p>친근한 조언, 일관성 있는 언어 사용, 자료들을 통한 논리적 진행 등 자신감을 복돋아주기 위한 많은 방법들이 있습니다. 하지만 이런 방법들보다 우선 <strong>가장 중요한 점은 제시한 과제가 반드시 제대로 동작해야 한다는 것</strong>입니다. 학습자는 당신이 시킨대로 어떤 행동을 했을 때 반드시 당신이 말 한대로의 효과를 확인할 수 있어야 합니다.</p>
<p>학습자의 행동이 이상한 결과나 오류를 만들어낸다면 튜토리얼은 망한 것입니다. 당신 탓이건 아니건 그런건 중요하지 않습니다. 옆에서 학생을 보고 있다면 그 자리에서 어떻게든 해결해 줄 수 있겠지만 학생이 그저 혼자서 튜토리얼 문서를 읽고 있는 거라면 그럴 수가 없습니다. 따라서 그런 일이 일어나지 않도록 미리 미리 대비를 해야 합니다. 물론 말처럼 쉬운 건 아닙니다만.</p>
<h4 id="유저가-결과를-바로-확인할-수-있도록-하세요.">유저가 결과를 바로 확인할 수 있도록 하세요.</h4>
<p><strong>학습자가 하는 모든 행동은 아무리 사소하더라도 이해할 수 있는 뭔가를 달성하는 것이어야 합니다.</strong> 혹시 학생이 이해가 안 가는 뻘짓을 두 페이지씩 따라 해야 겨우 결과를 확인할 수 있다면 그건 좀 너무한거죠. 모든 행동의 효과는 가능한 빠르고 분명하게 눈에 보여야 합니다. 물론 행동과 결과의 연관성도 명확하게 드러나야 하구요.</p>
<p>또한, 튜토리얼의 각 섹션의 결론, 튜토리얼 전체를 아우르는 결론은 반드시 의미있는 성과여야 합니다.</p>
<h4 id="튜토리얼을-반복할-수-있게-만드세요.">튜토리얼을 반복할 수 있게 만드세요.</h4>
<p><strong>튜토리얼은 반드시 반복이 가능해야 합니다.</strong> 그렇게 만드는 게 쉽진 않지만요. 사람들은 튜토리얼에 여러가지 운영체제와 도구를 통해서 찾아오고, 각 개인이 가진 경험도 천차만별입니다. 게다가 같은 유저라고 하더라도 사용하는 프로그램이나 자원들은 매번 조금씩 달라져있을 가능성이 큽니다.</p>
<p>그 어떤 유저가 시도하더라도 튜토리얼은 항상 정확히 동작해야 합니다.</p>
<p>안타깝지만 튜토리얼이 그렇게 잘 작동하는 것을 확인하기 위해서는 정기적이고 세심한 테스트가 필요하겠죠.</p>
<h4 id="추상적인-개념보다는-구체적인-단계에-집중하세요.">추상적인 개념보다는 구체적인 단계에 집중하세요.</h4>
<p><strong>튜토리얼은</strong> 정확한 행동과 결과를 바탕으로 <strong>구체적인 내용을 담고 있어야 합니다.</strong></p>
<p>추상적인 내용을 소개하고 싶은 유혹은 아주 강렬합니다. 추상화야말로 대부분의 컴퓨터 공학의 힘의 원천이니까요. 하지만 모든 학습의 과정은 구체적이고 특정한 부분으로부터 점차 일반적이고 추상적인 방향으로 진행되어야 합니다. 학습자가 구체적인 내용에 대해 충분히 곱씹어볼 기회를 갖기도 전에 추상화의 이점을 설파하려 드는 것은 잘못된 교습 방법입니다.</p>
<h4 id="필요한-최소한의-설명만을-제공하세요.">필요한 최소한의 설명만을 제공하세요.</h4>
<p><strong>굳이 학습자에게 별로 필요도 없는 지식을 모조리 설명하려 들지 마세요.</strong> 물론 논의의 지평을 넓히는 것은 중요한 일이지만, 굳이 튜토리얼에서 그럴 필요는 없습니다. 그런 내용들은 그냥 학습의 방해물에 불과합니다. 필요 최소한의 설명이 딱 적당합니다. 튜토리얼에서 직접 설명을 하는 대신 어디 다른 문서에 있는 설명을 링크로 제공하세요.</p>
<h4 id="오직-사용자가-해야-하는-단계에만-집중하세요.">오직 사용자가 해야 하는 단계에만 집중하세요.</h4>
<p><strong>튜토리얼은 당장 해야 하는 작업에만 집중할 필요가 있습니다.</strong> 당신이 방금 소개한 명령어가 다른 수많은 옵션을 가지고 있을 수도 있겠죠. 혹은 어떤 API 에 접근하는 수많은 다른 방법들이 있을 수도 있구요. 하지만 그딴 게 무슨 상관이 있겠습니까. 지금 당장 튜토리얼을 진행하는 데 필요한 것도 아닌데.</p>
<h2 id="하우-투-가이드-1">하우-투 가이드</h2>
<p>하우-투 가이드는 현실적 문제를 단계별로 해결하는 방법을 설명합니다.</p>
<p>하우-투 가이드는 특정한 목표를 달성하기 위한 안내서입니다. 예를 들어 ‘웹 폼을 만드는 법’, ‘3차원 데이터셋을 도면으로 그리는 법’, ‘LDAP 인증을 활성화 하는 법’ 같은 것들이죠.</p>
<p>하우-투 가이드는 <strong>목표 지향적</strong>인 문서입니다.</p>
<p>비유하자면, 무언가를 먹기 위해서 어떤 식재료를 요리하는 방법을 설명하는 조리법과 비슷합니다.</p>
<p>조리법은 명확하게 정의된 목표가 있고 특정한 질문을 다룹니다. 이 문서는 어떠한 목표를 달성하기 위한 과정을 설명하는 것이며, 이 문서를 읽는 사람이 이미 기본적인 지식을 갖추었을 거라고 전제할 수 있습니다.</p>
<p>하우-투 가이드는 튜토리얼과는 완전히 다릅니다. 하우-투 가이드는 튜토리얼이 대상으로 할 만한 진짜 초보자로서는 떠올리지도 못 할 만한 질문에 대한 해답을 제시합니다.</p>
<p>하우-투 가이드에서는 독자가 어느 정도의 기본적 지식과 이해를 가지고 있다거나, 이미 기본적인 방법과 도구 활용법을 알고 있다고 가정하고 설명할 수 있죠.</p>
<p>하우-투 가이드 문서는 대체로 꽤 잘 갖춰져있는 경우가 많습니다. 작성하기에도 쉽고 재밌는 편이죠.</p>
<h3 id="하우-투-가이드를-잘-쓰는-방법">하우-투 가이드를 잘 쓰는 방법</h3>
<h4 id="일련의-단계를-제시하세요">일련의 단계를 제시하세요</h4>
<p><strong>하우-투 가이드는 순서대로 따라야 하는 단계별 목록을 제시합니다</strong>(튜토리얼과 흡사합니다). 굳이 아주 초보적인 부분보다는 적당하다고 생각되는 부분을 시작점으로 선택할 수 있습니다. 하우-투 가이드는 신뢰할 수 있어야 하지만 튜토리얼처럼 반드시 반복 가능해야 하는 견고한 구조까지는 필요하지 않습니다.</p>
<h4 id="결과물에-집중하세요">결과물에 집중하세요</h4>
<p><strong>하우-투 가이드는 실용적인 목표에 집중해야 합니다.</strong> 그 외의 다른 것은 모두 부차적인 문제입니다. 튜토리얼에서와 마찬가지로, 과도한 설명은 지양해야 합니다.</p>
<h4 id="문제를-해결하세요">문제를 해결하세요</h4>
<p><strong>하우-투 가이드는 반드시 특정한 문제나 질문에 대한 해답을 제시해야 합니다.</strong> 이 문서는 “ㅇㅇㅇ을 하는 방법” 이니까요.</p>
<p>이 점이 바로 하우-투 가이드가 튜토리얼과 차별화되는 부분입니다. 하우-투 가이드를 읽는 독자는 자신이 하고자 하는 게 무엇인지는 이미 짐작하고 있습니다. 다만 구체적인 방법을 모를 뿐이죠. 튜토리얼에서처럼 당신은 독자가 해당 문제를 해결하기 위해 무엇을 알아야 하는지를 결정할 책임이 있습니다.</p>
<h4 id="개념을-설명하지-마세요">개념을 설명하지 마세요</h4>
<p><strong>하우-투 가이드는 뭔가를 설명하지 않습니다.</strong> 그런 종류의 논의를 하기 위한 무대가 아닙니다. 하우-투 가이드에서는 단순히 행동을 나열하면 됩니다. 만약 중요한 설명이 필요하다면 해당 설명에 대한 링크를 제공하세요.</p>
<h4 id="어느정도의-유연성을-허용하세요">어느정도의 유연성을 허용하세요</h4>
<p>하우-투 가이드는 같은 일을 하기 위한 <strong>여러가지 다른 방법들에 대해 유연한 태도를 가져야 합니다.</strong> 여러 비슷한 경우들에 대해 제시된 내용이 어떻게 적용이 가능한지 유저가 알 수 있을 정도, 혹은 비슷한 다른 시스템이나 환경에서 어떻게 이 방법을 적용할 있는지 알 수 있을 정도면 충분합니다. 너무 특정한 상황에서만 들어맞는 문서는 정확히 동일한 상황이 아니면 쓸모가 없겠죠.</p>
<h4 id="내버려-두세요">내버려 두세요</h4>
<p><strong>완벽한 것 보다는 실용적인 것이 중요합니다.</strong> 튜토리얼은 완성도가 높고 처음부터 끝까지를 제대로 설명해야 하지만 하우-투 가이드는 그럴 필요가 없습니다. 하우-투 가이드는 시작와 끝을 적당히 정해도 됩니다. 주제와 관계된 것이 있다고 해서 굳이 그 것들을 모조리 언급할 필요도 없습니다. 내용이 너무 빵빵한 하우-투 가이드는 유저에게 빠른 해결책을 제공하지 못합니다.</p>
<h4 id="적절한-이름을-붙이세요">적절한 이름을 붙이세요</h4>
<p><strong>하우-투 가이드의 제목은 이 문서가 무엇을 설명하고 있는지를 정확하게 드러내야 합니다.</strong> ‘클래스 기반 뷰를 만드는 방법’ 은 좋은 제목입니다. '클래스 기반 뷰 만들기’는 좀 애매하네요. '클래스 기반 뷰’라는 제목은 영 별로입니다.</p>
<h2 id="레퍼런스-1">레퍼런스</h2>
<p>기술 레퍼런스는 실제로 작동하는 메커니즘과 그 운용 방식에 대한 기술적인 설명입니다.</p>
<p>레퍼런스는 오직 설명만 합니다. 레퍼런스가 설명하는 내용이 클래스나 함수, API, 기타 등등 코드 그 자체이기 때문에 문서의 구조는 코드의 구조를 따르게 됩니다. 또한 레퍼런스는 함수, 멤버 변수, 속성, 메소드 같은 것들의 목록을 나열하고 그것들을 사용하는 방법을 제시합니다.</p>
<p>레퍼런스는 <strong>정보 지향적</strong>입니다.</p>
<p>기술 레퍼런스는 사용법을 묘사하기 위한 예제를 포함할 수도 있지만 기본적인 개념을 설명하거나 공통적인 작업을 달성하는 방법을 설명하기 위한 예제여서는 안됩니다.</p>
<p>레퍼런스는 <strong>간결하고 정중해야 합니다.</strong></p>
<p>요리법에 관한 비유를 다시 들자면 <em>레퍼런스는 어떤 식재료에 대한 백과사전 항목과 비슷합니다.</em> 해당 식재료의 성분, 기원, 효능과 화학적 구조, 조리법등을 담고 있죠.</p>
<p>레퍼런스에는 이 기능을 어떻게 사용하는지에 관한 기초적 설명이 <em>꼭</em> 포함되어야 합니다. 예를 들면 특정 클래스를 어떻게 인스턴스화 하는지, 어떤 메소드를 어떻게 호출하는지, 어떤 함수에 무언가 매개변수를 넘길 때 반드시 주의해야 할 점은 무엇인지 등등. 이런 점들이 레퍼런스와 하우-투 가이드를 구분짓는 차이점입니다. 소프트웨어의 정확한 사용법을 설명하는 것(레퍼런스)은 특정한 목적을 달성하기 위한 방법을 보여주는것(하우-투 가이드)과는 전혀 다릅니다.</p>
<p>세상엔 레퍼런스 말고 다른 종류의 문서라는 게 존재한다는 걸 상상도 못하는 개발자들도 있습니다. 그들은 이미 그들의 소프트웨어를 이해하고 있으며, 어떻게 사용하는지도 알고 있습니다. 그들은 다른 사람들에게 필요한 것도 오직 그런 기술적인 정보들일거라고만 여깁니다.</p>
<p>레퍼런스 문서도 보통 잘 작성되어 있는 편입니다. 심지어 자동으로 생성할 수도 있습니다(결과물이 항상 좀 허술하긴 하지만).</p>
<h3 id="레퍼런스를-잘-쓰는-방법">레퍼런스를 잘 쓰는 방법</h3>
<h4 id="문서-구조는-코드에-기반해서-결정하세요">문서 구조는 코드에 기반해서 결정하세요</h4>
<p><strong>레퍼런스 문서의 구조를 코드베이스와 동일하게 만들면</strong> 사용자는 코드와 레퍼런스 문서를 함께 참조할 수 있습니다. 또한, 이렇게 하면 관리자들도 쉽게 문서화 과정에서 빠진 부분이나 갱신이 필요한 부분을 발견할 수 있게 됩니다.</p>
<h4 id="일관적인-표현을-사용하세요">일관적인 표현을 사용하세요</h4>
<p><strong>레퍼런스 문서는 다른 사전들처럼 구조, 어조, 형식등을 항상 일관성 있게 사용해야 합니다.</strong></p>
<h4 id="오직-설명만-하세요">오직 설명만 하세요</h4>
<p><strong>레퍼런스 문서에 요구되는 유일한 기능은 바로 가급적 명확하고 완전한 설명입니다.</strong> 그 외의 다른 것들(해설, 논의, 조언, 추측, 의견 등)은 문서를 활용하기도, 유지보수하기도 어렵게 만듭니다. 혹시 필요하다면 설명을 위한 적절한 예제를 제공하세요</p>
<p>레퍼런스 매뉴얼에 기본적인 소프트웨어 사용법을 넘어서, 특정한 목적을 이루기 위한 응용법을 설명하고 싶은 유혹을 떨쳐내세요. 개념을 설명하고 싶은 욕심이나 개발과 관련된 사항을 논의하고 싶은 충동도 이겨내야 합니다. 대신 적절하게 하우-투 가이드와 해설 문서, 튜토리얼 문서들에 대한 링크를 제공하세요.</p>
<h4 id="정확하게-작성하세요">정확하게 작성하세요</h4>
<p>이 문서에 포함된 설명들은 <strong>반드시 최신화된 정확한 내용이어야 합니다.</strong> 설명 문서와 실제 동작 사이에 존재하는 모순 유저의 꼭지를 확 돌게 만들고 말 것입니다.</p>
<h2 id="해설-문서-1">해설 문서</h2>
<p>해설과 논의는 특정한 주제를 명확히 하거나 주의를 환기합니다. 이런 것들은 문서가 커버하는 주제의 범위를 넓히는 역할을 합니다.</p>
<p>해설 문서는 <strong>이해 지향적</strong>입니다.</p>
<p>해설 문서는 어떤 면에서는 논의 문서라고도 할 수 있습니다. 이 문서들은 소프트웨어 자체에서 한 발짝 물러나서 더 넓은 시야, 혹은 기존과 다른 관점에서 소프트웨어를 바라볼 수 있게 해 줍니다. 여가 시간에 취미로 코드를 읽는 것 보다는 해설이나 논의를 읽는 게 일반적으로 덜 이상해보이겠죠.</p>
<p>이런 종류의 문서가 명시적으로 생성 되는 경우는 드뭅니다. 대신 문서나 코드 여기저기에 파편화된 해설들이 흩어져있곤 하죠. 가끔 해설 섹션이 존재하는 경우가 있긴 하지만 그런 경우에도 보통 '해설’이라는 제목이 아니라 대충 '배경 설명’이나 ‘비고’ 등의 제목이 붙어있고 제대로 된 해설이나 논의 문서로 기능하지 않기 일쑤입니다.</p>
<p>논의 문서는 생각보다 쓰기 쉽습니다. 누군가의 질문에 대답하는 게 아무래도 빈 종이에 무언가에 대한 설명을 써내려가는 것 보다는 간단하니까요.</p>
<p>특정한 목표를 달성하기 위한 방법(하우-투 가이드)이나, 사용자가 배우길 바라는 주제(튜토리얼), 작동 방식에 의해 정의되는 내용(레퍼런스)…등을 제외한 주제 중에서 당신이 한 문서에 담기 적당하다고 생각하는 내용들을 넣는 곳이 바로 해설/논의 문서입니다. 따라서 간혹 논의 문서가 다루는 주제는 좀 생뚱맞을 수도 있습니다.</p>
<h3 id="해설-문서를-잘-쓰는-방법">해설 문서를 잘 쓰는 방법</h3>
<h4 id="맥락을-제공하세요">맥락을 제공하세요</h4>
<p><strong>해설 문서는 배경과 맥락을 제공하는 곳입니다.</strong> 예를 들면 ‘Django를 통해 제어되는 웹 폼’ 이라던지 ‘Django CMS와 검색에 관하여’ 같은 것들이 되겠죠.</p>
<p>또한, 현재의 어떤 것이 <em>왜, 어쩌다가 이렇게 된 것인지</em> (설계 단계의 결정 때문이었다거나, 어떤 역사적 이유가 있다거나, 기술적 제약 때문이라거나 등등) 그 이유를 설명할 수 있는 곳이기도 합니다.</p>
<h4 id="대안과-의견들을-논의하세요">대안과 의견들을 논의하세요</h4>
<p><strong>해설 문서에서는 여러 대안들이나 다각도의 접근을 고려할 수 있습니다</strong>. 예를 들어 Django 배포에 관한 문서라면 여러가지 웹 서버를 사용하는 선택지들에 대해 고려하고 평가하는 등의 내용이 있을 수 있겠죠.</p>
<p>논의 문서는 서로 반대되는 의견들을 저울대에 올릴 수도 있습니다. 예를 들면 ‘테스트 모듈을 패키지 디렉토리 안에 넣을까 밖으로 빼야 할까’ 같은 것들이죠.</p>
<h4 id="무언가를-지시하거나-기술적-레퍼런스를-제공하지-마세요">무언가를 지시하거나 기술적 레퍼런스를 제공하지 마세요</h4>
<p><strong>해설 문서는 다른 문서들이 제공하지 않는 내용을 제공해야 합니다.</strong> 해설 문서는 유저에게 무언가를 하는 방법을 지시하거나 설명하는 곳이 아닙니다. 기술적인 설명을 제공하는 곳도 아니구요. 이런 내용들은 이미 다른 문서들이 해치운 부분이니까요.</p>
<h2 id="이런-문서-구조에-관해서">이런 문서 구조에 관해서</h2>
<h3 id="분류가-왜-이렇게-애매하죠">분류가 왜 이렇게 애매하죠?</h3>
<p>이렇게 명확한 분류 체계가 있음에도 불구하고 각 문서들이 애매하게 분류되고 서로의 영역을 자꾸 침범하는 데에는 이유가 있습니다.<br>
<img src="https://lazygyu.net/images/blog/51c9f1d6e48a3bcbb738d26f8370f0fd" alt="문서 종류 분류 사분면"><br>
튜토리얼과 하우-투 문서는 실용적인 단계를 설명한다는 점에서 비슷합니다. 하우-투 가이드와 레퍼런스는 실제로 코딩하거나 일하면서 필요하다는 점에서 비슷하죠. 리퍼런스와 해설은 이론적인 지식을 다룬다는 점이 비슷합니다. 튜토리얼과 해설 문서는 실제로 작업을 할 때보다는 공부를 할 때 더 유용하다는 점이 비슷하구요.</p>

<table>
<thead>
<tr>
<th></th>
<th>공부할 때 유용한 것</th>
<th>작업할 때 유용한 것</th>
</tr>
</thead>
<tbody>
<tr>
<td>실용적인 단계별 목록</td>
<td>튜토리얼</td>
<td>하우-투 가이드</td>
</tr>
<tr>
<td>이론적인 지식</td>
<td>해설문서</td>
<td>레퍼런스</td>
</tr>
</tbody>
</table><p>이렇게 각각의 영역들이 조금씩 겹치기 때문에 구분이 혼란스럽고 서로 섞여 버리곤 하는 거죠.</p>
<p>그러다보니 이 네 가지가 정확히 분류된 좋은 예를 찾기는 어렵습니다만, 꽤 많은 문서들이 이 네 가지 분류를 각기 다른 기능으로 인식하고 있다는 것은 어렵지 않게 확인할 수 있습니다.</p>
<p><a href="https://docs.djangoproject.com/en/1.11/#how-the-documentation-is-organized">Django</a>(Django의 <a href="https://docs.djangoproject.com/en/1.8/">예전 버전들은 이러한 분류들을 명시적으로 사용하지는 않았었습니다</a>)나 <a href="http://docs.django-cms.org/en/release-3.4.x/">Django CMS</a> 같은 몇몇 프로젝트들은 이 분류를 전면적으로 적용하고 있습니다. 두 프로젝트 모두에서 이러한 분류 방식은 가치를 입증해냈죠.</p>
<h3 id="분석에-대해서">분석에 대해서</h3>
<p>이 글에서 제시하는 문서화에 대한 분석은 다년간의 문서 작성 및 유지보수 경험과, 어떻게 하면 문서화를 더 향상시킬 수 있는지에 대해 고민하면서 보낸 많은 시간들에 기초하고 있습니다.</p>
<p>또한 이 글은 여러 분야에서 회자되는 원칙들에도 기초하고 있습니다. 예를 들어 튜토리얼에 대한 내용은 교육학의 기초적인 개념을 차용하고 있죠. 학습자와 선생을 배치하고, 소프트웨어 활용법을 마치 구체적인 작업을 하는 단계를 거침에 따라 일반적이고 추상적인 원칙과 개념을 익힐 수 있는 작업처럼 취급합니다.</p>
<h2 id="문서화-작업하기">문서화 작업하기</h2>
<p>문서 작업자들의 가장 큰 두통거리 중 하나는 그들이 해야 하는 일이 뭔지 정확히 예측 할 수가 없다는 것입니다. 글을 쓰고 또 쓰지만 그럴 수록 흡족하게 글을 쓰기는 어렵다는 것만 깨닫게 되죠.</p>
<p>이 글에서 제시한 구조는 명확한 분류와 구분으로 그 의문점들을 해소해줍니다. 이 방식은 문서를 작성하고 유지보수하기 편하게 만들어 줍니다. 게다가 사용하거나 탐색하기에도 더 편리하죠.</p>
<p>여전히 문서화가 자동으로 되진 않습니다만, 이제 더 이상 뭔가 어색한 문서 분류나 내용의 애매한 범위, 대체 문서에 어떤 내용이 들어있어야 하는지, 이런 문서는 어떤 스타일을 적용해야 하는지와 같은 문제를 가지고 씨름할 필요가 없습니다. 뭘 써야 할 지, 어떻게 써야 할 지, 그리고 어디에 써야 할 지가 훨씬 명확해졌죠.</p>
<p>이는 사용자에게 더 나은 서비스를 제공하게 해줍니다. 이제 사용자는 소프트웨어를 사용하는 어떤 단계에서든 그 시점에 가장 적절한 종류의 문서를 확인할 수 있기 때문입니다.</p>
<p>명시적/암시적으로 이 네 가지 종류의 문서를 작성해 두는 것은 더 많은 사용자를 소프트웨어로 모아들이고 유지할 수 있게 해줍니다. 이 사용자들은 잘 분류된 문서를 통해 소프트웨어를 더욱 효율적으로 활용할 수 있게 되죠. 궁극적으로 모든 소프트웨어 개발자들이 꿈꾸는 목표가 바로 이 것이겠죠.</p>
<h2 id="about-the-divio-expert-series">About the Divio Expert series</h2>
<p><a href="https://www.divio.com/en/company/about/">Our experts</a> really do deserve the name. Between them they have decades of Django development experience; the depth and breadth of the expertise we are able able to offer is world-class. They include core developers of Django, django CMS and other notable projects, and the architects of very large systems such as the Divio Cloud infrastructure.<br>
The new Divio Expert weblog series aims to share some of this expertise. For updates on new articles, follow <a href="https://www.divio.com/en/company/about/">our Twitter feed</a>, or subscribe to our (very low volume) newsletter.</p>
<h2 id="작성자-">작성자 :</h2>
<a href="https://www.divio.com/blog/author/daniele-procida/">
Daniele Procida
</a><br>
Author at Divio<br>
<blockquote>
<p>역주 : 마지막 문단은 원본 시리즈에 대한 설명 및 홍보 멘트여서 원문을 유지해 두었습니다.</p>
</blockquote>

 ]]></content:encoded>
<link>https://lazygyu.net/blog/secrets_of_documentation</link>
<category><![CDATA[ 번역 ]]></category>
<pubDate>Wed, 23 Jan 2019 19:00:00 +0900</pubDate>
<guid>https://lazygyu.net/blog/secrets_of_documentation</guid>
</item>
<item>
<title><![CDATA[ 그간 만들었던 것들 근황 ]]></title>
<description><![CDATA[ 그간 만들었던 물건들 근황 ]]></description>
<content:encoded><![CDATA[ <p>요즘 쓸 것도 없고 그간 만든 물건들 근황이나 적어봄미다</p>

<h3>키보드</h3>
<img src="https://lazygyu.net/images/blog/3a0bdb73107210c1597477a87980c08f" /><br />
<img src="https://lazygyu.net/images/blog/ffe84eedda3c279fb4c43f3c87b74cfd" /><br />
<p>몇 번의 개량을 거쳐 현재는 이런 형태로 정착..</p>
<p>케이스는 3d 프린터로 다시 제작하고, pcb도 새로 설계해서 주문...키캡은 DSA 로 변경</p>

<h3>습도 조절기</h3>
<img src="https://lazygyu.net/images/blog/0e1675f34d0cd46164f00a1ad446965b" />
<p>얘도 LCD를 달고 케이스를 변경해서 지난 겨울에도 아주 유용하게 사용함.</p>
<p>솔직히 가습기에 습도 센서만 내장해줘도 되는거 아닌가 싶지만 어쨌든 내 가습기엔 그런 기능 없으니까 별 수 없지...</p>

<h3>집 원격 제어기</h3>
<img src="https://lazygyu.net/images/blog/e9b3a004e450cdfa913f467aa6294951" />
<p>구매한 미에어에 API 가 있어서 미에어 제어 기능을 추가하고 미에어에서 제공하는 공기 질 센서 정보도 함께 표시하도록 개량.</p>
<p>펫츠뷰는 해킹 위험을 없애기 위해 외부 네트워크와 차단하고 라즈베리파이하고만 통신할 수 있도록 네트워크 설정해서 이제 외부에서 펫츠뷰에 직접 접근할 걱정은 제거됨.</p>

<p>맨날 노느라 사실 별다른거 만든게 없고... 시도했던건 몇 개 있는데 블로그에 올릴만한 건 딱히 없는 것 같아서 쓸 내용이 없당.  스윙 마이 베이비도 이제 던파 사이트에서 내려갔으니까 홈페이지 한 쪽에 공간을 마련해서 여기서 할 수 있게 할까 싶은데 귀찮아서 차일피일 미루는 중....</p> ]]></content:encoded>
<link>https://lazygyu.net/blog/things_in_recents</link>
<category><![CDATA[ 생활 ]]></category>
<pubDate>Wed, 22 Aug 2018 01:00:00 +0900</pubDate>
<guid>https://lazygyu.net/blog/things_in_recents</guid>
</item>
<item>
<title><![CDATA[ 조별과제와 발표에 관한 아재의 추억팔이글 ]]></title>
<description><![CDATA[ 예전에는 뭔가를 조사하려면 일단 도서관에 가야했다. ]]></description>
<content:encoded><![CDATA[ 1.
<p>
예전에는 뭔가를 조사하려면 일단 도서관에 가야했다. 정보에 대한 접근 방법 자체가 아주 제한되어 있었기 때문에 그 시절에 방송에 어디어디 교수나 박사라는 사람이 나와서 뭔가 한마디 하면 일반인으로서는 그게 맞는지 틀린지 검증할 방법이 없었다. 도서관에 가더라도 대체 그에 관한 정보가 어느 책에 있는지를 알아내는 것 부터가 이미 무리였기 때문이다. 따라서 당시의 언론은 정보에 있어서만큼은 그야말로 무소 불위의 권력을 가지고 있었다고 할 수 있다. 그러면 그런 만큼 더 막중한 책임감으로 자신들이 내보내는 정보를 검증했어야 할텐데 정말 그랬는지 방송업계와 관련 없는 나로선 알 수 없는 일이다.
</p>
2.
<img src="https://lazygyu.net/images/blog/0cd97709280da9ebf586eac08429c2c5" />
<p>
그래서 당시엔 조별과제를 하려면 일단 도서관에 모여서 주제와 관련있는 분야의 책들을 왕창 들고 열람실에 둘러앉아서 각자 책을 열심히 들여다보면서 관련된 부분을 찾아 취합해야 했다. 그렇게 조사한 자료를 가지고 취합해서 내용을 정리하고 발표 자료를 만들고 발표하는 것이다. 이 시절에 조별과제를 지배하는 것은 집에 백과사전을 가진 친구와 글씨를 잘 쓰는 친구였다. 
</p>
3.

<img src="https://lazygyu.net/images/blog/c2bf5900542c23f8a1061b051d2d3a31" /><br />
<img src="https://lazygyu.net/images/blog/490cc2681e9d1d616de1f48a7cb2fac2" />
<p>
발표 자료를 만드는 방식의 변천사도 재밌는 기억이다. 내가 겪은 한도 내에서 제일 오래된 방식은 2절지에 손으로 쓰는 거였다. 그걸 궤도에 걸어서 한 장씩 넘기면서 발표를 했다. 선생이나 발표자가 지휘봉을 들고 있는 것은 바로 그 궤도에 걸린 종이를 넘기기 위한 도구다. 종이를 일자로 잘 넘기지 않으면 종이가 구겨지거나 찢어져버리기 때문에 튼튼하고 긴 막대가 필요했던 것이다.
</p>
<p>
이 궤도에 글자를 쓰는 것도 몇가지 요령이 필요한데, 우선 조에서 글자를 가장 잘 쓰는 사람을 선별해야 한다. 그리고 종이에 바로 글자를 써버리면 줄이 맞지 않고 비뚤어지기 때문에 종이를 부채 접기 하듯이 잘근잘근 접어서 줄을 표시한 담에 거기에 맞춰서 쓰는게 기본 요령이었다. 간혹 그렇게 접지 않고도 줄을 칼같이 맞춰서 쓰는 기술을 가진 친구들이 있었는데 이런 친구들은 발표자료 제작에서 우대를 받곤 했다. 끝이 약간 비스듬한 사각형으로 된 매직이 획의 굵기에 변화를 주면서 큰 글씨를 쓰기위한 도구였다.<br />
<img src="https://lazygyu.net/images/blog/b926d83d6b2cc0f2759d3410c2e916c6" /><br />

궤도를 가장 마지막까지 사용한 곳은 아마 교회들이 아닐까 생각한다. 찬송가 가사 등을 적은 궤도를 한 번쯤은 다들 본 기억이 있을 것이다.
</p>

4.
<img src="https://lazygyu.net/images/blog/52559f6f467c6e8a7cce7b0cbba2782d" />

<p>
이런 발표 자료에 첫번째로 혁명을 가져다 준 것은 <em>OHP(OverHead Projector)</em>였다. 이게 뭐냐면, 투명한 필름에 네임펜으로 글을 써서 램프 위에 올리면 위쪽에 달린 프로젝션 렌즈를 통해서 벽에 확대해서 비춰주는 기계다. 여기에 사용되는 투명한 필름이 OHP 필름이고, 이 필름에 글을 쓰는데 주로 사용된게 바로 네임펜이다. OHP 를 찾아 볼래야 찾아볼 수 없는 요즘 세대가 보기에 네임펜이란 건 그냥 얇은 매직과 비슷한 물건이겠지만 그 당시의 네임펜은 이런 발표자료를 만들기 위한 필수품이었다. 여기도 줄을 맞춰 쓰는게 어렵기 때문에 줄 쳐진 공책 위에 필름을 놓고 쓰는 등의 방법을 사용했다. 투명한 아크릴 재질에 끝쪽에만 빨간색으로 삼각형이 달려있는 지휘봉은 이 OHP 시절의 물건이다. OHP 자체는 사양세를 걸었지만 OHP 헤드유닛에 들어있는 렌즈 어셈블리는 지금도 자작 프로젝터를 만드는 사람들에게 소중한 자원으로 취급되고 있다.
</p>

5.

<p>
OHP에도 한 차례 혁신이 찾아왔는데, 그건 바로 개인용 PC의 보급과 프린터의 대중화였다. OHP 필름에 인쇄를 할 수 있는 프린터가 가정에 보급되고, 그로 인해 워드 프로세서로 만든 자료를 바로 OHP 필름에 뽑아낼 수 있게 되면서 이제 손글씨를 잘 쓰는 학생보다 집에 프린터를 가진 학생이 조별 과제에 더욱 요긴한 자원이 된 것이다. 다만 이는 OHP 시대의 마지막 즈음이어서, 프린터 가진 학생이 조원들에게 갑질을 할 수 있는 시대는 길게 가지 못했다.
</p>
6.

<img src="https://lazygyu.net/images/blog/b7d811285d2573a05d1c7c7bdae239d2" />
<p>
OHP 말엽에 잠시 등장했던 것이 실물 화상기다. 말 그대로 OHP 랑 비슷하게 생겼지만 프로젝션 렌즈 대신 카메라가 달려서 물건을 화면으로 띄워주는 기기였다. 이 실물 화상기가 사용되기 위해서는 발표장에 반드시 대형 화면이 있어야 했기 때문에 사실 대형 화면이 보급되면서 이 화면의 활용성을 여러가지로 모색하던 시절의 반짝 유행이 아니었다 싶다. 실제로 대형 화면이 있는 곳에는 pc만 연결하면 그냥 pc 화면을 보여줄 수 있었기 때문에 실물 화상기는 생각보다 크게 반향을 일으키지 못하고 금새 사라지고 말았다. 요즈음 소형화되어서 카메라처럼 사용하거나 아예 모바일 기기를 실물화상기 대용으로 사용하는 경우가 많다.
</p>

7.

<img src="https://lazygyu.net/images/blog/05ef113b0120b406b150f9bd3fa01069" />
<p>
대화면 프로젝션 TV가 보급되고, 프로젝터도 대중화되고, pc 보급률이 높아지면서 이후 발표자료는 대부분 ppt 로 대체된다. 이 시기 즈음에 인터넷의 보급도 활발해지면서 자료를 조사하는 것도 이전과는 비교할 수 없이 편리해지고, 이제 조별과제는 말 그대로 '성의'와 '창의'의 문제로 변했다. 이제 얼굴 한 번 안 보고 메신저를 통해서 과제를 진행할 수 있는 시대지만 나는 개인적으로 모두 모여서 2절지를 접고 서로 글씨 대결을 하거나 머리를 맞대고 네임펜으로 한 자 한 자 OHP 필름에 내용을 적어내려가던 시절의 재미가 사라진 것이 조금 안타깝다. 다함께 도서관에서 책을 쌓아놓고 분담해서 자료를 찾고 글씨 잘 쓰는 학생을 뽑아 발표 자료를 만들어야 했던 그 시절에는 조별과제 자체가 불가피한 수단이었겠지만, 혼자서도 충분히 이 모든 과정을 그 시절보다 더욱 쉽고 퀄리티 높게 해낼 수 있는 지금의 시점에서 조별과제는 대체 무얼 위한 것일까, 라는 의문이 남는다.
</p> ]]></content:encoded>
<link>https://lazygyu.net/blog/presentation_methods_in_old_time</link>
<category><![CDATA[ 잡담 ]]></category>
<pubDate>Thu, 17 May 2018 18:50:00 +0900</pubDate>
<guid>https://lazygyu.net/blog/presentation_methods_in_old_time</guid>
</item>
<item>
<title><![CDATA[ 아두이노로 에어컨 원격제어 하기 ]]></title>
<description><![CDATA[ 나랑 아내는 낮에는 회사에 있지만 호두는 이 더운 날씨에 집에 있어야한다. 그래서 늘 외부에서 집안 온도를 모니터링하고 에어컨을 조작할 수 있는 방법이 필요하다고 느끼긴 했었지만 귀찮아서 차일피일 미뤄왔다. 그러다가 밍기적거리면서 우선 집안 온습도를 모니터링하는 부분을 만들었는데,  ]]></description>
<content:encoded><![CDATA[ <h1>에어컨 원격제어</h1> <h2>개요</h2> <p>나랑 아내는 낮에는 회사에 있지만 호두는 이 더운 날씨에 집에 있어야한다. 그래서 늘 외부에서 집안 온도를 모니터링하고 에어컨을 조작할 수 있는 방법이 필요하다고 느끼긴 했었지만 귀찮아서 차일피일 미뤄왔다. 그러다가 밍기적거리면서 우선 집안 온습도를 모니터링하는 부분을 만들었는데, 가는 날이 장날이라고 만들어둔 다음날 아침 출근길에 에어컨 끄는 걸 잊고 그냥 나와버린 것이다!!</p> <p><img alt="에어컨을 켜 놓은 자의 한탄" src="https://lazygyu.net/images/blog/aircon_img_01.png_1501874644.png"/></p> <p>그간 몽총하게 미뤄왔던 나의 게으름을 반성하지 않을 수 없게 되어버린 것이다... 그래서 만들어본 에어컨 원격제어 리모컨 개발기다.</p> <h2>적외선 리모콘의 원리</h2> <p>에어컨을 사면 리모콘을 같이 준다. 적외선 리모컨이다. 따라서 우리는 이 리모컨 신호를 똑같이 적외선으로 에어컨에 쏴주면 멍청한 에어컨을 속여서 동작시킬 수 있다.</p> <p><img alt="에어컨 살 때 끼워준 리모컨" src="https://lazygyu.net/images/blog/aircon_img_02.jpg_1501874675.jpg"/></p> <p>그럼 이 리모컨은 어떤 원리로 작동할까?</p> <p>리모컨의 버튼을 누르면 리모컨은 앞에 달린 적외선 LED를 통해 빛으로 신호를 발싸한다. 그러면 에어컨에 있는 적외선 수신부가 그 신호를 읽고 거기에 맞는 동작을 하는 것이다. 여기까진 아주 간단한 얘기지...</p> <h3>캐리어 주파수</h3> <p>리모컨의 빛은 특정 주파수대로 깜빡여야 한다. 신호와는 별개로 빛이 깜빡이는 빈도가 정해져있는데, 이 빈도를 맞춰주지 않으면 아무리 신호를 똑바로 보내도 에어컨은 '아 나한테 하는 말이 아닌가?' 하고 무시해버린다. 이걸 캐리어주파수라고 하는데 대부분의 가전제품은 38 ~ 40 khz 대역을 사용한다. 샘숭 에어컨도 38khz를 사용하기 때문에 빛이 켜져있는 동안은 초당 3만 8천회의 빈도로 빛을 깜빡깜빡해주면 된다. 아주 조금 어긋나는 거 정도는 보통 관용있게 받아들여주기 때문에 안심해도 된다.</p> <h3>통신 프로토콜</h3> <p>리모콘과 가전제품의 통신에 사용되는 규약에는 사실 딱히 표준이랄 게 없기 때문에 각 회사마다, 그리고 각 제품마다 지 멋대로 정해놓은 규약대로 통신을 한다. 그나마 TV같은 애들에 사용되는 신호들은 대체로 규격화가 되어 분석된 지 오래기 때문에 만능리모콘 같은 걸 집앞 수퍼에서 단 돈 몇천원에 살 수 있지만 에어컨은 좀 다르다.</p> <p>내가 쓰는 샘숭 에어컨의 경우 리모컨 신호를 직접 받아서 여러가지로 뜯어본 결과와 웹서핑하면서 찾아낸 정보들을 통해 대략적인 프로토콜을 확인할 수는 있었지만... 멍청한 삽질이었다. 나는 그냥 켜고 끄기만 하면 되는데 왜 이런 짓을 했는지.....</p> <p><img alt="그러니까 이건 걍 삽질이었다는 말씀" src="https://lazygyu.net/images/blog/aircon_img_03.jpg_1501874696.jpg"/> (위와 같은 신호를 뽑아내기 위해 아주 많은 삽질이 필요했지만... 몽총한 짓이었따...후새드)</p> <p>그냥 리모컨에서 나오는 전원 켜지는 신호와 꺼지는 신호를 복사해뒀다가 에어컨에 쏴주기만 하면 된다.</p> <h2>재료</h2> <h3>mcu(마블 시네마틱 유니버스 아님)</h3> <p>집에서 굴러다니는 보드들 중에서 도무지 쓸 일이 없는 아두이노 나노를 하나 쓰기로 했다. 프로 미니 같은 애가 더 작긴 하지만 라즈베리파이와 usb 시리얼 통신을 하기 위해서는 usb 인터페이스가 내장된 보드가 편하기 때문이다.</p> <h3>그 외 재료</h3> <p>IR LED가 우선 필요하다. 이건 싸다. 개당 350원이었다. 더 싼 것도 찾아보면 나올거다 아마.. </p> <p>그리고 전선쪼가리랑... 1옴, 330옴 저항이 하나씩 들었고 트랜지스터(MPS2222A)도 하나 썼다.</p> <h2>적외선 송신부 제작</h2> <p><img alt="송신용 회로기판" src="https://lazygyu.net/images/blog/aircon_img_06.jpg_1501874804.jpg"/></p> <p>우선 IR LED를 아두이노로 켜기 위한 간단한 회로를 만들어서 기판에 부품들을 실장한다...고 쓰면 있어보이겠지? 후후후... 여튼 기판에 회로대로 때워 넣고, 아두이노와 연결한다.</p> <p>아두이노에는 serial을 통해 입력을 받아서 led를 제어하는 간단한 프로그램을 넣으면 끝.</p> <p>그렇게 만들어진 <strong>적외선 리모컨 모듈(!)</strong>을 라즈베리파이의 USB 포트에 꽂아넣으면 적외선 송신 준비 완료다.</p> <h2>웹 서버 제작</h2> <p><a href="https://lazygyu.net/blog/petzview_ipcam">펫츠뷰 애견캠</a> 에서 만들어서 쓰고있던 라즈베리파이 서버에 API를 추가해서 인증된 사용자로부터 특정 요청이 오면 시리얼 포트를 통해 아두이노로 신호를 보내는 기능을 추가했다. 그리고 프론트엔드에 에어컨 on / off 버튼을 넣어서 버튼이 눌릴 때 해당 요청을 보내도록 하면 끝! 아아아주 간단하지 않을 수 없다!</p> <h2>케이스 제작</h2> <p>사이즈를 재서 단순하게 모델링해서 3D 프린터로 뽑아서 케이스를 만들었다. 아주아주 앙증맞은 제어기가 되어서 매우 흡족!</p> <p><img alt="동전과의 크기비교" src="https://lazygyu.net/images/blog/aircon_img_04.jpg_1501874830.jpg"/> <img alt="넘나뤼 앙증맞은 이 자태" src="https://lazygyu.net/images/blog/aircon_img_05.jpg_1501874845.jpg"/></p> <h2>결과</h2> <p>이제 회사에 있을 때나 바깥에 있을 때도 집안 온도를 보면서 에어컨을 맘대로 껐다 켰다 할 수 있게 되었다. 그 후로 낮에 집 온도가 너무 올라가면 에어컨을 잠깐씩 켜주면서 집을 적당히 쾌적하게 해주고 있는데, 호두한테 소감을 물어볼 방법이 없는 관계로 가장 큰 수혜 당사자의 총평을 들을 수 없는 점이 아쉽다.</p> <p>나나 아내의 경우에는 리모컨 찾아 헤매이지 않고 에어컨을 맘대로 조절할 수 있는 점도 그렇고 외출했다가 돌아가는 길에 적당히 미리 에어컨을 켜는 등 편리한 점이 많아서 아주 만족하고 있다. 특히 나는 그간 미루고 미뤄왔던 거 하나를 해치워서 어찌나 후련한지...헤헿</p> <h2>사족</h2> <p>이번에 만든 송신기는 에어컨 뿐만 아니라 적외선 신호를 받는 다른 기기들도 제어할 수 있다. 티비, 셋탑박스같은 것들... 당장은 필요가 없어서 해당 기기들을 제어하는 명령 코드는 넣지 않았지만, 혹시나 필요해진다면 쉽게 집안의 다른 기기들을 제어할 수 있다는 점은 아주 큰 메리트라고 본다. 적외선은 지향성이 있기 때문에 그런 형태의 만능 리모콘을 만들게 된다면 적외선 LED를 몇 개 더 붙여서 사방팔방으로 적외선을 쏘게 해야 하겠지만.. 뭐 그런건 사실 별로 일도 아니기도 하고..</p> <p>재료에는 써있지 않지만 적외선 신호를 복사하기 위해서는 적외선 수신 센서 모듈도 하나 사야 한다. 물론 그것도 몇천원 안 하기 때문에 큰 부담은 없다. 요즘 IoT니 뭐니 해서 이런 형태의 원격제어용 리모콘 제품들이 나오고 있던데... 보통 이런 가내수공업 제작품은 단가가 비싸게 마련이지만 이번만큼은 워낙 싼 재료들이라 집에서 만드는 것도 나름 가격 경쟁력이 있다. (인건비 들먹이면 할 말 없지만)</p> ]]></content:encoded>
<link>https://lazygyu.net/blog/controll_airconditioner_via_arduino_with_ir</link>
<category><![CDATA[ 아두이노 ]]></category>
<pubDate>Fri, 04 Aug 2017 01:03:00 +0900</pubDate>
<guid>https://lazygyu.net/blog/controll_airconditioner_via_arduino_with_ir</guid>
</item>
<item>
<title><![CDATA[ 3D 프린터 구입 및 조립기 ]]></title>
<description><![CDATA[ 개인적으로 늘 3D 프린터보다는 CNC를 갖고 싶었지만.. 아무래도 아파트에 거주하다 보니 소음이나 분진 문제도 있고 해서 포기하고 지냈었다.. 마음을 비우고 살고 있었지만 우연히 보게 된 링크에서 아주 저렴한 3D 프린터를 발견해서 아무 생각없이 지르고 마는데... ]]></description>
<content:encoded><![CDATA[ <h1>3D 프린터 구입기</h1> <p>개인적으로 늘 3D 프린터보다는 CNC를 갖고 싶었지만.. 아무래도 아파트에 거주하다 보니 소음이나 분진 문제도 있고 해서 포기하고 지냈었다..</p> <p>마음을 비우고 살고 있었지만 우연히 보게 된 링크에서 아주 저렴한 3D 프린터를 발견해서 아무 생각없이 지르고 마는데...(나중에 대참사가 일어남)</p> <p>어쨋든 그래서 <a href="http://www.nasspop.com">내써팝</a> 에서 델타형으로 하나를 구매! 늠나 적절한 가격 29만 9천원...</p> <p>그리고 기다렸더니 택배가 예쁘게 도착했다.</p> <p><img alt="" src="https://lazygyu.net/images/blog/%EC%88%98%EC%A0%95%EB%90%A8_DSC00278.png_1498133968.png"/></p> <p>내용물도 파손되지 않도록 잘 정돈되어 들어있다.</p> <p><img alt="" src="https://lazygyu.net/images/blog/%EC%88%98%EC%A0%95%EB%90%A8_DSC00279.png_1498134015.png"/> <img alt="" src="https://lazygyu.net/images/blog/%EC%88%98%EC%A0%95%EB%90%A8_DSC00280.png_1498134023.png"/></p> <p>일단 꺼내서 냅다 조립 시작...</p> <p><img alt="" src="https://lazygyu.net/images/blog/%EC%88%98%EC%A0%95%EB%90%A8_DSC00281.png_1498134052.png"/> <img alt="" src="https://lazygyu.net/images/blog/%EC%88%98%EC%A0%95%EB%90%A8_DSC00282.png_1498134071.png"/> <img alt="" src="https://lazygyu.net/images/blog/%EC%88%98%EC%A0%95%EB%90%A8_DSC00283.png_1498134079.png"/></p> <p>모터 끼울때 넘나 난관이었는데, 볼렌치를 쓰니까 렌치 각도가 좀 삐뚤어도 잘 돈다는 걸 처음 알았따... 난 맨날 제일 싸구려 렌치만 썼었는데...볼렌치 넣어준 판매자의 배려에 이 때 좀 감동함..</p> <p><img alt="" src="https://lazygyu.net/images/blog/%EC%88%98%EC%A0%95%EB%90%A8_DSC00285.png_1498134163.png"/></p> <p>그외 이래저래 다른 부분들도 다 조립해서 완성!!</p> <p><img alt="" src="https://lazygyu.net/images/blog/%EC%88%98%EC%A0%95%EB%90%A8_DSC00289.png_1498134197.png"/></p> <p>완성하자마자 아무 생각없이 일단 글자를 뽑아서 테스트해봤지만 젠젠 쓸 수 없을 정도의 퀄리티가 나와서 좌절했다.</p> <p><img alt="" src="https://lazygyu.net/images/blog/%EC%88%98%EC%A0%95%EB%90%A8_DSC00290.png_1498134236.png"/></p> <p>펌웨어를 새 버전으로 찾아서 다시 넣어보고 각종 세팅 다시 하고 베드 레벨링도 하고... 그새 노즐도 막혀서 뚫고 아주 쌩 난리를 친 끝에야 조금 쓸만한 걸 뽑을 수 있는 상태가 되었는데</p> <p><img alt="" src="https://lazygyu.net/images/blog/%EC%88%98%EC%A0%95%EB%90%A8_DSC00291.png_1498134286.png"/></p> <p>그 후에도 지속적으로 아직까지 조정해가면서 이래저래 시도해보고 있는 중이다. 이젠 꽤 퀄리티가 괜찮아서 본격적으로 뭘 만들어봐도 될 수준이 됨.</p> <p><img alt="" src="https://lazygyu.net/images/blog/IMG_20170621_084053.jpg_1498134499.jpg"/></p> <p>쓰면서 여러가지 문제들이 생기는데 (모터 탈조라던지, 노즐이 막힌다던지, 필라멘트에 이물질이 들어간다던지....등등) 어느정도 경험이 더 쌓여야 쉽게쉽게 해결할 수 있을것 같고 아직은 뭐 하나 틀어질때마다 으아아아 하면서 사용중...</p> <p>필라멘트는 아직은 PLA 만 쓰고 있는데 쓰다보니 점점 ABS도 쓰고 싶고... ABS를 쓰려면 히팅베드랑 챔버도 필요할테고... 일단 퀄리티가 아주 잘 나오게 되면 그 때 다시 생각해봐야징!</p> ]]></content:encoded>
<link>https://lazygyu.net/blog/delta_kossel_review</link>
<category><![CDATA[ 생활 ]]></category>
<pubDate>Thu, 22 Jun 2017 03:30:00 +0900</pubDate>
<guid>https://lazygyu.net/blog/delta_kossel_review</guid>
</item>
<item>
<title><![CDATA[ 커스텀 기계식 키보드 제작기 ]]></title>
<description><![CDATA[ 아두이노를 사용한 기계식 키보드 자작기 ]]></description>
<content:encoded><![CDATA[ <p><iframe width="100%" height="500" class="youtubeFrm" src="https://lazygyu.net//youtube.com/embed/_e7l1xSMtew?rel=0" frameborder="0" allowfullscreen="true"></iframe></p> <h1>커스텀 키보드 제작</h1> <p>아두이노로 만드는 커스텀 키보드</p> <p><img alt="" src="https://lazygyu.net/images/blog/%EC%88%98%EC%A0%95%EB%90%A8_WP_20170426_22_12_20_Rich.png_1494787863.png"/></p> <h2>사용된 재료 목록</h2> <h3>아두이노 기판</h3> <p>아두이노 레오나르도 호환 보드 - 드리머 나노</p> <p>제품 링크 : <a href="https://www.dfrobot.com/wiki/index.php/Dreamer_Nano_V4.0_(DFR0213)">클릭</a></p> <p>구매처 : <a href="http://shopping.naver.com/search/all.nhn?where=all&amp;frm=NVSCTAB&amp;query=%EB%93%9C%EB%A6%AC%EB%A8%B8+%EB%82%98%EB%85%B8">네이버 쇼핑 링크</a></p> <p>26.000원</p> <h3>기계식 스위치</h3> <p>구매처 : <a href="http://www.leopold.co.kr/?doc=cart/item.php&amp;it_id=1285820179">레오폴드</a></p> <p>49.000원</p> <h3>키캡</h3> <p>구매처 : <a href="http://item2.gmarket.co.kr/Item/detailview/Item.aspx?goodscode=814544137">G마켓</a></p> <p>23.000원</p> <h3>하우징</h3> <p>구매처 : <a href="http://hanaacryl.com/">하나아크릴</a></p> <p>24,000원</p> <h3>다이오드</h3> <p>구매처 : <a href="http://www.devicemart.co.kr/25">디바이스마트</a></p> <p>1,300원</p> <p>가격 계 : 123,300원</p> <p>위에 안 쓴 것들.. 예를 들어서 전선, 땜납 같은 것들을 포함하면 총 금액은 13만원 근처가 될 것 같네요.</p> <h2>기타 자료들</h2> <h3>아두이노 소스 코드</h3> <p>아래 코드는 제가 만든 키보드 배열에 맞는 코드입니다. 원하는 배열에 맞춰서 고쳐 쓰세요.</p> <p>그리고 핀 번호도 자신의 배선에 맞춰서 바꿔줘야 하는 거 잊지 맙시다.</p> <p><script src="https://gist.github.com/lazygyu/b2c36bd3bc91353ae7a626092ce55772.js"></script></p> <h3>하우징 도면</h3> <p>일러스트 할 줄 모르는데 대충 그려서 좀 구린데... 참고만 하시고 필요한대로 다시 그리거나 고쳐서 쓰시면 됩니다.</p> <p>그리고 아래 도면대로 하면 중간 판이 너무 얇아서 휘어버리는 수가 있으니까 그 부분은 꼭 신경써야 합니다.</p> <p><a href="https://drive.google.com/file/d/0B5wBxC9a1sQyV2lmYU5tSEl6UHc/view?usp=sharing">다운로드</a></p> <h2>끝</h2> <p>더 쓰고 싶은 내용은 많지만 졸리니까 일단 여기까지.</p> ]]></content:encoded>
<link>https://lazygyu.net/blog/make_a_custom_machanical_keyboard</link>
<category><![CDATA[ 아두이노 ]]></category>
<pubDate>Mon, 15 May 2017 03:58:00 +0900</pubDate>
<guid>https://lazygyu.net/blog/make_a_custom_machanical_keyboard</guid>
</item>
<item>
<title><![CDATA[ Hype Driven Development - 설레발 주도 개발 ]]></title>
<description><![CDATA[ 이 글은 Hype Driven Development 를 번역한 글입니다.  ]]></description>
<content:encoded><![CDATA[ <h1>Hype Driven Development</h1> <h2>설레발 주도 개발</h2> <blockquote><p>이 글은 <a href="https://blog.daftcode.pl/hype-driven-development-3469fc2e9b22">Hype Driven Development</a> 를 번역한 글입니다. 설레발 주도 개발은 임의로 붙인 단어입니다. 더 적절한 단어가 있으면 제안해주세요.</p></blockquote> <p>소프트웨어 개발 팀들은 자주 소프트웨어 구조 설계나 기술 스택에 대해 결정을 내립니다. 제대로 된 연구나 자신들의 프로젝트에 미치게 될 영향에 대한 고려 보다는 잘 알지도 못하는 오지랖, SNS, 혹은 핫하다는 대세에 기반해서요. 저는 이런 경향을 설레발 주도 개발이라고 부릅니다. 그런 것의 해로움을 감지하고 더 전문적인 접근을 선호하는 것은 "견고한 소프트웨어 공학"이라고 부르고요. 이제부터 이것들이 어떻게 작동하고, 대안은 어떤 게 있을지 살펴봅시다.</p> <h2>새로운 기술 - 새로운 희망</h2> <p>혹시 어떤 팀이 가장 최신의, 핫한 기술을 프로젝트에 적용하는 과정을 본 적 있나요? 먼저 누군가가 블로그에서 글을 읽습니다. '이게 트위터에서 유행중이고 우린 방금 이거에 대한 컨퍼런스에서 엄청난 이야기를 나누고 돌아오는 길이야' 조금 뒤, 이 팀은 그 새롭고 빛나는 기술(혹은 소프트웨어 디자인 패러다임)을 사용하기 시작합니다. 하지만 신기술이 약속했던 더 빠른 생산성이나 더 나은 결과물을 얻게 되는 대신 곧 문제에 직면하게 됩니다. 그들의 개발 속도는 느려지고, 의욕은 점점 사라지고, 다음 버전을 내놓는 데에 문제가 생깁니다. 어떤 팀들은 새로운 기능을 배포하기보다는 있는 버그를 고치는 데 급급하게 되기도 하죠. 이 문제들을 모두 해결하는 데에는 늘 '일정이 며칠만 더' 필요합니다.</p> <h2>설레발 주도 개발</h2> <p>설레발 주도 개발(Hype Driven Development - HDD)은 당신의 프로젝트에 다양한 방법으로 영향을 끼칩니다.</p> <ul><li><p><strong>레딧 주도 개발</strong> - 팀, 혹은 개인이 기술적/구조적/설계 결정을 내릴 때 유명한 블로거의 글이나 레딧, 해커뉴스, 블로그, 트위터, 페이스북, 깃헙 그외 뭐든간에 SNS에서 핫한 것에 기반을 두고 선택합니다.</p></li><li><p><strong>컨퍼런스 주도 개발</strong> - 사람들이 컨퍼런스에 참여하고 돌아온 뒤 무슨 일이 벌어지는지 유심히 살펴보세요. 사람들은 뭔가 영감을 받은 상태입니다. 양날의 검이죠. 충분한 고려 없이 새롭고 핫한 라이브러리/프레임워크/구조 설계 관점을 도입하는 것은 요단강 익스프레스의 티켓일 수도 있습니다.</p></li><li><p><strong>목소리 큰 놈 주도 개발</strong> - 어떤 놈이 하루 웬종일 이 프레임워크/라이브러리/기술 에 대해 쉴 새 없이 떠들어댑니다. 물론 그 놈이 딱히 그걸 해 본 경험이 있는 것은 아니지만 귀에 딱지가 앉도록 떠든 결과 팀은 그 프레임워크/라이브러리/기술을 사용하기로 결정합니다.</p></li><li><p><strong>젬/라이브러리/플러그인 주도 개발</strong> - 특히 루비 온 레일즈 커뮤니티에서, 가끔 아주 긴 젬 파일을 보곤 합니다. 그 젬 파일보다 긴 거라곤 오직 그 젬 파일을 로딩하는 데 걸리는 시간 뿐이죠. 이건 레일즈의 모든 문제를 반드시 젬으로만 해결해야 한다는 생각에서 발생하는 현상입니다. 어떤 건 그냥 두어줄만 코드에 추가하면 해결되는 문제인데도요. 하지만 우린 모든 문제를 라이브러리를 추가하거나, 플러그인을 깔거나, 젬을 받거나 프레임워크를 도입해서 해결하려고만 하죠. </p></li><li><p>그리고 설레발 주도 개발만큼이나 유명한 행태에 대해서도 짚고 넘어가야 할 것 같습니다. <strong>지식인 주도 개발</strong> - 개발자들이 스택 오버플로(혹은 그냥 인터넷 아무데서나)에서 제대로 이해하지도 않은 코드를 그냥 복붙해 오는 방법론입니다.</p></li></ul> <h2>HDD 는 팀을 어떻게 스스로 파멸시키는가</h2> <p>설레발의 큰 문제점은 아주 쉽게 나쁜 결정을 내리도록 유도한다는 점입니다. 설계 관점의 결정이건 기술 스택 결정이건 양 쪽 모두 잘못되었을 경우 <strong>팀 하나를 몇 달, 혹은 몇 년 안에 조져버릴 수 있습니다</strong>. 최악의 경우 소프트웨어 엔지니어링에서 벌어질 수 있는 또 다른 아주아주아주 더러운 문제에 맞닿뜨리게 됩니다. <strong>전부 뒤집어 엎고 다시 짜는거죠</strong>. 보통 이런건 망하게 마련입니다.</p> <p><strong>모든 악의 근원은 소셜 미디어인 것 같습니다</strong>. 새로운 아이디어가 테스트가 끝나기도 전에 잽싸게 전파되는 곳이죠. 사람들이 그것의 장단점에 대해 이해하는 것보다도 훨씬 빠르게 말이죠.</p> <h2>설레발 해부</h2> <p>대부분의 설레발은 비슷한 구조를 가지고 있습니다.</p> <p><img alt="" src="https://lazygyu.net/images/blog/1-_ZxvohNQOdpxeQUFDtzz7Q.png_1490772674.png"/></p> <h3><strong>1단계:</strong> 진짜 문제와 해결책</h3> <p>그들은 문제가 있는 회사에 있습니다. 회사의 한 팀이 이 문제에 대한 해결책은 현재의 기술 스택이나 구조를 넘어서는 일이라고 결정하죠. 회사는 새로운 프레임워크나 라이브러리, 혹은 패러다임을 만들고 곧 그 문제는 해결됩니다.</p> <h3><strong>2단계:</strong> 발표, 자랑질과 키워드</h3> <p>이 팀은 넘나 신나서 그들의 결과물을 세상에 보여주고, 블로그에 포스트를 싸지르고 컨퍼런스에 가서 약을 팝니다. 보통 그런 문제들은 딱히 중요한 것이 아니기 때문에, 그들은 별 것도 아닌 문제에 대한 인상적인 해결책을 가지고 뽐냅니다. 사람들은 이 새로운 기술에 흥분합니다. 걸림돌은 오직 이 문제가 뭔지를 정확히 이해하고 이 솔루션을 자세히 파악한 사람입니다. 이건 결국 별 것도 아닌 문제에 대한 별 것도 아닌 해결책입니다. 이를 눈치챈 사람은 트위터나 채팅, 블로그 혹은 그 외 다른 방법들을 써서 이 점을 설명하려 시도합니다. 하지만 소셜 미디어, 블로그 포스트, 컨퍼런스의 짤막 세션들 속에서 이런 이야기는 묻히고 맙니다.</p> <h3><strong>3단계:</strong> 빠돌이 탄생</h3> <p>모든 설레발 주도 개발자들이 블로그 글을 읽고 컨퍼런스에 참여했습니다. 곧 세계 전역의 많은 팀들이 새로운 기술을 사용하기 시작합니다. 묻혀버린 메시지 때문에 그 팀들 중 몇몇은 이게 그 팀의 실제적인 문제를 해결해주지 않는데도 불구하고 서둘러서 도입을 결정합니다. 그런 팀은 아직 이 신기술이 자신들의 문제를 해결하는데 도움이 될 거란 기대를 가지고 있습니다.</p> <p><img alt="" src="https://lazygyu.net/images/blog/0-HrGXvrYBMM5W1Jg5-.png_1490772684.png"/></p> <h3><strong>4단계:</strong> 실망</h3> <p>스프린트가 계속되면서, 이 신기술은 사람들이 기대했던 것 만큼 팀에 도움이 되질 않고 오히려 더 일을 늘리기만 합니다. 더 많은 학습이 필요하고 코드는 수없이 재작성됩니다. 팀은 지치고 관리자는 빡칩니다. 사람들은 속았다는 느낌을 받게 됩니다.</p> <h3><strong>5단계:</strong> 현실 인식</h3> <p>마침내 팀은 뒤를 돌아보고 새로운 기술 도입에 따른 대가가 무엇이었는지, 이게 대체 뭘 위한 기술이었는지를 깨닫습니다. 그들은 조금 현명해집니다. 다음번 설레발이 닥쳐오기 전까지는요.</p> <h2>설레발의 예제:</h2> <p>설레발의 몇몇 실례들을 살펴보고 어떤 식으로 진행되는지를 확인해봅시다.</p> <h3>예제 1 : 리액트</h3> <p><strong>1단계:</strong> 페이스북이 문제에 직면합니다. 페이스북과 같은 복잡한 웹 앱을 만들다 보면 아주 복잡한 상태 관리 이벤트로 정신이 넘나 사납고 어플리케이션 상태가 어떻게 되어가고 있는지를 추적하기가 어렵습니다.</p> <p><strong>2단계:</strong> 페이스북이 함수형, 가상 DOM, 컴포넌트 같은 몇몇 단어들로 새로운 패러다임 약을 팔기 시작합니다. </p> <p><strong>3단계:</strong> 빠돌이: 페이스북이 새 시대의 프론트엔드 프레임워크를 만들었다! 이제부터 다함께 모든 것들을 리액트로 다시 만들자고!</p> <p><strong>4단계:</strong> 아주 많은 일들이 진행되지만 업계에 별다른 성과는 나오지 않습니다.</p> <p><strong>5단계:</strong> 리액트는 실시간 알림이 아주 많은 단일 페이지 웹 앱을 만드는데에 아주 훌륭하지만, 그보다 간단한 웹앱을 만드는 데에는 딱히 필요 없는 물건이었습니다.</p> <h3>예제 2 : TDD는 죽었다 by DHH</h3> <p><strong>1단계:</strong> 데이빗(David Heinemeier Hansson, DHH : 루비온레일즈 프레임워크 개발자)은 레일즈가 객체지향에 적합한 구조가 아니라서 레일즈로 TDD를 진행하기가 어렵다는 걸 깨닫습니다. 따라서 실용적인 관점에서 테스트 작성을 때려칩니다.</p> <p><strong>2단계:</strong> 데이빗의 블로그 글과 컨퍼런스 발표에서 설레발이 시작됩니다. 키워드는 'TDD 쥬금'입니다.</p> <p><strong>3단계:</strong> 테스트를 건너뛰자! 우리 존잘님이 그러셨어! 우린 이제 더이상 테스트 같은거 작성 안할거야! 껍데기는 가라!</p> <p><strong>4단계:</strong> 기다려! 일이 줄어들긴 했지만.. 우리는 버그덩어리 코드를 만들었어</p> <p><strong>5단계:</strong> "TDD는 죽거나 살아있거나 한 게 아님. TDD는 API 변경이나 초보자의 미숙한 기술이나 기존의 설계 등에 대한 리스크를 포함한 기회비용을 대표함." - 켄트 벡</p> <h3>예제3 : 마이크로서비스</h3> <p><strong>1단계:</strong> 커다란 단일 어플리케이션은 확장이 어렵습니다. 이걸 여러 서비스로 나눠버리면 초당 요청 처리수의 관점에서나 여러개의 팀의 협업 관점에서나 확장하기 쉬워집니다.</p> <p><strong>2단계:</strong> 설레발 키워드 : 확장성, 느슨한 의존성, 단일 어플리케이션</p> <p><strong>3단계:</strong> 뭐든지 다 서비스로 재작성하자! 우리 코드가 '스파게티 코드'인 건 다 단일 어플리케이션 구조 때문이야! 모든걸 마이크로 서비스로 다시 만들어야해!</p> <p><strong>4단계:</strong> 헐랭! 앱 개발이 넘나 느리고 배포가 엿같은데다 여러 시스템에서 버그를 추적하는게 넘나 빡세..</p> <p><strong>5단계:</strong> 마이크로서비스는 팀에 아주 많은 개발 스킬을 요구하고, 대부분의 경우는 마이크로서비스를 도입하지 않고도 시스템과 팀에 대한 적절한 투자를 통해 확장성을 해결할 수 있습니다. 심각한 확장성 이슈를 맞닿뜨리기 전까지는 마이크로서비스도입은 낭비입니다. 마이크로 서비스는 추출되는 것이지 작성되는 것이 아닙니다. 마이크로 서비스를 사용하기 위해서는 최소한 그정도 수준이 되어야 합니다.</p> <h3>예제 4 : NoSQL</h3> <p><strong>1단계:</strong> SQL 데이타베이스들은 넘나 큰 공간을 요구하고 구조화되지 않은 데이터를 처리하기가 어렵습니다. 세계 곳곳에서 새로운 세대의 데이터베이스를 개발하기 시작합니다.</p> <p><strong>2단계:</strong> 설레발 키워드 : 확장성, 빅데이터, 고성능</p> <p><strong>3단계:</strong> 우리의 데이터베이스는 넘나 느리고 규모도 충분히 크지 않아! 우린 NoSQL이 필요해!</p> <p><strong>4단계:</strong> 테이블 조인이 필요한가요? 그런거 없습니다. 단순한 SQL 조작도 커다란 도전이 되어 버립니다. 개발 속도는 점점 느려지고 핵심적인 문제들은 해결되지 않습니다.</p> <p><strong>5단계:</strong> NoSQL 은 아주 특정한 문제들에 대한 해법입니다(아주 많은 양의 데이터, 구조화 되지 않은 데이터, 혹은 아주 많은 처리량 등). SQL 은 실제로 아주 훌륭한 도구이며, 적절하게 사용하기만 한다면 많은 양의 데이터와 높은 처리량을 감당할 수 있습니다. NoSQL 이 반드시 필요한 경우는 2016년 현재까지는 아주 드뭅니다.</p> <h3>예제 5 : 엘릭서와 피닉스(혹은 자신이 좋아하는 언어/프레임워크 짝을 넣어도 됩니다)</h3> <p><strong>1단계:</strong> 루비 온 레일즈 같은 웹 프레임워크는 고성능 어플리케이션, 분산처리, 웹소켓 같은 것들에 맞지 않아.</p> <p><strong>2단계:</strong> 설레발 키워드 : 확장성, 고성능, 분산, 결함 내구도</p> <p><strong>3단계:</strong> 오매 시봉탱, 우리의 어플리케이션은 느리고 우리 채팅은 확장성이 없어!</p> <p><strong>4단계:</strong> 헐, 함수형 프로그램이랑 분산 처리 배우는거 생각보다 빡센데. 이제 우린 그냥 느린 게 아니고 개느려...</p> <p><strong>5단계:</strong> 엘릭서와 피닉스는 훌륭한 프레임워크입니다만 배우는 데 많은 노력이 필요합니다. 길게 보면 언젠가 특별히 고성능의 앱을 만들어야 할 때는 도움이 될 겁니다.</p> <p>목록은 끝도 없이 늘어날 수 있습니다. 컴퓨터 엔지니어링 분야에서 공통적으로 아주 많은 설레발이 판치고 있습니다. 자바스크립트 계에서는 새로운 프레임워크가 매일 쏟아져 나옵니다. Node.js (키워드 : 이벤트 프로그래밍), 리액티브 프로그래밍, Meteor.js(키워드: 공유 상태), 프론트엔드 MVC, React.js. 걍 아무 이름이나 붙여보세요. 소프트웨어 공학에서도 새로운 구조들이 탄생합니다. 도메인 주도 개발, 헥사곤, DCI. 어떤 설레발을 제일 좋아하시나요?</p> <h2>우수 사례</h2> <p>그래서, 우리가 인터넷이나 다른 사람들의 의견에 의존해선 안된다면, 어떻게 하면 똘똘한 결정을 할 수 있을까요? 아래에 몇몇 좋은 예시들이 있습니다.</p> <h3>결정하기 전에 연구하고 테스트하기:</h3> <ul><li><p><strong>스파이크</strong> - 블로그가 아니라 경험을 통해 기술을 배우세요. 결정을 내리기 전에 하루 이틀 정도를 투자해 새로운 기술로 새로운 기능의 프로토타입을 만들어보세요. 팀이 이 기술의 장점과 단점을 분석하게 하세요. 경쟁 관계에 있는 몇몇 기술을 골라서 팀 내에서 각각의 기술로 프로토타입을 만들어 보도록 하세요.</p></li><li><p><strong>해커톤</strong> - 해커톤은 서로 다른 기술의 장단점에 대한 팀의 인식을 만들어가는 좋은 방법입니다. 하루 이틀 정도를 들여 전체 팀이 떠오르는 매력적인 신기술들을 사용해 보게 하세요. 이를 통해 팀은 자신들의 경험에 기반한 똘똘한 결정을 내릴 수 있게 됩니다.</p></li></ul> <h3>그럼 대체 언제 적용할까?</h3> <ul><li>원론적인 관점에서, <strong>투자 대비 아주 큰 대가가 기대될 때</strong> 입니다. 대부분의 기술들은 어떤 특정한 문제를 해결하기 위해 만들어졌습니다. 그 특정한 문제를 가지고 있나요? 그게 큰 문제인가요? 이 기술의 도입이 엄청나게 많은 시간을 줄여주나요? 이 기술을 사용해서 얻는 것이 기술을 배우는 데 드는 비용과 기존 코드의 재작성에 드는 비용을 합친 것보다 더 큰가요? 혹시 개발이 두 배로 늦어진다면? 혹시 네 배라면? 그래도 여전히 그만큼 가치가 있나요?</li><li><strong>훌륭한 팀은 더 많은 것이 가능합니다</strong>. 어떤 팀들은 누구보다 빠르게 남들과는 다르게 새로운 가치를 받아들입니다. 그들은 더 쉽게 뭔가를 하는 데 금방 질립니다. 이런 팀들에게는 새로운 기술을 더 자주 소개할 수 있겠죠. 그렇다고 그게 해커톤이나 스파이크를 안 해도 된다는 뜻은 아닙니다. 다른 경우, 혹시 팀이 새로운 가치를 받아들이는 데 어려움을 겪고 있다면 좀 더 주의깊게 접근할 필요가 있습니다.</li></ul> <h3>올바른 사람을 고용하세요</h3> <ul><li>강력한 기술적 배경은 좋은 신호입니다. 다양한 패러다임을 알고, 프로그래밍 이론을 이해하고(알고리즘, 병렬처리 등), 좋은 엔지니어링 문화를 가진 사람들은 설레발에 영향을 덜 받습니다.</li><li>경험 - 설레발은 젊은 개발자에게 더 잘 먹힙니다. 세월이 흐르면 사람들은 많은 기술들을 보고 많은 문제들을 만나면서 기술을 선택하는 데 있어서 더 균형잡힌 시각을 가지게 됩니다.</li></ul> <p><img alt="" src="https://lazygyu.net/images/blog/0-wWYk3YFNmHw1P7ov-.png_1490772692.png"/></p> ]]></content:encoded>
<link>https://lazygyu.net/blog/hype_driven_development</link>
<category><![CDATA[ 번역 ]]></category>
<pubDate>Wed, 29 Mar 2017 16:35:00 +0900</pubDate>
<guid>https://lazygyu.net/blog/hype_driven_development</guid>
</item>
<item>
<title><![CDATA[ HTML5 미니게임 개발 튜토리얼 7 ]]></title>
<description><![CDATA[ 다들 7회동안 수고 많았고 나중에 웃으면서 보자! 모두모두 앗녕!! 은 난 다신 이런 긴 글 쓰지 말아야지.... ]]></description>
<content:encoded><![CDATA[ <h1>HTML5 미니게임 개발 튜토리얼</h1>
<p><a href='https://lazygyu.net/blog/html5_js_minigame_tutorial6'>이전 글 : Swing my baby 를 통해 보는 HTML5 게임 개발(6)</a></p>
<p>현재 글 : Swing my baby 를 통해 보는 HTML5 게임 개발(7)</p>
<p><img alt='' src='https://lazygyu.net/images/blog/title.png_1490546382.png' /></p>
<p>아 대체 언제 끝나는가.... 쓰는 나도 슬슬 지겨워지는 시리즈지만 갈 데 까지 가보자... 사실 지난 편을 쓰고 나서 다른 일들 때문에 까먹고 있다가 이번 편이 늦어지고 말았다 ㅠㅠ 늦어진 만큼 내용을 꾹꾹 눌러 담아서 이번 편에는 마무리를 지어보자.</p>
<h2>개발 과정</h2>
<h3>아이템 상점</h3>
<p>코인을 모았으면 써야겠지? 이 코인을 어디다 쓰느냐, 바로 아이템 상점이다!</p>
<p>아이템 상점의 기획은 이렇다.</p>
<ul>
    <li>모은 코인으로 아이템을 구매할 수 있다.</li>
    <li>아이템은 점프 물약과 마나 물약 두 가지다.</li>
    <li>아이템들은 구매할 때마다 가격이 올라간다.</li>
    <li>새로운 게임을 시작하면 가격은 리셋된다.</li>
    <li>아이템은 게임 도중 s, d 키로 구매할 수 있다.</li>
    <li>아이템을 구매할 수 있을 만큼의 코인이 모이면 화면에 구매 가능하다는 게 표시되어야 한다.</li>
</ul>
<p>여기서 이 아이템 구매 UI 를 표시하는 주체가 누군지가 미묘해진다. 개념상 <code>GameUI</code>가 그려주는 게 맞는 거 같기도 하고, 아이템 상점이 <code>GameObject</code>를 상속한다면 아이템 상점 자체의 <code>render</code>이벤트에서 그려주는 게 맞을 거 같기도 하고 아리까리하다. 뭐 각자의 취향이 있겠지만 기왕 이렇게 된거 소스 길어지는 것도 귀찮으니 아이템 상점은 별도 클래스로 빼지 말고 걍 데이터는 <code>GameScene</code>이 들고 있고 그려주는 건 <code>GameUI</code>가 하도록 해보자. 이런 더러운 구조가 싫은 분들은 그냥 아이템 상점 클래스를 따로 만들어도 무방하다.</p>
<p>우선 <code>GameScene</code>의 <code>constructor</code>와 <code>init</code>에 아래와 같이 아이템들의 가격 초기값을 설정하는 코드를 넣고</p>
<pre><code>this.itemPrice = [500, 800]; // 마나포션 500, 점프포션 800</code></pre>
<p><code>GameUI.render</code>에 아래처럼 각 아이템 아이콘을 그려주자.</p>
<pre><code>
// 아이템 상점 표시 
// 마나 포션 
if (this.character.money >= this.parent.itemPrice[0]) {
    ctx.drawImage(this.img, 160, 151, 50, 51, 200, 540 - 55, 50, 51);
} else {
    ctx.drawImage(this.img, 210, 151, 50, 51, 200, 540 - 55, 50, 51);
}
// 점프 포션 
if (this.character.money >= this.parent.itemPrice[1]) {
    ctx.drawImage(this.img, 160, 202, 50, 51, 255, 540 - 55, 50, 51);
} else {
    ctx.drawImage(this.img, 210, 202, 50, 51, 255, 540 - 55, 50, 51);
}
// 아이템 가격 표시 
ctx.font = '9px verdana';
ctx.textAlign = 'left';
ctx.fillStyle = 'white';
ctx.fillText(this.parent.itemPrice[0], 215, 540 - 7);
ctx.fillText(this.parent.itemPrice[1], 270, 540 - 7);
</code></pre>
<p>아이템 가격보다 현재 소지금이 많은 경우에는 컬러 이미지, 그 외에는 흑백 이미지를 그려주고 적절한 위치에 가격을 써주는 코드다. 여기까지 하고 게임을 실행해보면 화면 아래쪽에 아이템 상점 버튼이 표시되는 것을 알 수 있다.</p>
<p>근데 표시만 해주면 뭐하나? 아이템을 살 수 있어야지! 아이템을 살 때는 어떤 처리가 필요한지 우선 생각해보자.</p>
<ol>
    <li>유저가 아이템 구매 버튼을 누른다.</li>
    <li>현재 소지금이 아이템 가격보다 많거나 같은지 확인</li>
    <li>현재 소지금을 아이템 가격만큼 깐다.</li>
    <li>아이템 가격을 올린다.</li>
    <li>캐릭터에 아이템 효과를 적용한다.</li>
</ol>
<p>그럼 <code>GameScene.update</code>에 이 내용을 적용해보자. 기존에 캐릭터의 점프를 처리하던 <code>if(key === 32)</code> 블록에 <code>elseif</code>로 붙이도록 하자.</p>
<pre><code>
else if (key === 83 || key == 68) { // S , D 
    let itemNo = (key === 83) ? 0 : 1; // s를 누르면 0번, 아니면 1번 
    if (this.character.money >= this.itemPrice[itemNo]) { // 돈이 있나? 
        this.character.money -= this.itemPrice[itemNo]; // 소지금을 까고 
        this.itemPrice[itemNo] += 500; // 아이템 가격을 올리고 
        this.character.gotItem((itemNo == 0) ? "mana" : "jump"); // 아이템 효과 적용
    }
}
</code></pre>
<p>아이템 상점에서 파는 아이템의 갯수가 늘어나면 조금 더 처리가 늘어나야하겠지만, 현재로선 이걸로 충분하다. 이제 게임을 실행해보면 아이템을 구매하면서 훨씬 수월해진 게임 진행을 만끽할 수 있다! 대충 이정도면 게임 진행 자체에 필요한 요소는 거의 다 만들어진 것 같다.</p>
<h3>캐릭터의 충돌 처리</h3>
<p>게임을 자꾸 자꾸 하다 보면 캐릭터가 지면과 닿아서 죽는 시점이 조금 이상하다는 것을 느낄 수 있을것이다. 왜냐면 캐릭터가 줄에 매달려 있을 때 충돌처리의 중심과 캐릭터의 중심이 다른 곳에 있기 때문이다. 우리는 캐릭터가 줄에 매달린 동안 손의 위치를 기준으로 캐릭터의 좌표를 계산하고 있는데, 이렇게 해서 줄과 캐릭터의 손 위치를 정확히 맞추기는 쉬워졌지만 대신에 손을 중심으로 한 원을 가지고 캐릭터의 충돌을 체크하기 때문에 실제 캐릭터의 몸통과는 동떨어진 충돌처리가 이루어지기 때문이다. 이걸 보정해주도록 하자.</p>
<p><img alt='' src='https://lazygyu.net/images/blog/collision_gap.png_1490546403.png' /></p>
<p>먼저 캐릭터에 실제 충돌처리를 위한 좌표를 얻어오는 부분을 추가하자.</p>
<pre><code>
get collisionCheckPosition() {
    let frame = this.animations[this.currentAnimation].current;
    return {
        x: this.x - (frame.ox - (frame.sw / 2)),
        y: this.y - (frame.oy - (frame.sh / 2))
    };
}
</code></pre>
<p>그리고 <code>Terrain</code>에서 캐릭터와 충돌체크하는 부분에서 그냥 <code>character</code>대신 <code>character.collisionCheckPosition</code>을 사용하도록 수정하면 된다. 아래와 같이 바꿔주면 OK</p>
<pre><code>
isHit(character) {
    let firstPoint = {
        x: this.points[0].x,
        y: 540
    };
    let lastPoint = firstPoint;
    let hit = false;
    let chPos = character.collisionCheckPosition; // 캐릭터의 실제 좌표 대신 이걸 쓰자 
    this.points.forEach((pt) =&gt; {
        if (Math.distanceToLine(chPos, [lastPoint, pt]) &lt; character.radius) { // 여기랑 
            hit = true;
            return false;
        }
        lastPoint = pt;
    });
    if (hit) return true;
    lastPoint = firstPoint;
    let count = 0,
        cur = 1;
    while (lastPoint.x &lt; chPos.x) {
        if (Math.isCross(chPos, [lastPoint, this.points[cur]])) count++; 
	// 여기에
        lastPoint = this.points[cur];
        cur++;
    }
    if (count % 2 == 0) return false;
    return true;
}
</code></pre>
<p>이제 캐릭터가 지형에 깔끔하게 닿았을 때만 부딪히는 걸 확인할 수 있다. 좋아좋아! 이제 게임 외적인 부분을 다듬도록 하자.</p>
<h3>게임 상태 처리</h3>
<p>우리가 지금까지 만들어온 건 게임 진행중인 상태의 처리들이다. <code>GameScene</code>에서 처리해줘야 할 상태는 크게 두 가지가 있다. 게임 진행중인 상태와 게임 종료 상태다. 쉽게 말해서 캐릭터가 살아서 진행하는 상태와 캐릭터가 죽어있는 상태라고 하면 되겠지? 지난 시간에 캐릭터가 죽었을 경우를 대비해서 <code>update</code>메소드 전체를 <code>if</code>문으로 감싸준 게 기억난다면 대충 어떤 느낌인지 알 수 있을것이다.</p>
<h4>게임 오버 상태</h4>
<p>게임오버 상태에서 해줘야 하는 것들이 뭐가 있는지 우선 생각해보자.</p>
<ul>
    <li>화면에 게임 오버 상태라는 걸 표시해줘야 한다.</li>
    <li>이번 판에 얻은 점수 및 그간의 최고 점수를 표시해줘야 한다.</li>
    <li>가능하면 각종 다른 정보들 - 예를 들어 이번 판에 얻은 코인 수나 사용한 코인 액수, 먹은 아이템 수 같은 것을 보여줘도 좋겠지?</li>
    <li>랭킹이 있다면 랭킹도 보여줘야 한다.</li>
    <li>스페이스바를 누르면 재시작</li>
</ul>
<p>요 녀석들을 어디서 처리하면 좋을까? 게임하고 별 상관 없으니까 얘들도 <code>UI</code>에서 그려주도록 하자. 일단 게임중에는 화면상의 UI 요소들이 페이드아웃되도록 해볼까?</p>
<p>처리는 되도록 시간을 기준으로 해야 한다. 그러므로 게임오버 화면을 그릴 때도 게임오버가 된 시점부터의 경과 시간을 가지고 이런저런 처리를 해 주는 게 좋겠지? 전체적인 경과 시간을 나타내는 <code>GameScene.elapsed</code>를 게임오버시에 리셋하는 코드를 먼저 넣자. 그리고 <code>this.elapsed += timeDelta</code>는 <code>update</code> 메소드의 맨 첫 부분으로 옮겨주자.</p>
<pre><code>
// GameScene.update 에서 this.state = 1; 아래에 추가 
this.elapsed = 0;
</code></pre>
<p>그리고 <code>UI.render</code>에 아래 부분을 추가해주자.</p>
<pre><code>
//UI.render 
render(ctx) {
        ctx.save();
        ctx.translate(this.parent.cameraX - 200, 0);
        if (this.parent.state == 1) {
            ctx.globalAlpha = Math.max(0, 1 - this.parent.elapsed); // 1초간 페이드 아웃 
        }
        // ...하략...
</code></pre>
<p>이제 죽으면 화면상의 UI 요소들이 슬며~~~시 사라지게 된다. 근데 사라지기만 하면 안되겠지? <code>ctx.restore()</code> 바로 위쪽에 이제 게임오버시의 요소들을 그리는 코드를 추가해보도록 하자.</p>
<p>우선 게임오버시에 사용될 스프라이트를 <code>UI.constructor</code>에 추가하자.</p>
<pre><code>
//UI.constructor 
this.gameover = new Sprite(this.img, 0, 400, 348, 81, 174, 0);
</code></pre>
<p>'야이 못된놈아 다른 것들은 그냥 그려놓고 왜 게임오버는 스프라이트로 만드냐' 라고 항의한다면 사실 할 말은 없다. 그냥 만든거...긴 하지만 부끄러우니까 가운데 정렬 하기 쉽도록 스프라이트로 만든거라고 뻥을 쳐두도록 하자.</p>
<p>여튼 이걸 다른 UI 요소들이 슬며시 사라진것과는 반대로 슬며~시 나타나도록 만들어보자.</p>
<pre><code>
//UI.render 맨 아래쪽 ctx.restore(); 바로 위에 추가 
if (this.parent.state === 1) {
    ctx.globalAlpha = Math.min(1, this.parent.elapsed);
    this.gameover.draw(ctx, 540 / 2, 60);
}
</code></pre>
<p>이정도면 넘나 스무스하고 좋긴 한데 뭔가 허전하기도 하다. 우선 점수까지 화면에서 굳이 사라질 필요는 없을 것 같다. 점수를 그려주는 부분을 페이드아웃보다 전으로 옮겨서 게임오버 화면에서도 점수는 나오도록 하자. 그리고 또 뭔가 추가해줄 효과는 없을까? 고전 애니메이션들이 그랬던 것처럼 게임오버가 돠면 캐릭터쪽으로 점점 둥글게 좁혀지는 화면을 만들어보자. 이 효과는 <code>UI</code>를 제외한 다른 오브젝트들을 그릴 때만 적용해야 하므로 <code>GameScene.render</code>를 고쳐주도록 하자.</p>
<pre><code>
//GameScene.render 전체는 이렇게 된다
render(ctx) {
    ctx.save();
    ctx.translate(-this.cameraX + 200, 0);
    if (this.state === 1) { // 게임오버 상태일 때 
        // 경과 시간에 비례해 작아지는 반경을 구해서
        let radius = (1.0 - Math.min(this.elapsed, 0.5) * 2) * 540;
        ctx.save(); // 캐릭터 위치에서 해당 반경만큼의 원을 그리고
        ctx.beginPath();
        ctx.arc(this.character.x, this.character.y, this.character.radius * 2 + radius, 0, Math.PI * 2);
        ctx.clip(); // 그 안쪽에만 그림이 그려지도록 제한한 뒤에 
        // UI 를 제외한 다른 자식들을 그려준다. 
        this.background.render(ctx);
        this.terrain.render(ctx);
        this.itemManager.render(ctx);
        this.character.render(ctx);
        ctx.restore(); // 제한을 해제하고 
        this.ui.render(ctx); // UI를 그려주면 끗 
    } else { // 게임중엔 걍 원래대로 다 그려버리면 된다.
        super.render(ctx);
    }
    ctx.restore();
}
</code></pre>
<p><img alt='' src='https://lazygyu.net/images/blog/gameover_scene1.png_1490546443.png' /></p>
<p>쨘! 이걸로 이제 드디어 플레이에 손색이 없는 게임이 되었다! 게임오버 화면에 다른 것들을 각자 이것저것 그려보면서 잠시 게임을 즐겨보도록 하자.</p>
<p>이후에 나올 <strong>페이스북 랭킹</strong> 섹션에서 랭킹 화면을 그려보게 될테니 그 내용은 나중에..</p>
<h3>기타 잡일</h3>
<h4>어차피 다 같이 쓰는 이미진데 그냥 하나를 돌려쓰자.</h4>
<p>우리는 현재 클래스 생성자마다 필요한 이미지를 각자 만들어서 쓰고 있다. 다 똑같은 이미지인데 굳이 이렇게 해봤자 메모리랑 처리 시간만 좀먹을 뿐 아무 이득이 없는데 이럴 필요가 있을까? 이러지 말고 같은 이미지는 하나만 선언해서 그걸 갖다쓰도록 하자. 배경에 쓰이는 이미지들은 어차피 거기 한 군데서만 쓰이니 내버려두고, 계속 쓰이는 스프라이트 이미지를 맨 위에 선언해주자.</p>
<pre><code>const SpriteImage = new Image(); SpriteImage.src = '스프라이트 이미지 주소';</code></pre>
<p>그리고 각 클래스 생성자들에서 <code>this.img = new Image(); this.img.src=...;</code> 으로 되어있는 부분들을 <code>this.img = SpriteImage;</code> 로 바꿔주면 깔끔!</p>
<h4>캐릭터의 채찍 디테일</h4>
<p>여기서 사용된 캐릭터는 던전앤파이터의 "검마"라는 캐릭터인데, 이 캐릭터는 채찍 형태로 늘어나는 "사복검"이라는 무기를 사용한다. 이 게임도 설정상으로 그 사복검을 휘둘러서 매달리는 거기 때문에 검날의 모양이 있어야 한다. 요렇게..</p>
<p><img alt='' src='https://lazygyu.net/images/blog/%EB%94%94%EC%96%B4%EC%82%AC%EC%9D%B4%EB%93%9Cjpg.jpg_1490546535.jpg' /> </p>
<p>(상기 이미지의 저작권은 물론 네오플에 있음)</p>
<p>사실은 이미 스프라이트 정의에도 저 칼날조각 아이콘이 있으니까 우리는 그걸 줄 따라 그려주도록 하자. 이 때 주의할 점은, 줄이 길어진다고 칼날 갯수가 늘어나거나 하면 어색하다는 거다! 그러니까 우리는 일정 갯수의 칼날을 줄 길이에 따라 동일한 간격으로 그려주면 되겠다. <code>Character.render</code>를 매만져보자.</p>
<p><img alt='' src='https://lazygyu.net/images/blog/length_independent.png_1490546552.png' /></p>
<pre><code>
// Chrarcter.render 의 if( this.pivot !== null ) 블록 안에 넣어주자 
// 칼날 그리기 
let tPt = {
    x: this.x,
    y: this.y
}; //시작점 
let target = {
    x: this.pivot.x,
    y: this.pivot.y
}; //목표점 
let ang = Math.atan2(target.y - tPt.y, target.x - tPt.x); // 각도를 구하자 
let dist = this.pLen / 12; // 칼날 갯수만큼으로 나눠서 각 칼날의 간격을 구한다 
let bladeAngle = -ang - Math.PI / 2;
for (let i = 0; i &lt; 12; i++) { //칼날은 열두개 
    this.spriteSheet.get(14).draw(ctx, tPt.x, tPt.y, {
        rotate: bladeAngle
    }); // 각도에 맞춰서 그리고
    tPt = Math.getPoint(tPt, ang, dist); // 간격만큼 이동 
}
</code></pre>
<p>해주는 김에 기존에 퍼런 색이었던 줄 색도 <code>red</code>로 바꿔주도록 하자.</p>
<h4>포커스를 잃었을 때는 게임을 일시정지하기</h4>
<p>개발하면서 잠깐 딴짓하다가 오면 게임이 아주 난리가 나있는 걸 계속 봐왔을 것이다. 백그라운드에서 화면이 그려지지 않을 때는 <code>requestAnimationFrame</code>이 호출되지 않으면서 <code>deltaTime</code>이 미친듯이 올라가기 때문...이지만 그딴 거 상세히 알아봤자 머리만 아프니까 우리는 유저가 다른 창으로 포커스를 옮겼을 경우 그냥 게임을 일시정지시키도록 하자.</p>
<p>키보드 이벤트 바인딩할 때 해서 알고 있겠지만 <code>Game</code>객체에서 이벤트 바인딩을 처리하면 된다. </p>
<p>먼저 이벤트 핸들러들을 만들어주자... 별건 없지만.</p>
<pre><code>// Game 에 아래 메소드들을 추가 blurHandler(e){ this.paused = true; } focusHandler(e){ this.now = this.last = performance.now(); // 일시 정지된 동안의 시간 경과를 무시하도록 this.paused = false; }</code></pre>
<p>위 핸들러들이 조작하는 대상인 <code>this.pause</code>도 생성자에서 선언해주고 핸들러들도 이벤트에 바인딩 해주자.</p>
<pre><code>
// Game.constructor 에 추가 
this.paused = false; 
// 키보드 이벤트처럼 this 를 바인드해서 넘기자
window.addEventListener('focus', this.focusHandler.bind(this), false);
window.addEventListener('blur', this.blurHandler.bind(this), false);
</code></pre>
<p>그리고 일시정지가 효과를 발휘하도록 <code>update</code> 메소드를 고쳐보자</p>
<pre><code>
// Game.update 전체 내용은 이제 아래와 같을 것이다
update() {
    // 일시정지된 동안은 시간이 흐르지 않게 해주자. 사실 안 그래도 상관은 없지만..
    if (!this.paused) {
        this.last = this.now;
        this.now = performance.now();
        this.timeDelta = (this.now - this.last) / 1000;
        this.elapsed += this.timeDelta;
    }
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    if (this.scenes.length > 0) {
        // 일시정지중이면 씬의 update 호출을 하지 말자.
        if (!this.paused) this.scenes.last().update(this.timeDelta, this.key);
        this.scenes.last().render(this.ctx);
    }
    this.key = null;
    requestAnimationFrame(this.update.bind(this));
}
</code></pre>
<p>시간 계산 부분을 감싼 <code>if</code>문은 실제로는 없어도 동작에 별 변화가 없다. 왜냐면 일시정지된 동안 업데이트를 호출하지 않기 때문이다. 다만 혹시 나중에 <code>elapsed</code>를 쓸 일이 있게 된다면 일시정지된 시간까지 합산되기 때문에 그 점을 생각해서 막아뒀을 뿐..</p>
<h3>음소거 버튼</h3>
<p>우리가 힘들게 넣은 소리들을 또 누군가는 듣기 싫어할 수도 있다. 소리를 껐다 켰다 할 수 있도록 음소거 버튼을 만들어보자.</p>
<p>우선 <code>UI</code>에서 버튼을 표시해주도록 하자.</p>
<p>일단 생성자에서 버튼 스프라이트를 정의하고</p>
<pre><code>
//UI.constructor에 추가 
this.sounds = { 
    on: new Sprite(this.img, 412, 310, 49, 49, 0, 0),
    off: new Sprite(this.img, 462, 410, 49, 49, 0, 0) 
}
</code></pre>
<p>그림으로 그려주면 된다</p>
<pre><code>
//UI.render 에 추가 
// 소리 온/오프 표시 
this.sounds[ ( this.parent.soundManager.enable ? "on":"off" ) ].draw(ctx, 540 - 54, 5);
</code></pre>
<p>그럼 이제 이 버튼을 어떻게 동작시킬까? 버튼이니까 당연히 클릭을 할 수 있게 해줘야 할텐데... 우리는 여지껏 마우스와 관련한 내용을 하나도 안 만들었으니 이제부터 꼴랑 이 버튼 하나를 위해 마우스 관련 처리를 해보도록 하자...ㅠㅠ</p>
<p>원래 클릭 가능한 요소가 많이 들어가는 게임이라면 각 오브젝트마다 범위를 가지고 마우스 클릭시에 해당 좌표의 오브젝트에게 클릭되었다는 신호를 보내고.....등의 표준적인 마우스 이벤트 핸들링 시스템을 만들어야 하겠지만 우리 게임은 그딴거 없다. 키보드 신호와 비슷하게 이벤트를 받아서 클릭 위치를 <code>update</code>에서 처리해주도록 하자.</p>
<p>지난번에 만든 키보드 핸들러와 비슷하니 구구절절 설명은 하지 않도록 하자....키보드 핸들러때도 왠지 별 설명은 안했던 것 같지만 그게 뭐 중요한가 헤헿 기분탓이겠지..</p>
<pre><code>
// Game.constructor 에 추가 
this.mouse = null; // 마우스 클릭 정보를 담을 변수 
/// 클릭 이벤트 핸들러를 등록하자 
/// 클릭 외에 다른 마우스 이벤트가 필요해질수도 있으니 아래처럼 클릭이라고 명시해줬지만 
/// 아마 이 게임에서는 별로 쓸 일은 없을 것 같다.
this.canvas.addEventListener('click', this.mouseHandler.bind(this, 'click'), false); // 위에서 있지도 않은 메소드를 핸들러로 등록했으니 빨리 메소드도 만들어주자 
mouseHander(type, e) { // type 에는 아까 바인드한 'click'이 넘어오겠지? 
    // css 등으로 캔바스의 논리적 크기와 실제 크기가 다를 수 있으니까 보정을 해서 넘기도록 하자
    let canvasStyle = window.getComputedStyle(this.canvas);
    let xratio = parseInt(this.canvas.width, 0) / parseInt(canvasStyle.width, 0);
    let yratio = parseInt(this.canvas.height, 0) / parseInt(canvasStyle.height, 0);
    let mouseEv = {
        type: type,
        x: e.offsetX * xratio,
        y: e.offsetY * yratio
    };
    this.mouse = mouseEv;
}
//Game.update 의 this.key = null 아래에 
this.mouse = null; //을 넣고 
// this.scenes.last().update(this.timeDelta, this.key) 를 아래처럼 바꾸자 
this.scenes.last().update(this.timeDelta, this.key, this.mouse);
</code></pre>
<p>이제 마우스로 게임 화면을 클릭하면 좌표 정보가 <code>GameScene.update</code>로 넘어가겠지? 센스있게 받아주도록 하자.</p>
<p>먼저 <code>GameScene.update</code>의 매개변수 정보를 바꾸자.</p>
<pre><code>
update(timeDelta, key, mouse){ // mouse 가 추가되었다
</code></pre>
<p>그리고 여기...서 자식들을 업데이트할 때 마우스를 넘겨주는 게 예쁜 그림이 되겠지만 그러면 넘나 귀찮아지니까 우리는 더럽게 여기서 바로 처리해주도록 하자. 우리의 음소거 버튼은 위치가 늘 고정되어있기 때문에 클릭 여부를 알기가 아주 간단한 편이다. 그리는 좌표 알고, 스프라이트 가로세로 크기 아니까 그냥 해당 위치를 클릭했을 때 간단하게 <code>SoundManager.toggle()</code>을 호출해주도록 하자.</p>
<pre><code>
//GameScene.update 의 맨 아래에 추가해주자
if( mouse &amp;&amp; mouse.x &lt; 540-54 !== mouse.x &lt; 540 - 5 &amp;&amp; mouse.y &lt; 5 !== mouse.y &lt; 54){
    this.soundManager.toggle(); 
}
</code></pre>
<p>이제 버튼을 클릭하면 깔끔하게 음소거 되는 걸 확인할 수 있다! 헤헿</p>
<h3>게임 스타트 씬</h3>
<p>멋진 게임을 만들었으니까, 멋진 타이틀 화면도 만들어봐야겠지? 페이지에 들어가자마자 냅다 게임이 시작되고 캐릭터가 죽어버리면 안되니까.. <code>GameScene</code>처럼 <code>GameStartScene</code>을 하나 만들어보자.</p>
<p><img alt='' src='https://lazygyu.net/images/blog/start_scene.png_1490546675.png' /></p>
<p>타이틀화면 위에 스페이스를 누르라는 메시지가 깜빡이고 페이스북 로그인 버튼이 있는 형태다. 페이스북 로그인은 나중에 설명하도록 하고 우선 화면을 만들고 스페이스를 누르면 게임 씬으로 넘어가도록 만들어보자. </p>
<p>초반에 만들었던 <code>Game</code> 클래스에는 씬들을 관리하는 메소드가 있었다. 하지만 씬에서 직접 <code>Game</code>클래스의 메소드들을 호출할 방법은 없는 상태다. 씬에다가 부모의 메소드를 넘겨주거나 부모 객체 자체를 전달해주는 방법도 있지만 그런건 이미 많이 했으니까 이번엔 이벤트 패턴으로 만들어보자. 우선 <code>Scene</code> 객체에 아래 내용을 추가한다.</p>
<pre><code>
// Scene.constructor 에 추가 
this.events = {};
</code></pre>
<p>생성자에서 <code>events</code>를 만들었으니 아래와 같은 두 개의 메소드를 추가하자.</p>
<pre><code>
// 이벤트 핸들러 등록 메소드 
on(type, handler) {
    // 핸들러 처음 정의될 때는 우선 핸들러 큐를 만들고 
    if (!this.events[type]) {
        this.events[type] = [];
    }
    // 이미 같은 핸들러가 이벤트에 등록되어 있으면 아무일도 하지 않고.. 
    if (this.events[type].some(fn => fb == handler)) return;
    // 그렇지 않은 경우에는 핸들러를 등록하자. 
    this.events[type].push(handler);
}
// 이벤트 발생시키는 메소드 
fire(type, arg) { // 핸들러가 존재하면 
    if (this.events[type]) {
        // 호출해주면 끗 
        this.events[type].forEach(fn => fn(type, arg));
    }
}
</code></pre>
<p>그럼 이제 <code>Game</code> 클래스에 이벤트 핸들러를 만들자.</p>
<pre><code>
// Game 클래스에 추가 
sceneEventHandler(type, arg) {
    switch (type) {
        case 'push':
            this.push(arg);
            break;
        case 'pop':
            this.pop();
            break;
    }
}
</code></pre>
<p>보다시피 별로 하는 일은 없다... 그럼 이 이벤트 핸들러를 씬마다 설정해주면 되겠지? 모든 씬이 거쳐가는 <code>push</code>메소드를 고치면 간단하다.</p>
<pre><code>
// Game.push 의 _scene.init(); 아래에 추가 
_scene.on('push', this.sceneEventHandler.bind(this));
</code></pre>
<p>그럼 준비는 갖춰졌으니 <code>GameStartScene</code>을 만들까? 하는 일이 별로 없으니 코드를 보자.</p>
<pre><code>
class GameStartScene extends Scene {
    constructor() {
        super();
        this.bgImg = new Image();
        this.bgImg.src = 'title.png';
        this.img = Images.sprites;
        // 스타트 버튼을 누르라는 안내문구 
        this.pressStart = new Sprite(this.img, 140, 375, 272, 25, 136, 0);
    }
    update(timeDelta, key, mouse) {
        super.update(timeDelta);
        if (key == 32) {
            this.fire('push', new GameScene());
        }
    }
    render(ctx) {
        ctx.drawImage(this.bgImg, 0, 0);
        if (this.elapsed % 1 &lt; 0.5) {
            this.pressStart.draw(ctx, 270, 425);
        }
    }
}
</code></pre>
<p>그리고 이제 스크립트 맨 밑에서 게임을 생성하는 부분을 수정하면 된다.</p>
<pre><code>
var game = new Game(document.getElementById("canv"));
game.push(new GameStartScene()); // GameScene 대신 GameStartScene 으로..
game.update();
</code></pre>
<h3>페이스북 랭킹</h3>
<p>게임은 혼자 하지만, 그래도 혼자서만 해서는 재미가 없다. 온라인 랭킹 시스템을 붙이면 더 재밌게 즐길 수 있겠지? 하지만 회원 가입 로그인 이런거 만들기도 귀찮고, 만들어봤자 사람들은 꼴랑 이 게임을 하기 위해 회원 가입을 할 만큼 한가하지가 않다. 플랫폼 사업자의 배를 불려주기 위해 페이스북 계정에 기반한 랭킹 시스템을 만들어보자...고는 썼지만 사실 이제 의욕도 없고 대충 어떻게 하는지 훑어만 보고 넘어가도록 하자.</p>
<p>우선 페이스북 앱 관리에서 새 앱을 만들고 게임을 선택하고... 하는 과정은 설명하기 귀찮으므로 각자 알아서 잘 해보도록 하자. 앱을 만들 때 카테고리를 게임으로 골라야 한다는 점을 잊지 말자.</p>
<p>어찌됐건 앱을 다 만들면 이제 게임과 연동을 시켜줘야겠지? 점수를 관장하는 <code>ScoreManager</code> 클래스에 페이스북 연동을 붙여보자.</p>
<p><code>ScoreManager</code> 코드가 전체적으로 변경되니까 그냥 대충 훑어보자.</p>
<pre><code>
class ScoreManager {
    constructor() {
        this.highscore = 0;
        this.gotCoin = 0;
        this.usedCoin = 0;
        this._score = 0;
        this.state = 0; // 페이스북 로그인 상태 
        this.name = ""; // 페이스북 이름
        this.authResp = null; // 페이스북 인증 정보 
        this.inited = false; // 초기화 완료 여부 
        this.scoreBoard = null; // 랭킹 정보 
        this.myRank = -1; // 내 랭크 
        this.appID = '{내 페이스북 앱 ID}'; // 페이스북 앱 관리 화면에 있는 앱 아이디를 넣자 
    }
    // 페이스북에서 점수를 가져오는 메소드
    getScore() {
        FB.api('https://lazygyu.net/me/scores', 'GET', (resp) =&gt; {
            if (resp.data.length &gt; 0) {
                this.highscore = Math.max(this.highscore, resp.data[0].score);
                this.name = resp.data[0].user.name;
            }
        });
    }
    // 페이스북에서 친구들의 점수와 랭킹을 가져오는 메소드 
    getScoreBoard() {
        if (this.state &lt; 2) return;
        FB.api('/' + this.appID + 'https://lazygyu.net/scores', 'GET', {}, (resp) =&gt; {
            this.scoreBoard = resp.data.slice();
            this.scoreBoard.forEach((u, i) =&gt; {
                if (u.user.id == this.authResp.userID) this.myRank = (i + 1);
                u.user.picture = new Image();
                u.user.picture.src = 'https://graph.facebook.com/' + u.user.id + 'https://lazygyu.net/picture';
            });
        });
    }
    // 페이스북 로그인 콜백 
    loginCallback(resp) {
        switch (resp.status) {
            case 'connected': // 로그인 및 연동 성공 
                this.state = 2;
                this.authResp = resp.authResponse;
                break;
            case 'not_authorized': // 페이스북 로그인은 되었지만 게임 연동은 안 됨
                this.state = 1;
                break;
            case 'unknown': //몰라잉
                this.state = 0;
                break;
        }
        if (this.state === 2) {
            this.getScore();
            this.getScoreBoard();
        }
    }
    reset() {
        this._score = 0;
        this.gotCoin = 0;
        this.usedCoin = 0;
    }
    save() { 
      	// 페북 로그인이 되어있지 않으면 저장 안함 헤헿 
        if (this.state != 2 || !this.authResp) return;
        FB.api('/' + this.authResp.userID + 'https://lazygyu.net/scores', 'POST', {
            'score': this.highscore
        }, (scoreResp) =&gt; {
            this.getScore();
            this.getScoreBoard();
        });
    }
    init() {
        this.score = 0;
        if (this.state == 0) {
            let cb = this.loginCallback.bind(this);
            window.FB.getLoginStatus(cb);
            this.inited = true;
        }
    }
    set score(v) {
        this._score = v;
        if (this._score &gt; this.highscore) this.highscore = this._score;
    }
    get score() {
        return this._score;
    }
    login() { // 페이스북 로그인 
        let cb = this.loginCallback.bind(this);
        FB.login(cb, {
            scope: "publish_actions,user_friends"
        });
    }
    logout() { // 페이스북 로그아웃
        let cb = this.loginCallback.bind(this);
        FB.logout(cb);
    }
}
</code></pre>
<p>이렇게 스코어 매니저를 바꿨으면 이제 <code>Game</code>클래스를 변경해서 스코어 매니저를 게임 클래스가 들고 있도록 해보자. 지금은 <code>GameScene</code>에서 스코어 매니저를 생성하고 있지만 그러면 어러 씬들 사이에서 공유가 안되니까..(씬이래봤자 두 개 밖에 없긴 하지만..)</p>
<pre><code>
//Game.constructor
// 스코어 매니저 
this.scoreManager = new ScoreManager();

// Game.push 
// _scene.init(); 위에 추가 
_scene.parent = this; // 부모를 지정해주자 

// Scene.constructor 
this.scoreManager = null;
this.parent = null; 

// Scene.init 
this.scoreManager = this.parent.scoreManager;
</code></pre>
<p>그리고 <code>GameScene</code> 에서 <code>ScoreManager</code>를 생성하는 부분을 삭제하면 깔끔. <code>init</code>에서도 맨 윗줄에 <code>super.init();</code> 를 추가해 주자.</p>
<p>그리고 HTML에도 페이스북 API를 사용하기 위한 부트스트래핑 코드를 게임 스크립트보다 전에 넣어주도록 하자. 아마 아래랑 비슷한 모양새일 것이다.</p>
<pre><code>
&lt;script&gt;
window.fbAsyncInit = function() {
    FB.init({
        appId: "내 앱의 ID",
        xfbml: true,
        version: "v2.8"
    });
    FB.AppEvents.logPageView();
};
(function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) {
        return;
    }
    js = d.createElement(s);
    js.id = id;
    js.src = 'https://lazygyu.net//connect.facebook.net/en_US/sdk.js';
    fjs.parentNode.insertBefore(js, fjs);
}(document, "script", "facebook-jssdk"));
&lt;/script&gt;
</code></pre>
<p>그럼 이제 <code>Game</code>의 <code>update</code>를 수정해서 <code>scoreManager.init</code>를 적당한 시기에 호출하도록 해주자.</p>
<pre><code>
//Game.update 에 추가
if( !this.scoreManager.inited &amp;&amp; window.FB ){ 
    this.scoreManager.init(); 
}
</code></pre>
<p>여기까지 했으면 이제 페이스북 로그인 버튼을 게임 스타트 씬에 추가해보자.</p>
<pre><code>
//GameStartScene.constructor 에 추가 
this.fbButton = new Sprite(sprites, 400, 90, 145, 90, 0, 0);
this.fbLogged = new Sprite(sprites, 400, 0, 145, 90, 0, 0); //GameStartScene.render 에 추가 
if (this.parent.scoreManager.state &lt; 2) { // 페이스북 연동이 되지 않은 경우 
    this.fbButton.draw(ctx, 360, 125);
} else { // 이미 연동된 경우 
    this.fbLogged.draw(ctx, 360, 125); // 나의 최고 점수를 써주자 
    ctx.save();
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.font = '15px sans-serif';
    ctx.fillText(this.scoreManager.name ? this.scoreManager.name : 'FACEBOOK 로그인 완료', 432, 155);
    ctx.font = '14px sans-serif';
    ctx.fillText('최고기록 ' + this.scoreManager.highscore + 'm', 432, 175);
    ctx.restore();
}
</code></pre>
<p>여기까지 했으면 처음 우리가 목표로 했던 게임 시작 화면이 나오고 있을 것이다 &gt;_&lt; 넘나 좋긴 하지만 여기서 끝이 아니다. 버튼을 클릭하면 페이스북 로그인을 할 수 있도록 해줘야겠지? <code>GameStartScene.update</code>를 고쳐보자.</p>
<pre><code>
// GameStartScene.update 에 추가 
if (mouse &amp;&amp; this.scoreManager.state &lt; 2 &amp;&amp; (mouse.x &lt;= 360 != mouse.x &lt;= 505) &amp;&amp; (mouse.y &lt;= 125 != mouse.y &lt;= 215)) {
    this.scoreManager.login();
}
</code></pre>
<p>보면 알겠지만 그냥 적당한 위치를 클릭하면 페이스북 로그인 메소드를 호출하게 된다. 로그인 과정은 페이스북이 알아서 해줄거고 우리는 그저 페북 굿굿 하면서 떡이나 먹으면 되는 편리한 부분!</p>
<p>이렇게 로그인과 점수 연동까지 했으면 랭킹을 표시해줘야겠지? 랭킹 표시를 위해 다시 <code>UI </code>클래스를 만져주도록 하자. 우선 게임 화면에서 내 순위를 표시해볼까?</p>
<pre><code>
//UI.render 의 최고기록 표시 밑에 추가 
// 내 순위 표시 
if (this.scoreManager.state == 2) {
    ctx.font = '12px verdana';
    ctx.fillStyle = 'white';
    let str = this.scoreManager.name ? this.scoreManager.name + '님' : 'FACEBOOK 로그인 됨';
    if (this.scoreManager.myRank &gt; 0) str = this.scoreManager.myRank + '위/' + str;
    ctx.fillText(str, 0, 540 - 3);
}
</code></pre>
<p><img alt='' src='https://lazygyu.net/images/blog/with_facebook_myrank.png_1490546898.png' /></p>
<p>쨘! 이제 페이스북 로그인을 하고 게임을 하면 현재 내 순위가 화면 맨 밑에 예쁘게 나온다! 헤헿 이 여세를 몰아서 게임 오버 화면에도 랭킹을 그려주자!</p>
<pre><code>
// UI.render 의 this.gameover.draw 바로 밑에 추가하자
if (this.scoreManager.state == 2 &amp;&amp; this.scoreManager.scoreBoard) { // 페북 연동이 된 상태고 랭킹 정보가 있을 때
    let wc = 540 / 2;
    ctx.fillStyle = 'white';
    ctx.save();
    // 나보다 최대 5등 높은 애부터 화면에 표시해준다. 
    // 왜냐면 랭킹에 너무 많은 사람이 있으면 내가 안 보이는 슬픈 일이 생기기 때문이다.
    let start = Math.max(0, this.scoreManager.myRank - 5);
    ctx.translate(0, -(start * 60)); // 각 항목의 높이는 대충 60으로 정했다.
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 1.0;
    ctx.strokeRect(3, 180, 534, 222); // 화면에 사각형을 그려주고 
    this.rankTitle.draw(ctx, wc, 180); // 랭킹을 그려주자 
    this.scoreManager.scoreBoard.slice(start, 8).forEach((v, i) =&gt; {
        let j = i % 4;
        let y = j * 45,
            x = i &lt; 4 ? 3 : wc;
        ctx.font = 'bold 32px verdana';
        ctx.fillText((start + i + 1), 30 + x, y + 237);
        ctx.font = 'bold 14px sans-serif';
        ctx.fillText(v.user.name, 110 + x, y + 220);
        ctx.font = '16px verdana';
        ctx.fillText(v.score + 'm', 110 + x, y + 240);
        if (v.user.picture) {
            ctx.drawImage(v.user.picture, 0, 0, 50, 50, 60 + x, y + 205, 40, 40);
        }
        ctx.strokeStyle = 'white';
        ctx.strokeRect(60 + x, y + 205, 40, 40);
    });
    ctx.restore();
    // 로그아웃 버튼도 대충 넣자
    ctx.fillStyle = '#3b5998';
    ctx.fillRect(540 - 85, 540 - 35, 80, 30);
    ctx.fillStyle = 'white';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('로그아웃', 540 - 45, 540 - 15);
} else {
    // 로그인 안 한 경우엔 로그인 버튼을 넣어주면 되겠지?
    ctx.textAlign = 'center';
    ctx.font = '16px sans-serif';
    ctx.fillText('Facebook에 로그인해서 친구들의 점수를 알아보세요!', 540 / 2, 220);
    this.fbButton.draw(ctx, 540 / 2, 250);
    ctx.textAlign = 'left';
}
</code></pre>
<p>그냥 노가다 코드라 딱히 설명할 부분은 별로 없다.. 게임 화면이 좁기 때문에 랭킹을 네 명씩 좌우로 나누어 보여주느라 코드가 쓸데없이 조금 긴 측면이 있지만 사실 별 내용이 없으니 안심하고 만들어보자.</p>
<p>여기에서 로그아웃과 로그인 버튼을 그려줬으니 클릭하면 로그아웃 / 로그인 처리를 해줘야겠지? 근데 우리는 지난번에 음소거 버튼 클릭 처리를 <code>UI</code>가 아니라 <code>GameScene</code>에서 대충 때워버렸기 때문에 이제와서 구조를 뜯어 고치기는 귀찮다는 문제가 있다. 게다가 <code>UI</code>클래스에는 딱히 <code>update</code>메소드도 별도로 정의한 게 없다. 그러니까 우리는 게임 장면에서 마우스 클릭을 감지하면 <code>UI</code> 클래스에만 좌표를 넘겨서 처리하는 간단한 방식으로 바꿔보자.</p>
<p>우선 <code>UI</code> 클래스에 <code>click</code>메소드를 추가하자</p>
<pre><code>
click(mouse) {
    if (this.parent.state === 1) { // 게임오버 화면에서 클릭한 경우
        // 페이스북 로그인 상태에 따라 갈린다.
        if (this.scoreManager.state === 2) { // 로그인 되어 있으면 로그아웃 버튼만 처리하면 되고 
            if (mouse &amp;&amp; (mouse.x &lt;= 540 - 65 !== mouse.x &lt;= 540 - 5) &amp;&amp; (mouse.y &lt;= 540 - 35 != mouse.y &lt;= 540 - 5)) {
                this.scoreManager.logout();
            }
        } else { // 그 외엔 로그인 버튼만 처리하면 된다. 
            if (mouse &amp;&amp; (mouse.x &lt;= 163 !== mouse.x &lt;= 376) &amp;&amp; (mouse.y &lt;= 250 != mouse.y &lt;= 312)) {
                this.scoreManager.login();
            }
        }
    } // 음소거 버튼은 게임오버든 아니든 작동해야 한다
    if (mouse &amp;&amp; mouse.x &lt; 540 - 54 !== mouse.x &lt; 540 - 5 &amp;&amp; mouse.y &lt; 5 !== mouse.y &lt; 54) {
        this.parent.soundManager.toggle();
    }
}
</code></pre>
<p>그리고 나서 <code>GameScene.update</code>에서 음소거 버튼에 대한 처리가 있던 부분을 지우고 방금 만든 메소드를 호출해 주자.</p>
<pre><code>if(mouse) this.ui.click(mouse);</code></pre>
<p>그럼 이제 로그인 로그아웃 버튼도 잘 작동하고 음소거 버튼도 잘 동작하는 게임이 드디어 완성됐다!</p>
<p>아 정말 길고도 힘든 여정이었다... 여기까지 읽은 사람은 아마 없겠지만 있다면 기쁨의 치킨을 시켜먹어도 좋다.</p>
<h2>마무리</h2>
<h3>JS 브라우저 호환성</h3>
<p>우리의 게임은 최소 <code>&lt;canvas&gt;</code> 와 <code>&lt;audio&gt;</code> 태그를 지원하는 브라우저가 필요하다. 바꿔 말하면 <code>IE9</code> 이상의 모던브라우저에서만 동작이 가능하다는 뜻이다. 하지만 IE9에서 이 게임을 실행하려고 하면 아마 실행이 안 될 것이다. 왜냐면 여지껏 작성한 코드들이 ES6 문법을 되는대로 갖다 쓰고 있기 때문이다. 그럼 이걸 어떻게 하면 될까... 다시 첨부터 다시 작성? 은 말도 안되는 소리고 이럴때 쓰라고 <code>바벨</code>이라는 게 있다. 좀 간지나게 하려면 웹팩 같은 번들러와 엮어서 빌드를 하면 좋겠지만 이 게임은 파일이 꼴랑 하나니까 간단하게 온라인 바벨 번역기를 써보자. 위 스크립트 내용을 <a href='https://babeljs.io/repl/'>바벨 사이트</a> 에 넣으면 오른쪽 창에 <code>ES5</code> 에서 실행 가능하도록 변환된 결과가 나온다. 이 변환된 내용을 스크립트 태그에 넣고 게임을 다시 실행해보자.</p>
<p>그래도 아마 안 될텐데, 이 게임에서 쓰는 몇몇 메소드들이 <code>IE9</code>에는 없기 때문이다. 예를 들어서 <code>requestAnimationFrame</code>나 <code>performance.now</code> 같은 것들이 그렇다. 이런 것들은 폴리필을 직접 구현해주거나 이미 구현된 폴리필을 사용하면 해결된다. 예를 들면 아래 코드와 비슷하게 구현해서 스크립트 최 상단에 추가해두자.</p>
<pre><code>
window.requestAnimationFrame = (function() {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || // if all else fails, use setTimeout 
        function(callback) {
            return window.setTimeout(callback, 1000 / 60); // shoot for 60 fps
        };
})();
(function() {
    if ('performance' in window == false) {
        window.performance = {};
    }
    Date.now = (Date.now || function() { // thanks IE8
        return new Date().getTime();
    });
    if ('now' in window.performance == false) {
        var nowOffset = Date.now();
        if (performance.timing &amp;&amp; performance.timing.navigationStart) {
            nowOffset = performance.timing.navigationStart
        }
        window.performance.now = function now() {
            return Date.now() - nowOffset;
        }
    }
})();
</code></pre>
<p><iframe height="680" scrolling="no" title="LWBgoN" src="https://lazygyu.net//codepen.io/lazygyu/embed/LWBgoN/?height=580&amp;theme-id=0&amp;default-tab=result&amp;embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/lazygyu/pen/LWBgoN/">LWBgoN </a> by LazyGyu (<a href="http://codepen.io/lazygyu">@lazygyu </a>) on <a href="http://codepen.io">CodePen </a>. </iframe> </p> <p>그 외에 게임의 로그인 상태를 저장하는 방법이라던지, 여러가지로 더 다듬을 수 있는 방법들이 있겠지만 나머지는 각자 자신의 게임을 만들어보면서 스스로 즐겨보도록 하자!</p>
<p>다들 7회동안 수고 많았고 나중에 웃으면서 보자! 모두모두 앗녕!!</p>
<p>은 난 다신 이런 긴 글 쓰지 말아야지....</p> ]]></content:encoded>
<link>https://lazygyu.net/blog/html5_js_minigame_tutorial7</link>
<category><![CDATA[ HTML5 게임 개발 튜토리얼 ]]></category>
<pubDate>Sat, 25 Mar 2017 06:27:00 +0900</pubDate>
<guid>https://lazygyu.net/blog/html5_js_minigame_tutorial7</guid>
</item>
<item>
<title><![CDATA[ HTML5 미니게임 개발 튜토리얼 6 ]]></title>
<description><![CDATA[  이제 드디어 땅에 닿으면 게임이 멈추고 스페이스바를 누르면 다시 시작된다! 이번 편은 여기까지... 다음편에서는 아이템 상점도 만들고 게임오버 화면도 다듬고.. 게임을 전체적으로 예쁘게 다듬어보도록 하자. ]]></description>
<content:encoded><![CDATA[ <h1>HTML5 미니게임 개발 튜토리얼</h1> <p><a href="http://lazygyu.net/blog/html5_js_minigame_tutorial5">이전 글 : Swing my baby 를 통해 보는 HTML5 게임 개발(5)</a><br/>현재 글 : Swing my baby 를 통해 보는 HTML5 게임 개발(6)<br/><a href="https://lazygyu.net/blog/html5_js_minigame_tutorial7">다음 글 : Swing my baby 를 통해 보는 HTML5 게임 개발(7)</a></p> <p><img alt="" src="https://lazygyu.net/images/blog/title.png_1485795720.png"/></p> <p>벌써 6편이라니... 소스코드보다 이 글이 벌써 몇배나 길어진건지 모르겠다... 그치만 무를 뽑았으면 칼이라도 썰어야지! 칼국수 만드는 심정으로 마지막까지 달려가보자.</p> <h2>개발 과정</h2> <p>자 이제 우리의 캐릭터는 줄을 걸고 점프하고 아이템을 먹을 수 있게 됐다. 이쯤되면 이제 정말 게임이다. 그치만 진정한 잉여력은 디테일에서 나오는 법. 이번에는 꼭 필요한건 아니지만 게임을 맛깔나게 해주는 것들을 만들어보자.</p> <h3>이펙트</h3> <p>아이템을 먹을 때나 점프할 때, 줄을 걸 때에 찰진 손맛을 느낄 수 있도록 이펙트를 넣어보자. 파티클이라고도 부르는 친구들인데 뭐 기본은 아이템과 거의 동일하다. 우선 <code>SpriteDef</code>와 <code>AnimationDef</code>에 이펙트에 쓰일 것들을 추가하자.</p> <pre><code>// SpriteDefs 에 추가 "effect": [ { x: 160, y: 0, w: 30, h: 30, origin: { x: 15, y: 15 } }, { x: 190, y: 0, w: 30, h: 30, origin: { x: 15, y: 15 } }, { x: 220, y: 0, w: 30, h: 30, origin: { x: 15, y: 15 } }, { x: 250, y: 0, w: 30, h: 30, origin: { x: 15, y: 15 } }, { x: 160, y: 40, w: 30, h: 30, origin: { x: 0, y: 0 } }, { x: 190, y: 40, w: 30, h: 30, origin: { x: 0, y: 0 } }, { x: 220, y: 40, w: 30, h: 30, origin: { x: 0, y: 0 } }, { x: 250, y: 40, w: 30, h: 30, origin: { x: 0, y: 0 } }, { x: 0, y: 250, w: 30, h: 30, origin: { x: 15, y: 15 } }, { x: 30, y: 250, w: 30, h: 30, origin: { x: 15, y: 15 } }, { x: 60, y: 250, w: 30, h: 30, origin: { x: 15, y: 15 } }, { x: 90, y: 250, w: 30, h: 30, origin: { x: 15, y: 15 } }, { x: 0, y: 280, w: 40, h: 40, origin: { x: 20, y: 20 } }, { x: 40, y: 280, w: 40, h: 40, origin: { x: 20, y: 20 } }, { x: 80, y: 280, w: 40, h: 40, origin: { x: 20, y: 20 } }, { x: 120, y: 280, w: 40, h: 40, origin: { x: 20, y: 20 } } ] // AnimationDefs 에 추가 "effect": { 'jump': [ { frame: 0, duration: 0.05 }, { frame: 1, duration: 0.05 }, { frame: 2, duration: 0.05 }, { frame: 3, duration: 0.05 } ], 'clap': [ { frame: 4, duration: 0.05 }, { frame: 5, duration: 0.05 }, { frame: 6, duration: 0.05 }, { frame: 7, duration: 0.05 } ], 'coin': [ { frame: 8, duration: 0.05 }, { frame: 9, duration: 0.05 }, { frame: 10, duration: 0.05 }, { frame: 11, duration: 0.05 } ], 'mana': [ { frame: 12, duration: 0.05 }, { frame: 13, duration: 0.05 }, { frame: 14, duration: 0.05 }, { frame: 15, duration: 0.05 } ] }</code></pre> <p>이펙트가 하는 일은 간단하다. 생성되어서, 특정한 자리에서 표시되다가, 애니메이션이 완료되면 사라진다. 그야말로 깔끔! 그럼 일단 이펙트 클래스를 만들어보자.</p> <pre><code>class Effect extends GameObject { constructor(anim, x, y) { super(); this.animation = anim; this.x = x; this.y = y; } get done() { return this.animation.done; } update(timeDelta) { this.animation.update(timeDelta); } render(ctx) { this.animation.draw(ctx, this.x, this.y); } }</code></pre> <p>하는 일이 간단하니 코드도 간단하다 히힣. 그리고 이제 이 이펙트들을 관리하는 이펙트 관리자 클래스를 만들자. 이펙트 관리자는 아이템 관리자와 하는 일이 거의 비슷하다. 이펙트를 생성하고, 업데이트해주고 그려주다가 다 끝난 이펙트는 제거하면 된다.</p> <pre><code>class EffectManager extends GameObject { constructor() { super(); this.effects = []; this.img = new Image(); this.img.src = "http://web.lazygyu.net/test/whip/images/eclipse_sprites.png"; this.spriteSheet = new SpriteSheet(this.img, SpriteDefs.effect); } update(timeDelta) { super.update(timeDelta); this.effects = this.effects.filter((e) => { e.update(timeDelta); return !e.done; }); } render(ctx) { super.render(ctx); this.effects.forEach((e) => { e.render(ctx); }); } create(type, x, y) { let anim = new Animation(this.spriteSheet, AnimationDefs.effect[type], { loop: false }); let ef = new Effect(anim, x, y); ef.init(); this.effects.push(ef); } }</code></pre> <p>그동안 열심히 해왔으니까 이젠 왠만한 코드는 간단하게 구현된다. 넘나 편리한것! 이렇게 관리자 클래스를 만들어줬으면 <code>GameScene</code>에 기존에 하던대로 센스있게 추가해주자.</p> <pre><code>// GameScene.constructor 에 추가 this.effectManager = new EffectManager(); this.children.push(this.effectManager); this.character.effect = this.effect.bind(this); // 캐릭터가 이펙트를 주로 생성하므로 전달해주자</code></pre> <p>이제 필요한 곳에 이펙트를 쑉쑉 추가해보자! 우선 우리의 캐릭터가 줄을 거는 동작에는 중간과정이 젠젠 없어서 줄이 허공에서 생성되는 것처럼 보이는데, 이걸 이펙트 하나로 센스있게 해결해보자! 덩달아서 줄에서 점프할 때도 가벼운 이펙트를 넣어주자.</p> <pre><code>// Character.setPivot 에 추가 this.effect("clap", point.x, point.y); // 이건 줄을 거는 쪽에 this.effect("jump", this.x, this.y); // 이건 줄을 놓는 쪽에</code></pre> <p>그리고 각 아이템을 먹을 때도 적절한 이펙트를 추가하도록 하자.</p> <pre><code>// Character.gotItem에 추가 this.effect("jump", this.x, this.y); // 이건 점프 this.effect("mana", this.x, this.y); // 이건 마나 물약 this.effect("coin", this.x, this.y); // 이건 동전</code></pre> <p>자석 먹을 때는 별다른 이펙트는 필요 없으니 무시하면 된다. 그리고 게임을 실행해보면 전보다 훨씬 보기 좋아진 것이.....느껴지나? 모르면 할 수 없고 헤헿</p> <h3>소리</h3> <p>아직까지 우리의 게임은 뭔가 허전하다. 뭐 때문일까? 바로 소리 때문이지! 이제 슬슬 사운드를 첨가해보도록 하자.</p> <h4>HTML5에서 소리는 어떻게 내면 되지?</h4> <p>외부 라이브러리를 쓰면 된다....고 하면 너무 무책임하니까 일단 뭐라도 있어보이게 늘어놔보도록 하자. HTML5 스펙에는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API"><code>웹 오디오 API</code></a>가 있다. 이걸 사용하면 여러가지를 상세하게 제어해서 소리를 내줄 수 있...지만 귀찮다. 귀찮고 브라우저마다 구현체가 다르거나 <code>canvas</code>보다도 지원 브라우저가 더 적다는 문제가 있다. 그러니까 우리는 간단한 방법을 쓰도록 하자.</p> <p>HTML5에는 <code><audio></code>라는 태그가 있다. 이 녀석은 옛날에 <code>embed</code>태그 같은걸로 음악을 넣던 것과 흡사한 방식으로 음악 파일을 재생할 수 있는데, 게다가 HTML5 표준 스펙이기 때문에 크로스 브라우징 염려도 확 줄어드는 장점이 있다.</p> <p>그럼 간단하게 소리를 관리하는 사운드 관리자를 만들어보도록 하자. 이녀석은 게임에 사용되는 소리를 모조리 관리하고 요청에 따라 사운드를 재생하거나 정지하는 역할을 한다.</p> <pre><code>class SoundManager { constructor(){ this.sounds = {}; this.enable = true; this.soundFiles = ['whip', 'jump', 'highjump', 'coin', 'gameover', 'potion', 'bgm']; this.soundFiles.forEach((v)=>{ this.sounds[v] = document.createElement("audio"); this.sounds[v].src = "sounds/" + v + ".mp3"; }); this.sounds.bgm.volume = 0.3; // 브금은 효과음보다 좀 작게.. this.sounds.bgm.addEventListener("ended", (v)=>{ // 브금이 끝나면 자동으로 다시 반복해서 재생하자 this.sounds.bgm.currentTime = 0; this.sounds.bgm.play(); }); } init(){ this.bgm.play(); } stop(name){ this.sounds[name].pause(); this.sounds[name].currentTime = 0; } bgmStart(){ this.stop('bgm'); this.sounds.bgm.play(); } bgmStop(){ this.sounds.bgm.pause(); } play(name){ if( this.sounds[name]){ this.stop(name); this.sounds[name].play(); } } toggle(){ this.enable = !this.enable; this.soundFiles.forEach((v)=>{ this.sounds[v].volume = this.enable?((i=='bgm')?0.3:1):0; }); } distructor(){ this.soundFiles.forEach((v)=>{ this.soundFiles[v].pause(); this.soundFiles[v] = null; }); } }</code></pre> <p>위 소스를 보면 알겠지만 올바른 경로에 <code>whip.mp3</code>, <code>jump.mp3</code>, <code>highjump.mp3</code>, <code>coin.mp3</code>, <code>gameover.mp3</code>, <code>potion.mp3</code>, <code>bgm.mp3</code> 등의 파일들이 있어야 한다. 안타깝지만 이 파일들은 내가 맘대로 제공해줄 수 없으니 각자 알아서 아무 사운드나 구해서 넣도록 하자. 저작권법의 철퇴를 맞지 않게 조심해서..</p> <p>어쨌든 이렇게 만들어진 사운드관리자를 <code>GameScene</code>에 추가하도록 하자. 다만 사운드관리자는 <code>GameObject</code>가 아니니까 <code>children</code>에는 추가하지 말아야 한다는 걸 잊지 말자.</p> <pre><code>// GameScene.constructor 에 추가 this.soundManager = new SoundManager(); // 소리를 내는 건 캐릭터니까 캐릭터에게 소리를 낼 수 있게 해주자 this.character.sound = this.soundManager.play.bind(this.soundManager);</code></pre> <p>이건 기우에서 하는 말인데, 이 게임은 소리를 내는 주체나 이펙트를 생성하는 주체가 캐릭터 하나 뿐이니까 이렇게 하는거고, 많은 객체들이 각자 소리를 내거나 이펙트를 생성할 수 있는 게임을 만들 때는 이렇게 하면 안된다. 로직도 꼬이거니와 메모리도 조지고 최적화에도 안좋....지만 지금은 그딴거 알 게 뭐야 그냥 가자 헤헿</p> <p>이제 우리는 소리를 낼 수 있다! 캐릭터가 소리를 내야 하는 부분마다 맘껏 넣어주자. 먼저 아이템 먹는 소리들을 넣어주자.</p> <pre><code>//이제 Character.gotItem 은 이런 모양일것이다. gotItem(item) { switch (item) { case "jump": this.pivot = null; this.force.y -= 8; this.force.x += 10; this.mp = Math.max(10, this.mp + 1); this.effect("jump", this.x, this.y); this.sound("highjump"); //소리! break; case "mana": this.mp = Math.max(10, this.mp+3); this.effect("mana", this.x, this.y); this.sound("potion"); // 소리!! break; case "magnet": this.magnet = 3; break; case "coin": this.money += 100; this.effect("coin", this.x, this.y); this.sound("coin"); //소소소소리!! break; } }</code></pre> <p>그리고 채찍 휘두르는 소리와 점프하는 소리도 넣자!</p> <pre><code>// setPivot 은 이런 모양이겠지? setPivot(point) { if (this.pivot === null && this.mp > 0) { this.mp--; this.pivot = point; this.pLen = Math.distance(this, this.pivot); this.position = { x: this.x - this.pivot.x, y: this.y - this.pivot.y }; this.angle = Math.angle({ x: this.x, y: this.y }, this.pivot); this.accel = (-1.3 * (this.force.x + this.force.y) / this.pLen) * Math.sin(this.angle); this.effect("clap", point.x, point.y); this.sound("whip"); // 쨘 소리! this.update(0); } else if(this.pivot !== null) { this.pivot = null; this.pLen = 0; this.position = null; this.angle = 0; this.accel = 0; this.effect("jump", this.x, this.y); this.sound("jump"); // 여기도 소리!! this.update(0); } }</code></pre> <p>그리고 이제 게임을 실행해보면 배경음악과 효과음이 얼마나 게임에 큰 영향을 미치는지 확 느낄 수 있을거다! 헤헿</p> <h3>점수 관리</h3> <p>이 게임은 점수를 많이 내는 게 목표다. 그러니까 점수를 잘 저장해둬야 한다. 이번에도 마찬가지로 점수 관리 클래스를 만들어보자. 사실 꼴랑 점수 관리하는 데 관리자 클래스가 필요하진 않지만 나중에 페이스북 랭킹을 붙이기 편하도록 미리 코드를 분리해둔다는 심정으로...</p> <pre><code>class ScoreManager{ constructor(){ this.highscore = localStorage.getItem("highscore") || 0; this._score = 0; } reset(){ this._score = 0; } save(){ if( this.highscore > 0 ){ localStorage.setItem("highscore", this.highscore); } } set score(v){ this._score = v; if( this._score > this.highscore ) this.highscore = this._score; } get score(){ return this._score; } }</code></pre> <p>그리고 늘 하던대로 <code>GameScene</code>에다가 추가해주고..</p> <pre><code>// GameScene.constructor this.scoreManager = new ScoreManager();</code></pre> <p><code>init</code>에서는 <code>reset</code>을 호출해주자</p> <pre><code>// GameScene.init this.scoreManager.reset();</code></pre> <p>그리고 <code>update</code>에서는 현재 점수를 넣어주면 되겠지?</p> <pre><code>// GameScene.update // 우리는 10픽셀을 1미터로 취급하니까 아래처럼 10으로 나눠주자. // 기본값인 100 을 빼주는 것도 잊지 말자 헤헿 this.scoreManager.score = Math.max(0, ((this.cameraX-100)/10)|0);</code></pre> <p>일단 이정도로 점수관리를 해두고 다음으로 넘어가자.</p> <h3>UI 만들기</h3> <p>우리는 게임 화면에 표시해줘야 할 것들이 많다. 점수도 표시해줘야 하고, 남은 MP도 보여줘야 하고, 최고기록도 보여줘야 하고, 현재 가진 코인도 보여줘야 한다. 우선 UI 클래스를 만들어보자.</p> <pre><code>class UI extends GameObject{ constructor(scoremanager, character){ this.scoreManager = scoremanager; //점수를 표시해주기 위해 점수 관리 객체를 받아두자 this.character = character; //MP를 표시해주기 위해 캐릭터를 받아두자. } }</code></pre> <p>생성자에서 눈치챘겠지만 요 녀석을 생성할 때는 저 둘을 넘겨줘야겠지? <code>GameScene</code>의 생성자에 아래 내용을 추가해주자.</p> <pre><code>// GameScene.constructor 에 추가 this.ui = new UI(this.scoreManager, this.character); //생성하고 this.children.push(this.ui); // 맨 마지막에 추가해준다.</code></pre> <p>구조상 <code>GameScene.children</code>은 뒤에 추가된 녀석일수록 화면에서 나중에 그려지기 때문에 UI는 반드시 마지막으로 추가되도록 해주자.</p> <p>업데이트에서는 당장 따로 해줄 게 없을 거 같으니 우선 렌더에서 점수와 mp를 그려보...려고 하는데 그러려면 이번에도 역시 현재 카메라의 x 좌표가 필요하다. 이쯤되면 매번 x 좌표를 넣어주는 것도 지겨우니 모든 <code>GameObject</code> 에 공통으로 x 좌표를 넣어줄 방법을 생각해보자.</p> <p>x 좌표 뿐만 아니라 각각의 게임 오브젝트들은 <code>GameScene</code>을 참조할 일이 생기기 쉽다. 이럴 바엔 모든 자녀 객체에 <code>parent</code>라는 멤버 변수를 두는게 어떨까? <code>GaemObject</code> 의 생성자(현재까지는 비어있을 것이다)에 아래처럼 벼수를 선언하자.</p> <pre><code>this.parent = null;</code></pre> <p>그리고 <code>GameScene</code>의 생성자 마지막 부분에 아래와 같은 줄을 추가하자.</p> <pre><code>this.children.forEach((ch)=>{ ch.parent = this; });</code></pre> <p>그럼 이제 각 게임객체들은 <code>this.parent.cameraX</code> 값을 참조해서 바로 카메라의 x 좌표를 가져올 수 있다. 그 동안 lastX 니 minX 니 하면서 각각 귀찮게 전달해주고 전달받던 코드들을 모조리 저걸로 연동시키도록 하자. (귀찮으니 여기서는 각자 알아서 잘 했겠거니 하고 넘어간다...) 그리고 <code>UI.render</code>에서 현재 점수를 그려보자.</p> <pre><code>render(ctx){ ctx.save(); ctx.translate(this.parent.cameraX-200, 0); // 현재 점수 표시 ctx.fillStyle = "white"; ctx.strokeStyle = "black"; ctx.strokeWidth = 2; ctx.font = "bold 40px verdana"; ctx.fillText(this.scoreManager.score + "m", 0, 540-35); ctx.strokeText(this.scoreManager.score + "m", 0, 540-35); // 외관선도 그려주자 ctx.restore(); } </code></pre> <p>그리고 나면 이번엔 mp 잔량을 그려보자. 지난 게시물들을 잘 따라왔다면 원래 이미지에 mp 표시를 위한 부분이 있었던 걸 기억할 것이다. 우선 UI 생성자에서 해당 이미지를 가지고 있다가 필요한 부분에 이미지를 그려주도록 하자.</p> <pre><code>//UI.constructor 에 추가 this.img = new Image(); this.img.src = "images/eclipse_sprites.png";</code></pre> <p>MP를 표시하는 부분은 아래처럼 생겼다.</p> <p><img alt="" src="https://lazygyu.net/images/blog/mp_view.PNG_1486924678.png"/></p> <p>동그란 구슬 속에 파란 색이 차있는 형태인데, 당연히 파란색을 현재 mp 잔량에 맞춰서 그려주고 그 위에 테두리 + 광택이 표현된 이미지를 얹어주면 되겠지?</p> <pre><code>//UI.render 에 추가 // mp 잔량 표시 let mp = this.character.mp/10*60; // 이미지 세로 크기인 60에 대한 비율로 나타내기 위해서... if( mp > 0 ){ ctx.drawImage(this.img, 75, 395-mp, 60, mp, 540-65, 540-5-mp, 60, mp); } ctx.drawImage(this.img, 0, 330, 70, 70, 540-70, 540-70, 70, 70);</code></pre> <p>왜 스프라이트를 만들지 않고 직접 <code>drawImage</code>를 사용하느냐 하면... 이 게임에서 이미지를 잘라서 표시하는 부분은 딱 저기 한 군데 뿐이기 때문에 얘를 위해서 스프라이트 클래스를 고치기가 귀찮기 때문이다. 헤헿...</p> <p>그리고 또 보여줘야 할 게 뭐가 있을까? 현재 캐릭터가 가진 소지 금액이 보여야 한다! 소지금액 앞에 이게 돈이라는 걸 알려주기 쉽도록 코인 아이템 모양도 그려주면 더 좋겠지? 우선 코인 스프라이트를 하나 만들자.</p> <pre><code>// UI.constructor 에 추가 this.coin = new Sprite(this.img, 300, 0, 40, 40, 0, 0);</code></pre> <p>만들었으면 그려주자</p> <pre><code>//UI.render 에 추가 // 현재 코인 잔액 표시 ctx.font = "bold 30px verdana"; ctx.fillStyle = "#ffb82f"; ctx.fillText(this.character.money, 35, 540-75); ctx.strokeText(this.character.money, 35, 540-75); this.coin.draw(ctx, 5, 440, {scale:0.625});</code></pre> <p>그리고 최고기록도 표시해주자.</p> <pre><code>//UI.render 에 추가 // 최고기록 표시 ctx.font = "16px verdana"; ctx.strokeText("HIGHSCORE " + this.scoreManager.highscore + "m", 0, 540-17); ctx.fillText("HIGHSCORE " + this.scoreManager.highscore + "m", 0, 540-17);</code></pre> <p>근데 최고기록을 보여줘봤자 우리 게임은 아직 죽질 않으니까 소용이 없다. 일단 임시로 캐릭터가 죽으면 다시 시작할 수 있도록 해보자. <code>GameScene</code>을 전체적으로 일단 바꿔보자.</p> <p>일단 생성자에서 현재 게임 상태를 나타내는 변수를 추가하자.</p> <pre><code>// GameScene.constructor this.state = 0; // 0 : 게임중, 1 : 쥬금</code></pre> <p>당연히 <code>init</code>에서는 초기화를 해주고</p> <pre><code>// GameScene.init this.state = 0;</code></pre> <p><code>update</code> 전체를 <code>if</code>로 감싸주자. 원래 많이 복잡해지면 업데이트와 렌더를 각 상태별로 분리해버리는게 편하지만, 별 거 없으니 그냥 <code>if</code>로 간다!</p> <pre><code>update(timeDelta, key) { if( this.state == 0 ){ this.elapsed += timeDelta; this.children.forEach((ch) => { ch.update(timeDelta, this.character); }); this.cameraX = Math.max(this.cameraX, this.character.x); this.scoreManager.score = Math.max(0, ((this.cameraX-100)/10)|0); this.itemManager.checkCollision(this.character); if (key === 32) { var tx = Math.cos(Math.PI / 4) * this.character.y + this.character.x; this.character.setPivot({ x: tx, y: 0 }); } if (this.character.y > 540 || this.terrain.isHit(this.character)) { this.terrain.fillStyle = "red"; this.state = 1; } else { this.terrain.fillStyle = "black"; } }else{ if( key === 32 ){ this.init(); } } }</code></pre> <p>이제 드디어 땅에 닿으면 게임이 멈추고 스페이스바를 누르면 다시 시작된다!</p> <p>이번 편은 여기까지... 다음편에서는 아이템 상점도 만들고 게임오버 화면도 다듬고.. 게임을 전체적으로 예쁘게 다듬어보도록 하자. 이제 진짜 거의 다왔다!</p> <p><p data-height="600" data-theme-id="0" data-slug-hash="QdzgEW" data-default-tab="result" data-user="lazygyu" data-embed-version="2" data-pen-title="QdzgEW" class="codepen">See the Pen <a href="http://codepen.io/lazygyu/pen/QdzgEW/">QdzgEW</a> by LazyGyu (<a href="http://codepen.io/lazygyu">@lazygyu</a>) on <a href="http://codepen.io">CodePen</a>.</p> <script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script></p> <p><a href="https://lazygyu.net/blog/html5_js_minigame_tutorial7">다음 글 : Swing my baby 를 통해 보는 HTML5 게임 개발(7)</a></p> ]]></content:encoded>
<link>https://lazygyu.net/blog/html5_js_minigame_tutorial6</link>
<category><![CDATA[ HTML5 게임 개발 튜토리얼 ]]></category>
<pubDate>Mon, 13 Feb 2017 03:28:00 +0900</pubDate>
<guid>https://lazygyu.net/blog/html5_js_minigame_tutorial6</guid>
</item>
<item>
<title><![CDATA[ 문고리 교체 ]]></title>
<description><![CDATA[ 우리집엔 개가 있다. 아주 귀엽고 큼직한 개가. 게다가 이녀석은 아주 똘똘하다. 똘똘하면서도 게으르기 때문에 말을 빠릿빠릿 알아듣고 재주를 부리지는 않지만, 대신 지 멋대로 문을 열고 다닌다. ]]></description>
<content:encoded><![CDATA[ <p><img alt="" src="https://lazygyu.net/images/blog/16601561_671277973051885_1734560851548835167_o.jpg_1486645768.jpg" /></p>
<p>우리집엔 개가 있다. 아주 귀엽고 큼직한 개가.</p>
<p>게다가 이녀석은 아주 똘똘하다. 똘똘하면서도 게으르기 때문에 말을 빠릿빠릿 알아듣고 재주를 부리지는 않지만, 대신 지 멋대로 문을 열고 다닌다.</p>
<p><iframe width="100%" height="500" class="youtubeFrm" src="https://lazygyu.net//youtube.com/embed/z0zTFEBDesI?rel=0" frameborder="0" allowfullscreen="true"></iframe></p>
<p>바로 이렇게!</p>
<p>그래서 이걸 어떻게 해결해야 할지 늘 고민이었지만 그냥 문고리를 호두가 돌릴 수 없는 동그란 문고리로 바꾸면 된다는 것을 깨닫고야 말았다.</p>
<p>아내에게 그 이야기를 했더니 아내가 동그란 문고리를 쿠팡 로켓배송으로 주문했다.</p>
<p>로켓배송이지만 섬구석이라 이틀 후에 도착했지만..</p>
<p><img alt="" src="https://lazygyu.net/images/blog/IMG_20170209_214839.jpg_1486646668.jpg" /></p>
<p>이녀석을 열어보면 이런 구성품이 들어있다. 이제 이걸로 문고리를 교체해보도록 하자.</p>
<p><img alt="" src="https://lazygyu.net/images/blog/IMG_20170209_214856.jpg_1486646706.jpg" /></p>
<p>우선 교체할 문고리를 찾아가서</p>
<p><img alt="" src="https://lazygyu.net/images/blog/IMG_20170209_214920.jpg_1486646722.jpg" /></p>
<p>냅다 나사를 뽑아낸다.</p>
<p><img alt="" src="https://lazygyu.net/images/blog/IMG_20170209_214939.jpg_1486646745.jpg" /> <img alt="" src="https://lazygyu.net/images/blog/IMG_20170209_215026.jpg_1486646755.jpg" /></p>
<p>그러면 이렇게 손잡이가 분리된다.</p>
<p><img alt="" src="https://lazygyu.net/images/blog/IMG_20170209_215040.jpg_1486646772.jpg" /></p>
<p>남아있는 이 고정쇠도 사정없이 분리해주자.</p>
<p><img alt="" src="https://lazygyu.net/images/blog/IMG_20170209_215128.jpg_1486646790.jpg" /></p>
<p><img alt="" src="https://lazygyu.net/images/blog/IMG_20170209_215137.jpg_1486646805.jpg" /></p>
<p>뻥뚫린 요 문구멍에 먼저 새 고정쇠를 설치한다. 이때 고정쇠를 반대로 설치하면 문이 안 닫히는 불상사가 벌어지므로 조심하도록 하자.</p>
<p><img alt="" src="https://lazygyu.net/images/blog/IMG_20170209_215308.jpg_1486646836.jpg" /></p>
<p>그리고 동그란 문손잡이의 요 구멍을 뾰족한 걸로 눌러서</p>
<p><img alt="" src="https://lazygyu.net/images/blog/IMG_20170209_215333.jpg_1486646866.jpg" /></p>
<p>뽑아낸다!</p>
<p><img alt="" src="https://lazygyu.net/images/blog/IMG_20170209_215411.jpg_1486646896.jpg" /></p>
<p>그 밑의 접시같이 생긴 쇠들도</p>
<p><img alt="" src="https://lazygyu.net/images/blog/IMG_20170209_215425.jpg_1486646912.jpg" /></p>
<p>뽑!뽑!</p>
<p>그리고 아까 설치한 고정쇠에 잘 맞춰서 끼우고</p>
<p><img alt="" src="https://lazygyu.net/images/blog/IMG_20170209_215627.jpg_1486646968.jpg" /></p>
<p>접시같은 쇠 하나를 끼운 뒤에 나사로 반대편 문손잡이와 단단히 결속해준다.</p>
<p><img alt="" src="https://lazygyu.net/images/blog/IMG_20170209_215715.jpg_1486646997.jpg" /></p>
<p>그 위에 덮개까지 씌우면 이렇게 된다.</p>
<p><img alt="" src="https://lazygyu.net/images/blog/IMG_20170209_215800.jpg_1486647383.jpg" /></p>
<p>문손잡이를 끼울 때는 옆의 홈을 잘 맞춰서</p>
<p><img alt="" src="https://lazygyu.net/images/blog/IMG_20170209_215818.jpg_1486647048.jpg" /></p>
<p>쑥!!!</p>
<p><img alt="" src="https://lazygyu.net/images/blog/IMG_20170209_215838.jpg_1486647056.jpg" /></p>
<p>밀어 넣으면 완성!</p>
<p><img alt="" src="https://lazygyu.net/images/blog/IMG_20170209_215849.jpg_1486647070.jpg" /></p>
<p>이제 호두놈이 다시는 베란다 문을 열지 못하겠지 큭큭큭....</p> ]]></content:encoded>
<link>https://lazygyu.net/blog/replacing_door_knobs</link>
<category><![CDATA[ 생활 ]]></category>
<pubDate>Thu, 09 Feb 2017 22:40:00 +0900</pubDate>
<guid>https://lazygyu.net/blog/replacing_door_knobs</guid>
</item>
<item>
<title><![CDATA[ HTML5 미니게임 개발 튜토리얼 5  ]]></title>
<description><![CDATA[ 지난 시간에 지형을 만들고 충돌체크까지 했으니 이번엔 아이템을 만들어 보자. ]]></description>
<content:encoded><![CDATA[ <h1>HTML5 미니게임 개발 튜토리얼</h1>
<p><a href="http://lazygyu.net/blog/html5_js_minigame_tutorial4">이전 글 : Swing my baby 를 통해 보는 HTML5 게임 개발(4)</a><br/>현재 글 : Swing my baby 를 통해 보는 HTML5 게임 개발(5)<br/><a href="http://lazygyu.net/blog/html5_js_minigame_tutorial6">다음 글 : Swing my baby 를 통해 보는 HTML5 게임 개발(6)</a> </p>
<p><img alt="" src="https://lazygyu.net/images/blog/title.png_1485795720.png" /></p>
<p>분량조절에 대차게 실패한 시리즈.... 뭐 어쨌든 이렇게 된 거 어떻게든 끝까지 한 번 가보자. 지난 시간에 지형을 만들고 충돌체크까지 했으니 이번엔 아이템을 만들어 보자.</p>
<h2>개발 과정</h2>
<h3>아이템 만들기</h3>
<p>이제 드디어 아이템을 만들 차례다! 게임의 긴장감과 재미를 높여주는 아주 소중한 존재긴 하지만 사실 어려운 부분은 위에서 다 했으니 이 녀석 정도는 아주 간단히 구현할 수 있다. 차근차근 구현을 해보자.</p>
<h4>아이템 스프라이트</h4>
<p>먼저 아이템들의 이미지를 스프라이트로 정의해두자. 스크립트 맨 위에 정의했던 <code>SpriteDefs</code> 에 아래 내용을 추가한다.</p>
<pre><code>"item": [ { x: 160, y: 80, w: 50, h: 50, origin: { x: 25, y: 25 } }, { x: 210, y: 80, w: 50, h: 50, origin: { x: 25, y: 25 } }, { x: 300, y: 0, w: 40, h: 40, origin: { x: 20, y: 20 } }, { x: 300, y: 40, w: 40, h: 40, origin: { x: 20, y: 20 } }, { x: 300, y: 80, w: 40, h: 40, origin: { x: 20, y: 20 } }, { x: 300, y: 120, w: 40, h: 40, origin: { x: 20, y: 20 } }, { x: 300, y: 160, w: 40, h: 40, origin: { x: 20, y: 20 } }, { x: 300, y: 200, w: 40, h: 40, origin: { x: 20, y: 20 } }, { x: 160, y: 260, w: 40, h: 40, origin: { x: 20, y: 20 } } ]</code></pre>
<p>그리고 <code>AnimationDefs</code>에도 아래 내용을 추가하자.</p>
<p> "item": { 'potion': [{ frame: 0, duration: 1 }], 'mana': [{ frame: 1, duration: 1 }], 'coin': [{ frame: 2, duration: 0.1 }, { frame: 3, duration: 0.1 }, { frame: 4, duration: 0.1 }, { frame: 5, duration: 0.1 }, { frame: 6, duration: 0.1 }, { frame: 7, duration: 0.1 }], 'magnet': [{ frame: 8, duration: 1 }] }</p>
<p>사실 물약이나 자석에는 애니메이션이 없지만 동전은 애니메이션이 있으니까, 귀찮으니 다 애니메이션으로 처리하려는 썩은 근성으로 이렇게 됐는데, 이게 께름칙하면 동전만 애니메이션으로 직접 처리하도록 하자 헤헿</p>
<h4>아이템 관리자</h4>
<p>아이템은 한 번에 아주 여러개의 인스턴스가 존재한다. 이걸 각자 다 <code>GameScene</code>의 <code>child</code>로 직접 관리하는 것도 사실 별 상관이야 없겠지만 뭔가 계란 후라이 다섯개를 하는 데 가스렌지 다섯개랑 후라이팬 다섯개를 쓰는 것 같은 찜찜함이 마음 한 구석을 저며오는 것 같지 않은가? 그러니까 아이템들을 모아서 관리해주는 아이템 관리자 클래스를 만들고 아이템 인스턴스들을 이 녀석이 관리하도록 하자. 아이템 관리자가 아이템을 생성하고, 업데이트하고, 효용이 끝난 아이템을 삭제하는 작업을 도맡아서 처리하게 되면 우리는 좀 더 편안한 마음으로 건설적인 미래를 향해 나아갈 수 있겠지? 게다가 각 아이템들이 이미지와 스프라이트시트를 매번 생성하는 것도 비효율적이니 그것도 아이템 관리자가 가지고 있다가 제공해주도록 하자!</p>
<pre><code>class ItemManager extends GameObject { constructor() { super(); this.items = []; this.minX = 0; this.img = new Image(); this.img.src = "images/eclipse_sprites.png"; this.spriteSheet = new SpriteSheet(this.img, SpriteDefs.item); } init(){ super.init(); this.items = []; this.minX = 0; } update(timeDelta) { this.items.forEach((i) => { i.update(timeDelta); // 화면 밖으로 나간 아이템은 제거 대상으로.. if( i.x < this.minX - 50 ) i.destroy = true; }); // 제거 대상인 아이템들을 실제로 제거 this.items = this.items.filter((i) => { return !i.destroy; }); } render(ctx) { let maxX = this.minX + 540; this.items.forEach((i) => { i.render(ctx, maxX); }); } createItem(type, x, y) { // 나중에 여기서 타입별로 아이템을 만들도록 하자 } }</code></pre>
<p>그리고 <code>GameScene</code> 의 생성자와 <code>init</code>에도 당연히 추가해줘야겠지?</p>
<pre><code>// GameScene.constructor 에 추가 this.itemManager = new ItemManager(); this.children.push(this.itemManager); // GameScene.init 에 추가 this.itemManager.init();</code></pre>
<p>눈치 챘을수도 있겠지만 <code>ItemManager.minX</code> 도 게임씬의 업데이트시에 x 좌표값을 넣어줘야 한다. <code>GameScene.update</code>에도 아래 내용을 추가하자.</p>
<pre><code>this.itemManager.minX = this.cameraX - 200;</code></pre>
<p>이럴 줄 알았으면 이것도 다 그냥 공용 인터페이스로 만들어버리는건데... 귀찮지만 이제 와서 별 수 없지.</p>
<h4>아이템 공통 구현</h4>
<p>1편의 게임 영상을 잊었다면 다시 복습하고 오도록 하자. 아이템들이 공통적으로 갖는 특징은 뭐가 있을까? 아이템들은 각각 스프라이트(혹은 애니메이션)을 가지고 있고, 각자 자기 자리를 지키고 있으며, 자기 자리에서 위아래로 둥실둥실 떠있다. 동전을 제외한 아이템들은 화면 밖에 있는 동안은 자기 높이를 말풍선으로 표시한다. 또, 캐릭터와 부딪히는 순간 아이템은 사라지고 각 아이템에 걸맞는 효과가 캐릭터에 반영된다. 각 효과는 아이템마다 다르지만 그 외의 것들은 공통이다. 그럼 공통되는 부분을 모아서 일단 클래스를 만들어보자.</p>
<pre><code>class Item extends GameObject { constructor(x, y, anim) { super(); this.x = x; this.originY = y; // 원래의 y 좌표 this.ty = 0; // 원래의 y 좌표에서 위아래로 이동한 상대적인 값 this.radius = 20; // 충돌 범위 this.elapsed = 0; this.destroy = false; this.anim = anim; } get y() { // 충돌체크에 편하도록 y 를 그냥 이렇게 얻어갈 수 있도록 하자. return this.originY + this.ty; } update(timeDelta) { super.update(timeDelta); this.elapsed += timeDelta; this.ty = (Math.sin(this.elapsed) * 80) - 40; // -40 ~ 40 까지 오락가락하도록... this.anim.update(timeDelta); } isHit(char){ // 충돌 체크 if( Math.distance(char, this) <= (char.radius + this.radius)){ this.action(); } } render(ctx, maxX) { // maxX 는 화면의 오른쪽 경계를 넘겨받는다 if (this.x > maxX + this.radius*2) { // 아직 화면에 나오기 전이다. 높이를 표시해주자. ctx.save(); ctx.fillStyle = "rgba(255,255,255,0.7)"; ctx.fillRect(maxX - 40, this.y - 20, 30, 40); ctx.fillRect(maxX - 45, this.y - 15, 40, 30); ctx.fillRect(maxX - 5, this.y - 2, 5, 5); this.anim.draw(ctx, maxX - 25, this.y, {scale:0.5}); ctx.restore(); } else { this.anim.draw(ctx, this.x, this.y, {}); // 애니메이션 그려주기 } } action(){ // 아이템의 효과를 나타내는 부분. 각 아이템 종류별로 서로 다른 처리가 필요하다. // 그치만 아이템이 사라진다는 건 공통적이지! this.destroy = true; } }</code></pre>
<h5>아이템 생성 및 표시</h5>
<p>아이템들은 캐릭터가 앞으로 나아감에 따라서 계속해서 생성된다. 그리고 화면 밖으로 지나간 아이템은 삭제된다. 아이템이 화면 내에 있을 때는 화면에 아이템이 표시되어야 한다. 그리고 아이템이 화면 밖에 있는 동안에도 물약이나 자석의 경우 높이가 표시된다. 화면 밖으로 나간 아이템이 삭제되는 부분은 이미 잘 해주고 있으니 나머지를 생각해보자.</p>
<p>아이템은 각각 생성되는 시점이 다르다. 일단 게임을 보면 일정 간격으로 동전 아이템이 늘어서있다. 그리고 그 사이사이에 일정 간격으로 파란 물약/빨간 물약/자석 중 하나가 생겨난다. 우선 아이템을 각각에 맞춰서 생성하는 부분 부터 만들어야겠다.</p>
<p>각각의 아이템은 아래와 같이 정의해주자.</p>
<pre><code>class Potion extends Item { action(){ super.action(); return "jump"; } } class Mana extends Item { action(){ super.action(); return "mana"; } } class Magnet extends Item { action(){ super.action(); return "magnet"; } } class Coin extends Item { action(){ super.action(); return "coin"; } render(ctx){ // 동전은 화면 밖에 있어도 높이를 표시해줄 필요가 없기 때문에 render 를 재정의하자. this.anim.draw(ctx, this.x, this.y, {}); } update(timeDelta){ this.elapsed += timeDelta; this.ty = (Math.sin(this.elapsed) * 10) - 5; // 동전은 예외적으로 위아래 움직임이 작다. this.anim.update(timeDelta); } }</code></pre>
<p>그리고 <code>ItemManager</code>의 <code>createItem</code>메소드를 채워보자. 이 메소드는 사실 하는 일이 별로 없다. 요구받은 위치에 적절한 아이템을 생성해서 <code>items</code>에 넣어주기만 하면 된다.</p>
<pre><code>createItem(type, x, y) { let item = null; switch(type){ case "potion": item = new Potion(x, y, new Animation(this.spriteSheet, AnimationDefs.item.potion)); break; case "mana": item = new Mana(x, y, new Animation(this.spriteSheet, AnimationDefs.item.mana)); break; case "coin": item = new Coin(x, y, new Animation(this.spriteSheet, AnimationDefs.item.coin)); break; case "magnet": item = new Magnet(x, y, new Animation(this.spriteSheet, AnimationDefs.item.magnet)); break; } if( item ) this.items.push(item); }</code></pre>
<p><code>createItem</code> 이 생겼으니 이제 아이템을 생성해볼 수 있겠지? 아이템은 언제 생성해야 할까?</p>
<p>우선 게임이 시작할 때 기본적으로 화면 전체에 아이템이 생성되어 있어야 한다. 그리고 앞으로 갈 때마다 더 앞쪽에 있는 아이템을 계속해서 생성해줘야 캐릭터가 진행하면서 아이템이 끊기지 않고 나오겠지?</p>
<pre><code>init(){ super.init(); this.items = []; this.minX = 0; this.lastItemX = 0; this.coinY = 260; let cnt = 0; let types = ["] while(this.lastItemX < 540 + 100){ this.lastItemX += 80; // 임의의 간격 this.coinY += Math.floor(Math.random() * 50) -25; this.createItem("coin", this.lastItemX, this.coinY); cnt++; if( cnt%10 == 0 ){ let tp = } } }</code></pre>
<p><code>this.lastItemX</code> 라는 변수는 아이템의 최종 생성 위치를 나타내는 쓸모있는 변수다. <code>this.coinY</code>는 동전들을 질서 정연하게 생성하기 위한 칭구다. 얘들을 생성자에도 넣어주자.</p>
<pre><code>/// ItemManager.constructor 에 추가 this.lastItemX = 0; this.coinY = 260;</code></pre>
<p>여기까지 하면 이제 아이템들이 잘 생성되어서 잘 표시되는 것을 볼 수 있다. 꺅 뿌듯행!</p>
<h5>충돌 체크</h5>
<p>하지만 캐릭터가 아이템에 닿아도 아무 일도 일어나질 않는다. 이래선 곤난하지.. 아이템과 캐릭터의 충돌 처리를 해주도록 하자. 먼저 아이템 클래스에 충돌 처리를 하는 메소드를 만들자.</p>
<pre><code>// Item 클래스에 추가 // 캐릭터를 인자로 받아서 아이템이 충돌했는지 확인한다. // 충돌했으면 캐릭터에 이 아이템의 효과를 전달해준다. // 알다시피 this.action 내에서 이 아이템을 삭제처리하는 부분이 있으니 이정도면 처리는 끗! isHit(char){ if( Math.distance(char, this) <= (char.radius + this.radius)){ // 아이템의 중심점과 캐릭터간의 거리가 둘의 반지름을 합친 것 보다 짧을때.. char.gotItem(this.action()); // 캐릭터에게 아이템 효과를 적용 } }</code></pre>
<p>캐릭터에 <code>gotItem</code> 이라는 메소드가 없지만 이건 조금 있다가 만들기로 하고 이어서 <code>ItemManager</code>에 충돌체크를 추가하자</p>
<pre><code>// ItemManager 클래스에 추가 checkCollision(char){ // 캐릭터와 충돌을 판정 this.items.forEach((i)=>{ i.isHit(char); }); }</code></pre>
<p>그리고 나서 이제 <code>GameScene.update</code> 에서 이 메소드를 호출해주면 되겠지? <code>GameScene.update</code>에 아래 내용을 추가하자.</p>
<pre><code>this.itemManager.checkCollision(this.character);</code></pre>
<p>이제 캐릭터의 <code>gotItem</code> 메소드를 만들자</p>
<pre><code>// Character 클래스에 추가 gotItem(item){ switch(item){ case "jump": // 점프 물약만 먼저 구현해보자. this.pivot = null; this.force.y -= 8; this.force.x += 10; break; case "mana": break; case "magnet": break; case "coin": break; } }</code></pre>
<p>이렇게 구현하고 다시 게임을 실행해보면 이제 아이템이 먹어지고, 빨간 물약을 먹으면 냅다 점프하는 걸 볼 수 있다.</p>
<h4>아이템별 구현</h4>
<p>각 아이템들은 서로 다른 효과를 나타낸다. 이 중에 점프 물약은 이미 구현이 완료되었으니 내버려두고, 나머지 아이템들의 구현을 생각해보자.</p>
<h5>동전</h5>
<p>동전은 소지금을 올려주면 된다. 아직 소지금을 쓸 데가 없긴 하지만 그게 뭐 중요한가? 로직도 단순하다. <code>Character</code> 클래스에 <code>money</code> 라는 멤버 변수를 추가하고 동전을 먹었을 때 올려주기만 하면 된다.</p>
<pre><code>// Character 클래스의 생성자와 init 메소드에 추가 this.money = 0; // Character 클래스의 gotItem 메소드 중 coin 부분에 추가 this.money += 100;</code></pre>
<h5>마나포션</h5>
<p>파란 물약은 마나 포션이다. 그런데 우리는 마나 같은거 안 키우고 있다. 여기서 이 게임의 마나가 어떤건지를 먼저 살펴보자.</p>
<p>이 게임에서 캐릭터가 줄을 던질 수 있는 횟수는 마나에 의존한다. 줄을 던질 때 마다 마나를 소모하고, 마나가 다 떨어지면 줄을 던질 수 없다. 그래서 유저는 마나 포션을 잘 먹으면서 이동해야 한다. 따라서 이 게임의 긴장감은 땅에 부딪히지 않는 것과, 마나가 다 떨어지지 않도록 마나포션을 잘 챙겨 먹는 것 두 가지에서 오게 된다. 그럼 위와 같은 내용을 어떻게 구현할까?</p>
<p>우선 캐릭터에 마나를 나타내는 멤버 변수를 추가하도록 하자. 마나 포인트의 줄임말인 <code>mp</code> 라고 쓰도록 하겠다.</p>
<pre><code>// Character 클래스의 생성자와 init 에 추가 this.mp = 10;</code></pre>
<p>그리고 <code>gotItem</code> 에서 마나 물약에 대한 효과를 추가하자. 일단 물약을 하나 먹을 때마다 3씩 채워주도록 하자.</p>
<pre><code>// Character 클래스의 gotItem 에 추가 this.mp += 3;</code></pre>
<p>그리고 줄을 던질 때 마다 <code>mp</code> 를 소모시키고, <code>mp</code>가 없을 때는 줄을 던지지 못하게 하자. <code>Character.setPivot</code>메소드를 아래처럼 변경하면 된다.</p>
<pre><code>setPivot(point){ if(this.pivot === null && this.mp > 0){ // 줄이 안 걸려있고 mp 도 있어야 줄을 건다. this.mp--; // 이하 생략</code></pre>
<p>이걸로 마나포션은 간단히 구현 완료!</p>
<p>그런데 마나가 없는 상태에서 줄에 매달려 있을 때 점프포션을 먹을 경우 날아가긴 하는데 더이상 줄을 뻗을 수 없어서 죽게 되는 문제가 있다. 점프 포션을 먹었을때도 한 번은 줄을 뻗을 수 있도록 mp+1 을 해주도록 하자.</p>
<pre><code>// gotItem 의 jump 부분에 추가 this.mp++;</code></pre>
<h5>자석</h5>
<p>이 게임의 가장 중요한 아이템인 자석 차례다. 다들 알고 있겠지만 자석은 일정시간동안 주변의 모든 아이템을 캐릭터쪽으로 끌어당기는 역할을 한다. 이걸 어떻게 구현하면 좋을까? 그리고 자석 효과가 발동된 동안을 어떻게 사용자에게 보여줄 수 있을까? 먼저 캐릭터에 현재 자석아이템이 활성화 상태인지 나타내는 변수를 만들자.</p>
<pre><code>// Character.construct 와 init 에 추가 this.magnet = 0; // 자석 효과가 남은 시간을 나타낸다.</code></pre>
<p>그러면 일단 자석의 아이템 효과는 간단히 넣을 수 있다. 단순히 자석 지속 시간을 3초로 바꿔주면 된다.</p>
<pre><code>// Character.gotItem 의 magnet 부분에 추가 this.magnet = 3;</code></pre>
<p>그냥 3으로만 해주면 영원히 3인채로 자석이 적용되어버릴테니 <code>character.update</code>에서 아래처럼 자석의 지속시간을 지속적으로 줄여주자.</p>
<pre><code>this.magnet = Math.max(0, this.magnet - timeDelta);</code></pre>
<p>이제 자석을 먹고 지속시간까지 잘 적용했지만 그게 눈에 보이질 않으니 도무지 잘 되고 있는지를 알 수가 없다. 자석의 효과가 지속되는 동안 자석 표시를 해주도록 하자. 지난 번에 추가했던 <code>AnimationDefs</code> 에 보면 <code>magnet_field</code>라는 항목이 있다. 요 녀석은 자기장을 표시하는 애니메이션이다. 이걸 <code>magnet</code>이 0보다 큰 동안 계속 표시하도록 하자. <code>Character.render</code> 의 캐릭터를 표시하는 부분 바로 전에 아래와 같은 내용을 추가하자.</p>
<pre><code>if( this.magnet > 0 ) { this.animations['magnet_field'].draw(ctx, this.x, this.y, {}); }</code></pre>
<p>그리고 자기장 애니메이션이 움직일 수 있도록 <code>Character.update</code>에도 아래 내용을 추가해주자.</p>
<pre><code>this.animations['magnet_field'].update(timeDelta);</code></pre>
<p><img alt="" src="https://lazygyu.net/images/blog/magnet_170131.png_1485795745.png" /></p>
<p>이제 다시 게임을 실행해서 자석을 먹어보면 자기장이 캐릭터 주위에 물결치는 모습을 볼 수 있다. 그치만 자기장만 움직이면 뭘 하나... 아이템들이 딸려오질 않는데... 아이템들을 어떻게 딸려오게 할까? 아이템을 모조리 관리하는 <code>ItemManager</code>에서 해주면 간단하겠지? 하지만 <code>ItemManager</code>는 캐릭터가 현재 자석을 먹은 상태인지 아닌지를 알 방법이 없다. 그치만 뭐 간단한 문제다. <code>update</code>에다가 캐릭터를 넘겨주면 되겠지? 물론 <code>checkCollision</code>메소드는 이미 캐릭터를 넘겨받고 있으니 거기서 해주면 되지 않겠냐고 생각할 수 있겠지만 그건 너무 근본없어 보인다는 단점을 제외하고도 <code>timeDelta</code>를 받을 수 없다는 문제점까지 있다. <code>GameScene</code>의 <code>update</code>를 아래와 같이 고쳐주자.</p>
<pre><code>// super.update(timeDelta) 줄을 삭제하고 아래 내용으로 대체한다. this.elapsed += timeDelta; this.children.forEach((ch)=>{ ch.update(timeDelta, this.character); // update에 캐릭터를 넘겨주긔 });</code></pre>
<p>그리고 <code>ItemManager.update</code>에서는 캐릭터를 받아서 자석에 대한 처리를 해주도록 하자.</p>
<pre><code>update(timeDelta, char) { let inMagnet = char.magnet > 0; // 현재 자석상태인지 this.items.forEach((i) => { i.update(timeDelta, inMagnet); if( inMagnet ){ // 자석처리 i.originY = i.y; i.ty = 0; let ang = Math.atan2(char.y - i.y, char.x - i.x); //각도를 구해서 let pt = Math.getPoint(i, ang, 540 * timeDelta); //해당 각도로 가까워진 지점에 i.x = pt.x; //아이템의 좌표를 이동시켜준다. i.originY = pt.y; } // 화면 밖으로 나간 아이템은 제거 대상으로.. if (i.x < this.minX - 50) i.destroy = true; }); /// 이하 생략</code></pre>
<p><code>item.update</code>에 <code>inMagnet</code> 을 넘겨주는데 <code>item.update</code>에는 받아주는 부분이 아직 없다. 이 부분도 만들어주자.</p>
<p><code>item.update</code>를 아래처럼 바꿔주면 된다. 이런 처리가 필요한 이유는 자석에 끌리는동안은 위아래로 움직여서는 안되기 때문이다. 이걸 안해주면 아이템들이 자석에 끌려오지 않고 널뛰기를 하게 된다.</p>
<pre><code>update(timeDelta, magnet) { super.update(timeDelta); this.elapsed += timeDelta*2; if( magnet ){ this.ty = 0; this.elapsed = 0; } else this.ty = (Math.sin(this.elapsed) * 80) - 40; // -40 ~ 40 까지 오락가락하도록... this.anim.update(timeDelta); }</code></pre>
<p>물론 까먹지 말고 <code>coin</code>에서 재정의한 <code>update</code>에도 같은 코드를 넣어주자.</p>
<p>정말 피곤한 일이었지만 이걸로 아이템까지 드디어 만들고야 말았다! 해냈엉!</p>
<p>그럼 여기까지 만들면서 빼먹은 사소한 것들을 다듬고 넘어가도록 하자.</p>
<h3>캐릭터의 동작들</h3>
<h4>MP가 오링났옹!</h4>
<p><img alt="" src="https://lazygyu.net/images/blog/empty_170131.png_1485795733.png" /></p>
<p>우리의 캐릭터는 이제 MP 를 가지고 있다. 그런데 MP가 다 떨어지는 걸 현재로서는 알 방법이 없다. 나중에 UI를 만들면서 남은 MP를 보여주는 것도 만들겠지만, 게임이니까 캐릭터의 모습에서 직관적으로 알 수 있는 방법이 있으면 더 좋겠지? mp가 없을 때는 평소와 달리 허우적대며 떨어지는 모습으로 애니메이션을 바꾸도록 하자.</p>
<pre><code>// Character.update의 if (this.pivot === null) { 아래를 아래처럼 this.currentAnimation = (this.mp==0)?"fall":"spin"; // mp 가 없을 때는 fall 로 바꾸자.</code></pre>
<h4>공중제비를 돌고싶옹!</h4>
<p>그러고보면 캐릭터가 공중에 있을 때는 웅크린 모션인데 빙글빙글 돌면 더 좋을 것 같다. 캐릭터에 <code>rotation</code> 이라는 변수를 추가하고 이걸로 캐릭터를 돌려주자.</p>
<pre><code>// Character의 생성자와 init 에 추가 this.rotation = 0;</code></pre>
<p>그리고 <code>update</code>에서 이 변수를 야금야금 변경시키자.</p>
<pre><code>// pivot 이 null 일때에 추가 this.rotation += -360 * timeDelta;</code></pre>
<p>왜 그냥 360 이 아니고 -360이냐면, 양수를 주면 시계방향으로 돌아가기 때문이다. 그러면 이상하잖아? 마지막으로 <code>Character.render</code>를 수정해서 rotation 을 적용해주자.</p>
<pre><code>this.animations[this.currentAnimation] .draw(ctx, this.x, this.y, {rotate:(this.currentAnimation=='spin')?this.rotation:0});</code></pre>
<p>그러면 이제 우리의 캐릭터가 빙글빙글 정신사납게 돌아가는 것을 볼 수 있다.</p>
<h4>저 하늘의 별이 될 고 같옹!</h4>
<p>캐릭터가 너무 높이 올라가면 화면에 캐릭터의 모습이 보이지 않는다. 그치만 이래서는 언제 떨어질지도 모르는 불안한 상태가 계속 이어지는 단점이 있다. 캐릭터가 너무 높이 올라갔을때는 캐릭터의 높이를 표시해주자. 아이템에 썼던 말풍선과 비슷한 방법으로 해주면 되니까 간단하겠지?</p>
<p><code>Character.render</code> 에서 처리해주도록 하자. 바로 위에서 고쳤던 부분을 다시 아래와 같이 고쳐주자.</p>
<pre><code>if( this.y < -20 ){ ctx.save(); ctx.translate(this.x, 0); ctx.fillStyle = "rgba(170,0,0,0.8)"; ctx.fillRect(-35, 10, 70, 30); ctx.fillRect(-30, 5, 60, 40); ctx.fillRect(-2, 0, 5, 5); ctx.fillStyle = "white"; ctx.textAlign = "center"; ctx.font = "bold 16px sans-serif"; ctx.fillText(Math.abs( (this.y/10)|0 ) + "m", 0, 30); ctx.restore(); }else{ this.animations[this.currentAnimation] .draw(ctx, this.x, this.y, {rotate:(this.currentAnimation=='spin')?this.rotation:0}); }</code></pre>
<h4>솔직히 이제 필요 없잖아?</h4>
<p>그동안 나름대로 도움이 되었지만 이제는 필요가 없어진 캐릭터의 원과 막대기들을 그리는 코드들을 깔끔하게 삭제해 치우도록 하자. 아 상쾌해!</p>
<h4>그대는 너무 빨라요</h4>
<p>우리의 캐릭터는 넘나 조신하지만 빨간 물약 한두개만 먹으면 발정난 망아지마냥 끝도없이 넘나 빨라지는 문제가 있다. 세상엔 공기로 가득한데 어째서 우리의 캐릭터는 이렇게 끝간데를 모르고 가속하기만 하는걸까? 공기 저항이 얼마나 무서운건지 맛을 보여주도록 하자.</p>
<p><code>Character.update</code>의 pivot 이 null 인 경우의 코드에 아래 내용을 추가하자.</p>
<pre><code>this.force.x *= 0.99;</code></pre>
<p>그러면 이제 아래와 같은 모양새가 되겠지? jsfiddle 이 너무 스크롤을 퍼먹는 것 같아서 이번엔 codepen을 이용해봤다. 헤헿</p>
<p>
    <p data-height="600" data-theme-id="0" data-slug-hash="BpJxBo" data-default-tab="result" data-user="lazygyu" data-embed-version="2" data-pen-title="BpJxBo" data-preview="true" class="codepen">See the Pen <a href="https://codepen.io/lazygyu/pen/BpJxBo/">BpJxBo</a> by LazyGyu (<a href="http://codepen.io/lazygyu">@lazygyu</a>) on <a href="http://codepen.io">CodePen</a>.</p>
    <script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
</p>
<p>그럼 이번 편도 여기까지에서 접고 다음편에는 게임에 MSG를 쳐보도록 하자. 깜찍한 이펙트와 사운드를 입히면 게임이 한층 더 게임같아질 거다.</p>
<p><a href="http://lazygyu.net/blog/html5_js_minigame_tutorial6">다음 글 : Swing my baby 를 통해 보는 HTML5 게임 개발(6)</a> </p> ]]></content:encoded>
<link>https://lazygyu.net/blog/html5_js_minigame_tutorial5</link>
<category><![CDATA[ HTML5 게임 개발 튜토리얼 ]]></category>
<pubDate>Tue, 31 Jan 2017 02:00:00 +0900</pubDate>
<guid>https://lazygyu.net/blog/html5_js_minigame_tutorial5</guid>
</item>
<item>
<title><![CDATA[ HTML5 미니게임 개발 튜토리얼 4 ]]></title>
<description><![CDATA[ 이번에는 드디어 캐릭터를 죽여볼 차례가 왔다! 으흐흐흫 지난 편에 왠지 소스코드로 너무 때우는거 아니냐는 지적이 있어서 이번에는 jsfiddle 인용을 되도록 줄여서 가보도록 하자... ]]></description>
<content:encoded><![CDATA[ <h1>HTML5 미니게임 개발 튜토리얼</h1>
<p><a href="http://lazygyu.net/blog/html5_js_minigame_tutorial3">이전 글 : Swing my baby 를 통해 보는 HTML5 게임 개발(3)</a><br/>현재 글 : Swing my baby 를 통해 보는 HTML5 게임 개발(4)<br/><a href="http://lazygyu.net/blog/html5_js_minigame_tutorial5">다음 글 : Swing my baby 를 통해 보는 HTML5 게임 개발(5)</a></p>
<p><img alt="" src="https://lazygyu.net/images/blog/title.png_1483110633.png" /></p>
<p>드디어 4편... 이번에는 드디어 캐릭터를 죽여볼 차례가 왔다! 으흐흐흫</p>
<p>지난 편에 왠지 소스코드로 너무 때우는거 아니냐는 지적이 있어서 이번에는 jsfiddle 인용을 되도록 줄여서 가보도록 하자...</p>
<h2>개발 과정</h2>
<p>지난 시간까지 우리는 캐릭터가 줄을 걸고 앞으로 나아가는 데 까지를 만들었다. 이제는 우리의 캐릭터가 헤딩할 맨 땅을 만들어보자.</p>
<h3>지형 만들기</h3>
<h4>일단 땅바닥을 그려보자</h4>
<p>1편에서 게임 영상을 봤다면 기억하고 있겠지만 우리의 게임은 그냥 검은색의 산맥같은 땅을 가지고 있다. 이건 단순히 그리기 편하기 때문이지만, 배경을 잘 깔아뒀으니 그다지 어색하지는 않을것이다. 헤헿. 다른 플랫폼(예를 들어서 GBA라던지...하...)이었다면 이런 방법을 쓰기 어렵지만 우리는 HTML5 캔버스를 쓰고 있으니 간단히 다각형을 그려서 속을 채워줄 수 있다. 이런 좋은 API 를 그냥 썩힐 필요는 없으니 적극적으로 사용해보자.</p>
<p>일단 지형을 어떤 자료구조로 표현할지를 결정해야 한다.</p>
<p><img alt="" src="https://lazygyu.net/images/blog/dots_terrain_170111.png_1484585998.png" /></p>
<p>우리의 지형은 대충 저런 그래프와 같은 모양이기 때문에 각 점의 좌표들만 보관하면 된다. 게다가 x축은 일정한 간격이기 때문에 실제로는 각 점의 y축 좌표만 가지고 있어도 단순히 지형을 그려주는 데는 아무런 문제가 없다. 다만 각 점의 x 좌표도 보관해야 나중에 지형을 가지고 이것 저것 쉽게 해볼 수 있으니까 그 점을 염두에 두고 지형 자료 구조는 <code>{x:x좌표, y:y좌표}</code>형태의 객체를 가진 배열로 결정하자.</p>
<p>이 지형을 그려줄 게임 객체인 지형 클래스를 먼저 만들어보자.</p>
<pre><code>class Terrain extends GameObject { constructor(){ this.points = []; //현재 지형 좌표를 보관할 배열 this.tileWidth = 540 / 50; /* x 축 간격을 화면 크기의 50분의 1로 정한다. 그러면 한 화면에는 좌표가 50개 그려지게 된다. 이 값을 늘릴수록 세밀한 지형 표현이 가능하지만 귀찮다. */ this.fillStyle = "black"; // 지형 색 } init(){ this.points = []; } update(timeDelta){ } render(ctx){ // 아래는 현재 지형 배열을 그려주는 코드.. 내용은 별 거 없다. ctx.save(); ctx.fillStyle = this.fillStyle; ctx.beginPath(); ctx.moveTo(this.points[0].x, this.points[0].y); this.points.forEach((pt)=>{ ctx.lineTo(pt.x, pt.y); }); ctx.lineTo(this.points.last().x, 540); ctx.lineTo(this.points[0].x, 540); ctx.fill(); ctx.restore(); } }</code></pre>
<p>자, 이렇게 하면 땅바닥을 그릴 수 있다... 그치만 그릴 땅바닥이 없잖아? 땅바닥을 어떻게 만들면 좋을까? 이제부터 고민해보자.</p>
<h4>랜덤으로 생성되는 지형?</h4>
<p>우선 가장 속편한 방법은 역시 랜덤이다. 까이꺼 대에에에충 랜덤으로 그려보면 어떨까?</p>
<h5>무작위 지형은 도무지 땅같지 않다</h5>
<p><img alt="" src="https://lazygyu.net/images/blog/random_terrain_170112.png_1484586013.png" /></p>
<p>테스트 삼아 랜덤으로 땅을 그려보면 이렇게 된다..... 물론 이렇게 된다고 게임을 못 하는 건 아닌데 그래도 이건 좀....</p>
<h5>지형은 어느정도 손으로 미리 정의해야 한다.</h5>
<p>결국 땅이 땅같아 보이도록 손으로 매만져 줄 수 밖에 없다. </p>
<p>지형을 몇개의 덩어리로 미리 정의해놓고 덩어리들을 계속 붙여서 지형을 이어가면 그럴싸한 땅을 만들 수 있게 된다. 우선은 아까 만든 <code>Terrain</code> 객체를 <code>GameScene</code>에 추가하고 진행하자. 이제 많이 해봐서 알겠지만 <code>GameScene.constructor</code>메소드를 아래와 같이 고쳐주면 된다.</p>
<pre><code>constructor(){ super(); this.character = new Character(); this.background = new Background(); this.terrain = new Terrain(); this.children.push(this.background); this.children.push(this.terrain); this.children.push(this.character); }</code></pre>
<p>그리고 <code>GameScene.init</code> 메소드에도 아래 줄을 추가하고</p>
<pre><code>this.terrain.init();</code></pre>
<p><code>GameScene.update</code>에서는 지난번에 배경에 했던것처럼 x 좌표를 넘겨주자.</p>
<pre><code>this.terrain.lastX = this.cameraX - 200;</code></pre>
<p>물론 그냥 둬도 괜찮지만 그러면 나쁜 어린이니까 <code>Terrain.init</code>에도 저 변수를 넣어줘야겠지?</p>
<pre><code>this.lastX = 0;</code></pre>
<p>이렇게 하면 일단 기본적으로 지형이 그려질 준비는 끝났다능!</p>
<p>그럼 우선 지형을 몇 개 미리 준비해보자.</p>
<p><img alt="" src="https://lazygyu.net/images/blog/terrain_making_170111.png_1484586024.png" /></p>
<p>x축 거리가 일정하므로 x축은 신경쓰지 말고 위 그림처럼 y 축의 변화만 신경써서 모양을 배열에 표현해보도록 하자. 낮은 지형과 높은 지형을 골고루 준비하되 각 지형들이 부드럽게 연결될 수 있도록 지형들의 시작과 끝의 y 값은 비슷해야 좋겠지?</p>
<p>그럼 이런식으로 프리셋을 몇 개 준비해보자. 이건 어차피 상수니까 그냥 클래스 밖에다가 선언해버릴거야!</p>
<pre><code>const tileSets = [ [5, 5, 6, 7, 6, 5], [5, 10, 15, 15, 10, 8], [5, 10, 15, 15, 18, 20, 16, 8], [5, 8, 11, 14, 17, 20, 30, 20, 10], [5, 30, 32, 34, 36, 30, 20], [5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 45, 40, 30, 20, 10], [5, 20, 40, 60, 70, 80, 80, 70, 60, 50, 40, 30, 20, 10], [5, 15, 20, 25, 30, 35, 50, 60, 70, 80, 90, 100, 100, 100, 90, 70, 50, 30, 10], [20,30,40,50,60,80,100,120,140,160,180,200,200,201,201,202,202,200,198,197 ,198,200,80,60,40,20], [5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 70, 90, 110, 130, 150, 170, 190, 210, 200, 190, 180, 170, 160, 150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10] ];</code></pre>
<p>그럼 이제 이렇게 미리 선언해 둔 타일들을 실제로 추가하는 로직을 만들어봐야겠지? 타일을 추가할 때는 어떤 순서로 진행해야 할지 생각해보자.</p>
<ol>
    <li>현재 points 배열의 길이가 화면 전체 폭(<code>tileWidth = 540/50</code> 이니까 배열 길이가 50개가 되어야 화면 폭만큼이 되겠지?)보다 작을 경우 타일 추가 루틴을 실행한다.</li>
    <li>배열 길이가 50보다 커질때까지</li>
    <li>타일 셋에서 랜덤하게 골라서 현재 타일 배열 뒤에 붙인다.
        <ol>
            <li>붙일때는 x 좌표를 잘 계산해서 붙이도록 하자.</li>
        </ol>
    </li>
</ol>
<p>3-1번을 위해서 <code>Terrain.init</code> 메소드에 변수를 하나 더 추가하자.</p>
<pre><code>this.maxX = 0;</code></pre>
<p>이 변수로 뭘 할거냐면, 매번 points 에 좌표를 하나씩 추가할 때마다 여기다가 tileWidth 를 더해줄 예정이다. 그러면 지금 당장 추가해야 할 좌표의 x 값을 쉽게 구할 수 있겠지? 그럼 함 구현을 해보자..</p>
<pre><code>addTile(){ while(this.points.length <= 55){ let src = tileSets[ Math.floor(Math.random()*tileSets.length)|0 ]; src.forEach((y)=>{ this.maxX += this.tileWidth; this.points.push({x:this.maxX, y:540-y}); }); } }</code></pre>
<p>왜 <code>while</code>문의 조건이 50이 아니라 55 이하냐면, 50개로 딱 떨어지면 화면 바로 밖의 포인트가 삭제되기 때문에 양쪽 가장자리의 지형이 뭉개지게 되기 때문이다.</p>
<p><img alt="" src="https://lazygyu.net/images/blog/edge_170111.png_1484586034.png" /></p>
<p>그럼 이제 이 메소드를 언제 호출해야 할까? 바로 위 <code>while</code>문의 조건처럼 <code>points.length</code>가 55보다 작아졌을때겠지? 그치만 이렇게 추가만 하고 제거를 안 하면 한 번 추가한 후에는 조건을 만족시킬 일이 없게 되니까 화면에서 이미 지나간 지점들을 지워주는 코드까지 함께 작성해야 한다.</p>
<p>그럼 이 내용들을 모두 넣어서 <code>Terrain.update</code>를 아래처럼 바꿔보자.</p>
<pre><code>update(timeDelta){ super.update(timeDelta); this.points = this.points.filter((pt)=>{ return pt.x + this.tileWidth > this.lastX; }); if( this.points.length < 55 ) this.addTile(); }</code></pre>
<p><code>filter</code> 메소드의 내부의 조건은 화면의 좌측 밖으로 <code>tileWidth</code>이상 지나간 좌표만 제거한다는 내용이다. 그리고 나서 다시 게임을 실행해보면 이제 정상적으로 지형이 흘러가는 것을 볼 수 있다. 우리는 흘러가는 코드를 별도로 넣진 않았는데? 그야 우리는 카메라를 캐릭터 따라 계속 앞으로 이동하고 있으니까 제자리에 그려도 자연히 흘러가게 될 수 밖에.. 초반에 코드 양이 적어지니까 카메라를 옮기는 게 편하다고 했던 부분 기억하겠지? 대충 되는대로 둘러댄 말이었지만 이쯤 되면 그게 다 큰 그림의 치밀한 설계였다고 우겨도 괜찮을 것 같다.</p>
<h4>충돌 체크</h4>
<p>그럴싸하게 움직이는 지형까지 만들어서 겉보기엔 좋아보이지만 아직도 우리의 캐릭터는 줄을 놓으면 저 깊은 무저갱으로 떨어지기만 할 뿐 죽지를 않는다. 이제 캐릭터를 한 번 죽여보자. 이 게임에서 캐릭터가 죽는 유일한 방법은 바로 땅과 부딪히는 것 뿐이다. 드디어 충돌체크를 만들어야 할 때가 오고 만 것이다!(두둥!)</p>
<p>캐릭터가 지형과 부딪히는 경우는 두 가지다. 캐릭터가 지형의 경계선에 닿았거나, 캐릭터가 지형의 내부에 들어갔거나. 그럼 이 두가지 경우에 대해 각각 알아보자.</p>
<h5>캐릭터와 어떤 점 간의 충돌</h5>
<p>캐릭터에겐 x,y 좌표가 있다. 캐릭터의 픽셀을 정밀하게 판별해서 충돌체크를 하는 방법도 있지만, 이 게임에 그정도의 정밀한 처리는 사실 필요 없다. 간단히 캐릭터의 중심점에서 일정 거리 이내로 들어오면(바꿔 말해서 캐릭터를 하나의 원 모양으로 가정하고 해당 원 안으로 대상 점이 들어오면) 충돌했다고 판단할 수 있다. </p>
<p><img alt="" src="https://lazygyu.net/images/blog/collision1_170114.png_1484586045.png" /></p>
<p>예를 들어 캐릭터에 아래와 같은 변수를 추가하고</p>
<pre><code>this.radius = 20;</code></pre>
<p>아래와 같은 메소드로 간단히 캐릭터와 어떤 원형 물체 간의 충돌을 감지할 수 있다.</p>
<pre><code>isHit(x, y, r){ // x, y 좌표와 반지름을 받거나 // 그냥 x,y,r 혹은 x,y,radius 를 가진 객체를 받아서 충돌 여부를 반환 if( typeof x === 'number'){ return Math.distance(this, {x:x, y:y}) < r+this.radius; }else{ return Math.distance(this, x) < (x.r||x.radius) + this.radius; } }</code></pre>
<p>하지만 지형은 점이 아니다. 어떻게 해야 할까?</p>
<h5>어떤 점과 다각형의 거리</h5>
<p>지형은 다각형이다. 다각형과 캐릭터의 거리가 <code>radius</code>보다 작으면 다각형과 캐릭터는 충돌했다고 볼 수 있다. 그럼 다각형과 캐릭터의 거리는 어떻게 구할까?</p>
<p>다각형은 선분의 집합이고, 선분은 두 점으로 이루어진다. 어떤 점과 캐릭터의 거리를 구하는 방법은 이미 알고 있으니 이번에는 어떤 선과 캐릭터의 거리를 구해보도록 하자. </p>
<p>어떤 점이 선분의 범위 안에 있을때(선분과의 수선이 존재할 때)에는 수선의 길이가 곧 선과의 거리가 된다. 그 외의 경우에는 양쪽 점과의 거리 중 짧은 쪽이 점과 선분과의 거리다. </p>
<p><img alt="" src="https://lazygyu.net/images/blog/line_distance_170114.png_1484586056.png" /></p>
<p>그럼 이부분을 구현해보자.</p>
<pre><code>Math.distanceToLine = function(pt, line){ // 점에서 선분까지의 거리를 구하자 // line 은 [{x:x1,y:y1}, {x:x2, y:y2}]다. let lineLength = Math.distance(line[0], line[1]); if( lineLength == 0 ) return Math.distance(pt, line[0]); // 길이가 0인 선분과의 거리는 깔끔 let prj = ((pt.x-line[0].x)*(line[1].x-line[0].x)+(pt.y-line[0].y)*(line[1].y-line[0].y))/lineLength; // 그림의 pt2와 같은 경우면 P1과의 거리를 if( prj < 0 ) return Math.distance(pt, line[0]); // P2와 더 가까울 때(수선이 없을 때)는 P2와의 거리를 if( prj > lineLength ) return Math.distance(pt, line[1]); // 그 외에는 노멀 벡터의 길이를 반환하면 된다 return Math.abs(-(pt.x-line[0].x)*(line[1].y-line[0].y) + (pt.y - line[0].y)*(line[1].x-line[0].x))/lineLength; }</code></pre>
<p>그럼 이제 다각형의 각 선분과 캐릭터의 거리를 구해서 그게 캐릭터의 반지름보다 작으면 충돌이라는 걸 알 수 있겠지? 깔끔!</p>
<h5>어떤 점이 다각형 내에 포함되었는지 여부</h5>
<p>하지만 캐릭터가 지형 속으로 쑥 들어가버린 경우에는 위 방법으로 충돌 체크가 안 될 수도 있다. </p>
<p><img alt="" src="https://lazygyu.net/images/blog/inside_poly_170115.png_1484586068.png" /></p>
<p>그러므로 우리는 어떤 점이 다각형 내부에 있는지도 판별해 보도록 하자!</p>
<p>어떤 점이 다각형의 안에 있는지 밖에 있는지를 판별하는 방법은 의외로 종류가 많다. 하지만 우리 게임에서는 아주 간단한 방식으로 이 부분을 해결해보기로 하자.</p>
<p>기본적인 아이디어는 이렇다. 현재 캐릭터가 있는 점에서 왼쪽으로 수평선을 긋는다. 그렇게 그은 수평선과 지형의 외곽선이 교차하는 횟수를 세서 교차 횟수가 홀수면 캐릭터가 내부에 있고, 짝수거나 0이면 외부에 있다고 보는 거다.</p>
<p><img alt="" src="https://lazygyu.net/images/blog/intersect_170117.png_1484586075.png" /></p>
<p>왼쪽으로 긋는 이유는 그냥 그 쪽이 더 짧기 때문이다. 매 프레임 판별을 해야 하기 때문에 되도록이면 수행량이 적은 방향으로 긋는게 당연히 낫겠지?</p>
<p>선분간의 교차를 구하는 방법도 여러가지가 있지만, 우리는 꼼수를 쓰도록 하자. 캐릭터에서 실제로 왼쪽으로 선을 그을 필요는 사실 없다. 그냥 y 좌표가 겹치는 선분중에서 캐릭터보다 왼 쪽에 있는 선분은 교차점이 있다고 보면 된다.</p>
<p><img alt="" src="https://lazygyu.net/images/blog/check_cross_170117.png_1484586082.png" /></p>
<p>그래서 구현도 간단해진다.</p>
<pre><code>Math.isCross = function(pt, line){ // line1, line2 는 [{x,y}, {x,y}] 형태의 배열 // 우리의 게임에서는 반드시 [0]보다 [1]이 오른쪽에 있게 된다. 따라서 더 간단! if( pt.y > line[0].y != pt.y > line[1].y ){ // y 좌표가 선에 걸쳐질때에만 let atX = (line[1].x-line[0].x)*(line[1].y-line[0].y)/(line[1].y-line[0].y)+line[0].x; if( pt.x > atX ) return true; } return false; }</code></pre>
<p>그럼 이제 지형과 캐릭터의 충돌을 판별하는 메소드도 만들 수 있겠지? <code>Terrain</code> 에 아래와 같은 메소드를 추가하자.</p>
<pre><code>isHit(character){ // 지형을 이루는 각 선분과의 충돌을 체크하자 let firstPoint = {x:this.points[0].x, y:540}; let lastPoint = firstPoint; let hit = false; this.points.forEach((pt)=>{ if( Math.distanceToLine(character, [lastPoint, pt]) < character.radius ){ hit = true; return false; } lastPoint = pt; }); if( hit ) return true; // 혹시 캐릭터가 지형 내부에 있는지도 체크하자 lastPoint = firstPoint; let count = 0, cur = 1; while(lastPoint.x < character.x){ if( Math.isCross(character, [lastPoint, this.points[cur]]) ) count++; lastPoint = this.points[cur]; cur++; } if( count > 0 ) console.log(count); if(count%2 == 0) return false; return true; }</code></pre>
<p> 이 메소드가 잘 작동하는지 확인을 어떻게 해볼까? <code>GameScene.update</code>에 아래와 같은 내용을 추가하자.</p>
<pre><code>if( this.terrain.isHit(this.character) ){ this.terrain.fillStyle = "red"; }else{ this.terrain.fillStyle = "black"; }</code></pre>
<p>이렇게 하면 이제 캐릭터가 지형과 겹쳐질 때마다 지형이 빨갛게 표시된다. 그런데 캐릭터가 화면 아래로 완전히 내려가버리면 오히려 지형은 빨개지지 않고 그대로다. 어째서냐면 거긴 사실 땅이 없기 때문이다. 그치만 이건 의도와는 다르니까 그것도 보정해줘야겠지? 위 코드의 <code>if</code>문 조건을 아래처럼 추가하자</p>
<pre><code>if( this.character.y > 540 || this.terrain.isHit(this.character) ){ this.terrain.fillStyle = "red"; }else{ this.terrain.fillStyle = "black"; }</code></pre>
<p>이번 편에서 아이템 구현까지 나갈 수 있을 줄 알았는데 벌써 분량이 꽉 차고 말았따.. 우선 가볍게 여기까지 만든 걸 보고 다음 편에서는 아이템을 제작해 보도록 하자. 꺅 아이템 짱졓아!</p>
<p>
    <script async src="https://lazygyu.net//jsfiddle.net/kaarjqk4/embed/js,html,result/"></script>
</p>
<p><a href="http://lazygyu.net/blog/html5_js_minigame_tutorial5">다음 글 : Swing my baby 를 통해 보는 HTML5 게임 개발(5)</a></p> ]]></content:encoded>
<link>https://lazygyu.net/blog/html5_js_minigame_tutorial4</link>
<category><![CDATA[ HTML5 게임 개발 튜토리얼 ]]></category>
<pubDate>Tue, 17 Jan 2017 02:33:00 +0900</pubDate>
<guid>https://lazygyu.net/blog/html5_js_minigame_tutorial4</guid>
</item>
<item>
<title><![CDATA[ HTML5 미니게임 개발 튜토리얼 3 ]]></title>
<description><![CDATA[ 지금까지 열심히 줄 타는 캐릭터를 만들었지만, 그냥 지 혼자 흔들거릴 뿐 도무지 재미를 느낄 수가 없었다면 이제 드디어 우리의 캐릭터를 조종해볼 시간이다.  ]]></description>
<content:encoded><![CDATA[ <h1>HTML5 미니게임 개발 튜토리얼</h1>
<p><a href="http://lazygyu.net/blog/html5_js_minigame_tutorial2">이전 글 : Swing my baby 를 통해 보는 HTML5 게임 개발(2)</a><br/>현재 글 : Swing my baby 를 통해 보는 HTML5 게임 개발(3)<br/><a href="http://lazygyu.net/blog/html5_js_minigame_tutorial4">다음 글 : Swing my baby 를 통해 보는 HTML5 게임 개발(4)</a></p>
<p><img alt="" src="https://lazygyu.net/images/blog/edit_%EB%94%94%EC%96%B4%EC%82%AC%EC%9D%B4%EB%93%9C.png_1483636185.png" /></p>
<p>으아 벌써 3편째.... 솔직히 만들떈 대충 슥슥 만들었는데 설명하려니까 이렇게 길어질줄은 몰랐다... 심지어 설명도 대충 적었는데...</p>
<h2>개발 과정</h2>
<p>지금까지 열심히 줄 타는 캐릭터를 만들었지만, 그냥 지 혼자 흔들거릴 뿐 도무지 재미를 느낄 수가 없었다면 이제 드디어 우리의 캐릭터를 조종해볼 시간이다.</p>
<h3>입력 처리</h3>
<p>JS는 기본적으로 이벤트 기반으로 입력을 받는다는 건 알고 있을것이다. 그러므로 입력 이벤트를 받아서 업데이트 루프에서 참조할 수 있도록 전달해주면 되겠지?</p>
<h4>입력 이벤트를 게임 루프와 조합하기</h4>
<p>우선 키보드 입력을 받아줄 변수를 만들자. 보통은 입력 매니저 객체를 만들어서 전체 키 입력을 스캔하는 편이지만 이 게임은 간단하니까 단순히 방금 입력된 키만 보관하면 된다. 우선 오랜만에 보는 게임 객체의 생성자에 입력된 키 값을 보관하는 변수를 추가하자.</p>
<pre><code>this.key = null;</code></pre>
<p>그리고 게임 객체에 키보드 이벤트 핸들러를 만들자.</p>
<pre><code>keyHandler(e){ if( !e.repeat ) this.key = e.keyCode; if( e.keyCode === 32 ){ e.preventDefault(); return false; } }</code></pre>
<p>그리고 다시 생성자로 돌아가서 저 친구를 document 객체에 이벤트 핸들러로 추가해주자.</p>
<pre><code>// this가 뭘 가리키는건지 애매해지지 않도록 바인드해서 넘겨주는 센스 document.addEventListener("keydown", this.keyHandler.bind(this), false);</code></pre>
<p>그러면 이 값에 각 게임장면이 어떻게 접근할 수 있을까? <code>Game.update</code>메소드를 고쳐서 매 업데이트시마다 키값도 함께 넘기도록 하자. 넘기고 나면 쓸모가 없으니 맨 마지막에는 키값을 리셋해주는 걸 잊지 말자. <code>update</code>메소드의 전체는 현재 아래와 같은 모양이 될 것이다.</p>
<pre><code>// 게임 루프용 메소드 // 이 메소드가 매 프레임(1/60초)마다 실행된다. update(){ this.last = this.now; this.now = performance.now(); // 현재 시간 this.timeDelta = (this.now-this.last)/1000; // 지난 프레임과의 경과시간을 초 단위로 환산 this.elapsed += this.timeDelta; // 게임이 시작된 후 경과된 전체 시간 this.ctx.clearRect(0,0,this.canvas.width, this.canvas.height); // 화면을 매 프레임 지워준다. if( this.scenes.length > 0){ // 처리해야 할 장면이 있을 경우에만 this.scenes.last().update(this.timeDelta, this.key); // 활성화된 장면을 갱신 **key를 넘겨주자 this.scenes.last().render(this.ctx); // 활성화된 장면을 그려줌 } this.key = null; requestAnimationFrame(this.update.bind(this)); // 1/60초 후에 다시 실행 }</code></pre>
<p>현재 <code>scene</code> 객체의 <code>update</code>를 호출할 때 경과시간 뒤에 key 를 넘겨주는 부분이 보이는가? 그럼 이제 <code>GameScene</code>의 <code>update</code>에서 저걸 한 번 받아보자. <code>GameScene.update</code> 를 아래처럼 고쳐보자...큭큭큭</p>
<pre><code>update(timeDelta, key){ super.update(timeDelta); if( key === 32 ){ // 스페이스바를 눌렀을 때 this.character.setPivot({x:240, y:0}); } }</code></pre>
<p>그러면 이제 아래와 같은 녀석이 나온다! 이제 드디어 스페이스바로 줄을 걸었다가 놨다가 할 수 있게 되었다 >_
    <</p>
        <p>
            <script async src="https://lazygyu.net//jsfiddle.net/lazygyu/8rfhkj91/embed/"></script>
        </p>
        <h3>배경 만들기</h3>
        <p>아직까지도 썰렁한 흰 화면에 캐릭터만 어슬렁거리니 이거 너무 허전하다. 이제는 화면을 좀 채워줄 때가 됐다!</p>
        <h4>우리는 앞으로 가야 한다</h4>
        <p>1편에서 완성된 게임을 보면 알겠지만 사실 게임 내내 캐릭터의 x축은 변하지 않는다. 대신 배경이 움직인다. 이걸 어떻게 구현하면 좋을까? 일단 간략하게 로직을 정리해보자.</p>
        <ol>
            <li>캐릭터가 앞으로 가면</li>
            <li>캐릭터 대신 배경이 뒤로 간다.</li>
            <li>배경은 한 번 뒤로 가면 캐릭터가 뒤로 간다고 해서 다시 앞으로 가지는 않는다.</li>
            <li>배경은 몇개의 레이어로 이루어져있고, 각 레이어는 스크롤 속도가 다르다.</li>
        </ol>
        <p>그러면 이걸 어떻게 처리하면 좋을까?</p>
        <p>여러가지 방법이 있는데 그 중에 간단한건 두 가지 정도를 생각해볼 수 있다.</p>
        <ol>
            <li>캐릭터의 x 좌표와 관계 없이 캐릭터를 일정한 위치에 그리고 배경을 캐릭터의 x 좌표에 맞춰서 그린다</li>
            <li>화면이 비추는 카메라의 위치를 캐릭터의 x 좌표에 맞추고 그냥 그린다.</li>
        </ol>
        <p>두 개 다 장단이 있긴 한데 코드가 적어지는 2번으로 가보자.</p>
        <h4>카메라 이동하기</h4>
        <p>우선 게임 장면에 카메라의 x 좌표를 보관할 변수를 만들자. <code>init</code> 에다가 살포시 추가하면 된다.</p>
        <pre><code>this.cameraX = 0;</code></pre>
        <p>그리고 <code>update</code> 에서 이 녀석을 갱신해주자</p>
        <pre><code>this.cameraX = Math.max(this.cameraX, this.character.x);</code></pre>
        <p>마지막으로 <code>render</code>에서 카메라를 실제로 이동시켜주면 된다. <code>super.render(ctx);</code> 위에다가 아래 코드를 추가하자.</p>
        <pre><code>ctx.translate(-this.camera.x + 100, 0);</code></pre>
        <p>뜬금없이 튀어나온 +100은 뭐냐면 캐릭터의 왼쪽 여백이다. 캐릭터가 화면 왼쪽에 계속 딱 붙어 있으면 아무래도 보기에도 안 좋고 이상하니까 좌측에서 좀 떨어진 곳으로 고정하는 거.. 왜 화면 중간으로 안 하냐면, 이 게임은 계속 앞으로 가는 게임이니까 캐릭터 뒤쪽은 사실 중요하지 않고 앞쪽이 더 많이 보여야 하기 때문이다.</p>
        <p>여기까지 하고 페이지를 다시 확인해보면 이제 진자에 매달려 앞으로 이동하다 보면 어느 위치 이상은 가지 않는 것을 볼 수 있다. 그런데 다시 점프를 하고 줄을 걸면 줄이 뒤로 걸린다. 우리가 테스트용도로 줄이 걸리는 위치를 고정해버렸기 때문이다. 그럼 이 줄을 현재 위치에 따라 45도 각도로 걸도록 코드를 수정해보자.</p>
        <p><code>GameScene.update</code>에 보면 <code>setPivot</code>을 호출하는 부분이 있다. 여기를 아래처럼 바꿔주자.</p>
        <pre><code>if( key === 32 ){ var tx = Math.cos(Math.PI/4) * this.character.y + this.character.x; this.character.setPivot({x:tx, y:0}); }</code></pre>
        <p>여기까지 하면 아래처럼 이제 앞으로 점프하면서 줄을 걸 수 있게 된다.</p>
        <p>
            <script async src="https://lazygyu.net//jsfiddle.net/lazygyu/eL33st14/embed/"></script>
        </p>
        <h4>원경? 근경? 패럴렉스 스크롤의 이해</h4>
        <p>먼 옛날 3D를 실시간으로 구현하기는 커녕 화면에 뿌려줄 수 있는 색상이 스무개도 안 되던 시절부터 우리의 선배님들은 게임 내에서 입체감을 구현하기 위해 갖은 고민을 해왔다. 그 중에서도 상당히 오래전부터 아주 효과적으로 사용된 방식이 바로 패럴렉스 스크롤이다. 용어는 있어보이지만 간단히 말해서 배경을 여러개의 레이어로 나누고 "가까운 레이어는 빨리 움직이고 먼 레이어는 천천히 움직이는 것"이 바로 패럴렉스 스크롤이다.</p>
        <p>이 게임에서는 배경을 네 개의 레이어로 처리하고 있다.</p>
        <ol>
            <li>움직이지 않는 배경(하늘)</li>
            <li>가장 천천히 움직이는 배경(별1)</li>
            <li>조금 빨리 움직이는 배경(별2)</li>
            <li>더 빨리 움직이는 배경(배경에 있는 산들)</li>
        </ol>
        <p>여기 사용된 배경 이미지들은 아래와 같다.</p>
        <p><img alt="" src="https://lazygyu.net/images/blog/background_170105.png_1483636215.png" /></p>
        <p><img alt="" src="https://lazygyu.net/images/blog/star1_170105.png_1483636223.png" /></p>
        <p><img alt="" src="https://lazygyu.net/images/blog/star2_170105.png_1483636232.png" /></p>
        <p><img alt="" src="https://lazygyu.net/images/blog/mountains_170105.png_1483636238.png" /></p>
        <p>그럼 이 배경들을 어떻게 표시해주면 좋을까? 네 개의 이미지가 있긴 하지만 이 네 개의 이미지 전체를 하나의 게임 오브젝트로 표시하도록 하자. 우선 클래스를 만들어보자.</p>
        <pre><code>class Background{ constructor(){ //이미지들을 로딩하자 let imageUrls = ["background_150105.png", "star1_150105.png", "star2_150105.png", "mountains_150105.png"]; this.images = imageUrls.map((v)=>{ let img = new Image(); img.src = v; return img; }); } init(){ this.x = 0; } render(ctx){ ctx.drawImage(this.images[0], this.x, 0); // 하늘은 움직이지 않으니까 일단 걍 그려주자. } }</code></pre>
        <p><code>render</code>에는 기본적으로 움직이지 않아서 한 번만 그려도 되는 하늘을 그려주는 코드가 들어있다. 가로 좌표를 <code>this.x</code>로 그리는 이유는 카메라가 움직여버렸기 때문에 0,0에다 그리면 갈수록 하늘도 뒤로 가버리기 때문이다. 그러면 당연히 안되겠지?</p>
        <p>보면 알겠지만 얘는 <code>update</code>를 별도로 구현하지 않았다. 왜냐면 <code>update</code>에서 해줄 일이 전혀 없기 때문이다.. 대신 게임 장면 객체의 <code>update</code>에서 매 프레임마다 cameraX 를 <code>Background.x</code>에 할당해주도록 하자. 게러쎄러 만드는 걸 좋아하는 사람들이 많지만 js는 어차피 특별히 건드리지 않으면 죄다 퍼블릭이다. 직접 쑤셔넣지 않을 이유가 없지! (착한 개발자는 안 따라해도 좋다)</p>
        <p>우선 <code>GameScene.constructor</code>에서 이 배경 객체를 생성하고 children 에 넣어주자. 이 때 주의할 점이 있는데, 요 녀석은 <code>Character</code> 보다 먼저 children에 넣어줘야 한다는 점이다. 배경을 먼저 그리고 캐릭터를 그려야 캐릭터가 배경에 가려지지 않겠지? 그리고 기존에 있던 <code>this.character.init()</code>는 <code>GameScene.init</code>로 옮기기 위해 일단 지워주자.</p>
        <pre><code>constructor(){ super(); this.character = new Character(); this.background = new Background(); this.children.push(this.background); this.children.push(this.character); }</code></pre>
        <p>그리고 <code>GameScene.init</code>를 아래와 같이 수정하자. 별 건 없고 그냥 초기화 코드를 이쪽으로 다 옮겨주기 위해서다.</p>
        <pre><code>init(){ this.background.init(); this.character.init(); this.cameraX = 100; }</code></pre>
        <p>그리고 <code>update</code>에서 <code>cameraX</code> 를 갱신하고 배경 객체에도 넘겨주자.</p>
        <pre><code>update(timeDelta, key){ super.update(timeDelta); this.cameraX = Math.max(this.cameraX, this.character.x); // 카메라 좌표 갱신 this.background.x = this.cameraX - 200; // 배경 객체에 넘겨주기 if( key === 32 ){ var tx = Math.cos(Math.PI/4) * this.character.y + this.character.x; this.character.setPivot({x:tx, y:0}); } }</code></pre>
        <p>알고 있겠지만 카메라 좌표는 한 번 우측으로 이동하면 다시 좌측으로 돌아가지 않도록 하기 위해 Math.max를 써서 이전 값보다 커졌을 때만 변경하도록 했다.</p>
        <h4>그럼 이제 어떻게 그려주면 될까?</h4>
        <p>이미지가 계속 흘러가게 하려면 레이어당 몇 개의 이미지가 필요할까? 정답은 두 개다. 어떻게 각 레이어당 두개로 이미지들이 계속 흘러가게 보이게 하는지는 대충 아래의 이미지를 보면 감이 오겠지?</p>
        <p><img alt="" src="https://lazygyu.net/images/blog/background_flow_170105.gif_1483636251.gif" /></p>
        <p>보다시피 그냥 이미지 두 장을 나란히 놓고 슥슥 땡겨주면 된다. 이렇게 땡겨주는 걸 게임 화면만 보면 아래처럼 자연스럽게 연결되게 된다.</p>
        <p><img alt="" src="https://lazygyu.net/images/blog/crop_170106.gif_1483636266.gif" /></p>
        <p>잘 보면 쉬운 규칙을 발견할 수 있다. 각 레이어의 1번 이미지는 0,0 좌표에서 -540(화면크기),0 좌표까지 이동하고 2번 이미지는 540,0 에서 0,0까지 이동한다. 각 레이어의 속도만 다를 뿐이다. </p>
        <p>그럼 구현을 해보자! <code>Background.render</code>를 아래처럼 수정하면 된다.</p>
        <pre><code>render(ctx){ ctx.save(); ctx.translate(this.x, 0); // 모든 레이어에 더해주기 귀찮으니 일단 베이스 좌표를 옮기자. let star1 = -(this.x/8)%540; // 별 레이어 1의 x 값. 캐릭터의 1/8속도다. let star2 = -(this.x/4)%540; // 마찬가지로 별레이어 2의 x값. let mountainX = -(this.x/2)%540; // 산 레이어의 x 값. // 산 레이어는 화면크기보다 세로가 짧아서 임의로 세로 좌표를 설정해봤다. let mountainY = 540 - this.images[3].height; ctx.drawImage(this.images[0], 0, 0); // 하늘은 움직이지 않으니까 일단 걍 그려주자. // 별1 그리기 ctx.drawImage(this.images[1], star1, 0); ctx.drawImage(this.images[1], star1+540, 0); // 별2 그리기 ctx.drawImage(this.images[2], star2, 0); ctx.drawImage(this.images[2], star2+540, 0); // 산 그리기 ctx.drawImage(this.images[3], mountainX, mountainY); ctx.drawImage(this.images[3], mountainX+540, mountainY); ctx.restore(); }</code></pre>
        <p>각 레이어의 x 좌표에 <code>% 540</code>을 해주는 이유는 대충 알겠지만 이동 폭을 0 ~ -540으로 고정하기 위해서다. 여기까지 해준 결과는 아래와 같다. 무지무지 그럴싸해져서 넘나 뿌듯한것 ㅠㅠ</p>
        <p>그럼 그럴싸한 모습을 즐기면서 다음 시간으로 넘어가도록 하자! 분량이 조금 애매하긴 한데, 지형이랑 아이템은 묶어서 한 챕터로 가는게 좋을 것 같으니 여기서 끊는 센스!</p>
        <p>
            <script async src="https://lazygyu.net//jsfiddle.net/lazygyu/f9xhkyjv/embed/"></script>
        </p>
        <p><a href="http://lazygyu.net/blog/html5_js_minigame_tutorial4">다음 글 : Swing my baby 를 통해 보는 HTML5 게임 개발(4)</a></p> ]]></content:encoded>
<link>https://lazygyu.net/blog/html5_js_minigame_tutorial3</link>
<category><![CDATA[ HTML5 게임 개발 튜토리얼 ]]></category>
<pubDate>Fri, 06 Jan 2017 02:11:00 +0900</pubDate>
<guid>https://lazygyu.net/blog/html5_js_minigame_tutorial3</guid>
</item>
<item>
<title><![CDATA[ HTML5 미니게임 개발 튜토리얼 2 ]]></title>
<description><![CDATA[ 이제 이 게임의 핵심인 줄타기를 만들어보자. 이것만 되면 게임 자체의 메커니즘은 거의 완성이다. ]]></description>
<content:encoded><![CDATA[ <h1>HTML5 미니게임 개발 튜토리얼</h1>
<a href="https://lazygyu.net/blog/html5_js_minigame_tutorial1">이전 글 : Swing my baby 를 통해 보는 HTML5 게임 개발(1)</a>

Swing my baby 를 통해 보는 HTML5 게임 개발(2)

<img src="https://lazygyu.net/images/blog/screenshot_170101.png_1483267658.png" alt="" />
<h2>개발 과정</h2>
<h3>캐릭터 만들기</h3>
<h4>진자의 움직임 적용</h4>
이제 이 게임의 핵심인 줄타기를 만들어보자. 이것만 되면 게임 자체의 메커니즘은 거의 완성이다. 나머지는 부차적인 부분일 뿐... 우리의 이 게임에서는 유저가 스페이스바를 누를 때마다 캐릭터가 줄을 걸고 줄에서 점프하기를 반복해야 한다. 입력 처리는 이후에 다시 나올테니까 우선 줄을 걸어서 캐릭터가 움직이도록 해보자.
<h5>일단 줄을 걸어보자</h5>
현재 캐릭터는 x 와 y 좌표만을 가지고 있는데, 줄을 걸게 되면 "줄이 걸린 위치"를 나타낼 변수가 필요하다.

<img src="https://lazygyu.net/images/blog/pivot_position_161231.png_1483267669.png" alt="" />

그럼 이 좌표들을 나타낼 변수를 추가해보자. <code>Character.init</code> 메소드를 아래처럼 변경한다.
<pre><code>init(){
    // 여기서는 각종 변수를 초기화해야 한다.
    // 일단 현재 위치를 나타내는 변수를 만들어봤다.
    this.x = 0;
    this.y = 0;
    this.gravity = 10; //일단 대충 10으로 해보자.
    this.pivot = null; //이건 줄이 걸린 좌표를 나타내는 변수다. null 이면 안 걸린거
    this.position = null; //이건 줄에 대한 캐릭터의 상대 좌표
    this.pLen = 0; //이건 줄의 길이
    this.angle = 0; //현재 진자운동의 각도
    this.accel = 0; //현재의 각가속도
}</code></pre>
줄의 길이가 왜 필요한가? 이건 잠시후에 진자의 물리학에서 살펴보자.
<h5>줄 걸기</h5>
줄을 걸 수 있는 변수가 생겼으니 줄을 거는 메소드를 만들어보도록 하자.
<pre><code>setPivot(point){
  //point 로 지정된 곳에 줄을 건다
  if( this.pivot === null ){
    // 현재 줄이 걸리지 않은 상태일때만 줄을 건다
    this.pivot = point; // 지지점을 할당하고
    this.pLen = Math.distance(this, this.pivot);  // 줄 길이
    this.position = {x:this.x - this.pivot.x, y:this.y - this.pivot.y}; // 상대위치
    this.angle = Math.angle({x:this.x, y:this.y}, this.pivot); // 현재 각도
    this.accel = 
      (-1.0 * (this.force.x+this.force.y)/this.pLen) * Math.sin(this.angle); // 각가속도
    this.update(0); // 줄이 걸린 것을 바로 반영하기 위해 업데이트 한 번 호출해준다.
  }
}</code></pre>
<code>Math.distance</code>나 <code>Math.angle</code>은 바로 밑에서 추가할테니 넘나 새롭다고 놀라지 말고 침착하게 읽어 보자.
<h5>수학 계산 유틸리티</h5>
그럼 이제부터 진자운동을 계산해보도록 하자. 그 전에 계산하기 쉽도록 몇가지 유틸리티 함수를 만들면 편하다. 아래 내용을 array.prototype.last 만든 곳 밑에다가 넣자. 하기 전에 일단 피타고라스 아저씨한테 잠시 감사를..
<pre><code>Math.distance = function(p1, p2){
  // 두 점 간의 거리를 구하는 함수
  // 왜 아래처럼 되는지 궁금하면 피타고라스의 정리를 보도록 하자!
  return Math.abs(Math.sqrt(Math.pow(p2.x-p1.x,2) + Math.pow(p2.y-p1.y,2)));
}
Math.rad2deg = function(rad){
  // 라디안 각도를 60분법 각도로 변환
  return rad * 180 / Math.PI;
}
Math.deg2rad = function(deg){
  // 60분법 각도를 라디안으로 변환
  return deg / 180 * Math.PI;
}
Math.angle = function(p1,p2){
  // 두 지점의 각도를 구하자
  let w = p2.x - p1.x;
  let h = p2.y - p1.y;
  return Math.atan2(-h,w) - Math.PI/2;
}
Math.getPoint = function(pt, deg, len){
  // 한 점에서 특정 각도로 특정 거리 떨어진 점의 좌표를 구한다
  return {x:pt.x + (len*Math.cos(deg)), y:pt.y + (len*Math.sin(deg))};
}</code></pre>
Math.angle 에서 단순히 Math.atan2(h,2); 를 반환하지 않고 -h 와 (-Math.PI/2) 를 해주는 이유는...

<img src="https://lazygyu.net/images/blog/angle_diff_170101.png_1483267684.png" alt="" />

이렇게 우리가 원하는대로 각도를 얻어오기 위해서 구해진 값을 조작해야 할 필요가 있기 때문이다.
<h5>진자의 물리학</h5>
일단 이 글을 쓰기에 앞서서 나는 가방끈도 짧고 수학도 젠젠 모른다는 점을 명시해두도록 하자. 아래 내용 중에 틀린게 있거나 비효율적인게 있을수도 있으니 대충 &#x27;아 얘는 이따위로 이걸 만들었구나..&#x27;라고 생각하도록 하자. 물론 더 좋은 공식이나 방법이 있다면 댓글로 알려주면 남들에게도 도움이 될 지도 모른다...(보는 사람이 있다면 말이지만)

우리의 캐릭터는 x 축에 대한 힘과 y 축에 대한 힘만을 가지고 이동한다. 따라서 진자 운동의 각속도를 x 축과 y축 선분으로 분해해서 캐릭터에 적용해주면 깔끔하게 캐릭터의 진자운동을 근사할 수 있게 된다.

<img src="https://lazygyu.net/images/blog/angular_velocity_170101.png_1483267692.png" alt="" />

우리가 진자운동에서 신경써야 할 유일한 부분은 바로 이 각속도다. 프레임당 각속도만 계산할 수 있으면 나머지는 다 무시해도 된다. 그럼 이 각속도는 어떻게 구해질까?
<blockquote>현재 진자 추에 가해지는 각가속도 = (중력/진자 줄의 길이)*sin(현재 진자의 각도)</blockquote>
대충 이렇게 구하면 현재 위치에서의 각가속도가 나온다. 그럼 이걸 또 어떻게 적용할까?

<code>Character.update</code> 에서 진자의 현재 위치에서의 각가속도를 구해서 진자 각도에 더해주도록 하자. 그걸로 현재 캐릭터의 지지점에 대한 상대위치는 간단히 결정할 수 있다. 그리고 이렇게 구해진 가속도를 가지고 가로세로 힘으로 분해해서 force 를 계산하고, 해당 force를 캐릭터의 위치에 반영하면 된다.

<img src="https://lazygyu.net/images/blog/vector_dec_170101.png_1483267702.png" alt="" />
<pre><code>update(timeDelta){
    // 캐릭터의 각종 상태를 변경하는 부분.
	if(this.pivot === null){
      	// 줄이 걸려있지 않을때
    	this.force.y += this.gravity * timeDelta;
      	this.x += this.force.x;
    	this.y += this.force.y;
	}else{
      	// 줄이 걸려있을 때
      	// 중력은 작용하고 있지만 각가속도 계산에 들어가므로 force.y 에 별도로 더해줄 필요가 없다.
      	let ang = this.angle;
      	let ang_vel = (-1*this.gravity/this.pLen) * Math.sin(ang); //각가속도
      	// 현재 각가속도에 경과시간을 곱해서 전체 각가속도에 합산
      	this.accel += ang_vel * timeDelta; 
      	// 계속 같은 높이로 흔들릴 수는 없으니 시간이 흐를수록 가속도를 줄여준다.
      	// 현실로 치자면 줄의 마찰력이나 공기저항에 대한 시뮬레이션이라고 볼 수 있겟지?
      	this.accel *= 0.999; 
      	// 그럼 이제 다음번 각속도 계산을 위해 현재 각도를 바꿔주고
      	ang += this.accel;
      	this.angle = ang;

      	// 각 성분으로 분해해서 force에 할당하자
      	this.force.x = this.pLen * this.accel * Math.cos(ang);
      	this.force.y = this.pLen * this.accel * Math.sin(ang);
      	this.position.x += this.force.x;
      	this.position.y += this.force.y;
	}


}</code></pre>
진자가 걸려있으면 줄이 표시되어야 한다. 줄 표시를 넣고, force가 제대로 들어가는지도 확인할 수 있도록 force를 눈으로 볼 수 있게 <code>Character.render</code>를 아래와 같이 고쳐보자.
<pre><code>render(ctx){
  // 여기서 그려주면 된다.
  ctx.save();
  if( this.pivot !== null ){ // 줄이 걸려있으면 줄을 그려준다
    ctx.strokeStyle = "blue";
    ctx.beginPath();
    ctx.moveTo(this.pivot.x, this.pivot.y);
    ctx.lineTo(this.pivot.x+this.position.x, this.pivot.y+this.position.y);
    ctx.stroke();
  }
  ctx.translate(this.x, this.y);
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.arc(0, 0, 20, 0, 2*Math.PI); // 각도는 늘 라디안이라는 점을 잊지 말자!
  ctx.fill();
  // force를 확인하기 쉽도록 20배로 증폭해서 화면에 그려준다
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, 2, this.force.y*20);
  ctx.fillRect(0, 0, this.force.x*20, 2);
  ctx.restore();
}</code></pre>
이렇게 하면 force 의 각 성분을 20배로 증폭해서 선 모양으로 볼 수 있게 된다.

이렇게 열심히 만들었으니까 정말 잘 동작하는지 테스트를 해봐야겠지?

<code>GameScene.update</code>에 아래와 같은 내용을 추가해보자
<pre><code>update(timeDelta){
  super.update(timeDelta);
  // 0.5초 이후에 줄을 걸어보자
  if( this.elapsed &amp;gt; 0.5 &amp;amp;&amp;amp; this.character.pivot === null){
    this.character.setPivot({x:240, y:0}); //240,0 좌표로 줄 걸기!
  }
}</code></pre>
여기까지 진행하면 아래와 같이 귀요미 진자가 동작하는 것을 볼 수 있다! 뿌듯행!

<script async src="https://lazygyu.net//jsfiddle.net/lazygyu/wtx11u95/1/embed/"></script>

잠시 쉰다는 마음으로 여러가지 값들을 바꿔보면서 한껏 즐겨주자! 헤헿
<h5>진자에서 탈출하려면</h5>
자 이렇게 줄을 걸어서 매달리는건 구현이 되었는데... 이제 이 줄에서 탈출을 해야겠지? 사실 탈출하는건 어렵지 않다. 그냥 this.pivot = null; 만 넣어주면 바로 탈출이 된다. <code>setPivot</code>을 고쳐보자.
<pre><code>setPivot(point){
  //point 로 지정된 곳에 줄을 건다
  if( this.pivot === null ){
    // 현재 줄이 걸리지 않은 상태일때만 줄을 건다
    this.pivot = point; // 지지점을 할당하고
    this.pLen = Math.distance(this, this.pivot);  // 줄 길이
    this.position = {x:this.x - this.pivot.x, y:this.y - this.pivot.y}; // 상대위치
    this.angle = Math.angle({x:this.x, y:this.y}, this.pivot); // 현재 각도
    this.accel = 
      (-1.0 * (this.force.x+this.force.y)/this.pLen) * Math.sin(this.angle); // 각가속도
    this.update(0); // 줄이 걸린 것을 바로 반영하기 위해 업데이트 한 번 호출해준다.
  }else{
    this.pivot = null;
    this.pLen = 0;
    this.position = null;
    this.angle = 0;
    this.accel = 0;
    this.update(0);
  }
}</code></pre>
다른 변수들도 그냥 마음이 상쾌하도록 같이 초기화를 시켜봤다. 실제로는 안 해줘도 된다.
<h5>예외처리</h5>
진자운동을 하다 보면 혹시 넘나 쎄게 매달려서 앞뒤로 90도 이상 흔들리는 경우도 있게 된다. 심하면 진자 운동이 아니라 한 방향으로 뱅글뱅글 돌게 될 수도 있다. 우리가 만든 공식으로 이런 부분도 제대로 표현되긴 하지만, 큰 문제가 있다. 현실에서 줄로 매달린 경우에, 진폭이 180도를 넘어가게 되면 줄이 강체가 아닌 이상 약간씩 궤도가 흐트러지게 마련이다. 하지만 우리가 만든 공식은 줄을 완벽한 강체로 가정하고 동작한다. 말하자면 우리의 코드상에서 줄은 사실 줄이 아니라 막대기와 비슷한 물체다.

<img src="https://lazygyu.net/images/blog/rigid_rope_170101.png_1483267718.png" alt="" />

그러면 어떻게하면 사실적으로 줄을 시뮬레이션할 수 있을까? 정답은 간단하다. 안 하면 된다.

앞이건 뒤건 진자의 각도가 90도를 넘으면 천장에 머리를 박고 떨어지게 만들자ㅋㅋㅋ

업데이트에서 ang += this.accel; 줄 바로 밑에 아래와 같이 추가하자.
<pre><code>if( Math.abs(Math.rad2deg(ang)) &amp;gt;= 90 ){
  this.setPivot(null);
  return;
}</code></pre>
그러면 이제 각도가 -90 이상이거나 90 이상이면 줄에서 자동으로 떨어지게 된다. 왜 이렇게 꼼수로 하냐면... 귀찮기 때문이긴 하지만 그렇게 말하면 없어보이니까 게임의 긴장감을 위해서라고 해두도록 하자(찡긋)
<h4>게임에 맞게 조정</h4>
지금의 진자운동만으로도 진자 시뮬레이션 자체는 그럴싸하게 완성됐다. 애초에 진자운동은 진폭과 진자 길이와 중력 가속도만 고려하면 되는거니까. 하지만 이대로 게임에 사용하면 캐릭터는 계속해서 아래로 내려가기만 할 뿐 절대로 위로 올라갈 수가 없다. 진자의 최고점보다 높이 올라갈 수가 없기 때문이다.

그러면 게임이 너무 루즈해지는 단점이 있는데다가 쫄깃한 손맛 없이 왠지 답답한 조작감에 짜증이 나게 마련이다. 어차피 우리가 만드는게 무슨 과학교재도 아니니까 게임의 재미를 위해 조금 조정을 가해보자.

먼저 줄을 걸었을 때 확 잡아채는 맛이 생기도록 <code>setPivot</code>메소드에서 줄을 거는 순간의 초기 가속도 구하는 데다가 MSG를 좀 치자. 원래 -1 을 곱했지만, 좀 더 초기 속도가 빨라지도록 -1.3 정도를 곱하는 걸로 바꿔주자.
<pre><code>this.accel = (-1.3 * (this.force.x+this.force.y)/this.pLen) * Math.sin(this.angle);</code></pre>
그리고 진자를 놓고 점프하는 순간에도 약간 탄력받는 느낌을 살리도록 force에 양념을 좀 치자.
<pre><code>this.force.x *= 1.2;
this.force.y -= 1.5;</code></pre>
일단 앞뒤로 움직이는 힘을 1.2배로 곱해줬다. (그러면 앞으로 빨리 가고 있었을 수록 더 많이 탄력받아서 쓩~ 날아갈 수 있게 되겠지?)

그리고 y 축 힘에 -1.5를 더해줬다. y 축 힘은 음수인 경우 위로 올라가는 힘이되니까 약간 점프력을 보태준다고 생각하면 된다.

적절한 수치는 각자 알아서 찾아보도록 하자. 이리저리 해본 결과 이정도가 너무 쉽지 않으면서도 열심히 하면 위로 올라갈 수는 있는 좋은 한계치인 것 같다.
<h4>캐릭터 애니메이션</h4>
여지껏 빨간 동그라미만 움직여왔는데, 초반에 열심히 만든 스프라이트니 애니메이션이니 이딴걸 대체 언제 써먹는건지 의문이었다면 드디어 써먹어볼 때가 왔다.

우선 아래 이미지를 가지고 캐릭터의 애니메이션을 만들어보자. 아래 이미지에는 이후로도 사용될 대부분의 스프라이트들이 포함되어 있다.. 그리고 저작권은 아마도 네오플에 있을거다. (사실 잘 모르지만 아마 그럴거임.. 근로계약서 꺼내보기 귀찮다. 네오플에 없어도 어쨌든 나한테는 있으니 상업적 이용은 하지 말 것...어따 쓰겠냐마는.)

<img src="https://lazygyu.net/images/blog/sprite_170101.png_1483267730.png" alt="" />

1편에서 우리가 만든 스프라이트 구조와 애니메이션 구조들은 기억할테니 거기에 맞게 스프라이트들을 정의해보자. 스크립트 맨 위쪽에 아래와 같이 스프라이트 정의와 애니메이션 정의를 추가한다.
<pre><code>const SpriteDefs = {
    "character":[
        {x:0,y:0,w:40,h:40,origin:{x:20,y:20}},
        {x:40,y:0,w:40,h:40,origin:{x:20,y:20}},
        {x:0,y:40,w:40,h:39,origin:{x:30,y:20}},
        {x:40,y:40,w:40,h:39,origin:{x:30,y:20}},
        {x:80,y:40,w:40,h:39,origin:{x:30,y:20}},
        {x:0,y:80,w:40,h:41,origin:{x:30,y:20}},
        {x:40,y:80,w:40,h:41,origin:{x:30,y:20}},
        {x:80,y:80,w:40,h:41,origin:{x:30,y:20}},
        {x:0,y:122,w:40,h:41,origin:{x:30,y:20}},
        {x:40,y:122,w:40,h:40,origin:{x:30,y:20}},
        {x:80,y:122,w:40,h:40,origin:{x:30,y:20}},
        {x:0, y:186,w:40,h:59,origin:{x:20,y:39}},
        {x:40, y:186,w:40,h:59,origin:{x:20,y:39}},
        {x:80, y:186,w:40,h:59,origin:{x:20,y:39}},
        {x:340, y:0, w:18,h:12,origin:{x:9,y:6}},
        {x:200,y:260,w:50,h:50,origin:{x:25,y:25}},
        {x:250,y:260,w:50,h:50,origin:{x:25,y:25}},
        {x:300,y:260,w:50,h:50,origin:{x:25,y:25}},
        {x:350,y:260,w:50,h:50,origin:{x:25,y:25}}
    ]
};
const AnimationDefs = {
    "character":{
                "spin":[{frame:0,duration:0.05}, {frame:1,duration:0.05}],
                "forward":[{frame:2,duration:0.08}, {frame:3,duration:0.08},{frame:4,duration:0.08},{frame:3,duration:0.08}],
                "nutral":[{frame:5,duration:0.05},{frame:6,duration:0.05},{frame:7,duration:0.05},{frame:6,duration:0.05}],
                "backward":[{frame:8,duration:0.05},{frame:9,duration:0.05},{frame:10,duration:0.05},{frame:9,duration:0.05}],
                "fall":[{frame:11,duration:0.05},{frame:12,duration:0.05},{frame:13,duration:0.05},{frame:12,duration:0.05}],
                "sword":[{frame:14,duration:1}],
                "magnet_field":[{frame:15,duration:0.05},{frame:16,duration:0.05},{frame:17,duration:0.05},{frame:18,duration:0.05}]
            }
};</code></pre>
스프라이트 정의를 보면 알겠지만 각 스프라이트들은 이미지에서의 위치/크기/중심점 좌표 정보를 가지고 있고, 각 애니메이션들은 각 프레임의 스프라이트 번호와 지속시간을 가지고 있다.

그럼 이 정보들을 바탕으로 스프라이트와 애니메이션을 생성해보자.

<code>Character.constructor</code>를 아래처럼 수정한다.
<pre><code>constructor(){
  this.img = new Image();
  this.img.src = "images/sprites.png"; //각자 자신의 이미지 주소를 넣자
  this.spriteSheet = new SpriteSheet(this.img, SpriteDefs.character); //캐릭트 스프라이트 시트
  this.animations = {}; //애니메이션들을 모아둘 컨테이너
  //애니메이션 정의에 맞춰서 컨테이너에 애니메이션을 생성해서 넣는다.
  for(let i in AnimationDefs.character){
    if( !AnimationDefs.character.hasOwnProperty(i)) continue;
    this.animations[i] = new Animation(this.spriteSheet, AnimationDefs.character[i]);
  }
}</code></pre>
그리고 현재 어떤 애니메이션이 필요한지를 나타내는 변수를 <code>init</code> 에 추가하자.
<pre><code>this.currentAnimation = "forward";</code></pre>
그 후엔 상태에 따라 애니메이션을 변경하는 코드를 <code>update</code>에 넣어보자.

일단 공중에 있는(줄이 걸려있지 않은) 상태일 때는 &#x27;spin&#x27; 애니메이션이 나타나고, 줄에 매달려서 앞으로 갈 때는 forward, 뒤로 갈 때는 backward, 가운데쯤에서는 nutral 이 나오게 해보자. 이 부분은 force 의 x 값에 따라 판별하면 되겠지?

<code>update</code>를 아래처럼 수정한다.
<pre><code>update(timeDelta){
  // 캐릭터의 각종 상태를 변경하는 부분.
  if(this.pivot === null){
    // 줄이 걸려있지 않을때
    this.currentAnimation = "spin"; //현재 애니메이션은 spin 으로
    this.force.y += this.gravity * timeDelta;
    this.x += this.force.x;
    this.y += this.force.y;
  }else{
    // 줄이 걸려있을 때
    // 중력은 작용하고 있지만 각가속도 계산에 들어가므로 force.y 에 별도로 더해줄 필요가 없다.
    let ang = this.angle;
    let ang_vel = (-1*this.gravity/this.pLen) * Math.sin(ang); //각가속도
    // 현재 각가속도에 경과시간을 곱해서 전체 각가속도에 합산
    this.accel += ang_vel * timeDelta; 
    // 계속 같은 높이로 흔들릴 수는 없으니 시간이 흐를수록 가속도를 줄여준다.
    // 현실로 치자면 줄의 마찰력이나 공기저항에 대한 시뮬레이션이라고 볼 수 있겟지?
    this.accel *= 0.999; 

    // 그럼 이제 다음번 각속도 계산을 위해 현재 각도를 바꿔주고
    ang += this.accel;
    if( Math.abs(Math.rad2deg(ang)) &amp;gt;= 90 ){
      this.setPivot(null);
    }else{
      this.angle = ang;


      // 각 성분으로 분해해서 force에 할당하자
      this.force.x = this.pLen * this.accel * Math.cos(ang);
      this.force.y = -this.pLen * this.accel * Math.sin(ang);

      this.position.x += this.force.x;
      this.position.y += this.force.y;
      this.x = this.position.x + this.pivot.x;
      this.y = this.position.y + this.pivot.y;
    }
    if(this.force.x &amp;lt; -3){ this.currentAnimation = "backward"; }else if(this.force.x &amp;gt; 3){
      this.currentAnimation = "forward";
    }else{
      this.currentAnimation = "nutral";
    }
  }
  this.animations[this.currentAnimation].update(timeDelta);
}</code></pre>
그럼 이제 <code>render</code>에서 현재 애니메이션을 그려주면 되겠지?
<pre><code>render(ctx){
  // 여기서 그려주면 된다.
  // 일단은 현재 위치에 반지름 20픽셀 짜리 빨간 원을 그리는 코드를 넣어보자.
  ctx.save();
  if( this.pivot !== null ){
    ctx.strokeStyle = "blue";
    ctx.beginPath();
    ctx.moveTo(this.pivot.x, this.pivot.y);
    ctx.lineTo(this.pivot.x+this.position.x, this.pivot.y+this.position.y);
    ctx.stroke();
  }
  ctx.translate(this.x, this.y);
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.arc(0, 0, 20, 0, 2*Math.PI); // 각도는 늘 라디안이라는 점을 잊지 말자!
  ctx.fill();
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, 2, this.force.y*20);
  ctx.fillRect(0, 0, this.force.x*20, 2);
  ctx.restore();
  this.animations[this.currentAnimation].draw(ctx, this.x, this.y, {});
}</code></pre>
여기까지 진행했으면 아래처럼 캐릭터가 살아 숨쉬게 된다! 우왕!굳!

<script async src="https://lazygyu.net//jsfiddle.net/lazygyu/tonub5vr/embed/"></script>

또 글이 너무 길어지니까 다음 편에서 만나도록 하자능! 헤헿
 ]]></content:encoded>
<link>https://lazygyu.net/blog/html5_js_minigame_tutorial2</link>
<category><![CDATA[ HTML5 게임 개발 튜토리얼 ]]></category>
<pubDate>Mon, 02 Jan 2017 05:00:00 +0900</pubDate>
<guid>https://lazygyu.net/blog/html5_js_minigame_tutorial2</guid>
</item>
<item>
<title><![CDATA[ HTML5 미니게임 개발 튜토리얼 1 ]]></title>
<description><![CDATA[ 이 글은 현재 "던전 앤 파이터"의 점검페이지에서 플레이할 수 있는 "Swing my baby"라는 게임을 HTML5 Canvas를 통해 만드는 과정을 설명한다 ]]></description>
<content:encoded><![CDATA[ <h1>HTML5 미니게임 개발 튜토리얼</h1>
Swing my baby 를 통해 보는 HTML5 게임 개발(1)

<img src="https://lazygyu.net/images/blog/title.png_1483110633.png" alt="" />
<h2 style="text-align: left;">이 글의 목표</h2>
<iframe width="100%" src="https://lazygyu.net//www.youtube.com/embed/P7NQyDeGfKE" frameborder="0" allowfullscreen></iframe>
<p style="text-align: left;">이 글은 현재 "던전 앤 파이터"의 점검페이지에서 플레이할 수 있는 "Swing my baby"라는 게임을 HTML5 Canvas를 통해 만드는 과정을 설명한다. 해당 게임은 던전 앤 파이터가 정기점검을 하는 매주 목요일 새벽에 http://df.nexon.com 에서 플레이해 볼 수 있다. 혹시 나중에 다른데서도 플레이 가능해질지도 모르지만 일단 현재는 그렇다.</p>
좋은 라이브러리들이 세상에는 많이 나와있지만, 간단한 게임이므로 별도의 라이브러리를 사용하지 않고 가능한한 직접 손으로 만들면서 진행해보도록 하자.

참고로 나는 발코더이기 때문에, 발로 쓴 것 같은 코드를 만나게 될테니 마음의 준비를 하면 더 좋다.

항상 귀차니즘으로 인해 블로그에는 '이런걸 만들어봤다' 라는 기록만 남기고 과정은 전혀 적지 않았는데, 연말이고 하니까 특별히 큰 맘 먹고 적어보자.
<h2>개발 과정</h2>
개발 과정중에 그래픽/사운드 리소스 제작이 빠져있는데, 이 부분은 각자 알아서 해보도록 하자... 뭐 이건 이 글에서 설명할 건덕지가 없다. 그래픽 리소스는 열심히 그리고, 사운드 리소스는 열심히 녹음하던지 찾던지 작곡하던지 하자.
<h3>게임 개괄</h3>
게임을 해봤거나 목표에 나온 화면을 보면 알겠지만, 이 게임은 기본적으로 원버튼 액션 장르로, 별도의 엔딩이 없는 기록 갱신형 게임이다. 게임의 주된 메커니즘은 스파이더맨이나 타잔이 줄타기하듯이 화면의 캐릭터가 줄에 매달려 진자운동을 통해 앞으로 얼마나 멀리 나아가느냐이다.
<h3>게임의 기본 구조 설계</h3>
게임 프로그램은 다른 웹 프로그램과 달리 무한 루프를 돌며 사용자의 입력이 없어도 능동적으로 계속해서 동작해야 한다. 따라서 일반적인 이벤트 드리븐 프로그램과는 코딩 스타일이 달라지게 된다. (물론 이벤트드리븐 프로그램들도 보통 내부적으로는 무한 루프를 돌고 있지만..)

이 글에서 만들어볼 게임의 기본 구조는 먼저 장면(흔히 Scene 이라고 부르곤 한다)을 기반으로 한다. 장면은 예를 들면 "타이틀 장면", "게임 장면", "게임 결과 장면"등이 된다.

각 장면들은 여러 게임 객체들을 가지고 있다. 예를 들어 게임 장면의 경우에는 캐릭터 객체, 아이템 객체, 점수 표시 객체, 배경 객체, 지형 객체등이 있을 수 있을 것이다.

게임 총괄 객체는 초당 60회를 기준으로 각 장면들에 대해 "갱신"과 "화면 그리기"를 요청하고, 이러한 요청을 받은 장면들은 마찬가지로 자신이 가지고 있는 게임 객체들에게 "갱신" 및 "화면 그리기" 요청을 보내게 된다.

각 게임 객체들은 각자의 논리에 맞춰서 상태를 갱신하고 화면에 정해진 내용을 그리게 된다.

그럼 이런 내용을 어떻게 코드로 표현하면 좋을지 생각해보자.

제일 먼저 게임 자체의 기본이 될 HTML 파일을 하나 만들자.
<pre><code><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"canv"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"540"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"540"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span> 
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript"> 
<span class="hljs-comment">  // 여기에 앞으로 게임을 작성하면 된다.</span> 
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;
</span></code></pre>
<h4>게임 총괄 객체</h4>
게임 전체를 관리하는 총괄 객체를 만들어보자. 게임 객체는 각 장면을 관리하고, 장면간의 전환을 처리하고, 게임 루프를 작동시키는 기능이 필요하다. 이런 역할을 하는 기본적인 뼈대를 아래처럼 작성해보자.
<pre><code>class Game{
  // 생성자
  constructor(_canv){
    this.canvas = _canv;
    this.ctx = this.canvas.getContext('2d'); // 2d 컨텍스트를 저장한다
    this.scenes = []; // 장면들을 관리하는 스택

    // 시간 관리용 멤버 변수들
    this.now = 0;
    this.last = 0;
    this.elapsed = 0;
    this.timeDelta = 0;
  }

  // 게임 루프용 메소드
  // 이 메소드가 매 프레임(1/60초)마다 실행된다.
  update(){
    this.last = this.now;
    this.now = performance.now(); // 현재 시간
    this.timeDelta = (this.now-this.last)/1000; // 지난 프레임과의 경과시간을 초 단위로 환산
    this.elapsed += this.timeDelta; // 게임이 시작된 후 경과된 전체 시간

    this.ctx.clearRect(0,0,this.canvas.width, this.canvas.height); // 화면을 매 프레임 지워준다.
    if( this.scenes.length &gt; 0){
      // 처리해야 할 장면이 있을 경우에만
      this.scenes.last().update(this.timeDelta); // 활성화된 장면을 갱신
      this.scenes.last().render(this.ctx); // 활성화된 장면을 그려줌
    }
    requestAnimationFrame(this.update.bind(this)); // 1/60초 후에 다시 실행
  }

  // 장면을 새로 전환할 때는 스택에 새로운 장면을 넣어주면 된다
  push(_scene){
    if( this.scenes.length&gt;0 ) { 
       // 혹시 실행되고 있는 장면이 있을 경우 해당 장면에 정지 신호를 보내주고
      this.scenes.last().pause(); 
    }
    _scene.init(); // 새로 추가될 장면의 초기화 코드를 호출해준 뒤
    this.scenes.push(_scene); // 스택에 새 장면을 넣어준다.
  }

  // 장면의 실행이 끝나고 이전 장면으로 돌아갈 때는 스택에서 마지막 장면을 뽑아주면 된다.
  pop(){
    if( this.scenes.length === 0 ) return null; // 뽑을 장면이 없으면 암 것도 안하면 된다.
    var sc = this.scenes.pop();
    sc.destroy(); // 각 장면이 끝날때 처리해줄 내용이 있을 수 있으니 호출해주자.
    if( this.scenes.length &gt; 0 ) {
      // 아직 장면 스택에 장면이 남아있다면 마지막 장면이 다시 활성화되어야 한다.
      // 활성화 신호를 보내주자.
      this.scenes.last().resume();
    }
    // 그리고 어디다 쓰고 싶을 수도 있으니까 뽑아낸 장면을 반환한다.
    return sc;
  }
}</code></pre>
위 내용을 보면 이제 게임 장면이 공통으로 구현해야 할 기본적인 인터페이스가 대충 그려질 것이다. 그려지면 뭐다? 만들어야지!

그치만 그 전에 아래 내용을 script 맨 위쪽에 추가하자.
<pre><code>Array.prototype.last = function(){
    return (this.length &gt; 0)?this[this.length-1]:null;
}</code></pre>
<h4>게임 장면 객체</h4>
게임 장면 객체는 기본적으로 위에 나온 <code>init</code>, <code>pause</code>, <code>resume</code>, <code>update</code>, <code>render</code>, <code>destroy</code> 메소드를 구현해야 한다. 그 외에 자신에게 등록된 자식 객체들도 관리해줘야 한다. 그럼 이 내용을 간단히 구현해보자.
<pre><code>class Scene {
  constructor(){
    this.children = []; // 자식 객체들을 보관할 컨테이너
    this.elapsed = 0; // 이 게임 장면에서 경과한 시간
  }

  init(){
    // 일반적으로는 할 일이 없으니 냅두자
  }  

  update(timeDelta){
    // 매 프레임 상태 업데이트를 처리하는 메소드
    this.elapsed += timeDelta;
    this.children.forEach((child)=&gt;{ child.update(timeDelta); }); // 자녀 객체들의 업데이트를 호출
  }

  render(ctx){
    // 화면에 장면을 그리는 메소드. ctx 는 캔버스의 2d 컨텍스트 객체가 된다.
    // 공통으로 하는 일은 그냥 단순히 전체 자식객체를 그려주는 정도면 된다.
    this.children.forEach((child)=&gt;{ child.render(ctx); });
  }

  pause(){
    // 여기도 비워둠
  }

  resume(){
    // 마찬가지로 비워둠
  }
}</code></pre>
이제 각 필요한 장면들은 이 Scene 클래스를 상속받아서 구현하면 깔끔!
<h4>기본 게임 장면 객체 만들기</h4>
그럼 이제 개발중에 계속해서 사용될 게임 장면 객체를 만들고 이 객체가 동작하도록 해보자.

먼저 아래와 같이 <code>GameScene</code>을 만들자.
<pre><code>class GameScene extends Scene {
  constructor(){
    super();
  }

  init(){

  }

  update(timeDelta){
    super.update(timeDelta);
  }

  render(ctx){
    super.render(ctx);
    ctx.save();
    ctx.fillStyle = "blue";
    ctx.font = "bold 40px verdana sans-serif";
    ctx.fillText("Hello Canvas!", 100, 100);
    ctx.font = "20px sans-serif";
    ctx.fillText(this.elapsed, 0, 20);
    ctx.restore();
  }
}</code></pre>
그리고 스크립트 태그 맨 아래에 아래 내용을 추가하자
<pre><code>var game = new Game(document.getElementById('canv'));
game.push(new GameScene());
game.update();</code></pre>
여기까지 진행한 내용과 결과는 아래에서 확인해보자.

<script async src="https://lazygyu.net//jsfiddle.net/lazygyu/49rrd8f5/embed/"></script>
<h3>화면에 그림 표시하기</h3>
게임을 만들려면 뭐니뭐니해도 화면에 그림을 표시할 수 있어야한다. 그러면 HTML5에서는 이걸 어떻게 하면 되느냐? 그걸 이제부터 살펴보자.
<h4>이미지?, 스프라이트?, 애니메이션?</h4>
먼저 간단히 용어를 정리하고 넘어가자. 그림 하나는 그냥 이미지라고 부르도록 하자. 그리고 스프라이트는 뭐냐? 그건 화면에 표시되는 정적인 이미지를 말한다. 예를 들어서 화면상에 보이는 캐릭터라던지 아이템 그림 같은 것들을 스프라이트라고 보면 된다. 옛날에는 스프라이트 = 투명한 부분이 있는 이미지로 간단히 정리되던 시절도 있었다. 하지만 지금 우리는 화면에 표시될 모든 이미지를 스프라이트로 취급할 예정이므로 그냥 화면에 나오는것들 = 스프라이트, 라고 생각하도록 하자.

애니메이션은 여러가지 정의가 있겠지만 이 글에서의 애니메이션은 특정한 스프라이트들을 정해진 시간과 순서대로 바꾸어가면서 표시하는 객체로 정의하도록 하자. 그러므로 애니메이션 하나는 각 프레임에 해당하는 스프라이트와 그 외 정보를 포함하게 된다.

<img src="https://lazygyu.net/images/blog/image_types_161226.gif_1483110663.gif" alt="" />

그니까 이런 느낌?
<h4>스프라이트</h4>
그러면 먼저 기본이 될 스프라이트 클래스를 만들어보자. 생성자는 아래와 같다.
<pre><code>class Sprite {
  constructor(image, sx, sy, sw, sh, ox, oy){
    this.img = image; // 원본 이미지
    this.sx = sx; // 이미지 내에서 스프라이트의 x 좌표
    this.sy = sy; // 이미지 내에서 스프라이트의 y 좌표
    this.sw = sw; // 스프라이트의 가로 크기
    this.sh = sh; // 스프라이트의 세로 크기
    this.ox = ox||0; // 스프라이트의 중심점 x
    this.oy = oy||0; // 스프라이트의 중심점 y
  }
}</code></pre>
하나의 이미지 내에 여러개의 스프라이트를 넣을 수 있도록 스프라이트를 이미지내의 일부분으로 사용하기 위한 멤버 변수들이 있는 것을 확인할 수 있다. <code>ox</code>와 <code>oy</code>가 뜬금없이 뭔지 의아할 수 있는데, 이건 스프라이트의 중심을 정해주는 변수다. 스프라이트를 회전하거나 크기를 조절할 때 기준점이 되는 위치가 필요하기 때문이다. 또, 이미지를 화면에 찍을 때 XY 좌표 부분에 해당 기준점이 위치하도록 찍어주는 역할도 한다.

<img src="https://lazygyu.net/images/blog/origin_point_161226.png_1483110674.png" alt="" />

위 그림과 같이 칼 스프라이트를 캐릭터의 손에 맞춰서 찍어야 한다거나 하는 경우에 기준점이 손잡이로 되어있으면 위치를 맞추기가 편하겠지? 이럴 때를 대비한 변수라고 생각하면 된다.

그럼 이런 것들을 반영해서 화면에 스프라이트를 찍는 메소드를 만들어보자.
<pre><code>draw(ctx, x, y, opt){
  // ctx : 캔버스 컨텍스트
  // x, y : 찍고자 하는 화면 좌표
  // opt : 기타 옵션들 (크기 조절, 회전 등)
  ctx.save();
  // 크기 조절에 별다른 값이 지정되어있지 않으면 크기를 조절하지 않는다.
  let scale = (opt&amp;&amp;opt.scale)||1;
  ctx.translate(x, y); //화면 기준점을 표시 좌표로 이동해서
  if( opt&amp;&amp;opt.rotate ) { ctx.rotate(-opt.rotate);  } // 회전 각도가 있다면 회전해주고
  // 원본 이미지에서 스프라이트만큼 잘라내서
  // 크기 조절에 맞춰서 찍어준다.
  ctx.drawImage(this.img, this.sx, this.sy, this.sw, this.sh,
               -this.ox * scale, -this.oy * scale, this.sw*scale, this.sh * scale);

  ctx.restore();
}</code></pre>
쨘! 이렇게 하면 이제 스프라이트를 화면에 찍을 수 있다.
<h4>스프라이트 시트</h4>
이미지 하나에 스프라이트는 한두개가 아닌데 이걸 언제 일일히 생성하고 전부 변수에 넣어서 관리할 수는 없는 일이다. 이 스프라이트들을 모아둔 걸 스프라이트 시트(sprite sheet)라고 부른다.

관리와 로딩의 편의를 위해서 스프라이트 시트를 만들어 보자.

스프라이트 시트에 필요한 기능은
<ol>
 	<li>스프라이트들을 한꺼번에 로드할 수 있어야 한다.</li>
 	<li>로드된 스프라이트를 바로바로 참조할 수 있어야 한다.</li>
</ol>
이 정도다. 간단하니까 코드도 간단해지겠지.
<pre><code>class SpriteSheet {
  constructor(image, def){
    // image는 스프라이트들이 들어있는 이미지
    // def 는 스프라이트의 정의가 모여있는 배열
    this.img = image;
    this.sprites = [];

    def.forEach((d)=&gt;{
      // 정의에 맞춰서 스프라이트를 생성하고
      let spr = new Sprite(this.img, d.x, d.y, d.w, d.h, d.origin.x, d.origin.y);
      this.sprites.push(spr); // 생성된 놈을 배열에 넣어둔다.
    });
  }

  get(idx){
    return this.sprites[idx]; // 그냥 배열에서 해당 번호의 스프라이트를 반환하면 끝.
  }
}</code></pre>
이제 간단하게 스프라이트들을 로딩할 수 있다. 예를 들면 이런 식으로..
<pre><code>const spriteDef = [
  {x:0, y:0, w:50, h:50, origin:{x:25,y:25}},
  {x:50, y:0, w:50, h:50, origin:{x:25,y:25}},
  {x:100, y:0, w:50, h:50, origin:{x:25,y:25}}
];
const image = new Image('image.png');

var sheet = new SpriteSheet(image, spriteDef);</code></pre>
깔-끔!
<h4>애니메이션</h4>
이제 스프라이트들을 모아서 애니메이션을 만들어야 한다. 모으는거야 스프라이트시트로 해결했고, 나머지 문제를 생각해보자.

애니메이션은 기본적으로 프레임의 연속이다. 각 프레임에 필요한 정보는 표시할 스프라이트와 해당 프레임의 지속 시간이다. 애니메이션 자체에 필요한 정보는 애니메이션이 계속 반복되는지 아닌지 여부 정도면 된다.

그럼 아래와 같은 코드가 간단히 나온다.
<pre><code>class Animation {
  constructor (_sheet, defs, opt){
    this.elapsed = 0; //경과 시간
    this.curFrame = 0;
    this.sprites = _sheet;
    this.frames = defs;
    this.done = false;
    this.duration = defs.reduce((p,v)=&gt;{ return p + v.duration; }, 0); // 각 프레임의 시간의 합
    this.loop = (opt&amp;&amp;opt.hasOwnProperty('loop'))?opt.loop:true;
  }

  clone() {
    // 같은 애니메이션이 동시에 여러개 화면에 표시되어야 하는 경우에는
    // 애니메이션 객체를 복제해서 써야 한다.
    // 이를 위한 유틸 메소드
    return new Animation(this.sprites, this.frames);
  }

  reset() {
    // 애니메이션을 처음으로 되돌리는 메소드.
    // 언젠가는 쓸모가 있을것!
    this.elapsed = 0;
    this.curFrame = 0;
  }

  get current() {
    // 현재 화면에 표시되는 프레임의 스프라이트를 반환하는 함수.
    return this.sprites.get(this.curFrame);
  }

  update (timeDelta){
    // 경과 시간에 따라 애니메이션을 업데이트한다.
    if( this.done ) return;
    this.elapsed += timeDelta;
    if( !this.loop &amp;&amp; this.elapsed &gt; this.duration ){
      // 반복되지 않는 애니메이션인데 끝까지 재생된 경우
      // 재생을 멈추고 마지막 프레임으로 고정
      this.done = true;
      this.curFrame = this.frames.length-1;
    }else{
      let idx = 0, sum = 0;
      while(true){
        sum += this.frames[idx].duration; // 각 프레임의 경과시간을 더해서
        if( sum &gt;= this.elapsed ) break; // 현재 경과 시간보다 크거나 같으면 이 프레임으로 결정
        idx+=1;							 // 아니면 다음 프레임으로..
        idx%=this.frames.length;		 // 다음 프레임이 없으면 처음으로 돌아가자
      }
      this.curFrame = idx;
    }
  }

  draw (ctx, x, y, opt){
    // 스프라이트를 그리는 거랑 동일한 형태인 이유는 바로
    this.sprites.get(this.frames[this.curFrame].frame).draw(ctx, x, y, opt);
    // 스프라이트를 그리는거니까 그렇다! 헤헿
  }
}</code></pre>
이제 애니메이션 객체까지 만들었으니 화면에 뭘 그릴 수 있는 상태가 대충 됐다 헤헿..

물론 아직 갈 길이 멀지만.. 뭐 어떻게든 되겠지.
<h3>캐릭터 만들기</h3>
이제부터 드디어 게임같은 걸 만드는 시점이 왔다. 나는 되는대로 눈에 보이는것부터 만들어서 고쳐나가는 걸 좋아하니까 다함께 캐릭터부터 만들어보도록 하자.

쭉 잘 읽어왔다면 이 게임 구조상 캐릭터나 아이템등의 모든 것들은 Scene 아래에 포함되는 '게임 객체'로 분류한 것을 알고 있을 것이다. 나는 이런 상속 구조를 싫어하긴 하지만 이게 귀차니즘을 덜어주므로 우선 '게임 객체' 클래스를 정의하도록 한다.
<pre><code>class GameObject{
  constructr(){  }
  init(){  }
  update(timeDelta) { }
  render(ctx){ }
}</code></pre>
보다시피 그냥 인터페이스다.

그럼 이제 캐릭터 클래스를 정의하도록 하자.
<pre><code>class Character extends GameObject {
  constructor(){
    // 생성자에서는 캐릭터에 사용될 이미지를 만들고 애니메이션들을 생성해야 한다.
    // 이 내용은 아래의 '캐릭터 애니메이션' 부분에서 다룰테니 기둘!
  }

  init(){
    // 여기서는 각종 변수를 초기화해야 한다.
    // 일단 현재 위치를 나타내는 변수를 만들어봤다.
    this.x = 0;
    this.y = 0;
  }

  update(timeDelta){
    // 캐릭터의 각종 상태를 변경하는 부분.
  }

  render(ctx){
    // 여기서 그려주면 된다.
    // 일단은 현재 위치에 반지름 20픽셀 짜리 빨간 원을 그리는 코드를 넣어보자.
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.arc(0, 0, 20, 0, 2*Math.PI); // 각도는 늘 라디안이라는 점을 잊지 말자!
    ctx.fill();
    ctx.restore();
  }
}</code></pre>
이렇게 클래스를 정의했으면 이걸 GameScene 에 추가해보도록 하자. GameScene 코드의 <code>constructor</code> 메소드 내에 아래 내용을 추가한다.
<pre><code>this.character = new Character();
this.children.push(this.character);</code></pre>
왜 바로 <code>this.children.push(new Character());</code>로 하지 않고 이렇게 별도로 멤버 변수로 할당하느냐면, 게임 장면에서 이 캐릭터에 직접적으로 접근할 일이 앞으로 많을 예정이기 때문이다. 사실은 children 에서 특정 키를 가진 객체를 바로 참조할 수 있는 방식으로 가도 괜찮지만, 귀찮으니까..

그리고 <code>GameScene.render</code> 메소드내에서 <code>super.render(ctx);</code>를 제외한 나머지를 싹 지워주자.

여기까지 진행했으면 아래와 같은 화면이 나올 것이다.

<script async src="https://lazygyu.net//jsfiddle.net/lazygyu/1L464k0w/1/embed/"></script>

화면 왼쪽 위에 빨간 동그라미가 살짝 보이는가? 그 동그라미가 우리가 이제부터 귀여워해줘야 할 우리의 캐릭터다! (실망스럽다...뭐야 저게)
<h4>캐릭터에 기본 물리 법칙 적용</h4>
그럼 이제 우리의 캐릭터를 움직여보도록 하자. 위 코드에 따르면 우리의 캐릭터는 그저 단순히 x/y 변수만 바꿔주면 위치가 바뀐다. 하지만 그냥 그렇게만 해서는 물리적인 움직임을 표현하기가 넘나 힘들다. 우선 <code>init</code> 메소드에 아래와 같은 내용을 추가하자.
<pre><code>this.force = {x:0, y:0};</code></pre>
이 변수는 내 캐릭터에 현재 가해지는 힘을 나타낸다. 앞으로 이 변수를 변화시키면 내 캐릭터가 거기에 맞게 움직이게 해주면 되는데... 그럼 이렇게 움직이는 코드를 <code>update</code>내에 넣어보자.
<pre><code>this.x += this.force.x;
this.y += this.force.y;</code></pre>
그럼 여기에 간단히 중력을 적용하는 코드도 추가하자. 일단 <code>init</code>에 중력을 정의하자. 왜 중력을 상수로 안 쓰고 변수로 하느냐면, 게임이라서 중력이 바뀔 수 있기 때문이다.
<pre><code>this.gravity = 10; //일단 대충 10으로 해보자.</code></pre>
그리고 update에 아까 추가한 두 줄 위에 아래 코드를 넣자.
<pre><code>this.force.y += this.gravity * timeDelta;</code></pre>
timeDelta는 지난 프레임 이후로 흐른 시간이 초단위로 들어있으므로, 지금 정의된 중력은 '초당 10픽셀의 가속도'라고 볼 수 있다. 다들 알고 있겠지만 힘이란건 가속도다.

여기까지 진행한 결과는 아래처럼 나온다.

<script async src="https://lazygyu.net//jsfiddle.net/lazygyu/w3j3j1ug/1/embed/"></script>

한동안 새로고침 하면서 각자 자신이 만든 캐릭터가 떨어지는 모습을 음미하며 즐겨보자. (이 페이지를 새로고침하라는 말은 아니다...그러지마 나 가난해 ㅠㅠ)

그럼 글이 너무 길어지니까 이쯤에서 1편은 마무리... 2편에서 이어가보자!
 ]]></content:encoded>
<link>https://lazygyu.net/blog/html5_js_minigame_tutorial1</link>
<category><![CDATA[ HTML5 게임 개발 튜토리얼 ]]></category>
<pubDate>Fri, 30 Dec 2016 00:11:00 +0900</pubDate>
<guid>https://lazygyu.net/blog/html5_js_minigame_tutorial1</guid>
</item>
<item>
<title><![CDATA[ 아두이노로 가습기 습도 조절하기 ]]></title>
<description><![CDATA[ 겨울이 오면 넘나 건조해서 작년에 가습기를 하나 샀다. 어릴적에 쓰던 가습기 향이 좋기도 하고 해서 가열식으로 샀는데, 아무래도 초음파식보다는 뿜뿜량이 부족한거 같지만 가습 잘 되고 따뜻한 수증기가 나오니까 만족스럽게 사용하고 있었다.

다만 불만이 하나 있다면, 밤에 켜놓고 자면 몇시간 후면 방안이 아주 축축해지고, 아침이 되면 어느새 물이 다 떨어져서 도로 건조해져있다는 점이었다 ]]></description>
<content:encoded><![CDATA[ <h1>아두이노로 가습기 습도 조절</h1>
<img src="https://lazygyu.net/images/blog/1482461725581.jpg_1482583768.jpg" alt="" />
<h2>개요</h2>
겨울이 오면 넘나 건조해서 작년에 가습기를 하나 샀다. 어릴적에 쓰던 가습기 향이 좋기도 하고 해서 가열식으로 샀는데, 아무래도 초음파식보다는 뿜뿜량이 부족한거 같지만 가습 잘 되고 따뜻한 수증기가 나오니까 만족스럽게 사용하고 있었다.

다만 불만이 하나 있다면, 밤에 켜놓고 자면 몇시간 후면 방안이 아주 축축해지고, 아침이 되면 어느새 물이 다 떨어져서 도로 건조해져있다는 점이었다. 그래서 일정 습도를 유지하도록 하면 물도 오래가고 과하게 축축하지도 않겠다는 생각이 들었다.
<h2>구상</h2>
가습기 자체를 조져버리는건 아무래도 나중을 생각하면 좋은 방법이 아닌 것 같아서 그냥 습도에 따라 릴레이로 콘센트에 전기를 껐다 켰다 하게 만들고, 그 콘센트에 가습기를 꽂기로 했다.
<h2>준비물</h2>
<ul>
 	<li>가습기</li>
 	<li>아두이노 프로 미니</li>
 	<li>습도 센서</li>
 	<li>릴레이</li>
 	<li>콘센트</li>
 	<li>기타 (땜납, 전선 등등)</li>
</ul>
<img src="https://lazygyu.net/images/blog/1482163626779.jpg_1482583778.jpg" alt="" />
요녀석이 바로 우리집 가습기

<img src="https://lazygyu.net/images/blog/1482053254242.jpg_1482583787.jpg" alt="" />
주문한 부품들이 도착한 모습!

<img src="https://lazygyu.net/images/blog/1482163431135.jpg_1482584093.jpg" alt="" />
마트에서 산 나머지 부품들...
<h2>코딩</h2>
코딩은 별 거 없다. 습도센서에서 읽어와서 설정한 값보다 낮으면 켜고 높으면 끄고.. 습도 표시 해주고..

<script src="https://gist.github.com/lazygyu/80a6d0956347e857a77387f423ffe050.js"></script>

대충 짠 소스..
<h2>회로구성</h2>
일단 만능기판에 대충 때워가면서 개발을 시작했다.

<img src="https://lazygyu.net/images/blog/1482163627276.jpg_1482584107.jpg" alt="" />

아두이노를 달고, 집구석에서 발견한 FND 를 달고(습도 표시용) 헤더핀 몇 개 달아서 거기다가 습도센서랑 릴레이 연결하고 뒷면에 배선하고.. 그렇게 만든 프로토타입이 잘 동작하는지 확인했다.

그리고 다 동작하는 걸 확인했는데 아무 생각없이 만들다보니 쓸데없이 너무 커다랗다는 걸 깨닫고 작은 사이즈로 다시 만들기로 했다.

<img src="https://lazygyu.net/images/blog/1482461725963.jpg_1482584131.jpg" alt="" />

그래서 작은 사이즈로 잘 부품을 우겨넣고 FND를 달려고 보니까 남은게 없는것이 아닌가!

결국 원래 기판에서 FND를 떼어내는데 실패해서 습도 표시 없는 녀석이 되고 말았다.... 하지만 상관 없겠지..
<h2>케이스</h2>
<img src="https://lazygyu.net/images/blog/1482416485359.jpg_1482584146.jpg" alt="" />

는 그냥 굴러다니던 폼보드로 대충...
<h2>결과</h2>
습도 조절이 되어서 너무 축축해지지 않는 것도 좋지만 역시 물이 아침까지 유지되는 점이 가장 좋은 것 같다. 헤헿....
 ]]></content:encoded>
<link>https://lazygyu.net/blog/humidifier_control</link>
<category><![CDATA[ 아두이노 ]]></category>
<pubDate>Sun, 25 Dec 2016 13:00:00 +0900</pubDate>
<guid>https://lazygyu.net/blog/humidifier_control</guid>
</item>
<item>
<title><![CDATA[ 책상에 키보드 서랍 달기 ]]></title>
<description><![CDATA[ 책상위가 너무 좁다. 나름 큰 책상을 샀는데도 계속 좁다. 내 책상은 특히 신티크때문에 너무 좁아서 하드보드지로 허접한 임시 테이블을 만들어서 이중으로 수납한 상태다. 아내 책상은 그렇게 좁지 않았지만, 얼마전에 마스터키보드를 하나 선물했는데 나름 슬림한 물건인데도 그게 놓이니까 도무지 키보드도 칠 수 없게 좁아졌다. ]]></description>
<content:encoded><![CDATA[ <h1>책상에 서랍 달기</h1>
<img src="https://lazygyu.net/images/blog/IMG_20161218_165350.jpg_1482164685.jpg" alt="" />
<h2>개요</h2>
<img src="https://lazygyu.net/images/blog/IMG_20161218_155606.jpg_1482164710.jpg" alt="" />

책상위가 너무 좁다. 나름 큰 책상을 샀는데도 계속 좁다. 내 책상은 특히 신티크때문에 너무 좁아서 하드보드지로 허접한 임시 테이블을 만들어서 이중으로 수납한 상태다. 아내 책상은 그렇게 좁지 않았지만, 얼마전에 마스터키보드를 하나 선물했는데 나름 슬림한 물건인데도 그게 놓이니까 도무지 키보드도 칠 수 없게 좁아졌다.

<img src="https://lazygyu.net/images/blog/IMG_20161218_155616.jpg_1482164723.jpg" alt="" />

그래서 이걸 해결하기 위해 책상에 서랍을 달기로 결정!
<h2>준비물</h2>
이랄게 뭐 있나. 전동드릴은 집에 있고, 목재와 레일은 철천지에 주문을 넣었다. 원목 키보드 서랍용으로 목재와 레일을 세트로 파는 상품이 있어서 치수만 좀 수정해서 주문을 넣었다. 그리고 잊어버릴 때 쯤 주문한 자재가 도착했다.

<img src="https://lazygyu.net/images/blog/IMG_20161218_155619.jpg_1482164737.jpg" alt="" />

주문하는 곳은 <a href="http://www.77g.com/shopping/prod_wood_view_all.asp?ct=23&amp;co=O1J18761&amp;cd=H18761">여기</a>
<h2>작업과정</h2>
<img src="https://lazygyu.net/images/blog/IMG_20161218_160723.jpg_1482164777.jpg" alt="" />

먼저 목재에 레일을 일케 일게 잘 박은 담에

<img src="https://lazygyu.net/images/blog/IMG_20161218_163932.jpg_1482164784.jpg" alt="" />

한쪽 끝을 책상에 적당히 박아준다. 직각자로 잘 재서 직각만 맞추면 된다.

그리고 서랍을 끼워서 반대쪽 목재를 박을 위치를 잘 표시하고 반대쪽 목재 박고 서랍을 끼워주면 끗.

<img src="https://lazygyu.net/images/blog/IMG_20161218_165018.jpg_1482164810.jpg" alt="" />

글을 쓰긴 쓰는데 너무 간단해서 이거 참...
<h2>결과</h2>
<img src="https://lazygyu.net/images/blog/IMG_20161218_165126.jpg_1482164826.jpg" alt="" />

<img src="https://lazygyu.net/images/blog/IMG_20161218_180155.jpg_1482164850.jpg" alt="" />

넘나 좁았던 책상이 큰 짐이 사라지니까 갱장히 쾌적해졌다!

다만 서랍 높이가 좀 애매한게 흠이지만... 크게 불편할 정도는 아니라서 일단 그냥 쓰기로 했다.

사실 이건 블로그에 하도 글을 안 써서 일단 뭐라도 쓰자는 마음에 써보는 것 뿐....

바니시라도 칠할까 했지만 귀찮아서 안 칠했는데 나름 나쁘지 않다.

<img src="https://lazygyu.net/images/blog/IMG_20161218_181100.jpg_1482164872.jpg" alt="" />
 ]]></content:encoded>
<link>https://lazygyu.net/blog/keyboard_drawer</link>
<category><![CDATA[ 생활 ]]></category>
<pubDate>Tue, 20 Dec 2016 01:10:00 +0900</pubDate>
<guid>https://lazygyu.net/blog/keyboard_drawer</guid>
</item>
<item>
<title><![CDATA[ 리듬게임 쿵치딱 개발기 ]]></title>
<description><![CDATA[ 지난 2016 던파/사퍼 한데이에 참가했던 리듬게임 "쿵치딱"의 개발 과정에 대해 간략하게 정리해본다. 각 세부항목들에 대해서도 기회가 되면 따로 글을 쓰면 좋겠지만 아마도 나는 그렇게까지 부지런할리가 없기 때문에 그런 일은 없을 것 같은 슬픈 예감이 든다.. ]]></description>
<content:encoded><![CDATA[ <h1>쿵치딱 개발기</h1>
<img src="https://lazygyu.net/images/blog/posttitle_0926.png_1474981436.png" alt="리듬게임 쿵치딱" />
<em>리듬게임 쿵치딱 개발에 대한 간략한 후기</em>
<h2>개요</h2>
지난 2016 던파/사퍼 한데이에 참가했던 리듬게임 "쿵치딱"의 개발 과정에 대해 간략하게 정리해본다. 각 세부항목들에 대해서도 기회가 되면 따로 글을 쓰면 좋겠지만 아마도 나는 그렇게까지 부지런할리가 없기 때문에 그런 일은 없을 것 같은 슬픈 예감이 든다..
<h2>발단</h2>
어릴적부터 리듬게임을 좋아했다. 초딩때 QBasic 가지고 혼자 말도 안되는 코드로 게임 만들면서 놀때도 리듬게임을 만들어보려고 삽질 많이 했던 기억이 난다. 나이 먹고 살면서 리듬게임 만들어보겠다는 생각을 까먹고 있었는데, 어느날 문득 재밌을 것 같다는 생각이 들었다.
<h2>개발 시작</h2>
<h3>플랫폼 결정</h3>
<iframe class="youtubeFrm" src="https://lazygyu.net//youtube.com/embed/bMp9GXZC5Kw?rel=0" width="100%" height="500" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
<em>(초기 웹버전 영상. 플레이어는 아내)</em>

처음에는 만들어서 괜찮다 싶으면 회사 홈페이지에 넣어볼까 하는 생각으로 웹 플랫폼으로 개발을 시작했다. 캔버스로 그래픽 붙이고 html5의 오디오 api 를 가지고 실제로 구동되는 게임까지 만들었지만, 브라우저마다 싱크를 맞추기가 너무 어렵고, 오디오와 화면의 싱크를 정밀하게 맞추는 것 자체에 한계가 있었다. 그러던 와중에 던파 한데이 개최 이야기를 듣고 방향을 급 선회해서 아예 실물 오락기를 만들어서 출품해보기로 마음을 바꿨다.
<h3>기획</h3>
던파/사퍼에서 다른 건 욕을 먹어도 유저들 모두가 입을 모아 칭송하는 것이 몇 가지 있는데, 대표적인게 던파의 도트팀과 네오플 게임들의 OST다. 아는 사람은 알겠지만 던파도 사퍼도 브금이나 OST 들이 굉장히 고퀄이다. 이런 요소들이 부각되지 못하는 부분이 늘 안타깝다고 생각했는데, 그런 마음에서 리듬게임이 쉽게 떠올랐던 것 같다.

그래서 브금에 맞춰서 몬스터들이 다가오고, 박자에 맞춰서 버튼을 눌러 그 몬스터들을 처치한다, 라는 간단한 컨셉으로 게임의 가닥이 아주 쉽게 잡혔다.
<h3>소프트웨어</h3>
아무 이유 없이 그냥 monogame 기반으로 개발을 시작했다. 정말 내가 왜 그랬는지 모르겠다. 그 후로 이어진 많은 삽질들을 떠올리면 차라리 그냥 쌩 dx 로 직접 짜는게 나았을것도 같다. 아니면 차라리 코코스나 유니티라도 썼어야 하는건데...

모노게임/XNA 에서 게임을 만들 때 짜증나는 일들이 한두가지가 아니지만, 가장 빡치는 건 역시 한글 출력이다. 얘들은 사용할 글자를 모조리 미리 텍스쳐 스프라이트로 컴파일해두고 이미지를 잘라서 화면에 뿌려주는 방식으로 폰트를 출력하는게 기본 스펙인데, 안타깝게도 한글은 그러기엔 넘나 글자 수가 많다. 그 짓거리를 글자 크기별로, 폰트마다 따로 다 해주려면 아마 실제 코딩보다 폰트 갖다 붙이는 시간이 더 걸릴지도 모르겠다.(물론 그럴리는 없다. 그냥 과장이다.)

그 외에 컨텐츠 매니저를 통하지 않고 외부 리소스들을 불러다 사용하는 것도 쾌적한 편은 아닌데, 기본적으로 프레임워크가 제공하는 컨텐츠 매니저와는 별개로 직접 외부 컨텐츠 관리를 만들어야 하기 때문이다. 어차피 그래야 한다면 차라리 기본 컨텐츠 파이프라인을 안 쓰는게 낫겠지만, 이것도 만들다 보니 생각한거고 막상 만들기 시작할 때는 아무 생각이 없었기 때문에 결국 더러운 코드만이 남고 말았다.

늘 끝나고 생각하면 참 쉽고 좋은 길이 눈에 보이는 법이지...
<h3>리소스</h3>
기본적으로 한데이는 2차창작 행사이기 때문에 나도 평범한 다른 유저들보다 기본적인 조건에서 우위를 가지는 건 불공평하다고 생각했다. 그래서 모든 유저가 얻을 수 있는 리소스(공식 홈페이지의 팬키트 및 구글링으로 찾은 정보들)만 가지고 제작했다. 그 과정에서 힘들었던 건 역시 음악들의 정보를 찾는 거였는데, 특히 각 음악의 BPM 을 제대로 알기가 힘들었다.

<img src="https://lazygyu.net/images/blog/background.png_1474981776.png" alt="" />
<img src="https://lazygyu.net/images/blog/background.png_1474981822.png" alt="" />
배경 그리면서 나는 도무지 배경을 그려본 적이 없다는 걸 뼈저리게 느꼈고...

<img src="https://lazygyu.net/images/blog/charac4.gif_1474981992.gif" alt="" />
도트 찍으면서 나는 도무지 도트를 못 찍는다는 걸 또 느꼈고...

<img src="https://lazygyu.net/images/blog/logo.PNG_1474982103.png" alt="" />
로고도 도무지 못만든다는 걸 느꼈고...

노트 채보 제작도 넘나 힘들고...

아니 난 뭐 잘하는게 없네?!
<h3>하드웨어</h3>
일단 몸체는 MDF 로 만들었다. MDF 재단해서 배송받아서 안 맞는 부분 좀 톱질하고 줄질해서 맞춰 조립했다.

<img src="https://lazygyu.net/images/blog/%EC%83%81%ED%8C%90_%EB%B2%84%ED%8A%BC.png_1474982127.png" alt="" />
상판은 아크릴로 만들었는데 치수 재서 간판집에 재단 맡겼더니 생각보다 저렴했다. 다만 화살표부분은 치수를 잘못 잰 건지 좀 안 맞아서 분노의 줄질로 어떻게든 어거지로 맞췄다.

리듬게임용 버튼은 IST 몰에서 구매.

스피커는 집에 굴러다니던 평범한 PC용 스피커를 뜯고 잘라서 몸체에 부착.

팬은 다나와에서 한 삼천원 주고 사서 달았고..

본체는 아내 생일에 새 컴퓨터 사주고 남은 아내의 옛날 컴퓨터를 뜯어서 넣었다. 나무로 된 케이스 바닥에 대충 메인보드 나사구멍 맞춰서 남는 나무조각 붙이고 피스로 보드를 그냥 고정. 파워도 비슷하게 고정했다. 하드디스크는 운송중에 파손의 우려가 가장 크기 때문에 꺽쇠 몇 개 써서 살짝 띄운 채 고정.

<img src="https://lazygyu.net/images/blog/%EC%97%91%EB%B0%95%ED%8C%A8%EB%93%9C.png_1474982147.png" alt="" />
컨트롤러는... 약 6년 정도 사용했던 엑박 360 컨트롤러를 뜯어서 기판에 납땜해서 사용. 정품으로 구매한 xpadder 가 있어서 버튼 배선에 별 부담없이 대충 납땜해서 붙여버렸다.

하드디스크가 남는게 없어서 고민이었지만 아내가 예전에 쓰던 외장하드를 기꺼이 내어줘서 그거 뜯어서 달았다.

<iframe class="youtubeFrm" src="https://lazygyu.net//youtube.com/embed/k2rMHpLQxkM?rel=0" width="100%" height="500" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
<em>대충 만들어진 프로토타입 기기 시연 영상. 플레이어는 물론 아내</em>
<h2>던파/사퍼 한데이 참가</h2>
어떻게든 완성했으니 이걸 가지고 행사에 직접 참가하는 일이 남았는데, 사실 이게 만드는 것보다 더 큰일이다.
<h3>운송</h3>
<img src="https://lazygyu.net/images/blog/WP_20160927_00_54_16_Rich.jpg_1474982266.jpg" alt="" />
일단 스티로폼을 사다가 기기를 감싼 뒤에 폐물장에서 커다란 박스들을 주워다 잘라서 겉을 감쌌다. 이 정도로 충격을 버텨주길 기도하는 마음으로... 다행히도 모니터를 행사측에서 지원해주기로 해서 큰 시름을 덜었다. 그거 아니었으면 모니터 못 들고 가서 울며 잠이 들었을 것...

무게를 재 보니 대충 15kg 이 안 될 것 같아서 일단 무작정 들고 공항에 갔더니 친절하게도 파손주의랑 상단 방향 표시 스티커를 붙여서 잘 받아주었다. 서울에 도착해서 시운전할 때도 별 문제 없었고. 돌아올 때도 마찬가지로 포장해서 비행기에 그냥 싣고 돌아왔다. 조금 더 작게 만들걸 하는 생각이 들었지만.. 뭐 다음번에 혹시나 또 뭔가를 만들게 된다면 그 때 참고하도록 하자.

<img src="https://lazygyu.net/images/blog/IMG_2259.JPG_1474982344.jpg" alt="" />
<em>공항 카트에 쏙 들어가는 아담한(?) 기기를 신나게 옮기는 모습</em>
<h3>행사</h3>
<img src="https://lazygyu.net/images/blog/before_open1.png_1474983058.png" alt="" />
<img src="https://lazygyu.net/images/blog/before_open2.png_1474983081.png" alt="" />
<em>오픈 직전에 찍은 부스 모습</em>

<img src="https://lazygyu.net/images/blog/IMG_2299.JPG_1474982510.jpg" alt="" />
<em>손에 든 게 바로 무선키보드</em>

행사 전날에 먼저 도착해서 현장에서 지원받은 모니터를 받아서 부스에 기계만 일단 설치했다. 시운전 후 잘 동작하는 것을 확인. 그치만 아무래도 불안함이 가시지 않아서 근처 이마트에서 무선 키보드&amp;마우스 세트를 구매했다. 이건 정말 신의 한 수였는데, 간간히 게임이 튕기는 일이 뒤늦게 발견되었지만 당황하지 않고 빛의 속도로 게임을 재기동시켜줄 수 있었던 것이다! 정말이지 다행이야.

<img src="https://lazygyu.net/images/blog/%EB%B6%80%EC%8A%A4%20%EC%A4%84.jpg_1474982532.jpg" alt="" />
<img src="https://lazygyu.net/images/blog/IMG_2285.jpg_1474982940.jpg" alt="" />
<em>쿵치딱을 하기 위해 줄 선 유저들</em>

<img src="https://lazygyu.net/images/blog/720858_1474794384.jpg_1474982571.jpg" alt="" />
<em>게임조선 기사에 나온 사진. 기사는 <a href="https://lazygyu.net//df.gamechosun.co.kr/board/view.php?bid=report&amp;num=2609772">여기</a></em>

행사 당일은... 정말이지 성황리에 마쳤다. 오전 10시 되기 조금 전부터 오후 5시까지 기계가 쉬었던 시간이 다 합쳐도 1분이나 될런지.. 끊임없이 유저들이 모여서 게임을 즐기는 모습에 뿌듯뿌듯.. 여러번 줄을 서가며 플레이하는 사람들도 꽤 많았다.

행사 전체적으로 여성 유저 비율이 훨씬 높았는데, 그 와중에 우리 부스에는 남성유저가 많이 모였던 것도 특이한 점이랄까.

아쉬운 것은... 집에 굴러다니던 싸구려 스피커를 붙였더니 음량이 부족했던 점이다.

그 외에 그래픽을 좀 더 신경써서 마무리하지 못하고 대충 그리다 만 채로 가동한 것도 아쉽고...

<img src="https://lazygyu.net/images/blog/160927_userphoto.png_1474983186.png" alt="" />
<em>유저분의 블로그에서 발견한 사진(팔에 이름표도 열심히 만들었는데 나온 사진이 이거 정도 뿐)</em>

<img src="https://lazygyu.net/images/blog/cyphers_hp.png_1474983404.png" alt="" />
<em>사퍼 공식 홈페이지 매거진에 실린 사진(플레이하는거 저 아님!)</em>
<h2>기타</h2>
<img src="https://lazygyu.net/images/blog/%EC%BF%B5%EC%B9%98%EB%94%B1%ED%8C%A8%EB%84%90-copy.jpg_1474983867.jpg" alt="" />
<img src="https://lazygyu.net/images/blog/%EC%98%A4%EB%8A%98%EB%A7%8C%EB%AC%B4%EB%A3%8C.jpg_1474983878.jpg" alt="" />
<img src="https://lazygyu.net/images/blog/%EC%BF%B5%EC%B9%98%EB%94%B1.jpg_1474983885.jpg" alt="" />

아내가 부스의 배너들과 사은품 자석을 열심히 만들어서 도와주었다. 게임의 구리디 구린 화면 레이아웃도 고쳐주고 각 음악들의 타이틀 이미지도 만들어 주었다. 정말 디자이너 아내는 최고다.

각 음악들의 저작권은 당연히 네오플에 있다. 음악들의 커버 이미지의 저작권도 물론 네오플꺼.

유저들이 간간히 이거 출시되는건지, 모바일 게임으로는 안 나오는지 물어왔는데... 그게 또 뭐 그렇게 간단한 문제가 아니니까...나도 잘 모르겠당.

담에 시간 나면 각 부분에 대해 좀 더 디테일하게 써보면 좋겠다.

일단 이 글은 여기까지...

마지막으로 게임 플레이 영상 투척

<iframe class="youtubeFrm" src="https://lazygyu.net//youtube.com/embed/UIgujc1lg3I?rel=0" width="100%" height="500" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
 ]]></content:encoded>
<link>https://lazygyu.net/blog/koongchittak</link>
<category><![CDATA[ 개발 기타 ]]></category>
<pubDate>Mon, 26 Sep 2016 22:00:00 +0900</pubDate>
<guid>https://lazygyu.net/blog/koongchittak</guid>
</item>
<item>
<title><![CDATA[ 카오디오 장착하기 ]]></title>
<description><![CDATA[ 내 차는 연식이 오래된 모델이다. 나름 한정판이라고 최고사양이라서 이것저것 만족하면서 타고 있지만 세월의 흐름을 비껴갈 수 없는 게 있었으니 그건 바로 오디오! ]]></description>
<content:encoded><![CDATA[ <h2>개요</h2>
내 차는 연식이 오래된 모델이다. 나름 한정판이라고 최고사양이라서 이것저것 만족하면서 타고 있지만 세월의 흐름을 비껴갈 수 없는 게 있었으니 그건 바로 오디오!

당시로서는 그래도 아주 큰 특혜랄 수 있는 6CD 가 들어가는 순정 씨디 체인저가 포함되어있지만(그나마도 이것도 한정판이라 들어있는 거고 원래는 없다고 한다...) USB도 안되고 블루투스도 안되는 건 아주 치명적인 약점이 아닐 수 없다. 결국 오디오를 교체하기로 마음먹게 되는데..
<h2>오디오 구매</h2>
늘 생각만 하다가 문득 지마켓에서 저렴한 카오디오 헤드유닛을 발견해서 냅다 지름!

차종을 쓰는 곳이 있길래 아무 생각 없이 206cc 라고만 적었는데 판매자한테 전화 와서 대체 차종이 뭐냐는 질문을 들었다. 결국 모르는 차라 잭은 개조 못해준다길래 알았다고 했더니 너덜너덜한 민짜 커넥터만 포함해서 왔다. 하지만 아무렴 어때!
<h2>기존 오디오 탈거</h2>
<img src="https://lazygyu.net/images/blog/WP_20160525_21_55_21_Rich.jpg_1464188061.jpg" alt="" />

오디오를 탈거 하기 위해서 철사 옷걸이 하나를 잘라서 탈거용 툴을 만들었다. 쑥~! 하고 뽑으니까 그냥 잘 뽑혀나와서 탈거는 쉽게 해결!
<h2>배선 및 확인</h2>
그리고 나면 이제 배선을 확인해야 한다. 새로 산 오디오 배선이야 친절하게 종이에 써서 동봉해줬고, 내 차 배선이 문제인데... 이건 뽑아낸 오디오 모델을 구글에 던져넣고 찾아냈다.

<a href="https://www.c5club.cz/files/pdf/PU-2472A.pdf">https://www.c5club.cz/files/pdf/PU-2472A.pdf</a> 쨘 바로 이거!

이거랑 새로 산 오디오 배선을 확인하면서 하나씩 신중하게 잘라서 이어주면 된다!

<img src="https://lazygyu.net/images/blog/WP_20160525_22_10_00_Rich.jpg_1464188094.jpg" alt="" />

우선 전원선을 따서 연결하고..

<img src="https://lazygyu.net/images/blog/WP_20160525_22_14_48_Rich.jpg_1464188108.jpg" alt="" />

전원이 잘 들어오는지 확인!

<img src="https://lazygyu.net/images/blog/WP_20160525_22_25_54_Rich.jpg_1464188123.jpg" alt="" />

내비 AUX 도 잘 되는지 확인!

물론 다 잘 된다.
<h2>마무리</h2>
<img src="https://lazygyu.net/images/blog/WP_20160525_23_10_24_Rich.jpg_1464188157.jpg" alt="" />

요렇게 잘 맞춰서 쑤욱

<img src="https://lazygyu.net/images/blog/WP_20160525_23_10_34_Rich.jpg_1464188171.jpg" alt="" />

쑥! 넣으면 완성!!
<h2>남은 작업</h2>
내비용 AUX 는 헤드유닛 뒤쪽에 있는 별도 단자에 꽂아야 하는데 일단 오밤중에 내장재를 뚫기는 좀 그래서 냅뒀다. 주말에나 해야 할듯.

씨디 체인저도 안 쓰니까 뽑아내야 하는데 이것도 나중에...
 ]]></content:encoded>
<link>https://lazygyu.net/blog/caraudio_install_to_206cc</link>
<category><![CDATA[ 생활 ]]></category>
<pubDate>Thu, 26 May 2016 04:00:00 +0900</pubDate>
<guid>https://lazygyu.net/blog/caraudio_install_to_206cc</guid>
</item>
<item>
<title><![CDATA[ Windows10 Mobile용 자전거 내비 개발 ]]></title>
<description><![CDATA[ 윈도폰을 벌써 세 개째 쓰고 있지만, 이전 폰까지는 윈도 스토어에 있는 티맵이 잘 동작해서 별 생각이 없었다. 그런데 루미아950XL로 폰을 바꾼 뒤 보니까 티맵이 여기엔 설치가 안된다!! 이유는 정확히 알 수 없지만 하드웨어 요구사항을 충족하지 않는다나...

어쨌든 최근에 자전거를 샀는데 길을 모르면 자전거를 타고 함부로 나갈 수가 없기 때문에 자전거용 내비를 만들어야겠다는 생각을 했다. ]]></description>
<content:encoded><![CDATA[ <img src="https://lazygyu.net/images/blog/wp_ss_20160303_0005.png_1457018705.png" alt="" />
<h1>개요</h1>
윈도폰을 벌써 세 개째 쓰고 있지만, 이전 폰까지는 윈도 스토어에 있는 티맵이 잘 동작해서 별 생각이 없었다. 그런데 루미아950XL로 폰을 바꾼 뒤 보니까 티맵이 여기엔 설치가 안된다!! 이유는 정확히 알 수 없지만 하드웨어 요구사항을 충족하지 않는다나...

어쨌든 최근에 자전거를 샀는데 길을 모르면 자전거를 타고 함부로 나갈 수가 없기 때문에 자전거용 내비를 만들어야겠다는 생각을 했다.
<h1>개발 과정</h1>
<h2>개발 환경 선택</h2>
먼저 제일 중요한 건 길찾기와 지도다. 이걸 어디서 가져오느냐... 역시 티맵이 진리 아닐까? 하는 마음에 티맵 API 가 있는지 찾아봤는데, 있었다!

늘 그렇지만 API 는 iOS, Android, Web(javascript) 이렇게 세 가지만 지원하고 있었다. 앞의 두 개는 당연히 안되고, 그러면 어쩔 수 없이 js 버전을 사용할 수 밖에 없다. 결국 티맵 API 가 나머지 개발 환경을 결정지어 버렸다.
<h2>Tmap API</h2>
일단 개발자 등록을 한다. 이건 뭐 별로 설명할 건덕지가 없다. 그냥 하면 된다. 개발자 등록 하고, 앱 등록 하고, sdk 사용법을 대충 보면 된다.

UWP 개발시 외부 스크립트를 불러오려고 하면 보안때문에 불러와지지 않는다. 이 부분은 <code>package.appxmanifest</code> 에서 <code>Content URIs</code> 에다가 <code>ms-appx-web://</code> 를 넣고 <code>WinRT Access</code> 를 <code>All</code> 로 설정한 뒤에 <code>Application</code> 항목의 <code>Start page</code> 를 <code>ms-appx-web://default.html</code> 로 변경해서 해결했다.

외부 스크립트, css, 지도 데이터 등등등을 불러와야 하기 때문에 <code>Capabilities</code> 에서 <code>Internet (Client)</code>, <code>Internet (Client &amp; Server)</code>, <code>Private Networks (Client &amp; Server)</code> 를 설정해줘야 한다.

지도를 표시하는 부분은 어렵지 않지만, 현재 진행 방향에 맞춰서 지도를 회전하려고 보니까 딱히 그런 API 를 제공하지는 않는 것 같다. 그래서 그냥 지도 크기를 화면상의 지도보다 크게 만들어서 돌리는 걸로 해결했다. 왜 크게 만들어야 하냐면 지도가 사각형 공간에 표출되기 때문에 회전하다보면 빈 공간이 보이기 때문이다. 피타고라스찡이 잘 정리해준대로 화면상의 지도 영역의 대각선 길이를 구한(sqrt(w<em>w+h</em>h)) 다음에 각 변을 대각선길이만큼 설정한 지도를 생성하면 된다.

장소 검색이야 뭐 그냥 API 에서 잘 뱉어줬고.. 경로 탐색도 문서 보고 삽질 좀 하니까 잘 됐다. 경로 표시해주는 부분은, 그러라고 만들어 둔 거 같진 않았지만 티맵 API 페이지의 기본 예제를 뜯어보고 어떻게 요래조래 구현했다.

사실 테스트하면서 사용해보니까 별 필요는 없었지만 그래도 구색을 갖추기 위해 단계별로 안내 문구도 표시해주게 했지만... 글쎄 이게 뭐 딱히 큰 쓸모가 있을지는...

스토어 제출을 위해서 패키지를 업로드하고 나서야 재탐색 버튼을 안 만든 걸 떠올렸지만 일단 뭐 없어도 별 상관은 없으니까.. 다음에 혹시 버전업 하게 되면 추가해야지.

개인적으로 사용해본 결과, 자전거용 내비에 자동 재탐색 기능은 별 쓸모가 없었다. 그냥 길에서 좀 벗어나도 원래 경로를 계속 표시해주는 게 더 편하더라. 혹시 아닌 사람이 있을지도 모르니까 이 부분도 나중에 버전업하게 되면 추가해야겠다.
<h2>ReactJS</h2>
어차피 웹앱(이라기도 애매하다 <code>UWP</code>-Universal Windows Platform으로 빌드하면 js 파일을 모조리 바이트코드로 컴파일해준다)이니까 좀 편하게 개발하기 위해서 리액트를 갖다 쓰기로 했다. 일단 리액트 홈페이지에 가서 예제를 좀 보고 최신 버전 파일을 다운받아서 프로젝트에 포함시켰다. 리액트를 처음 본 거라 삽질을 꽤 하긴 했지만 jsx 가 편해서 결국은 훨씬 간단하게 구현되었다.
<h2>webpack</h2>
요즘 리액트는 babel로 컴파일해야 되는 것 같다. 어차피 앱이란 게 배포하고 나서 라이브로 수정할 일이 없으니 사전에 컴파일해서 js 파일로 만들어 두는 게 좋다. 그래서 찾아낸 게 웹팩이었다. 하는 김에 css 대신 <code>less</code> 도 쓰기로 했다.

빌드 할 때 자동으로 webpack 으로 컴파일하는 과정을 먼저 넣으면 좋겠지만 컴맹인 나는 그런 설정 방법은 모른다. 그런데 시간 쓰고 싶지도 않고.. 그래서 그냥 간단하게 jsx 파일이랑 less 파일을 모아서 번들로 뽑아내도록 <code>webpack.config.js</code>파일을 작성하고 웹팩 빌드 명령어를 외부 툴에 넣은 뒤 단축키를 설정했다. 그냥 빌드 전에 눌러주면 bundle.js 파일이 생성된다.
<h2>GPS</h2>
처음에는 멍청하게 웹 브라우저의 <code>location</code> API 를 가지고 작성했다. 아마 자꾸 브라우저에서 테스트하다 보니까 그랬던 거 같다. 생각해보면 이건 어차피 윈도 스토어 앱이니까 그냥 <code>Windows.Devices.Geolocation</code> 네임스페이스에 있는 API 들로 변경했다.

현재 향한 방향의 경우에는... GPS 에서 주는 방향은 이동중에만 확인이 가능하다. 이 부분도 개선안을 생각은 해뒀는데 코드에 넣는다는 걸 까먹고 그냥 스토어에 패키지를 제출해버렸당...
<h2>이미지 리소스</h2>
<img src="https://lazygyu.net/images/blog/Square150x150Logo.scale-200.png_1457018753.png" alt="" />

로딩 이미지는 웹에서 찾아 썼고 나머지는 그렸다. 지도 이미지는 당연한 얘기지만 SK 제공이고, 작은 아이콘들은 <code>Segoe MDL2 Assets</code> 랑 <code>Segoe UI</code> 폰트들에 들어있는 문자들을 그냥 썼다. 어차피 윈도 앱이니까 이런건 걱정이 없다.
<h2>스토어 등록</h2>
대충 만들고 좀 테스트 해 보고 적당히 동작하는거 확인한 후에 그냥 패키징해서 윈도 스토어에 제출했다. 투잡 금지 규정에 묶여있기 때문에 광고도 못 달고 무료 앱이라서 속은 쓰리지만, 뭐 그러니까 이렇게 대충 만든 것도 거리낌 없이 막 올리는 거니까 그 부분은 장점일지도 모른다. 개발자 등록 해 둔 게 아까우니까 뭐든간에 만들면 재깍재깍 등록하는게 좋을 것 같다.

스토어에 등록하기 전에 꼭 해야 하는 작업이 뭐냐면, .js 파일을 모조리 <code>UTF-8 + BOM</code> 인코딩으로 변경해서 저장하는 거다. 바이트코드를 생성하려면 이게 기본 조건이다. utf-8 까진 이해하는데 마소는 왜 이렇게 BOM 을 좋아하는건지 모르겠다. 아 귀찮은 놈들 같으니..
<h1>기타</h1>
난 디자인 감각이 정말 구리다. 내가 열심히 만든 앱을 보고 아내가 비웃더니 조금씩 조금씩 고칠 부분을 알려줬는데, 아 정말 어이없게 사소한 것들인데도 고치니까 훨씬 나아졌다. 디자인 감각을 연마하려면 뭘 해야 하는걸까...

자전거 사놓고 별로 안 타게 될 것 같아서 불안했는데 이거 만드는 동안 테스트하느라 그나마 좀 타게 된 건 정말 장점이다. 날씨 풀리면 더 타야지.

그러나 저러나 다른건 다 그렇다 치고 그냥 티맵이 설치만 됐어도 내가 굳이 이 짓은 안 했을텐데..

다음에 이거 달고 자전거 타러 나갈 때는 앱 작동 영상을 찍어서 추가해야지. GPS 기반 앱은 방구석에 앉아서는 제대로 작동 영상을 찍을 수가 없다는 단점이 있다.

스토어 등록이 완료되더라도 사실 윈도폰 사용자가 국내에 별로 없고 그 중에 자전거를 타면서 핸드폰으로 내비를 보고 싶은 사람은 정말 별로 없을 예정이기 때문에 아마 다운로드 수는 처참할 게 분명하다. 안타까운 일이다. 선점효과 따위 없는 윈도폰의 현실 ㅠㅠ
 ]]></content:encoded>
<link>https://lazygyu.net/blog/bicycle_navigation_for_win10</link>
<category><![CDATA[ 개발 기타 ]]></category>
<pubDate>Wed, 11 May 2016 22:00:00 +0900</pubDate>
<guid>https://lazygyu.net/blog/bicycle_navigation_for_win10</guid>
</item>
    </channel>
  </rss>
  