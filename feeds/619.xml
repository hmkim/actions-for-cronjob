<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by 유희철 on Medium]]></title>
        <description><![CDATA[Stories by 유희철 on Medium]]></description>
        <link>https://medium.com/@ryuheechul?source=rss-c5f54e6e07e1------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/0*V3buyoKXxkV-0QdQ.jpeg</url>
            <title>Stories by 유희철 on Medium</title>
            <link>https://medium.com/@ryuheechul?source=rss-c5f54e6e07e1------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Tue, 14 May 2019 01:22:37 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@ryuheechul" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[Thanks for the concise and quality post!]]></title>
            <link>https://medium.com/@ryuheechul/thanks-for-the-concise-and-quality-post-ed007c546a22?source=rss-c5f54e6e07e1------2</link>
            <guid isPermaLink="false">https://medium.com/p/ed007c546a22</guid>
            <dc:creator><![CDATA[유희철]]></dc:creator>
            <pubDate>Thu, 21 Mar 2019 07:22:30 GMT</pubDate>
            <atom:updated>2019-03-21T07:22:30.181Z</atom:updated>
            <content:encoded><![CDATA[<p>Thanks for the concise and quality post!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ed007c546a22" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[꼭 같은 일은 겪은 건 아니지만 공감이 가는 부분이 많이 있었습니다. 좋은 글 잘 읽었습니다. ]]></title>
            <link>https://medium.com/@ryuheechul/%EA%BC%AD-%EA%B0%99%EC%9D%80-%EC%9D%BC%EC%9D%80-%EA%B2%AA%EC%9D%80-%EA%B1%B4-%EC%95%84%EB%8B%88%EC%A7%80%EB%A7%8C-%EA%B3%B5%EA%B0%90%EC%9D%B4-%EA%B0%80%EB%8A%94-%EB%B6%80%EB%B6%84%EC%9D%B4-%EB%A7%8E%EC%9D%B4-%EC%9E%88%EC%97%88%EC%8A%B5%EB%8B%88%EB%8B%A4-%EC%A2%8B%EC%9D%80-%EA%B8%80-%EC%9E%98-%EC%9D%BD%EC%97%88%EC%8A%B5%EB%8B%88%EB%8B%A4-73995f2c8e36?source=rss-c5f54e6e07e1------2</link>
            <guid isPermaLink="false">https://medium.com/p/73995f2c8e36</guid>
            <dc:creator><![CDATA[유희철]]></dc:creator>
            <pubDate>Thu, 14 Feb 2019 08:19:14 GMT</pubDate>
            <atom:updated>2019-02-14T08:19:14.981Z</atom:updated>
            <content:encoded><![CDATA[<p>꼭 같은 일은 겪은 건 아니지만 공감이 가는 부분이 많이 있었습니다. 좋은 글 잘 읽었습니다. 👏🏼</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=73995f2c8e36" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[hands down?]]></title>
            <link>https://medium.com/@ryuheechul/hands-down-65229b388dfe?source=rss-c5f54e6e07e1------2</link>
            <guid isPermaLink="false">https://medium.com/p/65229b388dfe</guid>
            <dc:creator><![CDATA[유희철]]></dc:creator>
            <pubDate>Mon, 17 Dec 2018 02:13:25 GMT</pubDate>
            <atom:updated>2018-12-17T02:13:25.426Z</atom:updated>
            <content:encoded><![CDATA[<p>hands down?</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=65229b388dfe" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[권한을 찾아서: GitHub Team을 이용하여 Kubernetes 계정 인증하기 (3)]]></title>
            <link>https://medium.com/rainist-engineering/k8s-auth-with-github-team-part3-7e976adcf4c6?source=rss-c5f54e6e07e1------2</link>
            <guid isPermaLink="false">https://medium.com/p/7e976adcf4c6</guid>
            <category><![CDATA[auth]]></category>
            <category><![CDATA[devops]]></category>
            <category><![CDATA[security]]></category>
            <category><![CDATA[kubernetes]]></category>
            <category><![CDATA[backend-development]]></category>
            <dc:creator><![CDATA[유희철]]></dc:creator>
            <pubDate>Mon, 10 Sep 2018 08:22:09 GMT</pubDate>
            <atom:updated>2018-10-26T06:42:06.873Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/480/1*eu-rLDmz1EsDGzbONkneIQ.png" /></figure><p><a href="https://medium.com/rainist-engineering/k8s-auth-with-github-team-part2-a8affa559570">바로 이전 포스트에서는</a> Guard를 이용해서 Authn 시스템을 구축했습니다. 즉 접속하는 유저가 누구이고 어떤 팀에 속해있는지 구별할 수 있게 되었고요. 이번에는 Role-based access control, 즉 RBAC를 이용해서 각각의 유저 혹은 그룹 마다 다른 권한을 부여하는 즉 Authz를 구성해보도록 하겠습니다.</p><blockquote><a href="https://kubernetes.io/blog/2017/10/using-rbac-generally-available-18/">k8s 1.8 버전 부터 RBAC 기능이 GA 로 승격되고</a> 특별히 옵션을 끄지 않는 이상 기본으로 적용되어 있습니다.</blockquote><p><a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">RBAC 에 대해서는 공식 문서에 자세히 설명이 되어있으니 참고해 주시고</a>, 여기서는 <a href="https://help.github.com/articles/about-teams/">Github 팀</a> 권한 인증을 위해 필요한 최소한의 개념만을 다루도록 하겠습니다. 일단 RBAC 에 관련된 리소스 중 Role/ClusterRole, RoleBinding/ClusterRoleBinding 에 대해서 알아야 합니다.</p><p>Role은 API/리소스 별로 권한을 설정하는 리소스입니다.</p><pre><strong># Role의 간단한 예제<br>kind: Role<br>apiVersion: rbac.authorization.k8s.io/v1<br>metadata:<br>  namespace: default<br>  name: pod-reader<br>rules:<br>- apiGroups: [&quot;&quot;] </strong><strong><em># &quot;&quot; 는 Core API 를 의미합니다.</em></strong><strong><br>  resources: [&quot;pods&quot;]<br>  verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;]</strong></pre><p>위의 예제는 pod-reader 라는 이름의 default 네임스페이스에서만 유효한 Role입니다. rules: 를 보시면 apiGroups, resources, verbs 등을 지정하여 특정 리소스에 대한 접근권한을 제어합니다. $ kubectl get role --all-namespaces 라고 입력하면 모든 네임스페이스에 있는 Role을 리스트업 할 수 있고 $ kubectl get role my-role -n my-namespace -o=yaml 을 통해서 각각의 Role 이 어떻게 설정되어있는지 살펴보실 수 있습니다.</p><p>ClusterRole과 다른 점은 이 Role이 적용되는 범위가 특정 네임스페이스인지 모든 네임스페이스(cluster-wide) 인지, 그 범위만 다릅니다.</p><p>위와 같은 Role을 실제로 적용하기 위해서는 RoleBinding 오브젝트를 만들어 등록해야 합니다.</p><pre><strong><em># jane 이라는 유저에게 pod-reader 라는 역할을 바인딩시키는 RoleBinding read-pods 라는 이름의 오브젝트 입니다.<br></em></strong><strong>kind: RoleBinding<br>apiVersion: rbac.authorization.k8s.io/v1<br>metadata:<br>  name: read-pods<br>  namespace: default<br>subjects:<br>- kind: User<br>  name: jane </strong><strong><em># 이름은 대소문자를 구별합니다.</em></strong><strong><br>  apiGroup: rbac.authorization.k8s.io<br>roleRef:<br>  kind: Role </strong><strong><em># Role 또는 ClusterRole을 지정할 수 있습니다.</em></strong><strong><br>  name: pod-reader </strong><strong><em># 실제 존재하는 역할과 매치되어야 합니다.</em></strong><strong><br>  apiGroup: rbac.authorization.k8s.io</strong></pre><p>이렇게 역할의 정의와 바인딩을 분리함으로써 하나의 역할을 다수의 RoleBinding과 ClusterRoleBinding에 적용할 수 있습니다.</p><blockquote>자 그럼 지금까지 습득한 내용을 기반으로 실제 여러분의 Github 팀과 Role을 묶어Binding 보도록 하겠습니다.</blockquote><h3>먼저 “나”에게는 k8s 내에 모든 걸 할 수 있는 cluster-admin 권한을 할당 해보도록 하겠습니다.</h3><p><a href="https://github.com/orgs/Rainist/new-team">https://github.com/orgs/{my-org}/new-team</a> 에 접속하여 새로운 팀을 만들어줍니다. 여기서는 admin-k8s 라는 이름으로 만들겠습니다.</p><p>우리가 적용하고자 하는clusterrole/cluster-admin 은 이미 존재하니 — $ kubectl get clusterrole cluster-admin — 건너뛰고 ClusterRoleBinding을 아래와 같이 작성합니다.</p><pre>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRoleBinding<br>metadata:<br>  name: admin-k8s-team<br>roleRef:<br>  apiGroup: rbac.authorization.k8s.io<br>  kind: ClusterRole<br>  name: cluster-admin<br>subjects:<br>- apiGroup: rbac.authorization.k8s.io<br>  kind: Group # Group 이라고 지정함으로써 Github Team을 가르켰습니다.<br>  name: admin-k8s # 대소문자를 구별함으로 주의해주세요</pre><blockquote>admin-k8s-team-rb.yml 등의 이름으로 파일을 생성하여 $ kubectl create -f admin-k8s-team-rb.yml 와 같은 명령어로 ClusterRoleBinding을 등록해 줍니다.</blockquote><p>그리고 ~/.kube/config 파일을 열어서 아래 내용을 users: 에 추가해주시구요</p><pre>users:<br>- name: my-github-token<br>  user:<br>    token: tttttt26ooooo275kkkkkk2f27eeeee51cnnnnnn</pre><blockquote><em>위의 </em><em>token 항목 에는 2편에서 발급 받은 Github 토큰 값을 넣으시면 됩니다.</em></blockquote><p>context 항목도 아래와 같이 수정하여 기존 kops 발급된 어드민용 인증 정보 대신 Github credential 을 사용하도록 변경합니다.</p><pre>- context:<br>    cluster: my.cluster.k8s.local<br>    user: my-github-token</pre><p>이제 $ kubectl get nodes 라고 입력했을 때 클러스터의 노드 리스트를 볼 수 있다면 드디어 Github Team + Guard + RBAC 를 이용한 인증에 성공했다고 보면 됩니다! 🎉</p><p><em>이러한 인증방식은 Github와 연동 되는 부분이 있기 때문에 처음에는 인증하는데에 몇 분 정도 시간이 필요할 수 있습니다. 이런 경우에는 몇 분 정도 기다렸다가 다시 시도해보세요.</em></p><blockquote>조금 더 확실하게 연동이 잘 되었는지를 테스트 하고 싶으시다면 ~/.kube/config 파일을 잘 백업해두신 후에 기존에 kops가 만들어준 어드민 user 항목을 삭제하시고 kubectl의 기능이 잘 동작하는지 확인해 볼 수 있습니다.</blockquote><h3>자 이번에는 k8s admin이 아닌 백엔드 팀에게 권한을 부여해보도록 하겠습니다.</h3><p>여러분이 직접 하실 때는 각 팀에게 꼭 필요한 권한만을 가지고 있는 Role/ClusterRole 을 만들어서 사용하시길 권장합니다. 이번 예제에서는 클러스터 구성 시 생성되는 clusterrole/edit을 사용하도록 하겠습니다.( $ kubectl get clusterrole edit -o=yaml )</p><p>그러면 ClusterRole이 준비되었으니 아래와 같이 RoleBinding을 작성합니다.</p><pre>apiVersion: rbac.authorization.k8s.io/v1<br>kind: RoleBinding # 이번에는 ClusterRolebinding이 아님을 주의하세요<br>metadata:<br>  name: backend-team<br>  namespace: development # RoleBinding의 경우는 네임스페이스를 지정합니다<br>roleRef:<br>  apiGroup: rbac.authorization.k8s.io<br>  kind: ClusterRole<br>  name: edit<br>subjects:<br>- apiGroup: rbac.authorization.k8s.io<br>  kind: Group # Group이라고 지정함으로써 Github Team을 가르켰습니다.<br>  name: backend # 대소문자를 구별함으로 주의해주세요</pre><p>위의 RoleBinding 을 k8s 클러스터에 등록하면 ($ kubectl apply -f my-role.yaml) 이제 Github 의 backend 팀으로 등록된 멤버들은 clusterrole/edit에 부여된 권한을 갖게 되었습니다.</p><blockquote>이제 다음으로 해당 팀원들이 k8s 클러스터에 접근 할 수 있도록 알려줘야 합니다.</blockquote><p>사실 위에서 이미 ~/.kube/config 파일을 수정한 것에서 몇가지 작업만 더하면 됩니다.</p><ol><li>user 항목의 name: admin인 유저를 찾아서 지워주시고요. 특히 client-key-data 를 가지고 있는 유저는 꼭 지워야 합니다.</li><li>본인의 Github 토큰을 공유하고 싶지 않을테니 해당 토큰을 포함한 유저도 지우거나 토큰을 의미 없는 값으로 변경하신 후 저장하면 이제 모든 팀원에게 공유할 수 있는 형태의 템플릿이 되었다고 볼 수 있습니다.</li><li>권한이 필요한 팀원에게 해당 파일과 Github 토큰을 발급 받는 방법(<a href="https://medium.com/rainist-engineering/k8s-auth-with-github-team-part2-a8affa559570">2편 참조</a>)을 공유해주시고, config 파일을 제 위치(~/.kube/config)에 옮겨주세요. 그리고 실제로 k8s 클러스터에 접속 후 기능 이용에 문제가 없는지 확인해주시면 됩니다.</li></ol><blockquote><strong>Webhook token auth + </strong><a href="https://github.com/appscode/guard"><strong>Guard</strong></a> 덕분에 자칫 복잡할 수 있는 Auth 문제를 생각보다 간편하게 해결 할 수 있었습니다.</blockquote><p>이렇게 함께 총 3편의 글을 통해 직접 Auth 문제를 해결해 보았는데 어떠셨나요? 제 예상으로는 앞으로 1년 내에 AWS 서울 리전에도 <a href="https://aws.amazon.com/ko/eks/">EKS</a>가 상륙할 것으로 보이고 그 때가 되면 AWS의 IAM을 통해서 훨씬 더 간편하게 Auth 문제를 해결할 수 있겠지만 지금 당장에도 이런식으로나마 보안과 계정 관리 문제의 두마리 토끼를 잡을 수 있었습니다.</p><p>그리고 저 개인적으로는 이번 작업을 진행한 덕분에 실제로 k8s의 Auth 작동방식에 대해서 더 자세히 이해할 수 있었고, 또 레이니스트의 기술 블로그에 처음으로 기고해보는 계기가 되었네요.</p><blockquote>그러면 비슷한 고민을 하셨을 분들께 흥미로운 사례가 되었길 바라며 글을 마칩니다. Happy DevOpsing! 👍 🕺</blockquote><figure><a href="https://rainist.com/recruit"><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*wZiZPK-aieV5XATGW26EuA.png" /></a></figure><ul><li><a href="https://medium.com/rainist-engineering/k8s-auth-with-github-team-part1-af745bcc0e03">권한을 찾아서: Github Team을 이용하여 Kubernetes 계정 인증하기 (1)</a></li><li><a href="https://medium.com/rainist-engineering/k8s-auth-with-github-team-part2-a8affa559570">권한을 찾아서: Github Team을 이용하여 Kubernetes 계정 인증하기 (2)</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7e976adcf4c6" width="1" height="1"><hr><p><a href="https://medium.com/rainist-engineering/k8s-auth-with-github-team-part3-7e976adcf4c6">권한을 찾아서: GitHub Team을 이용하여 Kubernetes 계정 인증하기 (3)</a> was originally published in <a href="https://medium.com/rainist-engineering">Rainist Engineering</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[권한을 찾아서: Github Team을 이용하여 Kubernetes 계정 인증하기 (2)]]></title>
            <link>https://medium.com/rainist-engineering/k8s-auth-with-github-team-part2-a8affa559570?source=rss-c5f54e6e07e1------2</link>
            <guid isPermaLink="false">https://medium.com/p/a8affa559570</guid>
            <category><![CDATA[auth]]></category>
            <category><![CDATA[backend-development]]></category>
            <category><![CDATA[devops]]></category>
            <category><![CDATA[kubernetes]]></category>
            <category><![CDATA[security]]></category>
            <dc:creator><![CDATA[유희철]]></dc:creator>
            <pubDate>Fri, 07 Sep 2018 06:40:36 GMT</pubDate>
            <atom:updated>2018-10-26T06:40:40.459Z</atom:updated>
            <content:encoded><![CDATA[<p><a href="https://medium.com/rainist-engineering/k8s-auth-with-github-team-part1-af745bcc0e03">이전 포스트</a>에 이어서 이번 포스트에서는 Guard를 적용하여 어떻게 인증<em>Auth</em> 문제를 해결하였는지에 대해 소개합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*oiUJ13znQRmx7OSE." /><figcaption>“A person holding a black iPhone in their hand” by <a href="https://unsplash.com/@ultralinx?utm_source=medium&amp;utm_medium=referral">Oliur Rahman</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral">Unsplash</a></figcaption></figure><blockquote>어떻게 하면 팀원들이 괴로워하지 않으면서 보안도 챙길 수 있을까요?</blockquote><p>고통이라는 건 중요하다고 생각합니다. 어떤 일을 반복할 때 고통이 느껴진다면 그 태스크가 제대로 수행되는데에 있어서 큰 장애물 또는 방해요소가 있다라고 정의할 수 있을 것 같네요.</p><p><a href="https://medium.com/rainist-engineering/k8s-auth-with-github-team-part1-af745bcc0e03?source=collection_home---4------1----------------">이전 포스트</a>에 적었던 것 처럼 <em>managed Kubernetes(이하 k8s) service</em> 를 사용하지 않고 직접 k8s 클러스터를 운영할 경우에는 Auth 관련 기능을 이용하기가 굉장히 까다롭기 때문에 인증처리를 제대로 하지 않게 될 확률도 높아지게 됩니다.</p><p>자 그렇다면 문제를 조금 쉽게 바꿔봅시다. 여러분들이 회사 또는 팀에서 Github 을 사용하고 개발자들이 각각 Github 계정을 가지고 있다고 한다면 <a href="https://help.github.com/articles/about-teams/">각 팀원들이 특정 팀에 속할 수 있겠죠</a>. 예를 들면 A 와 B 개발자는 <strong><em>ops</em></strong> 라는 팀에 들어갈 수 있구요. B 와 C 개발자는 <strong><em>back-end</em></strong> 라는 팀에 들어갈 수 있습니다. 그러면 Github 팀 별로 각각 k8s에 대한권한을 부여할 수는 없을까요?</p><blockquote>정리해보면 Github라는 플랫폼을 통해서 우리 팀원으로서 Sign-in 을 할 수 있고(<em>Authentication, 이하 </em><strong><em>Authn</em></strong><em>),</em> 각 팀에 맞는 접근 권한을 가질 수는(<em>Authorization, 이하 </em><strong><em>Authz</em></strong><em>)</em> 없을까요?</blockquote><p>네, 가능합니다! 여러 방법이 있는데 그 중에서 <a href="https://github.com/appscode/guard">Guard</a>를 이용한 방법을 공유해 보겠습니다. <em>그리고 이미 여러분이 kops를 사용해서 클러스터를 구성했다는 가정 하에 kops에 대한 자세한 설명은 생략 하도록 하겠습니다.</em></p><p>먼저 우리가 사용하려는 클러스터는 <a href="https://github.com/kubernetes/kops">kops</a> 를 이용해서 구성되어 있었는데 혹시나 Guard에서 <a href="https://appscode.com/products/guard/0.1.2/setup/install-kops/">kops를 위한 문서가 있었으나</a>, 해당 페이지만 읽어서는 이해가 어렵고 <a href="https://appscode.com/products/guard/0.1.2/setup/install/">기본적인 install 문서도 읽어야만 이해할 수 있습니다.</a></p><p>위에 언급한 문서를 읽어보면 kops가 설치된 머신에 Guard CLI 를 설치하도록 안내하고 있습니다. Linux 또는 macOS 등 사용하는 OS에 맞는 CLI 를 설치하신 후 <a href="http://crazia.tistory.com/entry/PKI-PKI-의-기본-개념-간단-설명">PKI</a> 관련 파일들을 생성하도록 안내하고 있습니다.</p><p>문서만 보고 그대로 따라하실 경우 조금 헷갈릴 수 있는데 모든 명령어를 그대로 입력해야 하는 것 아니고요. 제가 조금 더 정제된 과정을 하나씩 설명을 해드리겠습니다.</p><p>우선 $ guard init ca 를 실행해서 CA 인정서를 생성 한 후에 $ guard init server --ips=100.64.10.96 을 실행하여 서버용 인증서를 만듭니다. 여기서 주의해야 하는 부분은 <a href="https://appscode.com/products/guard/0.2.0/setup/install/">일반적인 install 페이지</a>에서 보여주는 IP와 <a href="https://appscode.com/products/guard/0.2.0/setup/install-kops/">kops 용 install 페이지</a>에서 보여주는 IP가 다릅니다. 우리는 kops 를 사용하고 있으니 kops 용 페이지를 보면서 해당 IP를 입력합시다.</p><p>IP가 다른 이유는 kops 에서 내부적으로 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/">Pods</a> 에 할당하는 가상 IP의 대역이 기본적으로 100.64.x.x 으로 설정되기 때문입니다. 이 부분은 $ kops edit cluster 명령어를 통해서 확인해보실 수 있습니다. 혹시라도 기존에 이미 동작 중인 <em>pod</em> 이나 <em>service</em> 에서 100.64.10.96 IP를 사용 중이라면 충돌이 날 수 있으니 주의 및 확인 할 수 있는 방법이 kops 용 인스톨 페이지에서 언급되고 있습니다.</p><blockquote>🎉 이제 서버용 인증서 설정이 완료되었습니다. 🎉</blockquote><p>이제는 클라이언트용 인증서를 생성해야 하는데 우리는 Github을 통해서 인증 할 것 이기 때문에 $ guard init client your-org -o github 이라고 입력 해줍니다. 여기서 your-org 를 인증할 때 사용하고자 하는 org 네임으로 변경해 주셔야겠죠 <em>예: Rainist</em></p><p>자 이렇게 모든 인증서<em>certificates</em> 가 ~/.guard/pki 폴더에 준비 되었습니다.</p><p>ls ~/.guard/pki 를 입력해서 6개 파일your-org@github.crt|key, ca.crt|key, server.crt|key 이 생성 되었을테고요.</p><p>아직 네 가지 작업이 남았습니다.</p><ol><li>만들어둔 인증서를 이용하여 서버를 띄우는 것</li><li>k8s 가 webhook 인증방식을 사용할 수 있도록 kops 의 설정 변경</li><li>kubectl config~/.kube/config 변경하여 유저 인증<em>Authn</em> 하기</li><li>ClusterRole 또는 Role 을 사용하여 권한 관리<em>Authz</em> 하기</li></ol><p>먼저 서버를 띄우기 위해 아래의 절차를 거치고요.</p><pre>$ guard get installer --auth-providers=github &gt; installer.yaml <br># installer.yaml 의 spec/clusterIP 의 값을 100.64.10.96 으로 변경 후<br>$ kubectl apply -f installer.yaml</pre><p><a href="https://appscode.com/products/guard/0.2.0/setup/install-kops/#during-configure-kubernetes-api-server">kops 의 설정을 변경하기 위해 </a><a href="https://appscode.com/products/guard/0.2.0/setup/install-kops/#during-configure-kubernetes-api-server">kops edit cluster 명령어를 입력하여 아래 내용을 추가 합니다.</a></p><pre>spec:<br>  kubeAPIServer:<br>    authenticationTokenWebhookConfigFile: /srv/kubernetes/webhook-guard-config<br>  fileAssets:<br>  - content: |<br>       (guard get webhook-config your-org -o github --addr=100.64.10.96:443 의 결과)<br>    name: guard-github-auth<br>    path: /srv/kubernetes/webhook-guard-config<br>    roles:<br>    - Master</pre><p>이제 이 설정된 부분이 적용되기 위해서는 k8s의 master nodes를 재시작해야 합니다.</p><p>kops 명령어를 이용해서 update 및 master node group에 대한 rolling-update를 진행하시면 클러스터에서 이제 Github 팀을 이용한 인증을 진행할 준비를 마쳤습니다.</p><blockquote>이 부분 (kops rolling-update) 에 익숙하지 않은 상태에서 프로덕션용 클러스터를 대상으로 진행할 경우 만약 롤링 업데이트 과정에서 문제가 발생해 낭패를 보실 수 있으니 꼭 사용법을 충분히 숙지하신 후, 연습용 클러스터에서 미리 수행해 보시고 작업하시는 것을 권장합니다.</blockquote><p>이제 kubectl 의 config 파일을 수정하여 Github Team 을 이용하여 Authn을 할 차례입니다.</p><p>kops 로 클러스터를 처음 만들었을 때 ~/.kube/config 를 제공 받으셨을 테고 이 파일에는 모든 권한을 가진 admin 용 credentials 가 포함 되어 있습니다. 해당 파일은 필요할테니 반드시 잘 보관해 두시고 이 파일을 기반으로 아래와 같이 수정하시면 Github Team 에 설정된 팀원으로 인증을 할 수 있습니다.</p><pre>apiVersion: v1<br>clusters:<br>- cluster:<br>    certificate-authority-data: ...<br>    server: <a href="https://your.cluster.server">https://my.cluster.server</a><br>  name: my.cluster.k8s.local<br>contexts:<br>- context:<br>    cluster: my.cluster.k8s.local<br>    user: my-github-token<br>  name: my.cluster.k8s.local<br>current-context: my.cluster.k8s.local<br>kind: Config<br>preferences: {}<br>users:<br>- name: my-github-token<br>  user:<br>    token: {github-token}</pre><ul><li><strong>users</strong> &gt; <strong>user</strong>의 <strong>name</strong>은 임의로 적어셔도 상관은 없으나 <strong>contexts </strong>&gt;<strong> context</strong> 의 <strong>user</strong> 와 동일해야 합니다.</li><li><strong>token</strong>은 <a href="https://github.com/settings/tokens/new">https://github.com/settings/tokens/new</a> 에 접속한 후 admin:org &gt;read:org 만 체크하신 후 <em>Token description</em>에 이 토큰이 무슨 용도인지 알 수 있도록 적당히 적어주신 후에 <strong>Generate Token</strong> 을 눌러서 발급을 받은 토큰을 {github-token} 항목에 적어주시면 되고 나중에는 Github을 통해 해당 토큰을 다시 볼 수 있는 방법이 없으니 잘 보관을 해두시거나 잃어버렸을 경우는 당황할 필요 없이 기존 토큰을 삭제하고 새 토큰을 발급받아서 사용하시면 됩니다. <em>(그리고 새 토큰을 위의 config 파일에도 업데이트 해주셔야겠죠)</em></li></ul><blockquote>이제 kubectl cluster-info 를 입력했을 때 에러 메세지가 없으면 Github Organization을 이용해서 Authn를 구현하였습니다.</blockquote><p>이제 마지막으로 인증된 유저의 권한을 관리해줘야 하는데요. (Authn은 되었지만 기본적으로는 권한이 거의 없다시피 하기 때문에 지금 당장으로써는 사용할 수 있는 기능이 거의 없습니다.)</p><blockquote>이제 Authz를 다뤄 볼 시간이죠!</blockquote><p>이 내용은 k8s의 <strong>RBAC</strong>도 언급해야 하는 등 내용이 생각보다 길어질 것 같아서 다음 글에서 이어 진행하도록 하겠습니다!</p><figure><a href="https://rainist.com/recruit"><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*7UG25N69Njz5SSkQfbb6NQ.png" /></a></figure><ul><li><a href="https://medium.com/rainist-engineering/k8s-auth-with-github-team-part3-7e976adcf4c6">권한을 찾아서: GitHub Team을 이용하여 Kubernetes 계정 인증하기 (3)</a></li><li><a href="https://medium.com/rainist-engineering/k8s-auth-with-github-team-part1-af745bcc0e03">권한을 찾아서: Github Team을 이용하여 Kubernetes 계정 인증하기 (1)</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a8affa559570" width="1" height="1"><hr><p><a href="https://medium.com/rainist-engineering/k8s-auth-with-github-team-part2-a8affa559570">권한을 찾아서: Github Team을 이용하여 Kubernetes 계정 인증하기 (2)</a> was originally published in <a href="https://medium.com/rainist-engineering">Rainist Engineering</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[I guess you meant percent]]></title>
            <link>https://medium.com/@ryuheechul/i-guess-you-meant-percent-e6fa3cef7488?source=rss-c5f54e6e07e1------2</link>
            <guid isPermaLink="false">https://medium.com/p/e6fa3cef7488</guid>
            <dc:creator><![CDATA[유희철]]></dc:creator>
            <pubDate>Mon, 20 Aug 2018 06:46:59 GMT</pubDate>
            <atom:updated>2018-08-20T06:46:59.831Z</atom:updated>
            <content:encoded><![CDATA[<p>I guess you meant percent</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e6fa3cef7488" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[maybe one not is enough?]]></title>
            <link>https://medium.com/@ryuheechul/maybe-one-not-is-enough-6ea677d92e42?source=rss-c5f54e6e07e1------2</link>
            <guid isPermaLink="false">https://medium.com/p/6ea677d92e42</guid>
            <dc:creator><![CDATA[유희철]]></dc:creator>
            <pubDate>Mon, 25 Jun 2018 04:06:54 GMT</pubDate>
            <atom:updated>2018-06-25T04:06:54.004Z</atom:updated>
            <content:encoded><![CDATA[<p>maybe one not is enough?</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6ea677d92e42" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[권한을 찾아서: Github Team을 이용하여 Kubernetes 계정 인증하기 (1)]]></title>
            <link>https://medium.com/rainist-engineering/k8s-auth-with-github-team-part1-af745bcc0e03?source=rss-c5f54e6e07e1------2</link>
            <guid isPermaLink="false">https://medium.com/p/af745bcc0e03</guid>
            <category><![CDATA[devops]]></category>
            <category><![CDATA[kubernetes]]></category>
            <category><![CDATA[kubernetes-auth]]></category>
            <category><![CDATA[backend-development]]></category>
            <category><![CDATA[github-team]]></category>
            <dc:creator><![CDATA[유희철]]></dc:creator>
            <pubDate>Fri, 01 Jun 2018 06:21:03 GMT</pubDate>
            <atom:updated>2018-10-26T06:39:30.810Z</atom:updated>
            <content:encoded><![CDATA[<h3>권한을 찾아서: GitHub Team을 이용하여 Kubernetes 계정 인증하기 (1)</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*a8GzNnlz4mxYG9ir." /><figcaption>“Numerous padlocks on a bridge railing” by <a href="https://unsplash.com/@ben182?utm_source=medium&amp;utm_medium=referral">Benjamin Bortels</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral">Unsplash</a></figcaption></figure><p>안녕하세요, Rainist의 DevOps 엔지니어 유희철입니다.</p><p>요즘 컨테이너 기술의 사용이 확대되면서 Kubernetes(이하 k8s), Docker Swarm, Mesos 와 같은 컨테이너 오케스트레이션<em>orchestration</em> 툴의 사용도 필수적으로 자리 잡고 있는 것으로 보입니다.</p><p>2015년 즈음에 서버 앱 배포 및 운영에 대해 본격적으로 관심을 가지기 시작하면서, 처음으로 Docker와 k8s를 접하게 되었습니다.</p><p>Docker의 매력에 먼저 빠져들어 이런저런 서버 앱을 모두 도커화 (<em>Dockerize</em>) 하였는데 <strong>막상 실제 프로덕션에서 운영하기에는 고민되는 지점이 한둘이 아니었습니다</strong>. 오히려 도커화되지 않은 네이티브 앱을 다루는 것 보다 훨씬 더 골치가 아팠습니다. 특히나 Rainist같은 스타트업에서는 제품이 언제 빠르게 성장할지 모르기 때문에, 늘 서버의 클러스터링, 동적 스케일 아웃<em>scale-out</em>, 클러스터 내의 서비스 디스커버리 등이 요구되는데 그러한 것들을 모두 처리하기에는 어려움이 너무 컸습니다.</p><p><strong>이 모든 복잡한 과정을 수동으로 직접 관리한다는 건 조금만 장기적인 관점으로 봐도 그 한계가 분명히 보였기에</strong>, 이런 과정을 자동으로 관리할 수 있는 도구를 찾아야겠다는 생각을 했습니다. 그 당시 사실상 Ops 분야의 뉴비였던 저에게 적합한 툴을 찾는 리서치가 버거웠지만 적합한 후보가 나올 때마다 실제로 적용해보면서 옥석을 가려갈 수 있었습니다. 그러한 과정에서 Deis, Flynn, Dokku와 같은 툴을 살펴보거나 세팅을 시도했고, 대부분 원하는 바를 달성하기에는 적합하지 않아 절망했던 기억이 있습니다. 절망의 가운데 k8s를 발견하고 당시 알파 또는 베타였던 GKE(지금의 Kubernetes Engine)를 이용해본 뒤, k8s의 철학에 크게 공감하여 언젠가 꼭 유용하게 사용하리라 다짐했습니다. (그때는 제가 전문적인 백엔드 또는 Ops 엔지니어가 아니었기에 실제로 k8s를 활용하기에는 기회가 한정적이었습니다.)</p><p>그런 아쉬움을 가지고 있던 와중에, 2017년에 Rainist에 DevOps 엔지니어로 합류하게 되었습니다. 회사에서도 DevOps 전담 엔지니어는 처음이었고 DevOps의 대한 니즈가 마침 필요하였기에 전폭적인 지원을 받으며 드디어 k8s 를 십분 활용하기 시작했고, 서서히 뱅크샐러드의 마이크로서비스들이 하나둘씩 k8s 위에서 운영되기 시작했습니다. 다행히 그동안 k8s도 기능과 이용자 규모의 측면에서도 폭발적으로 성장하여 점점 더 프로덕션에서 활용하기에 충분한 도구로 발전하고 있었습니다.</p><blockquote><em>제가 Rainist 엔지니어링 블로그에 처음으로 글을 작성하다 보니 서두가 약간(?) 길었네요. 이제 이 글의 진짜 목적에 대해서 집중해보도록 하겠습니다.</em></blockquote><blockquote>k8s는 한 번 세팅만 잘 되어 있다면 사용하는 입장에서는 아주 편한 툴이지만 사실 클러스터를 처음에 구성할 때는 부분에서는 마냥 쉽다고 말하기 힘듭니다.</blockquote><p>가장 쉽고 편하게 클러스터를 구성하고 운영하는 방법은 GCP의 Kubernetes Engine을 사용하는 것이지만 여러 가지 이유로 AWS를 사용해야 할 경우가 있습니다.</p><p>Rainist도 현재는 AWS에서 k8s 클러스터를 구성하는 게 유리하다는 판단으로 EC2를 활용하여 클러스터를 운영하고 있습니다. k8s 클러스터를 처음부터 일일이 구성하는 것이 불가능하지 않지만, 기술적인 어려움, 많은 시간 소요, 올바르게 설정되지 않을 수 있는 리스크등이 있기 때문에 세팅을 도와주는 도구가 많이 존재합니다. 저는 개인적으로 <a href="https://coreos.com/tectonic/">CoreOS에서 만든 Tectonic</a>을 사용 해본 적이 있었고, 당시에 Rainist에서는 <a href="https://github.com/kubernetes/kops">kops</a>를 사용하고 있습니다. kops를 사용하면 비교적 쉽게 클러스터를 구성하고 바로 사용할 수 있지만 모든 것이 다 원하는 대로 준비가 되어있는 것은 아닙니다.</p><p>kops 의 기본적인 구성을 사용하면서 아쉬운 부분을 몇 가지 나열해보면</p><ul><li>Networking — 기본 kubenet의 경우 노드를 50개 까지만 지원</li><li>Ingress — AWS Console에 접속하여 Security Group의 설정을 따로 변경해줘야 함</li><li>Authn/Authz (이하 Auth) — 관리자, 개발자별 아이디 발급 및 권한 설정하는 부분이 굉장히 까다롭거나 손이 많이감</li></ul><p>등이 있는데요, 그중에서 <strong>Auth는 모든 팀에게 상당히 중요합니다.</strong> 왜냐하면, k8s 활용을 극대화하기 위해서는 다양한 개발자들이 목적에 필요한 권한을 필요로 하는 즉시 바로 얻을 수 있어야 하기 때문입니다. 권한이 없어서 서버 앱을 배포하지 못하는 것만큼 시간 낭비가 없겠죠? <em>또 나중에 시간이 지나서 팀원이 퇴사한 경우에는 서버의 보안을 위해서 그 즉시 해당 팀원이 가지고 있는 권한을 삭제할 수 있어야 합니다.</em></p><p>이런 기능은 팀에서 GitHub 을 사용해 보셨다면 아주 간단하게 Member를 추가하고 권한을 부여하고 또 손쉽게 삭제하는 경험을 해보셨을 겁니다.</p><p>하지만 k8s 클러스터에는 이런 기능을 손쉽게 사용할 수 있는 UI는 커녕 CLI 명령어조차 없다시피 합니다. 결국, 시스템 설정을 건드리는 등의 작업을 해야 하는데 문서를 보고 바로 적용할 수 있는 수준과는 거리가 있고 막상 작업하더라도 손이 많이 가죠. <strong>Kubernetes Engine</strong>이나 <strong>Tectonic</strong> 또는 앞으로 출시될 <strong>AWS EKS</strong> 를 사용한다면 이런 기능은 지원이 되겠지만 저희는 현재 저희가 직접 설치한 클러스터를 사용하고 있으니까요.</p><p>결국, 이런 어려움으로 인해, 일반적으로 권장되지 않는 practice인 /.kube/config 파일 등을 공유하여 사용하게 되는 일들이 종종 있을 수 있겠죠. 그렇게 되면 누가 어떤 액션을 취했는지 (프로덕션 서버에서는 아주 중요한 정보이죠) Auditing이 불가능해질 뿐더러 퇴사자가 생길 때마다 인증 정보를 변경해야 하며 모든 사람이 같은 권한 (cluster-admin) 을 가지고 있는 불편하고 또 불안한 상황을 마주할 수 밖에 없게 되겠죠?</p><p>이러한 상황을 k8s 공식/비공식 개발팀에서도 인지하고 있으며, 관련하여 <a href="https://kubernetes.io/docs/admin/authentication/">여러 가지 방안</a>을 내놓고 있습니다. 그중의 하나가 k8s 의 인증방식 중 하나인 OIDC 를 이용한 <a href="https://github.com/coreos/dex">dex</a> 를 이용하는 방식입니다. (참고 — <a href="https://dailyhotel.io/kubernetes-with-dex-integration-f456e22dd8e4">데일리 호텔의 사례</a>)</p><p>하지만 OIDC 를 쉽게 사용할 수 있도록 도와주는 dex 조차도 설치해서 운영하는데 만만치 않은 기술적인 도전과 복잡도가 있었기 때문에 썩 내키지는 않았습니다.</p><p>그러다 얼마 전에 Webhook Token Authentication 방식을 이용하는 <a href="https://github.com/appscode/guard">AppsCode의 Guard라는 오픈소스 툴</a>을 발견하고서 희망을 품어보았습니다.</p><p>그래서 바로 시도해본 결과, 결론부터 말씀드리면 아주 만족스럽게 k8s cluster 의 Auth 이슈를 해결할 수 있었습니다!</p><p>실제로 어떤 과정을 거쳐서 적용했는지는 이어지는 다음 포스트에서 확인해보세요!</p><figure><a href="https://rainist.com/recruit/engineer"><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*wZiZPK-aieV5XATGW26EuA.png" /></a></figure><ul><li><a href="https://medium.com/rainist-engineering/k8s-auth-with-github-team-part2-a8affa559570">권한을 찾아서: Github Team을 이용하여 Kubernetes 계정 인증하기 (2)</a></li><li><a href="https://medium.com/rainist-engineering/k8s-auth-with-github-team-part3-7e976adcf4c6">권한을 찾아서: GitHub Team을 이용하여 Kubernetes 계정 인증하기 (3)</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=af745bcc0e03" width="1" height="1"><hr><p><a href="https://medium.com/rainist-engineering/k8s-auth-with-github-team-part1-af745bcc0e03">권한을 찾아서: Github Team을 이용하여 Kubernetes 계정 인증하기 (1)</a> was originally published in <a href="https://medium.com/rainist-engineering">Rainist Engineering</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[I think the url should be https://docs.openebs.io]]></title>
            <link>https://medium.com/@ryuheechul/i-think-the-url-should-be-https-docs-openebs-io-c1736db667d7?source=rss-c5f54e6e07e1------2</link>
            <guid isPermaLink="false">https://medium.com/p/c1736db667d7</guid>
            <dc:creator><![CDATA[유희철]]></dc:creator>
            <pubDate>Wed, 14 Mar 2018 06:58:41 GMT</pubDate>
            <atom:updated>2018-03-14T06:58:41.795Z</atom:updated>
            <content:encoded><![CDATA[<p>I think the url should be <a href="https://docs.openebs.io">https://docs.openebs.io</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c1736db667d7" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Nicely done.]]></title>
            <link>https://medium.com/@ryuheechul/nicely-done-fb80bd736832?source=rss-c5f54e6e07e1------2</link>
            <guid isPermaLink="false">https://medium.com/p/fb80bd736832</guid>
            <dc:creator><![CDATA[유희철]]></dc:creator>
            <pubDate>Sat, 20 Jan 2018 08:12:16 GMT</pubDate>
            <atom:updated>2018-01-20T08:12:16.430Z</atom:updated>
            <content:encoded><![CDATA[<p>Nicely done. You could also use just https://ngrok.com/ and skip the code changes and certification settings if you just want https enabled URL that you can access to for instant testings.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=fb80bd736832" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>