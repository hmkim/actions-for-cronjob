<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
<title>ChanceTheCoder</title>
<link>https://chancethecoder.tistory.com/</link>
<description></description>
<language>ko</language>
<pubDate>Tue, 14 May 2019 11:52:18 +0900</pubDate>
<generator>TISTORY</generator>
<managingEditor>chancethecoder</managingEditor>
<item>
<title>지식에도 유통기한이 있다</title>
<link>https://chancethecoder.tistory.com/21</link>
<description>&lt;div class=&quot;markdown-body&quot;&gt;
&lt;p&gt;최근에 들은 내용 중에 기억에 남는 생각이 있어서 글로 적어봅니다.&lt;/p&gt;
&lt;h3&gt;지식의 유통기한&lt;/h3&gt;
&lt;p&gt;한 번 축적된 지식은 영원히 유효할까? 이에 대한 저의 생각은 &amp;quot;아니다&amp;quot; 입니다.&lt;/p&gt;
&lt;p&gt;엔지니어나 개발자들이 공부해야 할 기술적인 발전은 날이 갈수록 빨라지고 복잡해집니다. 어제 공부한 내용이 내일은 구식이 되고, 며칠이 지나면 역사 속으로 사라진 기술이 되기도 합니다. 스칼라의 Dataframe API를 어떻게 쓸지 고민하고 있는데, 옆에 시니어 개발자가 와서 본인의 20년 전 프로그래밍 시절 이야기를 하면서 프로시저로 모든 것을 작성하던 이야기를 한다면 전혀 도움이 되지 않을 것입니다.&lt;/p&gt;
&lt;p&gt;요즘 힙하다는 웹 기술로 예를 들어볼까요? Webpack을 &amp;quot;요즘&amp;quot; 개발자라고 하면 한 번은 써봤을텐데, Webpack의 업데이트 속도 또한 말도 안되게 빨라서 새로운 메이저 버전의 업데이트가 발표될 때 마다 많은 개발자들이 또 나왔어? 라고 말하곤 합니다. 심지어 아직 Webpack이 뭔지도 모르는 시니어 개발자가 많은데도 말입니다.&lt;/p&gt;
&lt;p&gt;많은 사람들이 이런 점은 공감하실 것입니다.&lt;/p&gt;
&lt;p&gt;기술 트렌드에서 예민하고 빠르게 변화하는 것들은 지금 축적된 지식의 가치가 급격하게 떨어질 수도 있습니다. 이 쪽 분야에 종사하는 분들이 힘들어하는 이유도 바로 트렌드를 읽고 꾸준히 공부해야 기술에 뒤쳐지지 않는다는 점을 알고 있기 때문입니다.&lt;/p&gt;
&lt;h3&gt;지식의 르네상스 시대&lt;/h3&gt;
&lt;p&gt;최근에  위 주제로 이야기하다 우스갯소리로 나온 이야기가 바로 &amp;quot;지식의 르네상스&amp;quot;입니다.&lt;/p&gt;
&lt;p&gt;무슨 말이냐? 주니어든 시니어든 똑같이 처음 보는 기술을 공부하고 적용하는 상황이 온 것입니다. 새로운 기술이 탄생하고 그 것이 나의 일터까지 오는데 몇 년, 혹은 몇 개월이 채 안걸리는 이 시점에, 주니어와 시니어의 구분이 의미 없을 정도로 기술의 발전 속도가 빨라진 것입니다.&lt;/p&gt;
&lt;p&gt;물론 기본 베이스가 차이나기 때문에 시니어의 역량이 절대적으로 우위에 있겠지만, &amp;quot;경험치&amp;quot;가 없다는 점은 동일합니다. 단지 습득이나 적용의 속도 차이가 있을 뿐입니다.&lt;/p&gt;
&lt;h3&gt;그렇다면 우리는 어떻게 해야 우리의 가치를 유지할 수 있을까?&lt;/h3&gt;
&lt;p&gt;이제 어려운 질문을 스스로 해봅니다. 어떻게 하면 이렇게 짧은 지식의 유통기한을 극복할 수 있을까? 어떻게 하면 우리의 가치를 보존할 수 있을까?&lt;/p&gt;
&lt;p&gt;정답은 없으나 한 가지 분명한 것은 &lt;strong&gt;유통기한은 점점 짧아지는 추세&lt;/strong&gt; 라는 사실입니다.&lt;/p&gt;
&lt;p&gt;아무리 노력해도 모든 기술을 알 수는 없는 것이고 미래의 트렌드를 예측해서 공부하는 것도 불가능하기에, 결국 답은 새로운 지식을 빠르게 터득하는 훈련을 하는 수 밖에는 없다는 결론을 내게 되었습니다.&lt;/p&gt;
&lt;p&gt;당연한 이야기같지만, 저 개인적으로는 한동안의 개발 인생을 관통하는 불변의 사실 한 가지가 정립된 것 같습니다.&lt;/p&gt;
&lt;/div&gt;</description>
<category>잡담</category>
<author>chancethecoder</author>
<guid>https://chancethecoder.tistory.com/21</guid>
<comments>https://chancethecoder.tistory.com/21#entry21comment</comments>
<pubDate>Sun, 12 May 2019 14:52:55 +0900</pubDate>
</item>
<item>
<title>2019 구글 머신러닝 스터디잼 후기</title>
<link>https://chancethecoder.tistory.com/20</link>
<description>&lt;div class=&quot;markdown-body&quot;&gt;
&lt;p&gt;얼마 전 친구와 스터디 얘기를 하다가 구글에서 머신러닝 스터디 프로그램을 연다는 사실을 알게 됐습니다.&lt;/p&gt;
&lt;p&gt;이름은 &lt;strong&gt;구글 머신러닝 스터디잼&lt;/strong&gt;. 참가비도 없고 기간은 2주에 수료를 마치면 티셔츠까지 주니, 안 하면 손해인 듯 해서 친구와 바로 등록하기로 했습니다.&lt;/p&gt;
&lt;p&gt;구인하고 등록까지 1~2주가 지나고 스터디가 시작 됐습니다. 강의는 퀵랩이라는 플랫폼을 통해 이용하는데, 총 4개의 코스를 이수하면 수료가 완료됩니다. 등록 시 1달 간 무료 크레딧을 주는데, 이걸 활성화 하고 듣고싶은 강의를 듣는 식이었습니다. (4개의 필수 강의 말고도 무제한으로 전부 들을 수 있습니다)&lt;/p&gt;
&lt;h3 id=&quot;%EA%B7%B8%EB%9E%98%EC%84%9C-%ED%95%B4%EB%B4%A4%EB%8D%94%EB%8B%88-%EC%83%81%ED%83%9C%EA%B0%80&quot;&gt;그래서 해봤더니... 상태가?&lt;/h3&gt;
&lt;p&gt;살짝 긴장하고 첫 코스를 열었습니다. 근데 왠걸... 데모용 구글 콘솔을 발급받고 API 몇 개 써보니 끝나는 아주 짧은 내용이었습니다. 아주 천천히 내용을 음미(?) 해봐도 15분이 채 안걸렸습니다.&lt;/p&gt;
&lt;p&gt;이름만 보고 많은 사람들이 머신러닝이나 딥러닝에 대한 지식 전달을 원하고 참여 했을텐데, 막상 내용은 구글의 플랫폼을 활용해보는 튜토리얼 정도의 강의였습니다.&lt;/p&gt;
&lt;p&gt;문제는, 그마저도 수료를 하려면 코스를 마쳐야하는데, vi나 curl 등 명령어를 써야하는 내용이라 비개발자에게 어려울만한 내용일 뿐더러 영양가가 없어 보였습니다. (어찌 따라는 해도 비개발자가 이런 것을 쓸 일이 있을까요?)&lt;/p&gt;
&lt;p&gt;나머지 3개의 코스를 30분에 끝내버리고 결국 저는 현타가 왔습니다... ㅠㅠ&lt;/p&gt;
&lt;p&gt;나중에 알게 됐지만, 구글 스터디잼이라는 것이 시리즈로 열려 매 번 주제가 바뀌는듯합니다. 아마도 구글 클라우드 플랫폼을 활용해주세요~ 하는 취지가 있지 않나 싶습니다. (쿠버네티스같은 주제로 스터디잼이 진행된다면 개발자분들 참여해볼만할 것 같습니다)&lt;/p&gt;
&lt;h3 id=&quot;%EA%B3%A0%EC%83%9D%ED%95%98%EC%8B%9C%EB%8A%94-%EB%B6%84%EB%93%A4%EB%8F%84-%EA%B3%84%EC%8B%AD%EB%8B%88%EB%8B%A4&quot;&gt;고생하시는 분들도 계십니다&lt;/h3&gt;
&lt;p&gt;그럼에도 불구하고 이런 교육을 무료로 제공하기위해 안보이는 곳에서 고생하시는 분들이 있으리라 생각합니다.&lt;/p&gt;
&lt;p&gt;특히 슬랙 채널에 빗발치는 문의에 일일이 대응하시는 운영진 분들을 보면서 감사하고 수고하신다는 말씀을 하진 않았지만 속으로 했습니다. (...)&lt;/p&gt;
&lt;p&gt;그리고 개인적으로는 티셔츠를 얻을 수 있었다는 성과(?)로 만족스러운 경험이었습니다.&lt;/p&gt;
&lt;/div&gt;</description>
<category>회고</category>
<author>chancethecoder</author>
<guid>https://chancethecoder.tistory.com/20</guid>
<comments>https://chancethecoder.tistory.com/20#entry20comment</comments>
<pubDate>Fri, 01 Mar 2019 15:18:43 +0900</pubDate>
</item>
<item>
<title>MS Azure로 갈아타기 - 5. Circle CI로 CI/CD 구성하기</title>
<link>https://chancethecoder.tistory.com/19</link>
<description>&lt;div class=&quot;markdown-body&quot;&gt;
&lt;p&gt;이번 포스트에서는 CI/CD 구성에 대해서 다루겠습니다. 저는 &lt;a href=&quot;https://circleci.com/&quot;&gt;Circle CI&lt;/a&gt;를 이용해 구성해보겠습니다. 진행은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CircleCI 빌드하기&lt;/li&gt;
&lt;li&gt;API로 Artifact 가져오기&lt;/li&gt;
&lt;li&gt;CircleCI에 가상머신 SSH 키 등록하기&lt;/li&gt;
&lt;li&gt;Azure 배포하기&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;시작에 앞서&lt;/h4&gt;
&lt;p&gt;CircleCI를 이용한 것은 저의 기존 프로젝트를 활용하기 위해서인데, 꼭 이와 동일하게 구성할 필요는 없습니다. 만약 선호하는 솔루션이 있거나 기존 사용하던 것이 있다면 다른 것을 사용하는 것도 무방합니다.&lt;/p&gt;
&lt;p&gt;CI 구성이 처음인 분들을 위해 다른 옵션을 소개드리면 Travis CI, Jenkins 등이 있습니다. 장단점이 있는데, 복잡한 것이 싫고 간단하게 해결하고싶은 분들은 Travis CI 또는 CircleCI를 사용하시고 본인이 CI용 서버를 별도 구축하여 세부적인 컨트롤 및 최적화를 하고싶은 분들은 Jenkins를 사용해보시길 추천드립니다.&lt;/p&gt;
&lt;h3&gt;CircleCI 빌드하기&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;CircleCI 대시보드에 접속합니다. 처음이라면 회원가입을 해줍시다.&lt;/li&gt;
&lt;li&gt;우상단 클릭 &amp;gt; User Settings &amp;gt; Account Integration에서 Github 계정과 연동하여 access permission이 있는지 확인합니다. 없다면 연결해줍니다.&lt;/li&gt;
&lt;li&gt;좌측 ADD PROJECTS를 클릭합니다. 본인의 Github 프로젝트 리스트를 볼 수 있습니다. 이 중에 배포하기 위한 프로젝트를 찾아 Set Up Project를 누릅니다.&lt;/li&gt;
&lt;li&gt;환경은 Linux, Node를 선택합니다.&lt;/li&gt;
&lt;li&gt;CircleCI에서는 설정을 읽어오기 위해 프로젝트 내의 .circleci/config.yml 파일을 참조합니다. 아래 내용을 복사하여 프로젝트의 .circleci/config.yml 파일에 붙여넣습니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; cd /path/to/project
 mkdir -p .circleci
 vi .circleci/config.yml&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-yml&quot;&gt; version: 2
 jobs:
 build:
   docker:
     - image: circleci/node:7.10
   working_directory: ~/repo
   steps:
     - checkout
     - restore_cache:
         keys:
         - v1-dependencies-{{ checksum &amp;quot;package.json&amp;quot; }}
         - v1-dependencies-
     - run: yarn install
     - save_cache:
         paths:
           - node_modules
         key: v1-dependencies-{{ checksum &amp;quot;package.json&amp;quot; }}
     - run: yarn test
     - run: yarn build
     - run:
         command: |
           tar cvf application.tar.gz -C build .
     - run:
         command: |
           mkdir -p /tmp/artifacts
           mv application.tar.gz /tmp/artifacts
     - store_artifacts:
         path: /tmp/artifacts
 deploy:
   machine:
     enabled: true
   steps:
     - run:
         command: |
           echo &amp;quot;Deploy Over SSH&amp;quot;
 workflows:
   version: 2
   build-and-deploy:
     jobs:
       - build
       - deploy:
         requires:
           - build
         filters:
           branches:
             only: master&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;변경사항을 커밋하고 github에 푸시합니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; git commit -a -m &amp;quot;Add CircleCI configuration file&amp;quot;
 git push&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;Start building을 누릅니다. config.yml에 정의한 과정대로 첫 번째 build가 수행되는 것을 볼 수 있습니다.&lt;/li&gt;
&lt;li&gt;jobs 탭을 확인합니다. success로 초록색 표시가 있다면 성공입니다. 이제 Artifacts 탭을 보면 application.tar.gz 파일이 생성된 것을 볼 수 있습니다. 다음으로 이 파일을 가상머신으로 가지고 와서 서버 기동까지 이어지는 작업을 해보겠습니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;API로 Artifact 가져오기&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;위에서 생성된 Artifacts를 CircleCI API를 통해 가져오기 위해서는 &lt;a href=&quot;https://circleci.com/docs/2.0/managing-api-tokens/#creating-a-personal-api-token&quot;&gt;Personal Token&lt;/a&gt;이 필요합니다. 우상단 아이콘 &amp;gt; User settings로 이동합니다.&lt;/li&gt;
&lt;li&gt;Personal API Tokens를 클릭합니다.&lt;/li&gt;
&lt;li&gt;Create New Token 버튼을 클릭합니다.&lt;/li&gt;
&lt;li&gt;Token name에 적당한 이름을 입력하고 Add API Token을 클릭합니다.&lt;/li&gt;
&lt;li&gt;생성된 토큰값을 복사하여 적당한 곳에 메모 해둡시다. &lt;strong&gt;한 번 보여준 뒤로 다시 볼 수 없기 때문에, 분실할 경우 복구가 불가능&lt;/strong&gt;합니다. 만약 분실한 경우 삭제 및 재생성을 하시기 바랍니다.&lt;/li&gt;
&lt;li&gt;가상머신에 접속합니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; ssh chancethecoder@52.141.36.128&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;생성된 토큰 값을 환경변수로 저장합니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; echo &amp;#39;export CIRCLE_TOKEN=&amp;quot;your_token&amp;quot;&amp;#39; &amp;gt;&amp;gt; ~/.bashrc
 source ~/.bashrc&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;curl로 API호출을 해봅시다. 예제에서 각각 vcs_type에 github, bitbucket 등 사용하는 VCS를, username에 CircleCI의 좌상단 유저 닉네임을, project에 VCS의 타겟 프로젝트 이름을, build_num에 호출하고자 하는 빌드 번호를 넣어주면 됩니다. 성공적으로 호출된다면 아래와 같은 값이 출력됩니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; # example
 curl https://circleci.com/api/v1.1/project/:vcs_type/:username/:project/:build_num/artifacts?circle-token=$CIRCLE_TOKEN&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt; [ {
 &amp;quot;path&amp;quot; : &amp;quot;tmp/artifacts/application.tar.gz&amp;quot;,
 &amp;quot;pretty_path&amp;quot; : &amp;quot;tmp/artifacts/application.tar.gz&amp;quot;,
 &amp;quot;node_index&amp;quot; : 0,
 &amp;quot;url&amp;quot; : &amp;quot;https://52-131691113-gh.circle-artifacts.com/0/tmp/artifacts/application.tar.gz&amp;quot;
 } ]&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;이제 artifact를 가져와봅시다. curl 명령어 결과와 wget을 조합해 아래와 같이 입력합니다. application.tar.gz 파일이 생성된다면 정상 호출 된 것입니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; curl https://circleci.com/api/v1.1/project/github/chancethecoder/playground/52/artifacts?circle-token=$CIRCLE_TOKEN | grep -o &amp;#39;https://[^&amp;quot;]*&amp;#39; | xargs -P4 -I % wget %?circle-token=$CIRCLE_TOKEN&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; ls -al | circle-token&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt; application.tar.gz?circle-token=...&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;이제 빌드 결과 파일을 구동시켜봅시다. 이 부분은 각자의 리액트 프로젝트 구성에 따라 다르겠습니다만, 저는 빌드를 통해 생성된 static 파일만을 서빙하도록 구성했기 때문에 pm2의 serve 명령어를 사용하겠습니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mkdir -p myapp
tar xvf application.tar.gz?circle-token=... -C myapp
pm2 delete all
# myapp은 static 파일 디렉토리 경로, 3000은 포트번호 지정입니다.
pm2 serve myapp 3000&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;이제 브라우저에서 본인의 도메인 혹은 공용아이피로 접속해봅시다. 본인이 작성한 리액트 앱이 보인다면 잘 따라오신 것입니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;CircleCI에 가상머신 SSH 키 등록하기&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;빌드 타임에 CircleCI에서 가상머신에 배포 및 구동까지 하도록 하기 위해서는 SSH 통신이 가능해야 합니다. 따라서 SSH 설정을 먼저 해줍시다. 먼저 가상머신에 접속합니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; ssh chancethecoder@52.141.36.128&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;ssh 키를 생성합시다. ssh-keygen 옵션은 본인에 맞게 변경하셔도 무방합니다. 엔터키를 계속 눌러주면 기본값으로 생성됩니다. 주의할점으로, &lt;strong&gt;passphrase는 빈 값&lt;/strong&gt;으로 두어야 합니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; ssh-keygen -t rsa -b 4096 -C &amp;quot;chancethecoder@gmail.com&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt; Generating public/private rsa key pair.
 Enter file in which to save the key (/home/chancethecoder/.ssh/id_rsa):
 Enter passphrase (empty for no passphrase):
 Enter same passphrase again:
 Your identification has been saved in /home/chancethecoder/.ssh/id_rsa.
 Your public key has been saved in /home/chancethecoder/.ssh/id_rsa.pub.
 ...&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;public 키를 authorized_keys에 추가합니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; cat ~/.ssh/id_rsa.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;private 키파일을 복사합니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; cat ~/.ssh/id_rsa&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;CircleCI에서 대시보드 &amp;gt; 프로젝트 설정(기어 버튼) &amp;gt; PERMISSIONS &amp;gt; SSH Permisions로 이동합니다.&lt;/li&gt;
&lt;li&gt;Add SSH Key 버튼을 클릭합니다.&lt;/li&gt;
&lt;li&gt;Hostname을 빈칸으로 두고 Private Key에 복사한 내용을 붙여넣습니다. 정상적으로 등록되면 Fingerprint가 보이는데, 해당 값을 복사합니다.&lt;/li&gt;
&lt;li&gt;리액트 프로젝트의 .circleci/config.yml에 아래 코드를 추가합니다. your_fingerprints 부분에 복사한 값을 넣으시면 됩니다.&lt;pre&gt;&lt;code class=&quot;language-yml&quot;&gt; ...
   deploy:
     machine:
       enabled: true
     steps:
       - add_ssh_keys:
           fingerprints:
             - &amp;quot;your_fingerprints&amp;quot;
       - run:
           command: |
             echo &amp;quot;Deploy Over SSH&amp;quot;
 ...&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Azure 배포하기&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;마지막으로 CircleCI에서 가상머신 배포까지 구성해봅시다. 마찬가지로 .circleci/config.yml에 아래 코드를 추가합니다.&lt;pre&gt;&lt;code class=&quot;language-yml&quot;&gt; ...
   deploy:
     machine:
       enabled: true
     steps:
       - add_ssh_keys:
           fingerprints:
             - &amp;quot;your_fingerprints&amp;quot;
       - run:
           command: |
             echo &amp;quot;Deploy Over SSH&amp;quot;
             ssh $SSH_USER@$SSH_HOST &amp;lt;&amp;lt; EOF
               rm -f application.tar.gz*
               curl https://circleci.com/api/v1.1/project/github/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/$CIRCLE_PREVIOUS_BUILD_NUM/artifacts?circle-token=$CIRCLE_TOKEN | grep -o &amp;#39;https://[^&amp;quot;]*&amp;#39; | xargs -P4 -I % wget %?circle-token=$CIRCLE_TOKEN
               pm2 delete all
               rm -rf myapp/*
               tar xvf application.tar.gz?circle-token=$CIRCLE_TOKEN -C playground
               pm2 serve myapp 3000
             EOF&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;CircleCI에서 대시보드 &amp;gt; 프로젝트 설정(기어 버튼) &amp;gt; BUILD SETTINGS &amp;gt; Environment Variables로 이동합니다.&lt;/li&gt;
&lt;li&gt;Add Variable 버튼을 누릅니다. Name과 Value가 있는데, 각각 아래의 값으로 추가해줍시다.&lt;ol&gt;
&lt;li&gt;SSH_USER: 가상머신 접속 계정&lt;/li&gt;
&lt;li&gt;SSH_HOST: 가상머신 아이피 주소&lt;/li&gt;
&lt;li&gt;CIRCLE_TOKEN: Personal Token&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;리액트 프로젝트의 .circleci/config.yml 변경사항을 푸시합니다.&lt;/li&gt;
&lt;li&gt;소스 커밋 &amp;gt; CircleCI 워크플로우 실행 &amp;gt; 가상머신 ssh 배포 (다운로드, 재기동) 까지 일련의 과정이 잘 진행되는 지 확인합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;여기까지 잘 오셨다면 CI/CD 구성까지 완료된 것입니다. 이제 본인만의 어플리케이션을 구축해보시기 바랍니다. 저의 경우 리액트도 공부할 겸 &lt;a href=&quot;https://chancethecoder.me/&quot;&gt;이력서용 사이트&lt;/a&gt;를 만들어 두었는데요, Azure를 활용해 1년 동안 무료 호스팅이 가능하기 때문에 이를 잘 활용해서 본인만의 사이트를 만들어보시길 바랍니다.&lt;/p&gt;
&lt;/div&gt;</description>
<category>Cloud</category>
<category>Azure</category>
<category>cloud</category>
<category>서버</category>
<author>chancethecoder</author>
<guid>https://chancethecoder.tistory.com/19</guid>
<comments>https://chancethecoder.tistory.com/19#entry19comment</comments>
<pubDate>Wed, 06 Feb 2019 16:12:26 +0900</pubDate>
</item>
<item>
<title>MS Azure로 갈아타기 - 4. React 어플리케이션 만들기</title>
<link>https://chancethecoder.tistory.com/18</link>
<description>&lt;div class=&quot;markdown-body&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;CI/CD 구성 예제에서 React를 기준으로 설명하기 위해 진행하는 과정입니다. 기존 React 프로젝트가 있거나 다른 프레임워크를 사용하실 분들은 생략하셔도 무방합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이번 포스트에서는 기본적인 React 어플리케이션을 생성하고 Github에 등록하여 소스관리가 가능하도록 구성해보겠습니다. 다음 과정으로 진행하겠습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React 어플리케이션 생성&lt;/li&gt;
&lt;li&gt;Github 등록&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;react-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%83%9D%EC%84%B1&quot;&gt;React 어플리케이션 생성&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;react app을 생성합니다. 로컬 머신의 nvm을 통해 &lt;strong&gt;Node 8.10.0 버전 이상&lt;/strong&gt;을 설치하고 진행하시기 바랍니다. 만약 하위 버전을 사용해야 한다면, create-react-app 모듈을 별도 설치해 진행해주셔도 무방합니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;div&gt;node --version &lt;span class=&quot;hljs-comment&quot;&gt;# v8.10.0 이상&lt;/span&gt;
npx create-react-app my-react-app
&lt;/div&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;react app을 실행해봅니다. 브라우저에 정상적으로 뜬다면 성공입니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;div&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;cd&lt;/span&gt; my-react-app
npm start
&lt;/div&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;div&gt;Compiled successfully!

You can now view my-react-app in the browser.

  Local:            http://localhost:3000/
  On Your Network:  http://xxx.xxx.xxx.xxx:3000/

Note that the development build is not optimized.
To create a production build, use npm run build.
&lt;/div&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;빌드를 해봅시다. 생성된 결과물은 추후 가상머신 웹서버에서 서빙할 예정입니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;div&gt;npm run build
&lt;/div&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;div&gt;&amp;gt; playground@0.1.0 build /Users/a1101041/Workspace/playground
&amp;gt; react-scripts build

Creating an optimized production build...
Compiled successfully.

File sizes after gzip:

  34.71 KB  build/static/js/1.fa92c112.chunk.js
  763 B     build/static/js/runtime~main.229c360f.js
  713 B     build/static/js/main.52fd3884.chunk.js
  510 B     build/static/css/main.d4a37200.chunk.css

The project was built assuming it is hosted at the server root.
You can control this with the homepage field in your package.json.
For example, add this to build it for GitHub Pages:

  &amp;quot;homepage&amp;quot; : &amp;quot;http://myname.github.io/myapp&amp;quot;,

The build folder is ready to be deployed.
You may serve it with a static server:

  npm install -g serve
  serve -s build

Find out more about deployment here:

  http://bit.ly/CRA-deploy
&lt;/div&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;github-%EB%93%B1%EB%A1%9D&quot;&gt;Github 등록&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;git log를 실행해봅니다. create-react-app v2.1.3 기준으로 커밋이 자동 생성됩니다. 만약 git 프로젝트 생성되지 않았다면, git init을 해줍시다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;div&gt;git &lt;span class=&quot;hljs-built_in&quot;&gt;log&lt;/span&gt;
&lt;/div&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&lt;div&gt;commit c9f306ff948b94a3d34d35d42868a852dc76754c (HEAD -&amp;gt; master)
Author: Youngkyun Kim &amp;lt;yg.kim@sk.com&amp;gt;
Date:   Sun Jan 27 13:07:15 2019 +0900

    Initial commit from Create React App
&lt;/div&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;github에 새 프로젝트를 생성합니다.&lt;/li&gt;
&lt;li&gt;생성된 프로젝트로 remote 설정을 한 뒤 소스를 푸시합니다. github 계정에 SSH 설정이 되어있지 않은 경우 미리 해주도록 합시다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;div&gt;git remote add origin git@github.com:chancethecoder/my-react-app.git
git push -u origin master
&lt;/div&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;github 세팅이 완료됐습니다. 이제 본인이 개발하고자 하는 react 어플리케이션을 개발하면 됩니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
<category>Cloud</category>
<category>Azure</category>
<category>cloud</category>
<category>서버</category>
<author>chancethecoder</author>
<guid>https://chancethecoder.tistory.com/18</guid>
<comments>https://chancethecoder.tistory.com/18#entry18comment</comments>
<pubDate>Wed, 30 Jan 2019 21:27:11 +0900</pubDate>
</item>
<item>
<title>MS Azure로 갈아타기 - 3. 웹서버 실행하기</title>
<link>https://chancethecoder.tistory.com/17</link>
<description>&lt;div class=&quot;markdown-body&quot;&gt;
&lt;p&gt;저번 포스트에서 리눅스 가상머신 준비를 마쳤습니다. 이번에는 아래 과정을 진행해보겠습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nginx 설치&lt;/li&gt;
&lt;li&gt;웹 어플리케이션 연결&lt;/li&gt;
&lt;li&gt;도메인 설정 (optional)&lt;/li&gt;
&lt;li&gt;SSL 인증서 설정 (optional)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;nginx 설치&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;CentOS의 경우 nginx 설치는 yum으로 진행하면 됩니다. 운영체제에 따라 다르겠지만, CentOS가 아니라면 nginx의 공식 문서를 참고하여 설치하도록 합시다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; sudo yum -y update
 sudo yum -y install epel-release
 sudo yum -y install nginx&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;설치가 다 됐으면 nginx를 구동해봅시다. 시스템이 재시작됐을 때 자동으로 nginx를 시작하게 하고싶다면 enable을 해줘야 합니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; sudo systemctl enable nginx
 sudo systemctl start nginx&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;포트를 확인해봅시다. 80번 포트가 열려있는 것을 볼 수 있습니다. (그렇지 않다면 nginx가 제대로 실행되지 않았다는 것입니다.)&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; ss -ntl | grep 80&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt; LISTEN     0      128          *:80                       *:*
 LISTEN     0      128         :::80                      :::*&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;이제 브라우저에서 가상머신의 공용 아이피로 접속했을 때 아래와 같이 nginx 기본 화면이 보입니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;웹 어플리케이션 연결&lt;/h3&gt;
&lt;p&gt;이제 웹 어플리케이션을 연결해봅시다. 기존에 운영하시는 프로젝트가 있다면 그대로 사용하면 되지만, 없다고 가정하여 Node 프로젝트 생성부터 진행해보겠습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;nvm을 설치합니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash
 source ~/.bashrc&lt;/code&gt;&lt;/pre&gt;
 아래처럼 nvm ls를 했을 때 정상적으로 출력된다면 성공입니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; nvm ls&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;             N/A
 iojs -&amp;gt; N/A (default)
 node -&amp;gt; stable (-&amp;gt; N/A) (default)
 unstable -&amp;gt; N/A (default)&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;node를 설치합니다. 별 이슈가 없다면 최신 stable 버전으로 설치합시다. 2019년 1월 기준으로 최신 버전은 v11.6.0이 되겠습니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; nvm install stable
 node --version # v11.6.0&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;node 프로젝트를 생성합니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; mkdir myapp
 cd myapp
 npm init&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;package.json이 만들어졌다면, 서버 코드를 작성합니다. 이 때 구동에 필요한 npm 패키지도 같이 설치해줍시다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; npm install express --save
 npm install -g pm2
 vi app.js&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt; // 아래 내용을 app.js에 추가
 var express = require(&amp;#39;express&amp;#39;);
 var app = express();
 app.get(&amp;#39;/&amp;#39;, function (req, res) {
   res.send(&amp;#39;Hello World!&amp;#39;);
 });
 app.listen(3000, function () {
   console.log(&amp;#39;Example app listening on port 3000!&amp;#39;);
 });&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;위에서 설치한 pm2를 이용해 서버를 구동합니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; pm2 start app.js --name myapp&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;이제 브라우저에서 &lt;strong&gt;공인아이피:3000 주소로 접속하면 타임아웃 현상이 발생합니다&lt;/strong&gt;. 3000번 포트에 대해서 인바운드 설정을 하지 않았기 때문입니다. 우리는 사용자가 3000번 포트가 아닌 80/443 포트를 통해 접근하기를 원합니다. 따라서 Nginx를 통해 80/443 -&amp;gt; 3000 리다이렉션을 수행하도록 리버스 프록시 설정을 추가하겠습니다.&lt;/li&gt;
&lt;li&gt;아래와 같이 myapp.conf에 다음과 같이 설정을 추가하고 Nginx를 재시작합니다. 재시작 할 때 에러가 발생할 경우 십중팔구 conf 파일에 오타가 있을 수 있으니 잘 확인합시다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; sudo vi /etc/nginx/conf.d/myapp.conf&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt; # 아래 내용을 myapp.conf에 추가
 upstream backend {
     server localhost:3000;
 }
 server {
     listen       80;
     server_name  your_domain; # --&amp;gt; 도메인 or 공인아이피 입력
     location / {
         proxy_set_header X-Real-IP $remote_addr;
         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
         proxy_set_header Host $host;
         proxy_set_header Port $proxy_port;
         proxy_http_version 1.1;
         proxy_pass http://backend;
     }
 }&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; sudo systemctl restart nginx # nginx 재시작&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;이제 본인이 설정한 서버네임으로 브라우저에서 접속해봅시다. &lt;strong&gt;잘 될 것 같지만, 502 Bad Gateway 에러가 나올 것입니다&lt;/strong&gt;. (ㅜㅜ) Nginx 에러 로그를 살펴봅니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; sudo cat /var/log/nginx/error.log | tail -1&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;위와 같은 에러가 나오는데, SELinux에서 3000번 포트에 대해 Nginx 연결을 deny하는 이슈입니다. 이를 해결하려면 아래 명령어를 추가로 실행해줘야 합니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; sudo setsebool httpd_can_network_connect on&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;이제 다시 브라우저로 접속해봅니다. Hello World!라는 문구가 출력되면 정상적으로 연결 된 것입니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;도메인 설정 (optional)&lt;/h3&gt;
&lt;p&gt;개인 서버를 운영하는 경우 대부분 자신만의 도메인 네임을 가지고 있습니다. 사용자가 서버의 아이피 주소를 외우고 다닐 리가 없을 뿐더러, 깔끔하지 않기 때문입니다. 다만, &lt;strong&gt;이 과정은 선택사항이기 때문에&lt;/strong&gt; 도메인 네임까지 설정할 필요가 없다고 생각하시는 분들은 가볍게 넘어가되, 공인 아이피로 접속해주시면 되겠습니다.&lt;/p&gt;
&lt;h4&gt;구성&lt;/h4&gt;
&lt;p&gt;저는 &lt;a href=&quot;https://aws.amazon.com/route53/&quot;&gt;AWS Route53&lt;/a&gt;을 사용하고 있습니다. 여기에 추가적으로 HTTPS 세팅을 하기 위해서는 SSL 인증서가 필요한데, &lt;a href=&quot;https://www.cloudflare.com/ko-kr/&quot;&gt;Cloudflare&lt;/a&gt;에서 무료로 발급받아 사용중입니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;이 구성이 최선인 것은 당연히 아닙니다. 각자 본인에 맞게 구성해주시면 되겠습니다&lt;/strong&gt;. 다만, 도메인 네임 대행 서비스는 업체마다 가격이 천차만별이고 서비스의 질도 다르기 때문에 잘 알아보고 선택하는 것이 나중에 후회하지 않습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;AWS, Cloudflare에 각각 회원가입을 진행합니다.&lt;/li&gt;
&lt;li&gt;Route53에서 도메인 네임을 등록합니다. 등록까지 시간은 다소 걸리지만, 어려운 것은 없기 때문에 별도 설명하지 않겠습니다.&lt;/li&gt;
&lt;li&gt;Cloudflare에서 등록한 도메인으로 사이트를 추가하고, DNS 메뉴를 선택합니다.&lt;/li&gt;
&lt;li&gt;DNS Records 부분에서 다음과 같이 레코드를 추가합니다.&lt;ol&gt;
&lt;li&gt;Type: A&lt;/li&gt;
&lt;li&gt;Name: 자신의 도메인&lt;/li&gt;
&lt;li&gt;Value: 가상머신의 공인 아이피&lt;/li&gt;
&lt;li&gt;TTL: Automatic&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Cloudflare Nameservers 부분의 네임서버 정보를 확인합니다.&lt;/li&gt;
&lt;li&gt;Route53의 사이드 메뉴에서 Registered domains &amp;gt; 본인의 도메인 선택 &amp;gt; 우상단의 Add or edit name servers를 누른 후에 Cloudflare의 네임서버를 추가해줍니다.&lt;/li&gt;
&lt;li&gt;브라우저에서 도메인으로 접속해봅니다. 도메인 등록의 경우 시간이 다소 걸리기 때문에 바로 접속되지 않을 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;SSL 인증서 설정 (optional)&lt;/h3&gt;
&lt;p&gt;도메인 설정과 마찬가지로, SSL 설정은 부가적인 옵션입니다. 위의 Nginx 설정이 완료된 상태에서 &lt;a href=&quot;https://support.cloudflare.com/hc/en-us/articles/217471977&quot;&gt;Cloudflare 공식 문서&lt;/a&gt;를 참고하여 아래 과정을 진행합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Cloudflare에 접속한 후 Crypto 메뉴를 선택합니다.&lt;/li&gt;
&lt;li&gt;Origin Certificates에서 Create Certificate를 누릅니다. 다이얼로그가 나타나면 본인의 도메인 네임 리스트를 입력합니다. 서브도메인을 위해 Asterisk를 포함한 도메인도 추가해줍니다.&lt;pre&gt;&lt;code&gt; *.your-domain.com, your-domain.com&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;Next를 누르면 Origin Certificate와 Private Key가 생성되는 것을 확인할 수 있습니다. 생성된 키와 인증서를 복사하여 서버에 추가해줍니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; sudo vi /etc/ssl/certs/your-domain.com.key # --&amp;gt; Private Key 내용 추가
 sudo vi /etc/ssl/certs/your-domain.com.pem # --&amp;gt; Origin Certificate 내용 추가&lt;/code&gt;&lt;/pre&gt;
 주의 할 점으로, Private Key의 경우 &lt;strong&gt;한 번 발급되면 다시 보여주지 않기 때문에 로컬에 복사&lt;/strong&gt;해두는 것이 좋습니다. 만약 분실할 경우 삭제 후 다시 발급해야 합니다.&lt;/li&gt;
&lt;li&gt;서버의 Nginx 설정을 엽니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; sudo vi /etc/nginx/conf/conf.d/myapp.conf&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;SSL 인증서 설정을 추가하고 Nginx를 재시작합니다.&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt; upstream backend {
     server localhost:3000;
 }
 server {
     listen       80;
     listen       443;
     ssl        on;
     ssl_certificate         /etc/ssl/certs/your-domain.com.pem;
     ssl_certificate_key     /etc/ssl/certs/your-domain.com.key;
     server_name  your_domain;
     location / {
         proxy_set_header X-Real-IP $remote_addr;
         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
         proxy_set_header Host $host;
         proxy_set_header Port $proxy_port;
         proxy_http_version 1.1;
         proxy_pass http://backend;
     }
 }&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; sudo systemctl restart nginx&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;도메인에 https를 붙여서 접속해봅시다. 정상 접속이 된다면 설정이 마무리 된 것입니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
<category>Cloud</category>
<category>Azure</category>
<category>cloud</category>
<category>서버</category>
<author>chancethecoder</author>
<guid>https://chancethecoder.tistory.com/17</guid>
<comments>https://chancethecoder.tistory.com/17#entry17comment</comments>
<pubDate>Sun, 20 Jan 2019 18:19:59 +0900</pubDate>
</item>
<item>
<title>MS Azure로 갈아타기 - 2. 가상머신 만들기</title>
<link>https://chancethecoder.tistory.com/16</link>
<description>&lt;div class=&quot;markdown-body&quot;&gt;
&lt;p&gt;리눅스 VM 생성부터 서버 세팅까지 기본적인 사항은 &lt;a href=&quot;https://docs.microsoft.com/ko-kr/azure/virtual-machines/linux/&quot;&gt;MS Azure 공식 문서&lt;/a&gt;에 대부분 나와 있으니 참고하도록 합니다.&lt;/p&gt;
&lt;p&gt;이번 포스트에서는 아래 과정을 진행해보겠습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가상머신 생성&lt;/li&gt;
&lt;li&gt;디스크 마운트&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;가상머신 생성&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;먼저 포탈에 접속해서 홈 &amp;gt; 가상머신 &amp;gt; 추가를 선택합니다.&lt;/li&gt;
&lt;li&gt;구독 및 리소스 그룹을 설정합니다. 처음 생성하는 경우 리소스 그룹을 새로 만들기로 만들어주면 됩니다.&lt;/li&gt;
&lt;li&gt;인스턴스 정보를 입력합니다. 이미지의 경우 선호하는 운영체제를 선택하면 됩니다. 저는 CentOS-based 7.5로 진행해보겠습니다. 지역, 가용성, 크기는 각각 대한민국, 사용 안함, B1s로 선택합니다.&lt;/li&gt;
&lt;li&gt;관리자 계정 정보를 입력합니다. SSH 키 방식을 선택하고 사용자 이름, SSH 키 정보를 넣어줍니다. SSH 키 생성 방법은 &lt;a href=&quot;https://docs.microsoft.com/ko-kr/azure/virtual-machines/linux/mac-create-ssh-keys&quot;&gt;공식 문서&lt;/a&gt;에 자세히 있으므로 설명하지 않겠습니다.&lt;/li&gt;
&lt;li&gt;네트워크 인바운드를 설정합니다. 여기서 &lt;strong&gt;HTTP, HTTPS, SSH&lt;/strong&gt; 세 개 포트를 허용해줍니다. 이를 해주지 않을 경우 SSH 접속 및 브라우저 접근이 안되므로 반드시 설정해주어야 합니다.&lt;/li&gt;
&lt;li&gt;다음: 디스크를 누르고 넘어갑시다. 디스크는 B1s 기준으로 30GB(프리미엄 SSD)의 OS 메모리가 제공되는데, 이를 그대로 사용해도 상관없다면 별도 설정 없이 다음 탭으로 넘어가셔도 됩니다. 저는 체험판 계정에서 무료 제공되는 128GB의 디스크를 활용하기 위해 추가 설정을 해보도록 하겠습니다.&lt;/li&gt;
&lt;li&gt;아래 데이터 디스크의 새 디스크 만들기 및 연결을 누릅니다. 새 디스크 만들기 탭이 나오면 크기를 64GB로 변경하고 확인을 누릅니다. 똑같이 한 번 더 반복하여 두 개의 디스크를 만들어줍니다.&lt;/li&gt;
&lt;li&gt;나머지 설정은 별다른 설정 없이 계속해서 넘어가줍니다. 마지막으로 검토+만들기를 선택하면 가상머신 생성이 완료됩니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;가상머신 접속&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;이제 가상머신에 접속해봅시다. 대시보드 &amp;gt; 생성된 가상머신을 클릭합니다. 개요 탭에서 좌상단의 연결을 누릅니다.&lt;/li&gt;
&lt;li&gt;우측 탭에서 SSH 커맨드를 복사한 다음 터미널 혹은 SSH 클라이언트에서 접속해봅시다. 정상적으로 SSH 설정이 됐다면 별도의 과정 없이 바로 연결 가능합니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; ssh chancethecoder@52.141.36.128&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt; Last login: Sun Jan 20 03:31:49 2019 from 121.167.144.18&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;디스크 마운트&lt;/h3&gt;
&lt;p&gt;데이터 디스크를 추가한 경우, 리눅스 머신에서 별도로 마운트 작업을 해줘야 사용이 가능합니다. 만약 디스크 추가 없이 OS 디스크만으로 사용하겠다면 이 과정을 생략합시다.&lt;/p&gt;
&lt;p&gt;역시 &lt;a href=&quot;https://docs.microsoft.com/ko-kr/azure/virtual-machines/linux/attach-disk-portal&quot;&gt;공식문서&lt;/a&gt;를 참고하여 진행하겠습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;가상머신에 접속했다면, 디스크 설정을 진행합시다. 먼저 디스크 정보를 확인합니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; df -h&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt; Filesystem      Size  Used Avail Use% Mounted on
 /dev/sda2        30G  1.2G   29G   5% /
 devtmpfs        444M     0  444M   0% /dev
 tmpfs           456M     0  456M   0% /dev/shm
 tmpfs           456M  6.7M  449M   2% /run
 tmpfs           456M     0  456M   0% /sys/fs/cgroup
 /dev/sda1       497M   81M  417M  17% /boot
 /dev/sdb1       3.9G   16M  3.7G   1% /mnt/resource
 tmpfs            92M     0   92M   0% /run/user/1000&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;Filesystem에 sda, sdb가 마운트되어 있습니다. 다음으로 추가해둔 두 개의 디스크(sdc, sdd)를 확인합니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; dmesg | grep SCSI&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt; [    0.353148] SCSI subsystem initialized
 [    2.411302] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 248)
 [    9.567794] sd 2:0:0:0: [sda] Attached SCSI disk
 [    9.590129] sd 5:0:0:1: [sdd] Attached SCSI disk
 [    9.614972] sd 5:0:0:0: [sdc] Attached SCSI disk
 [    9.640439] sd 3:0:1:0: [sdb] Attached SCSI disk&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;fdisk로 디스크를 초기화해줍시다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; sudo fdisk /dev/sdc&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt; Welcome to fdisk (util-linux 2.23.2).
 Changes will remain in memory only, until you decide to write them.
 Be careful before using the write command.
 Device does not contain a recognized partition table
 Building a new DOS disklabel with disk identifier 0xd9841c1a.
 The device presents a logical sector size that is smaller than the physical sector size. Aligning to a physical sector (or optimal I/O) size boundary is recommended, or performance may be impacted.
 Command (m for help):&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;커맨드 입력이 나오면 n을 입력합니다. 파티션은 전부 default 값을 선택해줍시다.&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt; Command (m for help): n
 Partition type:
     p   primary (0 primary, 0 extended, 4 free)
     e   extended
 Select (default p): p
 Partition number (1-4, default 1): 1
 First sector (2048-134217727, default 2048): Using default value 2048
 Last sector, +sectors or +size{K,M,G} (2048-134217727, default 134217727): Using default value 134217727
 Partition 1 of type Linux and of size 64 GiB is set&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;다시 커맨드 입력이 나오면 p를 입력합니다.&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt; Command (m for help): p
 Disk /dev/sdc: 68.7 GB, 68719476736 bytes, 134217728 sectors
 Units = sectors of 1 * 512 = 512 bytes
 Sector size (logical/physical): 512 bytes / 4096 bytes
 I/O size (minimum/optimal): 4096 bytes / 4096 bytes
 Disk label type: dos
 Disk identifier: 0xd9841c1a
 Device Boot      Start         End      Blocks   Id  System
 /dev/sdc1            2048   134217727    67107840   83  Linux&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;다시 커맨드 입력이 나오면 w를 입력하여 쓰기 및 fdisk를 종료합니다.&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt; Command (m for help): w
 The partition table has been altered!
 Calling ioctl() to re-read partition table.
 Syncing disks.&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;이제 mkfs로 파티션에 파일시스템을 지정해줍니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; sudo mkfs -t ext4 /dev/sdc1&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;마지막으로 데이터 디렉토리를 생성해준 다음 디스크를 마운트합니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; sudo mkdir /data1
 sudo mount /dev/sdc1 /data1&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;1~8을 반복해서 sdd도 마운트해줍니다.&lt;/li&gt;
&lt;li&gt;디스크가 잘 마운트 되었는지 확인해봅시다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;df -h&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Filesystem      Size  Used Avail Use% Mounted on
/dev/sda2        30G  1.2G   29G   5% /
devtmpfs        444M     0  444M   0% /dev
tmpfs           456M     0  456M   0% /dev/shm
tmpfs           456M  6.7M  449M   2% /run
tmpfs           456M     0  456M   0% /sys/fs/cgroup
/dev/sda1       497M   81M  417M  17% /boot
/dev/sdb1       3.9G   16M  3.7G   1% /mnt/resource
tmpfs            92M     0   92M   0% /run/user/1000
/dev/sdc1        63G   53M   60G   1% /data1
/dev/sdd1        63G   53M   60G   1% /data2&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;마지막으로, 서버 재부팅 시 디바이스가 자동으로 마운트 되려면 /etc/fstab을 업데이트 해야 합니다. 먼저 blkid로 블럭 디바이스의 UUID를 확인합니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo -i blkid&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;/dev/sda1: UUID=&amp;quot;11111111-1a1a-1b1b-1c1c-1d1d1d1d1d1d&amp;quot; TYPE=&amp;quot;xfs&amp;quot;
/dev/sda2: UUID=&amp;quot;22222222-2a2a-2b2b-2c2c-2d2d2d2d2d2d&amp;quot; TYPE=&amp;quot;xfs&amp;quot;
/dev/sdb1: UUID=&amp;quot;33333333-3a3a-3b3b-3c3c-3d3d3d3d3d3d&amp;quot; TYPE=&amp;quot;ext4&amp;quot;
/dev/sdc1: UUID=&amp;quot;44444444-4a4a-4b4b-4c4c-4d4d4d4d4d4d&amp;quot; TYPE=&amp;quot;ext4&amp;quot;
/dev/sdd1: UUID=&amp;quot;55555555-5a5a-5b5b-5c5c-5d5d5d5d5d5d&amp;quot; TYPE=&amp;quot;ext4&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;택스트 편집기로 fstab을 아래와 같이 수정해줍니다.&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo vi /etc/fstab&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;#
# /etc/fstab
# Created by anaconda on Wed Aug 15 19:30:54 2018
#
# Accessible filesystems, by reference, are maintained under &amp;#39;/dev/disk&amp;#39;
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
#
UUID=22222222-2a2a-2b2b-2c2c-2d2d2d2d2d2d /                       xfs     defaults        0 0
UUID=11111111-1a1a-1b1b-1c1c-1d1d1d1d1d1d /boot                   xfs     defaults        0 0
UUID=44444444-4a4a-4b4b-4c4c-4d4d4d4d4d4d /data1                   ext4     defaults,nofail 1 2 # &amp;lt;-- 추가
UUID=55555555-5a5a-5b5b-5c5c-5d5d5d5d5d5d /data2                  ext4    defaults,nofail 1 2 # &amp;lt;-- 추가&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이렇게 가상머신 생성 및 디스크 추가가 완료됐습니다. 다음 포스트에서는 서버에 Nginx 및 도메인 설정을 해보도록 하겠습니다.&lt;/p&gt;
&lt;/div&gt;</description>
<category>Cloud</category>
<category>Azure</category>
<category>cloud</category>
<category>서버</category>
<author>chancethecoder</author>
<guid>https://chancethecoder.tistory.com/16</guid>
<comments>https://chancethecoder.tistory.com/16#entry16comment</comments>
<pubDate>Sun, 20 Jan 2019 14:52:28 +0900</pubDate>
</item>
<item>
<title>MS Azure로 갈아타기 - 1. 체험판 계정 만들기</title>
<link>https://chancethecoder.tistory.com/15</link>
<description>&lt;div class=&quot;markdown-body&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://azure.microsoft.com/ko-kr/free/free-account-faq/&quot;&gt;Azure 체험 계정 FAQ&lt;/a&gt;를 가볍게 흝어보고 시작하겠습니다. 체험판 계정을 통해 제공되는 것은 아래와 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;12개월 무료 서비스&lt;ul&gt;
&lt;li&gt;750시간의 Microsoft Windows Server용 Azure B1S 범용 Virtual Machines&lt;/li&gt;
&lt;li&gt;750시간의 Linux용 Azure B1S 범용 Virtual Machines&lt;/li&gt;
&lt;li&gt;128GB의 Managed Disks: 64GB(P6) SSD 저장소 2개의 조합, 1GB 스냅숏 및 2백만 개 I/O 작업&lt;/li&gt;
&lt;li&gt;5GB의 LRS-Hot Blob Storage: 2백만 개의 읽기, 2백만 개의 쓰기 및 2백만 개의 읽기/목록 작업&lt;/li&gt;
&lt;li&gt;5GB의 LRS File Storage: 2백만 개의 읽기, 2백만 개의 목록 및 2백만 개의 기타 파일 작업&lt;/li&gt;
&lt;li&gt;데이터베이스 트랜잭션 단위가 10개인 250GB의 SQL Database 표준 S0 인스턴스&lt;/li&gt;
&lt;li&gt;5GB의 Azure Cosmos DB: 400개의 예약된 단위&lt;/li&gt;
&lt;li&gt;아웃바운드 데이터 전송을 위한 15GB의 대역폭(인바운드 전송은 무제한 무료)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;200$ 크레딧&lt;/li&gt;
&lt;li&gt;Always free 서비스&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;여기서 첫 번째 항목인 12개월 무료 서비스가 주요 혜택입니다. 200$의 크레딧 옵션 또한 좋아 보일 수 있으나, &lt;strong&gt;한 달이라는 유효 기간&lt;/strong&gt;이 있기 때문에 주의해야 합니다. 처음 30일동안의 리소스 사용량에 대해 무료 사용량 초과분이 크레딧에서 공제되는 방식이며, 12개월 무료 서비스만을 이용하고싶다면 처음부터 없는 옵션이라고 생각하고 서버를 구성합시다.&lt;/p&gt;
&lt;h3&gt;MS 계정 가입하기&lt;/h3&gt;
&lt;p&gt;Azure를 사용하려면 MS 계정이 필요합니다. 이미 있는 경우 사용하시면 되지만, 저는 새로 만들었습니다. 새로 만들 경우 전화번호를 입력하는데, 입력 란에 1-2345-6789 이런 식의 이상한 자릿수로 입력하라고 되어 있습니다. 가볍게 무시하고 앞자리(01x)부터 입력 후 문자인증을 진행하면 됩니다. 나머지 사항은 별다른 것이 없어서 따로 셜멍하지 않습니다.&lt;/p&gt;
&lt;h3&gt;구독 종량제 업그레이드&lt;/h3&gt;
&lt;p&gt;200$ 크레딧이 만료되거나 전부 사용되면 종량제 구독으로 변경해야 합니다. 종량제는 월 단위 과금 설정 및 카드를 연동하여 사용자에게 과금을 청구할 수 있도록 등록하는 것인데, 크레딧 만료 기간과 상관 없이 해 두면 손해볼 일이 없기 때문에 미리 해두는 것을 추천합니다.&lt;/p&gt;
&lt;h3&gt;Azure 접속&lt;/h3&gt;
&lt;p&gt;이제 MS 계정으로 &lt;a href=&quot;https://portal.azure.com&quot;&gt;Azure&lt;/a&gt;에 접속해봅시다. 대시보드가 정상적으로 보인다면 본격적인 작업을 하기 위한 준비는 마친 것입니다.&lt;/p&gt;
&lt;/div&gt;</description>
<category>Cloud</category>
<category>Azure</category>
<category>cloud</category>
<author>chancethecoder</author>
<guid>https://chancethecoder.tistory.com/15</guid>
<comments>https://chancethecoder.tistory.com/15#entry15comment</comments>
<pubDate>Mon, 31 Dec 2018 03:13:42 +0900</pubDate>
</item>
<item>
<title>MS Azure로 갈아타기 - 0. 시작하며</title>
<link>https://chancethecoder.tistory.com/14</link>
<description>&lt;div class=&quot;markdown-body&quot;&gt;
&lt;p&gt;공부도 할 겸 나만의 웹 서버를 갖고싶어 시작한 클라우드 서비스가 있었습니다. Digital Ocean이라는 호스팅 서비스를 이용했는데, 나름 메이저에 속하면서 가성비도 괜찮아 최근까지 만족스럽게 잘 써 왔습니다. 그런데 얼마 전 친구가 구글 GCP 크레딧을 얻어 사용하는 모습을 보고 혹하게 됐습니다. 그래서 GCP를 들어가 확인해보니, 예전에 무슨 생각이었는지 몰라도 크레딧을 받았었고 그 사실을 까맣게 잊어버려 300$가 그대로 만료되어 있었습니다. 대충 넘어갈 수 있었지만, 전에 AWS 프리티어도 이와 비슷하게 활용하지 못한 전적이 있었기 때문에 어떻게든 체험판 크레딧을 써보자 하고 마음먹게 됐습니다.&lt;/p&gt;
&lt;p&gt;그래서 생각한 것이 바로 MS Azure입니다. 알만한 사람은 다 알겠지만 MS 역시 구글, 아마존과 비슷하게 클라우드 서비스를 제공하고 있으며 신규 사용자에게 체험판 이용권을 주고 있습니다. 요즘 Azure의 상승세가 엄청나기 때문에 이 기회에 사용해보는 것도 의미가 있다고 생각했습니다.&lt;/p&gt;
&lt;h3&gt;그래서 어떤 것을 해볼까?&lt;/h3&gt;
&lt;p&gt;계정 생성부터 도메인 설정, Nginx 세팅 및 React 어플리케이션 접속까지 해보고, 마무리로 CI를 구성해보려고 합니다. React는 기존에 운영하던 포트폴리오 앱을 사용하며, CI 역시 기존에 구성했던 것과 비슷하게 마이그레이션 해보겠습니다.&lt;/p&gt;
&lt;p&gt;포스트는 시리즈로 올리겠지만, 궁금한 점이 있을 수도 있고 제가 진행하는 내용이 best practice는 아니기 때문에 만약 이 글을 보고 혹해서 Azure로 넘어오다 삽질을 하셨거나(...?) 뭔가 새로운 아이디어를 제안하고 싶으시다면 연락주시면 감사하겠습니다.&lt;/p&gt;
&lt;h3&gt;Azure vs Digital Ocean 과금 비교&lt;/h3&gt;
&lt;p&gt;시작에 앞서 과금에 대해 살펴보다가 Digital Ocean과 Azure의 과금이 얼마나 차이날까 궁금해서 살짝 조사해보게 됐습니다. Digital Ocean에 관심이 없으시다면 가볍게 패스해주시면 되겠습니다.&lt;/p&gt;
&lt;p&gt;제가 기존에 Digital Ocean을 사용할 땐 월 20$짜리 플랜을 이용했습니다. 이번에 갈아타면서 최대한 비슷한 스펙으로 과금을 비교해봤는데, 생각보다 차이가 커서 놀랐습니다. (결론만 놓고 보면 Digital Ocean이 압도적으로 저렴합니다)&lt;/p&gt;
&lt;h4&gt;비교 테이블&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Service&lt;/th&gt;
&lt;th&gt;Instance&lt;/th&gt;
&lt;th&gt;Spec&lt;/th&gt;
&lt;th&gt;Region&lt;/th&gt;
&lt;th&gt;Price&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Digital Ocean&lt;/td&gt;
&lt;td&gt;Standard 4GB 2cores&lt;/td&gt;
&lt;td&gt;2 vCPUs / 4GB Memory / 80GB Disk&lt;/td&gt;
&lt;td&gt;싱가포르&lt;/td&gt;
&lt;td&gt;$20/월&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Azure&lt;/td&gt;
&lt;td&gt;B2S&lt;/td&gt;
&lt;td&gt;2 vCPUs / 4GB Memory / 8GB Disk&lt;/td&gt;
&lt;td&gt;한국중부&lt;/td&gt;
&lt;td&gt;$41.17/월&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;이미지는 리눅스 배포판으로 동일하기 때문에 제외하고, 디스크 용량은 Digital Ocean이 훨씬 많음에도 불구하고 비용은 Azure가 2배 가량 비싼 것으로 보입니다. (Azure의 경우 Disk를 따로 추가하도록 권장하며, 저장소 별도로 과금이 추가 발생하게 됩니다) 하지만 Region에 따라 가격 변동(Azure의 경우 Region 변경으로 30$까지 가능)이 다양하며, 네트워크나 기타 이것 저것 자세히 따져본 것은 아니기 때문에 정확한 비교는 아닙니다.&lt;/p&gt;
&lt;p&gt;한 가지 다행인 점은 Azure가 1개월 단위인 종량제가 아니라 연단위 결제로 했을 경우 할인폭이 매우 커서(1년에 43%, 3년에 61%), 이를 잘 활용하면 Azure가 개인 서버용으로 마냥 나쁜 옵션은 아니라는 생각도 들었습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.vpsbenchmarks.com/compare/azure_vs_docean&quot;&gt;MS Azure vs Digital Ocean 벤치마크&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://azure.microsoft.com/ko-kr/pricing/calculator/&quot;&gt;Azure 요금 계산기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.digitalocean.com/pricing/&quot;&gt;Digital Ocean 요금 표&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</description>
<category>Cloud</category>
<category>Azure</category>
<category>cloud</category>
<author>chancethecoder</author>
<guid>https://chancethecoder.tistory.com/14</guid>
<comments>https://chancethecoder.tistory.com/14#entry14comment</comments>
<pubDate>Mon, 31 Dec 2018 03:06:46 +0900</pubDate>
</item>
<item>
<title>ping은 되는데 curl/wget이 안되는 경우</title>
<link>https://chancethecoder.tistory.com/13</link>
<description>&lt;div class=&quot;markdown-body&quot;&gt;
&lt;p&gt;최근 리눅스에서 개발 중 특정 서버의 Rest API를 curl/wget으로 호출 시 timeout 에러가 발생한 적이 있습니다. 방화벽 문제를 의심했으나, ping은 가능한 상황입니다. 통신이 가능하므로 방화벽 외의 다른 문제가 있을 것이라고 의심하게 됐습니다.&lt;/p&gt;
&lt;h3&gt;결론(tl;dr)&lt;/h3&gt;
&lt;p&gt;위의 경우 &lt;strong&gt;특정 port&lt;/strong&gt;의 인바운드/아웃바운드 방화벽이 적용된 것이라고 생각할 수 있습니다.&lt;/p&gt;
&lt;h2&gt;ping은 port를 사용하지 않는다&lt;/h2&gt;
&lt;p&gt;흔히 특정 port에 대해 통신 테스트를 할 경우 ping이 아니라 telnet을 사용합니다. ping은 port 옵션이 없기 때문입니다. 여기서 유추해볼 수 있는 것은 ping이 port를 사용하지 않는 통신 방식이라는 것입니다.&lt;/p&gt;
&lt;h3&gt;Protocol&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://curl.haxx.se/docs/manpage.html&quot;&gt;curl&lt;/a&gt;은 HTTP, FTP, LDAP 등 어플리케이션 계층의 다양한 프로토콜을 지원합니다. 이들은 전송 계층(TCP/UDP)에 포함되며, &lt;a href=&quot;https://ko.wikipedia.org/wiki/TCP/UDP%EC%9D%98_%ED%8F%AC%ED%8A%B8_%EB%AA%A9%EB%A1%9D&quot;&gt;well-known port&lt;/a&gt; 혹은 지정 port를 가지게 됩니다.&lt;/p&gt;
&lt;p&gt;그에 비해, &lt;a href=&quot;https://linux.die.net/man/8/ping&quot;&gt;ping&lt;/a&gt;은 ICMP 프로토콜을 사용합니다. 이는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/OSI_%EB%AA%A8%ED%98%95&quot;&gt;OSI 7 계층 모형&lt;/a&gt;에서 네트워크 계층에 해당하며, 전송 계층보다 상위에 존재하게 됩니다. 당연히 port를 사용하지 않으며, IP 기반으로 데이터 전송 기능을 수행합니다.&lt;/p&gt;
&lt;p&gt;대표적인 라우팅 프로그램으로 traceroute(윈도우에선 tracert)가 있습니다. 이는 리눅스 기준으로 UDP 통신을 하는데, 옵션을 통해 ICMP 통신을 하도록 설정할 수 있습니다. 위 사례의 경우 traceroute 역시 통신 가능했을 것이라고 추측할 수 있겠습니다. 문제와 별개로, &lt;a href=&quot;https://www.linuxquestions.org/questions/linux-networking-3/why-linux-traceroute-use-udp-instead-of-icmp-815625/&quot;&gt;기본 통신이 UDP인 이유와 차이점&lt;/a&gt;은 리눅스의 권한 특성을 고려한 것으로 생각됩니다.&lt;/p&gt;
&lt;h2&gt;복기&lt;/h2&gt;
&lt;p&gt;다시 현상으로 돌아가서, timeout이 발생할 경우 다음 두 가지에 해당합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;request 도달 실패&lt;/li&gt;
&lt;li&gt;response 도달 실패&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;생각해보면 네트워크 문제일 확률이 높은데(트러블 슈팅이 바로 됐어야 합니다), ping이 가능한 상황에서 방화벽 문제를 의심했음에도 불구하고 착각으로 인해 이를 간과했습니다.&lt;/p&gt;
&lt;p&gt;이번 기회에 평소 아무 생각 없이 사용하는 명령어도 간혹 깊게 들어가서 살펴볼 필요가 있겠다는 생각을 했습니다.&lt;/p&gt;
&lt;/div&gt;</description>
<category>회고</category>
<category>Linux</category>
<category>TIL</category>
<category>개발</category>
<category>네트워크</category>
<category>서버</category>
<author>chancethecoder</author>
<guid>https://chancethecoder.tistory.com/13</guid>
<comments>https://chancethecoder.tistory.com/13#entry13comment</comments>
<pubDate>Sat, 29 Dec 2018 16:06:30 +0900</pubDate>
</item>
<item>
<title>다익스트라 알고리즘 파이썬으로 구현하기 - 최단경로</title>
<link>https://chancethecoder.tistory.com/12</link>
<description>&lt;div class=&quot;markdown-body&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1753&quot;&gt;baekjoon - 최단경로&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%81%AC%EC%8A%A4%ED%8A%B8%EB%9D%BC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98&quot;&gt;다익스트라 알고리즘&lt;/a&gt;을 사용해 최단거리를 구하는 문제입니다. 별다른 고민 없이 알고리즘 그대로 파이썬으로 옮겨 적으면 쉽게 통과할 것 같지만, 한 가지 함정이 있습니다. 바로 &lt;strong&gt;빠른 IO 처리&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;p&gt;파이썬에서의 빠른 입출력 구현은 input 대신 &lt;strong&gt;sys.stdin.readline&lt;/strong&gt;을 사용하는 것인데, 입출력이 큰 경우 시간 최적화를 위해 습관화 하는 것이 좋습니다. 아래 코드는 우선순위큐를 사용한 다익스트라 알고리즘에 빠른 입출력을 적용하여 시간초과 없이 통과한 코드입니다. (알고리즘 상에는 변화가 없습니다)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import sys
import heapq

input = sys.stdin.readline    # 빠른 입출력
INF = sys.maxsize

# 다익스트라 알고리즘
def solve(adjacent, K):
    prev = [-1] * (len(adjacent) + 1)    # predecessor
    dist = [INF] * (len(adjacent) + 1)   # source로부터의 최소 거리 배열
    dist[K] = 0

    priority_queue = []
    heapq.heappush(priority_queue, [0, K])

    while priority_queue:
        # 거리가 제일 작은 노드 선택
        current_dist, here = heapq.heappop(priority_queue)

        # 인접 노드 iteration
        for there, length in adjacent[here].items():
            next_dist = dist[here] + length

            if next_dist &amp;lt; dist[there]:
                dist[there] = next_dist
                prev[there] = here
                heapq.heappush(priority_queue, [next_dist, there])

    return dist, prev

if __name__ == &amp;quot;__main__&amp;quot;:
    V, E = map(int, input().split())
    K = int(input())
    adjacent = [{} for _ in range(V + 1)]

    for _ in range(E):
        u, v, w = map(int, input().split())

        # 만약 동일한 경로의 간선이 주어질 경우 적은 비용의 간선 선택
        if v in adjacent[u]:
            adjacent[u][v] = min(adjacent[u][v], w)
        else:
            adjacent[u][v] = w

    dist, prev = solve(adjacent, K)

    for d in dist[1:]:
        print(d if d != INF else &amp;quot;INF&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</description>
<category>Algorithm</category>
<category>Algorithm</category>
<author>chancethecoder</author>
<guid>https://chancethecoder.tistory.com/12</guid>
<comments>https://chancethecoder.tistory.com/12#entry12comment</comments>
<pubDate>Mon, 17 Dec 2018 02:02:06 +0900</pubDate>
</item>
</channel>
</rss>