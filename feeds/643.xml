<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
<title>Changing Stuff and Seeing What Happens</title>
<link>https://mark3236.tistory.com/</link>
<description></description>
<language>ko</language>
<pubDate>Mon, 13 May 2019 22:27:38 +0900</pubDate>
<generator>TISTORY</generator>
<managingEditor>mark3236</managingEditor>
<image>
<title>Changing Stuff and Seeing What Happens</title>
<url>http://cfile10.uf.tistory.com/image/232056465948055A2A6E11</url>
<link>https://mark3236.tistory.com</link>
<description></description>
</image>
<item>
<title>삼성전자 SW 테스트 B형 가이드</title>
<link>https://mark3236.tistory.com/entry/%EC%82%BC%EC%84%B1%EC%A0%84%EC%9E%90-SW-%ED%85%8C%EC%8A%A4%ED%8A%B8-B%ED%98%95-%EA%B0%80%EC%9D%B4%EB%93%9C</link>
<description>&lt;h1&gt;삼성전자 SW 테스트 B형 (공채 추가시험)&amp;nbsp;가이드&lt;/h1&gt;
&lt;h2&gt;Disclaimer&lt;/h2&gt;
&lt;p&gt;채용 진행과정에서 작성한 기밀유지서약서가 있기 때문에 채용 프로세스 및 정보(SW테스트 제약사항, 기출문제 등)는 이미 인터넷에 공개적으로 알려진 사항에 대해서만 정리하여 작성한 것이며, 기밀유지 하기로 한 부분에 대해서 문제시될 부분은 없습니다.&lt;br /&gt;
SW Test에 대한 안내사항은 &lt;a href=&quot;https://www.swexpertacademy.com&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;swexpertacademy&lt;/a&gt;&lt;a href=&quot;https://www.codeground.org&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.swexpertacademy.com&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&amp;nbsp;공식 사이트&lt;/a&gt;에 안내된 부분을 다시 정리한 것일 뿐이며, 기출문제는 유출하지 않습니다.&lt;br /&gt;
타 사이트(백준저지 등)에 올라온 문제를 기반으로 저의 해설을 추가했을 뿐, 참가했던 SW테스트와는 무관합니다.&lt;/p&gt;&lt;p&gt;그래도 만약 문제가 되는 부분이 있을 경우 통보해주시면 해당 내용은 삭제조치하도록 하겠습니다.&lt;/p&gt;&lt;p&gt;또한, 본 가이드는 알고리즘 학습에 도움을 주기 위함일 뿐이며, 미래 정확성은 책임지지 않습니다.&lt;br /&gt;
본 가이드 내 정보를 참고한 모든 결과에 대한 책임은 독자에게 있습니다.&lt;/p&gt;
&lt;h2&gt;1. 개요&lt;/h2&gt;
&lt;p&gt;삼성전자에서는 2016년쯤부터 S직군(소프트웨어) 신입사원 및 인턴사원 공채 전형에서 SW 테스트를 실시하고 있습니다.
서류전형 -&amp;gt; SW테스트 (GSAT/SSAT 면제) -&amp;gt; 최종면접(인성, 직무, 창의)으로 진행됩니다.&lt;/p&gt;&lt;p&gt;이 때 보는 SW테스트가 바로 SW Test A형입니다.&lt;br /&gt;
이렇게 기존에는 사내 직원들에게만 실시하던 테스트를 삼성전자가 얼마 전 코드그라운드를 통해 일반 대학생/졸업생에게 오픈하였습니다.&lt;br /&gt;
링크 : &lt;a href=&quot;https://www.swexpertacademy.com/main/main.do&quot;&gt;https://www.swexpertacademy.com/main/main.do&lt;/a&gt;&lt;/p&gt;&lt;p&gt;참고로 B/C형은 취득시 인사평가/배치시 우대사항이 있는 것으로 공지되어 있는데요,&lt;br /&gt;
A형에 대해서는 이미 글(&lt;a href=&quot;http://mark3236.tistory.com/47&quot;&gt;링크&lt;/a&gt;)을 썼었으니
&lt;strong&gt;이번에는 B형에 대해 써보려고 합니다&lt;/strong&gt;. (C형은 한번도 시험을 안 봤기 때문에 쓸 일이 없을 것 같네요)&lt;/p&gt;
&lt;h2&gt;2. B형 대비방법&lt;/h2&gt;
&lt;p&gt;먼저, 삼성에서 공개적으로 밝힌 안내사항입니다.&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:605px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/998348345AF9784528&quot; filemime=&quot;image/jpeg&quot; filename=&quot;1231242.PNG&quot; height=&quot;312&quot; width=&quot;605&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;
위와 같이 &lt;strong&gt;B형은 4시간이 주어지며 한 문제를 풀어야 합니다. 언어는 C/C++/JAVA이며 stdio/iostream을 제외한 라이브러리 사용 불가합니다.&lt;/strong&gt;&lt;br /&gt;
즉, C++ 기준으로 STL 모두 사용할 수 없고, C++ 11 및 14까지도 지원은 될겁니다만 의미가 없습니다(STL이 안되니). auto, 람다 등은 아마도 모두 사용 가능할텐데, 다만 문제 구성이 이와 같은 기능을 필요로하는 형태가 아닙니다.&lt;/p&gt;&lt;p&gt;B형은 A형에 비해 꽤나 까다로운 편인데요, A형과 비교하자면...&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;A&lt;/th&gt;
&lt;th&gt;B&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;라이브러리&lt;/td&gt;
&lt;td&gt;STL 등 라이브러리 사용 자유&lt;/td&gt;
&lt;td&gt;표준라이브러리 등 일체 사용금지(stdio 등도 사용하지 않음)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;특징&lt;/td&gt;
&lt;td&gt;input을 받아 expected output 출력&lt;/td&gt;
&lt;td&gt;출력 필요없음 - API 사용하여 문제해결&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;제약사항&lt;/td&gt;
&lt;td&gt;모든 코드 자유수정 가능&lt;/td&gt;
&lt;td&gt;바꿀 수 없는 코드 존재&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;제한시간&lt;/td&gt;
&lt;td&gt;2문제 3시간&lt;/td&gt;
&lt;td&gt;1문제 4시간&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;유형&lt;/td&gt;
&lt;td&gt;시뮬레이션&lt;/td&gt;
&lt;td&gt;최적 솔루션 도출&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;중요 포인트&lt;/td&gt;
&lt;td&gt;O(N^2) 따위만 되지 않게 구현&lt;/td&gt;
&lt;td&gt;API 호환되게 로직 구현, 최적화 매우 중요&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;3. 문제풀이 예시&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;주의 : 벼락치기로 통과하기에는 다소 무리가 있는 시험입니다. 예를 들어, GUI 부분은 건너뛰더라도 테트리스 기본 로직 정도를 짤 자신이 없다면 기초를 먼저 닦는 시간을 가지는 걸 추천합니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;운 좋게 실력보다 높은 수준을 요구하는 자리에 합격했다 하더라도, 실제 회사생활 중에 받게 될 스트레스는 훨씬 더 고통스럽습니다. 지금은 취업이 더 급한 것 같지만, 내실을 다지는 것이 더 중요합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;3-1. Prerequisites (기본 요구사항)&lt;/h3&gt;
&lt;p&gt;A형 해설에서 이미 많은 부분을 짚어두었습니다.&lt;br /&gt;
B형에 추가적으로 요구될 만한 것들은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;라이브러리를 사용해봤을 것&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;여기서 라이브러리라 함은, STL이나 &lt;code&gt;java.util&lt;/code&gt; 같은 게 아닙니다. 다른 사람들이 만든 라이브러리를 써봤어야 합니다. 예를 들어 게임엔진처럼, 내가 main함수를 다 짜는 게 아니라 이미 있는 메인에 리소스를 스폰시키고 카메라를 이동시키고... 이런 모든 것들이 하나의 추상화된 단계를 거친달까요?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;협업 프로젝트를 해보았을 것&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다른 사람의 코드를 보고 이해할 수 있어야 합니다. 내가 생각한 로직으로 내가 구현하는 거에만 익숙한 사람은 B형에서 상당한 어려움을 겪을겁니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;... 이 외에는, 평범한 요구사항들입니다(알고리즘 기초지식 등).&lt;/p&gt;
&lt;h3&gt;3-2. 문제 형식 요약 및 간단 예시&lt;/h3&gt;
&lt;p&gt;B형은 주로 API를 만들거나 사용하는 방식을 따릅니다.&lt;br /&gt;
&lt;code&gt;UserCode.cpp&lt;/code&gt;(혹은 .java 혹은 .c인데, 본 글은 c++를 기준으로 작성됩니다.)와 &lt;code&gt;Main.cpp&lt;/code&gt;가 나뉘어져 있습니다.&lt;br /&gt;
&lt;code&gt;Main.cpp&lt;/code&gt;는 읽기전용이기 때문에 열람만 가능하고, 수험자가 수정할 수 없습니다. 이 코드에서는 테스트케이스를 별도 파일에서 읽어오고, 이를 이용하여 &lt;code&gt;UserCode.cpp&lt;/code&gt;의 함수들을 통한 결과값을 산출한 뒤 &lt;code&gt;expectedoutput.txt&lt;/code&gt;의 결과와 비교하고 수험자의 성적을 출력합니다. 완벽하게 모두 분석할 필요도, 시간도 없지만 구체적인 testcase만 별도 파일로 숨겨져있을 뿐 수험자의 성적 채점코드 자체가 모두 공개되어있는 것이기 때문에 문제풀이의 방향을 이 코드를 통해서 알 수 있습니다.&lt;br /&gt;
수험자는 &lt;code&gt;UserCode.cpp&lt;/code&gt;에 요구사항대로 함수들을 구현하여(혹은 &lt;code&gt;Main.cpp&lt;/code&gt;에 제공되어 수정할 수는 없지만 사용할 수는 있는 함수들을 사용하여) 최대 성적을 내는 것이 목표입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;예시 1 - Main API 사용) 연결리스트를 별도로 구현한 코드가 있다. newList()는 새 리스트를 동적할당으로 생성하여 반환하고, append()는 새 엘리먼트를 연결시키며...(생략)&lt;br /&gt;
이 코드를 활용하여 정렬 알고리즘을 구현하시오.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위와 같은 방식의 API사용은 대부분 익숙할테니 부연설명은 하지 않도록 하겠습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;예시 2 - Main에게 API 제공 초급) 테트리스 코드가 있다.&lt;br /&gt;
현재 보드상태는 10x30 배열 형태로 표현되며, 새로운 블록은 5가지 모양을 가지고 있다.&lt;br /&gt;
&lt;code&gt;vector&amp;lt; vector&amp;lt;int&amp;gt; &amp;gt; board&lt;/code&gt;에 0은 빈자리, 1은 채워진공간(이미 고정된 블록), 2는 현재 내려오고 있는 새블록을 뜻한다.&lt;br /&gt;
&lt;code&gt;mvRight()&lt;/code&gt;은 떨어지는 블록을 오른쪽으로,&lt;br /&gt;
&lt;code&gt;mvLeft()&lt;/code&gt;는 왼쪽으로 한칸 움직이며,&lt;br /&gt;
&lt;code&gt;rotate()&lt;/code&gt;는 블록을 시계방향으로 회전시키고,&lt;br /&gt;
&lt;code&gt;checkStatus()&lt;/code&gt;는 현재 보드의 상태를 보고 테트리스 규칙에 따라 삭제되어야 할 줄이 있으면 삭제시킨 뒤 중력에 맞게 위에 있는 블록들을 아래로 내려주는 일을 해야한다.&lt;br /&gt;
수험자는 &lt;code&gt;mvRight()&lt;/code&gt;, &lt;code&gt;mvLeft()&lt;/code&gt;, &lt;code&gt;rotate()&lt;/code&gt;, &lt;code&gt;checkStatus()&lt;/code&gt;를 구현하면 된다.&lt;br /&gt;
메인 프로그램은 수험자가 작성한 함수들을 호출하게 되며, 이를 활용한 결과가 정확하면 점수를 얻을 수 있고, 틀리면 감점된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예시 3 - Main에게 API 제공 고급) 테트리스 코드가 있다.&lt;br /&gt;
&lt;code&gt;getBoard()&lt;/code&gt;는 호출시 현재 보드상태를 10x30 배열 형태로 반환한다.&lt;br /&gt;
&lt;code&gt;tick()&lt;/code&gt;은 내부 로직으로, 시간을 1초 가게 한다. 이 때 위에서 떨어지는 블록은 중력에 따라 한칸 아래로 내려오게 되며, 내려온 뒤 테트리스 규칙에 따라 삭제되어야 할 줄이 있으면 바로 삭제시키고 보드 상태에 반영한다.&lt;br /&gt;
&lt;code&gt;mvRight()&lt;/code&gt;은 떨어지는 블록을 오른쪽으로,&lt;br /&gt;
&lt;code&gt;mvLeft()&lt;/code&gt;는 왼쪽으로 한칸 움직이며,&lt;br /&gt;
&lt;code&gt;rotate()&lt;/code&gt;는 블록을 시계방향으로 회전시킨다.&lt;br /&gt;
이것들 중 외부에서(수험자가) 부를 수 있도록 extern 처리된 함수는 &lt;code&gt;mvRight()&lt;/code&gt;, &lt;code&gt;mvLeft()&lt;/code&gt;, &lt;code&gt;rotate()&lt;/code&gt;이다.&lt;br /&gt;
수험자는 단 하나의 함수를 구현하면 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;void nextCommand(vector&amp;lt; vector&amp;lt;int&amp;gt; &amp;gt; board) {
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;메인 로직(수험자가 수정할 수 없고, 열람만 가능)의 구현체 요약은 다음과 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;for(..생략..){
  nextCommand(getBoard());
  tick();
}
int score = compareWithExpectedResult();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;주의점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;새로운 블록이 소환되었을 때(항상 중앙에서 시작), 바로 아래에 채워진 자리가 있다면 게임이 즉시 종료된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;블록을 &lt;code&gt;rotate()&lt;/code&gt;할 수 없는데 &lt;code&gt;nextCommand()&lt;/code&gt;에서 이를 호출할 경우 역시 게임이 즉시 종료된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nextCommand()에서는 한번에 단 하나의 함수밖에 호출할 수 없다. 즉, &lt;code&gt;tick();&lt;/code&gt;이 실행될 때 &lt;code&gt;int time&lt;/code&gt;을 1 증가시키는데, 동일한 &lt;code&gt;time&lt;/code&gt;값일 때 &lt;code&gt;mvRight()&lt;/code&gt;, &lt;code&gt;mvLeft()&lt;/code&gt;, &lt;code&gt;rotate()&lt;/code&gt;이 모두 합쳐서 1회 초과하여 호출될 경우 이 역시 게임이 종료된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;테트리스 점수는 한 줄이 삭제될 때 +1점이 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;게임이 종료된 후 점수가 높을수록 좋다(당연히...).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;테트리스의 점수가 최대가 되도록 &lt;code&gt;nextCommand()&lt;/code&gt;를 구현하시오.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3-3. 문제풀이 예시&lt;/h3&gt;
&lt;h4&gt;문제 설명&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;개발자 관리 시뮬레이터&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개요:&lt;br /&gt;
FourStarsCompany에는 N명의 개발자들이 일을 하고 있다. 이 개발자들은 능력이 동일하여, 어떤 일을 하든 동일한 효율을 낸다.&lt;br /&gt;
하지만 이 회사에는 Git과 같은 소스제어/협업툴이 존재하지 않아서, 압축파일로 매번 작업물을 공유해야 한다. 따라서 동시에 두 개발자 이상이 동일한 프로젝트를 맡는 것은 불가능하다.&lt;br /&gt;
그러나 하루는 한 개발자가 일하고 다음 날은 다른 개발자에게 프로젝트를 물려주는 것은 가능하며, 이 때 인수인계 시간 등은 0이고 효율 또한 변동되지 않는다.&lt;br /&gt;
각 프로젝트는 끝내기 위해 필요한 &lt;code&gt;workload&lt;/code&gt;값이 있으며, 하루 개발자가 일했을 때 1 증가한다. 그리고 각 프로젝트에는 &lt;code&gt;deadline&lt;/code&gt;이 존재한다. 이 값은 이 프로젝트가 주어진 날로부터(!= 개발자가 배정된 날) ${deadline}일수만큼 시간이 주어진다는 뜻이며, 데드라인을 넘으면 어떠한 보상도 받지 못한다.&lt;br /&gt;
각 프로젝트는 끝냈을 때 받는 &lt;code&gt;payment&lt;/code&gt;가 있다. 이는 회사 매출에 합산된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;목표:&lt;br /&gt;
프로젝트 성과를 가능한 최대로 만들어라. 해당 test case의 이론적 최대치에 가까울수록 점수를 높게 받을 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;문제상세:&lt;br /&gt;
이 회사는 T일의 시간동안 영업한다. T일 이후에는 즉시 모든 업무를 중단한다.&lt;br /&gt;
수험자가 사용할 수 없는 메인 함수들은 다음과 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;void tick(); //currentTime을 하루 가게 한다. 또한, 이 함수에선 getNewProject(), nextCommand() 등을 호출한다.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 &lt;code&gt;tick()&lt;/code&gt; 함수는 중요하므로 의사코드로 아래에 부연설명을 진행한다.&lt;br /&gt;
(실제 시험에서는 당연히 온전한 코드로 존재합니다. 제가 실제코드 짜기 귀찮아서 의사코드로 제공합니다.)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def tick():
  global currentTime
  global pID

  currentTime += 1
  for item in [i for i in newProjectList if i.time == time]:
    getNewProject(pId, item.payment, item.workload, item.deadline)
    pID += 1
  
  nextCommand(time)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;수험자가 사용할 수 있는 메인 함수들은 다음과 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;void allocProject(int pID, int wID); //wID 개발자에게 pID 프로젝트를 배정한다.
void finishProject(int pID); //프로젝트를 종료시키고, payment가 매출에 합산된다.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;수험자가 제공해야 하는 함수들은 다음과 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;void init(int N, int T); //각 테스트케이스 시작 전에 N과 T 전달. 수험자가 만든 전역변수 등이 있으면 이를 알아서 초기화해줘야 오답 방지 가능.
void getNewProject(int pID, int payment, int workload, int deadline);
void nextCommand(int currentTime); //여기에서 allocProject(), finishProject() 함수들을 이용하여 최적의 의사결정을 한다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;수험자는 위 3개 함수를 구현하여 회사의 매출을 최대로 올려야 한다.&lt;br /&gt;
&lt;strong&gt;주의점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;만약 프로젝트가 요구로 하는 인시(workload)를 채우지 못했거나, 제한시간(deadline)을 넘었거나, 요구시간보다 많이 투입된 상태에서 &lt;code&gt;finishProject()&lt;/code&gt;가 호출될 경우 수험자는 0점처리된다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stopProject()&lt;/code&gt;라는 함수는 없고, 당연히 구현할 수도 없다(지정된 사용자함수만 Main에서 호출해가기 때문에, 구현해도 사용할 수가 없다.). Main함수의 모든 변수들은 접근불가능하고, 접근할 수 있도록 열어준 것은 &lt;code&gt;allocProject()&lt;/code&gt;와 &lt;code&gt;finishProject()&lt;/code&gt; 함수 두개 뿐이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;allocProject()&lt;/code&gt;를 동일한 프로젝트ID(pID)에 대해 다른 개발자ID(wID)에게 배정하면, 기존 개발자는 해당 프로젝트에서 제외되고 해당 신규 개발자에게 배정된다.&lt;br /&gt;
달리 말하면, 1이라는 프로젝트를 1이라는 개발자가 하고 있었을 때, &lt;code&gt;allocProject(1, 2)&lt;/code&gt;를 호출시 1프로젝트는 2개발자가 맡게 되며, 1개발자는 아무 프로젝트에도 배정받지 않은 상태가 된다.&lt;br /&gt;&lt;br /&gt;
또한, 이후 &lt;code&gt;allocProject(2, 2)&lt;/code&gt;를 호출시 2개발자는 2프로젝트를 맡게 되고, 1프로젝트 연계는 해제된다. 따라서 1프로젝트는 아무도 하고 있지 않게 된다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;해설&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;참고: 일단은 정보가 급한 분들이 계실 것 같아서, 문제를 완전히 만들지는 않은 상태에서 얼개만 짜놓고 바로 포스팅하게 되었습니다. 나중에 모든 채점코드(Main)와 모범답안(UserCode)을 만들게 된다면 구체적인 풀이코드를 포스팅하겠습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;처음 저런 형태의 문제를 접하면, 기존의 &quot;input.txt만 제공할테니 알아서 이거 입력 받고, 우리가 원하는 출력만 해줘. 그럼 점수 줄게&quot; 같은 형식에만 익숙했던 분들은 충공깽 상태에 빠집니다. 대체 뭘 짜라는지도 모르겠고, 어떻게 접근해야 할지도 당황스럽죠.&lt;br /&gt;
하지만 알고보면 단순한 문제입니다.&lt;br /&gt;&lt;br /&gt;
일단, &lt;code&gt;Main::allocProject()&lt;/code&gt;와 &lt;code&gt;Main::finishProject()&lt;/code&gt;을 사용하는 것 이외에 우리가 메인 코드에 영향을 줄 수 있는건 없습니다. 따라서, 메인 코드에 시뮬레이션되어있는 문제 현황을 우리 또한 동일하게 파악하고 있을 수 있으려면, &lt;strong&gt;우리가 별도로 시뮬레이션 환경을 똑같이 만들어줘야 합니다&lt;/strong&gt;.&lt;br /&gt;
즉, 메인 함수에도 당연히 현재 프로그래머들이 어디 프로젝트에 배치되었는지, 각각 진행상황은 어떻고 매출은 어떤지 등등을 산정하고 있을텐데요...&lt;br /&gt;
이걸 우리가 접근해서 확인할 방법은 없으니 우리가 똑같이 구현해줘야 합니다. 다행스럽게도 &lt;code&gt;UserCode::nextCommand()&lt;/code&gt;는 &lt;code&gt;Main::tick()&lt;/code&gt;함수를 보면 알 수 있듯이 각 유니크한 currentTime에 단 한번만 불립니다.&lt;br /&gt;&lt;br /&gt;
즉, &lt;code&gt;UserCode::getNewProject()&lt;/code&gt;가 틱함수에서 불릴 때 우린 새로운 프로젝트들에 대한 정보를 받아올 수 있고, 이걸 &lt;code&gt;UserCode.cpp&lt;/code&gt;파일에 만들어놓은 전역변수 배열에 저장해둬야 하며, currentTime 또한 처음에 0으로 셋팅한 뒤 &lt;code&gt;UserCode::nextCommand()&lt;/code&gt;가 불릴 때 직접 1씩 더해줘야 합니다. 알다시피 &lt;code&gt;Main::getCurrentTime()&lt;/code&gt;이란 함수가 제공되지 않았기 때문에 &lt;code&gt;Main::currentTime&lt;/code&gt; 변수의 접근이 불가하기 때문이죠.&lt;br /&gt;&lt;br /&gt;
우리가 해야 하는 걸 정리하면...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;init()&lt;/code&gt;이 불릴 때, 전역변수로 만들어놓은 &lt;code&gt;현재시간&lt;/code&gt;, &lt;code&gt;프로젝트 리스트&lt;/code&gt;, &lt;code&gt;개발자-프로젝트 배정 현황&lt;/code&gt; 정보 등 모든 것들을 초기화해줍니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getNewProject()&lt;/code&gt;가 불릴 때 현재 할 수 있는 프로젝트 리스트에 workload와 payment 정보를 추가합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nextCommand()&lt;/code&gt;가 실행될 때, 현재 시간과 프로젝트들의 가치를 고려하여 최적으로 인력을 배정합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;여기에서 &lt;code&gt;nextCommand()&lt;/code&gt;가 제일 중요해보이죠? 맞습니다. 여기에 모든 코어 로직이 들어가야 하죠. &lt;code&gt;Main.cpp&lt;/code&gt;에서는 매 &lt;code&gt;tick&lt;/code&gt;마다 이 함수를 불러주는게 끝입니다. 그리곤 &lt;code&gt;UserCode.cpp&lt;/code&gt;에서 알아서 필요한 &lt;code&gt;Main::functions&lt;/code&gt;를 불렀을거라고 가정하고 바로 다음 날로 넘어가고, 영업일이 끝나면 종료한뒤 성적을 계산합니다. 따라서 우린 매번 &lt;code&gt;nextCommand&lt;/code&gt;가 불릴 때, 적합한 의사결정을 해줘야 합니다.&lt;br /&gt;
여기서 어떤 로직을 쓰면 될까요? 조금 생각해보면 답이 나오는데요...&lt;br /&gt;
생각할 시간을 드리겠습니다. 답을 보려면 내려주세요.&lt;br /&gt;
.&lt;br /&gt;
.&lt;br /&gt;
.&lt;br /&gt;
.&lt;br /&gt;
.&lt;br /&gt;
.&lt;br /&gt;
.&lt;br /&gt;
.&lt;br /&gt;
.&lt;br /&gt;
.&lt;br /&gt;
.&lt;br /&gt;
.&lt;br /&gt;
.&lt;br /&gt;
.&lt;br /&gt;
.&lt;br /&gt;
.&lt;br /&gt;
.&lt;br /&gt;
.&lt;br /&gt;
각 프로젝트는 다른 payment를 제공하죠. 하지만 무조건 높다고 좋은건 아닙니다. 100일이 걸리고 10원을 주는 프로젝트와 10일이 걸리고 9원을 주는 프로젝트중엔 당연히 후자가 좋겠지요.&lt;br /&gt;
따라서 &lt;code&gt;payment/workload&lt;/code&gt;이 우선순위값이라고 생각해볼 수 있습니다.&lt;/p&gt;&lt;p&gt;하지만 이렇게 되면 문제가 생기는데요... 개발자 한명만 있는 회사를 생각해봅시다.&lt;/p&gt;&lt;p&gt;0일차에 10일 걸리고 50원 주는 &lt;code&gt;프로젝트1&lt;/code&gt;을 받아서, &lt;code&gt;개발자1&lt;/code&gt;을 배치시켰습니다.&lt;br /&gt;
그리고 5일동안 아무일이없었는데(==계속 배정된대로 일을 진행),&lt;br /&gt;
5일차에 6일 걸리고 50일 걸리는 &lt;code&gt;프로젝트2&lt;/code&gt;가 생겼습니다.&lt;/p&gt;&lt;p&gt;그럼 이 때 우린 &lt;code&gt;프로젝트2&lt;/code&gt;로 재배치해야 할까요? &lt;code&gt;프로젝트1&lt;/code&gt;은 &lt;code&gt;50/10 == 5&lt;/code&gt;의 우선순위고, &lt;code&gt;프로젝트2&lt;/code&gt;는 &lt;code&gt;50/6 == 8.333&lt;/code&gt;의 우선순위인데 말이죠.&lt;br /&gt;
그런데 잘 생각해보면 &lt;code&gt;프로젝트1&lt;/code&gt;은 앞으로 5일만 하면 50원을 받는데, &lt;code&gt;프로젝트2&lt;/code&gt;는 6일을 해야 50원을 받습니다.&lt;br /&gt;
즉, 우리 공식에 조정이 필요하겠군요. &lt;code&gt;payment/(workload - currentInvestedTime)&lt;/code&gt;으로 바꿔서, 실제로 보상을 수령하기까지 추가로 투입해야 되는 시간을 payment에서 나눠야 매몰비용을 제거할 수 있을 것입니다. 그리고 당연하지만, 이미 더 투입해야 하는시간(&lt;code&gt;workload - currentInvestedTime&lt;/code&gt;)이 데드라인까지 남은시간(&lt;code&gt;currentTime - deadline&lt;/code&gt;)보다 클 경우 프로젝트를 마칠 수 없는게 당연하니까 우선순위를 0으로 설정해주는 로직이 있어야겠습니다.&lt;/p&gt;&lt;p&gt;그리고 우선순위를 알았으니, 우선순위로 내림차순 정렬한 뒤 N명의 개발자가 있으니 N명에게 상위 N개 프로젝트를 배분하면 됩니다(다행히도 모든 개발자는 동일한 1workload/day의 효율을 가지니까 고민할 게 없습니다).&lt;/p&gt;&lt;p&gt;자, 이거면 문제 끝입니다. 구현만 조심히 잘 하면 되겠네요.&lt;/p&gt;&lt;p&gt;하지만 함정이 두가지 있습니다.&lt;br /&gt;
첫번째, 우선순위 순으로 프로젝트를 정렬해야 하는데 이걸 어떻게 정렬할 수 있을까요? 우선순위큐를 쓰면 편하겠지만, 위에서 말했다시피 STL 모두 쓸 수 없습니다(&lt;strong&gt;아.. 써놓고 보니 저도 실수한 부분이 있는데요, &lt;code&gt;std::vector&lt;/code&gt; 또한 사용 불가능합니다. 인자로 전달될 때도 배열로 와요. 위에 &lt;code&gt;vector&amp;lt;int&amp;gt;&lt;/code&gt; 등 써둔건 이해만 그렇게 하시고, 실제 시험에선 &lt;code&gt;int[]&lt;/code&gt;라고 생각하면 되겠습니다...&lt;/strong&gt;).&lt;br /&gt;
priority_queue를 쓸 수 없으니, 결국 정렬을 구현해야 합니다. 이 때 버블소트같은 거 쓰면, 문제 없을거같지만 이건 매우 엄격한 상대평가라서 시간 때문에 탈락합니다. 퀵소트는 바로 그 자리에서 구현해서 쓸 수 있어야 합니다.&lt;br /&gt;
두번째, 개발자들을 적절하게 배치해야 하는데, 매일매일 하루가 지날 때마다 프로젝트 우선순위 리스트가 바뀔텐데요, 이 때 이미 배정된 개발자가 있을때 이걸 처음부터 죄다 재배치할 수는 없습니다(그렇게 되면 실행시간이 무지막지하게 길어져서 탈락하게 됩니다). 따라서 이미 배정된 적이 있는 pID와 그에 상응하는 wID, 그리고 배정되지 않은 pID와 wID를 계속 트래킹할 수 있어야 하며, 다음 날 currentTime이 +1되어서 우선순위 리스트들이 갱신되었을 때 우선순위에서 밀려서 dealloc될 프로젝트를 파악하고 그 프로젝트를 맡고있는 wID의 개발자를, 어제까진 배정되지 않았지만 오늘부터 우선순위(상위 N where N is number of developers) 안에 들게 된 pID의 프로젝트에 배정(&lt;code&gt;allocProject()&lt;/code&gt;)해야 할 것입니다. 이 모든걸 구현하려면 역시 해시맵이나 스택, 큐 등 본인 구현방법에 필요한 자료구조들을 손수 만들어 써야 합니다.&lt;br /&gt;
이 모든걸 4시간 안에 해야 하는 것이죠.&lt;/p&gt;&lt;p&gt;깔끔하게 글을 쓰고 싶었는데 주저리주저리하다보니 길어지고 난잡해졌네요. B형에 대한 글들은 인터넷에 눈을 씻고 찾아봐도 없던데, 아마 다들 S사에서 열심히 일하느라 무서워서(?) 글을 못 쓰나 봅니다.&lt;br /&gt;
전 이제 다른 회사에서 일하고 있으니 무서울게 없...어서요 하..하하(농담)&lt;/p&gt;&lt;p&gt;어쨌든, 이 문제 설명대로 문제를 풀어보시기에는 어려움이 있을 겁니다. 채점코드도 없고 메인코드도 없는 상황에서 함수만 짜면 확인이 안되니까요.&lt;br /&gt;
대신, 시간이 좀 되신다면 직접 채점코드 Main 구조부터 수험자가 짜야 할 &lt;code&gt;UserCode.cpp&lt;/code&gt;까지 직접 모두 만들어보시는걸 추천합니다. 그렇게 하고 나면 많은 걸 배운 자신을 돌아볼 수 있지 않을까 싶습니다.&lt;/p&gt;&lt;p&gt;덧. 오늘 이 글을 쓰고 swacademy 한번 들어가보니 이제 아예 샘플 문제를 제공하네요 -_-;; 괜한 고생을 해서 글을 썼나 싶긴 합니다만, 도움이 되었으면 좋겠네요. 아직 블로그 글 제대로 쓰고있지는 않아서 상관은 없는데,&amp;nbsp;도움됐으면 ♥공감&amp;nbsp;눌러주고 가세요~&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>2017 삼성전자</category>
<author>mark3236</author>
<guid>https://mark3236.tistory.com/49</guid>
<comments>https://mark3236.tistory.com/entry/%EC%82%BC%EC%84%B1%EC%A0%84%EC%9E%90-SW-%ED%85%8C%EC%8A%A4%ED%8A%B8-B%ED%98%95-%EA%B0%80%EC%9D%B4%EB%93%9C#entry49comment</comments>
<pubDate>Mon, 14 May 2018 20:47:45 +0900</pubDate>
</item>
<item>
<title>삼성전자 SW 테스트 A형 (공채전형 1차시험) 가이드</title>
<link>https://mark3236.tistory.com/entry/%EC%82%BC%EC%84%B1%EC%A0%84%EC%9E%90-SW-%ED%85%8C%EC%8A%A4%ED%8A%B8-A%ED%98%95-%EA%B3%B5%EC%B1%84%EC%A0%84%ED%98%95-1%EC%B0%A8%EC%8B%9C%ED%97%98-%EA%B0%80%EC%9D%B4%EB%93%9C</link>
<description>&lt;h2&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;Disclaimer&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;채용 진행과정에서 작성한 기밀유지서약서가 있기 때문에 채용 프로세스 및 정보(SW테스트 제약사항, 기출문제 등)는 이미 인터넷에 공개적으로 알려진 사항에 대해서만 정리하여 작성한 것이며, 기밀유지 하기로 한 부분에 대해서 위배한 사항은 없습니다.&lt;br /&gt;
SW Test에 대한 안내사항은 &lt;a href=&quot;https://www.codeground.org&quot;&gt;Codeground 공식 사이트&lt;/a&gt;에 안내된 부분을 다시 정리한 것일 뿐이며, 기출문제는 유출하지 않습니다.&lt;br /&gt;
타 사이트(백준저지 등)에 올라온 문제를 기반으로 저의 해설을 추가했을 뿐, 참가했던 SW테스트와는 무관합니다.&lt;/p&gt;&lt;p&gt;그래도 만약 문제가 되는 부분이 있을 경우 통보해주시면 해당 내용은 삭제조치하도록 하겠습니다.&lt;/p&gt;&lt;p&gt;또한, 본 가이드는 알고리즘 학습에 도움을 주기 위함일 뿐이며, 미래 정확성은 책임지지 않습니다.&lt;br /&gt;
본 가이드 내 정보를 참고한 모든 결과에 대한 책임은 독자에게 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2&gt;1. 개요&lt;/h2&gt;
&lt;p&gt;삼성전자에서는 2016년쯤부터 S직군(소프트웨어) 신입사원 및 인턴사원 공채 전형에서 SW 테스트를 실시하고 있습니다.
서류전형 -&amp;gt; SW테스트 (GSAT/SSAT 면제) -&amp;gt; 최종면접(인성, 직무, 창의)으로 진행됩니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;이 때 보는 SW테스트가 바로 SW Test A형입니다.&lt;/strong&gt;&lt;br /&gt;
기존에는 사내 직원들에게만 실시하던 테스트를 삼성전자가 얼마 전 코드그라운드를 통해 일반 대학생/졸업생에게 오픈하였습니다.&lt;br /&gt;
링크 : &lt;a href=&quot;https://www.codeground.org/sst/common/userTestList&quot;&gt;https://www.codeground.org/sst/common/userTestList&lt;/a&gt; (링크는 로그인했을 때 접근 가능합니다. 로그인시에만 메인페이지 상단에 SW TEST 탭이 새로 생성됩니다.)&lt;/p&gt;&lt;p&gt;&amp;lt;Edit : 이제는 접수 페이지가 바뀌어서&amp;nbsp;&lt;a href=&quot;https://www.swexpertacademy.com/main/main.do&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;https://www.swexpertacademy.com/main/main.do&lt;/a&gt; 사이트에서 신청받는다고 합니다.&amp;gt;&lt;/p&gt;&lt;p&gt;A, B, C형은 각각 스타일 및 난이도가 매우 다르므로 가이드 또한 각각에 대해 파트를 나누어 쓰도록 하겠습니다(C형은 거의 알려진 바가 없으므로 생략합니다).&lt;br /&gt;
일단 취업에 필요한 건 A형 딱 하나이므로 A형을 먼저 보도록 하죠.&lt;br /&gt;
참고로 B/C형은 취득시 인사평가/배치시 우대사항이 있는 것으로 공지되어 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2&gt;2. A형 대비방법&lt;/h2&gt;
&lt;p&gt;먼저, 삼성에서 공개적으로 밝힌 안내사항입니다.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:605px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/990C503D5A3D2B5707&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Screen Shot 2017-12-22 at 2.42.41 PM.png&quot; height=&quot;368&quot; width=&quot;605&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
위와 같이 &lt;strong&gt;A형은 3시간이 주어지며 두 문제를 풀어야 합니다. 언어는 C/C++/JAVA이며 라이브러리 제한은 없습니다.&lt;/strong&gt; C++ STL 사용 가능하고, C++ 11 및 14까지도 지원됩니다. auto, 람다 등 모두 사용 가능합니다. 다만 문제 수준이 11/14를 요구할만한 난이도가 아닙니다. 어차피 간단한 알고리즘 문제에서 C++ 11 이상의 신규기능을 써야 할 일이 많이 없습니다.&lt;/p&gt;&lt;p&gt;A형은 보통 기본적인 알고리즘으로 풀 수 있는 경우가 많습니다. 각종 Sorting 알고리즘이나 자료구조(linked list, queue, stack, heap...) 등을 손수 구현해야 하는 문제도 나오지 않는 편이며, 어차피 라이브러리가 사용 가능하므로 std::priority_queue 쓰면 그만입니다.&lt;br /&gt;
개인적으로 여러번 시험을 보고 모두 통과했지만, 대기업 알고리즘 시험에서 algorithm과 std::vector 말고 필요한 건 없었습니다.&lt;br /&gt;
(예외 : 카카오 17년도 블라인드 공채의 경우 1차 코딩은 algorithm/vector만 필요했으나 2차 코딩은 REST API 사용을 위한 웹 request 라이브러리 및 json parser가 필요했고, 3차 오프라인 코딩은 python의 list comprehension 및 string manipulation이 매우 유용했습니다. 3차 오프라인 코딩의 경우 C++의 string 라이브러리로는 시간 내 구현이 불가능하다고 느꼈습니다.)&lt;/p&gt;&lt;p&gt;대비를 위해서는 일단 다음의 순서를 추천합니다. 시간이 없으면 윗부분부터 차례대로 포기하세요.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;만들고 싶은 거 아무거나 생각해서, 과제가 아니라 진짜 하고 싶어서 만드는 거 해보기(과제 삽질은 기억에 잘 안 남아요. 본인이 능동적으로 만드는 프로젝트 삽질이 기억에 남지..). Python이나 웹(html/javascript)으로 하는 걸 추천합니다.&lt;/li&gt;
&lt;li&gt;알고리즘 책 하나 골라서 자료구조/알고리즘 제대로 한번 보기&lt;/li&gt;
&lt;li&gt;깔끔하고 정상적인 문제들 &lt;a href=&quot;https://algospot.com/&quot;&gt;알고스팟&lt;/a&gt;이나 &lt;a href=&quot;https://www.acmicpc.net/&quot;&gt;백준저지&lt;/a&gt;같은 사이트에서 풀어보기 (테스트케이스, 문제구조 등이 함정 없이 깔끔합니다)&lt;/li&gt;
&lt;li&gt;공식 삼전 연습사이트 https://www.codeground.org/ 가셔서 악랄한 문제 체험해보기&lt;/li&gt;
&lt;li&gt;&quot;기출문제&quot;(&lt;a href=&quot;https://algospot.com/&quot;&gt;예시링크&lt;/a&gt;) 구해서 풀어보기 (본 링크는 해당 사이트 운영자가 임의로 소문에 유사하게 재구성한 문제이며, 유출된 기출문제가 아닙니다.)&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;h2&gt;3. 문제풀이 예시&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;주의 : 만약 아주 기초적인 코딩도 모르는 상태에서 싸트 공부하듯 벼락치기하려는 의도라면, 다른 직군을 알아보거나 기본기를 닦은 다음 도전하는 것을 권해드립니다.&lt;br /&gt;
본 글은 기초 소양이 있지만 알고리즘 시험에 익숙하지 않거나 삼전 알고리즘 시험 특유의 어려운 포인트를 확인하고 싶은 분들을 대상으로 작성되었습니다.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;3-1. Prerequisites (기본 요구사항)&lt;/h3&gt;
&lt;p&gt;SW테스트 해설을 읽기에 앞서, 다음 문제들을 보고 답을 바로 생각해낼 수 있는지, 혹은 C/파이썬/자바 등 본인이 가장 편한 언어로 20~30분 안에 구현할 수 있을지 생각해보세요.&lt;br /&gt;
그렇지 않다면 자료구조 등 전공과목 복습 및 &lt;a href=&quot;https://www.acmicpc.net/step&quot;&gt;백준 단계별 학습&lt;/a&gt;에서 16단계까지는 적어도 단계별 한문제씩 완료하고 오는 것을 추천드립니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;본인이 사용하는 언어에서, 함수에 정수형 변수를 pass by value가 아닌 pass by reference의 방식으로 전달하여 실제 값을 조작할 수 있는 방법을 말해보세요.&lt;/li&gt;
&lt;li&gt;삽입정렬의 시간 복잡도는 어떻게 되나요?&lt;/li&gt;
&lt;li&gt;1억번의 비교적 단순한 연산을 해야 하는 알고리즘을 재귀함수로 구현했을 때 어떻게 될까요? for문으로 구현했을 때는 어떻게 될까요? (프로그램이 정상 동작할까요? 몇초나 걸릴까요?)&lt;/li&gt;
&lt;li&gt;100x100(nxn) 오목판에 현재 돌 배치가 주어졌을 때, O(n^2) 수준으로 승리조건을 어떻게 확인할까요?&lt;/li&gt;
&lt;li&gt;정수 N을 받습니다. 해당 숫자가 3으로는 나눠 떨어지나 5로는 떨어지지 않으면 &quot;Fizz&quot;, 반대로 5로 나눠지고 3이 안 떨어지면 &quot;Buzz&quot;, 3과 5 둘 모두로 나눠 떨어지면 &quot;Fizz Buzz&quot;를 출력하세요.&lt;/li&gt;
&lt;li&gt;정수 N을 받습니다. 해당 숫자가 소수인지 아닌지 O(N^(1/2)) 혹은 그 이하로 확인하세요.&lt;br /&gt;
*답은 아래에 있습니다.&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;h3&gt;3-2. &lt;a href=&quot;https://www.acmicpc.net/problem/14891&quot;&gt;톱니바퀴 문제&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;문제 조건은 링크(&lt;a href=&quot;https://www.acmicpc.net/problem/14891&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;https://www.acmicpc.net/problem/14891&lt;/a&gt;) 참조바랍니다.&lt;br /&gt;
일단, 톱니바퀴 개수는 4개 / 톱니 개수는 8개로 고정되어 있으니 main함수 작성은 쉽습니다. 쿨하게 배열을 만들어버립시다.&lt;br /&gt;
다만... 인풋이 좀 당황스럽죠? 10101111과 같은 식으로 들어오는데, 타 언어에 비해 C/C++에서는 이걸 변환하는게 약간 골치가 아픕니다.&lt;br /&gt;atoi나 stringstream을 쓰면 되기는 합니다만, 저는 개인적으로 정신없는 알고리즘 시험장에서는 가능하면 디버깅할 확률이 적은 방법을 선호합니다. (특히 문자열 관련해서는 주소/값 전달 때문에 골치아파질 일이 가끔 있습니다. cstring형을 받아서 주소를 줘야 하는데 내가 주고 싶은 건 3번째 인덱스 문자 하나라서 에러가 터진다든가 등...) 아스키코드 값 이용해서 그냥 char를 int로 바꿔버린다음 offset을 더하거나 빼는 방법도 있습니다만, 이 역시 정신없는 시험장에서는 코드값 다시 확인해야 하는 등 별로 좋지 않을 수 있습니다.&lt;br /&gt;
그래서 &lt;strong&gt;이 문제에서 전 string으로 다 받아버릴 겁니다.&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;vector&amp;lt;string&amp;gt; gears(COUNT);
for (auto it = gears.begin(); it != gears.end(); ++it) {
    cin &amp;gt;&amp;gt; (*it);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그리고, K 회전 수를 받은 뒤 K번 입력이 주어진다고 하므로 입력을 받아줍니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;int K;
cin &amp;gt;&amp;gt; K;
for (int i = 0; i &amp;lt; K; ++i) {
    // ...?
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;잠깐, 여기서 멈추고 생각을 해봅시다. K번 입력이 주어지는데, 돌릴 톱니바퀴와 돌릴 방향이 띄어쓰기가 된 두 정수로 들어옵니다. 그러면 이걸 어떻게 저장하는게 좋을까요?&lt;br /&gt;
아래처럼 두 배열을 만들어서 저장하나요?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;vector&amp;lt;int&amp;gt; sel(K);
vector&amp;lt;int&amp;gt; dir(K);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;아니면, &quot;깔끔하게&quot; class나 struct를 만들어서 저장하나요?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;Class Command {
    public:
        int sel;
        int dir;
};
//main
vector&amp;lt;Command&amp;gt; commands(K, Command());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;제 의견이지만, 모두 오답입니다. 알고리즘 시험 때는 시간이 생명이고, 이런 건 모두 시간 낭비일 뿐입니다.&lt;br /&gt;
문제를 잘 읽어보면 해당 명령을 수행만 하면 될 뿐 반드시 입력이 끝난다음에 실행할 필요가 전혀 없습니다.&lt;br /&gt;
그러므로 그냥 K번 입력받는 루프 안에서 그대로 시뮬레이션 함수 돌리면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;int K;
cin &amp;gt;&amp;gt; K;
for (int i = 0; i &amp;lt; K; ++i) {
    int sel, dir;
    cin &amp;gt;&amp;gt; sel &amp;gt;&amp;gt; dir;
    Simulate(args);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런데 아직 하나 주의할 점이 있습니다. 톱니 선택이 1부터 4로 주어집니다. 즉, 그대로 함수에 넘겨버리면 index out of range가 뜨게 됩니다. 악랄한 입력값을 정화시켜줍시다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;int K;
cin &amp;gt;&amp;gt; K;
for (int i = 0; i &amp;lt; K; ++i) {
    int sel, dir;
    cin &amp;gt;&amp;gt; sel &amp;gt;&amp;gt; dir;
    --sel;  // sel이 1부터 시작하므로 0부터 시작하게 normalize
    Simulate(args);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;자, 그럼 이제 입력 처리는 모두 끝났습니다. 본 게임을 시작해봅시다.&lt;/p&gt;&lt;p&gt;톱니바퀴가 돌아가야 한다는데, 이걸 어떻게 해야 할까요? 알고리즘 문제 삽질을 좀 해보면서 야매스킬이 생긴 분들은 바로 생각나는게 있겠지만, 정석대로 전공과목만 착실하게 하신 분들은 어쩌면 이렇게 생각할지도 모릅니다 :&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&quot; 아, 이거 자료구조/알고리즘 수업 때 배웠어! 환형 링크드 리스트로 구현해야 돼! &quot;&lt;/strong&gt;&lt;br /&gt;
네..... 당연히, 그렇게 만들면 한 문제 풀고 3시간 다 끝납니다.&lt;/p&gt;&lt;p&gt;어차피 우리가 알고싶은 건 상대적인 변화일 뿐입니다.&lt;br /&gt;
그렇다면, &lt;strong&gt;'top' 배열을 만들어서 그냥 {0,0,0,0}으로 초기화해놓고 첫째 톱니바퀴가 시계방향으로 움직이면 7로 바꾸고, 반시계방향으로 움직이면 1로 바꾸면 되겠지요?&lt;/strong&gt; 결국 프로그래머인 우리가 저 top의 의미만 인지하고 있으면 톱니간 상호작용 때도 적절히 offset 줘서 계산하고, 나중에 총 점수 계산할 때도 gears[top]만 확인해서 계산하면 됩니다.&lt;br /&gt;
0일 때 시계방향이면 -1이 아니라 7로 해주고 7일때 시계방향이면 8이 아니라 0으로 해주는 걸 하드코딩해놓을 순 없으니 %(modular) 연산을 쓰도록 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;int Turn(int current, int dir) {
    return ((current + dir) + 8) % 8; // dir를 더한다음 8을 더하고(음수 방지) mod 8을 해주면(8 overflow 방지) 0부터 7까지의 깔끔한 값으로 변함 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;그런데 잠깐 또 스톱!&lt;/strong&gt;&lt;br /&gt;
여기 어김없이 골때리는 함정이 있습니다. 문제 조건을 잘 읽어봅시다.&lt;br /&gt;
시계방향일 때 +1이고 반시계방향일 때 -1이랍니다. 하... 대체 왜......&lt;br /&gt;
그쵸. Turn 함수를 저렇게 만들면 거꾸로 돌려버립니다. 시계 방향일 땐 -1을 해줘야 하는데 말이죠.&lt;br /&gt;
바꿔줍시다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;int Turn(int current, int dir) {
    return ((current - dir) + 8) % 8; // dir를 더한다음 8을 더하고(음수 방지) mod 8을 해주면(8 overflow 방지) 0부터 7까지의 깔끔한 값으로 변함 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;돌리는 로직도 만들어놨으니, 이제 Simulate() 함수만 만들어서 돌리게 만들면 끝나겠군요.&lt;br /&gt;
Simulate()에서는 먼저 돌릴 바퀴와 방향을 받아서 Turn()을 호출하여 top을 수정해주고, 옆에 있는 바퀴들을 돌릴 수 있다면 옆의 바퀴들도 돌려줘야 합니다.&lt;br /&gt;
단, 여기서 주의할 점이 있습니다. 돌릴 바퀴 주변의 바퀴가 돌아갈 수 있는지는 돌린 후가 아니라 &lt;strong&gt;돌리기 전&lt;/strong&gt;의 상황과 비교해야 합니다. 즉, 돌리기 직전에 N/S가 맞아야 옆에 바퀴가 돌 수 있는 것이지, 돌린 후에 맞아봤자 소용이 없습니다.&lt;br /&gt;
따라서, top 수정 명령은 defer 처리해야 하며, 다른 톱니를 돌린 후에 적용해줘야 합니다.&lt;br /&gt;
이를 효과적으로 구현하는 방법은 여러가지가 있겠지만, &lt;strong&gt;가장 편한 방법은 재귀를 쓰지 않고 그냥 처음 시작할 때 제대로 맞물린 톱니만 찾고 -1/+1을 번갈아가며 양쪽으로 나아가는 것입니다.&lt;/strong&gt; 만약 Simulate로 톱니 하나만 돌리고 붙어있는 톱니를 돌리기 위해 재귀를 썼다간 난리 납니다. 옆에 Simulate가 다시 돌아와서 부모톱니를 부르고, 또 반복되고....&lt;br /&gt;
백문이불여일견이라고, 한번 구현된걸 보죠.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;void Simulate(vector&amp;lt;string&amp;gt; &amp;amp;gears, vector&amp;lt;int&amp;gt; &amp;amp;top, int sel, int dir) {

    int leftlimit = sel, rightlimit = sel;
    // 왼쪽으로 연속해서 맞물린 톱니 탐색
    for (int i = sel - 1; i &amp;gt;= 0; --i) {
        // 전단계(오른쪽)의 톱니가 현재(왼쪽)의 톱니와 맞물려있는지 -값이 다른지- 확인
        if (gears[i + 1][(top[i + 1] - 2 + 8) % 8] != gears[i][(top[i] + 2) % 8]) {
            leftlimit = i;
        }
        else {
            break;
        }
    }
    // 오른쪽으로 연속해서 맞물린 톱니 탐색
    for (int i = sel + 1; i &amp;lt; COUNT; ++i) {
        // 전단계(왼쪽)의 톱니가 현재(오른쪽)의 톱니와 맞물려있는지 -값이 다른지- 확인
        if (gears[i - 1][(top[i - 1] + 2) % 8] != gears[i][(top[i] - 2 + 8) % 8]) {
            rightlimit = i;
        }
        else {
            break;
        }
    }

    // 자기 자신을 포함해서 왼쪽으로 나아가며 맞물린 바퀴들은 시계/반시계 번갈아가며 적용해줍니다.
    int d = dir;  // dir를 바꿔버리면 밑부분 오른쪽으로 탐색할 때 본래 방향을 모릅니다.
    for (int i = sel; i &amp;gt;= leftlimit; --i) {
        top[i] = Turn(top[i], d);
        d = -d;
    }
    // 자기 자신을 제외하고(이미 한번 돌렸으니) 오른쪽으로 나아가며 번갈아가며 바꿔줍니다.
    // 주의할 점 : 자기 자신 제외이므로 d를 처음부터 -dir로 설정한 다음 시작해야 합니다.
    d = -dir;
    for (int i = sel + 1; i &amp;lt;= rightlimit; ++i) {
        top[i] = Turn(top[i], d);
        d = -d;
    }

    return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드의 부연설명을 하자면, 윗부분 블록에서는 왼쪽 오른쪽으로 순차탐색을 하며 연속적으로 맞물린 가장 먼 바퀴를 확인합니다. 아랫부분 블록에서는 방금 전 알게 된 정보를 토대로 시계/반시계 번갈아가며 각 바퀴들을 돌려줍니다(연속적으로 맞물린 가장 먼 곳까지만). 참 쉽죠?&lt;/p&gt;&lt;p&gt;사실 실제 시험 때는 이렇게 깔끔하게 못 짭니다. 방금 제가 언급한 &quot;함정&quot;들에 대부분 빠진 상태로 코딩을 하고 테스트케이스 fail해서 디버깅하는 과정에서 확인하는 경우가 많기 때문에 온갖 스파게티 코드 양산 경험을 해볼 수 있습니다.&lt;br /&gt;
하지만 이해를 돕기 위해, 그리고 모범적인 답안을 제시해보기 위해 다소 비현실적일 수 있는 형태로 깔끔하게 짜보았습니다.&lt;br /&gt;
실제 시험 때 얼마나 헷갈리는 부분이 많을 수 있고, 작은 실수가 전체 구조를 다 짜고 났을 때는 얼마나 고치기 어려운지 미리 한번 경험해보고 잘 대비할 수 있는 데에 도움이 되었으면 합니다.&lt;br /&gt;
마지막 간단한 &quot;점수산정&quot; 부분까지 추가하여 완성된 코드는 아래 첨부합니다.&lt;/p&gt;&lt;p&gt;원래 3~4개 예제 풀어서 올리려고 했으나 피곤한 관계로 한개만 하도록 할게요.&lt;br /&gt;
미래에 요청이 좀 들어온다면 추가적으로 올리도록 하겠습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;

#define COUNT 4
#define TEETH 8

using namespace std;

int Turn(int current, int dir) {
    return ((current - dir) + 8) % 8; // dir를 더한다음 8을 더하고(음수 방지) mod 8을 해주면(8 overflow 방지) 0부터 7까지의 깔끔한 값으로 변함 
}

void Simulate(vector&amp;lt;string&amp;gt; &amp;amp;gears, vector&amp;lt;int&amp;gt; &amp;amp;top, int sel, int dir) {

    int leftlimit = sel, rightlimit = sel;
    // 왼쪽으로 연속해서 맞물린 톱니 탐색
    for (int i = sel - 1; i &amp;gt;= 0; --i) {
        // 전단계(오른쪽)의 톱니가 현재(왼쪽)의 톱니와 맞물려있는지 -값이 다른지- 확인
        if (gears[i + 1][(top[i + 1] - 2 + 8) % 8] != gears[i][(top[i] + 2) % 8]) {
            leftlimit = i;
        }
        else {
            break;
        }
    }
    // 오른쪽으로 연속해서 맞물린 톱니 탐색
    for (int i = sel + 1; i &amp;lt; COUNT; ++i) {
        // 전단계(왼쪽)의 톱니가 현재(오른쪽)의 톱니와 맞물려있는지 -값이 다른지- 확인
        if (gears[i - 1][(top[i - 1] + 2) % 8] != gears[i][(top[i] - 2 + 8) % 8]) {
            rightlimit = i;
        }
        else {
            break;
        }
    }

    // 자기 자신을 포함해서 왼쪽으로 나아가며 맞물린 바퀴들은 시계/반시계 번갈아가며 적용해줍니다.
    int d = dir;  // dir를 바꿔버리면 밑부분 오른쪽으로 탐색할 때 본래 방향을 모릅니다.
    for (int i = sel; i &amp;gt;= leftlimit; --i) {
        top[i] = Turn(top[i], d);
        d = -d;
    }
    // 자기 자신을 제외하고(이미 한번 돌렸으니) 오른쪽으로 나아가며 번갈아가며 바꿔줍니다.
    // 주의할 점 : 자기 자신 제외이므로 d를 처음부터 -dir로 설정한 다음 시작해야 합니다.
    d = -dir;
    for (int i = sel + 1; i &amp;lt;= rightlimit; ++i) {
        top[i] = Turn(top[i], d);
        d = -d;
    }

    return;
}

int main() {

    vector&amp;lt;string&amp;gt; gears(COUNT);
    vector&amp;lt;int&amp;gt; top(COUNT, 0);

    for (auto it = gears.begin(); it != gears.end(); ++it) {
        cin &amp;gt;&amp;gt; (*it);
    }

    int K;
    cin &amp;gt;&amp;gt; K;
    for (int i = 0; i &amp;lt; K; ++i) {
        int sel, dir;
        cin &amp;gt;&amp;gt; sel &amp;gt;&amp;gt; dir;
        --sel;  // sel이 1부터 시작하므로 0부터 시작하게 normalize
        Simulate(gears, top, sel, dir);
    }

    int score = 0;
    int mult = 1;
    for (int i = 0; i &amp;lt; COUNT; ++i) {
        if (gears[i][top[i]] == '1') {
            score += mult;
        }
        mult *= 2;
    }
    cout &amp;lt;&amp;lt; score;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;h2&gt;4. 팁&lt;/h2&gt;
&lt;p&gt;B형에 대해서는 팁이 좀 있는데, A형은 사실 할 말이 많지 않습니다.&lt;br /&gt;
위의 풀이에 다 녹아내었으니 실수하기 쉬운 부분, 함정 등을 잘 캐치해내는 연습을 해보세요.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;문제풀이에 들어가는 시간은 생각보다 길지 않다. 디버깅으로 낭비하는 시간이 훨씬 길다. &lt;strong&gt;따라서 문제 조건은 제대로 읽고 한번 더 읽어라.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;시간 복잡도를 생각해야 되는 경우도 있다. A형은 브루트포스로 대부분 풀리지만, 아닐 가능성도 있다. 테스트케이스 당 총 반복횟수가 1억번이 넘어가면 실패 가능성이 상당히 높아진다. 하지만, &lt;strong&gt;1억번을넘지 않는다면 더 효율적인 알고리즘 고민하며 시간 낭비하느니 그대로 구현하면 된다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;가능하면 C는 쓰지 않는것이 좋다. 언어 자체의 문법적 제약도 심하고, 좋은 점이 하나도 없다. 굳이 C++ 배우기 싫다면, 그냥 using namespace std; 한줄만 위에 추가하고 C언어처럼 그대로 써라. C 코드 그대로 써도 전혀 문제 없고, 오히려 가끔 변수 선언을 코드 중간에 한다든가 하는 실수를 했을 때 C++ 문법이 눈감아줄 것이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C++의 std::vector는 사랑이다&lt;/strong&gt;. 초기화도 매우 쉽고, 사이즈 조절도 내장 메소드로 간편하며, 대단히 효율적이고(단, 주의할 점은 여러번 반복하여 불리는 함수에 &amp;amp;레퍼런스가 아니라 value copy로 넘기면 시간복잡도가 무지막지하게 늘어난다. vector의 value copy는 굉장히, 무시무시하게 고비용의 작업이다.) C array의 상위호환이다.&lt;/li&gt;
&lt;li&gt;C++에서 문자열을 쓸 일이 있다면 string 클래스를 쓰는 것이 char[] C스트링보다 훨씬 좋다. cout / cin과의 호환성도 그렇고, 크기도 마음대로 바꿀 수 있으며 훨씬 안정적이다. 심지어 라이브러리 못 쓰는 B형에서도, iostream 헤더에 string이 내장되어 있으므로(!!!) string 클래스는 사용할 수 있다.&lt;/li&gt;
&lt;li&gt;내실을 갖추는 공부를 하는 것이 좋다. 아무리 벼락치기해서 SW테스트에 운좋게 붙는다 해도, 면접 및 실무에서 다 들통난다. 그냥 알고리즘 문제만 잔뜩 푸는 것보단 웹서비스 프로젝트나 유니티, MFC, Python/pyqt 등 이용해서 실질적인 프로젝트를 해보는 것이 코딩 센스도 늘리면서 스펙도 쌓고 경험 및 스토리도 만드는 지름길이다.&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;h2&gt;5. 맺음말&lt;/h2&gt;
&lt;p&gt;맺음말은 독백.&lt;br /&gt;
삼전 등 시작으로 카카오, 라인, 네이버 등 대부분의 대기업/IT기업들이 코딩 테스트를 실시하기 시작한 것은 상당히 좋은 변화라고 생각한다.&lt;br /&gt;
기존에는 C언어 기초도 힘겹게 대충 배운 사람들이 이런저런 흔한 대학생 스펙쌓는 활동을 하곤 대기업 개발직군에 들어가는 경우가 많았다. 이 때문에 고급 개발자원이 양성되기 어려운 환경이었고, SI 하청 프로젝트의 방향으로 트렌드가 치중되어 있었는지도 모른다.&lt;br /&gt;
어쨌든 학력차별이 줄어들고 실력으로 승부할 수 있는 사회가 되어가는 건 좋은 게 아닐까 싶다.&lt;br /&gt;
물론 코딩 테스트 또한 사교육 열풍의 손아귀를 벗어날 순 없기에 이것도 조만간 GET 리퀘스트가 뭔지도 모르면서 코딩테스트만 연습한뒤 취업되는 웹개발자들이 양성되는 모습으로 변질되지 않을까 하는 걱정이 들지만, 남 삿대질할 시간에 내 기술스택을 쌓는 게 우선순위일 것 같다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3&gt;보너스 : 3-1번 퀴즈 정답&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C라면 포인터로 parameter를 정의한 뒤 argument로 넘길 때 주소를 넘깁니다. C++는 좀 더 깔끔한 방법이 있는데, int &amp;amp;val과 같이 parameter를 정의한 뒤 argument로 넘길 때 그냥 넘기면 됩니다. Java의 경우 Int형은 immutable하므로 불가하며, 굳이 써야겠다면 별도로 class를 정의한 뒤 class를 wrapper처럼 쓰면 됩니다.&lt;/li&gt;
&lt;li&gt;삽입 정렬은 O(n^2) 복잡도를 가집니다. 정확히는 n^(n-1)/2번 연산이며, Big O 노테이션 규칙에 따라 차수를 제외하고 버립니다.&lt;/li&gt;
&lt;li&gt;1억번은 일반적으로 1초가 걸린다고 가정하면 좋습니다(CPU 성능이 좋으면 적게 걸리지만, 최악의 경우를 가정하는 것이 좋으므로). 이는 for문으로 stack depth가 깊어지지 않으면서 구현했을 때의 경우고, 이를 재귀함수로 구현하여 재귀 콜스택이 1억번이 된다면... 일반적으로는 그렇게 되기 훨씬 전에 뻗어버립니다.&lt;/li&gt;
&lt;li&gt;가장 구현하기 간단한 방법은, 좌-&amp;gt;우, 상-&amp;gt;하, 왼대각선, 우대각선으로 크게 4사이클을 확인하면 되며, 각 사이클에서는 순서대로 오목판 전체를 확인하면 간단합니다. 현재 totalLen과 prevColor(0 비어있음, 1 W 2 B)를 변수로 가지고, 다음 칸에 돌이 있으며 해당 돌색과 prevColor가 같으면 totalLen을 1 증가시키고, 5가 되면 탐색을 종료합니다. 육목은 해당사항이 없어야 할 경우, 다음 칸까지 확인하여 prevColor가 같지 않을 경우에만 탐색을 종료합니다. 또한, 당연한 이야기지만 prevColor가 같지 않을 경우 totalLen을 0 혹은 1(비어있다면 0)로 초기화시키고 prevColor를 현재 돌색깔(비어있으면 0)로 초기화시킵니다. 100*100 판에서는 40000번 탐색으로 확인 가능하며, 1억번에 훨씬 못 미치기 때문에 무리 없습니다.&lt;/li&gt;
&lt;li&gt;..이건 정말 기초이므로 생략합니다. 웃고 싶은 분들은 &lt;a href=&quot;http://joelgrus.com/2016/05/23/fizz-buzz-in-tensorflow/&quot;&gt;머신러닝으로 FizzBuzz 풀이&lt;/a&gt;를 보시기 바랍니다.&lt;/li&gt;
&lt;li&gt;당연한 말이지만 모든 약수는 다른 약수와 곱해 N이 되는 짝이 존재할 수밖에 없습니다.&lt;br /&gt;
또한, N은 sqrt(N)*sqrt(N)과 같으므로 sqrt(N)보다 큰 약수는 당연히 sqrt(N)보다 작은 약수와 짝이 될 수밖에 없습니다. 따라서 소수 여부를 판별할 때 sqrt(N)보다 큰 수까지 확인하는 것은 낭비입니다.&lt;br /&gt;
그러므로 N이 2부터 sqrt(N) 이하의 정수로 나눠떨어지는 경우가 있는지 확인하면 소수 여부 판별이 가능합니다. 주의할 점은, N이 1이거나 2일 때 예외처리를 해줘야 합니다. 이 예외처리를 할 생각을 못했다면 정말 열심히 공부하지 않는 이상 알고리즘 시험에서 상당한 어려움을 겪을 가능성이 높습니다. Edge case에 대한 심각한 강박증은 어느 개발자나 갖춰야 할 덕목입니다.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>2017 삼성전자</category>
<author>mark3236</author>
<guid>https://mark3236.tistory.com/47</guid>
<comments>https://mark3236.tistory.com/entry/%EC%82%BC%EC%84%B1%EC%A0%84%EC%9E%90-SW-%ED%85%8C%EC%8A%A4%ED%8A%B8-A%ED%98%95-%EA%B3%B5%EC%B1%84%EC%A0%84%ED%98%95-1%EC%B0%A8%EC%8B%9C%ED%97%98-%EA%B0%80%EC%9D%B4%EB%93%9C#entry47comment</comments>
<pubDate>Sat, 23 Dec 2017 00:53:51 +0900</pubDate>
</item>
<item>
<title>삼성전자 S직군 17년 전반기/하반기 합격 후기</title>
<link>https://mark3236.tistory.com/entry/%EC%82%BC%EC%84%B1%EC%A0%84%EC%9E%90-17%EB%85%84-%EC%9D%B8%ED%84%B4-%ED%95%A9%EA%B2%A9-%ED%9B%84%EA%B8%B0</link>
<description>&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;Disclaimer&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;채용 진행과정에서 작성한 기밀유지서약서가 있기 때문에,&lt;/p&gt;&lt;p&gt;채용 프로세스 및 정보(SW테스트 제약사항, 기출문제, 면접문제 등)는 이미 인터넷에 공개적으로 알려진 사항에 대해서만 정리하여 작성한 것이며, 기밀유지 하기로 한 부분에 대해서 문제시될 부분은 없습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;면접에서 제가 답했던 내용들의 저작권은 저에게 있으며, 면접 문제를 노출시키지 않는 선상에서 제가 준비했던 내용을 공개하는 것은 기밀유지와 무관한 부분입니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;만약 문제가 되는 부분이 있을 경우&amp;nbsp;통보해주시고,&amp;nbsp;해당 내용은 삭제조치하도록 하겠습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;1. 스펙&lt;/h1&gt;
&lt;p&gt;토익 990 / 오픽 AL / 학점 3.96
이 외에 외부활동 스펙이 많지는 않습니다. 프리랜싱이나 공모전 부분참여한 것 세네개 정도 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;2. 서류&lt;/h1&gt;
&lt;p&gt;지원서는 총 두번 넣었습니다 - 인턴 &amp;amp; 공채..&lt;br /&gt;
전반기에 인턴 합격 후 수료했고, 개인 사정으로 전환포기 후 3급 신입공채로 다시 넣고 합격했습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;3. 시험&lt;/h1&gt;
&lt;p&gt;S전자 S직군은 얼마 전부터 코딩시험으로 GSAT/SSAT를 대체하고 있습니다. 한... 3배수 정도 뽑는다는 소리가 있던데, 어쨌든 프로그래밍 언어로 삽질 조금 해봤다 하는 사람 기준으로, 꽤나 쉬운 편입니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;
저 때는 &lt;a href=&quot;https://www.acmicpc.net/problem/14891&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;https://www.acmicpc.net/problem/14891&lt;/a&gt; &lt;a href=&quot;https://www.acmicpc.net/problem/14888&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;https://www.acmicpc.net/problem/14888&lt;/a&gt; 와 같은 문제가 나왔고, 둘 중 하나만 풀어도 면접까지는 왔나봅니다(면접장에서 만난 지원자분이 한개만 풀었다더군요). 시험 시간은 3시간이고, C/C++(99/11/14)/자바 쓸 수 있고 C++ STL, JAVA 기본 패키지들 사용 가능합니다. C++ 쓰세요. 속도도 빠르고, stl vector 짱짱맨.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;위의 시험시간 등 정보는 제가 알려드리는 것이 아니라, 공식 삼성전자 코드그라운드 홈페이지에서 발췌한 내용입니다.&lt;/p&gt;&lt;p&gt;(공채 SW테스트는 여기서 A형에 해당합니다.)&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:605px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9967A83A5A3C9BAB2C&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Screen Shot 2017-12-22 at 2.42.41 PM.png&quot; height=&quot;368&quot; width=&quot;605&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;팁은... 일단 아직까지는 삼전에서 알고리즘 중요시하는 걸 못봤습니다.&lt;br /&gt;
DP/다익스트라 같은건 고사하고 DFS BFS도 거의 안 나와요. 트리탐색 AVL 이런거 달달 외워가면 바보.&lt;/p&gt;&lt;p&gt;까다로운 문제를 빠른 시간내에 정확히 구현하는(즉, 삽질을 통한 내공..) 능력이 제일 중요해요.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;
예를 들면, 원래 배열 인덱스는 이상한 언어를 제외하곤(matlab 나빠...) 0부터 시작하죠.&lt;br /&gt;
그런데 누구나 n 크기의 배열로 저장해뒀을 항목 n개를 0~(n-1)이 아닌 1~n으로 주는 악랄함이라든가 그런 부분이 많습니다.&lt;br /&gt;이를테면, 4개의 쿠키가 있고 2번째의 쿠키를 먹는다는 인풋을 테스트케이스에서 줄 때 &quot;2 eat&quot;로 주는거죠. 1 eat이 아니라. (시험 때 이거때매 index out of bound 떠서 당황)&lt;/p&gt;&lt;p&gt;인터넷에 기출이라고 떠도는 거 많을텐데, 그거 먼저 덥썩 풀어버리면 본인한테 손해고요,&lt;br /&gt;
(시간이 없다면 위 항목부터 차례대로 포기)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;만들고 싶은 거 아무거나 생각해서, 과제가 아니라 진짜 하고 싶어서 만드는 거 해보기(과제 삽질은 기억에 잘 안 남아요. 본인이 능동적으로 만드는 프로젝트 삽질이 기억에 남지..). Python이나 웹(html/javascript)으로 하는 걸 추천합니다.&lt;/li&gt;
&lt;li&gt;알고리즘 책 하나 골라서 자료구조/알고리즘 제대로 한번 보기&lt;/li&gt;
&lt;li&gt;깔끔하고 정상적인 문제들 알고스팟이나 백준같은데 가서 풀어보기 (테스트케이스, 문제구조 등이 함정 없이 깔끔합니다)&lt;/li&gt;
&lt;li&gt;공식 삼전 연습사이트 https://www.codeground.org/ 가셔서 악랄한 문제 체험해보기&lt;/li&gt;
&lt;li&gt;&quot;기출문제&quot; 구해서 풀어보기
의 순서 추천합니다.&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;
&lt;h1&gt;4. 면접&lt;/h1&gt;
&lt;p&gt;면접은 자신감이 중요합니다. 보면 되게 죄송한 눈빛으로 오는 분들이 많던데, 겸손 != 죄송입니다. &quot;내가 이 회사 한번 어떤가 보러 왔다&quot;고 생각해야지, &quot;혹시 저를 한번 고려해주실 수 있으신지 여쭤볼 수 있을지 여쭤보러 왔습니다&quot; 태도는 안돼요.&lt;br /&gt;
면접은 소개팅이랑 비슷하다고 생각합니다. 일방적인게 아니라, 본인도 면접관 및 회사를 평가할 권리가 있습니다. 어느 정도의 예의는 지켜야 하지만, 그렇다고 을이 되어서도 안됩니다.&lt;/p&gt;&lt;p&gt;그리고, 대부분 학교에서 제공하고 있을 실전 모의면접이 정말 좋아요.&lt;br /&gt;
지금까지 면접 3번 보고 3번 붙었는데, 면접 스터디나 취업 스터디 한번도 안해봤고, 모교취업센터 방문상담 30분 4번 한거랑 거기서 &quot;실전 모의면접&quot; 3번 신청해본게 면접준비의 모든 것이었습니다. 같은 취준생끼리 모여서 할 때 느낌이랑 모의면접이랑은 다르지 않을까 싶습니다. 모의면접 꼭 신청해서 해보세요.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;5. 가장 중요한 팁...&lt;/h1&gt;
&lt;p&gt;이건 전공/직무를 막론하고 모두 적용된다고 생각하는 부분인데요,&lt;br /&gt;
자기 전공/직무와 회사/부서를 연결시켜서 분석을 해봐야 한다고 생각합니다.&lt;/p&gt;&lt;p&gt;보통 사람들이 저지르는 흔한 실수 두가지가, 둘 중 하나에 치중하는 게 아닐까 싶어요.&lt;br /&gt;
A - 그냥 자기 전공지식(건축이든, 마케팅이든, 재무든, 언론학이든, 뭐든간에) 공부만 엄청 해서, 교수나 연구원 하지 왜 이 회사로 오려는건지 모르겠는 지원자&lt;br /&gt;
B - 회사 분석은 엄청 해서 최근 10년 재무제표까지 아는데 정확히 와서 무슨 가치를 제공할 수 있는지 모르겠는 지원자&lt;/p&gt;&lt;p&gt;저는 회사 덕질을 제 전공 기준으로 했습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;채용 사이트의 자동 로그아웃이 불편해서 그거 막는 크롬 익스텐션 만들어놓은 다음 안심하고 자소서 쓸 수 있었던 것&lt;/li&gt;
&lt;li&gt;해당 회사 서비스/어플리케이션에서 고쳐야 할 부분(로직/UX/UI 등) 10가지 이상&lt;/li&gt;
&lt;li&gt;해당 회사 서비스/어플리케이션 클라이언트 노출된 부분 코드 분석(웹사이트 소스보기 등)&lt;/li&gt;
&lt;li&gt;미래에 성공하려면 제공해야 하는 서비스 몇가지 구상
..등등&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;다른 직무로 예를 들어 HR부서 채용이라면,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;해당 기업 주최 취업설명회에서 개선했으면 좋을 점&lt;/li&gt;
&lt;li&gt;이번 채용 프로세스에서 좋았던 점과 좀 더 좋은 퀄리티 지원자들을 뽑고 입사 선택을 장려할 방안
...등등&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;마케팅부서라면,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;해당 기업의 광고 중 가장 인상깊었던 것과 가장 개선할 여지가 있었던 것&lt;/li&gt;
&lt;li&gt;현재 소비자로서 느낄 수 있는 가장 큰 단점
...등등&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;보통 많은 조언글에서 기업을 분석하라는 말이 나오지만, 그냥 &quot;난 이 기업에 가고 싶다&quot;는 건 설득력이 떨어집니다.&lt;br /&gt;
그냥 전반적인 기업 역사 매출 서비스 이런 분석이 아니라,&lt;br /&gt;
지금 내가 지원하는 직무를 기준으로 어떤 점을 고치고 싶고 어떤 점이 유망하기에 미래를 함께하고 싶은지,&lt;br /&gt;
오늘 당장 입사한다면 뭐부터 바꾸고 싶은지,&lt;br /&gt;
(그렇게 말하면 당연히 치고 들어올 추적질문인 &quot;실제로는 바로 원하는대로 바꿀 수 있는 힘이 없을텐데, 의견이 반영되지 않으면 어떻게 해결할 것인지&quot;에 대한 깔끔한 답변 준비 - 예시 : &quot;물론 변화의 씨앗을 만들 수 있도록 꾸준히 노력하겠지만, 반론이 있다면 입장을 바꿔 생각해보기도 하고, 될 때까지 노력하겠습니다. 하지만 이 부분이 중요한 이유는, 저는 장기적인 꿈이 있어야 행복하기 때문입니다 blah blah&quot;) 등등...&lt;br /&gt;
이런 분석이 차별점을 두는 방법이라고 생각합니다.&lt;/p&gt;&lt;p&gt;물론 문과취업시장 제대로 겪어보지도 않은 half-공대생의 헛소리였을 수도 있지만, 모의 면접 때 같이 오신 분들 말씀하시는 거 들어봐도 이 부분은 개선의 여지가 있다고 봅니다.&lt;br /&gt;
정말 전문지식 많고, 시사 상식도 풍부하고, 기업 정보도 있는데 &quot;왜 내가 이곳에서 일하고 싶은지&quot;에 대한 진지한 고민을 할 시간이 없었던 분들이 많지 않나 싶습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;덧.&lt;/b&gt; 위에 쓴 것들은 취준하면서 그 때부터 시작해서 준비해야 하는 것들만 있는데, 걸어온 길을 다시 기억해보며 지금의 나를 있게 한 것이 무엇인지 밝히면 좋습니다.&lt;br /&gt;
즉, 달리 말하면 &quot;내가 이 방향으로 나아가고 싶게 된 계기&quot;가 필요합니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;[나쁜 예시]&lt;/strong&gt;&lt;br /&gt;
제가 한창 금융에 심취해있을 때 이야기입니다.&lt;br /&gt;
전 돈이 좋았습니다. 그냥 돈 벌고 스포츠카 사고 그러면 멋있을 것 같았습니다. 그래서, 왠지 제가 찍는 주식은 올라가고 뭔가 저에게 직감이 있는 것 같아서, 퀀트(양적분석)로 가서 알고리즘 트레이딩 이런 거 짜고 그러면 잘 될 것 같았습니다.&lt;br /&gt;
그런데 이렇게 별 생각 없이 유치하게 만든 꿈은, 제가 제대로 달려가지도 못할 뿐더러 조금만 이해가 깊은 분을 뵙고 나면 털리기만 하더군요.&lt;br /&gt;
결국 &quot;금융&quot;에 대해 진정으로 원하는 것이 아니라는 걸 (비록 당시에 전 금융이 저의 주어진 길이라고 믿었습니다만) 알아채셨던 겁니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;[좋은 예시]&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;이건 현재 저의 이야기입니다.&lt;br /&gt;
제가 소프트웨어로 길을 잡게 된 건, 군대 가기 전에 만든 게임과 군대에서 만든 게임 두개가 가장 큰 촉매였습니다.&lt;/p&gt;&lt;p&gt;1 - 군대 가기 전에 간단한(정말 간단한) 브레인퀴즈 같은 걸 앱스토어에 올렸었는데, 제가 개발하면서 그리고 계속 시간 날 때 해서 만들어놨던 하이스코어를 지구 반대편 어딘가의 누군가가 넘사벽으로 깨버린 겁니다 며칠만에.&lt;br /&gt;
누군가가 저의 게임을 해줬다는 것도 고마운데, 제가 넘지도 못할 하이스코어를 만든 걸 보면서 제 게임을 그렇게 열심히 해줬구나 하는 생각에 정말 감동했었습니다.&lt;/p&gt;&lt;p&gt;2 - 군대에서 행정병 일을 하면서, 인트라넷엔 게임이 없으니 제가 만들어서 해야겠다는 일념으로 2048을 인터넷에서 봤던 기억을 되살려 메모장 html/js 코딩으로 만들었었습니다. 이걸 다른 사무실에 근무하는 선임에게 보내줬는데, 몇시간만에 2048점이 됐는데 왜 게임이 안 끝나냐는 전화가 왔습니다. 전 (지금 이 글을 쓰는 시점까지도) 2048 블록을 만들어본적이 아예 없어서 그냥 귀찮은 마음에 승리조건 코딩을 안했었는데, 제가 만든 2048을 다른 사람이 재밌게 하면서 깬 걸 보곤 정말 감동했습니다.&lt;/p&gt;&lt;p&gt;이 두가지 이야기를 면접에서 말했었습니다.&lt;br /&gt;
웃긴건 이 스토리를 면접 준비하면서 생각해본적이 없었는데, 면접장에서 &quot;왜 이 길을 정했냐&quot;는 질문을 듣곤 갑자기 기억이 나더군요...&lt;br /&gt;
저도 면접 전까진 몰랐었지만, 알고보니 제 깊은 마음 속에서는 개발자가 되고 싶은 진정한 이유가 있었던 겁니다. (사람들에게 행복을 주고 싶은 마음)&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;다들 뭔가 하나는 있을 거라고 생각합니다.&lt;/p&gt;&lt;p&gt;다들 스토리를 만들어나가야 한다고 하는데, 그건 1학년에게 말할땐 조언이지만 3~4학년에게는 사형선고 같은 말이라고 생각합니다. 지금 취업해야 하는데 스토리를 어떻게 만듭니까.&lt;/p&gt;&lt;p&gt;그런데, 스토리를 만들어야 하는 것이 아니라 기억만 하면 되는 겁니다. &lt;b&gt;다들 점수 맞춰서 어떻게든 살려고 아둥바둥하다가 여기까지 온 것 같지만, 그래도 무의식적으로 &quot;차선의 선택&quot;을 하는 과정에서, 그 의사결정 프로세스에 어떻게든 무의식이 작용했을 겁니다.&lt;/b&gt;&lt;/p&gt;&lt;p&gt;재무를 하려고 했는데 수학이 어려워서 마케팅을 공부한 경영학과 학생도, 분명 회계나 국제경영 같은 걸 안 고르고 마케팅을 선택한 이유가 그래도 어딘가에 숨어있을 겁니다.&lt;/p&gt;&lt;p&gt;그걸 잘 돌이켜보세요.&lt;/p&gt;&lt;p&gt;여친이나 남친이 있으면, 애인한테 주저리주저리 털어놓는 것도 방법일 겁니다. 말하다보면 떠오르겠죠.&lt;/p&gt;</description>
<category>2017 삼성전자</category>
<author>mark3236</author>
<guid>https://mark3236.tistory.com/46</guid>
<comments>https://mark3236.tistory.com/entry/%EC%82%BC%EC%84%B1%EC%A0%84%EC%9E%90-17%EB%85%84-%EC%9D%B8%ED%84%B4-%ED%95%A9%EA%B2%A9-%ED%9B%84%EA%B8%B0#entry46comment</comments>
<pubDate>Fri, 22 Dec 2017 08:06:11 +0900</pubDate>
</item>
<item>
<title>우분투 16.04 서버 셋팅 시 자주 생기는 FAQ</title>
<link>https://mark3236.tistory.com/entry/%EC%9A%B0%EB%B6%84%ED%88%AC-1604-%EC%84%9C%EB%B2%84-%EC%85%8B%ED%8C%85-%EC%8B%9C-%EC%9E%90%EC%A3%BC-%EC%83%9D%EA%B8%B0%EB%8A%94-FAQ</link>
<description>&lt;h2&gt;AWS Tips&lt;/h2&gt;
&lt;h3&gt;EC2 포트 문제&lt;/h3&gt;
&lt;p&gt;AWS EC2는 Security Group에서 별도로 허용해주지 않으면 포트들이 기본적으로 막혀있다. 따라서 EC2 Dashboard -&amp;gt; Network &amp;amp; security -&amp;gt; Security Groups에서 Inbound 룰을 바꿔줘야 한다.&lt;br /&gt;
예를 들면, 80포트 웹서버를 외부에 오픈하기 위해서는 프로토콜 : TCP, 포트 : 80 으로 Source : 0.0.0.0/0 (모든 IP)를 열어줘야 한다. HTTPS 443, MySQL 3306, SSH 22 등 또한 일일히 열어줘야 한다.&lt;br /&gt;
자주하는 실수 : 새로운 테스트 서버 열어야 해서 9000과 같은 포트로 설정해놓곤 Security Group에서 열어주는 걸 잊어버리는 것&lt;/p&gt;
&lt;h3&gt;AWS RDS MySQL 인코딩 문제&lt;/h3&gt;
&lt;p&gt;AWS RDS(관계형 데이터베이스) 서비스로 MySQL을 시작해보면, 한국어가 제대로 들어가지 않는 것을 확인할 수 있다. 기본값이 latin-1이라서 생기는 문제점인데, 뒤늦게 고치려면 골치가 아프다. 처음 시작할 때부터 제대로 만들자.&lt;br /&gt;
RDS Dashboard -&amp;gt; Parameter Groups를 가서 Create DB parameter group 버튼을 클릭한다.&lt;br /&gt;
적절히 이름을 넣고 만든 뒤, Edit parameters 버튼을 눌러 수정을 시작한다.
Parameters 탭의 항목들을 다음과 같이 변경한다 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;character_set_client : utf8
character_set_connection : utf8
character_set_database : utf8
character_set_filesystem : utf8
character_set_results : utf8
character_set_server : utf8
collation_connection : utf8_general_ci
collation_server : utf8_general_ci
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;SSH Tips&lt;/h2&gt;
&lt;h3&gt;SSH config&lt;/h3&gt;
&lt;p&gt;.pem과 같은 키를 이용해 ssh 연결을 하는 경우, 항상 .pem을 arg에 포함시키는 게 귀찮다. 이는 config 파일을 수정해놓으면 편하게 할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd ~/.ssh
sudo chmod 400 key.pem
vim config

# === config file === #
Host               friendly-name
HostName           long.and.cumbersome.server.name
IdentityFile       ~/.ssh/private_ssh_file
User               username-on-remote-machine
# === end === #

ssh friendly-name
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Node.js 설치&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;설치하는 방법에는 &lt;a href=&quot;https://nodejs.org/en/download/&quot;&gt;공식링크&lt;/a&gt;에 나와있듯, 소스를 받아 컴파일 하는 방법부터 리눅스 바이너리 등 여러가지가 있지만, 개인적으로는 패키지관리자(apt 등)를 이용한 방법을 추천한다. Node.js는 업데이트가 잦고 LTS 버전도 4, 6, 8과 같이 짝수 패턴으로 계속 올라가는데 은근 버전업이 빨리 이루어진다. 패키지 매니저로 설치하는 것이 제거/업그레이드가 매우 용이하다. (&quot;sudo apt remove node&quot;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;apt를 이용한 설치 방법&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -
sudo apt-get install -y nodejs
sudo apt-get install -y build-essential
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;서버 production 레벨로 띄우기 : PM2&lt;/h3&gt;
&lt;p&gt;&quot;node app.js&quot;와 같은 방식으로 서버를 실행시키면, 쉘을 닫았을 때 서버가 꺼져버린다. 이를 막기 위해서는 PM2와 같은 node 프로세스 관리자를 써야 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo npm install -g pm2   # pm2를 쉘 명령어로 사용 가능하게 global 설치(현재 폴더 node_modules가 아님)
sudo pm2 start app.js     # start process
sudo pm2 monit            # monitor process
sudo pm2 list             # list processes
sudo pm2 save             # save current process list
sudo pm2 startup          # reload process list even after rebooting
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;서버 안죽게 띄우기 : 번외편1(권장하지 않음)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nohup node webchat.js &amp;amp;   # &quot;&amp;amp;&quot;만 쓰고 실행시키면, 앞의 명령어는 백그라운드 프로세스로 실행시켜버리고 다음 명령어 입력을 기다린다.
ps -ef                    # 프로세스 보기
kill [process number]     # 프로세스 종료
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;서버 안죽게 띄우기 : 번외편2(권장하지 않음)&lt;/h3&gt;
&lt;p&gt;forever라는 애드온도 존재한다. 그런데 개인적으론 pm2보다 불안정한 느낌이 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo npm install –g forever
forever start app.js
forever list
forever stop
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;노드 포트(port) 문제&lt;/h3&gt;
&lt;p&gt;보안 등 문제로 인해 노드는 sudo로 실행시키는 것을 권장하지 않는다. 그런데 sudo로 하지 않으면 80포트를 쓰지 못하는데, 그러면 웹서버인데도 브라우져에서 접속할 때 포트 번호를 직접 써줘야 하는 문제가 발생한다.&lt;br /&gt;
그렇기 때문에 포트 외에도 성능 등 문제를 개선하기 위해 node 앞에 nginx 등의 프론트 웹엔진을 두는 것이 좋다.&lt;br /&gt;
하지만 그게 여의치 않다면, 모든 80 포트로 들어오는 통신을 8000 포트로 redirect 해서 미봉책으로 해결하는 방법도 존재한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# Port routing
sudo iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8000
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;iptables 재부팅 후 자동 초기화 막는법&lt;/h3&gt;
&lt;p&gt;iptables는 재부팅시 모두 날아간다. 위에서 말했듯, nginx 설정하는 건 매우 쉬우므로 iptables hack(미봉책)을 사용하지 않는 걸 추천하지만, 굳이 해야겠다면 재부팅 후에도 지속되도록 툴을 써줘야 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# iptables-persistent 설치
sudo apt-get install iptables-persistent

# Ubuntu 16.04 미만
sudo /etc/init.d/iptables-persistent save     # 현재 iptables 상태 저장
sudo /etc/init.d/iptables-persistent reload   # 저장된 것 불러오기(재부팅시에는 자동으로 불러옴)

# Ubuntu 16.04 이상
sudo netfilter-persistent save                # 현재 iptables 상태 저장
sudo netfilter-persistent reload              # 저장된 것 불러오기(재부팅시에는 자동으로 불러옴)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;iptables 항목 삭제&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo iptables -t nat -L --line-numbers
sudo iptables -t nat -D $chainname $linenumber
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;MySQL Tips&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;인코딩 변경&lt;/strong&gt;&lt;br /&gt;
만약 이미 DB를 생성한 상태인데 인코딩 때문에 골치가 아프다면, 다음과 같이 쿼리문으로 수정 가능하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SHOW VARIABLES LIKE 'c%';
use dbname;
SET ~~~~~(whatever entry that came out above without quotes) = 'utf8';
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Node.js Tips&lt;/h2&gt;
&lt;h3&gt;Router 사용법&lt;/h3&gt;
&lt;p&gt;노드의 가장 흔한 웹어플리케이션 프레임워크 Express.js는 4.x 버전부터 Router 클래스가 새로 추가되었다. 이를 통해 node의 메인 앱(index.js, app.js와 같은)에서 모두 routes를 관리할 필요가 없어졌다.&lt;br /&gt;
예를 들면, 다음과 같은 기초 예제 코드가 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// app.js
const http = require('http');
const express = require('express');
const app = express();


app.get('/', function(req, res, next) {
    res.send(&quot;Hello World!&quot;);
});

app.get('/bye', function(req, res, next) {
    res.send(&quot;Bye World!&quot;);
});


const server = http.createServer(app);
server.listen(9000);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 정도 크기에서는 문제가 많지 않지만, 실제로 Production으로 올릴 경우에는 복잡도가 기하급수적으로 증가한다. 따라서 Model-View-Controller 패턴을 따를 필요가 있다.&lt;br /&gt;
View는 ejs, jade 등의 뷰엔진을 쓰면 되는데, Controller는 Express의 Router 클래스를 활용하면 된다. Router를 이용한 프로젝트 구조는 다음과 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;models/
views/
    index.ejs
    bye.ejs
controllers/
    index.js
    bye.js
app.js
package.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 때, app.js는 index.js만 불러오면 된다.&lt;br /&gt;
index.js는 bye.js 및 앞으로 계속 추가될 모든 route들을 관리해준다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// app.js
const http = require('http');
const express = require('express');
const app = express();

const index = require('./controllers/index');
app.use('/', index);

const server = http.createServer(app);
server.listen(9000);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// index.js
const express = require('express');
const router = express.Router();

const bye = require('./bye');

router.get('/', function(req, res, next) {
    res.render('index');
});

router.use('/bye', bye);

module.exports = router;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bye.js
const express = require('express');
const router = express.Router();

router.get('/', function(req, res, next)) {
    res.render('bye');
}

module.exports = router;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>Server(node.js, express)</category>
<author>mark3236</author>
<guid>https://mark3236.tistory.com/43</guid>
<comments>https://mark3236.tistory.com/entry/%EC%9A%B0%EB%B6%84%ED%88%AC-1604-%EC%84%9C%EB%B2%84-%EC%85%8B%ED%8C%85-%EC%8B%9C-%EC%9E%90%EC%A3%BC-%EC%83%9D%EA%B8%B0%EB%8A%94-FAQ#entry43comment</comments>
<pubDate>Sun, 18 Jun 2017 03:56:42 +0900</pubDate>
</item>
</channel>
</rss>