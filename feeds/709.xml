<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Seungho Lee on Medium]]></title>
        <description><![CDATA[Stories by Seungho Lee on Medium]]></description>
        <link>https://medium.com/@shlee1353?source=rss-ee5dcb11357a------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*g0wVl9koJ2nnMtsUWvro9Q.jpeg</url>
            <title>Stories by Seungho Lee on Medium</title>
            <link>https://medium.com/@shlee1353?source=rss-ee5dcb11357a------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 13 May 2019 04:23:11 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@shlee1353" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[웹팩 입문: 3. webpack 4, babel7 설정 및 웹성능 최적화]]></title>
            <link>https://medium.com/@shlee1353/%EC%9B%B9%ED%8C%A9-%EC%9E%85%EB%AC%B8-3-webpack-4-babel7-%EC%84%A4%EC%A0%95-%EB%B0%8F-%EC%9B%B9%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-4d5162a69a71?source=rss-ee5dcb11357a------2</link>
            <guid isPermaLink="false">https://medium.com/p/4d5162a69a71</guid>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[webpack4]]></category>
            <category><![CDATA[webpack]]></category>
            <category><![CDATA[babel-7]]></category>
            <dc:creator><![CDATA[Seungho Lee]]></dc:creator>
            <pubDate>Wed, 08 May 2019 10:19:45 GMT</pubDate>
            <atom:updated>2019-05-09T02:25:33.891Z</atom:updated>
            <content:encoded><![CDATA[<h3>웹팩 입문: 3. webpack4, babel7 설정 및 웹성능 최적화</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/818/1*dk0enMRYV6lgpG2OR-z5NQ.png" /></figure><p>웹팩 입문 시리즈 세번째편, webpack 4와 babel7 설치에 대해 알아보도록 하겠습니다. 이전 1편, 2편에서는 webpack 3.x.x를 사용하였습니다. 이번은 4.30.0버전을 기반으로 웹팩 설정을 진행하도록 하겠습니다.</p><pre>$ npm install --save-dev webpack webpack-cli</pre><p>처음 설치는 동일하며 다른점이 있다면 entrypoint와 output을 설정하지 않아도 자동으로 ./src/index.js 파일로, ./dist/main.js로 인지하고 번들링합니다.</p><p>다음으로 babel7을 설치하도록 하겠습니다.</p><pre>npm install --save-dev @babel/core babel-loader @babel/preset-env</pre><p>설치 후 .babelrc를 생성 후 기본설정을 추가해 주셔야합니다.</p><pre>{<br> &quot;presets&quot;: [<br>  &quot;<a href="http://twitter.com/babel/preset-env">@babel/preset-env</a>&quot;<br> ]<br>}</pre><p>마지막으로 webpack.config.js를 설정합니다. package.json을 포함한 전체 코드를 살펴보도록 하겠습니다. 1편, 2편에 강좌에 사용했던 설정 몇가지들을 함께 추가해봤습니다.</p><pre>{<br>  &quot;name&quot;: &quot;webpack_example&quot;,<br>  &quot;version&quot;: &quot;1.0.0&quot;,<br>  &quot;description&quot;: &quot;&quot;,<br>  &quot;main&quot;: &quot;index.js&quot;,<br>  &quot;scripts&quot;: {<br>    &quot;dev&quot;: &quot;webpack-dev-server --hot --inline&quot;,<br>    &quot;build&quot;: &quot;webpack --mode production&quot;<br>  },<br>  &quot;author&quot;: &quot;&quot;,<br>  &quot;license&quot;: &quot;ISC&quot;,<br>  &quot;devDependencies&quot;: {<br>    &quot;<a href="http://twitter.com/babel/core">@babel/core</a>&quot;: &quot;^7.4.4&quot;,<br>    &quot;<a href="http://twitter.com/babel/preset-env">@babel/preset-env</a>&quot;: &quot;^7.4.4&quot;,<br>    &quot;babel-loader&quot;: &quot;^8.0.5&quot;,<br>    &quot;css-loader&quot;: &quot;^2.1.1&quot;,<br>    &quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;,<br>    &quot;style-loader&quot;: &quot;^0.23.1&quot;,<br>    &quot;webpack&quot;: &quot;^4.30.0&quot;,<br>    &quot;webpack-cli&quot;: &quot;^3.3.2&quot;,<br>    &quot;webpack-dev-server&quot;: &quot;^3.3.1&quot;<br>  }<br>}</pre><pre>const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);<br>const path = require(&#39;path&#39;);</pre><pre>module.exports = {<br> module:{<br>  rules:[<br>   {<br>    test: /\.css$/,<br>    use: [&#39;style-loader&#39;,&#39;css-loader&#39;]<br>   }, {<br>    test: /\.js$/,<br>    exclude: /node_modules/,<br>    use: {<br>     loader: &quot;babel-loader&quot;<br>    }<br>   }<br>  ]<br> },<br> devServer: {<br>  contentBase: path.join(__dirname, &quot;./dist/&quot;),<br>  port: 9000<br> },<br> plugins: [<br>  new HtmlWebpackPlugin({<br>   title: &#39;Project Demo&#39;,<br>   minify: {<br>    collapseWhitespace: true<br>   },<br>   hash: true,<br>   template: &#39;./src/index.html&#39;<br>  })<br> ]<br>}</pre><p>웹팩을 사용하는 이유는 번들을 통한 성능 최적화라는 목적을 가지고 있습니다. 즉, 적정 사이즈의 번들을 생성하고 관리를해야합니다. 이럴 때 사용할 수 있는 것이 바로 webpack-bundle-analyzer 입니다. 설치와 사용방법은 매우 간단하지만 아주 강력한 기능을 제공하고 있습니다.</p><pre>npm install --save-dev webpack-bundle-analyzer</pre><pre>// webpack.config.js<br>const BundleAnalyzerPlugin = require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin;</pre><pre>plugins: [<br>  new HtmlWebpackPlugin({<br>   title: &#39;Project Demo&#39;,<br>   minify: {<br>    collapseWhitespace: true<br>   },<br>   hash: true,<br>   template: &#39;./src/index.html&#39;<br>  }),<br>  new BundleAnalyzerPlugin()<br> ]</pre><p>설치 및 설정이 끝나면 npm run dev 명령어를 실행을 합니다. 그러면 브라우저에서 아래와같은 화면을 확인하실 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*MlOIqcrEihCrIyRJLE-m6g.png" /></figure><p>번들의 크기를 시각적으로 쉽게 알 수 있어서 매우 편리합니다. 예를들어, 가장 많은 용량을 차지하는 것이 sockjs.js인데요, 사전에 설치한 webpack-dev-server 모듈 때문입니다. 성능 최적화를 위해, webpack-dev-server를 제거하거나 다른 모듈로 대치할 수 있습니다. 그러면 sockjs.js를 비롯하여 관련 모듈이 제거 되면서 아래와 같은 화면이 나옵니다. 용량도 크게 줄었습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*zUzR_nuoLw-AgP4eka_URQ.png" /></figure><p>극히 단순한 예시지만, webpack-bundle-analyzer의 용도를 이해하기에 충분합니다. 만약 서비스가 리액트로 개발되어 있다면, <a href="https://reactjs.org/docs/code-splitting.html">React.lazy</a>를 사용하여 Code splitting을 통한 리소스 로딩 최적화도 가능합니다.</p><ul><li><a href="https://medium.com/@shlee1353/%EC%9B%B9%ED%8C%A9-%EC%9E%85%EB%AC%B8-%EA%B0%80%EC%9D%B4%EB%93%9C%ED%8E%B8-html-css-%EC%82%AC%EC%9A%A9%EA%B8%B0-75d9fb6062e6">웹팩 입문: 1. HTML, CSS 사용하기</a></li><li><a href="https://medium.com/@shlee1353/%EC%9B%B9%ED%8C%A9-%EC%9E%85%EB%AC%B8-2-scss-img-svg-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-b908093a6312">웹팩 입문: 2. sass, img, svg 사용하기</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4d5162a69a71" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[자바스크립트 Object 오브젝트 속성 알아보기]]></title>
            <link>https://medium.com/@shlee1353/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-object-%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EC%86%8D%EC%84%B1-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-d52077942592?source=rss-ee5dcb11357a------2</link>
            <guid isPermaLink="false">https://medium.com/p/d52077942592</guid>
            <category><![CDATA[es6]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[ecmascript-6]]></category>
            <dc:creator><![CDATA[Seungho Lee]]></dc:creator>
            <pubDate>Tue, 30 Apr 2019 16:47:58 GMT</pubDate>
            <atom:updated>2019-04-30T16:49:00.544Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/559/1*OieekG2BPz9zz-rZgYZafQ.png" /></figure><h4>Object에 function 작성</h4><pre>// ES5<br>let obj = {<br> getTotal: function(param) {<br>  return param + 123;<br> }<br>}</pre><pre>//ES6<br>let obj = {<br> getTotal(param) {<br>  return param + 123;<br>    }<br>}</pre><p><strong>디스크립트</strong></p><pre>Object.defineProperty({}, &quot;book&quot;, {<br> value: 123,<br> enumerable: true<br>});</pre><p>프로퍼티 디스크립터는 데이터 프로퍼티 디스크립터(value, writable) 타입과 액세스 디스크립터(get, set) 타입으로 분류됩니다. 공용(enumerable, configurable). 데이터 타입과 액세스 속성을 함께 작성할 수 없습니다.</p><p><strong>get, set 속성</strong></p><pre>// get 속성<br>var obj = {};</pre><pre>Object.defineProperty(obj, &quot;book&quot;, {<br> get: function() {<br>  return &quot;책&quot;;<br> }<br>});</pre><pre>obj.book</pre><pre>// set 속성<br>var obj = {};</pre><pre>Object.defineProperty(obj, &quot;item&quot;, {<br> set: function(param) {<br>  this.sports = param;<br> }<br>});</pre><pre>obj.item = &quot;야구&quot;;<br>obj.sports;</pre><p>set 속성은 obj.item 코드를 해석한다, obj 오브젝트에서 item 프로퍼티 작성 여부를 확인후 set 속성 존재 여부를 체크한다. 존재하면 set 속성값인 함수를 실행하고 이때 파라미터로 값을 넘겨준다. setter 함수가 호출되면 this.sports에서 this는 obj 오브젝트를 참조하고 파라미터로 넘겨받은 값을 sports프로퍼티에 설정한다. obj.sports는 getter 이지만 get 속성이 없지만 디폴트 getter가 호출되어 sports 값을 반환한다. ES6에서는 좀더 직관적입니다.</p><pre>// get 속성<br>let obj = {<br> value: 123,<br> get getValue() {<br>  return this.value;<br> }<br>};</pre><pre>obj.getValue</pre><pre>// set 속성<br>let obj = {<br> set setValue(value) {<br>  this.value = value;<br> }<br>};</pre><pre>obj.setValue = 123;<br>obj.value;</pre><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d52077942592" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[코딩 테스트 만들고 연결하고 동작 시키다]]></title>
            <link>https://medium.com/@shlee1353/%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%A7%8C%EB%93%A4%EA%B3%A0-%EC%97%B0%EA%B2%B0%ED%95%98%EA%B3%A0-%EB%8F%99%EC%9E%91-%EC%8B%9C%ED%82%A4%EB%8B%A4-7e155dc4408d?source=rss-ee5dcb11357a------2</link>
            <guid isPermaLink="false">https://medium.com/p/7e155dc4408d</guid>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[coding-education]]></category>
            <category><![CDATA[coding-test]]></category>
            <category><![CDATA[coding]]></category>
            <dc:creator><![CDATA[Seungho Lee]]></dc:creator>
            <pubDate>Thu, 25 Apr 2019 08:25:58 GMT</pubDate>
            <atom:updated>2019-04-26T04:12:37.685Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/636/1*TJa8txzOu6jR7E1c3R2PHg.jpeg" /></figure><ol><li><strong>보이는 것을 만든다</strong></li></ol><p>자바스크립트를 이용하여 간단한 UI를 즉시 만들어내야합니다. 그렇지 않을 경우, 로직에 투자해야할 시간이 많이 부족해집니다. 기본적은 UI를 만든다는 것은 복잡한 인터렉션이 아니라, 사용자의 정보를 입력/출력할 수 있는 정도를 말합니다. 예를들어, 간단한 구구단을 작성해서 콘솔/화면에 출력시키는 것은 간단합니다.</p><pre>for(var i = 2; i &lt; 10; i++) {<br>  for(var j = 1; j &lt; 10; j++) {<br>    document.write(i + &quot;*&quot; + j + &quot;=&quot; + i * j + &quot;&lt;br&gt;&quot;)<br>  }<br>}</pre><p>하지만, 이것을 화면에 이쁘게 노출 시키려면 약간더 복잡해질 수 있습니다. 예를들어, 아래처럼 구구단표를 만들기 위해서는 어떻게 해야 할까요?</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/745/1*CfCRHw1tBsuekyMkOvOKzw.png" /></figure><pre>function timesTables () {<br>  var tag = &quot;&quot;;<br>  var startTag = &quot;&lt;span&gt;&quot;;<br>  var endTag = &quot;&lt;/span&gt;&quot;;<br>  <br>  for (var i = 2; i &lt; 10; i++) {<br>    tag += startTag;<br>    for (var j = 1; j &lt; 10; j++) {<br>      var answer = i * j;<br>      tag += i + &quot;x&quot; + j + &quot;=&quot; + answer + &quot;&lt;br/&gt;&quot;;<br>    }<br>    tag += endTag;<br>  }<br>  return tag;<br>}</pre><p>다음은 아래와 같이 기본적인 테이블을 만들어 보도록 하겠습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/801/1*DBCjx98BOtgtJXDQX7phIg.png" /></figure><pre>function start() {<br>        var mybody = document.getElementsByTagName(&quot;body&quot;)[0];</pre><pre>mytable = document.createElement(&quot;table&quot;);<br>        mytablebody = document.createElement(&quot;tbody&quot;);</pre><pre>for(var j = 0; j &lt; 5; j++) {<br>            mycurrent_row = document.createElement(&quot;tr&quot;);<br>            for(var i = 0; i &lt; 5; i++) {<br>                mycurrent_cell = document.createElement(&quot;td&quot;);<br>                currenttext = document.createTextNode(&quot;cell is row &quot;+j+&quot;, column &quot;+i);<br>                mycurrent_cell.appendChild(currenttext);<br>                mycurrent_row.appendChild(mycurrent_cell);<br>            }<br>            mytablebody.appendChild(mycurrent_row);<br>        }<br>        mytable.appendChild(mytablebody);<br>        mybody.appendChild(mytable);<br>        mytable.setAttribute(&quot;border&quot;, &quot;1&quot;);<br>    }</pre><p>테이블도 만들었으니, 이제는 사용자의 정보와 노출된 정보를 보여줄 수 있는 화면을 만들어 보도록 하겠습니다. 정보를 입력하는 가장 기본적인 것은 input과 textarea가 될 수 있습니다.</p><p><strong>2. 만든 것을 연결한다</strong></p><p>간단한 인터렉션은 클릭, 엔터 정도를 의미합니다. 선택된 엘리먼트에 이벤트를 추가하는 방법을 잘 숙지해야합니다. 가장 기본적으로, DOM event types은 아래와 같습니다.</p><ul><li><strong>mouse events (MouseEvent):</strong> mousedown, mouseup, click, dblclick, mousemove, mouseover, mousewheel, mouseout, contextmenu</li><li><strong>touch events (TouchEvent):</strong> touchstart, touchmove, touchend, touchcancel</li><li><strong>keyboard events (KeyboardEvent):</strong> keydown, keypress, keyup</li><li><strong>form events:</strong> focus, blur, change, submit</li><li><strong>window events: </strong>scroll, resize, hashchange, load, unload</li></ul><p>DOM 이벤트를 사용하기 위해서는 HTML상에 있는 엘리먼트를 선택해서 그 곳에 이벤트를 추가시켜줘야합니다. 여기서 중요한 것이 getElementsByTagName() — live NodeList, querySelectorAll() — static NodeList, 메소드의 종류에 따라 결과값이 다른 형태라는 것입니다. 코드를 통해 살펴보도록 하겠습니다. 다음 코드는 textarea의 값을 기준으로 input에 입력된 값이 얼마나 정확도가 있는지 간단히 보여주는 코드입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/599/1*D5POiJYtCmX7VhcG0O5W1w.png" /></figure><pre>function start() {<br>        var textareaEl = document.getElementById(&#39;textarea&#39;);<br>        var inputEl = document.getElementById(&#39;input&#39;);<br>        var textareaVal;<br>        var inputVal;<br>        var textareaLength;<br>      <br>        inputEl.addEventListener(&#39;keypress&#39;, function(e) {<br>          if(e.which == 13) {<br>            getTextareaVal()<br>            getInputVal()<br>            compareVal(textareaVal, inputVal)<br>          }<br>        })<br>        <br>        function getTextareaVal () {<br>          textareaVal = textareaEl.value.split(&#39; &#39;);<br>          textareaLength = textareaVal.length;<br>        }<br>      <br>        function getInputVal () {<br>          inputVal = inputEl.value.split(&#39; &#39;);<br>        }<br>      <br>        function compareVal (arr1, arr2) {<br>          const objMap = {}<br>          <br>          arr1.forEach(e1 =&gt; arr2.forEach(e2 =&gt; {<br>            if(e1 === e2) {<br>              objMap[e1]=objMap[e1] || 1;<br>            }<br>          }));<br>          <br>          var finalArray = Object.keys(objMap).map(e =&gt; e);<br>          var num = finalArray.length;<br>          <br>          accuracyRate(num);<br>        }  <br>      <br>        function accuracyRate (num) {<br>          console.log(num/textareaLength * 100)<br>        }<br>    }</pre><p><strong>3. 연결한 것을 동작 시키다</strong></p><p>화면상에 필요한 모든 것들이 연결되면 이제 작동을 구현해야 합니다. 아무래도 이 부분이 가장 집중력과 시간이 필요한 부분이라고 생각합니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7e155dc4408d" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[웹성능 최적화 네이버 UI개발]]></title>
            <link>https://medium.com/@shlee1353/%EC%9B%B9%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%84%A4%EC%9D%B4%EB%B2%84-ui%EA%B0%9C%EB%B0%9C-21f44bf6a792?source=rss-ee5dcb11357a------2</link>
            <guid isPermaLink="false">https://medium.com/p/21f44bf6a792</guid>
            <category><![CDATA[web-performance]]></category>
            <category><![CDATA[ux-engineer]]></category>
            <category><![CDATA[front-end-development]]></category>
            <category><![CDATA[css-animation]]></category>
            <category><![CDATA[html]]></category>
            <dc:creator><![CDATA[Seungho Lee]]></dc:creator>
            <pubDate>Tue, 23 Apr 2019 07:14:54 GMT</pubDate>
            <atom:updated>2019-04-23T07:14:54.441Z</atom:updated>
            <content:encoded><![CDATA[<p>사용자에게 최적의 인터넷 환경을 제공하기 위해서 프론트엔드 UI개발에서 고려해야할 점들은 생각보다 많습니다. 이번 포스팅에서는 필자가 웹성능을 향상 시키기 위해 사용했던 다양한 방법을 정리하여 소개하고자 합니다.</p><ol><li>서비스에서 프로젝트 작업시 불필요한 CSS라이브러리를 베재하고 꼭 필요한 스타일 요소만 추가하였습니다. CSS 리소스는 랜더링을 차단하는 요소이기 때문에, 브라우저에서 필요한 기본 스타일만 사용해야합니다. 물론, 리액트로 작업 환경이 바뀌면서 CSS in JS구현이 가능해졌지만, 자바스크립트 프레임워크를 지원하지 않는 서비스에서는 꼭 고려해야할 요소 입니다. 실제로 CSS in JS를 구현하기 위해 styled-components 테스트 및 사용을 고려하였습니다.</li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*rK4TznqGgo-p8gljrk2Mxw.png" /></figure><p>2. HTTP2.0을 사용하고 있지만, 아직까지 개별 이미지 보다는 스프라이트 이미지를 적용하고 있습니다. 이미지 최적화를 위해 사용한 방법 중 하나는 아이콘 폰트이며, 다른 하나는 SVG 입니다. 아이콘폰트는 텍스트로 인식되어 CSS 스타일이 적용되며 자유롭게 사이즈를 변형할 수 있습니다. SVG 또한 벡터 기반으로 사이즈 변형과 퍼포먼스에서 뛰어난 성능을 보여 줍니다. 다만 브라우저 캐시가 되지않는 다는 단점이 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/744/1*zUNX2MCMYmB2FuAifzuMkQ.png" /></figure><p>3. 로딩 애니메이션을 사용하기 위해 기존에는 GIF를 많이 사용해 왔습니다. 실제 서비스에서 GIF는 HTTP요청을 증가시킬 뿐만 아니라, 디자인 변경이 유연하지 않아서 수정이 매우 번거로운게 사실입니다. 그래서 업무 시 GIF를 제거하고 CSS애니메이션을 최대한 활용하여 로딩바를 구현하였습니다. 그 결과 PC, 모바일 모두 하나의 코드로 대응이 가능해졌으며 컬러값이나 위치 수정이 편리해졌습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1000/1*CpJi2sy-EMrJNAWdxnzQeA.jpeg" /></figure><p>4. 마크업상에서 성능 최적화를 위한 노력에도 불구하고 더 빠른 SPA 환경 구축이 필요했으며 이를 위해 등장한 것이 자바스크립트 모던 프레임워크(Angular, React, Vue etc..)입니다. 현재 제가 서비스하는 곳은 리액트 환경으로 작업을 진행하고 있으며 Virtual DOM을 활용하여 필요한 부분만 랜더링이 되는 방식을 도입하였습니다. 이는 불필요한 랜더링 과정을 생략하고 성능 향상을 가져왔습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/615/1*5n-MPBKRwshGpHDJaEW_dg.png" /></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=21f44bf6a792" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[리액트(React) UI개발 지금 어디까지 왔나?]]></title>
            <link>https://medium.com/@shlee1353/%EB%A6%AC%EC%95%A1%ED%8A%B8-react-ui%EA%B0%9C%EB%B0%9C-%EC%A7%80%EA%B8%88-%EC%96%B4%EB%94%94%EA%B9%8C%EC%A7%80-%EC%99%94%EB%82%98-93b65b554b28?source=rss-ee5dcb11357a------2</link>
            <guid isPermaLink="false">https://medium.com/p/93b65b554b28</guid>
            <category><![CDATA[ux-engineer]]></category>
            <category><![CDATA[markup]]></category>
            <category><![CDATA[html]]></category>
            <category><![CDATA[react]]></category>
            <category><![CDATA[javascript]]></category>
            <dc:creator><![CDATA[Seungho Lee]]></dc:creator>
            <pubDate>Mon, 22 Apr 2019 06:27:29 GMT</pubDate>
            <atom:updated>2019-04-22T06:28:54.604Z</atom:updated>
            <content:encoded><![CDATA[<h3>디자인&amp;인터렉션</h3><p>UI개발을 하시면서 많이 접하시는 디자인이며 간단한 인터렉션과 노출조건이 들어가 있습니다. 하나는 상품을 확인할 수 있는 캐로셀 UI 컴포넌트이며, 다른 하나는 각 이미지에 설명이 들어가 있는 리스트 구조의 UI입니다. 초록색 박스로 그러져있는 설명 부분은 일정 높이에서 펼치기 버튼이 노출됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/799/1*OW0Dp1614UlkGjBUt9hr5Q.png" /></figure><h3>1. 캐로셀</h3><p>우선, 매우 간단한 구조이며, 기존에 리액트로 업무를 하시면서 setState 메소드와 간단한 반복문(map)을 사용하셨다면 쉽게 구현이 가능합니다. 저는 다음과 같은 프로세스로 작업을 진행하였습니다.</p><ul><li>map을 사용하기 위해 필요한 데이터는 무엇이 있는가? 기본적으로 썸네일에 사용되는 상품 이미지가 있습니다.</li><li>다음으로, 상품 이미지 경로가 들어가 있는 초기값을 선언해 놓습니다. 더미 데이터를 만드는 방법은 여러가지가 있지만, 우선 간단 예로 3개 정도만 만들어 보도록 하겠습니다.</li></ul><pre><strong>const</strong> initialState = [<br>    {<br>        id: 1<br>        imgUrl: &#39;이미지주소&#39;<br>    },<br>    {<br>        id: 2<br>        imgUrl: &#39;이미지주소&#39;<br>    },<br>    {<br>        id: 3<br>        imgUrl: &#39;이미지주소&#39;<br>    }<br>]</pre><ul><li>초기값을 담고 있는 initialState 배열을 실제로 사용해야할 변수에 담아줘야 합니다. 기존에는 이 단계에서 setState 메소드를 사용하였지만, 지금은 useState 를 사용합니다.</li></ul><pre><strong>const</strong> [products, setProducts] = useState(initialState)</pre><ul><li>useState 메소드 인자로 initialState를 넘겨주며 이 값은 products에 담기게 됩니다.</li><li>이제 기존처럼 map을 사용하여 캐로셀에 들어가는 상품 이미지가 담긴 UI를 생성할 수 있습니다. 생각보다 쉽게 적용이 가능합니다.</li></ul><pre><strong>const</strong> Product = ({ imgUrl }) =&gt; {<br>    <strong>return</strong> (<br>        &lt;li className=&quot;item&quot;&gt;<br>            &lt;a href=&quot;#&quot; className=&quot;product&quot;&gt;<br>                &lt;img src={imgUrl} className=&quot;img&quot; width=&quot;100&quot; height=&quot;100&quot; alt=&quot;이미지&quot; /&gt;<br>            &lt;/a&gt;<br>        &lt;/li&gt;	<br>    )<br>}<br><br>&lt;ul className=&quot;product_list&quot;&gt;<br>    {products.map(product =&gt; (<br>        &lt;Product<br>            key={product.id}<br>            imgUrl={product.imgUrl}<br>        /&gt;<br>    ))}<br>&lt;/ul&gt;</pre><h3>2. 리스트</h3><p>사실, 리스트와 캐로셀을 작업하는데 큰 차이는 없습니다. 다만, 조건식이 더해졌을 때, UI개발에서 어느정도 수준의 인터렉션 개발이 가능한지 보여드리려고 합니다. 복잡한 인터렉션이 아니라면 간단한 것은 직접 개발을 하면 좋을 것 같습니다. 물론, 실제 개발을 진행하면서 수정/삭제 될 수는 있지만, 리액트와 같은 자바스크립트 프레임워크/라이브러리를 이해하는데 큰 도움이 됩니다.</p><p>예로, 이미지 리스트를 만들기 위해 아래와 같은 인터렉션 조건이 있습니다.</p><ol><li>초록색 박스 설명의 내용이 두 줄 이상일 경우 height:40px 펼치기 버튼이 노출된다.</li><li>펼치기 버튼을 누르면 해당 초록색 박스의 높이값이 auto가 되면서 펼쳐진다.</li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/621/1*-Z1eIRbCoU_03XJCyuaGSw.png" /></figure><p>위와같은 인터렉션 조건을 코드로 어떻게 풀어나갈 수 있을까요? 다음과 같은 순서로 생각할 수 있습니다.</p><ol><li>펼치기 버튼은 첫 랜더링시 결정되어 사용자에게 보여줘야합니다.</li><li>그러기 위해서는, 초록색 설명 박스의 높이값을 알고 있어야합니다.</li><li>이때 사용할 수 있는 것이 useRef 이며, 이는 jQuery의 선택자와 같은 기능을 합니다.</li><li>useRef로 초록색 설명 박스를 선택하고, 기존에 사용하였던 componentDidMount 대신에 userEffect를 사용하여 각각의 설명박스 높이값을 저장합니다.</li><li>저장된 높이값을 기준으로 height:40px 이상일 경우 펼침 버튼을 노출하는 조건문을 추가합니다.</li><li>펼침 버튼을 눌렀을 시 height값을 auto로 바꿔주는 것은 useRef로 선택한 엘리먼트에 기존처럼 open 클래스를 추가하면 됩니다. 지금까지 설명한 내용을 코드로 살펴보도록 하겠습니다.</li></ol><pre><strong>const</strong> [infoHeight, setInfoHeight] = useState([])<br><strong>const</strong> elRef = useRef([])<br><br><strong>function</strong> <strong>handleClick</strong>(e, i) {<br>    e.preventDefault()<br>    elRef.current[i].classList.add(&#39;open&#39;)<br>}<br><br>useEffect(() =&gt; {<br>    setInfoHeight(elRef.current.map(item =&gt; item.clientHeight))<br>}, [])<br><br><strong>const</strong> Image = () =&gt; {<br>    <strong>return</strong> (<br>        &lt;li className=&quot;item&quot;&gt;<br>            &lt;div className=&quot;image_box&quot;&gt;이미지&lt;/div&gt;<br>            &lt;div className=&quot;info_box&quot; ref={el =&gt; elRef.current[i] = el}&gt;설명&lt;/div&gt;<br>            {infoHeight[i] &gt;= 40 &amp;&amp;<br>                &lt;a href=&quot;#&quot; className=&quot;btn&quot; roel=&quot;button&quot; onClick={e =&gt; handleClick(e, i)}&gt;펼침버튼&lt;/a&gt;<br>            }<br>        &lt;/li&gt;	<br>    )<br>}<br><br>&lt;div className=&quot;image_area&quot;&gt;<br>    &lt;ul className=&quot;image_list&quot;&gt;<br>        {images.map((image, index) =&gt; {<br>            &lt;Image<br>                key={index}<br>            /&gt;<br>        }}<br>    &lt;/ul&gt;<br>&lt;/div&gt;</pre><p>갑자기 코드량이 많아졌네요! 코드를 한 줄씩 살펴보도록 하겠습니다.</p><ol><li>div.info_box에 ref={el =&gt; elRef.current[i] = el}를 추가합니다. 여기서 중요한 것은 useRef 메소드를 통해서 elRef 객체를 생성하면 current 값이 자동으로 생성되며 여기에 선택된 엘리먼트를 순서대로 추가하는 코드입니다.</li><li>그런다음 useEffect를 통하여 저장된 초록박스 설명의 높이값을 가져와서, 상단에 이미 선언해 놓은 infoHeight 배열에 추가합니다.</li><li>이제 배열 안에는 초록박스의 높이값이 전부 담겨 있으며 infoHeight[i] &gt;= 40 조건문을 통하여 펼침버튼 노출/미노출을 결정하게됩니다.</li><li>펼침 버튼에는 onClick={e =&gt; handleClick(e, i)}를 추가하여 클릭시 해당 초록박스에 open 클래스를 추가하여 높이값을 auto로 만들어줍니다. 이부분은 css에 미리 선언해 두셔야합니다.</li></ol><p>처음 리액트로 서비스를 시작하시는 분들에게는 다소 복잡한 내용일 수 있지만, 컴포넌트 구조화 및 기본적인 인터렉션만 잘 구현해도 FE협업시 큰 시너지 효과가 있다고 생각합니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=93b65b554b28" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[리액트 hooks, useState 4가지 상용방법]]></title>
            <link>https://medium.com/@shlee1353/%EB%A6%AC%EC%95%A1%ED%8A%B8-hooks-usestate-4%EA%B0%80%EC%A7%80-%EC%83%81%EC%9A%A9%EB%B0%A9%EB%B2%95-dfe8b2096750?source=rss-ee5dcb11357a------2</link>
            <guid isPermaLink="false">https://medium.com/p/dfe8b2096750</guid>
            <category><![CDATA[react]]></category>
            <category><![CDATA[react-hook]]></category>
            <category><![CDATA[hooks]]></category>
            <category><![CDATA[redux]]></category>
            <dc:creator><![CDATA[Seungho Lee]]></dc:creator>
            <pubDate>Sat, 02 Mar 2019 15:21:35 GMT</pubDate>
            <atom:updated>2019-03-04T09:24:24.495Z</atom:updated>
            <content:encoded><![CDATA[<p>지금까지 함수형 컴포넌트에서 state를 관리하기 위해서는 클래스형 컴포넌트로 바꿔줘야했습니다. 생각해보면 참으로 번거로운 작업이기도 합니다. 우선, class Thing extends React.Component를 적어주고 render() 메서드와 함께 들여쓰기를 다시 해줘야 비로소 state 추가가 가능합니다. 이제 hooks를 사용해서 좀 더 깔끔한 코드작성이 가능합니다. 오늘은 useState의 사용방법에 대해 알아보도록 하겠습니다.</p><p>useState는 함수형 컴포넌트에 state를 추가할 수 있도록 도와줍니다. (hooks라는 용어를 사용하지만 실제적으로는 함수입니다). class 내부에서는 state는 항상 객체였습니다. 하지만, hooks 에서는 다양한 타입이 될 수 있습니다. (array, number, boolean, string, etc)</p><h4>Example 1: Show/Hide Component With useState</h4><pre>import React, { useState } from &#39;react&#39;;<br>import ReactDOM from &#39;react-dom&#39;;</pre><pre>function LessText({ text, maxLength }) {<br> const [hidden, setHidden] = useState(true);</pre><pre>if (text &lt;= maxLength) {<br>  return &lt;span&gt;{text}&lt;/span&gt;<br> }</pre><pre>return (<br>     &lt;span&gt;<br>       {hidden ? `${text.substr(0, maxLength).trim()} ...` : text}<br>       {hidden ? (<br>         &lt;a onClick={() =&gt; setHidden(false)}&gt; read more&lt;/a&gt;<br>       ) : (<br>         &lt;a onClick={() =&gt; setHidden(true)}&gt; read less&lt;/a&gt;<br>       )}<br>     &lt;/span&gt;<br>  );<br>}</pre><h4><strong>Example 2: Updating state based on previous state</strong></h4><pre>function StepTracker() {<br>  const [steps, setSteps] = useState(0);</pre><pre>function increment() {<br>    setSteps(steps =&gt; steps + 1);<br>  }</pre><pre>return (<br>    &lt;div&gt;<br>      Today you&#39;ve taken {steps} steps!<br>      &lt;br /&gt;<br>      &lt;button onClick={increment}&gt;I took another step&lt;/button&gt;<br>    &lt;/div&gt;<br>  );<br>}</pre><p>useState를 사용하여 새로운 state를 생성한 후 초기값을 0으로 설정합니다. step 카운터를 증가하기 위해 increment 함수도 선언합니다. 함수 안에서 setSteps()를 사용하여 이전 state값을 업데이트합니다.</p><h4><strong>Example 3: state as an array</strong></h4><pre>function RandomList() {<br>  const [items, setItems] = useState([]);</pre><pre>const addItem = () =&gt; {<br>    setItems([<br>      ...items,<br>      {<br>        id: items.length,<br>        value: Math.random() * 100<br>      }<br>    ]);<br>  };</pre><pre>return (<br>    &lt;&gt;<br>      &lt;button onClick={addItem}&gt;Add a number&lt;/button&gt;<br>      &lt;ul&gt;<br>        {items.map(item =&gt; (<br>          &lt;li key={item.id}&gt;{item.value}&lt;/li&gt;<br>        ))}<br>      &lt;/ul&gt;<br>    &lt;/&gt;<br>  );<br>}</pre><p>state값은 다양한 타입이 될 수 있다고 위에서 언급했습니다. 초기값을 []로 설정하였으며, setItems 함수는 이전 값과 새로운 값을 merge 하지않습니다. 새로운 값을 배열에 추가하기 위해, ES6의 spread operator를 사용하여 기존에 존재하는 값을 복재하여 새로운 값을 추가합니다.</p><h4>Example 4: state with multiple keys</h4><pre>function LoginForm() {<br>  const [form, setValues] = useState({<br>    username: &#39;&#39;,<br>    password: &#39;&#39;<br>  });</pre><pre>const printValues = e =&gt; {<br>    e.preventDefault();<br>    console.log(form.username, form.password);<br>  };</pre><pre>const updateField = e =&gt; {<br>    setValues({<br>      ...form,<br>      [e.target.name]: e.target.value<br>    });<br>  };</pre><pre>return (<br>    &lt;form onSubmit={printValues}&gt;<br>      &lt;label&gt;<br>        Username:<br>        &lt;input<br>          value={form.username}<br>          name=&quot;username&quot;<br>          onChange={updateField}<br>        /&gt;<br>      &lt;/label&gt;<br>      &lt;br /&gt;<br>      &lt;label&gt;<br>        Password:<br>        &lt;input<br>          value={form.password}<br>          name=&quot;password&quot;<br>          type=&quot;password&quot;<br>          onChange={updateField}<br>        /&gt;<br>      &lt;/label&gt;<br>      &lt;br /&gt;<br>      &lt;button&gt;Submit&lt;/button&gt;<br>    &lt;/form&gt;<br>  );<br>}</pre><p>예시 3번과 같이 spread operator를 사용하여 값을 설정합니다. useState 뿐만 아니라, useReducer를 사용해서 코드를 좀 더 효과적으로 작성이 가능합니다.</p><p><a href="https://medium.freecodecamp.org/hooked-on-hooks-how-to-use-reacts-usereducer-2fe8f486b963">https://medium.freecodecamp.org/hooked-on-hooks-how-to-use-reacts-usereducer-2fe8f486b963</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=dfe8b2096750" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[리액트 아폴로(React Apollo) 리덕스와 무엇이 다른가?!]]></title>
            <link>https://medium.com/@shlee1353/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%95%84%ED%8F%B4%EB%A1%9C-react-apollo-%EB%A6%AC%EB%8D%95%EC%8A%A4%EC%99%80-%EB%AC%B4%EC%97%87%EC%9D%B4-%EB%8B%A4%EB%A5%B8%EA%B0%80-a4bfdb48bbc?source=rss-ee5dcb11357a------2</link>
            <guid isPermaLink="false">https://medium.com/p/a4bfdb48bbc</guid>
            <category><![CDATA[apollo-client]]></category>
            <category><![CDATA[apollo]]></category>
            <category><![CDATA[react]]></category>
            <category><![CDATA[react-apollo]]></category>
            <dc:creator><![CDATA[Seungho Lee]]></dc:creator>
            <pubDate>Thu, 28 Feb 2019 07:37:12 GMT</pubDate>
            <atom:updated>2019-04-23T16:04:19.078Z</atom:updated>
            <content:encoded><![CDATA[<p>최근들어, 네이버의 다양한 서비스에서 REST API의 단점을 보완하고 더욱더 개선된 인터넷 환경을 제공하기 위해, GraphQL을 기반으로 한 리액트 아폴로를 도입하기 시작했습니다. 그 결과, 기존에 사용하던 리덕스와 라이프사이클의 사용빈도가 줄어들면서 GraphQL과 hooks에 대한 기본개념 숙지가 중요해졌습니다.</p><p>이 글에서는 리덕스와 GraphQL 기반의 리액트 아폴로의 차이점을 설명하고, 리액트 아폴로를 사용하기 위한 간단한 개발 환경구축을 살펴보도록 하겠습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/796/1*z-LROfr9BoiuMhlra-_OZQ.png" /></figure><pre>// card.js<br><br>import React from &#39;react&#39;;<br>import { View, Text } from &#39;react-nativee&#39;;<br><br>export default ({ title, body }) =&gt; (<br>  &lt;View&gt;<br>    &lt;Text&gt;{title}&lt;/Text&gt;<br>    &lt;Text&gt;{body}&lt;/Text&gt;<br>  &lt;/View&gt;<br>);</pre><ol><li>만약, 기존 리덕스를 이용한 데이터 교환은 다음 아래와 같은 절차를 통해 이루어집니다.</li><li>&lt;CardDetail/&gt; 내부에서 &lt;Card/&gt; 랜더링을 하게되면,</li><li>&lt;CardDetail/&gt; 마운트 될 때, action creator는 action과의 dispatch를 통하여 리덕스에게 fetching 할 것을 알려줍니다.</li><li>Endpoint를 거쳐 데이터를 받으면, 그것을 사용하기 쉽게 구조화 합니다.</li><li>데이터 구조화가 완료되면, action을 통해 리덕스에게 fetch가 완료 되었다고 알려 줍니다.</li><li>리덕스는 reducer를 통해 받은 데이터를 사용하여 store에 있는 state tree를 업데이트합니다.</li><li>&lt;CardDetail/&gt;은 props를 통해서 데이터를 전달 받고 필터를 마치면, 자식 요소인 &lt;Card/&gt; 랜더링 될 때 전달합니다.</li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/720/1*QaEO-IoG5_vusbbC4PkooA.png" /></figure><p>&lt;Card/&gt; 컴포넌트 하나를 랜더링하기 위해 너무나도 많은 과정이 필요합니다. 이 외에도, 여러개의 Endpoint로 인한 복잡도 증가와 Overfetching &amp; Underfetching 문제가 있습니다. GraphQL 기반인 Apollo Client의 기본 원리에 대해 알아보기 전에 용어 정리를 간단히 하도록 하겠습니다. GraphQL은 Server API를 통해 정보를 주고받기 위해 사용하는 Query Language 입니다. GraphQL API는 보통 하나의 Endpoint를 사용하며, 요청시 사용하는 Query 문에 따라 응답의 구조가 달라집니다. Apollo Client는 클라이언트 애플리케이션에서 GraphQL과의 데이터 교환을 도우며, 특별히 리액트에서 사용하는 라이브러리를 리액트 아폴로(React Apollo)라고 부릅니다.</p><p>위 과정을, GraphQL을 사용하여 표현하면 어떻게 될까요? &lt;CardDetail/&gt;는 아래의 쿼리를 통해 fetch를 하는 HOC와 연결됩니다.</p><pre>query Card($id: Float!) { // Operation type<br>  match(id: $id) {        // Operation &quot;endpoint&quot;<br>    card {<br>      title               // Requested fields<br>      body<br>    }<br>  }<br>}</pre><p>이렇게 하면, &lt;Card/&gt;에 필요한 데이터를 props와 연결하여 자동으로 내려줍니다. 여기서는 컴포넌트가 랜더링 되기위해 필요한 데이터에만 집중하고 있습니다. Operation type에는 query, mutation, subscription이 존재하며 용도에 맞게 사용해야 합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/720/1*wtcMBaabTwyphlZq3lqCZg.png" /></figure><p>작성된 GraphQL query는 Apollo Client에서 컴포넌트와 함께 사용할 수 있습니다. 데이터를 받아올 때 사용하는 Query 컴포넌트에 대해 알아보도록 하겠습니다. 컴포넌트 사용에 필요한 것이 GraphQL query이며, query 문자열을 gql 함수로 감싸줘야합니다. 이것을 Query 컴포넌트에 query props로 추가합니다.</p><pre>import gql from &quot;graphql-tag&quot;;<br>import { Query } from &quot;react-apollo&quot;;<br><br>const GET_DOGS = gql`<br>  {<br>    dogs {<br>      id<br>      breed<br>    }<br>  }<br>`;<br><br>const Dogs = ({ onDogSelected }) =&gt; (<br>  &lt;Query query={GET_DOGS}&gt;<br>    {({ loading, error, data }) =&gt; {<br>      if (loading) return &quot;Loading...&quot;;<br>      if (error) return `Error! ${error.message}`;<br><br>      return (<br>        &lt;select name=&quot;dog&quot; onChange={onDogSelected}&gt;<br>          {data.dogs.map(dog =&gt; (<br>            &lt;option key={dog.id} value={dog.breed}&gt;<br>              {dog.breed}<br>            &lt;/option&gt;<br>          ))}<br>        &lt;/select&gt;<br>      );<br>    }}<br>  &lt;/Query&gt;<br>);</pre><p>Query 컴포넌트에 파라미터로 loading, error와 함께 Query 컴포넌트가 제공하는 data를 넘겨줍니다. 데이터를 받는 과정을 좀 더 자세히 살펴 보도록 하겠습니다. Qeury 컴포넌트가 마운트되면, Apollo Client는 query에 대한 옵저버를 생성합니다. 컴포넌트는 Apollo Client 캐시를 통하여 query에 대한 결과값을 구독합니다. 먼저, query 결과값을 Apollo 캐시로부터 가져옵니다. 없을경우, 서버로 요청을 보내며, 데이터를 받으면 Apollo 캐시에 저장을 합니다. Query 컴포넌트가 결과값을 구독하고 있기 때문에, 자동 업데이트 됩니다.</p><pre>const GET_DOG_PHOTO = gql`<br>  query Dog($breed: String!) {<br>    dog(breed: $breed) {<br>      id<br>      displayImage<br>    }<br>  }<br>`;<br><br>const DogPhoto = ({ breed }) =&gt; (<br>  &lt;Query query={GET_DOG_PHOTO} variables={{ breed }}&gt;<br>    {({ loading, error, data }) =&gt; {<br>      if (loading) return null;<br>      if (error) return `Error!: ${error}`;<br><br>      return (<br>        &lt;img src={data.dog.displayImage} style={{ height: 100, width: 100 }} /&gt;<br>      );<br>    }}<br>  &lt;/Query&gt;<br>);</pre><p>Apollo에서 캐시되는 과정을 위 코드로 살펴보도록 하겠습니다. 위 코드에서 DogPhoto는 breed를 props로 받고 있습니다. 이 값은 처음 작성한 Dogs 컴포넌트의 값을 반영한 것입니다. 여기서 variables라는 props 하나가 더 추가되었습니다. 이 값은 GraphQL query로 보내려고 하는 variables를 포함하고 있는 객체입니다.</p><p>GraphQL을 사용하기 위해서는 기본적인 서버 환경설정이 필요합니다.</p><p>1.schema.js 파일에 GraphQL 스키마를 작성해야 합니다. 여기에는 타입정의(type definition)가 필요합니다.</p><pre>let typeDefs =`<br>	type Channel {<br>		id: ID!<br>		name: String<br>	}<br>	<br>	type Query {<br>		channels: [Channel]<br>	}<br>`</pre><p>예로, ChannelList 컴포넌트가 있다면 데이터 교환을 위해 아래와 같은 쿼리를 작성할 수 있습니다. 쿼리정의는 라우터의 기능을 담당하고 있습니다.</p><pre>query ChannelsListQuery {<br>	channels {<br>		id<br>		name<br>	}<br>}</pre><p>2.다음으로, API-methods가 실행될 때 실행되는 함수를 선언해줘야 합니다. 이는 resolvers.js에 작성합니다. resolve 함수는 각각의 쿼리에 대해 서버가 어떻게 대응하는지를 정의하기 때문에 GraphQL의 핵심 요소입니다. MVC 패턴에서 컨트롤러 역할을 생각하면 됩니다.</p><pre>const channels = [{<br>	id: 1,<br>	name: &#39;soccer&#39;,<br>}, {<br>	id: 2,<br>	name: &#39;baseball&#39;,<br>}];<br><br>export const resolvers = {<br>	Query: {<br>		channels: () =&gt; {<br>			return channels;<br>		}<br>	}<br>}</pre><p>3.makeExecutableShcema를 사용하여 schema와 resolver를 머지합니다.</p><pre>// src/shcema.js<br><br>const shcema = makeExecutableShcema({ typeDefs, resolvers });<br>export { shcema }</pre><p>4.마지막으로, server.js를 작성하면 클라이언트와 통신하기 위한 어느정도의 준비가 완료됩니다.</p><pre>server.use(&#39;/graphql&#39;, bodyParser.json(), graphqlExpress({<br>	schema<br>}));</pre><p>위에서 작성한 코드를 GraphQL 전체적으로 봤을 때, 아래와 같은 그림으로 나타낼 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/720/1*K90eMhqRDBrkj_FtY1TlJw.png" /></figure><p>지금까지, 리덕스와 리액트 아폴로의 차이점 및 기본 환경 설정에 대해 알아봤습니다. 실제로 하나의 서비스를 만들기 위해서는 더 많은 추가 작업이 필요합니다. 처음 GraphQL을 접하시는 분들에게는 다소 생소할 수도 있다고 생각합니다. 정리하자면, REST API는 자원의 사이즈가 서버에 의해 결정되며, 지금까지 리덕스에 사용되어 왔습니다. 반면, GraphQL은 서버는 어떠한 자원을 사용할 수 있는지 정하고, 클라이언트에서 그때그때 필요한 것을 요청합니다. 어느것이 더 좋다고 말하기가 어려운 것이 서비스의 방향과 개발환경에 따라 어느 한쪽 또는 양쪽 모두를 사용할 수 있기 때문입니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a4bfdb48bbc" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[CSS 레이아웃 Normal Flow & Floats]]></title>
            <link>https://medium.com/@shlee1353/css-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-normal-flow-floats-bee7b8da72b4?source=rss-ee5dcb11357a------2</link>
            <guid isPermaLink="false">https://medium.com/p/bee7b8da72b4</guid>
            <category><![CDATA[css]]></category>
            <category><![CDATA[web]]></category>
            <category><![CDATA[web-development]]></category>
            <category><![CDATA[html]]></category>
            <category><![CDATA[web-design]]></category>
            <dc:creator><![CDATA[Seungho Lee]]></dc:creator>
            <pubDate>Thu, 07 Feb 2019 04:41:22 GMT</pubDate>
            <atom:updated>2019-02-07T08:12:33.273Z</atom:updated>
            <content:encoded><![CDATA[<p>CSS 페이지 레이아웃 기법 중 normal flow는 페이지 레이아웃을 제어하는 어떠한 것도 하지 않으면, 브라우저가 기본적으로 HTML을 레이아웃하는 방법입니다. (<a href="https://developer.mozilla.org/ko/docs/Learn/CSS/CSS_layout/Introduction">링크</a>)</p><pre>&lt;p&gt;I love my cat.&lt;/p&gt;<br>    <br>&lt;ul&gt;<br>  &lt;li&gt;Buy cat food&lt;/li&gt;<br>  &lt;li&gt;Exercise&lt;/li&gt;<br>  &lt;li&gt;Cheer up friend&lt;/li&gt;<br>&lt;/ul&gt;<br>    <br>&lt;p&gt;The end!&lt;/p&gt;</pre><p>HTML이 소스 코드에 나타나는 정확한 순서대로 표시되고 있습니다. CSS를 사용하여 레이아웃을 잡으면, 작업 요소를 normal flow에서 분리해 독립적으로 위치 수정이 가능합니다. CSS에서 요소 배치를 변경할 수 있는 방법은 다음과 같습니다.</p><ul><li>display: block, inline, inline-block</li><li>float</li><li>position</li><li>table</li><li>flex</li><li>grid</li></ul><h4>Floats</h4><p>float 속성은 본래는 이미지와 텍스트 배치 용도(메거진 스타일)로 등장했지만, 요즘에는 레이아웃을 만들기 위해 많이 사용하고 있습니다. float 속성은 block 레벨 엘리먼트의 행동을 바꿉니다. 왼쪽 또는 오른쪽으로 이동하며 normal flow로 부터 제거가 됩니다. float이 적용된 엘리먼트 뿐만 아니라, 주위를 둘러싸고 있는 엘리먼트 또한 float된 엘리먼트를 감싸게 만듭니다. (<a href="https://developer.mozilla.org/ko/docs/Learn/CSS/CSS_layout/Introduction">링크</a>)</p><pre>&lt;h1&gt;Simple float example&lt;/h1&gt;<br>    <br>&lt;div class=&quot;box&quot;&gt;Float&lt;/div&gt;<br>    <br>&lt;p&gt; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec lacus varius commodo et a urna. Ut id ornare felis, eget fermentum sapien.&lt;/p&gt;</pre><pre>.box {<br>    float: left;<br>    width: 150px;<br>    height: 150px;<br>    margin-right: 30px;<br>}</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/381/1*2x6uHsaXt30hCNw0HvudZA.gif" /></figure><p>clear 속성을 사용하면, float된 엘리먼트 주변 요소에게 float 속성을 무시하라고 말해줍니다. clear이 적용된 엘리먼트는 float이 적용된 엘리먼트 바로 뒤에 위치하게 됩니다. clear 속성은 block 요소에만 적용이 됩니다.</p><p>float된 엘리먼트를 포함하고 있는 부모 요소의 높이값은 0이 되어버립니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=bee7b8da72b4" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[자바스크립트 브라우저 이벤트 기초]]></title>
            <link>https://medium.com/@shlee1353/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EA%B8%B0%EC%B4%88-80fb8a97dd02?source=rss-ee5dcb11357a------2</link>
            <guid isPermaLink="false">https://medium.com/p/80fb8a97dd02</guid>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[event-handlers]]></category>
            <dc:creator><![CDATA[Seungho Lee]]></dc:creator>
            <pubDate>Thu, 31 Jan 2019 02:30:59 GMT</pubDate>
            <atom:updated>2019-01-31T02:30:59.154Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/657/1*H3suXnaM2YzFw2YdPJvg1w.png" /></figure><p>event는 무언가가 일어났다는 신호이며, 모든 DOM 노드는 이러한 신호를 발생할 수 있습니다. 가장 대표적인 이벤트 몇개를 소개합니다.</p><ul><li>click</li><li>contextmenu</li><li>mouseover / mouseout</li><li>mousedown / mouseup</li><li>mousemove</li><li>submit</li><li>focus</li><li>keydown / keyup</li><li>DOMContentLoaded</li><li>transitioned</li></ul><p>이벤트를 활성화 시키기 위해서는 이벤트 헨들러가 필요합니다. 헨들러를 할당하는 방법에는 여러가지가 있습니다.</p><ul><li>HTML 상에서 on&lt;event&gt; 속성으로 선언이 가능합니다.</li></ul><pre>&lt;input value=&quot;Click me&quot; onClick=&quot;alert(&#39;Click!&#39;)&quot; type=&quot;button&quot;&gt;</pre><ul><li>HTML 상에서 많은 코드작성은 비효율적이기 때문에 함수로 미리 만들어 놓는 방법을 지향합니다.</li></ul><pre>&lt;script&gt;<br>  function countRabbits() {<br>    for(let i=1; i&lt;=3; i++) {<br>      alert(&quot;Rabbit number &quot; + i);<br>    }<br>  }<br>&lt;/script&gt;<br><br>&lt;input type=&quot;button&quot; onclick=&quot;countRabbits()&quot; value=&quot;Count rabbits!&quot;&gt;</pre><ul><li>미리 선언해 놓은 함수를 엘리먼트에 바로 할당할 수도 있습니다.</li></ul><pre>function sayThanks() {<br>  alert(&#39;Thanks!&#39;);<br>}<br><br>elem.onclick = sayThanks;</pre><pre>elem.onclick = sayThanks(); // 잘못된 방법으로 undefined을 리턴합니다. 하지만, 마크업상에서는 () 이 필요합니다.</pre><ul><li>핸들러 내부에 선언되어 있는 this는 이벤트가 할당된 엘리먼트를 가리킵니다.</li></ul><pre>&lt;button onclick=&quot;alert(this.innerHTML)&quot;&gt;Click me&lt;/button&gt;</pre><ul><li>마크업에 선언되어 있는 이벤트 핸들러는 아래와 같이 해석됩니다.</li></ul><pre>&lt;input type=&quot;button&quot; id=&quot;button&quot; onclick=&quot;sayThanks()&quot;&gt;</pre><pre>button.onclick = function() {<br>  sayThanks(); // the attribute content<br>};</pre><ul><li>addEventListener을 사용하면 더욱더 효율적인 코드 작성이 가능합니다. 예로, 하나의 엘리먼트에 여러 이벤트 할당이 가능합니다.</li></ul><pre>function handler1() {<br>  alert( &#39;Thanks!&#39; );<br>}</pre><pre>function handler2() {<br>  alert( &#39;Thanks again!&#39; );<br>}</pre><pre>input.addEventListener(&quot;click&quot;, handler1);<br>input.addEventListener(&quot;click&quot;, handler2);</pre><pre>// ....<br>input.removeEventListener(&quot;click&quot;, handler1);</pre><ul><li>event 속성을 사용하여 타입을 분기처리하면 좀더 효율적인 코드 작성이 가능합니다.</li></ul><pre>&lt;button id=&quot;elem&quot;&gt;Click me&lt;/button&gt;<br><br>&lt;script&gt;<br>  class Menu {<br>    handleEvent(event) {<br>      switch(event.type) {<br>        case &#39;mousedown&#39;:<br>          elem.innerHTML = &quot;Mouse button pressed&quot;;<br>          break;<br>        case &#39;mouseup&#39;:<br>          elem.innerHTML += &quot;...and released.&quot;;<br>          break;<br>      }<br>    }<br>  }<br><br>  let menu = new Menu();<br>  elem.addEventListener(&#39;mousedown&#39;, menu);<br>  elem.addEventListener(&#39;mouseup&#39;, menu);<br>&lt;/script&gt;</pre><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=80fb8a97dd02" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[프론트앤드(Front-End) UI인터렉션 개발]]></title>
            <link>https://medium.com/@shlee1353/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%95%A4%EB%93%9C-front-end-ui%EC%9D%B8%ED%84%B0%EB%A0%89%EC%85%98-%EA%B0%9C%EB%B0%9C-86d0d203d533?source=rss-ee5dcb11357a------2</link>
            <guid isPermaLink="false">https://medium.com/p/86d0d203d533</guid>
            <category><![CDATA[front-end-development]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[ui-developer]]></category>
            <category><![CDATA[web-development]]></category>
            <category><![CDATA[web-font]]></category>
            <dc:creator><![CDATA[Seungho Lee]]></dc:creator>
            <pubDate>Wed, 26 Dec 2018 07:05:35 GMT</pubDate>
            <atom:updated>2019-01-03T09:17:00.366Z</atom:updated>
            <content:encoded><![CDATA[<h3>프론트엔드(Front-End) UI인터랙션 개발</h3><p>프론트엔드개발을 진행하면서 자주 사용할 법한 UI 인터렉션을 정리하였습니다. 부족한 실력으로 바닐라 자바스크립트를 사용하여 제작하였으며, 앞으로도 꾸준히 업데이트를 진행할 예정입니다. 인터렉션 스크린샷과 코드를 확인할 수 있습니다.</p><p><strong>1. 리뷰 평점주기 (</strong><a href="https://github.com/shlee1353/web-development-blog/blob/feature/fe-ui/src/js/01_rating.js"><strong>코드</strong></a><strong>)</strong></p><p>사용자가 리뷰 작성 시 평점을 줄 수 있는 UI 입니다. 총 1점~5점까지 선택이 가능합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/750/1*eq4vvy-v4GabztySzB2FaQ.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/750/1*yX2DBukGp__IpzTwygyPVA.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/750/1*ok8rLiMEGOa30boWQj1BEg.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/750/1*XJJKgwxXAqC_eq3kyGkGYw.png" /></figure><p><strong>2. 이미지 업로드 (</strong><a href="https://github.com/shlee1353/web-development-blog/blob/feature/fe-ui/src/js/02_upload.js"><strong>코드</strong></a><strong>)</strong></p><p>이미지를 업로드하는 UI로 파일을 선택 후, 업로드 상태를 0~100%로 보여줍니다. 추가된 이미지의 썸네일을 추출하여 화면상에 보여주며, 원하는 이미지를 삭제할 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/750/1*rNJGt1sIYGpJfFPdi4Apeg.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/750/1*PWgsllXnMXYph-79-hmSNg.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/750/1*R_zTXTDSRf9Kt22DPOiiHg.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/750/1*m3nuOn-C1_fuuKAoOtrIiw.png" /></figure><p><strong>3. API 통신 (</strong><a href="https://github.com/shlee1353/web-development-blog/blob/feature/fe-ui/src/js/03_api.js"><strong>코드</strong></a><strong>)</strong></p><p>XMLHttpRequest를 사용하여 간단한 API통신을 통하여 불러온 데이터를 화면에 리스트로 보여주는 UI입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/750/1*392i3acwK8rSup5sLsQSDg.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/750/1*H2uqcMtyyI3rGz87KHzs0g.png" /></figure><h4>GET</h4><pre>var xhr = new XMLHttpRequest();<br>xhr.open(&#39;GET&#39;, &#39;/server&#39;, true);<br><br>xhr.onload = function () {<br>  // Request finished. Do processing here.<br>};<br><br>xhr.send(null);</pre><h4>POST</h4><pre>var xhr = new XMLHttpRequest();<br>xhr.open(&quot;POST&quot;, &#39;/server&#39;, true);<br><br>//Send the proper header information along with the request<br>xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);<br><br>xhr.onreadystatechange = function() { // Call a function when the state changes.<br>    if (this.readyState === XMLHttpRequest.DONE &amp;&amp; this.status === 200) {<br>        // Request finished. Do processing here.<br>    }<br>}<br>xhr.send(&quot;foo=bar&amp;lorem=ipsum&quot;);</pre><p><strong>4. 동영상 이미지 추출 (</strong><a href="https://github.com/shlee1353/web-development-blog/blob/feature/fe-ui/src/js/04_video.js"><strong>코드</strong></a><strong>)</strong></p><p>동영상의 이미지를 초 단위 또는, 랜덤하게 캡쳐하는 UI입니다. 평소 원하는 동영상에서 이미지를 가져올 때 편리하게 가져올 수 있을 것 같아 제작하였습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*MJMv5TA6f5Ftkveu4yypLw.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*NlY25KOGgC6htZKrjJEb3A.png" /></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=86d0d203d533" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>