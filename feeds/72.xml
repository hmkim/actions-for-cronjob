<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Hyeokwoo Alex Kwon on Medium]]></title>
        <description><![CDATA[Stories by Hyeokwoo Alex Kwon on Medium]]></description>
        <link>https://medium.com/@khwsc1?source=rss-4584900007e7------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*n4VB9UbNNoB78-vGIhulag.jpeg</url>
            <title>Stories by Hyeokwoo Alex Kwon on Medium</title>
            <link>https://medium.com/@khwsc1?source=rss-4584900007e7------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Sun, 12 May 2019 10:47:06 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@khwsc1" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[쉽고 빠르게 SNS 만들기 — Stream으로 트위터를 만들어 보자!]]></title>
            <link>https://medium.com/@khwsc1/stream%EC%9C%BC%EB%A1%9C-%EC%89%BD%EA%B3%A0-%EB%B9%A0%EB%A5%B4%EA%B2%8C-%EB%89%B4%EC%8A%A4%ED%94%BC%EB%93%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0-%ED%8A%B8%EC%9C%84%ED%84%B0%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4-%EB%B3%B4%EC%9E%90-39ba19d6b886?source=rss-4584900007e7------2</link>
            <guid isPermaLink="false">https://medium.com/p/39ba19d6b886</guid>
            <category><![CDATA[api-integration]]></category>
            <category><![CDATA[api]]></category>
            <category><![CDATA[newsfeed]]></category>
            <dc:creator><![CDATA[Hyeokwoo Alex Kwon]]></dc:creator>
            <pubDate>Sat, 09 Feb 2019 08:41:07 GMT</pubDate>
            <atom:updated>2019-02-09T08:42:16.152Z</atom:updated>
            <content:encoded><![CDATA[<h3>쉽고 빠르게 SNS 만들기 — Stream으로 트위터를 만들어 보자!</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dkdnHzKX5Qf0jdlDXmjAiA.png" /></figure><p>최근에는 많은 온라인 서비스들이 뉴스피드 기능을 제공하고 있습니다. 페이스북, 트위터와 같은 소셜 미디어 서비스 뿐만 아니라 Strava, Spotify 그리고 최근 개편한 토스에서도 타임라인에 따른 컨텐츠를 보여주는 방식의 피드가 제공되고 있죠. 심지어 B2B서비스들에도 타임라인 피드를 제공하는 서비스도 있습니다. 그만큼 뉴스피드 기능을 활용하여 컨텐츠를 제공하는 방식이 인기를 끌고 대중에게 익숙해졌다는 것입니다.</p><p>엔지니어의 입장에서는 새로운 서비스 애플리케이션을 개발할 때, 뉴스피드 기능을 구현해야 할 필요성이 높아졌다는 뜻입니다. 하지만 실제 제품에 사용한 만한 확장 가능하고 퍼포먼스가 뛰어난 뉴스피드를 구현하기는 정말 어렵습니다. 제대로 만들기 위해서는 수많은 시간과 고도의 기술이 필요하기 때문이죠.</p><p>만약 In-house로 직접 뉴스피드 기능을 개발한다고 했을때 다음과 같은 서버들이 동시에 존재해야 합니다.</p><ul><li>API 서버들</li><li>메시지 브로커</li><li>오토스케일링 클러스터</li><li>데이터베이스 클러스터</li><li>실시간 처리를 위한 인프라</li><li>Redis를 활용한 실시간 처리와 lock 핸들링</li><li>분석을 위한 인프라</li></ul><p>이것들을 구현하고 관리하는 것만 해도 어마어마한 비용과 시간이 소요될 것이라는 것을 직감적으로 느낄 수 있죠 😖</p><p>저 또한 새로운 앱에 뉴스피드 기능을 넣으려고 기술 기반을 알아보다가 위와 같은 것들을 모두 준비해야 한다고 생각하니 한숨부터 나오더라구요. 그래서 더 쉽게 구현할 수 있는 방법이 무엇이 있을지 열심히 검색을 해보니, 뉴스피드 기능을 쉽게 구현할 수 있는 Stream이라는 API서비스를 찾게 되었습니다!</p><p>Stream은 뉴스 피드와 활동 스트림(activity stream)을 손쉽게 구현할 수 있는 API 서비스 입니다. 위에서 언급한 기술적인 제반 사항을 따로 구현할 필요 없이, Stream을 사용하여 확장 가능한 뉴스 피드 서비스를 상대적으로 편리하게 개발할 수 있죠.</p><h3>트위터 타임라인 만들기</h3><p>간단하게 트위터 클론을 만들어 보면서 Stream을 익숙해져 보도록 하겠습니다. 먼저, <a href="https://getstream.io">https://getstream.io</a>에 접속하신 후에 새로운 계정을 생성 해주세요.</p><blockquote>본 포스트의 예제는 Stream에서 제공하는 <a href="https://getstream.io/get_started/">인터렉티브 튜토리얼</a>의 예제를 차용했습니다. 해당 페이지에서 한번 API콜을 날려보시면 훨씬 쉽게 이해하실 수 있을거에요!</blockquote><p>그 다음, 대시보드에 접근해서 새로운 프로젝트를 생성해 주세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*FWezYXuZ1yHY3EvcMGVWBg.png" /></figure><p>저는 twitter-clone이라는 이름의 프로젝트를 새로 만들었습니다. 아직 사용 가능한 서버의 리전은 US East, EU West, Tokyo, Singapore 뿐이기 때문에 한국과 가까운 도쿄 리전으로 선택했습니다.</p><p>프로젝트를 생성하고 나면 새로운 피드 그룹(Feed Group)을 생성할 수 있습니다. 저희는 두 개의 피드 그룹을 생성할 껀데요, user와 user_timeline 그룹을 각각 Flat 유형으로 선택해서 만들어 주세요.</p><blockquote>Stream은 세 가지의 피드 유형을 제공합니다. 일반적으로 팔로잉 가능한 Flat 피드, 액티비티를 요약할 수 있는 Aggregated 피드, 그리고 실시간 알림을 위한 Notification이 있습니다. 피드 유형에 대한 자세한 설명은 <a href="https://getstream.io/docs/js/#notification-feeds">여기</a>에서 확인하실 수 있습니다.</blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*HWR8ms7vjK1UGuHLEAeFtA.png" /></figure><p>위와 같이 피드의 이름과 피드의 유형을 선택할 수 있습니다. user와 user_timeline을 모두 Flat 유형으로 선택해 주세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*NaddBBLPaekVUd-EBTMytA.png" /></figure><p>위와 같이 user, user_timeline 피드 그룹을 각각 Flat 유형으로 생성했습니다. Flat 피드는 바로 팔로우(follow)할 수 있다는 특징이 있는 가장 대표적인 유형입니다. 타임라인을 구성할 때 Flat피드를 사용하고, 액티비티를 추가할 수 있죠.</p><h4>트윗 생성하기</h4><p>이제 피드 그룹이 준비 되었으니, 본격적으로 Stream을 활용하여 트위터 기능을 구현해보도록 하겠습니다. 다음과 같이 코드를 작성하여 새로운 트윗을 작성하는 로직을 구현할 수 있습니다.</p><blockquote>저는 nodejs가 편해서 JS로 예시 코드를 작성하겠습니다. Stream은 REST API로 제어 가능하고, 다양한 언어별로 클라이언트 라이브러리를 제공하고있습니다. Ruby, JS, Python, Java, Go, PHP, .Net, Swift 에 대해서 클라이언트를 지원하고 있고, 자세한 사항은 <a href="https://getstream.io/docs/">Stream 문서</a>에서 확인하실 수 있습니다.</blockquote><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/e23bebce9844d84fd64333e510e245da/href">https://medium.com/media/e23bebce9844d84fd64333e510e245da/href</a></iframe><p>위의 예제에서, 먼저 유저의 ID를 토대로 user 피드 그룹에 대해 1번 유저의 피드를 userOneFeed 로 만들어 냈습니다. 그 후, DB에 새로운 트윗을 생성하고 새로운 액티비티 객체를 만들어 addActivity() 메소드를 호출하여 새로운 액티비티를 추가합니다. 이 때, actor 에는 유저 ID, verb에는 유저의 행동 그리고 object 속성에는 행동의 객체(여기서는 새로 만든 트윗)에 대한 정보를 작성하면 됩니다.</p><p>위와 같이 작성하면, Stream서버에 어떤 유저가 피드에 무슨 행동을 했는지를 기록하게 됩니다. 지금 저희는 1번 유저가 자신의 피드에 새로운 트윗을 작성하는 행동을 기록한 것이죠.</p><h4>유저 팔로우</h4><p>이제 1번 유저의 피드에 트윗이 작성되었으니, 2번 유저가 1번 유저를 팔로우 하여 2번 유저의 타임라인 피드에서 팔로윙한 유저의 트윗을 확인 할 수 있습니다. 다음과 같이 코드를 작성하여 팔로잉 할 수 있습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/4e32f4dd71d16019268a4c248b1a0371/href">https://medium.com/media/4e32f4dd71d16019268a4c248b1a0371/href</a></iframe><p>클라이언트를 활용하여 user_timeline 피드 그룹에 대해서 유저 ID 2에 대한 피드 객체인userTwoTimelineFeed 를 생성했습니다. 이 타임라인 피드는 유저가 팔로잉한 유저의 트윗정보를 담아야 하죠. 그렇기 때문에 user_timeline 이 user 를 팔로우하게 됩니다. 위에서는 userTwoTimelineFeed.follow() 메소드를 활용하여 1번 유저의 user 피드를 팔로우 했습니다.</p><p>1번 유저의 user피드를 2번 유저가 팔로우 했으니, 이제 1번 유저의 피드에 새로운 트윗이 작성되면 자동으로 2번 유저의 user_timeline 에서 새 트윗을 확인 할 수 있습니다! 😎</p><h4>타임라인 불러오기</h4><p>이제 2번 유저의 구성된 타임라인을 불러오도록 해볼께요. 타임라인은 user_timeline 피드 그룹을 활용하고 있기 때문에, 다음과 같이 해당 피드의 내용을 get() 메소드를 활용하여 불러올 수 있습니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f979417c30fdde65232f7af4da54ab5a/href">https://medium.com/media/f979417c30fdde65232f7af4da54ab5a/href</a></iframe><p>위와 같이 2번 유저의 타임라인에서 최근 10개의 항목을 불러왔습니다. 간단하죠? 불러온 데이터의 object 항목의 ID를 DB에서 조회하여 클라이언트에게 데이터를 전달하기만 하면 됩니다 👻</p><h3>활동 스트림 만들기</h3><p>일반적으로 자주 사용하는 소셜 미디어 기능은 위의 Flat 유형의 피드를 활용하여 구현할 수 있습니다. 글을 작성하고, 특정 유저를 팔로우하고, 팔로우한 유저들의 글을 시간순으로 구성되는 타임라인을 구성하는 것 말이죠.</p><p>하지만 페이스북이나 인스타그램에서 볼 수 있는 또 다른 화면이 있습니다. 바로 내가 팔로우하는 유저의 활동 정보를 보여주는 활동 스트림이죠.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/400/1*wN2w1eqSJo6a7wv0BxoEZw.png" /></figure><p>이러한 정보는 어떤 유저가 어떤 활동을 했는지 간단하게 요약해서 나타냅니다. 특정 유저가 특정 활동을 <strong>몇 번 </strong>수행했는지 정리해서 나타내죠. 위의 인스타그램 화면에서는 <em>‘게시물 8개를 좋아 합니다’</em> 와 같이 요약된 정보를 보여주고 있네요. ❤️</p><p>이러한 기능 또한 Stream의 Aggregated 피드 타입을 통해 손쉽게 구현할 수 있습니다. 저희도 위와 같은 기능을 바로 구현해 보죠!</p><h4>유저 팔로우 by Aggregated 피드</h4><p>다시, Stream의 대시보드로 돌아오셔서 user_timeline_aggregated 라는 이름의 새로운 피드 그룹을 만들어 주세요. 이 피드는 Aggregated 유형으로 설정하시면 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*z07-vW--xckP4BrFJ2LmNQ.png" /></figure><p>그 다음 특정 유저를 팔로우 할때, Aggregated 피드가 팔로우 하도록 코드를 작성합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/0729127fe1c10f57e2ea8374e0854ec9/href">https://medium.com/media/0729127fe1c10f57e2ea8374e0854ec9/href</a></iframe><p>저희가 위에서 user_timeline 이 다른 유저를 팔로우 할 때와 같은 메소드를 사용합니다. 실제 프로덕션 앱이라면, 팔로잉 하는 로직을 처리하는 부분에서 user_timeline 과 user_timeline_aggregated 가 동시에 user 를 팔로우 하면 되겠네요.</p><h4>Aggregated 타임라인 불러오기</h4><p>이제 팔로우한 유저들의 활동 스트림을 불러오도록 하겠습니다. 다음과 같이 user_timeline_aggregate 피드 그룹의 항목을 get() 메소드를 사용하여 호출합니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/9151f4e9cb3405be31144976e1c166f4/href">https://medium.com/media/9151f4e9cb3405be31144976e1c166f4/href</a></iframe><p>반환된 결과 데이터에 액티비티들의 정보와 그에 대한 count까지 모두 담겨있네요! 이 데이터를 활용해서 인스타그램의 팔로잉 활동 스트림과 비슷한 화면을 구성할 수 있습니다.</p><h3>정리하며</h3><p>직접 구현하기에는 굉장한 시간과 기술적 난이도가 요구되는 뉴스피드와 활동 스트림 기능을 Stream의 API를 통해서 쉽게 개발할 수 있었습니다. 물론 외부 서비스에 의존적인 아키텍쳐가 될 수 밖에 없지만, 빠르고 값싼 기능 구현을 위해서는 괜찮은 타협점이라고 생각됩니다. 이와 같은 API서비스가 더 많아지면 좋겠네요!</p><p>Stream에는 본 포스트에서 소개 되지 않은 다양한 기능들이 더 있습니다. Stream문서를 자세히 살펴보시면 좋을것 같습니다.</p><p>긴 글 읽어주셔서 감사합니다 😁</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=39ba19d6b886" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[코딩 없이 10분 만에 REST API/Graphql 서버 개발하기]]></title>
            <link>https://medium.com/@khwsc1/js%EB%A1%9C-10%EB%B6%84%EB%A7%8C%EC%97%90-rest-api-graphql-%EC%84%9C%EB%B2%84-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0-d28148dbdef2?source=rss-4584900007e7------2</link>
            <guid isPermaLink="false">https://medium.com/p/d28148dbdef2</guid>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[strapi]]></category>
            <dc:creator><![CDATA[Hyeokwoo Alex Kwon]]></dc:creator>
            <pubDate>Sun, 27 Jan 2019 01:36:29 GMT</pubDate>
            <atom:updated>2019-01-27T03:48:57.094Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*uAzSmir6YMhOI0KncOmYqg.png" /></figure><p>스타트업에서 가장 중요한 건 빠르고 값싸게 비즈니스 모델을 실험하는 것입니다. 그리고 비즈니스 모델이 검증되면 재빠르게 제품을 만들어 내야 하죠. 최소한 알파버전으로라도 런칭을 해야 하니까요.</p><p>그래서 저는 값싸고 빠르게 개발하는 방법에 언제나 관심을 가지고 있습니다. 그래서 저는 프론트엔드의 영역에서는 웹과 앱을 모두 만들어 낼 수 있는 리액트를 선택했죠. 마찬가지로 서버 개발을 빠르고 쉽게 할 수는 없을까? 라는 의문을 가지고 있었습니다.</p><p>사실 API 서버 개발을 위한 프레임워크나 라이브러리는 수두룩하게 많습니다. 하지만 제가 항상 힘들었던 것은, 리소스를 편리하게 관리할 백 오피스, 즉 관리자 웹 사이트를 만드는 것이었습니다. 그래서 nodejs로 API 서버와 관리자 페이지를 한 번에 만드는 툴을 열심히 찾아보게 되었죠.</p><p>수많은 구글링 와중에 괜찮아 보이는 녀석을 발견했습니다! <a href="https://strapi.io/">strapi</a>라는 라이브러리인데요, headless CMS를 표방하고 있는 프로젝트 입니다.</p><p>간단하게 특징을 살펴보면</p><ul><li><strong>관리자 페이지 제공</strong> — 컨텐츠 관리, 모델링</li><li><strong>RESTful API 및 Graphql 사용 가능</strong></li><li><strong>다양한 DB연동</strong> — mongo, postgresql, mysql 등</li><li><strong>커스터마이징</strong> — 원하는 로직으로 코드 수정</li><li><strong>CLI 제공</strong> — API 생성 과 같은 기능을 CLI로 제공</li></ul><p>와 같은 기능들이 있습니다. 제가 항상 고민했던 관리자 페이지를 제공해 주고, 원하는 대로 코드를 수정하여 로직을 커스터마이징 할 수 있다는 것이 큰 장점으로 다가왔습니다. 그리고 프론트엔드 개발을 10배 빠르게 만들어주는 graphql 을 사용할 수 있다는 점도 장점입니다.</p><p>그럼 바로 strapi를 활용해서 간단한 커뮤니티 사이트의 API 서버를 만들어 보도록 하겠습니다.</p><h3>1. 데이터베이스 생성하기</h3><p>API 서버를 생성하기 전에 strapi에서 사용할 데이터베이스를 생성해야 합니다. 안타깝게도 strapi는 데이터베이스를 자동으로 생성해주지는 않기 때문에 따로 DB를 생성하겠습니다.</p><blockquote>도커를 사용하셔도 좋지만 이번 튜토리얼에서는 조금 더 편리하게 mlab의 mongodb를 사용하도록 하겠습니다.</blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*XT5udFMPXzqlAgKOHzKaVg.png" /></figure><p>먼저 <a href="https://mlab.com/">mlab</a>에 접속하신 후에 무료 DB를 생성하기 위해 계정을 만들어 주세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*NSxFCJ8RxG4q8t_a-basFg.png" /></figure><p>계정을 만드시고 로그인이 되셨으면, 새로운 mongodb를 배포하실 수 있습니다. 화면 우측 상단의 <strong>Create New </strong>버튼 클릭 후, 원하는 클라우드 플랫폼을 선택하신 후, <strong>SANDBOX</strong> 플랜을 선택해 주세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*oGGzXrg70Z2TZet-qtr3hA.png" /></figure><p>그 다음 DB의 리전을 선택해 주세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*CFd6dg-U52Lnla-CgVIyQw.png" /></figure><p>그 다음 데이터베이스 이름을 설정할 수 있는데요, 커뮤니티 사이트용 DB이기 때문에 <strong>community</strong>라는 이름으로 지정했습니다. 여러분이 원하는 데이터베이스 이름으로 작성해 주세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*TbGSSPPsUeLuKB7vk1U75A.png" /></figure><p>데이터베이스가 성공적으로 생성되었습니다! 그런데 DB에 접근하기 위해서는 데이터베이스 계정을 생성해야 합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*vx5Wgut1DXSLETcslN5dWw.png" /></figure><p>Users 탭을 선택하신 후, <strong>Add database user</strong>버튼을 클릭하시면 새로운 계정을 생성하실 수 있습니다. 여러분이 원하는 내용을 계정을 생성해 주세요. 저는 admin이라고 지었어요.</p><h3>2. Strapi 생성하기</h3><p>이제 데이터베이스는 성공적으로 생성했으니, 본격적으로 strapi를 활용해서 API서버를 만들어 보도록 하겠습니다.</p><p>API 서버를 만들기 위해서는 strapi를 통해 프로젝트를 새로 생성해야 합니다. 여러분의 터미널을 여신 후에 다음의 명령어로 strapi를 설치해 주세요.</p><blockquote>nodejs v10, npm v6 이상이 설치되어 있어야 합니다.</blockquote><pre>npm install strapi@alpha -g</pre><p>설치가 완료 되었으면 다음 명령어를 통해 strapi가 정상적으로 설치 되었는지 확인해 볼께요.</p><pre>strapi -v</pre><p>위의 명령어를 입력해서 3.0.0-alpha.x 와 같은 버전 이름이 나타난다면 성공적으로 설치되었다는 것을 알 수 있습니다!</p><p>이제 프로젝트를 담을 디렉토리로 이동하신 후 다음의 명령어를 통해 새로운 strapi 프로젝트를 생성하겠습니다.</p><pre>strapi new my-community</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*WHWkEv_xbKATyUC6MCvsUA.png" /></figure><p>위의 명령어를 실행하면 Strapi CLI가 여러가지 질문을 하게 됩니다. 이 때, 여러분이 mlab에서 생성한 DB정보를 입력하면 됩니다.</p><p>mlab에서 DB를 생성하면 다음과 같은 주소를 확인 할 수 있는데요:</p><pre>ds113495.mlab.com:13495/community</pre><p>이 주소에서 확인할 수 있듯이, 여러분이 만든 DB 정보와 계정 정보를 다음과 같이 CLI에 입력하면 됩니다.</p><pre>Choose your main database:<br>&gt; MongoDB</pre><pre>Database name:<br>&gt; Community</pre><pre>Host:<br>&gt; ds113495.mlab.com // DB 주소의 호스트</pre><pre>+srv connection:<br>&gt; false</pre><pre>Port (It will be ignored if you enable +srv):<br>&gt; 13945 // DB 주소의 포트</pre><pre>Username:<br>&gt; admin // mlab에서 생성한 계정 username</pre><pre>Password:<br>&gt; ********* // 계정 패스워드</pre><p>Strapi 프로젝트가 성공적으로 설치 되었으면 서버를 바로 실행 해보도록 할께요! 프로젝트 디렉토리로 이동 하신 후 strapi start 명령어를 실행하시면 됩니다.</p><h3>3. 관리자 페이지 접근하기</h3><p>로컬 머신에서 위의 방법으로 Strapi 서버를 실행하셨으면, localhost:1337/admin 에 접속하여 관리자 페이지에 접근할 수 있습니다. 처음 실행하여 접속하게 되면 다음과 같은 화면이 나타납니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*1Ss6s2tYqs_srhhwGobPbw.png" /></figure><p>여러분의 서버의 루트 관리자 계정을 생성을 안내하고 있네요! 항목을 입력하여 바로 계정을 만들어보도록 하겠습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*95z5GtYN-lVoYLNBSrTquw.png" /></figure><p>계정을 생성하고 나면 위와 같이 관리자 페이지에 접근하게 됩니다. 이제 본격적으로 커뮤니티 사이트를 위한 API를 개발해보도록 할께요!</p><h3>4. DB 모델링</h3><p>저희가 예시로 든 커뮤니티는 간단한 구조로 되어있습니다. 마치 DC 인사이드와 비슷하다고 생각하면 될 것 같아요. 게시글을 작성할 수 있는 게시판(board)이 있을 테고, 각 게시판 별로 글(post)를 작성하게 되고, 글마다 댓글(comment)을 달 수 있을 겁니다.</p><p>그러면 필요한 것은 네 개의 모델이 되겠네요. User, Board, Post 그리고 Comment 입니다. 각각의 속성은 다음과 같습니다.</p><pre>User<br>- username<br>- posts* // Post : User = M : 1<br>- comments* // Comment : User = M : 1</pre><pre>Board<br>- title<br>- posts* // Post : Board = M : 1</pre><pre>Post<br>- title<br>- content<br>- user* // Post : User = M : 1<br>- board* // Post : Board= M : 1<br>- comments* // Comment : Post = M : 1</pre><pre>Comment<br>- content<br>- user* // Comment : User = M : 1<br>- post* // Comment : Post = M : 1</pre><p>위와 같이 모델을 구성하면 기본적인 커뮤니티 앱을 만들 수 있습니다.</p><p>Strapi에서는 관리자 페이지에서 모델링을 할 수 있습니다. 모델의 이름을 정의하고, 속성 이름과 자료형을 UI로 정의하면, 그에 맞춰 자동으로 API를 생성해주죠. 저희도 위의 모델에 맞춰 바로 만들어 보도록 하겠습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*J7iPVM7_Ns7DgHZ5PNHLgg.png" /></figure><p>먼저 좌측 메뉴 리스트에서 <strong>콘텐츠 타입 빌더 </strong>메뉴에 접근하고 <strong>콘텐츠 타입 추가</strong> 버튼을 클릭합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*WNW0V5I6n4LE12QjLtqKJw.png" /></figure><p>그 다음 Board 모델을 만들기 위해 이름 필드에 board를 작성하고 저장 버튼을 눌러주세요.</p><p>그 다음 필드 추가 버튼을 눌러서 Board 모델에 필요한 필드를 추가해 봅시다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*CgM_ByB9bSyyyjG4SMT8DQ.png" /></figure><p>일단 Board의 title 속성을 문자(string) 자료형으로 추가했습니다. 그 후 저장을 눌러 모델을 생성해 주세요.</p><p>위와 같은 방법을 통해 이번에는 Post 모델을 생성해 봅시다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*AgprB8kvWzOi-0AJlf0izQ.png" /></figure><p>먼저 기본적인 자료형을 가지는 title과 content 속성을 추가하고, 각각 문자(string)과 텍스트(text) 로 지정했습니다.</p><p>그런데 Post 모델은 Board, User, Comment와 관계를 가지기 때문에 이들 모델과의 관계를 설정해야 합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*XM0ogBPQT0C_ILxye3OFhA.png" /></figure><p>필드 추가 버튼을 클릭한 후, 관계 자료형을 선택해 주세요. 그러면 위와 같이 다른 모델과의 관계를 설정할 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*bYd3-Ko05xHuhiFMELroJQ.png" /></figure><p>이와 같은 과정을 통해 board와 user 속성을 추가로 작성하고 모델을 저장하세요.</p><blockquote>Strapi는 프로젝트를 생성할 때 User 모델을 기본적으로 생성합니다. 여기에서는 Strapi가 만들어 낸 User 모델을 사용했습니다.</blockquote><p>지금까지의 과정을 통해, 저희가 위에서 설계한 모델대로 Board, Post, Comment 모델을 추가로 생성할 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*b3KVO3WXk4XWm29507X48w.png" /></figure><p>모델을 전부 작성하면 위와 같이 설계 되었음을 확인할 수 있습니다!</p><h3>5. API 사용하기</h3><p>Strapi는 위와 같은 방법으로 모델링을 하게 되면 자동으로 API 엔드포인트를 만들어 내고 그 로직을 처리하는 컨트롤러를 자동으로 생성합니다. 따라서, 위의 방법으로 모델링을 하셨다면 바로 API를 사용하실 수 있습니다!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*bQIbdUfQGHmrakWllzZ94Q.png" /></figure><p>API를 사용하기 전에 간단하게 데모 데이터를 만들어 보도록 하겠습니다. 게시판, 포스트 그리고 댓글들을 직접 작성해 보세요. 데이터는 관리자 페이지 왼쪽 메뉴 리스트에 각 모델에 맞는 Content Type 메뉴에서 추가할 수 있습니다.</p><p>본격적으로 API를 사용하기 전에 각 모델별로 API 권한을 설정해야 합니다. 관리자 페이지에서 역할 &amp; 권한 메뉴에서 설정할 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*h6zLu_2yepzwBM1opl2TPw.png" /></figure><p>Strapi는 세 가지로 권한을 나누어 놨습니다. Administrator, Authenticated 그리고 Public입니다. Administrator는 말 그대로, 관리자 사용자의 역할입니다. Authenticated는 가입하여 로그인 한 사용자(token을 제공한 사용자)의 역할이고, Public은 로그인 하지 않은 사용자의 역할 입니다.</p><p>저희는 게시판과 그 게시물에 대한 조회는 Public 역할에서도 할 수 있도록 변경해야 해요. 그래야 로그인하지 않은 사용자도 게시물과 댓글을 볼 수 있을 테니까요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*AQ7J-Mni3RT1dunT7NygpA.png" /></figure><p>Public 역할 페이지에 접근하시면 위의 화면과 같이 해당 역할이 각 모델에 대해 가지는 권한을 설정할 수 있습니다. Public은 조회만 가능하게 할 것이기 때문에 Board, Post, Comment에 대해서 count, find, findone 권한을 부여해 주세요. 그 다음 좌측 상단의 저장 버튼을 클릭해 주세요.</p><p>그 다음 바로 API에 요청을 생성하여 데이터를 받아보도록 하겠습니다. 여러분의 브라우저에서 http://localhost:1337/posts에 접근해 보세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*w9lPGodRXoJkgNfgWae_Ig.png" /></figure><p>제가 아까 작성한 데모데이터를 위와 같이 확인할 수 있네요. /posts 위치에 GET 요청을 생성했더니, DB에 저장된 모든 게시물들의 데이터를 응답하는 것을 확인할 수 있습니다. 이와 같이 리소스들을 조회하는 API가 생성되었다는 것을 확인 할 수 있죠.</p><p>조회 API 뿐만아니라 생성, 업데이트 그리고 삭제 권한을 부여해서 실험할 수 있습니다. postman같은 도구를 사용해서 API를 실험해 보세요! API 요청에 대한 자세한 내용은 <a href="https://strapi.io/documentation/3.x.x/getting-started/quick-start.html#_5-consume-the-api">strapi 문서</a>에서 확인해 보세요.</p><h3>6. GraphQL 사용하기</h3><p>Strapi에서는 기본으로 제공하는 RESTful API 뿐만 아니라 GraphQL를 활용할 수도 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*TL-mSZk6MO61D9wRqf55qA.png" /></figure><p>먼저 관리자 페이지에서 마켓 플레이스 페이지에 접근해 주세요. 해당 페이지에는 Strapi에서 사용할 수 있는 여러가지 플러그인들을 확인할 수 있습니다. 목록 중에서 GRAPHQL 플러그인 항목의 다운로드 버튼을 클릭 해 주세요. 클릭 후에 조금만 기다리면 설치가 완료됩니다.</p><p>설치가 완료되었으면 http://localhost:1337/graphql 에 접근해서 graphql playground에 접근 할 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*spxcVCZMgslfpgqDSw6bEQ.png" /></figure><p>여기에서도 마찬가지로 쿼리를 작성하여 데이터를 요청할 수 있죠. 좌측 영역에 다음과 같은 내용으로 쿼리를 작성하고 실행 해 보세요.</p><pre>query {<br>  boards {<br>    title<br>    posts {<br>      title<br>      content<br>      comments {<br>        content<br>      }<br>    }<br>  }<br>}</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*lqFAEyBh2Y47BmTXDBZHdw.png" /></figure><p>위와 같이 요청한 쿼리의 내용과 구조에 맞춰 데이터가 응답 되는것을 확인할 수 있습니다.</p><p>정말 손쉽게 graphql을 적용했네요!</p><h3>정리하며</h3><p>Strapi 라이브러리를 사용하면 빠르게 기본적인 서버 개발을 마칠 수 있었습니다. 물론 실제로 프로덕션에서 활용하기 위해선 코드를 직접 수정하여 커스터마이징 해야겠지만, 간단하게 데이터를 처리할 API 서버를 만들 수 있었습니다. 또, 백엔드 시스템에 익숙하지 않은 경우에 UI를 활용하여 모델링을 하는 것도 나쁘지 않은 사용자 경험이라고 생각합니다.</p><p>저는 곧 <a href="https://www.learnit.co.kr/study/programming/react_js/">리액트 강의</a>를 하게 되는데, 그 때 Strapi를 통해 직접 서버를 구축하고 그 위에 프론트 앱을 작성하는 컨텐츠를 작성해보려 합니다. 아무래도 쉽고 빠르게 API 서버를 만들 수 있으니까요!</p><p>긴 글 읽어주셔서 감사합니다 😁</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d28148dbdef2" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[자바스크립트 ES6 — Set에 대해 알아보자 ]]></title>
            <link>https://medium.com/@khwsc1/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-es6-set%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90-9b7294dfba99?source=rss-4584900007e7------2</link>
            <guid isPermaLink="false">https://medium.com/p/9b7294dfba99</guid>
            <category><![CDATA[es6]]></category>
            <category><![CDATA[javascript]]></category>
            <dc:creator><![CDATA[Hyeokwoo Alex Kwon]]></dc:creator>
            <pubDate>Sun, 13 Jan 2019 03:45:13 GMT</pubDate>
            <atom:updated>2019-01-13T03:45:13.760Z</atom:updated>
            <content:encoded><![CDATA[<h3>자바스크립트 ES6 — Set에 대해 알아보자 🎉</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*uLh8H5xKwo3m__fUjroGMg.png" /></figure><p>ES6가 등장하기 이전에는 자바스크립트 자체는 set을 구현하고 있지 않았습니다. 근데, set이 뭘까요? Set은 데이터 타입 중의 하나인데, 중복되는 값을 가지지 않는 값들의 리스트입니다. 그리고 이 때 값은 순서가 존재하지 않죠. 그러면 ES6의 Set이 어떤 문제들을 해결할 수 있는지, 그리고 어떻게 활용할 수 있는지 살펴보도록 하겠습니다.</p><h3>구성자(Constructor)</h3><p>새로운 set을 만들때 new Set() 을 활용합니다. 이 때 구성자에 반복자(iterator)를 직접 작성할 수 있죠.</p><pre>const foo = new Set();<br>console.log(foo) // Set {}</pre><pre>const bar = new Set([ 1, 2, 3 ]);<br>console.log(bar) // Set { 1, 2, 3 }</pre><p>그런데 set을 만들 때 중복되는 값을 가진 반복자를 넘기면, Set이 알아서 중복되는 값들 중 맨 앞의 값만 남기고 무시합니다.</p><pre>const foo = new Set([ 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 5 ]);<br>console.log(foo);<br>// Set { 1, 2, 3, 4, 5 }</pre><h3>add 메소드와 size 속성</h3><p>Set 은 add 메소드를 통해 한 개의 값을 set에 추가할 수 있습니다. 또, size 속성을 통해 set이 가지고 있는 항목의 수를 알아낼 수 있죠.</p><pre>const foo = new Set();</pre><pre>console.log(foo.size) // 0<br>foo.add(1) // foo에 1을 추가<br>console.log(foo.size) // 1</pre><p>set은 중복된 값을 가지지 않는다는 특성을 잊지 않으셨죠? add 를 통해 값을 추가할 때, 추가하는 값이 이미 존재한다면 무시됩니다.</p><pre>const foo = new Set([&#39;하이큐&#39;, &#39;쿠로코의 농구&#39;, &#39;겁쟁이 패달&#39;]);<br>foo.add(&#39;하이큐&#39;);<br>console.log(foo) // Set { &#39;하이큐&#39;, &#39;쿠로코의 농구&#39;, &#39;겁쟁이 패달&#39; }</pre><h3>객체 set을 진짜 Set으로!</h3><p>Set 이 존재하기 이전에는 일반 객체를 활용해서 set을 구현해야 했습니다. 하지만 문자열(string)만이 객체의 속성으로 쓰일 수 있기 때문에 몇가지 문제점이 나타나기도 했죠. 5 는 &quot;5&quot; 로 형 강제 변환(coercion)이 일어나고, {}는 [object Object] 가 됩니다. 하지만 Set은 값의 타입을 강제로 변환하지 않습니다. 5 와 &quot;5&quot; 는 두 개의 다른 값이죠.</p><pre>const foo = new Set();</pre><pre>foo.add({}); // 빈 객체 추가<br>foo.add({}); // 또 다른 빈 객체 추가</pre><pre>console.log(foo.size); // 2<br>console.log(foo) // Set { {}, {} }</pre><pre>foo.add(10); // 숫자 10 추가<br>foo.add(&#39;10&#39;); // 문자열 &quot;10&quot; 추가<br>foo.add(10); // 이미 10이 있기때문에 무시됩니다</pre><pre>console.log(foo.size); // 4<br>console.log(set); // Set { {}, {}, 10, &#39;10&#39; }</pre><p>이와같이 여러개의 서로 다른 객체들을 set에 추가할 수 있습니다. 이 때 Set 은 값을 추가할 때, Object.is() 메소드를 사용해서 두 값을 비교합니다.</p><pre>Object.is(10, 10) // true<br>Object.is(10, &#39;10&#39;) // false<br>Object.is({}, {}) // false</pre><h3>has, delete, clear 메소드</h3><p>Set 을 다루는 데 있어 또 다른 유용한 메소드로 has , delete 그리고 clear 가 있습니다.</p><ul><li>has(값) — set에 값이 존재하는지 확인합니다. true 또는 false 를 반환하죠.</li><li>delete(값) — set에서 값을 제거합니다.</li><li>clear() — set에서 모든 값을 제거합니다.</li></ul><pre>const foo = new Set([ &#39;트와이스&#39;, &#39;레드벨벳&#39;, &#39;모모랜드&#39; ]);<br>console.log(foo.has(&#39;트와이스&#39;)) // true<br>console.log(foo.has(&#39;여자친구&#39;)) // false</pre><p>위와 같이 has를 통해 항목을 확인할 수 있습니다.</p><pre>const foo = new Set([ &#39;트와이스&#39;, &#39;레드벨벳&#39;, &#39;모모랜드&#39; ]);</pre><pre>console.log(foo.size); // 3</pre><pre>foo.delete(&#39;모모랜드&#39;);<br>console.log(foo.size); // 2</pre><pre>foo.clear();<br>console.log(foo.size); // 0</pre><h3>반복하기</h3><p>Set을 반복할 때에는 forEach() 메소드를 사용하면 됩니다. 그런데 일반 배열에서 forEach() 를 사용할 때와는 조금 다릅니다. 일단 forEach()의 인자인 콜백 함수는 세 가지 인자를 받습니다.</p><ul><li>값 자체</li><li>키(인덱스)</li><li>반복하고 있는 배열</li></ul><p>그런데 Set 에서는 앞의 두 가지 인자가 같은 값을 가집니다. 왜냐하면 Set 에는 키가 없기 때문이죠.</p><pre>const foo = new Set([&#39;안녕&#39;, &#39;하이&#39;, &#39;샬롬&#39; ]);</pre><pre>foo.forEach((value, key, s) =&gt; {<br>  console.log(value, key, s);<br>});</pre><pre>// 안녕 안녕 Set(3) {&quot;안녕&quot;, &quot;하이&quot;, &quot;샬롬&quot;}<br>// 하이 하이 Set(3) {&quot;안녕&quot;, &quot;하이&quot;, &quot;샬롬&quot;}<br>// 샬롬 샬롬 Set(3) {&quot;안녕&quot;, &quot;하이&quot;, &quot;샬롬&quot;}</pre><p>이와 같이 여러분이 이미 잘 알고 계신 forEach() 를 활용하여 Set 을 반복할 수 있습니다.</p><h3>Set을 배열로 바꾸기</h3><p>맨 위에서 살펴봤듯이, 배열을 Set 으로 바꾸는 방법은 쉽습니다. Set 구성자에 배열을 넘기기만 하면 되었죠. 반대로 set을 배열로도 바꿀 수 있는데요, 바로 전개 연산자(spread operator)를 활용하면 됩니다.</p><pre>const foo = new Set([ &#39;아이폰XR&#39;, &#39;갤노트9&#39; ]);<br>const fooInArray = [ ...foo ];<br>console.log(fooInArray) // [ &#39;아이폰XR&#39;, &#39;갤노트9&#39; ];</pre><h3>Set. 그리고 WeakSet.</h3><p>지금 까지 저희가 살펴본 Set 은 강한 Set (strong set)이라고 불리기도 합니다. Set가 객체를 가질 때에는 변수에 객체를 할당할 때와 같은 방법으로 참조하기 때문이죠. 실제 객체를 저장하는 것이 아닙니다. 그렇기 때문에 Set 인스턴스가 존재하는 한, 메모리를 비우기 위해 가비지 콜렉션(garbage collection)되지 않습니다.</p><pre>const foo = new Set();<br>let object = { coffee: &#39;룽고&#39; };</pre><pre>foo.add(object); // foo에 object 객체에 대한 참조 값을 추가<br>console.log(foo.size) // 1</pre><pre>object = null; // 객체에 대한 참조를 object에서는 해제<br>console.log(foo.size) // 1</pre><pre>object = [...foo][0]; // foo 가 참조하고 있던 객체를 다시 object에 할당<br>console.log(object); // { coffee: &#39;룽고&#39; }</pre><p>위와 같이 Set 이 객체를 참조하고 있기 때문에 { coffee: &#39;룽고&#39; } 객체는 사라지지 않습니다.</p><p>그런데 Set 이 참조하고 있는 객체에 대한 다른 참조가 전부 사라졌을 때, Set 의 참조도 없애고 싶을 때가 있을 수 있습니다. 이와 같은 경우를 위해 ES6에서는 WeakSet 을 제공합니다. WeakSet 은 약한(weak) 객체 참조를 가지게 되죠. 즉, WeakSet 이 참조하는 객체에 다른 참조가 없으면 가비지 컬렉션 됩니다. 또, WeakSet 은 원시 자료형(primitive types)를 가질 수 없습니다. string이나 integer를 set에 추가할 수 없죠.</p><pre>const foo = new WeakSet();</pre><pre>foo.add(10) // TypeError</pre><pre>let object = { coffee: &#39;아메리카노&#39; };<br>foo.add(object); // foo에 object 객체에 대한 참조 값을 추가<br>foo.has(object); // true</pre><pre>object = null; // 객체에 대한 참조를 object에서 해제. 동시에 foo에서도 해제됨.<br>set.has(object); // false</pre><p>WeakSet 은 다음과 같은 특성이 있습니다.</p><ul><li>객체가 아닌 값을 add() , has() , delete() 메소드들에 인자로 넘기면 TypeError 가 발생함.</li><li>반복할 수 없음(non-iterable). 즉, forEach() 를 사용할 수 없음</li><li>size 속성이 존재하지 않음.</li></ul><h3>정리하며</h3><p>ES6의 Set 을 활용하여 그간 다양한 방법으로 사용되던 set을 네이티브 Set 또는 WeakSet 으로 구현할 수 있습니다. Array를 사용하다가 한계를 느낀다면 set을 활용하는 것도 좋은 방법일 것 같습니다. 또, set을 활용할 때 메모리 누수 문제를 해결하고자 한다면 WeakSet 을 활용해서 메모리를 조금 더 철저하게 관리할 수 있겠죠?</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9b7294dfba99" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[번역] thank u, next: 연결 리스트(linked list)알아보기]]></title>
            <link>https://medium.com/@khwsc1/%EB%B2%88%EC%97%AD-thank-u-next-%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4%ED%8A%B8-linked-list-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-c179d0a8f81b?source=rss-4584900007e7------2</link>
            <guid isPermaLink="false">https://medium.com/p/c179d0a8f81b</guid>
            <category><![CDATA[data-structures]]></category>
            <category><![CDATA[linked-lists]]></category>
            <dc:creator><![CDATA[Hyeokwoo Alex Kwon]]></dc:creator>
            <pubDate>Sun, 09 Dec 2018 07:10:41 GMT</pubDate>
            <atom:updated>2018-12-09T07:10:41.696Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/880/0*TDE_NA4_rM1vFShY.png" /></figure><blockquote>본 아티클은<a href="https://dev.to/aspittel/thank-u-next-an-introduction-to-linked-lists-4pph"> thank u, next: an introduction to linked lists</a> 의 번역글 입니다</blockquote><p>이번 포스트에서는 아리아나 그란데의 “thank u, next” 의 가사를 빌려서 연결 리스트(linked list) 데이터 구조에 대해 알아보도록 하겠습니다. 아직 이 곡의 뮤직비디오를 본 적이 없으시다면, 저희가 본격적으로 시작하기 전에 잠깐 멈추고 감상해 보세요.</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2Fgl1aHhXnN1k%3Ffeature%3Doembed&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3Dgl1aHhXnN1k&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2Fgl1aHhXnN1k%2Fhqdefault.jpg&amp;key=d04bfffea46d4aeda930ec88cc64b87c&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/bf7f6ef4a813b6e699b2ce90a3856ced/href">https://medium.com/media/bf7f6ef4a813b6e699b2ce90a3856ced/href</a></iframe><p>연결 리스트란 데이터(data)와 포인터(pointer)로 구성된 노드(node)들이 한 줄로 연결된 데이터의 모음입니다. 저희는 데이터와 다음 노드를 가리키는 포인터로 구성된 노드를 가지는 단일 연결 리스트(singly linked list)에 집중하도록 하겠습니다. 연결 리스트는 이중 연결 리스트(doubly) 또는 원형 연결 리스트(circular)와 같은 다른 종류의 것들이 있지만, 지금은 단일 연결 리스트에만 집중해보도록 하겠습니다.</p><p>몇 가지 정의들을 빠르게 훑고 지나갈께요. 저희가 이해하고 있는게 맞나 확인해 보죠.</p><ul><li><strong>포인터</strong>는 메모리 내에서 특정 값의 주소를 저장하고 있다. 포인터는 아무것도 가르키지 않을 수 있다. <strong>레퍼런스(reference)</strong>는 포인터와 비슷하지만, 반드시 무언가를 가르켜야 한다.</li><li><strong>데이터 구조(data structure)</strong>란 어떤 프로그래밍 언어에서도 구현할 수 있는 데이터의 집합이다.</li></ul><p>본 포스트에서는 다음의 연결 리스트 예제를 활용하도록 하겠습니다:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/880/0*bol5mfrutohDzEoM.png" /></figure><p>위의 도표에 따르면, 총 5개의 노드가 존재하는것을 확인할 수 있습니다. 그리고 각 노드는 데이터 값을 가지고 있죠. 첫번째 4개의 노드는 아리아나 그란데의 전 남친들을 순서대로 나타내고 있습니다.</p><blockquote>Thought I’d end up with Sean / 난 내가 Sean이랑 평생갈 줄 알았어<br>But he wasn’t a match / 그런데 내 짝이 아니더라<br>Wrote some songs about Ricky / Ricky에 대해서 노래를 몇 곡 썼었는데<br>Now I listen and laugh / 지금 다시 들으니 웃기기만 하더라<br>Even almost got married / 거의 결혼할 뻔 했지 뭐야<br>And for Pete, I’m so thankful / 그리고 Pete한테는 너무 고마워<br>Wish I could say, “Thank you” to Malcolm / Malcolm에게도 “고마워&quot;라고 말할 수 있으면 좋을 텐데<br>’Cause he was an angel / 왜냐면 완전 천사였거든</blockquote><p>그리고 마지막 노드(Ari 노드)는 아리아나 그란데를 의미합니다.</p><blockquote>Plus, I met someone else / 아, 그리고 나 다른 사람 만났어<br>We havin’ better discussions / 더 좋은 얘기들을 나누고 있어<br>I know they say I move on too fast / 사람들은 내가 너무 빨리 갈아탄다고 하지만<br>But this one gon’ last / 이번에는 마지막이야<br>’Cause her name is Ari / 왜냐면 그 애의 이름은 Ari거든<br>And I’m so good with that (so good with that) / 아 지금 너무 만족해 (너무 만족해)</blockquote><p>데이터 뿐만 아니라 각 노드들은 다음 노드에 대한 포인터를 가지고 있습니다. 노래에서는 언제나 순서대로 전남친에 대해 이야기 하고, 그리고 마지막에 그녀 자신에 대해 노래하고 있죠. 저희가 위의 연결 리스트를 반복하게 되면 노래와 마찬가지로 같은 순서가 적용될 것입니다. 연결 리스트의 맨 첫번째 노드인 머리 노드(head node)에서 시작하여 그 다음 노드들로 이어지게 됩니다. 단일 연결 리스트는, 순서를 역행하거나 무작위로 노드가 연결되지 않습니다. 대신 머리에서 시작하여 마지막 노드까지, 언제나 같은 순서로 연결되죠.</p><p>다음과 같이 노드와 연결 노드들을 만들어 초간단 연결 리스트를 만들 수 있습니다:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/e908281afb9cdd77bd4d5142e78f0517/href">https://medium.com/media/e908281afb9cdd77bd4d5142e78f0517/href</a></iframe><blockquote>본 포스트에서 활용한 코드의 파이썬 버전은 <a href="https://github.com/aspittel/coding-cheat-sheets/blob/master/data_structures/linked_lists.md">여기</a>에서 확인하실 수 있습니다.</blockquote><p>이 코드에서 Sean 노드를 출력해보면, 해당 노드는 data 속성에 이름을 가지고 있을 뿐 아니라 Ricky 라는 다음 노드에 대한 참조값을 가지고 있는 것을 알 수 있습니다. 여기서 next 속성을 활용하여 모든 노드들을 훑고 지나갈 수 있어요!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/880/0*7PUa5eDXUTWROSFs.png" /></figure><p>또, 연결 리스트의 맨 끝에는 널 포인터(null pointer)가 있네요. 여기서 Ari는 여왕이기 때문에 스스로에게 만족하고 더 이상 다른 좋은 사람을 만날 필요가 없습니다. 그래서 다음 노드는 노땡큐(no thank u, next).</p><p>연결 리스트는 배열(array)과 비교했을 때 여러가지 장점이 존재합니다. 배열은 선형 데이터 구조(linear data structure) 세계에서 연결 리스트의 주요 대안 중의 하나이죠. 배열은 전통적으로 메모리에서 연속적인 블록에 저장되는데, 이를 통해 빠른 인덱스 공식인 배열_시작점_메모리 + 배열의_각_항목에_할당된_공간 * 우리가_원하는_항목의_인덱스 를 사용할 수 있게 되죠. 배열은 특정 인덱스의 항목을 가져올 때에는 굉장히 효율적( O(1) )이지만, 여러 항목들을 추가하거나 삭제할 때에는 비효율적입니다. 왜냐하면 메모리 내에서 모든 것을 다른 블록으로 옮겨야 하기 때문이죠. 그리고 새 항목을 추가할 배열의 앞이나 뒤에 공간이 있는지 보장 할 수도 없습니다. 배열의 중간에 추가하고자 할 때에도 같은 로직이 적용되는데, 주변의 항목들을 옮겨야 새 공간을 만들거나 공백을 메울 수 있죠.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/363/0*PRyNdSWI6fVbTIcM.png" /></figure><p>배열과 달리, 연결 리스트는 메모리에서 연속적인 블록에 저장할 필요가 없기 때문에 연결 리스트의 맨 앞에 추가하거나 삭제하는 것이 더 편리합니다. 또, 포인터는 메모리에서 어떤 위치든지 가르킬 수 있기 때문에, 새 노드를 추가하기 위해 모든 데이터를 옮길 필요가 없죠.</p><p>그 말인즉슨, 연결 리스트에 대해 검색을 하거나, 중간에 항목을 추가하거나 삭제할 때에는 이 과정이 비효율적입니다. 왜냐하면 머리부터 작업을 수행하고자 하는 노드까지 전부 훑어야 하기 때문이죠.</p><p>연결 리스트의 또 다른 단점 중의 하나는 배열보다 조금 더 많은 메모리를 차지한다는 것입니다. 왜냐하면 단지 데이터만을 포함하고 있는 배열과 달리, 데이터 뿐만아니라 다음 노드에 대한 포인터를 가지고 있기 때문이죠.</p><p>이런 작업들 중 일부를 구현한 코드를 살펴 보겠습니다. 연결 리스트의 맨 앞에 항목을 추가하고, 특정 인덱스의 항목을 삭제하는 작업에는 어떤 과정들을 거쳐야 하는지 나타내고 있습니다:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/3c78f3026fe6512eec3ebecfdd991671/href">https://medium.com/media/3c78f3026fe6512eec3ebecfdd991671/href</a></iframe><p>다음은 도표는 저희의 연결 리스트에서 Ari가 빌어먹을 Ricky에게 좀 덜 고맙다고 느꼈을 때 Ricky를 없애는 모습을 나타내고 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/880/0*_5RWK05-5WQXIWBY.png" /></figure><p>붉은 색으로 표시된 노드가 삭제 되죠.</p><p>또 다른 유용한 메소드로는 search 와 iterate 가 있네요:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/136b5b06898d986ec3ec803dee4d87f7/href">https://medium.com/media/136b5b06898d986ec3ec803dee4d87f7/href</a></iframe><p>그래서 저희는 연결 리스트에 아리아나 그란데의 전 남친들을 저장하는 것이 해당 데이터 구조의 좋은 활용처라는 것을 알게 되었습니다. 이제 저희가 “thank u, next”를 따라 부를 때 마다 전 남친들의 순서를 항상 같은 순서로 나열하기 때문이죠. 그렇다면 연결 리스트를 활용할 만한 또 다른 좋은 예제가 있을까요? 또 다른 예제로는 작업 큐(task queue)가 있을 겁니다. 예를 들어, 프린터의 경우에는 한 번에 한 장 밖에 인쇄하지 못하지만, 저희는 인쇄 할 때 마다 인쇄버튼을 누르는 것 대신, 작업들을 한번에 쌓아두고 싶을테죠! 저희가 작업 리스트를 만들 때에는, 새로운 항목은 언제나 큐(queue)의 맨 끝에 추가하고 인쇄할 때에는 맨 앞의 항목부터 인쇄할 겁니다! 뒤로가기 버튼도 마찬가지죠! 아니면 되돌리기(undo) 단축키도요! 그래서 스택(stack)이나 큐(queue)와 같은 자료구조를 연결 리스트를 활용하여 구현할 수 있습니다. 저는 여러가지 코딩 문제를 풀 때 연결 리스트가 큰 도움이 되었거든요.</p><p>이 포스트가 여러분에게 끈기나 고통대신 사랑을 전해드릴 수 있었으면 좋겠네요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/384/1*n04Q_WEeW3jjLg3GURMQoA.gif" /></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c179d0a8f81b" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[A simple React(Next.js) app development on Docker]]></title>
            <link>https://medium.com/@khwsc1/a-simple-react-next-js-app-development-on-docker-6f0bd3f78c2c?source=rss-4584900007e7------2</link>
            <guid isPermaLink="false">https://medium.com/p/6f0bd3f78c2c</guid>
            <category><![CDATA[nextjs]]></category>
            <category><![CDATA[react]]></category>
            <category><![CDATA[docker]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[nodejs]]></category>
            <dc:creator><![CDATA[Hyeokwoo Alex Kwon]]></dc:creator>
            <pubDate>Sun, 09 Dec 2018 01:15:20 GMT</pubDate>
            <atom:updated>2018-12-09T01:15:20.705Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/proxy/1*yChjVUZWv2pS3eIk6IJFsw.png" /></figure><p>Often, when developing applications with a microservice architecture, you cannot throughly test out all services until you deploy to a production server. This usually takes much too long to get feedback. Docker helps to speed up this process by making it easier to link together small, independent services locally.</p><p>On this article, we will go through how to set and use docker on react.js application development. We will build a simple next.js app and make it as docker image to run a container on your local machine with a production environment.</p><h3>1. Building a simple Next.js application</h3><p>First, let’s start a simple server-side rendered react application project and set a minimum docker setting to make a docker image. We are going to use the next.js library which easily allows us to build an SSR react application.</p><blockquote>Docker image is a file to create and run a docker container or to build other images. Consider that docker image contains an application and its executable codes to build and run. <a href="https://searchitoperations.techtarget.com/definition/Docker-image">Refer here for more detail.</a></blockquote><p>Let’s make a new project in your local machine with following commands:</p><pre>mkdir docker-nextjs<br>cd docker-nextjs<br>yarn init</pre><p>On the newly built nodejs project, let’s install next.js:</p><pre>yarn add --save next react react-dom</pre><p>And we should add scripts on package.json to easily manage the app:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/56854134e62fc32a56763a8129a0c59d/href">https://medium.com/media/56854134e62fc32a56763a8129a0c59d/href</a></iframe><p>Then we have to set minimal next.js app’s routes. Let’s create a simple hello world page on the main route. We can achieve this by creating pages/ directory inside the project and add index.js inside the directory. The file becomes the route and gets rendered as the main page.</p><p>Create a pages/index.js and write the following component in the file:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/a9df0b1f4493046979ce8e3b4fbeca1c/href">https://medium.com/media/a9df0b1f4493046979ce8e3b4fbeca1c/href</a></iframe><p>Now we can run the app on our local machine by running the command yarn run dev . You will be able to access the app on localhost:3000 .</p><h3>2. Write Dockerfile to build Docker Image</h3><p>So far, we just set a minimal hello world next.js application, now let’s make the app to be a docker image.</p><p>The docker image can be built with a single file within the project. The Dockerfile . By definition, “A Dockerfile is a text document that contains all the commands you would normally execute manually in order to build a Docker image.”</p><p>So, mainly by writing commands to build and run the app, you make an ingredient to building a docker image. When you build the docker image, docker system reads the Dockerfile that contains all the list of commands and executes it line by line to build an image.</p><p>Okay, then let’s write our own Dockerfile . Create a file with the name of Dockerfile inside the project directory and fill the file with following code:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/197277ab6de82dc7dfe75e2b7b0775d6/href">https://medium.com/media/197277ab6de82dc7dfe75e2b7b0775d6/href</a></iframe><p>The code contains sets of commands to build and run the application. The first line FROM node:10, the image brings nodejs version 10 from official nodejs docker image, so the app can run on the nodejs environment.</p><p>Next command sets the working directory with WORKDIR which sets the path of application files to /usr/src/app . Therefore when the container is run with this image, all the copied and built files are going to be located on that location.</p><p>Then, we added a command to install dependencies with npm install and copy the source files to the docker with COPY . . command. And we should add build command npm run build for production build and run the app with npm start .</p><p>Good! Now we are ready to build up docker image with the Dockerfile we created until now. From the terminal, go to your project directory and run the command:</p><pre>docker build -t &lt;your_username&gt;/docker-nextjs .</pre><p>With the build command, your docker system will go through the commands on Dockefile and make out a new image. The -t flag was to tag your image so you can easily find your image on the list. You can check your docker images with docker images command.</p><h3>3. Running up Container with image</h3><p>To actually run the application with docker, you should run a docker container based on the image.</p><blockquote>A container is a runtime instance of a docker image. Each container can be created with docker image as we built so far. <a href="https://www.docker.com/resources/what-container">Check out more on here.</a></blockquote><p>As we have our own docker image, we can create and run a docker container with the command:</p><pre>docker run -d -p 3333:3000 &lt;your_username&gt;/docker-nextjs:latest</pre><p>The command creates a new docker container with image &lt;your_username&gt;/docker-nextjs:latest with the port binding 3333:3000 . The binding means the application is run on port 3000 inside docker and can be accessed from host’s localhost:3000 .</p><h3>Wrapping up</h3><p>By following the article, you would be able to dockerize react application easily with minimum settings. The example just consists of dockerizing the application, but at least you can test the production environment more rapidly with the power of docker. Hope your life gets easy! 🐳</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6f0bd3f78c2c" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[두 번째 글또 스타뜨!]]></title>
            <link>https://medium.com/@khwsc1/%EB%91%90-%EB%B2%88%EC%A7%B8-%EA%B8%80%EB%98%90-%EC%8A%A4%ED%83%80%EB%9C%A8-b21e2e65f709?source=rss-4584900007e7------2</link>
            <guid isPermaLink="false">https://medium.com/p/b21e2e65f709</guid>
            <dc:creator><![CDATA[Hyeokwoo Alex Kwon]]></dc:creator>
            <pubDate>Sun, 11 Nov 2018 04:55:58 GMT</pubDate>
            <atom:updated>2018-11-11T04:55:58.225Z</atom:updated>
            <content:encoded><![CDATA[<p>글또가 첫 번째 시즌에 이어 두 번째 시즌으로 이어져 참가하게 되었습니다. 새로운 시즌에 참가하는 만큼, 마치 새 해가 되었을 때 마냥 새 마음가짐으로 글또 시즌 2를 시작합니다. ☀️</p><blockquote>글또 — “글쓰는 또라이”의 줄임말이며, 블로그 글쓰기 커뮤니티입니다. 개인의 의지만으로는 정기적으로 블로그 글을 작성하기 어렵기 때문에 커뮤니티에서 마감일을 지정하여 글을 정해진 기간 내에 작성할 수 있도록 합니다. 시즌 초기에 10만원을 예치하여 마감을 지키지 못하면 예치금이 차감되는 제도를 통해 글을 작성할 강력한 동기를 부여합니다.🤑 <a href="https://www.facebook.com/groups/375431516259701/">https://www.facebook.com/groups/375431516259701/</a></blockquote><h3>지난 글또 시즌에서는…</h3><p>처음으로 시행된 글또 시즌에서는 가벼운 마음으로 들어왔다가 큰 코 다치고 많이 배우게 되었습니다. 블로그 글? 그까짓꺼 대충 쓰면 되지 라는 마음으로 시작했지만.. 무언가 글을 쓴다는 것은 굉장히 힘든 일이었습니다. 글의 주제 정하기 부터 퇴고의 과정까지 많은 절차들이 있고 굉장히 많은 노력이 들기 마련이죠.</p><p>하지만 어려운 길을 거친 만큼 개인적으로 큰 성과를 일구어 냈습니다. 지난 시즌 동안 번역글 및 튜토리얼 글들을 주로 작성해 왔는데, 작성하는 과정동안 참조한 자료들을 통해 많은 것을 공부하고, 그것을 저만의 색깔로 풀면서 완전히 제 지식으로 소화 되었습니다. 또, 많은 분들이 좋아해 주시고 도움을 드릴 수 있어서 큰 만족감을 얻었습니다.</p><h3>이번 시즌에는!</h3><p>다음과 같은 goal들을 이루고자 노력합니다.</p><ol><li><strong>글 주제 확장.</strong> 현재 스타트업을 시작하겠다는 마음을 먹고 허슬링 중인데요, 소프트웨어 개발뿐만 아니라 경영/비즈니스 그리고 린스타트업 방법론까지 다뤄보려고 합니다. 특히 Steve Blank의 고객 개발은 이론이라기 보다는 기술에 가깝다고 생각하기 때문에, 기술 자료를 작성하기 위한 글또 커뮤니티에 공유하는것이 큰 의미가 있을것 같습니다.</li><li><strong>영문 글 작성하기. </strong>지금 하고있는 허슬링이 언제 망할지 모르니, 해외 취업을 위한 보험용으로 영문 글 비율을 높이고자 합니다. 국문 반, 영문 반 정도면 좋겠네요. 또, 지난 시즌에 영문 글(<a href="https://medium.com/@khwsc1/step-by-step-guide-of-simple-routing-transition-effect-for-react-with-react-router-v4-and-9152db1566a0">https://medium.com/@khwsc1/step-by-step-guide-of-simple-routing-transition-effect-for-react-with-react-router-v4-and-9152db1566a0</a>)을 한편 작성했는데 미디엄에 박수가 많이 달려서 만족감이 크네요!</li><li><strong>예치금 보존. </strong>어찌 되었건 스케쥴을 지키고 꾸준히 글쓰는 과정을 밟는게 중요하다고 생각합니다. 부득이하게 pass를 사용할 때를 제외하고 최대한 마감일을 지키고자 합니다. 그리고 예치금도 잃지 않을 수 있겠죠?</li></ol><h3>정리하며</h3><p>지난 글또 시즌에서 쉽지 않은 과정을 거쳤지만 많은 성과를 얻어냈습니다. 또 개발 커뮤니티에 기여할 수 있어서 기쁘네요. 이번 시즌에는 목표한 바를 전부 이룰 수 있도록 노력하려 합니다.👻</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b21e2e65f709" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[손으로 따라 만드는 심플노트 앱 — 초심자를 위한 리액트 튜토리얼]]></title>
            <link>https://medium.com/@khwsc1/%EC%86%90%EC%9C%BC%EB%A1%9C-%EB%94%B0%EB%9D%BC-%EB%A7%8C%EB%93%9C%EB%8A%94-%EC%8B%AC%ED%94%8C%EB%85%B8%ED%8A%B8-%EC%95%B1-%EC%B4%88%EC%8B%AC%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-fa96abcf6504?source=rss-4584900007e7------2</link>
            <guid isPermaLink="false">https://medium.com/p/fa96abcf6504</guid>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[tutorial]]></category>
            <category><![CDATA[react]]></category>
            <dc:creator><![CDATA[Hyeokwoo Alex Kwon]]></dc:creator>
            <pubDate>Sun, 26 Aug 2018 10:55:43 GMT</pubDate>
            <atom:updated>2018-08-26T11:00:15.982Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*TG9BBaIsfIUlL7_ZvN8H-g.png" /></figure><p>처음으로 리액트를 다루기 시작했던 그 시기, “프론트엔드를 점령해버리겠어! “라는 마음가짐으로 열정만 넘치던 때가 있었죠. 하지만 udemy의 기본 리액트 강의를 다 듣고 나서도 따라 할 수 있는 튜토리얼은 많지 않았습니다. 죄다 To-do 앱 만들기 뿐이었죠😢.</p><p>그래서 제가 막 리액트를 공부하시는 분들을 위해 새로운 튜토리얼을 들고 왔습니다! 이제 To-do는 질렸으니, 깔끔한 노트앱을 만들면서 리액트에 다시금 재미를 붙여보세요! 본 튜토리얼을 따라오시면서 리액트의 props와 state 개념을 알아보시고 이벤트를 어떻게 다루는지 살펴보세요. 이해가 되지 않더라도, 손으로 코드를 따라 치다보면 어느 순간 손에 익어있을거에요!👻</p><blockquote>본 튜토리얼은 리액트 초심자를 대상으로 한 튜토리얼입니다. props, state, 이벤트 핸들링, 복합 컴포넌트 사용과 같이 컴포넌트를 다루는 연습을 할 수 있도록 구성되었습니다. 프로덕션용으로 사용하기에는 미흡한 점이 있습니다.</blockquote><h3>데모 앱 살펴보기</h3><ul><li><a href="http://simplenote-react.surge.sh/">http://simplenote-react.surge.sh/</a> 에서 앱의 데모를 볼 수 있습니다. 🤪</li></ul><h3>참고</h3><ul><li>본 튜토리얼에서 만드는 심플노트 앱의 코드는 <a href="https://github.com/alexKwonIsAwesome/simplenote-react">https://github.com/alexKwonIsAwesome/simplenote-react</a> 에서 확인하실 수 있습니다.</li><li>스타일링에 대한 내용은 다루지 않았습니다. 코드 예제에서 css 파일을 참고 해주세요.</li></ul><h3>목차</h3><ol><li>개발 환경 설정</li></ol><p>1–1. 프로젝트 구조 설정하기</p><p>2. UI 컴포넌트 작성하기</p><p>3. state로 데이터 관리하기</p><p>4. &lt;List /&gt;렌더링하기</p><p>5. &lt;List /&gt;이벤트 핸들링</p><p>6. &lt;Note /&gt; 렌더링</p><p>7. &lt;Note /&gt; 이벤트 핸들링</p><p>8. 노트 추가 및 삭제하기</p><h3>1. 개발 환경 설정</h3><p>본격적으로 튜토리얼을 진행하기 이전에 코드를 작성할 환경을 설정해 봅시다. 여러분의 컴퓨터에서 작업하고 싶다면, <a href="https://github.com/facebook/create-react-app">create-react-app</a> 을 설치하신 후 새로운 프로젝트를 생성합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*H75Uwz9pYmwPJsc7pJ3AGg.png" /></figure><p>그런데, 이 과정이 너무 귀찮고 바로 시작하고 싶으시면, <a href="https://codesandbox.io/">https://codesandbox.io/</a> 에서 새로운 리액트 프로젝트를 시작하셔도 됩니다. 또는 <a href="https://github.com/alexKwonIsAwesome/simplenote-react">프로젝트 레포지토리</a>를 git clone하신 후, starter 브랜치에서 시작할 수 있습니다.</p><h3>1–1. 프로젝트 구조 설정하기</h3><p>create-react-app으로 프로젝트를 생성하면 기본적으로 다음과 같은 디렉토리 구조를 가집니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*2Zobd7_XJcrn-FuLWGZz6Q.png" /></figure><p>저희는 대부분의 코드를 src/ 디렉토리 내부에 작성 할겁니다. 그런데 코드를 잘 정리에서 작성할 수 있도록 디렉토리 구조와 코드를 조금 변경하도록 하겠습니다. 먼저 앱 디렉토리 구조를 다음과 같이 바꿔주세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dV1Hf1gtDXoyPJ4FBsb54g.png" /></figure><p>src/ 디렉토리 내부에 components/ 디렉토리를 만들고 &lt;App /&gt;컴포넌트를 담을 App/ 디렉토리를 생성합니다. 그 후, index.js 와 App/index.js 코드를 다음과 같이 작성합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Fs-lkObORtJabkAiy0bOpQ.png" /><figcaption>index.js</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*mLwi3Vb51kdTObw5YyKOhA.png" /><figcaption>App/index.js</figcaption></figure><p>이제 앞으로 작성할 컴포넌트들은 전부 components/ 디렉토리에 작성합니다. 그리고 컴포넌트는 컴포넌트 디렉토리를 생성하고 index.js 에 컴포넌트 코드를 작성하시면 됩니다.</p><h3>2. UI 컴포넌트 작성하기</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*TG9BBaIsfIUlL7_ZvN8H-g.png" /></figure><p>코드를 작성하기 전에, 먼저 앱의 UI를 파악해보겠습니다. 심플노트 앱을 살펴보면, 상단에 앱 제목과 추가, 삭제 버튼이 있는 헤더 영역이 있군요. 그 아래에는 좌측에 노트들의 리스트가 있네요. 그리고 오른쪽에는 노트의 전체 내용을 보고 편집할 수 있는 영역이 있습니다.</p><p>리액트에서 컴포넌트는 대개 UI 요소를 따라 구성하게 됩니다. 그러면 헤더는 &lt;Header/&gt;, 좌측 리스트는 &lt;List /&gt; 그리고 노트 에디터는 &lt;Note /&gt;로 구성할 수 있겠네요. 아 그리고 리스트의 각 영역은 &lt;ListItem /&gt;으로 구성할께요.</p><p>그러면 각각의 컴포넌트들을 작성해보도록 할까요? 처음에는 여러 로직을 뺀 UI적인 요소만 코드로 작성해보도록 하겠습니다. html 처럼 생긴 JSX로 구조를 작성하고, 각 컴포넌트의 index.css 파일에 스타일을 작성하겠습니다.</p><p>다음과 같은 구조로 디렉토리와 파일을 만들어 주세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*LUt6puSfqm_xBqX5PJsMCg.png" /></figure><p>그 후, 각 컴포넌트 디렉토리에 다음과 같이 코드를 작성할 수 있습니다.</p><blockquote>각 컴포넌트의 css 코드는 <a href="https://github.com/alexKwonIsAwesome/simplenote-react">깃헙 레포지토리</a>에서 확인해 주세요!</blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*iG-Y69t4hJ5JKbdfvloAag.png" /><figcaption>Header/index.js</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*e7o5erCmKIBdJt1chnilxw.png" /><figcaption>ListItem/index.js</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dK-rpG6pLcNCGcDWGZuO3Q.png" /><figcaption>List/index.js</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*LODeRui4NmN_-kOCCVl0MA.png" /><figcaption>Note/index.js</figcaption></figure><p>각 컴포넌트들을 작성한 뒤, 다음과 같이 &lt;App /&gt; 의 render() 메소드에 &lt;Header /&gt; , &lt;List/&gt; ,&lt;Note /&gt;컴포넌트를 작성하여 렌더링 해보죠!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*yPl3SAfAOLhX7FLpKH9m8g.png" /><figcaption>App/index.js</figcaption></figure><h3>3. state로 데이터 관리하기</h3><p>이제 여러분이 작성할 노트를 state 데이터로 관리해보도록 하겠습니다.</p><blockquote>state란 UI의 상태를 기록하는 데이터입니다. 일반적으로 버튼의 활성화 상태, input의 입력 값, 체크박스 체크 여부 등의 상태를 관리하죠.</blockquote><p>여러분의 &lt;App /&gt; 컴포넌트의 state에 notes 와 activeId를 설정합니다. notes는 앱의 노트 정보를 담은 array이고, activeId는 리스트에서 유저가 선택하여 활성화 된 노트의 id를 기록합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*6zTNcQrhWgccOk-PySidXg.png" /><figcaption>App/index.js</figcaption></figure><p>그리고 notes는 앞으로 다음과 같은 형태의 노트 정보를 관리하게 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*aYclPlFxTALtc77TMuQ4CQ.png" /><figcaption>notes와 activeId 데이터</figcaption></figure><p>id, title, contents 속성을 가진 노트 정보들이 notes에 담기고, 그 중 활성화된 노트의 id가 activeId에 기록되죠. 이런 방식으로 저희가 만들 앱은 화면에 무엇을 그려야 할지 알 수 있습니다.</p><blockquote>🔥 코드를 작성하는 과정에서, 원활한 디버깅을 위해 notes와 activeId에 위와 같은 객체 값들을 작성해주세요! 아직은 노트를 추가하는 기능이 없기 때문에 실제로 잘 동작하는지 확인하기 위해서는 this.state에 객체를 작성해야 합니다.</blockquote><p>이제 &lt;App /&gt;이 관리하는 notes와 activeId데이터를 &lt;List /&gt;컴포넌트에 전달하도록 하겠습니다. 그래야 &lt;List /&gt;컴포넌트가 노트들의 제목과 내용을 그리고 어떤 노트가 활성화 되었는지 알 수 있죠.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Pcxa4XiMGQmGfeSNQ0daQA.png" /><figcaption>App/index.js</figcaption></figure><p>&lt;List /&gt; 컴포넌트의 notes속성에 notes를 전달하고 activeId속성에 activeId를 전달했습니다. 이제 &lt;List /&gt;는 notes와 activeId라는 props에 접근하여 데이터를 참조할 수 있습니다.</p><blockquote>props는 상위 컴포넌트가 하위 컴포넌트에 데이터를 전달하는 방법입니다. 하위 컴포넌트는 this.props를 참조하여 데이터에 접근할 수 있죠. 이 때, props 데이터는 읽기 전용이기 때문에 절대 변경해서는 안됩니다. 왜냐하면 컴포넌트는 pure function 처럼 작동해야 하기 때문이죠. UI를 변경할 필요가 있다면 state를 활용하시면 됩니다 😛</blockquote><h3>4. &lt;List /&gt; 렌더링하기</h3><p>&lt;List /&gt; 컴포넌트가 notes데이터를 props로 전달 받게 되었으니, 그 데이터에 따라 노트 리스트를 그리도록 해보겠습니다. &lt;List /&gt;컴포넌트를 다음과 같이 작성해 주세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*hXNwxjC3VzRRgpBFTdqETQ.png" /><figcaption>List/index.js</figcaption></figure><p>&lt;List /&gt; 컴포넌트는 this.props.notes 데이터에 대해 반복문을 돌면서 &lt;ListItem /&gt;컴포넌트를 반환합니다. 이 때, 각 노트의 정보인 item객체에서 id, title, contents 데이터를 &lt;ListItem /&gt;컴포넌트에 전달하네요.</p><blockquote>반복문을 돌 때에는 key가 필수! 리액트는 어떤 엘리먼트가 변경, 생성, 삭제 되었는지 판단할 때 key를 활용합니다.각 엘리먼트에 유일성(identity)을 보장하기 위해 id와 같은 unique한 키를 사용하시면 됩니다. <a href="https://reactjs.org/docs/lists-and-keys.html#keys">https://reactjs.org/docs/lists-and-keys.html#keys</a></blockquote><p>&lt;ListItem /&gt; 컴포넌트도 전달받은 데이터를 표현하기 위해 다음과 같이 코드를 수정하겠습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*kquW52in-r3U7nxqhOcOvg.png" /><figcaption>ListItem/index.js</figcaption></figure><p>this.props.titl과 this.props.contents 를 알맞은 위치에 작성합니다. this.props.active는 활성화 상태 여부를 담고 있는데요, 노트가 활성화되면 active를 className에 추가하게 됩니다. 저희 앱 에서는 푸른색의 배경화면으로 표시하기 위함이죠.</p><h3>5. &lt;List /&gt; 이벤트 핸들링</h3><p>지금 까지 노트 데이터를 하위 컴포넌트에 전달하고 리스트 UI를 그려내었습니다. 이제는 유저가 어떤 노트를 클릭했을 때, 해당 노트를 활성화 할 수 있도록 이벤트 핸들러를 작성하도록 하겠습니다.</p><p>이벤트 핸들러는 기본적으로 함수 형태인데요, 엘리먼트의 이벤트 속성에 핸들러를 작성하게 됩니다. 그럼 먼저 &lt;App /&gt; 컴포넌트에 이벤트 핸들러 메소드(함수)를 작성해보도록 하겠습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*0-wxX39dJuf5esxelaHn2g.png" /><figcaption>App/index.js</figcaption></figure><p>&lt;App /&gt; 컴포넌트에 handleListItemClick 이라는 메소드를 만들었습니다. 이 메소드를 매개변수 id를 this.setState() 메소드를 활용하여 activeId를 설정합니다.</p><blockquote>this.setState() 는 state를 설정하는 메소드입니다. state를 변경할 때는 반드시 this.setState()를 사용하세요! this.state를 직접 조작하면, render() 메소드가 다시 호출되지 않습니다. 따라서 UI가 업데이트 되지 않죠. <a href="https://reactjs.org/docs/state-and-lifecycle.html#do-not-modify-state-directly">https://reactjs.org/docs/state-and-lifecycle.html#do-not-modify-state-directly</a></blockquote><p>handleListItemClick 메소드는 하위의 &lt;ListItem /&gt;이 사용할 것이기 때문에,&lt;App /&gt;과 &lt;ListItem /&gt;사이에 있는 &lt;List /&gt;컴포넌트의 onListItemClick 속성에 메소드를 전달했습니다.</p><p>그 후, 유저가 노트를 클릭했을 때 해당 메소드가 호출되도록 다음과 같이 작성합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*p7gxW3PpksdMzvcJqsV76g.png" /><figcaption>List/index.js</figcaption></figure><p>전달 받은 이벤트 핸들러를 가르키는 this.props.onListItemClick 메소드를 &lt;ListItem /&gt;의 onClick 속성에 작성합니다. &lt;ListItem /&gt;에서 onClick이 호출되면 () =&gt; onListItemClick(id)이 호출되어 &lt;App /&gt;의 handleListItemClick이 호출됩니다.</p><p>그러면 &lt;ListItem /&gt;의 &lt;div /&gt;엘리먼트를 클릭했을 때 해당 핸들러가 호출 될 수 있도록 다음과 같이 &lt;ListItem /&gt; 컴포넌트를 수정합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*JaqBkSKBPFnWTOxkP_sQDA.png" /><figcaption>ListItem/index.js</figcaption></figure><p>&lt;ListItem /&gt;의 가장 상위 엘리먼트인 &lt;div /&gt; 의 onClick 속성에 this.props.onClick을 작성했습니다. 그러면 유저가 해당 엘리먼트를 클릭했을 때(즉, click 이벤트가 발생했을 때) 전달 받은 this.props.onClick을 호출합니다.</p><blockquote>버튼 클릭(onClick), 인풋의 변경(onChange) 과 같은 유저의 상호작용에 의해 이벤트가 발생했을 때, 함수 형태의 이벤트 핸들러에 적절한 로직을 작성합니다. <a href="https://reactjs.org/docs/handling-events.html">https://reactjs.org/docs/handling-events.html</a></blockquote><p>이제 리스트에서 원하는 노트를 클릭하면, 해당 노트가 푸른색 배경으로 바뀌며 활성 상태를 나타냅니다!</p><h3>6. &lt;Note /&gt; 렌더링</h3><p>이제 원하는 노트를 선택할 수 있게 되었으니, 해당 노트의 전체 내용을 보고 편집할 수 있는 &lt;Note /&gt; 컴포넌트와 연동하도록 하겠습니다. 먼저 노트의 내용을 볼 수 있도록 &lt;App /&gt;에서 활성화된 노트 객체를 &lt;Note /&gt;컴포넌트에 전달하도록 하겠습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*NWUDguWDAqgeDImePVZiiA.png" /><figcaption>App/index.js</figcaption></figure><p>먼저, 위 코드에서 activeId와 일치하는 id를 가진 노트 객체를 찾아냈습니다. 이 때 어레이의 .filter() 메소드를 활용했습니다. 그 후, &lt;Note /&gt;에 note 속성으로 활성화 된 노트 객체인 activeNote를 전달했습니다.</p><p>이 때, 노트가 하나도 없는 경우에는 &lt;Note /&gt;컴포넌트를 그릴 필요가 없으므로, notes.length !== 0 &amp;&amp; &lt;Note note={activeNote} /&gt;와 같이 작성하여 노트가 한 개라도 존재할 때만 &lt;Note /&gt;를 렌더링합니다.</p><p>그 후, &lt;Note /&gt;가 전달 받은 note 데이터를 잘 렌더링할 수 있도록 다음과 같이 컴포넌트를 수정합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*hmq9tfCuxry9nbEeaWaEaw.png" /><figcaption>Note/index.js</figcaption></figure><p>위와 같이 작성하시면, 리스트에서 활성화된 노트 내용을 화면 우측에서 확인할 수 있습니다. 😛</p><h3>7. &lt;Note /&gt; 이벤트 핸들링</h3><p>이제는 보고있는 노트의 내용을 편집할 수 있어야겠죠? 노트의 내용을 변경하기 위해 &lt;App /&gt;에서 노트의 편집을 위한 이벤트 핸들러를 작성하겠습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*bN1djyLcr2xmhU3UOWS9zA.png" /><figcaption>App/index.js</figcaption></figure><p>&lt;App /&gt; 컴포넌트에 handleEditNote 메소드를 만들었습니다. 이 메소드는type과 이벤트 객체를 전달받습니다. 유저가 입력한 값은 e.target.value에 존재합니다. 유저가 편집한 노트를 찾고 내용을 알맞게 변경하여 this.setState()를 호출하여 state를 변경합니다.</p><blockquote>이벤트 발생 시 첫번째 인자인 event는 이벤트 객체입니다. 해당 이벤트와 관련된 속성과 메소드들을 제공하죠. event.target 에 접근하면 네이티브 DOMNode를 반환하게 됩니다. 따라서 input의 onChange와 같은 이벤트는 e.target.value 를 통해 유저가 입력한 값에 접근할 수 있습니다. <a href="https://reactjs.org/docs/events.html">https://reactjs.org/docs/events.html</a></blockquote><p>그리고 handleEditNote 메소드를 &lt;Note /&gt;컴포넌트에 onEditNote라는 이름의 속성으로 전달했습니다.</p><p>그 다음 유저가 내용을 변경할 수 있도록 &lt;Note /&gt;컴포넌트의 input과 textarea에 onChange이벤트를 등록합니다. 바로 전달받은 this.props.onEditNote를 등록하면 되겠죠?</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*w7oHXhyxeUDmvDFLX1T6qw.png" /></figure><p>위와 같이 코드를 수정하여 노트의 내용을 수정할 수 있는 기능까지 구현했습니다! 오예!</p><h3>8. 노트 추가 및 삭제하기</h3><p>지금까지 저희는 기존의 노트를 선택하고 노트의 내용을 편집할 수 있는 기능까지 추가했습니다. 이제는 새로운 노트를 추가하고 원하는 노트를 삭제하는 기능을 작성해보도록 하겠습니다.</p><p>먼저, 노트를 새로 추가할 수 있는 기능을 작성해보도록 할께요. &lt;App /&gt;컴포넌트에 또 다른 이벤트 핸들러를 작성하겠습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ft7PKl9_MfBFTb2PfA4OsA.png" /><figcaption>App/index.js</figcaption></figure><p>이번에는 handleAddNote 라는 이름의 메소드를 만들고, 해당 메소드를 &lt;Header /&gt;에 onAddNote라는 속성에 전달했습니다.</p><p>이 메소드는 this.state.notes에 새로운 노트 객체를 생성하여 추가합니다. 이 때, id는 고유해야 하므로 랜덤 id를 생성하는 유틸리티 함수를 사용했습니다.</p><blockquote>id 생성함수는 utils.js에서 확인하세요. <a href="https://github.com/alexKwonIsAwesome/simplenote-react/blob/master/src/utils.js">https://github.com/alexKwonIsAwesome/simplenote-react/blob/master/src/utils.js</a></blockquote><p>그 후 &lt;Header /&gt; 의 추가 버튼 엘리먼트를 클릭했을 때, 해당 핸들러가 호출되도록 다음과 같이 코드를 작성합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Jzx1NSi8MmMPmCHoZfbogQ.png" /><figcaption>Header/index.js</figcaption></figure><p>이제 헤더에서 추가 버튼을 클릭하면, 새로운 노트가 추가 되는것을 확인하실 수 있습니다!</p><p>노트를 추가할 수 있으니, 이제는 필요 없는 노트를 삭제할 수 있어야겠죠? 이번에도 위와 같은 방식으로 &lt;App /&gt;에 노트를 삭제하는 이벤트 핸들러 메소드를 작성하겠습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ukQ-sdtDHfDlHJt6E7-o9g.png" /><figcaption>App/index.js</figcaption></figure><p>새로 작성한 handleDeletNote메소드는 기존의 this.state.notes에서 현재 선택한 노트 객체를 제외하여 this.state.notes에 새롭게 할당합니다. 이 때 activeId는 새로운 notes 어레이의 첫번째 노트의 id로 지정했습니다. 노트를 삭제하면 자동으로 첫번째 노트가 선택 되도록 하는거죠.</p><p>그리고 해당 메소드를 &lt;Header /&gt;의 onDeleteNote속성에 전달했습니다.</p><p>그 후, &lt;Header /&gt;에서 삭제 버튼을 눌렀을 때 본 메소드가 호출되도록 컴포넌트를 수정합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*sX1ETfQyCdOE9jiW-AuG9A.png" /><figcaption>Header/index.js</figcaption></figure><p>이제 헤더의 삭제 버튼을 클릭하면 선택한 노트가 사라지게 됩니다!</p><p>드디어 노트 앱이 완성 되었습니다! 수고 많으셨습니다 👍👍</p><h3>정리하며</h3><p>어떠셨나요? 이것 저것 작성할 코드는 많았지만, 전부 다 비슷한 원리로 만들어서 쉽게 만드실 수 있으셨을 거에요. props로 데이터를 전달하고, 이벤트 핸들러로 state를 변경하면서 데이터들을 손쉽게 업데이트 했습니다.</p><p>중간중간에 막히는 부분이 있으셨다면, 프로젝트 레포지토리를 참고하셔서 완성된 코드를 참고하시면 됩니다! 끝까지 읽어주셔서 정말 감사합니다.</p><p>이 글이 유용하셨다면 박수👏를 (50번) 눌러주시면 정말 감사하겠습니다! 혹시 주변에 이 글이 도움될만한 분이 계신다면 공유해주세요~</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=fa96abcf6504" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[프로듀스48과 함께하는 GraphQL(그래프큐엘)]]></title>
            <link>https://medium.com/@khwsc1/%ED%94%84%EB%A1%9C%EB%93%80%EC%8A%A448%EA%B3%BC-%ED%95%A8%EA%BB%98%ED%95%98%EB%8A%94-graphql-%EA%B7%B8%EB%9E%98%ED%94%84%ED%81%90%EC%97%98-10c3e5da2f7b?source=rss-4584900007e7------2</link>
            <guid isPermaLink="false">https://medium.com/p/10c3e5da2f7b</guid>
            <category><![CDATA[graphql]]></category>
            <dc:creator><![CDATA[Hyeokwoo Alex Kwon]]></dc:creator>
            <pubDate>Sat, 21 Jul 2018 05:18:51 GMT</pubDate>
            <atom:updated>2018-07-21T05:18:51.141Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/970/1*cc6ydy77XsGNzTbovuVRhw.png" /></figure><p>최근에 새로운 프로젝트를 시작했는데 간단한 프로토타이핑을 위해 빠르고 쉽게 개발할 수 있는 스택을 찾아보게 되었습니다. 저는 주로 javascript로 개발을 했기 때문에 프론트는 react를, 서버사이드에는 express를 사용하기로 정했죠.</p><p>그런데 개발을 하다보니 RESTful API를 구성하는것이 너무너무 귀찮았습니다. 필요에 따라서 endpoint를 파는게 정말 귀찮더군요.. 무언가 나은 방안이 없을까? 라는 질문을 가지고 검색해보니 GraphQL을 알게되었습니다.</p><p>GraphQL의 개념을 훑고나니 “헐! 이거면 내 귀차니즘을 해결해주겠구만!” 라는 생각을 가지게 되었고, 프로젝트에 활용하게 되었습니다. 대체 GraphQL이란 무엇일까요?</p><h3>기본 개념</h3><p>GraphQL이란 간단히 말하면, <strong>데이터를 요청하는 방법을 정의한 문법</strong>입니다. 일반적으로 클라이언트가 서버에 데이터를 요청할 때 사용하게 되죠.</p><p>GraphQL은 이런 특징이 있습니다.</p><ol><li>필요한 데이터만 요청할 수 있다.</li><li>한번의 요청으로 여러 리소스의 데이터를 전송받을 수 있다.</li><li>타입 시스템(type system)을 활용하여 데이터를 정의한다.</li></ol><p>그러면 GraphQL은 어떤 이유로 탄생하게 되었고, 어째서 이런 특성을 가지게 되었을까요? 함께 살펴보시죠.</p><h3>탄생 배경</h3><p>최근 몇 년간은 클라이언트와 서버, 또는 서버와 서버 간의 통신에 REST API를 활용해 왔습니다. 하지만 이를 사용하다보면 몇가지 문제를 겪을 수 있습니다.</p><p>예를 들어 프로듀스 48의 연습생 리스트와 댓글을 확인할 수 있는 페이지를 만든다고 가정하겠습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1003/1*Mk2qQUkqBImDxWkXlsXhjQ.png" /></figure><p>위와 같은 페이지의 데이터를 조회하기 위해 다음과 같이 REST API를 구성할 수 있습니다. 이 API로 연습생들(trainees)의 리스트를 조회하고 각 연습생(trainee)에 대한 정보들(name, agency) 과 댓글( comments) 리스트를 조회할 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*2ss-wRFtAt3ru2Cy4S_bcg.png" /><figcaption>연습생 정보와 댓글 리스트 API</figcaption></figure><p>이번에는 댓글을 제외한 단순한 연습생 리스트 페이지를 만들고자 합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/540/1*NucV94uzwxPgaHynbfEiKA.png" /></figure><p>그런데 위와 같은 페이지에서 위에서 구성한 API를 활용한다면 불필요한 데이터까지 요청하게 됩니다. 이런 상황을 피하기 위해 새로운 API를 추가로 구성해야 합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*8ytXtXTukBzYtkTYCP0MXQ.png" /><figcaption>연습생 정보 단순 리스트 API</figcaption></figure><p>이와 같이 간단한 예제에서도 API가 두 가지 다른 API로 분리될 수 있습니다. 복잡한 웹 서비스의 경우라면, 생성해야 할 endpoint의 수는 끝도없이 늘어나게 됩니다. 수 많은 API endpoint를 관리하기는 쉽지 않습니다.</p><p>여기서 또 한 가지 문제가 발생할 수 있습니다. 만약 연습생 데이터와 댓글 데이터가 서로 다른 리소스에 저장되어 있다면, 이를 위해 클라이언트는 여러 네트워크 요청을 생성해야 합니다. 이는 네트워크 오버페칭(overfetching)으로 이어질 가능성이 높죠.</p><p>이와같이 전통적인 RESTful API에서 발생할 수 있는 문제들을 해결하기 위해 페이스북은 2012년에 GraphQL을 오픈소스로 공개했습니다.</p><h3>문제점 해결</h3><p>페이스북이 공개한 GraphQL은 위의 문제를 “불필요한 여러 API를 두지말고, 필요한것만을 요청할 수 있는 하나의 API만을 두자”라는 방식으로 해결합니다.</p><p>GraphQL에서 데이터를 요청하는 방식을 간략히 살펴보도록 하겠습니다. 프로듀스 48의 연습생 데이터를 GraphQL문법으로 다음과 같이 요청할 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Ey8x_0EAdWYuT08haPlHlw.png" /><figcaption>GraphQL 연습생 데이터 query</figcaption></figure><p>위의 GraphQL 문법은 trainees 리스트를 조회하고 각 리스트 아이템의 name , agency , comments 를 조회합니다. 위 query를 GraphQL 서버에 요청하면 다음과 같은 데이터를 전달 받습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*gZ99Dfh-_X4Iy0iPWR7A9w.png" /><figcaption>GraphQL 서버의 응답 데이터</figcaption></figure><p>GraphQL query 에서 요청한 필드와 그 형태와 같은 구조의 데이터가 반환됩니다. 이와같이 원하는 데이터 필드를 요청할 수 있고, 응답 데이터의 구조를 예상할 수 있습니다.</p><p>이번에는 댓글을 제외한 연습생의 리스트를 조회해보겠습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*TQi0ml8GBKenJKbETcrnBg.png" /><figcaption>댓글을 제외한 연습생 리스트 조회하기</figcaption></figure><p>이번 query에는 단순히 trainees 리스트의name, agency 필드만을 요청했습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*LRRhzIbv7oadXTgdOSfjeA.png" /><figcaption>댓글을 제외한 연습생 리스트</figcaption></figure><p>그랬더니 위와같이 요청한 query의 형태 그대로 구성된 데이터가 응답으로 돌아왔습니다.</p><p>이렇게 GraphQL을 활용하면 기존의 RESTful API와 같이 여러 endpoint로 나눌 필요없이, 하나의 GraphQL API endpoint 에 대해 필요한 데이터를 요청하기만 하면 됩니다. 완전 편하죠! 😝</p><h3>로직 작성하기</h3><p>GraphQL서버에 대해 query를 요청하면 그에 알맞은 데이터가 반환됩니다. 하지만 이때 데이터가 반환되는것은 마법처럼 자동적으로 되지 않습니다. 저희가 직접 로직을 작성해야죠!</p><p>GraphQL에서는 <strong>resolver</strong> 에 이 로직을 작성할 수 있습니다. Resolver란, query에서 특정 필드에 대한 요청이 있을 때, 그것을 어떤 로직으로 처리할지 GraphQL에게 알려주는 역할을 합니다.</p><p>저희의 프로듀스 48 예제에서는 다음과 같이 resolver를 작성할 수 있습니다.(node.js 기준으로 작성했습니다.)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*iFP7Ws6jVz0OGscLnG7voQ.png" /></figure><p>먼저, 가장 최상위의 trainees 필드의 로직은 Query 에 작성합니다. 왜냐하면 trainees 필드는 루트(root) 레벨에서 직접 부를 것이기 때문이죠.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*6CCUNnJ3B64nV5BGN37XxA.png" /></figure><p>그 다음, 서브 필드(subfields)의 resolver를 순차적으로 작성했습니다. trainees가 반환하는 Trainee의 각 필드를 Trainee 객체에 작성했죠. 이때 Trainee의 comments 필드를 반환하기 위해 Comment 객체의 resolver도 함께 작성합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*gPWXgNdP_gzBpo4ZPU9EMw.png" /></figure><p>이와 같이 resolver를 작성함으로써, 각 필드가 처리할 로직과 반환할 데이터의 종류를 지정할 수 있습니다.</p><h3>정리하며</h3><p>GraphQL은 REST API를 완전히 대체하기 위한 기술이라기 보다는 몇몇 발생 가능한 문제를 해결할 수 있는 한가지 방법중의 하나입니다. 천천히 살펴보시고 이를 활용하기에 적당한 프로젝트에 사용하시면 될 것 같습니다.</p><p>저는 개인적으로 프론트엔드 개발의 입장에 보았을 때 GraphQL이 굉장히 매력적입니다. 특히 컴포넌트 단위로 코드를 모듈화 하는 리액트 개발에 있어서 여러가지 API에 요청을 생성하는 것 대신에, 컴포넌트에 필요한 데이터만을 요청하는 GraphQL이 훨씬 더 코드를 간결하게 만듭니다. 귀찮은 일이 훨씬 줄어들어요!</p><p>처음에는 GraphQL이 복잡하고 어려워보일 수 있지만, 차분히 개념을 살피고 해결하고자 하는 문제를 이해하면 쉽게 활용하실 수 있을거에요. 👍</p><p>읽어 주셔서 감사합니다! 이 글이 도움이 될 만한 분에게 공유해주시고, 박수를 (50번)쳐주시면 정말 힘이 날 겁니다! 😝</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=10c3e5da2f7b" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[번역] 데이터 구조와 설계 — 튜토리얼]]></title>
            <link>https://medium.com/@khwsc1/%EB%B2%88%EC%97%AD-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%84%A4%EA%B3%84-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-b25792a0aa86?source=rss-4584900007e7------2</link>
            <guid isPermaLink="false">https://medium.com/p/b25792a0aa86</guid>
            <category><![CDATA[database]]></category>
            <category><![CDATA[database-design]]></category>
            <dc:creator><![CDATA[Hyeokwoo Alex Kwon]]></dc:creator>
            <pubDate>Sun, 13 May 2018 12:33:08 GMT</pubDate>
            <atom:updated>2018-05-15T08:39:24.624Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/750/1*5ukoQq4U9nlEcImWxd2VPg.png" /></figure><blockquote>본 글은 <a href="https://www.lucidchart.com/pages/database-diagram/database-design">Database Structure and Design Tutorial</a> by <a href="https://www.lucidchart.com/">Lucidchart</a>의 번역 글입니다.</blockquote><p>Lucidchart 와 같은 신뢰할 만한 데이터베이스 설계 도구를 사용하면, 잘 설계된 데이터를 통해 사용자가 필수 정보에 접근할 수 있습니다. 본 튜토리얼에서 설명하는 원칙을 따르면, 잘 동작하면서 앞으로 발생할 수 있는 요청을 반영할 수 있도록 데이터베이스를 설계할 수 있습니다. 데이터베이스를 구성하는 방법뿐만 아니라 최적화된 결과를 위해 정제하는 방법을 살펴보도록 하겠습니다.</p><h4>데이터베이스 설계 프로세스</h4><p>잘 설계된 데이터베이스는</p><ul><li>불필요한 데이터를 제거함으로써 디스크 공간을 절약합니다.</li><li>데이터 정확성(accuracy)과 무결성(integrity)을 유지합니다.</li><li>유용한 방법으로 데이터에 접근할 방법을 제공합니다.</li></ul><p>효율적이면서 유용한 데이터베이스를 설계하는 것은, 다음 단계와 같은 적절한 프로세스를 따라가는지 아닌지와 관계가 있습니다.</p><ol><li>요구사항을 분석하거나 데이터베이스의 용도 식별하기</li><li>데이터를 테이블로 구성하기</li><li>primary key를 찾아내고 관계를 분석하기</li><li>테이블을 standardize 하기 위해 normalizing 하기</li></ol><p>각 단계를 자세히 알아가 보도록 하죠. 참고로 이 가이드는 Edgar Codd의 관계형 데이터베이스 모델을 SQL(계층적, 네트워크, 또는 객체 데이터 모델이 아닌)로 작성한 것을 다룹니다. 데이터베이스 모델에 대한 자세한 내용은 <a href="https://www.lucidchart.com/pages/database-diagram/database-models">여기</a>에 있는 가이드를 참고하세요.</p><h4>요구사항 분석: 데이터베이스의 용도 식별하기</h4><p>여러분의 데이터베이스의 목적을 이해하게 되면 설계 과정 전반에서 어떤 방향으로 나아가야 할 지 알 수 있습니다. 데이터베이스를 다양한 관점에서 고려해야 하죠. 예를 들어, 공공 도서관에 필요한 데이터베이스를 만든다고 했을 때, 사서와 이용객 모두가 데이터에 접근할 필요가 있다는 것을 생각해야 합니다.</p><p>데이터베이스를 만들기 전에, 다음 방법을 통해서 정보를 얻을 수 있습니다.</p><ul><li>데이터베이스를 사용할 사람들을 대상으로 인터뷰하기</li><li>명세서, 시간 기록표, 설문 결과와 같은 문서 분석하기</li><li>기존에 존재하는 데이터 시스템 찾아보기(물리적, 디지털 형식을 포함하여)</li></ul><p>이제 데이터베이스에 포함하고자 하는 존재하는 데이터를 모으기 시작하세요. 그런 다음 저장하려는 데이터 유형과 해당 데이터가 설명하는 개체나 사람, 사물, 위치 및 이벤트를 다음과 같이 나열합니다.</p><p>고객(Customer)</p><ul><li>이름(Name)</li><li>주소(Address)</li><li>도시, 주, 우편번호(City, State, Zip)</li><li>이메일(Email address)</li></ul><p>제품(Products)</p><ul><li>이름(Name)</li><li>가격(Price)</li><li>재고 수량(Quantity in stock)</li><li>주문 수량(Quantity on order)</li></ul><p>주문(Orders)</p><ul><li>주문 ID(Order ID)</li><li>영업 담당자(Sales representative)</li><li>날짜(Date)</li><li>제품(Product(s))</li><li>수량(Quantity)</li><li>가격(Price)</li><li>총계(Total)</li></ul><p>이 정보는 나중에 데이터베이스 내의 테이블과 필드의 윤곽을 그릴 데이터 딕셔너리(data dictionary)의 일부분이 될 것입니다. 이때 정보를 최대한 작지만 유용한 단위로 쪼개야 합니다. 예를 들어, 주소 정보에서 도로명과 국가 정보를 분리하는 것을 고려해 놓으면, 국가별로 사람을 조회할 수 있게 됩니다. 또, 같은 데이터 요소를 두 개 이상의 테이블에 저장하는 것을 피해야 합니다. 이로 인해 불필요한 복잡성이 증대되기 때문이죠.</p><p>데이터베이스에 어떤 종류의 데이터를 포함하고, 데이터의 출처와 그 데이터가 어떻게 활용될지 알게 되면, 실제 데이터베이스를 계획할 준비가 된 것입니다.</p><h4>데이터베이스 구조: 데이터베이스의 구성 요소(building blocks)</h4><p>다음 단계는 여러분의 데이터베이스를 시각적으로 나열하는 것입니다. 이를 위해서 여러분은 관계형 데이터베이스가 어떻게 구성되는지 정확히 이해하셔야 합니다.</p><p>데이터베이스 내부에서는, 서로 관련된 데이터는 테이블로 묶여 있고, 각 테이블은 마치 스프레드시트처럼 행(row)과 열(column)로 구성되어있습니다.</p><p>데이터 목록을 테이블로 변형하기 위해서는, 각 개체의 종류별로 테이블을 만들기 시작하면 됩니다. 제품(products), 매출(sales), 고객(customers) 그리고 주문(orders)과 같이 말이죠. 다음 예제를 살펴보도록 합시다.</p><p>테이블의 각 행(row)을 레코드(record)라고 합니다. 레코드는 어떤 것 또는 어떤 사람의 정보를 담고 있습니다. <em>‘어떤 고객의 정보’</em>와 같은 특정 대상처럼요. 반면, 컬럼(column, 필드(field) 또는 속성(attribute)이라고 불리기도 합니다)은 각 레코드에 표시되는 단일 유형의 정보들을 포함하고 있습니다. 마치 테이블에서 ‘<em>모든 고객의 주소’</em>와 같이 말이죠.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/424/1*Ax0Buxq9M4DimTQbUWk-7Q.png" /></figure><p>레코드들이 일관된 데이터를 저장하게 하기 위해서는 각 컬럼별로 적합한 데이터 유형을 지정해야 합니다. 일반적으로 다음과 같은 데이터 유형이 있습니다.</p><ul><li>CHAR —고정된 길이의 문자</li><li>VARCHAR — 가변적인 길이의 문자</li><li>TEXT — 많은 양의 문자</li><li>INT — 음수이거나 양수인 모든 숫자</li><li>FLOAT, DOUBLE —소수점을 가질 수 있는 숫자</li><li>BLOB — 바이너리 데이터</li></ul><p>몇몇 데이터베이스 관리 시스템은 자동숫자(Autonumber) 데이터 유형을 제공하기도 합니다. 이 데이터 유형은 행마다 고유한 숫자를 자동으로 생성해줍니다.</p><p>개체-관계 다이어그램(entity-relationship diagram)이라는 데이터베이스를 시각적 개요를 그릴 때는 실제 테이블을 포함하지 않습니다. 대신, 테이블 하나가 한 개의 박스로 표현되죠. 각 박스의 제목은 해당 테이블이 어떤 데이터를 다루는지 나타내고, 그 아래에 속성들이 다음과 같이 표시됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/300/1*32SALBOuxY3F_9K5iYBGoA.png" /></figure><p>마지막으로, 테이블별로 어떤 속성이 프라이머리 키(primary key)가 될지 (필요한 경우) 정해야 합니다. 프라이머리 키(Primary key, PK)란, 각 개체의 고유 인식자(unique identifier)입니다. 즉, 이 값만 알아도 특정 고객을 선택해낼 수 있다는 의미입니다.</p><p>프라이머리 키로 선택된 속성은 고유하고, 변경되지 않고, 언제나 존재하는(절대 빈값이나 NULL이 아닌) 상태여야 합니다. 이러한 이유로, 주문 번호나 유저 이름은 프라이머리 키로 사용하기 적합하고, 전화번호나 도로 주소의 경우에는 그렇지 않습니다. 또한, 여러 가지 필드를 함께 사용하여 프라이머리 키를 만들어낼 수 있습니다(이런 키를 복합키(composite key)라고 부릅니다).</p><p>실제 데이터베이스를 만들 때가 되면, 여러분은 논리적인 데이터 구조와 물리적인 데이터 구조를 데이터 관리 시스템이 지원하는 데이터 정의 언어로 표현해야 합니다. 이 시점에서 데이터베이스의 크기를 예측해야 데이터베이스가 요구하는 성능 수준과 저장 공간을 확보할 수 있습니다.</p><h4>개체 간 관계 생성하기</h4><p>여러분의 데이터베이스 테이블이 여러 테이블로 변환되고 나면, 이제 테이블간의 관계를 분석할 수 있게 됩니다. 카디널리티(Cardinaliry)란 두 개의 관련된 테이블 간에 상호작용하는 인자의 개수를 의미합니다. 카디널리티를 인식하게 되면 데이터를 가장 효율적으로 테이블에 나눌 수 있게 됩니다.</p><p>각 개체는 다른 모든 개체와 관계를 맺을 수 있죠. 하지만 그 관계는 보통 다음의 세 가지 유형 중의 하나입니다.</p><p><strong>일대일 관계(One-to-one relationships)</strong></p><p>만약 개체 B의 각 인스턴스에 대해 하나의 개체 A의 인스턴스가 존재할 때 이 둘은 일대일 관계라고 합니다(종종 1:1이라고 표시됩니다). 이와 같은 관계를 ER 다이어그램(entity relationship diagram)에서는 각 끝의 대시 기호를 그린 선분을 통해서 나타낼 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/682/1*pkQqpmZbQ1-zs8egc_2Cxg.png" /></figure><p>반드시 1:1 관계로 테이블을 구성해야 할 필요가 없는 한, 1:1 관계는 대개 두 테이블의 데이터를 단일 테이블로 통합하는 것이 더 낫다는 것을 의미합니다.</p><p>만약 “설명&quot;이라는 어떤 선택적인 데이터를 저장하는 필드가 있고, 이 값은 많은 레코드에서 빈값일 때, “설명&quot; 필드를 전부 제거하고 새로운 테이블에 저장할 수 있습니다. 그러면 빈 공간을 줄이고 데이터베이스 성능을 증대시킬 수 있죠.</p><p>데이터가 정확히 일치하는지 보장하기 위해서, 각 테이블에 최소한 한 개 이상에 같은 컬럼을 가지고 있어야 합니다. 이때 주로 프라이머리 키를 사용하죠.</p><p><strong>일대다 관계(One-to-many relationships)</strong></p><p>이와 같은 관계는 한 테이블의 레코드가 다수의 항목과 관련되었을 때 발생합니다. 예를 들어, 한 명의 고객은 여러 개의 주문을 생성할 수 있고, 도서관 고객은 한 번에 여러 권의 도서를 대여할 수 있죠. 일대다(1:M) 관계는 다음의 예시와 같이 “까마귀 발 표기법(Crow’s foot notation)”이라는 표기법으로 표시됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/682/1*ePWrXONjT-GrDG8UJnSdVg.png" /></figure><p>데이터베이스를 구성할 때 1:M 관계를 구현하려면, 한쪽의 프라이머리 키를 다른 쪽의 속성으로 추가하기면 하면 됩니다. 이 방식으로 다른 테이블에 프라이머리 키가 나열될 때, 이 프라이머리 키를 외래키(foreign key)라고 부릅니다. 1:M에서 “1” 방면의 테이블이 상위 테이블(parent table)이라 부르며, 다른 방면의 테이블을 하위 테이블(child table)이라고 합니다.</p><p><strong>다대다 관계(Many-to-many relationships)</strong></p><p>한 테이블의 복수의 개체가 다른 테이블의 복수의 개체와 관련이 있을 때, 이 둘은 다대다 (M:N) 관계가 있다고 합니다. 이러한 관계는 학생과 수업 간의 경우에서 발생할 수 있는데요, 학생 한 명은 여러 수업을 수강할 수 있고, 한 수업은 여러 명의 학생으로 구성되기 때문이죠.</p><p>이를 ER 다이어그램에서 다음과 같은 선분을 사용하여 표현할 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/682/1*85Azkky_k4922No2HuhawQ.png" /></figure><p>안타깝게도, 이런 관계는 데이터베이스에서 직접 구현할 수가 없습니다. 대신, 이러한 관계를 두 개의 일대다 관계로 분리해야 합니다.</p><p>이를 위해선, 두 테이블 사이에 새로운 개체를 생성합니다. 만약 M:N 관계가 판매(sales)와 제품(products) 간에 존재한다면, 새로운 개체는 ‘판매된 제품(sold_products)’으로 부르는 것이 적합할 겁니다. 각 판매별 제품을 표시할 것이기 때문이죠. 그러면 판매와 제품 테이블은 각각 ‘판매된 제품&#39; 테이블과 1:M 관계를 맺게 될 것입니다. 이런 종류의 중개역할을 하는 개체를 모델에 따라 연결 테이블(link table), 결합 개체(associative entity) 또는 교차 테이블(junction table)이라고 부릅니다.</p><p>연결 테이블의 각 레코드는 인접한 테이블의 개체 중 두 개를 연결합니다(이 레코드는 부가적인 정보도 포함하게 되죠). 예를 들어, 학생과 수업은 이런 모습을 보일 겁니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/984/1*wHnfkjBuQsneYapUqkyV3A.png" /></figure><p><strong>필수(mandatory)인가 아닌가?</strong></p><p>관계를 분석하는 또 다른 방법은 관계에서 한 방면이 존재하기 위해 어떤 방면이 반드시 존재해야 하는지 생각해보는 것입니다. 필수적이지 않은 방면은 선분에서 대쉬 기호 옆에 동그라미를 표시합니다. 예를 들어, UN에서 대표를 하기 위해서는 국가가 존재해야 하지만, 그 반대는 그렇지 않습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/984/1*pASscMQDuZVPd5gyUrZFrw.png" /></figure><p>두 개체는 서로 의존적이게 됩니다(한 방면은 다른 한 방면 없이 존재할 수 없습니다).</p><p><strong>재귀적 관계(recursive relationships)</strong></p><p>종종 테이블이 자신을 다시 가리키게 되는 경우가 있습니다. 예를 들어, 직원(employees) 테이블은 “매니저(manager)”라는 속성으로 해당 테이블 내의 한 개인을 가리킬 수 있습니다. 이것을 재귀적 관계(recursive relationships)라고 부르죠.</p><p><strong>중복 관계(redundant relationships)</strong></p><p>중복 관계(redundant relationships)란 두 번 이상 표현되는 것을 말합니다. 일반적으로는, 중요한 정보를 잃지 않으면서 관계를 제거할 수 있습니다. 예를 들어, “학생(students)” 개체가 “선생님(teachers)” 개체와 직접적인 관계가 있지만 “수업(classses)” 개체를 통해 선생님 개체와 간접적인 관계가 존재할 때 학생과 선생님의 관계를 제거하는 것이 좋습니다. 왜냐하면, 학생들이 선생님에게 할당되는 유일한 방법은 수업을 통해서 만이기 때문이죠.</p><h4><strong>데이터베이스 정규화(Database normalization)</strong></h4><p>데이터베이스의 기초적인 설계를 마쳤다면, 테이블이 정확하게 구조화될 수 있도록 정규화(normalization) 규칙을 적용할 수 있습니다. 이 규칙은 마치 산업 표준이라고 생각하시면 됩니다.</p><p>그렇지만, 모든 데이터베이스가 정규화를 하기에 적합한 대상이 아닙니다. 보통, 온라인 거래 프로세싱(online transaction processing, OLTP) 데이터베이스는 사용자들이 거래 내용을 생성하고, 읽고, 업데이트하고 삭제하는 것에 관심이 있기 때문에 정규화되어야 합니다.</p><p>온라인 분석 프로세싱(online analytical processing, OLAP) 데이터베이스는 분석과 리포팅을 위해 사용되기 때문에 어느 정도의 비정규화가 더 나을 수 있습니다. 왜냐하면, 연산의 속도가 강조되기 때문이죠. 여기에는 데이터가 변경되지 않고 신속하게 분석해야 하는 의사 결정 지원 애플리케이션이 포함됩니다.</p><p>각 형(form), 또는 정규화 단계는 하위 단계 형의 규칙을 포함합니다.</p><p><strong>제1 정규형(First normal form)</strong></p><p>제1정규형(1NF)은 테이블의 각 셀은 여러 값의 리스트가 아닌 오직 한 개의 값만을 가질 수 있다고 정의합니다. 따라서 다음과 같은 테이블은 규칙에 어긋난 경우입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/330/1*wIarM7gYkrvUfrwpnHfp8Q.png" /></figure><p>여러분은 아마 추가 컬럼을 생성하고 그곳에 데이터를 옮김으로써 이 문제를 해결하고 싶은 충동이 드시겠지만, 그것 또한 규칙에 어긋납니다. 반복되거나 밀접하게 관계가 있는 속성들의 묶음이 있는 테이블은 제1 정규형 규칙에 부합하지 않습니다. 예를 들어 아래의 테이블 또한 규칙에 어긋난 경우입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/300/1*yfKB7fCSxuHCuGNxg9nG_Q.png" /></figure><p>대신, 각 셀이 한 개의 데이터를 가지고 추가 컬럼이 존재하지 않을 때 까지 데이터를 여러 개의 테이블이나 레코드로 분리하세요. 이때, 데이터는 원자성을 가지고 있다(atomic)고 합니다. 또는 가장 작고 유용한 크기로 분리되었다고 합니다. 위의 테이블을 살펴보았을 때, “판매 상세(Sales details)&quot;라는 추가 테이블을 생성해서 특정 상품과 판매를 연결할 수 있습니다. “판매(Sales)”는 “판매 상세(Sales detail)”와 1:M 관계를 맺게 되겠죠.</p><p><strong>제2 정규형(Second normal form)</strong></p><p>제2정규형(2NF)은 각 속성이 모든 프라이머리 키에 완전히 종속적이어야 한다고 규정합니다. 즉, 각 속성은 다른 속성을 통해 간접적으로 의존적인 것이 아니라 프라이머리 키에 직접 의존적이어야 합니다.</p><p>예를 들어, “나이(age)&quot; 속성은 “생일(birthdate)”에 의존적이며 이는 결국 “학생ID(studentID)”에 의존적일 때, “나이&quot; 속성은 부분적으로 기능 의존성을 가지고 있다고 하며, 이런 속성을 포함하고 있는 테이블은 제2 정규형에 부합하지 않게 되죠.</p><p>게다가, 여러 필드로 구성된 프라이머리 키를 사용하는 테이블은, 한 개 이상의 필드가 키의 모든 부분에 의존적이지 않으면, 제2 정규형을 위반하게 됩니다.</p><p>따라서, 이런 필드를 가진 테이블은 제2 정규형에 부합하지 않습니다. 왜냐하면, “제품 명(product name)” 속성은 제품 ID(product ID)에는 의존적이지만 주문 번호(order number)에는 의존적이지 않기 때문이죠.</p><ul><li>주문 번호(Order number, 프라이머리 키)</li><li>제품 ID(product ID, 프라이머리 키)</li><li>제품 명(product name)</li></ul><p><strong>제3 정규형(Third normal form)</strong></p><p>제3 정규형(3NF)은 키가 아닌 모든 컬럼은 다른 컬럼에 대해서 독립적이어야 한다는 규칙을 추가합니다. 만약 하나의 키가 아닌 컬럼의 값을 변경할 때, 다른 컬럼의 값이 변한다면 이 테이블은 제3 정규형에 부합하지 않습니다.</p><p>이 규칙은 테이블에 파생된 데이터를 저장하지 못하도록 합니다. 마치 다음 테이블에서 가격에 의존적인 “세금(tax)” 컬럼과 같이 말이죠.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/276/1*qk5hE4mlXDTDW9PHxihK5w.png" /></figure><p>이외에도 Boyce-Codd 정규형, 제4 부터 6 정규형, 그리고 도메인-키(domain-key) 정규형과 같이 추가적인 정규형이 제안되었지만, 위의 세 가지 정규형이 가장 많이 사용되고 있습니다.</p><p>이런 정규형들은 일반적으로 따를 만한 좋은 관습들을 설명하고 있지만, 정규형의 정도는 데이터베이스에 따라 다릅니다.</p><h4>다차원 데이터(Multidimensional data)</h4><p>어떤 사람들은 단일 데이터 유형의 복수의 차원에 접근하고자 합니다. 특히 OLAP 데이터베이스에서 말이죠. 예를 들어, 고객 당 판매량(sales by customer), 현재 상태(state) 그리고 판매 월(month)을 알고자 한다고 합시다. 이런 상황에서는, 중앙 테이블(central fact table)을 만들어 다른 고객(customer), 상태(state), 그리고 판매 월(month) 테이블이 참조할 수 있도록 합니다. 다음과 같이 말이죠.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ovHZ5nPQLfmaTBpX18ffLw.png" /></figure><h4>데이터 무결성 규칙</h4><p>데이터베이스의 포함될 데이터가 적절한 규칙에 따라 유효성을 검사하도록 설정해야 합니다. 많은 데이터베이스 시스템들, 마이크로소프트 액세스(Microsoft Access)와 같은 시스템은 이런 규칙을 자동으로 적용하기도 하죠.</p><p>개체 무결성 규칙(entity integrity rule)에 따르면, 프라이머리 키는 절대 NULL 값을 가지고 있으면 안 됩니다. 만약 키가 여러 컬럼으로 구성되어 있다면, 구성된 컬럼들은 NULL 값을 가지면 안 됩니다. 그렇지 않으면, 레코드를 고유하게 인식할 수 없게 됩니다.</p><p>참조 무결성 규칙(referential integrity rule)은 한 테이블에 나열된 외래키가 참조하는 테이블의 하나의 프라이머리 키와 일치해야 함을 요구합니다. 만약 프라이머리 키가 변하거나 삭제되면, 이러한 변화는 데이터베이스 내외에서 그 키를 참조하는 모든 것에 적용되어야 합니다.</p><p>비즈니스 논리 무결성 규칙(business logic integrity)은 데이터가 특정 논리 매개 변수에 맞는지 확인합니다. 예를 들어, 예약 시간은 영업시간에 포함되도록 해야 할 테죠.</p><h4>인덱스(index)와 뷰(view) 추가하기</h4><p>인덱스(index)란, 한 개 또는 그 이상의 컬럼을 정렬하여 복사한 것입니다. 이때 값을 오름차순 또는 내림차순으로 정렬하죠. 인덱스를 추가하게 되면 유저는 레코드를 훨씬 빠르게 찾을 수 있습니다. 각 쿼리를 재정렬 하는 대신에, 시스템은 인덱스에 순서대로 정의된 레코드에 접근할 수 있습니다.</p><p>물론 인덱스가 데이터 조회를 빠르게 하지만, 데이터를 삽입, 업데이트 그리고 삭제를 느리게 할 수 있습니다. 왜냐면 레코드가 변화할 때마다 인덱스를 새로 구성해야 하기 때문이죠.</p><p>뷰(view)란, 단순히 데이터에 저장된 쿼리를 의미합니다. 뷰는 여러 테이블의 데이터를 유용하게 결합(join)하거나 테이블 일부분을 보여줍니다.</p><h4>확장된 속성</h4><p>기본적인 윤곽이 완성되면, 데이터베이스를 확장 속성을 사용하여 데이터베이스를 정제할 수 있습니다. instructional text, input masks, 그리고 formatting rules와 같은 것들을 특정 스키마, 뷰 또는 컬럼에 적용할 수 있습니다. 해당 방식의 장점은, 규칙들이 데이터베이스 그 자체에 저장되기 때문에, 데이터에 접근하는 다양한 프로그램들에서 데이터가 일관되게 나타납니다.</p><h4>SQL과 UML</h4><p>통합 모델링 언어(Unified Modeling Language, UML)는 객체 지향 프로그램 언어로 만든 복잡한 시스템을 시각적으로 표현하는 또 다른 방법입니다. 본 가이드에서 설명한 여러 개념은 UML에서는 다른 이름으로 알려져 있습니다. 예를 들어, 개체는 UML에서는 클래스(class)라고 알려져있습니다.</p><p>요즘 UML은 예전만큼 자주 쓰이지는 않습니다. 오늘날에는 학문적으로 활용되거나 소프트웨어 설계자들과 클라이언트들의 소통 도구로 종종 사용됩니다.</p><h4>데이터베이스 관리 시스템</h4><p>설계 선택의 대부분은 어떤 데이터베이스 관리 시스템을 쓰느냐에 따라 달라질 것입니다. 몇몇 자주 사용되는 시스템은 다음과 같습니다.</p><ul><li>오라클 DB</li><li>MySQL</li><li>마이크로소프트 SQL 서버</li><li>PostgreSQL</li><li>IBM DB2</li></ul><p>선택권이 주어졌을 때는 가격, 운영체제 기능 등을 기반으로 데이터베이스 관리 시스템을 선택하시면 됩니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b25792a0aa86" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[번역] 자바스크립트 스코프와 클로저(JavaScript Scope and Closures)]]></title>
            <link>https://medium.com/@khwsc1/%EB%B2%88%EC%97%AD-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%8A%A4%EC%BD%94%ED%94%84%EC%99%80-%ED%81%B4%EB%A1%9C%EC%A0%80-javascript-scope-and-closures-8d402c976d19?source=rss-4584900007e7------2</link>
            <guid isPermaLink="false">https://medium.com/p/8d402c976d19</guid>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[closure]]></category>
            <category><![CDATA[scopes]]></category>
            <dc:creator><![CDATA[Hyeokwoo Alex Kwon]]></dc:creator>
            <pubDate>Thu, 05 Apr 2018 05:24:49 GMT</pubDate>
            <atom:updated>2018-04-05T09:14:19.795Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*IDQ9bZ7rXpn5FOUh1WPaag.png" /><figcaption>한쪽에서만 보이는 취조실 특수 유리. 스코프의 접근 권한과 비슷한 원리다. (역자)</figcaption></figure><blockquote>본 글은 <a href="https://css-tricks.com/javascript-scope-closures/">JavaScript Scope and Closures</a> by Zell Liew의 번역 글입니다.</blockquote><p>스코프와 클로저는 자바스크립트에서 굉장히 중요합니다. 하지만 제가 처음 자바스크립트를 시작할 때 이 두 개념이 굉장히 헷갈렸어요. 대체 스코프와 클로저가 무엇인지, 여러분이 이해할 수 있도록 도와드리고자 이 글을 준비했습니다.</p><p>그럼, 스코프부터 시작해 보도록 하죠.</p><h3><strong>스코프(Scope)</strong></h3><p>자바스크립트에서 스코프란 어떤 변수들에 접근할 수 있는지를 정의합니다. 스코프엔 두 가지 종류가 있는데요, 전역 스코프(global scope)와 지역 스코프(local scope)가 있죠.</p><h4><strong>전역 스코프(Global Scope)</strong></h4><p>변수가 함수 바깥이나 중괄호 ({}) 바깥에 선언되었다면, <strong>전역 스코프</strong>에 정의된다고 합니다.</p><blockquote>이 설명은 웹 브라우저의 자바스크립트에만 유효합니다. Node.js에서는 전역 스코프를 다르게 정의하지만, 이번 글에서는 다루지 않겠습니다.</blockquote><pre>const globalVariable = &#39;some value&#39;</pre><p>전역 변수를 선언하면, 여러분의 코드 모든 곳에서 해당 변수를 사용할 수 있습니다. 심지어 함수에서도 말이죠.</p><pre>const hello = &#39;Hello CSS-Tricks Reader!&#39;</pre><pre>function sayHello () {<br>  console.log(hello)<br>}</pre><pre>console.log(hello) // &#39;Hello CSS-Tricks Reader!&#39;<br>sayHello() // &#39;Hello CSS-Tricks Reader!&#39;</pre><p>비록 전역 스코프에 변수를 선언할 수는 있어도, 그러지 않는 것이 좋습니다. 왜냐하면, 두 개 이상의 변수의 이름이 충돌하는 경우가 생길 수도 있기 때문이죠. 만약 변수를 const나 let을 사용하여 선언했다면, 이름에 충돌이 발생할 때마다 에러가 발생합니다. 이렇게 되면 안 되죠.</p><pre>// Don’t do this!<br>let thing = &#39;something&#39;<br>let thing = &#39;something else&#39; // Error, thing has already been declared</pre><p>만약 var를 이용하여 변수를 선언했다면, 두 번째 변수가 첫 번째 변수를 덮어쓰게 됩니다. 이러면 디버깅이 어려워지기 때문에 이런 식으로 사용하면 안 됩니다.</p><pre>// Don’t do this!<br>var thing = &#39;something&#39;<br>var thing = &#39;something else&#39; // perhaps somewhere totally different in your code<br>console.log(thing) // ‘something else’</pre><p>그래서 여러분은 언제나 전역 변수가 아닌, 지역 변수로써 변수를 선언해야 합니다.</p><h4><strong>지역 스코프 (Local Scope)</strong></h4><p>여러분 코드의 특정 부분에서만 사용할 수 있는 변수는 지역 스코프에 있다고 할 수 있습니다. 이런 변수들은 지역 변수라고 불리죠.</p><p>자바스크립트에서는 두 가지의 지역 변수가 존재합니다. 바로 함수 스코프(function scope)와 블록 스코프(block scope)죠.</p><p>먼저 함수 스코프부터 알아보도록 합시다.</p><p><strong>함수 스코프(Function Scope)</strong></p><p>여러분이 함수 내부에서 변수를 선언하면, 그 변수는 선언한 변수 내부에서만 접근할 수 있습니다. 함수 바깥에서는 해당 변수에 접근할 수 없죠.</p><p>아래의 예제를 살펴보면 변수 hello는 sayHello의 스코프 내에 존재한다는 것을 알 수 있습니다.</p><pre>function sayHello () {<br>  const hello = &#39;Hello CSS-Tricks Reader!&#39;<br>  console.log(hello)<br>}</pre><pre>sayHello() // &#39;Hello CSS-Tricks Reader!&#39;</pre><pre>console.log(hello) // Error, hello is not defined</pre><p><strong>블록 스코프(Block Scope)</strong></p><p>여러분이 중괄호({}) 내부에서 const 또는 let으로 변수를 선언하면, 그 변수들은 중괄호 블록 내부에서만 접근할 수 있습니다.</p><p>다음 예제에서 볼 수 있듯이 변수 hello는 중괄호 내부의 스코프에 존재합니다.</p><pre>{<br>  const hello = &#39;Hello CSS-Tricks Reader!&#39;<br>  console.log(hello) // &#39;Hello CSS-Tricks Reader!&#39;<br>}</pre><pre>console.log(hello) // Error, hello is not defined</pre><p>함수를 선언할 때는 중괄호를 사용해야 하므로 블록 스코프는 함수 스코프의 서브셋(subset) 입니다(여러분이 화살표 함수(<a href="https://zellwk.com/blog/es6/#arrow-functions">arrow function</a>)를 사용해서 암시적(implicit) 반환을 하는게 아니라면 말이죠).</p><p><strong>함수 호이스팅(Function hoisting)과 스코프</strong></p><p>함수가 함수 선언식(function declaration)으로 선언되면, 현재 스코프의 최상단으로 호이스팅(hoist) 됩니다.</p><p>다음 예제에서 두 가지 경우는 같은 결과를 보입니다.</p><pre>// This is the same as the one below<br>sayHello()<br>function sayHello () {<br>  console.log(&#39;Hello CSS-Tricks Reader!&#39;)<br>}</pre><pre>// This is the same as the code above<br>function sayHello () {<br>  console.log(&#39;Hello CSS-Tricks Reader!&#39;)<br>}<br>sayHello()</pre><p>반면 함수가 함수 표현식(function expression)으로 선언되면, 함수는 현재 스코프의 최상단으로 호이스팅되지 않습니다.</p><pre>sayHello() // Error, sayHello is not defined<br>const sayHello = function () {<br>  console.log(aFunction)<br>}</pre><p>이렇게 두 방식의 행동이 다르기 때문에, 함수 호이스팅은 혼란스러울 수 있으므로 사용하면 안 됩니다. 언제나, 함수를 호출하기 전에 선언해놓아야 합니다.</p><p><strong>함수는 서로의 스코프에 접근할 수 없다</strong></p><p>함수들이 각각 선언되었을 때, 서로의 스코프에는 접근할 수 없습니다. 어떤 함수가 다른 함수에서 사용되더라도 말이죠.</p><p>아래의 예제에서, 함수 second는 변수 firstFunctionVariable에 접근할 수 없습니다.</p><pre>function first () {<br>  const firstFunctionVariable = &#39;I’m part of first&#39;<br>}</pre><pre>function second () {<br>  first()<br>  console.log(firstFunctionVariable) // Error, firstFunctionVariable is not defined<br>}</pre><p><strong>네스팅된 스코프(Nested scopes)</strong></p><p>함수가 다른 함수 내부에서 정의되었다면, 내부 함수는 외부 함수의 변수에 접근할 수 있습니다. 이런 행동을 렉시컬 스코핑(lexical scoping)이라고 부르죠.</p><p>하지만, 외부 함수는 내부 함수의 변수에 접근할 수 없습니다.</p><pre>function outerFunction () {<br>  const outer = &#39;I’m the outer function!&#39;<br>    <br>  function innerFunction() {<br>     const inner = &#39;I’m the inner function!&#39;<br>     console.log(outer) // I’m the outer function!<br>  }<br>    <br>  console.log(inner) // Error, inner is not defined<br>}</pre><p>스코프가 어떻게 동작하는지 그림을 그려보자면, 취조실 특수 유리(단방향 투과성 유리)를 상상하시면 됩니다. 여러분이 바깥을 바라볼 수는 있지만, 바깥에 있는 사람들은 여러분을 볼 수 없죠.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1000/1*94wTu61tmltShnyb5U0kgw.png" /><figcaption>함수의 스코프는 마지 단방향 투과성 유리와 같다. 당신은 바깥을 볼 수 있지만, 바깥사람들은 당신을 볼 수 없다.</figcaption></figure><p>만약 스코프 내부에 스코프가 있다면, 여러장의 취조실 유리가 겹쳐진 것처럼 그림을 그릴 수 있죠.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/936/1*okKkgfvr31oBiI_Gs90CPg.png" /><figcaption>여러 레이어로 이루어진 함수는 여러 레이어로 이루어진 단방향 투과성 유리와 같다.</figcaption></figure><p>지금까지 스코프에 대한 모든 것을 이해했으니, 이제 여러분은 클로저에 대해 이해하실 준비가 되었습니다.</p><h3>클로저(Closures)</h3><p>함수 내부에 함수를 작성할 때마다, 여러분은 클로저를 생성한 것입니다. 내부에 작성된 함수가 바로 클로저죠. 클로저는 차후에 외부 함수의 변수를 사용할 수 있기 때문에 대개 반환하여 사용합니다.</p><pre>function outerFunction () {<br>  const outer = &#39;I see the outer variable!&#39;</pre><pre>  function innerFunction() {<br>    console.log(outer)<br>  }</pre><pre>  return innerFunction<br>}</pre><pre>outerFunction()() // I see the outer variable!</pre><p>여기에서 내부 함수는 반환되기 때문에, 함수를 선언하자마자 반환되도록 코드를 조금 더 짧게 수정할 수 있습니다.</p><pre>function outerFunction () {<br>  const outer = &#39;I see the outer variable!&#39;<br>  <br>  return function innerFunction() {<br>    console.log(outer)<br>  }<br>}</pre><pre>outerFunction()() // I see the outer variable!</pre><p>클로저는 외부 함수의 변수에 접근할 수 있기 때문에, 일반적으로 두 가지 목적을 위해 사용합니다.</p><ol><li>사이드 이펙트(side effects) 제어하기</li><li>private 변수 생성하기</li></ol><h4>클로저로 사이드 이펙트 제어하기</h4><p>함수에서 값을 반환할 때를 제외하고 무언가를 행할 때 사이드 이펙트(side effects)가 발생합니다. 여러 가지 것들이 사이드 이펙트가 될 수 있는데요, 예를 들어 Ajax 요청이나 timeout을 생성할 때, 그리고 심지어 console.log를 선언하는 것도 사이드 이펙트 입니다.</p><pre>function (x) {<br>  console.log(&#39;A console.log is a side effect!&#39;)<br>}</pre><p>보통 Ajax나 timeout과 같이 코드 흐름을 방해하는 것들이 신경 쓰일 때, 클로저를 활용하여 사이드 이펙트를 제어합니다.</p><p>예제를 보며 조금 더 자세히 살펴보도록 합시다.</p><p>예를 들어, 여러분이 친구 생일을 위해 케이크를 만들어 주려고 한다고 해보죠. 케이크를 만드는 데 1초가 걸린다면, 1초 후에 made a cake을 로깅 하는 함수를 작성했습니다.</p><blockquote>예제를 더 짧고 이해하기 쉽게 작성하기 위해 ES6의 화살표 함수를 사용했습니다.</blockquote><pre>function makeCake() {<br>  setTimeout(_ =&gt; console.log(&#39;Made a cake&#39;), 1000)<br>}</pre><p>보다시피, 케이크를 만드는 함수는 사이드 이펙트가 존재합니다. 바로 timeout이죠.</p><p>이제는 친구가 케이크의 맛을 선택할 수 있도록 해봅시다. 그렇게 하기 위해선 맛을 추가할 수 있도록 makeCake함수를 작성할 수 있습니다.</p><pre>function makeCake(flavor) {<br>  setTimeout(_ =&gt; console.log(&#39;Made a ${flavor} cake!&#39;, 1000))<br>}</pre><p>함수를 실행하면, 1초가 지난 즉시 케이크가 만들어진다는 것을 유의해주세요.</p><pre>makeCake(‘banana’)<br>// Made a banana cake!</pre><p>그런데 문제가 생겼습니다. 여러분은 케이크의 맛을 알자마자 케이크를 만들고 싶지 않습니다. 맛을 알게 된 후에, 원하는 시점에 케이크를 만들고 싶죠.</p><p>이 문제를 해결하기 위해서, 맛의 정보를 담고 있는 prepareCake함수를 작성할 수 있습니다. 그리고 prepareCake함수 내부에서는 클로저인 makeCake을 반환합니다.</p><p>이제 여러분이 원하는 시점에 언제든지 반환된 함수를 호출할 수 있고, 호출한 후 1초 뒤에 케이크가 만들어질 겁니다.</p><pre>function prepareCake (flavor) {<br>  return function () {<br>    setTimeout(_ =&gt; console.log(&#39;Made a ${flavor} cake!&#39;, 1000))<br>  }<br>}</pre><pre>const makeCakeLater = prepareCake(‘banana’)</pre><pre>// And later in your code…<br>makeCakeLater()<br>// Made a banana cake!</pre><p>이와 같이 클로저를 활용하여 사이드 이펙트를 줄일 수 있습니다. 여러분이 원할 때 내부 클로저를 호출할 수 있는 함수를 만드는 것이죠.</p><h4>Private 변수와 클로저</h4><p>잘 아시다시피, 함수 내의 변수는 함수 바깥에서 접근할 수 없습니다. 그 변수들은 접근할 수 없기 때문에, private 변수라고 불립니다.</p><p>하지만, 해당 변수들에 접근해야 할 필요가 종종 발생합니다. 이것 또한 클로저를 활용해서 할 수 있죠.</p><pre>function secret (secretCode) {<br>  return {<br>    saySecretCode () {<br>      console.log(secretCode)<br>    }<br>  }<br>}</pre><pre>const theSecret = secret(&#39;CSS Tricks is amazing&#39;)<br>theSecret.saySecretCode()<br>// &#39;CSS Tricks is amazing&#39;</pre><p>해당 예제에서 saySecretCode는 유일하게 secret함수 바깥에서 secretCode를 노출하는 함수(클로저)입니다. 따라서, 이런 함수를 <strong>특권 함수(privileged function)</strong>라고 부르기도 합니다.</p><h3>개발자 도구(DevTools)를 사용하여 스코프 디버깅 하기</h3><p>크롬이나 파이어폭스의 개발자도구를 사용하면 현재 스코프에서 접근할 수 있는 변수들을 쉽게 디버깅할 수 있습니다. 두 가지 방법을 사용하여 이 기능을 사용할 수 있죠.</p><p>첫 번째 방법은 바로 debugger 키워드를 코드에 추가하는 것입니다. 이렇게 하면 브라우저상에서 자바스크립트의 실행을 일시 정지하여 디버깅할 수 있습니다.</p><p>prepareCake의 예제에 적용해봅시다.</p><pre>function prepareCake (flavor) {<br>  // Adding debugger<br>  debugger<br>  return function () {<br>    setTimeout(_ =&gt; console.log(&#39;Made a ${flavor} cake!&#39;, 1000))<br>  }<br>}</pre><pre>const makeCakeLater = prepareCake(&#39;banana&#39;)</pre><p>크롬에서 개발자 도구를 열어 Sources 탭(파이어폭스에서는 Debugger 탭)으로 이동하면 사용할 수 있는 변수들을 확인할 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1000/1*Nu5IIF7h66KvTgdJyY8l1g.png" /><figcaption>preareCake 스코프 디버깅하기</figcaption></figure><p>또, debugger키워드를 클로저 내부로 옮길 수 있습니다. 이번에는 스코프의 변수들이 어떻게 변했는지 살펴보세요.</p><pre>function prepareCake (flavor) {<br>  return function () {<br>    // Adding debugger<br>    debugger<br>    setTimeout(_ =&gt; console.log(&#39;Made a ${flavor} cake!&#39;, 1000))<br>  }<br>}</pre><pre>const makeCakeLater = prepareCake(&#39;banana&#39;)</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1000/1*Si3yT9ln7dOuuzNuwEGFaA.png" /><figcaption>클로저 스코프 디버깅하기.</figcaption></figure><p>디버깅을 하는 두 번째 방법으로는, 직접 Sources(또는 Debugger) 탭에서 코드 라인을 클릭하여 breakpoint를 추가하는 방식이 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1000/1*qtVfWXZ3jgDIOu5ZId6PQQ.png" /><figcaption>breakpoint를 추가하여 스코프 디버깅하기</figcaption></figure><h3>정리하며</h3><p>스코프와 클로저는 이해하기에 몹시 어려운 개념들은 아닙니다. 취조실 유리가 동작하는 원리로 생각해본다면 꽤 간단히 이해할 수 있죠.</p><p>함수 내부에서 변수를 선언할 때, 그 변수는 함수 내부에서만 접근할 수 있습니다. 이런 변수들은 함수의 스코프 위에 존재한다고 말합니다.</p><p>함수 내부에서 함수를 선언할 때, 내부의 함수는 클로저라고 불립니다. 이 클로저는 외부 함수에서 생성된 변수들에 접근할 수 있는 권한을 가지고 있습니다.</p><p>궁금증이 생기셨다면 어떤 질문이든지 남겨주세요. 제가 최대한 빨리 답해보도록 하겠습니다.</p><p>이 글이 마음에 드셨다면, 제가 <a href="https://zellwk.com/blog/">블로그</a>나 <a href="https://zellwk.com/newsletter/css-tricks/">뉴스레터</a>에 쓴 다른 프론트엔드 관련된 글도 마음에 드실 거에요. 그리고 제가 새로 만든 (무료에요!) 이메일 수업(<a href="https://jsroadmap.com/">JavaScript Roadmap</a>)도 있습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8d402c976d19" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>