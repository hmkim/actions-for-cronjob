<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>nGenius Blog</title>
    <description>All content copyright &lt;b&gt;nGenius Blog&lt;/b&gt; © 2017 • All rights reserved.</description>
    <link>http://nGeniuskr.github.io/</link>
    <atom:link href="http://nGeniuskr.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 13 Jan 2019 06:54:16 +0000</pubDate>
    <lastBuildDate>Sun, 13 Jan 2019 06:54:16 +0000</lastBuildDate>
    <generator>Jekyll v3.7.4</generator>
    
      <item>
        <title>[번역] 'Universal application code structure in Nuxt.js' translated by korean</title>
        <description>&lt;h1 id=&quot;nuxtjs의-유니버셜-어플리케이션-코드-구조&quot;&gt;Nuxt.js의 유니버셜 어플리케이션 코드 구조&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.freecodecamp.org/universal-application-code-structure-in-nuxt-js-4cd014cc0baa&quot;&gt;See original article (원문 보기)&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;유니버셜 어플리케이션의 정확하고 확실한 한글말(번역)을 찾을 수 도 없고 생각도 나지 않아 그냥 한글로 써놨습니다. (추측에는 NUXT의 소개말에서 온 어원으로 추측됩니다.)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;한글로 적어놨으나 의미전달이 불분명하다고 생각되는부분에는 소괄호로 영어나 한글을 첨언하였습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;오역에 대한 오류사항 수정관련 피드백 언제든지 환영합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;nuxtjs-코드-구조-짧은-요약입니다&quot;&gt;Nuxt.js 코드 구조 짧은 요약입니다&lt;/h2&gt;

&lt;p&gt;아직 nuxt.js 프레임 워크가 새롭고, nuxt.js의 많은 폴더가 생성된것에 놀라(overwhelmed)셨습니까? 또한 대부분의 폴더들이 비어있거나 readme.md 파일만 생성되어 있는 것에 놀랐(surprised)나요? 그때는 내가 1년 전 뭘 몰랐을 때 입니다. 그 이후로 나는 각 폴더가 Nuxt 프로젝트에서 동작하는 마법(적인 자동화)을 배우고, 문서화하는 것을 항상 원했습니다.&lt;/p&gt;

&lt;p&gt;그리고 지금, 몇몇 프로젝트에 이 프레임워크(nuxt)를 통해 구현해 본 후, 내가 이해한 서버 렌더링 된 Vue 어플리케이션을 각각의 폴더가 어떻게 작동 하는지에 대한 것을 문서화 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*lwIEF0F3eDlMKR1hKZic7Q.jpeg&quot; alt=&quot;nuxtjs code structure diagram&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 다이어그램은 &lt;a href=&quot;https://ssr.vuejs.org/guide/structure.html#introducing-a-build-step&quot;&gt;Vue SSR 가이드&lt;/a&gt;를 기반으로하며 Nuxt.js를 연관하여 확장되었습니다. 한 눈에 보기에도, &lt;em&gt;당신의 유니버설 어플리케이션 코드&lt;/em&gt; 섹션에서 폴더구조가 다른지와, 코드가 Nuxt에 의해 패키지화 되고 Webpack에 번들되는 방법을 볼 수 있습니다&lt;/p&gt;

&lt;p&gt;이 글은 Nuxt SSR에 대한 튜토리얼도 아니고 완벽한 안내서도 아닙니다. 오히려 유니버셜 어플리케이션의 시작에 필요한 내용(part)을 보여줍니다.&lt;/p&gt;

&lt;p&gt;다이어그램의 맨 위에 모듈, serverMiddleware 및 플러그인이 있지만 먼저 Store부터 시작합시다.&lt;/p&gt;

&lt;h3 id=&quot;vuex-저장소-store&quot;&gt;Vuex 저장소 (/store)&lt;/h3&gt;

&lt;p&gt;Vuex는 nuxt.js에 이미 포함되어있지만, &lt;em&gt;/store&lt;/em&gt; 디렉토리에 Vuex 저장소를 만들고 저장소를 만들지 않는 한 활성화되지 않습니다.&lt;/p&gt;

&lt;p&gt;이것은 모든 데이터 기반 프로젝트를 위한 매우 특별한 디렉토리입니다. 여기에서 데이터 저장소를 만들고 &lt;em&gt;nuxtServerInit&lt;/em&gt; 작업을 정의 할 수 있습니다. 이것은 거의 첫 번째 라이프 사이클 훅에서 발생합니다!&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;createStore&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Vuex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;  
      &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;사용자가 어플리케이션에 처음 액세스 할 때, 이것은 (Data)저장소를 채우거나, 업데이트하는 데 도움이됩니다. 또한 응용 프로그램 전체에서 데이터 상태를 유지 관리합니다.&lt;/p&gt;

&lt;h3 id=&quot;route-middleware-middleware&quot;&gt;Route Middleware (/middleware)&lt;/h3&gt;

&lt;p&gt;Nuxt에는 세 가지 종류의 라우트 미들웨어가 있습니다.
그것들은 &lt;em&gt;/middleware&lt;/em&gt; 디렉토리 하나의 모두 정의됩니다.&lt;/p&gt;

&lt;p&gt;여기서 다음과 같은 방법으로 사용할 수 있습니다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Global middleware — (Nuxt config에 추가하고 and 모든 routes 적용됩니다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// nuxt.config.js&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
  &lt;span class=&quot;na&quot;&gt;router&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;na&quot;&gt;middleware&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'authenticated'&lt;/span&gt;  
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Layout middleware (layouts 폴더 안 파일에 추가하고, 일치하는 라우트 그룹에 영향을 줍니다, 즉 인증 된 사용자 만 보거나 액세스 할 수 있는 특정 페이지 같은 것을 예로 들수 있습니다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// layouts/default.vue&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
  &lt;span class=&quot;na&quot;&gt;middleware&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'authenticated-basic-plan-user'&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Page middleware (page component 폴더 안 파일에 추가하고 각각의 라우트(=경로)에서 작동합니다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// pages/index.vue&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;middleware&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'subscribed'&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 미들웨어는 정확히 위의 순서로 처리됩니다. 즉, 우선 순위를 변경 할 수 없습니다. 따라서 신중하게 검토하고 신중하게 계획을 세워야만, 그것들(middleware)을 최대한 활용할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;vue-컴퍼넌트&quot;&gt;Vue 컴퍼넌트&lt;/h3&gt;

&lt;p&gt;Nuxt 프로젝트에서 &lt;em&gt;.vue&lt;/em&gt; 파일이 생성되는 세 개의 디렉토리가 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;1-page-components--pages&quot;&gt;&lt;strong&gt;1. Page components 👑 (/pages)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;이것은 어플리케이션의 뷰와 라우트와 관련되어 있는 모든 디렉터리 중 가장 중요한 디렉터리입니다. 여기에 생성 된 Vue.js 구성 요소는 어플리케이션 route로 직접 변환됩니다.&lt;/p&gt;

&lt;p&gt;페이지 컴퍼넌트의 진정한 강점은 동적 경로에 있습니다. 당신은 이것(동적 경로)을 사용하여 SEO 친화적인 데이터 지향적 URL을 생성 할 수 있습니다. 동적 경로는 &lt;em&gt;/pages.&lt;/em&gt; 아래의 디렉토리 구조를 기반으로 생성됩니다.&lt;/p&gt;

&lt;p&gt;또한, Nuxt는 다른 곳에서는 사용할 수 없는 페이지 구성 요소에 세 가지 특수 메소드를 추가 할 수도 있습니다. 그들은 &lt;em&gt;validate()&lt;/em&gt; , &lt;em&gt;asyncData()&lt;/em&gt;, &lt;em&gt;fetch()&lt;/em&gt; 입니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// pages/index.vue&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;validate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// dynamic URL 인자 값을 검증합니다.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 데이터의 가용성을 확인한다.&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;asyncData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// component 데이터를 설정(set)합니다.&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 구성 요소 데이터를 설정하지 않지만, 추가적으로 컨텍스트 데이터를 가져옵니다.  &lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2-layout-components-layouts&quot;&gt;&lt;strong&gt;2. Layout components (/layouts)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;레이아웃 컴퍼넌트는 어플리케이션의 구조적 측면(체계)을 강화합니다. 모든 페이지에 있는 공통 컴퍼넌트가 여기에 올려지게(found on) 됩니다 (기본 메뉴, 보조 메뉴, 머리글, 바닥 글 등). 그것들은 &lt;em&gt;/layouts&lt;/em&gt; 디렉토리에 있습니다.&lt;/p&gt;

&lt;p&gt;당신이 생각하는데로(creative) 이 공간을 꾸밀 수 있고, 그리고 그 꾸밈의 도구는 Vue.js의 컴퍼넌트 입니다. 레이아웃 매인 컨텐츠 구역에 &lt;em&gt;&amp;lt;nuxt/&amp;gt;&lt;/em&gt; 를 추가하나는 것을 잊지 마세요.&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;template&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;nuxt/&amp;gt;&lt;/span&gt; /* 선언을 잊지 마세요! */
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/template&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다양한 시나리오에 대응하는 많은 사용자 유형에 맞는 &lt;em&gt;누가 무엇을 볼지(who-sees-what)&lt;/em&gt; 에 대한 기능을 담은 완벽한 레이아웃 컴퍼넌트를 구축하기 위해 &lt;em&gt;라우트-미들웨어&lt;/em&gt; 와 &lt;em&gt;데이터-상태 저장소&lt;/em&gt; 를 구성하세요(Incorporate). 커스텀 유져 인터페이스를 사용하는 것보다 더 많은 것을 얻을 수 있습니다. (오역주의)&lt;/p&gt;

&lt;h4 id=&quot;3-vuejs-components-components&quot;&gt;&lt;strong&gt;3. Vue.js components (/components)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;이들은 형식적(regular)이지만 다재다능한 Vue 컴퍼넌트들입니다. &lt;em&gt;/components&lt;/em&gt; 디렉토리에 만들어집니다. 해당 디랙토리 안의 컴퍼넌트들은 Page 컴퍼넌트와 같은 특별한 방법으로 무언가가 되지 않습니다.&lt;/p&gt;

&lt;p&gt;하지만 비즈니스 로직을 구조화하고 구성 할 수 있습니다. 또한 &lt;strong&gt;페이지&lt;/strong&gt; 및 &lt;strong&gt;레이아웃&lt;/strong&gt; 컴퍼넌트에서 큰 마크업 구조(HTML)을 숨깁니다. 이렇게 하면 코드베이스를보다 쉽게 ​​관리 할 수 ​​있습니다.&lt;/p&gt;

&lt;p&gt;이제 자세히 살펴보십시오 - Nuxt 라이프 사이클 다이어그램의 부분 폴더 구조가 이해 되시나요(can you see)?
&lt;strong&gt;힌트:&lt;/strong&gt; 저장소 (nuxtServerInit), 라우트 미들웨어 및 페이지 컴퍼넌트들 (validate, asyncData 및 fetch 메소드)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://pbs.twimg.com/media/DeDKSyuUwAARbq-.jpg&quot; alt=&quot;Nuxt.js Lifecycle Hooks&quot; /&gt;&amp;lt;blockquote class=&quot;twitter-tweet&quot; data-lang=&quot;ko&quot;&amp;gt;&amp;lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&amp;gt;Understanding Nuxt.js Lifecycle Hooks… &lt;a href=&quot;https://twitter.com/nuxt_js?ref_src=twsrc%5Etfw&quot;&gt;@nuxt_js&lt;/a&gt; &lt;a href=&quot;https://twitter.com/vuejs?ref_src=twsrc%5Etfw&quot;&gt;@vuejs&lt;/a&gt; …had ton of fun creating this diagram. ✍️ &lt;a href=&quot;https://t.co/nDu1dXRfEF&quot;&gt;pic.twitter.com/nDu1dXRfEF&lt;/a&gt;&amp;lt;/p&amp;gt;— krutiepatel (@KrutiePatel) &lt;a href=&quot;https://twitter.com/KrutiePatel/status/1000022559184764930?ref_src=twsrc%5Etfw&quot;&gt;2018년 5월 25일&lt;/a&gt;&amp;lt;/blockquote&amp;gt;&lt;/p&gt;

&lt;h3 id=&quot;assets&quot;&gt;Assets&lt;/h3&gt;

&lt;h4 id=&quot;webpacked-assets-assets&quot;&gt;&lt;strong&gt;Webpacked assets (/assets)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;JavaScript 파일, 커스텀 글꼴 및 CSS 파일과 같은 Asset은 파일 형식에 따라 특정 로더(css-loader, file-loader, url-loader etc)를 사용하여 Webpack에서 처리됩니다. 예를 들어 CSS를 &lt;em&gt;.scss&lt;/em&gt; 또는 &lt;em&gt;.less&lt;/em&gt; 문법으로 작성하면 Webpack은 특정 로더를 사용하여 이러한 파일을 처리하고 브라우저에서 사용할 수있는 컴파일 된 &lt;em&gt;.css&lt;/em&gt; 파일을 만들어냅니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;nuxt.config.js&lt;/em&gt; 의 값을 조정하며 Webpack에서 빌드 프로세스의 일부로 assets 폴더의 이미지를 축소 및 최적화하도록 설정 할 수도 있습니다. Webpack이 파일을 처리 한 후 처리 된 항목에 해시 코드를 첨부(&lt;em&gt;예 : index.4258e3668a44556dd767.js&lt;/em&gt;)하면 동적 자산의 장기간 캐싱과 캐시 무효화에 도움이됩니다.&lt;/p&gt;

&lt;h4 id=&quot;static-assets-static&quot;&gt;&lt;strong&gt;Static assets (/static)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;변경되지 않는 파일(assets)의 경우 &lt;em&gt;static&lt;/em&gt; 폴더에 안전하게 보관할 수 있습니다. Webpack은 static 폴더를 무시하고 static 폴더 안에 것 전부 다 처리하지 않습니다.&lt;/p&gt;

&lt;h3 id=&quot;modules-servermiddleware-and-plugins&quot;&gt;Modules, serverMiddleware and plugins&lt;/h3&gt;

&lt;p&gt;위의 것들(modules, serverMiddleware, plugins)은 Nuxt 구성으로 (경로 별로) 모두 정의됩니다. 그것들은 Nuxt 어플리케이션 내에서 어디에서도(globally) 접근 가능합니다.&lt;/p&gt;

&lt;h4 id=&quot;modules-modules&quot;&gt;&lt;strong&gt;Modules (/modules)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;새로만들어진(fresh) Nuxt 응용 프로그램은 기본적으로 Vue, Vue Router, Vuex, Vue Server Rendered 및 Vue Meta와 함께 미리 패키지되어 있습니다.&lt;/p&gt;

&lt;p&gt;하지만 Sitemap, Google Analytics, Progressive Web Apps 등과 같은 것들은 사용할때는 어떻게 해야할까요? 모듈을 사용할 생각이라면 네, 맞습니다. 이것이 Nuxt 모듈의 강점입니다.&lt;/p&gt;

&lt;h4 id=&quot;servermiddleware-ie-api&quot;&gt;&lt;strong&gt;serverMiddleware (i.e. /api)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;serverMiddleware는 응용 프로그램의 확장 점으로 간주 될 수 있습니다. serverMiddleware은 &lt;a href=&quot;https://github.com/senchalabs/connect&quot;&gt;connect 프레임 워크&lt;/a&gt;를 기본 인스턴스로서 접근 할 수 있기 때문에 특별합니다.&lt;/p&gt;

&lt;p&gt;Nuxt는 &lt;strong&gt;connect&lt;/strong&gt;를 사용하여 애플리케이션을 재공하기 때문에 사용자 정의 함수를 미들웨어로 기본 요청 파이프 라인에 연결할 수 있습니다.&lt;/p&gt;

&lt;p&gt;serverMiddleware를 사용하여 다음을 수행 할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;외부 어플리케이션에 연결할 API 엔드 포인트를 생성&lt;/li&gt;
  &lt;li&gt;Nuxt 응용 프로그램에서 사용자에게 이메일을 보낼 API 엔드 포인트를 생성&lt;/li&gt;
  &lt;li&gt;어떤식으로든 Nuxt에 도달하기 전에의 요청을 ​​접근하고 수정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;serverMiddleware 및 모듈 용으로 미리 채워진 빈 폴더가 없다는 점을 알아두세요. 필요한 경우 만들면 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;plugins-plugins&quot;&gt;&lt;strong&gt;Plugins (/plugins)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;기존의 Vue 믹스인, 필터 또는 directive를 Nuxt 플러그인으로 변환하면 더 열심히 일하게됩니다. Nuxt 설치와 함께 제공되는 &lt;em&gt;/plugins&lt;/em&gt; 디렉토리에 해당 파일을 저장합니다.&lt;/p&gt;

&lt;p&gt;하지만 대부분의 경우 외부 패키지 또는 Vue 라이브러리를 Nuxt 플러그인으로 추가하게됩니다. &lt;em&gt;Vue.use()&lt;/em&gt; 구문을 사용하여 Nuxt에 통합 할 수 있습니다. 내(저자) Nuxt 프로젝트 안에서 항상 사용하는 주요(staple) 플러그인 중 일부는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Vue Bootstrap&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;form validation&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;font-awesome icon-set&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;axios&lt;/code&gt;입니다.&lt;/p&gt;

&lt;p&gt;이게 플러그인 역활의 끝이 아닙니다. 사용자 정의 플러그인을 작성하여 응용 프로그램 루트에 추가 할 수 있습니다. Nuxt 어플리케이션에서 어디서든 접근할수 있도록(globally) 사용할 수 있습니다. 이것은 변형시킨 GreenSock 또는 Scroll-Magic transitions을 프로젝트에 추가하고 Vue &lt;em&gt;(/components)&lt;/em&gt; 및 Page &lt;em&gt;(/pages)&lt;/em&gt; 구성 요소에서 사용하는 것이 개인적으로 가장 자주사용하는 방법입니다.&lt;/p&gt;

&lt;h4 id=&quot;high-level-overview-of-modules-servermiddleware-and-plugins&quot;&gt;High-level overview of modules, serverMiddleware and plugins&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://pbs.twimg.com/media/DeqXp7PUwAAvMIk.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;blockquote class=&quot;twitter-tweet&quot; data-lang=&quot;ko&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;Understanding modules, serverMiddleware and plugins in Nuxt Js Configuration &lt;a href=&quot;https://twitter.com/nuxt_js?ref_src=twsrc%5Etfw&quot;&gt;@nuxt_js&lt;/a&gt; &lt;a href=&quot;https://twitter.com/vuejs?ref_src=twsrc%5Etfw&quot;&gt;@vuejs&lt;/a&gt; ✍️ &lt;a href=&quot;https://t.co/QSubHBkECP&quot;&gt;pic.twitter.com/QSubHBkECP&lt;/a&gt;&lt;/p&gt;&amp;mdash; krutiepatel (@KrutiePatel) &lt;a href=&quot;https://twitter.com/KrutiePatel/status/1002781159997100033?ref_src=twsrc%5Etfw&quot;&gt;2018년 6월 2일&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;https://platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;h3 id=&quot;package-bundle-and-deliver&quot;&gt;Package, bundle and deliver&lt;/h3&gt;

&lt;p&gt;원하는 기능을 다 만들었다면, &lt;em&gt;npm run build&lt;/em&gt; 를 사용하여 어플리케이션을 빌드할 수 있습니다. Nuxt가  어플리케이션을 패키지화합니다.&lt;/p&gt;

&lt;p&gt;아래 다이어그램에 표시된 것처럼 &lt;em&gt;index.js&lt;/em&gt; 는 &lt;em&gt;app.js&lt;/em&gt; 를 가져 오는 메인 진입 점입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*5K1HLp5zxlKfwlM7X2BdZw.jpeg&quot; alt=&quot;IMAGE;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nuxt가 코드를 패키지화합니다. Webpack 번들로 코드를 전달합니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;App.js&lt;/em&gt; 는 루트 Vue 인스턴스를 정의합니다. &lt;em&gt;.nuxt/App.js&lt;/em&gt; 를 면밀히 살펴보면 Vue 구성 요소 일 뿐입니다.&lt;/p&gt;

&lt;p&gt;이 root Vue 인스턴스가 정의되면 클라이언트 구성요소(&lt;em&gt;client.js&lt;/em&gt;)는 이를 기반으로 새 인스턴스를 만들고 이를 DOM 요소에 마운트 합니다.&lt;/p&gt;

&lt;p&gt;사용자는 그들의 브라우저에서 새로운 앱 인스턴스를 보게됩니다. 서버 구성요소(&lt;em&gt;server.js&lt;/em&gt;)는 (클라이언트의)요청 마다 새로운 앱 인스턴스를 만듭니다.&lt;/p&gt;

&lt;p&gt;마지막으로 Webpack은 클라이언트와 서버 측 모두에서 코드가 실행되도록 앱을 묶습니다. 서버 번들은 서버 측을 렌더링하고 클라이언트 번들은 정적 HTML 마크 업을 브라우저에 활성화(hydrates) 시킵니다. 클라이언트 측 데이터 변경에 반응 할 수 있는 다이나믹 DOM(Virtual DOM?) 으로 변환합니다.&lt;/p&gt;

&lt;p&gt;Nuxt는이 모든 작업을 자동으로 수행하므로 수동으로 설정을 필요가 없습니다. 복잡성의 많은 부분이 패키징 및 번들의 마지막 두 단계로 진행됩니다. 그러나 Nuxt는 모든 것을 숨깁니다. 그리하여 다른것은 신경쓰지 않고 제품(the final application)의 어플리케이션 코드에 집중할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;결론&quot;&gt;결론&lt;/h3&gt;

&lt;p&gt;Naxt 프레임 워크의 학습 과정에서 애플리케이션 코드 구조에 대한 더 높은 수준의 개요를 통해 한 걸음 더 나아갈 수 있기를 바랍니다.&lt;/p&gt;

&lt;p&gt;이것은 Nuxt 애플리케이션에서 모든 것이 어떻게 잘 맞는지 이해하는 데 도움이되는 많은 대체적인 관점 중 하나 입니다.&lt;/p&gt;

&lt;p&gt;개인적으로, 이 가벼운(little) 연습은 저(me)에게 도움이됩니다. (오역주의)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Nuxt의 기본적인(out-of-the-box) 기능에 대해 프로젝트 요구 사항을 제시&lt;/li&gt;
  &lt;li&gt;이미 사용 가능한 관련 커뮤니티 모듈 및 플러그인 나열, 그리고&lt;/li&gt;
  &lt;li&gt;커스텀 개발이 필요한 남겨진 부분 혹은 복잡한 부분(bits)를 선택하십시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;위에서-사용-된-다이어그램의-고해상도-버전과-연결됩니다&quot;&gt;&lt;strong&gt;위에서 사용 된 다이어그램의 고해상도 버전과 연결됩니다.&lt;/strong&gt;&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://bit.ly/2xv6PDV&quot;&gt;Nuxt Js lifecycle hooks&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://bit.ly/2sHNieo&quot;&gt;Understanding modules, serverMiddleware and plugins&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://bit.ly/2MFl23s&quot;&gt;Universal application code in Nuxt.js&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;의견, 피드백 또는 보고 싶은 새로운 다이어그램 아이디어에 대한 제안을 언제든지 얻을 수 있습니다 (아래의 설명 섹션 참조).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*IslxntaSDwDHfcKEieqDng.jpeg&quot; alt=&quot;IMAGE&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.pariksha.io/&quot;&gt;https://www.pariksha.io/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Nuxt에 익숙하지 않다면, “&lt;a href=&quot;https://codeburst.io/why-nuxt-js-is-perfect-framework-for-your-landing-page-53e214649b88&quot;&gt;Why Nuxt Js is the perfect framework for your landing page?&lt;/a&gt;“에 대한 이전 기사를 확인해보십시오. 그것은 당신에게 더 깊은 Nuxt로 어플리케이션을 개발할 때의 핵심에 대한 통찰력을 줄 것 입니다.&lt;/p&gt;

&lt;h3 id=&quot;아직도-nuxt를-안-사용하시나요&quot;&gt;아직도 Nuxt를 안 사용하시나요?&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*xV6a7Pxle-OrI10wcbCCeQ.jpeg&quot; alt=&quot;IMAGE&quot; /&gt;&lt;/p&gt;

&lt;p&gt;@_achopin이 @vuejsamsterdam에서 “Are you Nuxt?”라고 물었을 때, 저는 “hey… I am Nuxt”라고 생각했습니다.&lt;/p&gt;

&lt;p&gt;그리고 관심이 있다면 Moo Printing에서 인쇄하고 배달 해줄 &lt;a href=&quot;https://www.etsy.com/au/shop/CrewShopDesigns&quot;&gt;Nuxt 스티커&lt;/a&gt; 를 만들었음을 알려드립니다. 또는 &lt;a href=&quot;https://www.redbubble.com/people/krutie?asc=u&quot;&gt;RedBubble&lt;/a&gt;에서도 주문할 수 있습니다.&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Nov 2018 00:00:00 +0000</pubDate>
        <link>http://nGeniuskr.github.io/2018/11/19/introduce-nuxtjs.html</link>
        <guid isPermaLink="true">http://nGeniuskr.github.io/2018/11/19/introduce-nuxtjs.html</guid>
        
        
      </item>
    
      <item>
        <title>OS: process sync</title>
        <description>&lt;h2 id=&quot;프로세스-동기화를-고민해야-하는-이유&quot;&gt;프로세스 동기화를 고민해야 하는 이유&lt;/h2&gt;

&lt;p&gt;Process가 CPU에서 일정하게 순차적으로 돌아간다면 이 고민은 하지 않아도 될 지 모른다. 하지만 현재 Process는 병렬적 혹은 동시성을 지닌 상태로 돌아가게 되기 때문에 이 문재의 고민은 시작한다.&lt;/p&gt;

&lt;h3 id=&quot;고민을-구체화-시켜줄-예제&quot;&gt;고민을 구체화 시켜줄 예제&lt;/h3&gt;

&lt;p&gt;연산자 &lt;code class=&quot;highlighter-rouge&quot;&gt;counter++&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;counter--&lt;/code&gt;를 생각해 보자. 이 연산자는 counter라고 이름 붙여진 저장공간(변수)에 저장되어 있는 값을 1씩 증가시키거나 감소시키는 연산자다. 이 연산자를 기계어 수준으로 잘라보면 다음과 같은 공정을 가질 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c1&quot;&gt;// counter++
&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;register1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;register1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;register1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;register1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c1&quot;&gt;// counter--
&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;register1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;register1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;register1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;register1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;각 한줄이 하나의 task(cpu가 처리하는 단위)라는 가정하에 아래의 코드를 진행한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;    counter++;
    counter--;
    printf(&quot;%d\n&quot;, counter); // 5? 4? 6?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 위의 코드를 진행하는 스케쥴 표이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Task&lt;/th&gt;
      &lt;th&gt;Process&lt;/th&gt;
      &lt;th&gt;state&lt;/th&gt;
      &lt;th&gt;task infomation&lt;/th&gt;
      &lt;th&gt;processed data&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;T0&lt;/td&gt;
      &lt;td&gt;producer&lt;/td&gt;
      &lt;td&gt;execute&lt;/td&gt;
      &lt;td&gt;register1 = counter&lt;/td&gt;
      &lt;td&gt;register1 = 5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;T1&lt;/td&gt;
      &lt;td&gt;producer&lt;/td&gt;
      &lt;td&gt;execute&lt;/td&gt;
      &lt;td&gt;register1 = register1 + 1&lt;/td&gt;
      &lt;td&gt;register1 = 6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;T2&lt;/td&gt;
      &lt;td&gt;consumer&lt;/td&gt;
      &lt;td&gt;execute&lt;/td&gt;
      &lt;td&gt;register2 = counter&lt;/td&gt;
      &lt;td&gt;register2 = 5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;T3&lt;/td&gt;
      &lt;td&gt;consumer&lt;/td&gt;
      &lt;td&gt;execute&lt;/td&gt;
      &lt;td&gt;register2 = register2 - 1&lt;/td&gt;
      &lt;td&gt;register2 = 4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;T4&lt;/td&gt;
      &lt;td&gt;producer&lt;/td&gt;
      &lt;td&gt;execute&lt;/td&gt;
      &lt;td&gt;counter = register1&lt;/td&gt;
      &lt;td&gt;counter = 6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;T5&lt;/td&gt;
      &lt;td&gt;consumer&lt;/td&gt;
      &lt;td&gt;execute&lt;/td&gt;
      &lt;td&gt;counter = register2&lt;/td&gt;
      &lt;td&gt;counter = 4&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위와 같은 상황이 100% 저렇게만 진행 되진 않지만 저렇게 진행될 가능성이 있고 이는 코드를 작성한 사람의 의도대로 결과가 나오지 않게 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이처럼 두 개 이상의 프로세스가 공통 자원을 병행적으로(concurrently) 읽거나 쓸 때, 공용 데이터에 대한 접근이 어떤 순서에 따라 이루어졌는지에 따라 그 실행 결과가 달라지는 상황을 &lt;code class=&quot;highlighter-rouge&quot;&gt;Race Condition&lt;/code&gt;이라고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;크리티컬-섹션-문제&quot;&gt;크리티컬 섹션 문제&lt;/h2&gt;

&lt;p&gt;각 프로세스 안에는 크리티컬 섹션(critical section)이라는 부분이 있다. 크리티컬 섹션은 해당 프로세스가 다른 프로세스와 함께쓰는(공용) 데이터를 불러오거나 쓰는 부분이다. 여기서 문제가 발생하는데 여러 프로세스가 동시에 같은 공용 데이터를 사용하게 될 떄 위와 같은 문제가 발생하게 되며 이를 방지 하기 위해 공용 데이터를 접근할 때에는 접근을 허가하는 요청을 보내고 요청이 수락 되었을 때 접근 할 수 있도록 하는 규약(protocol)을 정함으로서 크리티컬 섹션 문제를 해결한다.&lt;/p&gt;

&lt;p&gt;아래의 그림은 일반적인 프로세스 구조로 각 영역별 역활이 있으며 entry section에서는 critical section을 접근 요청하고 접근 허가가 날때까지 대기하며, exit section의 경우에는 허가받은 권한을 돌려주는 과정을 진행해야한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-04-13-jump-to-os-processSync/criticalSection.png&quot; alt=&quot;일반적인 process 구조&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;크리티컬-섹션을-만족하는-조건&quot;&gt;크리티컬 섹션을 만족하는 조건.&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Mutual exclusion(상호 배제): 한 프로세스가 크리티컬 섹션을 사용한다면 다른 프로세스는 크리티컬 섹션을 접근 할 수 없다.&lt;/li&gt;
  &lt;li&gt;Progress(진행): 크리티컬 섹션이 사용 중이지 않다면 접근을 원하는 프로세스는 언제든지 크리티컬 섹션에 접근 할 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;Bounded waiting(한정된 대기): 기다리는 시간은 한정적이여야 하며 무한정 기다려선 안된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;크리티컬-섹션-문제의-해결-조건들을-만족하는-여러-알고리즘&quot;&gt;크리티컬 섹션 문제의 해결 조건들을 만족하는 여러 알고리즘&lt;/h2&gt;

&lt;h3 id=&quot;피터슨-알고리즘&quot;&gt;피터슨 알고리즘&lt;/h3&gt;

&lt;p&gt;소프트웨어로서 해결한 알고리즘, 피터슨 알고리즘이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;do {

    flag[i] = true;
    turn = j;
    while (flag[j] &amp;amp;&amp;amp; turn == j); // Busy Waiting
    
        // critical section
    
    flag[i] = false;

        // remainder section 

} while (true);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;둘다 접근하여고 하는 경우에는 turn 의 값으로 접근할 프로세스가 결정된다. 
그렇지 않은 경우에는 flag값을 통해서 접근할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 이 알고리즘에는 문제가 없는 것은 아니다. Busy Waiting(=spin lock)의 문제가 발생한다. 계속 CPU와 Memory를 사용하면서 대기하는 상황인 것이다. 쓸데 없이 while 속에서 무한루프를 반속하며 대기하고 있는 것은 비효율 적인 방법이다.&lt;/p&gt;

&lt;h3 id=&quot;하드웨어-동기화&quot;&gt;하드웨어 동기화&lt;/h3&gt;
&lt;p&gt;사실 소프트웨어에서의 동기화는 커널의 인터럽트에 의해 모든 규칙이 께어질 수 있다. 그래서 하드웨어 단에서 크리티컬 섹션을 만족시키기 위한 기능을 구현되었다. 대부분 locking을 이용하여 크리티컬 섹션을 보호한다.&lt;/p&gt;

&lt;p&gt;locking을 사용한다는 것은 크리티컬 섹션을 접근하기 전에 이 섹션에 대한 접근을 막고 단독적으로 사용한다는 의미이다. 그리고 사용이 종료되면 락을 풀고 다른 프로세스가 사용할 수 있도록 하는것이다.&lt;/p&gt;

&lt;p&gt;단일 처리 환경(싱글프로세서)에서 공유 변수가 변경되는 동안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;인터럽트&lt;/code&gt;를 금지함으로서 동기화 문제를 해결하였다.(하지만 지금은 멀티 프로세스 시대)&lt;/p&gt;

&lt;p&gt;지금은 &lt;code class=&quot;highlighter-rouge&quot;&gt;원자적(atomic) 하드웨어 명령어&lt;/code&gt;를 제공함.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;원자적(atomic) : 인터럽트 되지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;test_and_set&quot;&gt;test_and_set()&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;한 워드(word)의 내용을 검사하고 변경 명령어 이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;라고 공룡책에 정리되어있다.&lt;/p&gt;

&lt;p&gt;test_and_set()을 코드로 표현한다면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// default lock = false
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_and_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// target == lock
&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test_and_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* do nothing */&lt;/span&gt;

        &lt;span class=&quot;cm&quot;&gt;/* critical section */&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;cm&quot;&gt;/* remainder section */&lt;/span&gt; 

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;크리티컬 섹션에 접근하기 위해 test_and_set을 무한하게 실행시키면서, lock변수가 false가 되는 것을 기다린다. 이미 크리티컬 섹션을 점유하였던 프로세스가 용무를 마치고 &lt;code class=&quot;highlighter-rouge&quot;&gt;크리티컬 섹션의 사용 권한을 반납(=&amp;gt; lock = false)&lt;/code&gt;하게 되면 기다리고 있던 프로세스 중에 첫번 째로 test_and_set을 실행시킨 프로세스가 무한 루프를 빠저나가면서 &lt;code class=&quot;highlighter-rouge&quot;&gt;크리티컬 섹션의 사용 권한을 획득(=&amp;gt; lock = true)&lt;/code&gt;하고 크리티컬 섹션을 점유하게된다.&lt;/p&gt;

&lt;h4 id=&quot;compare_and_swap&quot;&gt;compare_and_swap()&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;두 워드(expacted, newValue)의 내용을 원자적으로 교환&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;라고 공룡책에 정리되어있다.&lt;/p&gt;

&lt;p&gt;compare_and_swap()을 코드로 표현한다면 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// default lock = 0
&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compare_and_swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
            &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compare_and_swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* do nothing */&lt;/span&gt;
            &lt;span class=&quot;cm&quot;&gt;/* critical sexction */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;cm&quot;&gt;/* remainder section */&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;마찬가지로 크리티컬 섹션에 접근하기 위해 compare_and_swap을 무한하게 실행시키면서, lock변수가 0이 되는 것을 기다린다. 이미 크리티컬 섹션을 점유하였던 프로세스가 용무를 마치고 &lt;code class=&quot;highlighter-rouge&quot;&gt;크리티컬 섹션의 사용 권한을 반납(=&amp;gt; lock = 0)&lt;/code&gt;하게 되면 기다리고 있던 프로세스 중에 첫번 째로 compare_and_swap을 실행시킨 프로세스가 무한 루프를 빠저나가면서 &lt;code class=&quot;highlighter-rouge&quot;&gt;크리티컬 섹션의 사용 권한을 획득(=&amp;gt; lock = newValue, 위의 코드에서는 1)&lt;/code&gt;하고 크리티컬 섹션을 점유하게된다.&lt;/p&gt;

&lt;h4 id=&quot;위의-두-기능에-부족한-것이-있다&quot;&gt;위의 두 기능에 부족한 것이 있다.&lt;/h4&gt;

&lt;p&gt;위의 두 기능은 크리티컬 섹션의 접근 허가를 무작위로 하고 있기 때문에 한 프로세스의 &lt;strong&gt;bounded waiting이 지켜지지 않을 수도 있다&lt;/strong&gt;. 이을 보완 하기 위해 대기 큐를 만들어서 확인 후 대기 순번에 맞추어서 프로세스를 실행 시키는 방법을 도입한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;waiting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;waiting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test_and_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;waiting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 

        &lt;span class=&quot;cm&quot;&gt;/* critical section */&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// waiting queue안의 i의 다음 프로세스
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;waiting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 대기 중인 프로세스가 없는 경우 
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 첫번째 대기 중인 프로세스인 경우 
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;waiting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* remainder section */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;mutex&quot;&gt;mutex&lt;/h2&gt;

&lt;p&gt;하드웨어를 기반으로 하는 해결책의 경우에는 확실한 방법이 되기도 하지만 동시에 프로그래머가 사용하기에는 복잡하다.(대부분 c low level 코드이거나 어샘블리단의 기능)&lt;/p&gt;

&lt;p&gt;그래서 운영체제에서 소프트웨어에서 하드웨어적으로 사용되었던 기능을 사용할 수 있도록 툴을 만들어 제공하고 있다.&lt;/p&gt;

&lt;p&gt;가장 간단한 방식의 기능이 &lt;strong&gt;mut&lt;/strong&gt;ual &lt;strong&gt;ex&lt;/strong&gt;clusion(상호 배제)를 제공하는 mutex이다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 함수 내용이 원자적으로 실행 됨
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;available&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// busy wait
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;abailable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 함수 내용이 원자적으로 실행 됨
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;available&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// critical section
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// remainder section
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;락획득(acquire())과 락방출(release())함수로 크리티컬 섹션을 보호&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;acquire()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;release()&lt;/code&gt; 둘은 원자적으로 실행되어야 함.&lt;/li&gt;
  &lt;li&gt;락 획득을 하기 위한 대기 방법으로 busy wait(spin lock) 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;semaphore세마포어&quot;&gt;semaphore(세마포어)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로세스들을 동기화 시키는 (multex 락 보다) 좀 더 복잡한 동기화툴&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이라고 공룡책에 서술되어 있으나 사실 mutex == semaphore라고 보면 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;세마포어 &lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt; 는 정수이다.&lt;/li&gt;
  &lt;li&gt;두 개의 표준 원자적 연산 wait()과 signal()로만 세마포어를 접근 할 수 있다.&lt;/li&gt;
  &lt;li&gt;wait()과 signal()는 원자적이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// busy wait
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;S가 0이면 락 상태이다. S값에 초기 값에 따라 동시에 접근 할 수 있는 프로세스의 수가 달라지며 S값이 1인 세마포어를 이진 세마포어라고 하며 mutex와 같은 역활을 한다.&lt;/p&gt;

&lt;h3 id=&quot;세마포어는-어렵다&quot;&gt;세마포어는 어렵다.&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;인간은 누구나 실수를 한다`&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그런 가능성이 있기 때문에 코드를 꼼꼼히 봐야하지만, 실수를 하기 때문에 다음과 같은 상황이 발생 할 수도 있다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// synch = 0

// P1
    // missing wait()
    S1;
    signal(synch);

// P2
    wait(synch);
    S2;
    // missing signal()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또한 여러 프로세스가 동시에 wait()과 signal()을 호출하여 S(세마포어)를 변경하지 못하도록 wait()과 signal()역시 크리티컬 섹션 문제에 해당이 된다.
그리고 무한 루프를 사용하기 떄문에 CPU가 많이 놀게 되는 경우가 발생하기도 한다.&lt;/p&gt;

&lt;h3 id=&quot;busy-waiting-이라도&quot;&gt;busy waiting 이라도…&lt;/h3&gt;

&lt;p&gt;그래서 무한루프로 대기를 하는대신 권한을 획득하기 전까지는 자신을 waiting queue로 보내는 기능을 추가하여 CPU가 놀지 않도록 하게 하면 된다.
그리고 자기 차래가 되면 waiting queue에서 불러와서 권한을 얻고 진행 하면 된다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// back to ready queue in OS
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;wakeup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;monitor모니터&quot;&gt;monitor(모니터)&lt;/h2&gt;

&lt;p&gt;모니터는 OS를 넘은 언어에서 구현이 되어서 지원이 되는 동기화 구조 도구이다.&lt;/p&gt;

&lt;p&gt;대표적으로 java의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Synchronized&lt;/code&gt; 키워드와 &lt;code class=&quot;highlighter-rouge&quot;&gt;Monitor&lt;/code&gt; 객체가 있다.&lt;/p&gt;

&lt;p&gt;기본적으로 모니터안에 존재하면 크리티컬 섹션 문제를 해결하는 공간이 되며 모니터에 접근할 떄는 한 프로세스만 접근 할 수 있기 때문에 상호 배제도 보장이 된다. 또한 모니터를 기다리는 queue를 만들면 progress와 bounded waiting까지 해결 할 수 있게 된다. (크리티컬 섹션 문제를 해결하기 위해서 전에 했던 알고리즘에 장점만 붙였다고 생각하면 된다.)&lt;/p&gt;

&lt;p&gt;대략적으로 이렇게 생각하면 된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;monitor&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;changedValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;changedValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;끝&lt;/p&gt;
</description>
        <pubDate>Thu, 13 Apr 2017 00:00:00 +0000</pubDate>
        <link>http://nGeniuskr.github.io/2017/04/13/jump-to-OS-processSync.html</link>
        <guid isPermaLink="true">http://nGeniuskr.github.io/2017/04/13/jump-to-OS-processSync.html</guid>
        
        
      </item>
    
      <item>
        <title>Jump To OS : Thread</title>
        <description>&lt;p&gt;OS 2탄이 돌아왔습니다! 하하.. 하나의 포스트로 정리하려고 했는데 역시나 OS는 넓고 어렵습니다 ㅠㅠ 이번에는 Thread입니다.&lt;/p&gt;

&lt;p&gt;스레드는 CPU 사용의 기본 단위다. 스레드 ID, 프로그램 카운터, 레지스터 세트 및 스택을 포함한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-02-05-jump-to-OS/thread.png&quot; alt=&quot;thread&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;motivation&quot;&gt;Motivation&lt;/h2&gt;

&lt;p&gt;단일 응용 프로그램이 여러 가지 유사한 task를 수행해야 할 수도 있다. 예를 들어, 웹 서버는 웹 페이지, 이미지, 사운드 등에 대한 클라이언트 요청을 받아들인다. 사용량이 많은 웹 서버에는 여러 클라이언트가 동시에 액세스 할 수 있다. 웹 서버가 기존의 single thread process로 실행되면 한 번에 하나의 클라이언트만 서비스 할 수 있으며 클라이언트는 요청을 처리하는 데 오랜 시간을 기다려야 할 수 있다.
한 가지 해결책은 서버가 요청을 각각의 single process로 실행되도록하는 것이다. 서버가 요청을 수신하면 서버는 해당 요청을 처리 할 별도의 process를 쓴다. 그러나 process 생성은 많은 시간과 자원을 필요로 한다.&lt;/p&gt;

&lt;h2 id=&quot;benefits&quot;&gt;Benefits&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Responsiveness. 쌍방향 응용 프로그램의 다중 스레드는 프로그램은 작업의 일부가 차단되거나 긴 작업을 수행하는 경우에도 프로그램이 계속 실행되도록하여 사용자의 입력에 대한 응답 속도를 높인다. 특히 사용자 인터페이스 설계에 유용하다. 예를 들어 사용자가 시간이 많이 걸리는 작업을 수행하는 버튼을 클릭하면 단일 스레드 응용 프로그램은 작업이 완료 될 때까지 사용자에게 응답하지 않는다. 반대로 시간이 많이 걸리는 작업이 별도의 스레드에서 수행되는 경우 응용 프로그램은 사용자에게 응답한다.&lt;/li&gt;
  &lt;li&gt;Resource sharing. 프로세스는 Shared Memory 및 Message passing과 같은 기술을 통해서만 리소스를 공유 할 수 있다. 이러한 기술은 프로그래머가 명시적으로 구성(하드코딩)해야한다. 그러나 스레드는 메모리와 기본적으로 속한 프로세스의 리소스를 공유한다.&lt;/li&gt;
  &lt;li&gt;Economy. 프로세스 생성을 위해 메모리와 리소스를 할당하는 것은 많은 비용이 든다. 스레드는 스레드가 속한 프로세스의 리소스를 공유하기 때문에 스레드를 만들고 context-switch 하는 것이 더 경제적이다. 오버 헤드의 차이를 경험적으로 측정하는 것은 어려울 수 있지만 일반적으로 스레드보다 프로세스를 만들고 관리하는 데 훨씬 많은 시간이 소요된다. 예를 들어 솔라리스에서 프로세스 생성은 스레드를 만드는 것보다 약 30 배 느리고 context-switch은 약 5 배 느리다.&lt;/li&gt;
  &lt;li&gt;Scalability. 스레드가 다른 프로세싱 코어에서 병렬로 실행될 수 있는 멀티 프로세서 아키텍처에서는 멀티 스레딩의 이점을 훨씬 크게 누릴 수 있습니다. 단일 스레드 프로세스는 사용 가능한 프로세서 수에 관계없이 하나의 프로세서에서만 실행될 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;multicore-programming&quot;&gt;Multicore Programming&lt;/h1&gt;

&lt;p&gt;코어들(2개이상)이 CPU 칩 전체 또는 CPU 칩 안에서 존재하면 멀티 코어 또는 멀티 프로세서 시스템이라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-02-05-jump-to-OS/singlecore.png&quot; alt=&quot;singlecore&quot; /&gt;
&lt;img src=&quot;/images/2017-02-05-jump-to-OS/multicore.png&quot; alt=&quot;multicore&quot; /&gt;&lt;/p&gt;

&lt;p&gt;동시성은 싱글 코어에서 멀티 스레드를 동작시키기 위한 방식으로 멀티 태스킹을 위해 여러 개의 스레드가 번갈아가면서 실행되는 성질을 말한다. 동시성을 이용한 싱글 코어의 멀티 태스킹은 각 스레드들이 병렬적으로 실행되는 것처럼 보이지만 사실은 번갈아가면서 조금씩 실행되고 있는 것이다. 병렬성은 멀티 코어에서 멀티 스레드를 동작시키는 방식으로, 한 개 이상의 스레드를 포함하는 각 코어들이 동시에 실행되는 성질을 말한다. 따라서 병렬 처리없이 동시성을 가질 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;type-of-parallelism&quot;&gt;Type of Parallelism&lt;/h2&gt;

&lt;p&gt;일반적으로 병렬 처리에는 데이터 병렬 처리와 작업 병렬 처리의 두 가지 유형이 있다. 
데이터 병렬 처리는 전체 데이터를 쪼개 서브 데이터들로 만든 뒤, 서브 데이터들을 병렬 처리하여 작업을 빠르게 수행하는 것을 말한다. 자바 8에서 지원하는 병렬 스트림이 데이터 병렬성을 구현한 것이다. 서브 데이터는 멀티 코어의 수만큼 쪼개어 각각의 데이터들을 분리된 스레드에서 병렬 처리한다. 작업 병렬 처리는 서로 다른 작업을 병렬 처리하는 것을 말한다. 대표적인 예는 웹 서버로, 각각의 브라우저에서 요청한 내용을 개별 스레드에서 병렬로 처리한다.
기본적으로 데이터 병렬 처리는 여러 코어에서의 데이터 배포와 여러 코어에서의 작업 분산에 대한 작업 병렬 처리를 포함한다. 대부분의 경우 응용 프로그램은 이 두 가지 전략을 섞어서 사용한다.&lt;/p&gt;

&lt;h1 id=&quot;multithreading-models&quot;&gt;Multithreading Models&lt;/h1&gt;

&lt;p&gt;스레드에 대한 지원은 사용자 수준에서의 user thread 또는 커널에 의해 제공되는 kernel thread을 제공받을 수 있다. 사용자 스레드는 커널 위에서 작동하고 커널 지원없이 관리되며 커널 스레드는 운영 체제에서 직접 지원 및 관리된다.&lt;/p&gt;

&lt;h2 id=&quot;many-to-one-model&quot;&gt;Many-to-One Model&lt;/h2&gt;

&lt;p&gt;다대일 모델은 여러개의 user thread를 하나의 kernel thread로 관리하는 모델이다. thread library를 사용해서 관리하며 효율적인 방법이다. 그러나 하나의 thread가 block을 호출하면 나머지 thread도 block당하며 하나의 kernel thread를 사용하기 때문에 다중 코어 시스템에서의 병렬처리가 불가능하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-02-05-jump-to-OS/many-to-one-model.png&quot; alt=&quot;many-to-one-model&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;one-to-one-model&quot;&gt;One-to-One Model&lt;/h2&gt;

&lt;p&gt;일대일 모델은 하나의 user thread를 하나의 kernel thread로 관리하는 모델이다. 이 모델은 동시성도 우수하고 다중 코어 시스템에서의 병렬처리도 가능하고 block에 독립적이기 때문에 빠르다. 다만 단점은 User thread가 많아짐으로서 kernel thread도 같이 많아지기 과부하가 걸리게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-02-05-jump-to-OS/one-to-one-model.png&quot; alt=&quot;one-to-one-model&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;many-to-many-model&quot;&gt;Many-to-Many Model&lt;/h2&gt;

&lt;p&gt;다대다 모델은 여러개의 user thread를 user thread의 수보가 적게 kernel thread로 관리하는 모델이다. 개발자는 필요한만큼의 사용자 스레드를 만들 수 있으며 해당 커널 스레드는 다중 프로세서에서 병렬로 실행할 수 있다. 또한 스레드가 블로킹 system call을 수행 할 때 커널은 다른 스레드의 실행을 예약 할 수 있다. 위의 모델들의 장단점이 분명하기 때문에 이 두가지 모델의 장점을 섞어서 만들어진 것이 two-level model이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-02-05-jump-to-OS/many-to-many-model.png&quot; alt=&quot;many-to-many-model&quot; /&gt;
&lt;img src=&quot;/images/2017-02-05-jump-to-OS/two-level-model.png&quot; alt=&quot;two-level-model&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 12 Feb 2017 00:00:00 +0000</pubDate>
        <link>http://nGeniuskr.github.io/2017/02/12/jump-to-OS-thread.html</link>
        <guid isPermaLink="true">http://nGeniuskr.github.io/2017/02/12/jump-to-OS-thread.html</guid>
        
        
      </item>
    
      <item>
        <title>Jump To OS : Process</title>
        <description>&lt;p&gt;OS는 중요하고 프로그래머라면 누구든지 알고 있어야 하는 것이다. 라는 말을 프로그래밍하시는 분들이나 전산과 계열에서 대학을 졸업하신 분들이라면 한번쯤은 들어보셨겠죠? 그래서 저도 막상 대학에선 잘 이해 하지 못했던 운영체제에 대한 공부를 결심한 한지 약 2년째 되어가는 차에.. 회사 공부 발표를 운영체제로 정해버렸습니다.. ㅠㅠ 이걸 2주만에 공부할 수 있었던건 정말로 신입적응기간이기 때문인것 같은데… 이번에 정리를 잘 해놔서 가치 있는 글을 남겨보려 합니다.(뭐 또 끝내놓으면 사라질 글일 느낌이 없진 않습니다..)&lt;/p&gt;

&lt;h1 id=&quot;process-concept&quot;&gt;Process Concept&lt;/h1&gt;

&lt;p&gt;프로세스는 단순히 실행되고 있는 코드를 뜻하는 것이 아니다. 프로세스는 많은 것을 가지고 있는데 아래에 나열해본다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-02-05-jump-to-OS/process-in-memory.PNG&quot; alt=&quot;process-in-memory&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Program Counter : 명령어 주소 레지스터라고 불리우며 다음 번에 실행될 명령어의 주소를 가지고 있는 저장소.&lt;/li&gt;
  &lt;li&gt;Stack : 임시적인 데이터(function parameters, return addresses, local variables)를 가지는 저장소이며 메모리 끝부터 0번지 방향으로 자료가 쌓인다.&lt;/li&gt;
  &lt;li&gt;data section : global variables 저장소.&lt;/li&gt;
  &lt;li&gt;heap : process가 실행되는 시간에 동적으로 할당되는 메모리 공간.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Program은 Process가 아니다. Program은 디스크에 저장된 실행코드의 리스트(실행파일)들 같은 &lt;strong&gt;passive entity&lt;/strong&gt;이다. 반면 Process는 다음실행해야할 실행코드와 그 실행코드가 엮인 리소스와 같은 &lt;strong&gt;active entity&lt;/strong&gt;이다. Program이 process가 되기 위해선 실행파일이 메모리로 불러와져야 한다. 같은 프로그램을 여러 사용자가 동시에 사용하거나 한 사용자가 같은 프로그램을 여러개 실행하여 사용하여도 동일한 process를 사용하는 것이 아닌 각각의 실행된 프로그램의 process를 사용하게 되는 것이다. process는 자신이 아닌 다른 process를 실행할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;process-state&quot;&gt;Process State&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://operatingsystems.tistory.com/entry/OS-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%ACProcess-Management&quot;&gt;참고가 된 자료&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-02-05-jump-to-OS/diagram-of-process-state.PNG&quot; alt=&quot;process-in-memory&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;New : Process가 만들어 진다.&lt;/li&gt;
  &lt;li&gt;Running : 명령어가 실행되어지고 있다.&lt;/li&gt;
  &lt;li&gt;Waiting : 어떠한 이벤트(I/O interrupt 등)로 인해서 기다리게 됨.&lt;/li&gt;
  &lt;li&gt;Ready : 프로세서에 할당되길 기다린다.&lt;/li&gt;
  &lt;li&gt;Terminated : 프로세스가 종료 되었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pcb-process-control-block&quot;&gt;PCB (Process Control Block)&lt;/h2&gt;

&lt;p&gt;OS안에서 각각의 process는 Process Contral Block(PCB)로 표현된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-02-05-jump-to-OS/PCB.PNG&quot; alt=&quot;PCB&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Process state : 현재 프로세스의 상태이다( ready, waiting, running 등등)&lt;/li&gt;
  &lt;li&gt;Program counter : 이 프로세스가 다음에 실행시켜야 할 명령어의 주소값.&lt;/li&gt;
  &lt;li&gt;CPU registers : 프로세스의 다양한 상태값(stack pointer, condition code, index register)이나 interrupt로 인한 waiting 상황 발생시 process의 모든 값을 저장하는 장소.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-02-05-jump-to-OS/CPU-switch.PNG&quot; alt=&quot;CPU-switch&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU-Scheduling infomation : cpu가 처리하는 스케쥴링 큐의 포인터나 스케쥴링의 기준이 되는 값을 저장.&lt;/li&gt;
  &lt;li&gt;Memory-management information : OS가 관리하는 Memory system의 page table이나 segment table, base register, limit register 값이 들어있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-02-05-jump-to-OS/base-limit-register.PNG&quot; alt=&quot;base-limit-register&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Accounting infomation : (process가) 사용중인 CPU, 실 사용시간, time limits, account numbers, job or process numbers 등의 정보가 들어있다.&lt;/li&gt;
  &lt;li&gt;I/O status infomation : process에 할당된 I/O devices 리스트, 열고 있는 files 등의 정보가 들어있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;process-scheduling&quot;&gt;Process Scheduling&lt;/h1&gt;

&lt;p&gt;멀티프로그래밍의 목적 중 하나는 CPU가 노는 시간을 줄이는 것이다. 시분할의 목적은 process를 cpu에 자주 할당시켜 각각의 프로그램이 도는동안 상호 호환시키기 위해서다. 이 목적들을 위해 &lt;strong&gt;process Scheduler&lt;/strong&gt;는 사용가능한 process를 선택하여 CPU에 실행시킨다.&lt;/p&gt;

&lt;h2 id=&quot;scheduling-queues&quot;&gt;Scheduling Queues&lt;/h2&gt;

&lt;p&gt;process가 시스탬에 속하면 process는 &lt;strong&gt;Job Queue&lt;/strong&gt;에 올라간다. process가 memory에 로딩이 되는 순간부터 ready나 Waiting상태일 경우 &lt;strong&gt;Ready Queue&lt;/strong&gt;에 올라간다. &lt;strong&gt;Ready Queue&lt;/strong&gt;는 보통 linked list로 저장이 되며 첫부분과 끝부분의 포인터를 가지는 구조이고, 각각의 PCB블럭은 각자 자신의 다음 실행해야할 PCB를 가리킨다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Job Queue&lt;/strong&gt;에는 다른 queue들이 존재한다. process가 CPU에 할당이 될 떄, process가 실행 중 갑작스럽게 종료 되거나, interrupt 당하거나, I/O Event를 기다리기 되기도 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-02-05-jump-to-OS/Job-Queue.PNG&quot; alt=&quot;Job-Queue&quot; /&gt;&lt;/p&gt;

&lt;p&gt;새로운 process는 ready queue에 들어간다. 그러고 실행될 때(dispatched) 까지 기다린다. process가 CPU에 처리되는 동안 몇가지 이밴트가 발생할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I/O Queue에 있던 I/O request가 발생한다.&lt;/li&gt;
  &lt;li&gt;새로운 자식 process가 발생하고 자식 process가 끝나기를 기다려야한다.&lt;/li&gt;
  &lt;li&gt;process는 interrupt로 인해 강제적으로 CPU에서 제거 될 수 있다.&lt;/li&gt;
  &lt;li&gt;모든 이벤트가 발생하면 CPU에 있던 process는 Ready Queue로 돌아간다.&lt;/li&gt;
  &lt;li&gt;process는 Terminated 될 떄까지 위의 과정을 반복한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;schedulers&quot;&gt;Schedulers&lt;/h2&gt;

&lt;p&gt;OS에서는 스케쥴링을 위해 어떤 방식으로 이루어진 몇몇 큐에 있는 프로세스를 선택해야 하는데 이 일을 수행하는 것은 Scheduler라고 한다.
배치 시스탬은 종종 process가 급작스럽게 많아지게 되면 disk에 process를 저장한다. long-term Scheduler(job Scheduler)는 저런 process들을 실행시키기 위해 memory로 불러오는 역활을 하며, short-term Scheduler(CPU Scheduler)는 실행이 준비가 된 process들 중 하나를 CPU에 할당한다. 두 scheduler의 가장 큰 차이점은 실행 빈도이다.&lt;/p&gt;

&lt;p&gt;short-term Scheduler는 CPU에 할당 시킬 process를 선택한다. 그래서 short-term Scheduler는 빠르게 작동해야한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cfile7.uf.tistory.com/image/123A763350E18EBC2FCF47&quot; alt=&quot;long-term Scheduler&quot; /&gt;
출처 : &lt;a href=&quot;http://operatingsystems.tistory.com/entry/OS-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC-scheduler&quot;&gt;빛나유님 블로그&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;반면에 long-term Scheduler는 disk에 있는 code를 memory로 이전시키는 역활을 하기 떄문에 short-term Scheduler와는 상대적으로 빈도수가 적게 일을 한다. (&lt;a href=&quot;http://operatingsystems.tistory.com/entry/OS-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC-scheduler&quot;&gt;참고자료&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cfile9.uf.tistory.com/image/2552DD3650E18ECE0AABEC&quot; alt=&quot;short-term Scheduler&quot; /&gt;
출처 : &lt;a href=&quot;http://operatingsystems.tistory.com/entry/OS-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC-scheduler&quot;&gt;빛나유님 블로그&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;대부분의 process들은 I/O bound 이냐 CPU bound 이냐로 나뉜다. I/O bound process의 경우는 처리되는 시간을 I/O처리에 두고, CPU bound process의 경우는 처리되는 시간을 CPU 연산에 둔다. long-term Scheduler는 이 두가지의 process들을 잘 결합해서 스케쥴링을 해야한다.&lt;/p&gt;

&lt;p&gt;어떠한 시스탬은 long-term Scheduler를 빼거나 축소 시킨다. 시분할이 적용된 OS들(UNIX, WINDOWS 등)에서는 중간 단계의 스케줄링인 medium-term scheduler를 사용한다. medium-term scheduler의 핵심은 오랫동안 사용되지 않는 process를 메모리에서 뺴서 다른 저장공간(ex. disk, usb 등)에 두고 필요 할 떄 다시 메모리로 불러오는 방식이며 이 구동을 swapping이라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-02-05-jump-to-OS/medium-term-scheduling.PNG&quot; alt=&quot;medium-term-scheduling&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;context-switch&quot;&gt;context switch&lt;/h2&gt;

&lt;p&gt;interrupt는 CPU의 처리를 기존 작업에서 kernel routine으로 바꾼다. interrupt가 일어나 기존 작업에 대한 정보(the current &lt;strong&gt;context&lt;/strong&gt; of the process running on the CPU)를 저장한다. 그래야만 중단된 지점부터 다시 실행할 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;CPU가 다른 process로 전환시 현재 process의 상태 정보(PCB)을 저장하고 작업해야할 process의 상태 정보를 불러오는 과정을 &lt;strong&gt;context switch&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;h1 id=&quot;operations-on-process&quot;&gt;Operations on Process&lt;/h1&gt;

&lt;p&gt;대부분의 시스템의 process들은 동시에 실행되며, 동적으로 실행되거나 죽는다.&lt;/p&gt;

&lt;h2 id=&quot;process-creation&quot;&gt;Process Creation&lt;/h2&gt;

&lt;p&gt;process는 다른 process에 의해 생성된다.(그리고 그 프로세스를 child process라고 한다.) 그런 행위들이 반복해서 일어나면 계층이 생기고 그 모양을 도식화 시키면 Tree가 된다.각각의 Process는 PID(프로세스 식별자)가 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-02-05-jump-to-OS/tree-of-processes.PNG&quot; alt=&quot;tree-of-processes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;init process는 root 프로세스이며 모든 프로세스의 부모가 된다. init process을 통해 다른 프로세스를 만들어내며 사용자의 메인프로세스나 web server, print server, ssh로 접속한 사용자까지 생성해 낸다. linux에서 process 목록을 보고 싶다면 다음 명령어를 사용하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ps -el
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;보통 child process가 만들어 질 때, 일정한 리소스 (CPU time, memory, files, I/O devices)가 필요하다. 이 리소스는 OS가 주거나 부모 process의 subset 자원으로서 할당 되어(공유하며) 사용할 수도 있다. 새로운 process가 생성되면,&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;부모와 자식 process가 동시에 실행된다.&lt;/li&gt;
  &lt;li&gt;부모는 자식이 끝날 떄까지 기다린다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;또한 두가지의 주소 공간을 가질 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;부모를 복사한다.&lt;/li&gt;
  &lt;li&gt;새로운 프로그램으로 로드 된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이러한 차이를 알기 위해서는 UNIX OS을 조금 알아야한다. UNIX에서는 fork()라는 system call을 이용하여 새로운 process를 만든다. fork()를 이용하면 기존의 PID를 반납하는 부모 process와 PID = 0을 반환하는 자식 process를 생성하여 각자가 할 일을 하며 다음과 같이 사용하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
	pid_t pid;    // 프로세스 번호 (Process ID; PID)가 저장될 변수 pid
	
	pid = fork(); // 자식 프로세스를 생성한다. 
  						  // 성공시 0, 실패시 -1, 부모 프로세스이면 양수 (프로세스 ID)를 반환한다.
	if (pid &amp;lt; 0) {
		// pid 가 음수이면 에러가 난 것이다.
		fprintf(stderr, &quot;fork failed!&quot;);
		return -1;
	} else if (pid == 0) {
		// pid 가 0 이면 자식 프로세스이다.
		// 자식 프로세스가 해야 할 일
		printf(&quot;자식 프로세스 (#%i)&quot;, getpid());

	} else {
		// pid 가 양수이면 부모 프로세스이다.
		// 부모 프로세스가 해야 할 일
      	printf(&quot;부모 프로세스 (#%i)&quot;, getpid());
		wait(NULL);  // 자식 프로세스들이 모두 종료될 때 까지 기다린다.
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;fork() 후에 보통은 두 process중 하나는 exec()라는 system call을 사용하여 새로운 프로그램을 해당 process에 로딩한다(exec()를 실행한 process의 메모리는 파괴된다.).(&lt;a href=&quot;https://kldp.org/node/141415&quot;&gt;이렇게 생성하는 이유! : 댓글에 shell 프로그램을 예시로 설명함.&lt;/a&gt;)
exec() system call은 바이너리 파일을 메모리로 로딩하고 실행한다. 위의 방법을 사용하면 서로의 process는 통신이 가능하며 다른 일이 가능해진다. 부모 프로세스는 다른 자식 프로세스를 만들거나 wait() system을 이용하여 ready queue로 돌아간 후 자식 프로세스가 끝나기를 기다린다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-02-05-jump-to-OS/using-fork.PNG&quot; alt=&quot;using-fork&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;process-termination&quot;&gt;Process Termination&lt;/h2&gt;

&lt;p&gt;process가 종료되는 시점은 process의 마지막 명령을 실행했거나 exit() system call을 사용하는 경우 발생한다. process 가 종료되면 종료 상태 값(보통 int)을 반환하며 OS에서는 모든 리소스를 반환시킨다.&lt;/p&gt;

&lt;p&gt;부모 process가 자식 process를 죽이는 경우가 발생하는데 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자식이 허용치 이상의 리소스를 사용하는 경우(죽여야 하는 상황을 감지하기 위해, 부모 process에 자식 리소스를 감시하는 기능을 가져야 한다.)&lt;/li&gt;
  &lt;li&gt;자식 process가 더 이상 필요 없는경우&lt;/li&gt;
  &lt;li&gt;부모 process가 종료 되는 경우.(OS가 자동으로 종료 시킨다. 이런 현상을 cascading termination 이라고 한다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;자식 process가 종료되면 커널에 리턴값을 넘기고 커널은 부모에게 그 값을 전달한다. 그러나 그 값을 넘기기 전에 부모 프로세스가 불의의 사고(다른 process가 죽임 등등)로 종료된다면 커널은 해당 자식 프로세스를 좀비 프로세스로 만든다.(wait()을 써야하는 이유, UNIX에서는 사실 좀비가 되면 부모가 없어지는게 아니고 init process가 임시로 부모 역활을 하게 된다.)&lt;/p&gt;

&lt;h1 id=&quot;interprocess-communication-참고자료&quot;&gt;interprocess Communication [&lt;a href=&quot;http://talkingaboutme.tistory.com/551&quot;&gt;참고자료&lt;/a&gt;]&lt;/h1&gt;

&lt;p&gt;process들은 독립적으로 혹은 서로 의존하며 동시에 실행되고 있다. &lt;strong&gt;process는 독립적이다.&lt;/strong&gt; 
어떠한 process도 다른 process의 data를 공유할 수 없다. 만약 process가 서로간의 간섭이 가능하다면 process는 협동이 가능하다. 어떠한 다른 process와 data를 공유하는 process라면 이미 cooperating process 이다.
 프로세스 협력 할 수 있는 환경을 제공하기 위한 몇 가지 이유가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Information sharing. 여러명의 사용자가 같은 곳의 정보를 사용하려 하는 경우, 동시에 접근이 가능하도록 해줘야 한다.&lt;/li&gt;
  &lt;li&gt;Computation speedup. 어떠한 task를 빠르게 하기위해서는 task를 쪼개서 병렬로 처리하게 된다.&lt;/li&gt;
  &lt;li&gt;Modularity. 모듈러 유행을 따르고 싶어하는 경우이다. process나 threads로 나누어 처리하려한다.&lt;/li&gt;
  &lt;li&gt;Convenience. 개인 유저일 경우라도 한번에 많은 task를 처리하고 싶어한다. 예를들면 워드를 작성하고 음악을 들으면서 컴파일하는 경우이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;cooperating process는 data와 information을 교환을 허락하는 메카니즘인 interprocess communication(IPC)이 필요하다. IPC에는 2가지의 기본 모델이 있다.(shared memory, message passing).
 shared memory 모델에서는, cooperating process가 shared memory를 만든다. 그리고 공유되고 있는 메모리에서 data를 읽고 쓰며 정보를 교환한다.
 message passing 모델에서는 통신이 cooperating process들간의 메시지 교환을 통해 진행된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-02-05-jump-to-OS/sharedmemory-messagepassing.PNG&quot; alt=&quot;sharedmemory-messagepassing&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;shared-memory-systems&quot;&gt;Shared-Memory Systems&lt;/h2&gt;

&lt;p&gt;일반적으로, Shared-Memory는 주소공간 안의 process가 생성해놓은 Shared-Memory 위치한다.&lt;/p&gt;

&lt;h3 id=&quot;producer-consumer-problem&quot;&gt;producer-consumer problem&lt;/h3&gt;

&lt;p&gt;producer process는 정보를 생산하고 consumer process는 정보를 소비한다. 예를 들면, 컴파일러는 어셈블러에게 정보를 소비시켜 어셈블리코드를 생산한다. 그럼 어셈블러는 로더에게 어셈블리코드를 소비시켜 오브젝트 모듈을 만든다. 이 문제는 client-server 페러다임에 비유할 수 있다. 웹 서버가 html 파일을 만들어 client에게 전달하면 client는 브라우저를 통해 html을 소비하여 화면을 구성한다.&lt;/p&gt;

&lt;p&gt;producer-consumer problem의 하나의 해결책은 shared-memory를 사용하는 것이다. producer와 consumer를 동시에 돌리기 위해서는 공용으로 사용하는 buffer가 필요하다.
 2가지 종류의 buffer를 사용한다. unbounded buffer로 크기제한이 없는 buffer 이다. consumer는 새로운 아이탬을 기다리겠지만 producer는 항상 새로운 아이탬을 만들어 낼 수 있다. bounded buffer는 크기의 제한을 두는 buffer이다. 이 경우에는 buffer가 비어있다면 consumer가 기다리게 되고, buffer가 가득차면 producer가 기다리게 된다.&lt;/p&gt;

&lt;h2 id=&quot;message-passing-systems&quot;&gt;Message-Passing Systems&lt;/h2&gt;

&lt;p&gt;message-passing은 shared-memory없이도 process들의 동작을 동기화 시킬 수 있고, process간에 통신이 가능하도록 하는 메커니즘을 제공한다. 이 환경은 특히 네트워트 안에 다른 컴퓨터의 process와 통신하는 분산 환경에서 유용하다. 
message-passing 기능은 최소 2가지의 기능을 지원한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;send(message)                 receive(message)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;message의 크기는 고정되거나 가변적으로 보낸다. 만약 message가 고정적이라면, 시스탬 래밸에서의 구현을 간단하게 한다. 하지만 이 재한은 프로그래밍적 작업을 어렵게 한다. 반대로 가변적인 message는 좀더 복잡한 시스탬 래밸의 구현이 필요하나, 프로그래밍 작업이 간단해진다. 
process P와 Q가 있다고 가정하고 그들끼리 통신을 하려면 message를 주고 받을려면 &lt;strong&gt;communication link&lt;/strong&gt; 그들 사이에 있어야 한다. &lt;strong&gt;communication link&lt;/strong&gt;은 다양한 방법으로 구현할 수 있다. 물리적인 구현을 생각할 필요는 없지만, 논리적인 구현을 해야한다. 논리적 구현을 하는데는 몇가지 방법이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;직접 혹은 간접 통신&lt;/li&gt;
  &lt;li&gt;동기 혹은 비동기 통신&lt;/li&gt;
  &lt;li&gt;자동 혹은 명시적 버퍼링&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;naming&quot;&gt;Naming&lt;/h4&gt;

&lt;p&gt;직접 통신하에 통신하려는 각 process는 통신의 수신자 또는 송신자를 명시 적으로 명명해야합니다. 이 경우에 send() receive() 정의를 다음과 같이 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;symmetry&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;send(P, message) - process P에 message를 보낸다.&lt;/li&gt;
  &lt;li&gt;receive(Q, message) — process Q로 부터 온 message를 받는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그리고 이 방식의 communication link는 다음과 같은 속성을 따른다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;링크는 모든 통신을 원하는 짝이 있는 process끼리 자동으로 열린다. 프로세스들은 자신이 통신하고 싶은 process의 신원값(누구인지 확인하는 값)을 알아야한다.&lt;/li&gt;
  &lt;li&gt;링크는 정확히 2개의 프로세스에 속한다.&lt;/li&gt;
  &lt;li&gt;각각 짝이 된 process들에는 하나의 링크만 존재한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;asymmetry&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;send(P, message) — process P에 message를 보낸다.&lt;/li&gt;
  &lt;li&gt;receive(id, message) — 어떤 process에서 message를 받는다. id 변수는 통신을 열기 위한 process의 이름을 설정한 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 두방법의 단점은 process정의 결과의 모듈성을 제한한다. 하나의 process의 id를 바꾸면 통신하던 다른 process 역시 id값을 바꿔줘야 한다.&lt;/p&gt;

&lt;p&gt;간접 통신에선 message를 mailboxes 혹은 ports라는 곳에서 주고 받는다. mailbox는 추상적으로 개체를 프로세스별로 메시지를 배치하고 메시지를 제거 할 수있는 개체로 볼 수 있습니다. 각 mailbox에는 고유 한 ID가 있습니다. process끼리 통신하기 위해서는 그들끼리 하나의 mailbox를 공유해야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;send(A, message) — mailbox A에 message를 보낸다.&lt;/li&gt;
  &lt;li&gt;receive(A, message) — mailbox A에서 message를 받는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그리고 이 방식의 communication link는 다음과 같은 속성을 따른다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;각 맴버 모두 공유 사서함이있는 경우에만 한 쌍의 process간에 링크가 설정됩니다.&lt;/li&gt;
  &lt;li&gt;링크는 두 개 이상의 process와 연관 될 수 있습니다.&lt;/li&gt;
  &lt;li&gt;통신 process의 각 쌍 사이에는 여러 링크가 존재할 수 있으며 각 링크는 하나의 mailbox에 해당합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;또한 mailbox에서 수신자를 정하는 규칙과 조건은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;링크가 최대 두 개의 process와 연결되도록 허용합니다.&lt;/li&gt;
  &lt;li&gt;한 번에 하나의 process 만 receive() 작업을 수행 할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;시스템이 메시지를 수신 할 process를 임의로 선택하도록합니다 (두 process가 동시에 접근하더라고 한 process만 수신 가능). 혹은 시스템은 메시지를 수신 할 process를 선택하는 알고리즘을 정의 할 수 있습니다 (예 : 라운드 로빈, 프로세스가 차례로 메시지를 수신하는 경우). 혹은 시스템은 송신자에 대한 수신기를 식별 할 수있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;mailbox는 process나 OS의 소유가 된다. process가 mailbox의 소유인 경우 mailbox의 소유자(message를 받는사람)와 사용자(message를 주는사람)로 나뉜다. process가 mailbox의 소유을 끝내는경우 mailbox는 없어지고 mailbox가 없어진 것을 다른 process에게 알려야 한다.&lt;/p&gt;

&lt;p&gt;반대로, OS는 자기 소유의 mailbox를 가지게 된다. 그 mailbox는 어떠한 process도 접근할 수 없고 독립적이다. OS다음과 같은 process가 다음의 기능을 가능하게 하도록 제공해야한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;새로운 mailbox를 만들기&lt;/li&gt;
  &lt;li&gt;mailbox를 통해 message를 보내고 받기&lt;/li&gt;
  &lt;li&gt;mailbox를 지우기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;새로운 mailbox를 만든 process는 기본값으로 mailbox에 주인이 된다. 기본적으로 mailbox를 통해서 message를 주고 받지만 system call을 이용하여 사용해야 한다.&lt;/p&gt;

&lt;h4 id=&quot;synchronization&quot;&gt;Synchronization&lt;/h4&gt;

&lt;p&gt;message passing은 blocking 혹은 nonblocking( synchronous 와 asynchronous 로 알려진)이 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Blocking send.        수신 process 또는 mailbox에서 message를 수신 할 때까지 송신 process가 차단된다.&lt;/li&gt;
  &lt;li&gt;Nonblocking send.     발신 process가 message를 보내고 작업을 다시 시작한다.&lt;/li&gt;
  &lt;li&gt;Blocking receive.     수신자를 message를 사용할 수 있을 때 까지 차단한다.&lt;/li&gt;
  &lt;li&gt;Nonblocking receive.  수신자는 유효한 message 또는 널 (null)을 가져온다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;send()와 receive()가 모두 블럭일 때, 우리는 둘 사이에 랑데뷰(집결지)를 같는다. 이것이 생산자와 소비자 문제의 해결책이 된다. 생산자는 수신자 혹은 mailbox에 message가 전달 될 때 까지 send() 블락하고 기다립니다. 마찬가지로 소비자도 message를 받을 수 있기 전까지는 receive()를 블락합니다.&lt;/p&gt;

&lt;h4 id=&quot;buffering&quot;&gt;Buffering&lt;/h4&gt;

&lt;p&gt;통신이 직접이든 간접이든, message는 임시의 queue에서 통신 process들이 교환한다. 기본적으로 queue라면 3종류로 구현할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Zero capacity. queue의 최대 길이는 0. 따라서 링크에는 대기중인 메시지가 없고, 이 경우 보낸 사람은받는 사람이 메시지를 받을 때까지 차단해야합니다.&lt;/li&gt;
  &lt;li&gt;Bounded capacity. queue의 길이는 n. 따라서 최대 n 개의 메시지가 메시지에 상주 할 수 있다 새 메시지를 보낼 때 queue가 가득 차 있지 않으면 메시지는 queue에 저장된다. (메시지가 복사되거나 메시지 포인터가 유지됨). 송신자는 대기하지 않고 계속 실행할 수 있습니다. 링크가 가득 차면 발신자는 queue에서 사용 가능한 공간이 확보 될 때까지 차단 해야합니다.&lt;/li&gt;
  &lt;li&gt;Unbounded capacity. queue의 길이는 잠재적으로 무한. 따라서 어떤 수의 메시지도 기다릴 수 있고, 발신자는 차단하지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;example-of-ipc-systems&quot;&gt;example of IPC Systems&lt;/h2&gt;

&lt;h3 id=&quot;posix-shared-memory&quot;&gt;POSIX Shared Memory&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt; 
#include &amp;lt;stlib.h&amp;gt; 
#include &amp;lt;string.h&amp;gt; 
#include &amp;lt;fcntl.h&amp;gt; 
#include &amp;lt;sys/shm.h&amp;gt; 
#include &amp;lt;sys/stat.h&amp;gt;

int main()
{
/* the size (in bytes) of shared memory object */
const int SIZE 4096;
/* name of the shared memory object */
const char *name = &quot;OS&quot;;
/* strings written to shared memory */ 
const char *message 0 = &quot;Hello&quot;;
const char *message 1 = &quot;World!&quot;;

/* shared memory file descriptor */ 
int shm_fd;
/* pointer to shared memory obect */ 
void *ptr;

    /* create the shared memory object */
    shm_fd = shm_open(name, O CREAT | O RDRW, 0666);

    /* configure the size of the shared memory object */ 
    ftruncate(shm_fd, SIZE);

    /* memory map the shared memory object */
    ptr = mmap(0, SIZE, PROT WRITE, MAP SHARED, shm_fd, 0);

    /* write to the shared memory object */ 
    sprintf(ptr,&quot;%s&quot;,message 0);
    ptr += strlen(message 0); 
    sprintf(ptr,&quot;%s&quot;,message 1);
    ptr += strlen(message 1); 
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt; 
#include &amp;lt;stlib.h&amp;gt; 
#include &amp;lt;fcntl.h&amp;gt; 
#include &amp;lt;sys/shm.h&amp;gt; 
#include &amp;lt;sys/stat.h&amp;gt;

int main()
{
/* the size (in bytes) of shared memory object */
const int SIZE 4096;
/* name of the shared memory object */
const char *name = &quot;OS&quot;;
/* shared memory file descriptor */ 
int shm_fd;
/* pointer to shared memory obect */ 
void *ptr;

    /* open the shared memory object */
    shm_fd = shm_open(name, O RDONLY, 0666);
    /* memory map the shared memory object */
    ptr = mmap(0, SIZE, PROT READ, MAP SHARED, shm fd, 0);
    /* read from the shared memory object */
    printf(&quot;%s&quot;,(char *)ptr);
    /* remove the shared memory object */ 
    shm_unlink(name);
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;mach-message-passing&quot;&gt;Mach message passing&lt;/h3&gt;

&lt;p&gt;Mach에서는 System Call 조차도 message에 의해 이루어진다. 작업이 만들어지면 두 개의 특수 mailbox 인 Kernel mailbox과 Notify mailbox이 만들어진다. 커널은 Kernel mailbox를 사용하여 작업과 통신하고 이벤트 발생 알림을 Notify port로 보낸다. message 전송에는 시스템 호출이 세 번이면 된다. &lt;code class=&quot;highlighter-rouge&quot;&gt;msg_send()&lt;/code&gt; 호출은 mailbox로 message를 보낸다. message는 &lt;code class=&quot;highlighter-rouge&quot;&gt;msg_receive()&lt;/code&gt;를 통해 수신된다. Remote procedure calls (RPC)은 &lt;code class=&quot;highlighter-rouge&quot;&gt;msg_rpc()&lt;/code&gt;를 통해 실행된다. &lt;code class=&quot;highlighter-rouge&quot;&gt;msg_rpc()&lt;/code&gt;는 message를 보내고 발신자로부터 정확히 하나의 반환 message를 기다린다. 이런 식으로 RPC는 일반적인 서브 루틴 프로시저 호출을 모델링하지만 시스템간에 작동 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;windows-message-passing&quot;&gt;Windows message passing&lt;/h3&gt;

&lt;p&gt;Windows의 message-passing 기술은 advanced local procedure call (ALPC)라고 불리운다. 같은 컴퓨터 안에 process끼리 통신할 떄 쓰이며, 넓게 쓴다면 RPC와 유사하게 보이지만 windows에 특화 시켰다. 윈도우는 2개의 mailbox를 사용한다: connection ports, communication ports.&lt;/p&gt;

&lt;p&gt;Server process는 모든 process가 볼 수있는 Connection port 개체를 게시한다. 클라이언트가 서브 시스템의 서비스를 원하면 서버의 Connection port 객체에 대한 재어권을 열고 해당 포트에 연결 요청을 전송한다. 그런 다음 서버는 채널을 생성하고 클라이언트에 재어권을 반환한다. 채널은 개인 통신 포트 쌍(Client-Server message 용, Server-Client message 용)으로 구성된다. 또한 통신 채널은 클라이언트와 서버가 일반적으로 응답을 기대할 때 요청을 수락 할 수 있도록하는 콜백 메커니즘을 지원한다.&lt;/p&gt;

&lt;h1 id=&quot;communication-in-client-server-systems&quot;&gt;Communication in Client-Server Systems&lt;/h1&gt;

&lt;h2 id=&quot;sockets&quot;&gt;Sockets&lt;/h2&gt;

&lt;p&gt;소켓은 통신의 끝지점이다. 네트워크를 통해 통신하는 한 쌍의 process는 한 쌍의 소켓 (각 process마다 하나씩)을 사용한다. 소켓은 IP주소와 포트번호로 식별한다. 보통 소켓은 Server-Client 아키텍쳐에 사용된다. 서버는 지정된 포트를 수신하여 들어오는 클라이언트 요청을 대기한다. 요청이 수신되면 서버는 클라이언트 소켓에서 연결을 수락하여 연결을 완료한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.tutorialspoint.com/perl/images/perl_socket.jpg&quot; alt=&quot;socket&quot; /&gt;&lt;/p&gt;

&lt;p&gt;소켓 연결의 대표적인 방식이 2가지 있다: Connection-oriented (TCP) sockets, Connectionless (UDP) sockets.&lt;/p&gt;

&lt;h2 id=&quot;remote-procedure-callsrpc&quot;&gt;Remote Procedure Calls(RPC)&lt;/h2&gt;

&lt;p&gt;RPC는 네트워크 연결이있는 시스템간에 사용하기 위해 프로시저 호출 메커니즘을 추상화하는 방법으로 설계되었다. 많은면에서 IPC 메커니즘과 유사하다.&lt;/p&gt;

&lt;p&gt;RPC의 의미는 클라이언트가 프로시저를 로컬에서 호출 할 때와 같이 원격 호스트에서 프로시저를 호출 할 수 있게 한다. RPC 시스템은 클라이언트 측에서 스텁을 제공함으로써 통신이 일어나는 세부 사항을 숨긴다. 일반적으로 각 별도의 원격 프로시저마다 별도의 스텁이 있다. 클라이언트가 원격 프로시저를 호출하면 RPC 시스템은 해당 스텁을 호출하여 원격 프로시저에 제공된 매개 변수를 전달한다. 이 스텁은 서버의 포트를 찾고 매개 변수를 정렬한다. 마샬링은 매개 변수를 네트워크를 통해 전송 될 수있는 형식으로 패키징하는 것을 포함한다. 그런 다음 스텁은 메시지 전달을 사용하여 서버에 메시지를 전송한다. 서버 측의 비슷한 스텁이이 메시지를 수신하고 서버에서 프로시저를 호출한다. 필요한 경우 반환 값은 동일한 기술을 사용하여 클라이언트에 다시 전달된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cfile2.uf.tistory.com/image/195AAD154AC051FD7D2AEF&quot; alt=&quot;RPC&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;pipes&quot;&gt;Pipes&lt;/h2&gt;

&lt;p&gt;파이프는 두 process가 통신 할 수 있도록하는 직점 연결해주는 역할을 한다. 파이프는 초기 UNIX 시스템에서 최초의 IPC 메커니즘 중 하나였다. 이들은 일반적으로 process가 서로 통신 할 수있는 간단한 방법 중 하나를 제공하지만 몇 가지 제한이 있습니다. 파이프를 구현할 때는 다음 네 가지 문제를 고려해야 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;파이프가 양방향 통신을 허용합니까? 아니면 통신이 단방향입니까?&lt;/li&gt;
  &lt;li&gt;양방향 통신이 허용되는 경우 반이중 (데이터는 한 번에 한 방향으로 만 전송할 수 있음) 또는 전이중 (데이터가 동시에 양방향으로 이동할 수 있음)입니까?&lt;/li&gt;
  &lt;li&gt;의사소통 과정간에 관계 (예 : parent-child)가 있어야합니까?&lt;/li&gt;
  &lt;li&gt;파이프가 네트워크를 통해 통신 할 수 있습니까? 아니면 통신 프로세스가 동일한 시스템에 있어야합니까?&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;ordinary-pipes&quot;&gt;Ordinary Pipes&lt;/h3&gt;

&lt;p&gt;보통 파이프는 두 process가 표준 생산자-소비자 방식으로 통신 할 수 있게한다. 생산자는 파이프의 한쪽 끝(쓰기 끝)에 쓰고 소비자는 반대쪽 끝(읽기 끝)에서 읽는다. 결과적으로 ordinary pipe는 단방향이므로 단방향 통신 만 허용된다. 양방향 통신이 필요한 경우 두 파이프를 사용해야하며 각 파이프는 다른 방향으로 데이터를 보낸다. ordinary pipe는 UNIX 시스템과 Windows 시스템 모두에서 통신 process간에 parent-child 관계가 필요하다. 즉, 이 파이프는 동일한 시스템의 process 간 통신에만 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cfile25.uf.tistory.com/image/2247644B51E4295B1A4045&quot; alt=&quot;Ordinary Pipes&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;named-pipes&quot;&gt;Named Pipes&lt;/h3&gt;

&lt;p&gt;named pipe는 훨씬 강력한 통신 도구다. 통신은 양방향 일 수 있으며 parent-child 관계는 필요하지 않다. named pipe가 설정되면 여러 process가 통신을 위해 이 process를 사용할 수 있다. 통신 process가 완료된 후에도 named pipe가 계속 존재한다. UNIX 및 Windows 시스템은 모두 named pipe를 지원하지만 구현 세부 사항은 크게 다르다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://wyday.com/blog/images/2010/multi-process-c-sharp-app/mario-pipes-wyupdate.jpg&quot; alt=&quot;Named Pipes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;참고자료&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.tutorialspoint.com/operating_system/&quot;&gt;tutorialspoint - OS&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://operatingsystems.tistory.com/category/Operating%20Systems&quot;&gt;빛나유님 블로그&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://talkingaboutme.tistory.com/551&quot;&gt;IPC 참고자료&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://vascocenter.tistory.com/entry/%EB%B6%84%EC%82%B0%EA%B0%9C%EC%B2%B4-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%97%90%EC%84%9C%EC%9D%98-%EC%8A%A4%ED%85%81stub-%EC%8A%A4%EC%BC%88%EB%A0%88%ED%86%A4Skeleton&quot;&gt;Stub 참고자료&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 05 Feb 2017 00:00:00 +0000</pubDate>
        <link>http://nGeniuskr.github.io/2017/02/05/jump-to-OS-process.html</link>
        <guid isPermaLink="true">http://nGeniuskr.github.io/2017/02/05/jump-to-OS-process.html</guid>
        
        
      </item>
    
      <item>
        <title>Preview Gulp.js</title>
        <description>&lt;p&gt;회사 입사 후 3밀만에 발표를 마치고 다음 주제를 결정하려는데 제가 gulp를 하기로 했습니다. 관심 있던 주제이기도 하고 알아두면 참 편리 할 것 같았습니다.&lt;/p&gt;

&lt;h1 id=&quot;make-tool&quot;&gt;Make tool&lt;/h1&gt;

&lt;p&gt;갑작스럽고 뜬금 없지만 옛날 이야기 : 과거 리눅스에서 개발하는 c 개발자들은 혼란하고 복잡하게 나뉘어진 c파일을 일일이 컴파일해서 합치는 과정에 신물이나서 make라는 훌륭한 도구를 만들어 낸다. make라는 툴은 컴파일을 과정을 서술한 ‘Makefile’의 내용대로 컴파일을 자동으로 하는 아주아주 훌륭한 툴이다. 말로만보면 모르겠으니 Makefile의 내용을 봅시다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://bowbowbow.tistory.com/12&quot;&gt;&lt;img src=&quot;http://cfile4.uf.tistory.com/image/242A274956E5920F2BC750&quot; alt=&quot;Makefile 문법&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://bowbowbow.tistory.com/12&quot;&gt;&lt;img src=&quot;http://cfile27.uf.tistory.com/image/2714AC4A56E592A6080DB5&quot; alt=&quot;Makefile 예제&quot; /&gt;&lt;/a&gt;
출처: http://bowbowbow.tistory.com/12 [멍멍멍]&lt;/p&gt;

&lt;h3 id=&quot;작성-규칙&quot;&gt;작성 규칙&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;매크로를 참조 할 때는 소괄호나 중괄호 둘러싸고 앞에 ‘$’를 붙인다.&lt;/li&gt;
  &lt;li&gt;탭으로 시작해서는 안되고 , :,=,#,”” 등은 매크로 이름에 사용할 수 없다.&lt;/li&gt;
  &lt;li&gt;매크로는 반드시 치환될 위치보다 먼저 정의 되어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;원래 diary.exe라는 파일을 만들기 위해서는 위의 3가지 object file(memo.0, calendar.o, main.o)가 필요하고 그 파일들을 만들어 주기 위해 각각을 컴파일을 해야한다. 하지만 저 명세와 함깨 마법의 명령어 &lt;code class=&quot;highlighter-rouge&quot;&gt;make all&lt;/code&gt;을 입력하면 된다.&lt;/p&gt;

&lt;h1 id=&quot;혼란스러운-javascript-프로젝트&quot;&gt;혼란스러운 javascript 프로젝트&lt;/h1&gt;

&lt;p&gt;최근 웹 개발은 각각의 모듈화로 인해 파일의 겟수가 많아지고 디렉토리 경로 역시 복잡해지고 있다. 특히 프론트엔드의 경우에는 프론트엔드에서 진행되어야 할 부분까지 커버해야 하기도 할 때가 생겼기 때문이다. 이에 할 일(concatenating, minifying, validating)이 많아진 프론트엔드 프로젝트의 &lt;strong&gt;자동화를 편리하게 관리&lt;/strong&gt;하기 위해 빌드 시스템들이 등장 하기 시작했다.&lt;/p&gt;

&lt;h1 id=&quot;build-system&quot;&gt;Build system&lt;/h1&gt;

&lt;p&gt;빌드 시스템을 한마디로 정리하면 연관된 작업모음의 자동화(보통 task runner라 한다)이다.&lt;a href=&quot;http://joellongie.com/gulp-build-system-fundamentals/&quot;&gt;(출처)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i1.wp.com/joellongie.com/wp-content/uploads/2015/02/web-workflow-componets.jpg&quot; alt=&quot;Building system&quot; /&gt;&lt;/p&gt;

&lt;p&gt;웹 개발자를 예로 든다면 프로젝트 파일 중 하나를 수정하면 프로젝트 결과물을 자동으로 배포하는(scss파일을 css파일로 컴파일, js파일들을 minifying하여 하나로 묶는 작업, 작업된 파일을 dist폴더로 이동 등등)작업을 자동화 시킨 것과 같다.&lt;/p&gt;

&lt;h1 id=&quot;javascript-build-tool&quot;&gt;Javascript build tool&lt;/h1&gt;

&lt;p&gt;자바스크립트 빌드툴이라고 불리우는 대표적인 것들이 grunt, webpack, browserify, gulp가 존재하며 2016년 사용현황은 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://stateofjs.com/2016/buildtools/&quot;&gt;&lt;img src=&quot;/images/2017-01-30-preview-gulp/build-tool-userchart.png&quot; alt=&quot;javascript-build-tool-user-chart&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;그래프와 같이 webpack과 gulp의 인기가 높으며, 습득하다 떠나는 경우가 많이 발생하지 않는다.&lt;/li&gt;
  &lt;li&gt;grunt는 러닝커브가 높아 사용도중 포기하는 경우가 많으며 수요조차 많이 떨어지고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://stateofjs.com/2016/buildtools/&quot;&gt;&lt;img src=&quot;/images/2017-01-30-preview-gulp/build-tool-usage-ratio.PNG&quot; alt=&quot;javascript-build-tool-user-chart&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;webpack은 주로 react진영의 도구들 (react.js, es6(babal), redux 등)에서 사용되고 있다.&lt;/li&gt;
  &lt;li&gt;gulp와 grunt는 주로 bower나 Angular, Backbone, Jasmine에서 쓰이고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;gulp&quot;&gt;gulp?&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/gulpjs/artwork/master/gulp-2x.png&quot; alt=&quot;gulp logo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;github.com에 있는 gulp.js의 메인에서는 gulp를 다음과 같이 정의 하고 있다. &lt;a href=&quot;https://github.com/gulpjs/gulp#what-is-gulp&quot;&gt;링크&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자동화 - gulp는 당신의 개발 workflow의 고통스럽고(painful) 시간낭비인(time-consuming)작업의 자동화를 도와주는 툴킷입니다.&lt;/li&gt;
  &lt;li&gt;플랫폼에 독립적이다 - 모든 IDEs에 설치 할수 있으며, 사람들은 gulp를 PHP, .NET, Node.js, Java 및 다른 플랫폼에 사용합니다.&lt;/li&gt;
  &lt;li&gt;강력한 생태계 - 사용하려는 npm 모듈을 사용할수 있고, 2000개 이상의 선별된 특별한 파일 스트림 변환을 사용한 플러그인이 있습니다.&lt;/li&gt;
  &lt;li&gt;간단함 - 간단한 API 환경을 제공함으로서, gulp는 쉽게 배우고 간단하게 사용합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;간단하게 정리해 보자면, 어디서든 쓸수 있고, 간단하며 많은 플러그인을 가진 자동화 툴이란 이야기이다.&lt;/p&gt;

&lt;h1 id=&quot;how-to-use-gulp&quot;&gt;How to use gulp?&lt;/h1&gt;

&lt;p&gt;gulp의 사용법을 비교해보자면 make를 들어볼 수 있다.(이런 이유로 앞에 설명하였다;) makefile이라는 명세를 만들고 make 명령어를 실행하는 방법이다. make와 같이 gulp도 gulpfile.js라는 파일에 task를 명세하여 사용한다.&lt;/p&gt;

&lt;h1 id=&quot;hello-gulp-world&quot;&gt;hello gulp world!!&lt;/h1&gt;

&lt;p&gt;gulp를 설치하는 방법은 간단하다. (npm은 설치되어있다고 가정합니다. 만약 모른다면? &lt;a href=&quot;https://github.com/npm/npm#super-easy-install&quot;&gt;여기로!&lt;/a&gt;)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install --global gulp-cli
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또한 &lt;code class=&quot;highlighter-rouge&quot;&gt;gulp&lt;/code&gt;라는 명령어를 사용하기 위해 프로젝트 디렉토리에서 아래의 명령어를 처주기만 하면된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install --save-dev gulp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그럼 프로젝트 디렉토리에서 gulpfile.js(이하 gulpfile)만 작성하면 준비가 끝난다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var gulp = require('gulp');

gulp.task('default', function() {
  // place code for your default task here
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 콘솔창에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;gulp&lt;/code&gt;를 입력하면 실행한다.&lt;/p&gt;

&lt;h2 id=&quot;gulp-api&quot;&gt;&lt;a href=&quot;https://github.com/preco21/gulp-docs-ko/blob/master/API.md&quot;&gt;gulp API&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;gulp를 사용하기 위해선 몇가지 알아야할 API가 존재한다.&lt;/p&gt;

&lt;h3 id=&quot;gulpsrcglobs-options&quot;&gt;&lt;a href=&quot;https://github.com/preco21/gulp-docs-ko/blob/master/API.md#gulpsrcglobs-options&quot;&gt;gulp.src(globs[, options])&lt;/a&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gulp.src('client/templates/*.jade')
  .pipe(jade())
  .pipe(minify())
  .pipe(gulp.dest('build/minified_templates'));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;globs&lt;/code&gt;는 &lt;a href=&quot;https://github.com/isaacs/node-glob&quot;&gt;node-glob문법&lt;/a&gt;을 따른다.&lt;/p&gt;

&lt;p&gt;gulp는 특이한 파일 시스탬을 사용하는데 이름은 &lt;a href=&quot;https://github.com/wearefractal/vinyl-fs&quot;&gt;vinyl&lt;/a&gt;이라고 한다.(&lt;a href=&quot;http://programmingsummaries.tistory.com/382&quot;&gt;관련링크&lt;/a&gt;) 이 특수한 파일시스탬은 &lt;a href=&quot;https://nodejs.org/api/stream.html&quot;&gt;node의 stream&lt;/a&gt;을 반환하며, node의 &lt;a href=&quot;http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options&quot;&gt;pipe()&lt;/a&gt;를 이용하여 작업을 진행한다.(&lt;a href=&quot;http://programmingsummaries.tistory.com/363&quot;&gt;참고자료: node stream의 이해&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;options는 javascript 객체이며 다음의 값을 갖는다.&lt;/p&gt;

&lt;h4 id=&quot;optionsbuffer&quot;&gt;options.buffer&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;타입: Boolean 기본값: true&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;false로 지정하면 file.contents를 버퍼 파일 대신 스트림 형식으로 반환한다. 아주 큰 파일을 다룰 때 유용하게 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;참고: 플러그인은 스트림에 대한 구현을 지원하지 않을 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;optionsread&quot;&gt;options.read&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;타입: Boolean 기본값: true&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;false로 지정하면 file.contents가 null이 되며 모든 파일을 읽지 않는다.&lt;/p&gt;

&lt;h4 id=&quot;optionsbase&quot;&gt;options.base&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;타입: String 기본값: 모든 glob가 시작되는 위치&lt;/code&gt; (&lt;a href=&quot;https://github.com/wearefractal/glob2base&quot;&gt;glob2base&lt;/a&gt;를 참고)&lt;/p&gt;

&lt;p&gt;예제: somefile.js가 client/js/somedir안에 있을 때:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gulp.src('client/js/**/*.js') // Matches 'client/js/somedir/somefile.js' and resolves `base` to `client/js/`
  .pipe(minify())
  .pipe(gulp.dest('build'));  // Writes 'build/somedir/somefile.js'

gulp.src('client/js/**/*.js', { base: 'client' })
  .pipe(minify())
  .pipe(gulp.dest('build'));  // Writes 'build/js/somedir/somefile.js'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;gulpdestpath-options&quot;&gt;&lt;a href=&quot;https://github.com/preco21/gulp-docs-ko/blob/master/API.md#gulpdestpath-options&quot;&gt;gulp.dest(path[, options])&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;파이프된 스트림을 파일로 변환시킨다. 파일로 변환 후 스트림은 끝나지 않으니 여러번 사용할 수 있으며, 지정된 경로에 폴더가 없을경우 자동으로 생성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gulp.src('./client/templates/*.jade')
  .pipe(jade())
  .pipe(gulp.dest('./build/templates'))
  .pipe(minify())
  .pipe(gulp.dest('./build/minified_templates'));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;options는 javascript 객체이며 다음의 값을 갖는다.&lt;/p&gt;

&lt;h4 id=&quot;optionscwd&quot;&gt;options.cwd&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;타입: String 기본값: process.cwd()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;결과물을 출력할 cwd 폴더를 지정합니다. 출력 폴더가 상대 경로일 경우에만 작동한다.&lt;/p&gt;

&lt;h4 id=&quot;optionsmode&quot;&gt;options.mode&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;타입: String 기본값: 0777&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;출력 폴더를 생성하기 위해 필요한 폴더의 모드를 8진수 권한 문자열로 설정한다.&lt;/p&gt;

&lt;h3 id=&quot;gulptaskname-deps-fn&quot;&gt;&lt;a href=&quot;https://github.com/preco21/gulp-docs-ko/blob/master/API.md#gulptaskname-deps-fn&quot;&gt;gulp.task(name[, deps], fn)&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/robrich/orchestrator&quot;&gt;Orchestrator&lt;/a&gt;를 사용하여 구현된 이 API는 아래의 예시 처럼 사용하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gulp.task('mytask', ['array', 'of', 'task', 'names'], function() {
  // do stuff
  gulp.src('client/templates/*.jade')
  .pipe(jade())
  .pipe(minify())
  .pipe(gulp.dest('build/minified_templates'));
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 작업은 &lt;code class=&quot;highlighter-rouge&quot;&gt;/client/templates/&lt;/code&gt;안의 jade파일을 gulp-jade플러그인을 이용하여 컴파일 하고, minifying 후 &lt;code class=&quot;highlighter-rouge&quot;&gt;build/minified_templates&lt;/code&gt;경로에 저장하는 하나의 task다.&lt;/p&gt;

&lt;p&gt;function의 작업을 비동기로 만들 수도 있다.&lt;/p&gt;

&lt;h4 id=&quot;콜백-사용&quot;&gt;콜백 사용&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// shell에서 구동 시에
var exec = require('child_process').exec;
gulp.task('jekyll', function(cb) {
  // build Jekyll
  exec('jekyll build', function(err) {
    if (err) return cb(err); // return error
    cb(); // finished task
  });
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;stream-반환&quot;&gt;Stream 반환&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gulp.task('somename', function() {
  var stream = gulp.src('client/**/*.js')
    .pipe(minify())
    .pipe(gulp.dest('build'));
  return stream;
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;promise-반환&quot;&gt;Promise 반환&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Q = require('q');

gulp.task('somename', function() {
  var deferred = Q.defer();

  // do async stuff
  setTimeout(function() {
    deferred.resolve();
  }, 1);

  return deferred.promise;
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 비동기 작업들은 기본적으로 모든 task는 한 번에 실행된다. 하지만 아래의 규칙을 적용한다면 비동기이지만 순차적으로 실행이 가능하다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;작업이 언제 완료되는지 표시한다.&lt;/li&gt;
  &lt;li&gt;다른 작업에서 해당 작업의 완료에 대해 표시해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예제를 통해서 알아봅시다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var gulp = require('gulp');

// 작업이 완료 될 때 엔진이 알 수 있도록 콜백을 받는다.
gulp.task('one', function(cb) {
    // do stuff -- async or otherwise
    cb(err); // if err is not null and not undefined, the run will stop, and note that it failed
});

// identifies a dependent task must be complete before this one begins
// 이 작업이 시작되기 전에 종속된 작업(one)이 완료되어야 한다.
gulp.task('two', ['one'], function() {
    // task 'one' is done now
});

gulp.task('default', ['one', 'two']);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;먼저 “one”과 “two”라는 작업이 있고, 다음과 같은 순서에 맞춰 진행 한다:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Stream, 콜백 또는 Promise을 사용하여 작업 “one”이 정상적으로 완료되는 부분을 표시한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;작업 “two”에선 실행 이전에 필요한 “one”이라는 작업을 종속성 작업으로 지정한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;gulpwatchglob--opts-two-way-method&quot;&gt;gulp.watch(glob [, opts], {two way method})&lt;/h3&gt;

&lt;p&gt;gulp.watch는 원하는 폴더를 감시하고 해당 폴더의 내용이 변경되었을 때 무언가를 진행하기 위해 만들어진 API다. 총 2가지 방법으로 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;우선 2가지의 변수를 설명합니다.&lt;/p&gt;

&lt;h4 id=&quot;glob&quot;&gt;glob&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;타입: String 또는 Array&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;변경을 감시할 타겟 파일입니다. 단일 glob 또는 배열을 지정할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;opts&quot;&gt;opts&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;타입: Object&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/shama/gaze&quot;&gt;gaze&lt;/a&gt;로 넘겨지는 옵션이다. &lt;a href=&quot;https://github.com/shama/gaze&quot;&gt;gaze&lt;/a&gt;는 node의 fs.watch를 이용한 watch 라이브러리이며 node 4버전 이상부터 사용이 가능하다.&lt;/p&gt;

&lt;h3 id=&quot;gulpwatchglob--opts-tasks&quot;&gt;&lt;a href=&quot;https://github.com/preco21/gulp-docs-ko/blob/master/API.md#gulpwatchglob-opts-tasks&quot;&gt;gulp.watch(glob [, opts], tasks)&lt;/a&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var watcher = gulp.watch('js/**/*.js', ['uglify','reload']);
watcher.on('change', function(event) {
  console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;tasks&quot;&gt;tasks&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;타입: Array&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;파일의 변경 이벤트가 발생할 때마다 호출할 task다. 여러 개 지정할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;gulpwatchglob-opts-cb&quot;&gt;&lt;a href=&quot;https://github.com/preco21/gulp-docs-ko/blob/master/API.md#gulpwatchglob-opts-cb&quot;&gt;gulp.watch(glob[, opts, cb])&lt;/a&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gulp.watch('js/**/*.js', function(event) {
  console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;cbevent&quot;&gt;cb(event)&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;타입: Function&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;콜백은 변경 이벤트마다 호출되며 event 객체를 반환한다.&lt;/p&gt;

&lt;h4 id=&quot;eventtype&quot;&gt;event.type&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;타입: String&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;발생한 이벤트의 타입입니다. added, changed, deleted 중 한 가지가 지정된다.&lt;/p&gt;

&lt;h4 id=&quot;eventpath&quot;&gt;event.path&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;타입: String&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이벤트가 발생한 파일의 경로다.&lt;/p&gt;

&lt;h2 id=&quot;gulp-cli&quot;&gt;&lt;a href=&quot;https://github.com/preco21/gulp-docs-ko/blob/master/CLI.md&quot;&gt;gulp Cli&lt;/a&gt;&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gulp \&amp;lt;a task\&amp;gt; [\&amp;lt;another tasks\&amp;gt; \&amp;lt;flags\&amp;gt;] 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;gulp는 make처럼 콘솔에서 실행해야 한다.(물론 IDE를 사용하시면 안하셔도 됩니다만.. 저는 콘솔이 편해서).&lt;/p&gt;

&lt;p&gt;gulp는 단독 실행이 가능하며 gulp만 입력했다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;gulp default&lt;/code&gt;를 실행 하는 것과 같다. 그래서 &lt;code class=&quot;highlighter-rouge&quot;&gt;gulpfile&lt;/code&gt;에 ‘default’ task가 없을 경우 에러를 낸다. 그래서 보통 ‘default’ task에는 integration이나 building process를 입력해놓는다.&lt;/p&gt;

&lt;p&gt;gulp는 각각의 task를 선택해서 실행이 가능하다. 또한 여러개의 task를 동시에 실행도 가능하다.&lt;/p&gt;

&lt;p&gt;gulp 명령어에는 help 커멘드가 없다. 이에 콘솔에서 쓰이는 gulp의 flag들을 확인해보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;v or –version 전역, 지역 gulp의 버전을 표시합니다.&lt;/li&gt;
  &lt;li&gt;-require &lt;code class=&quot;highlighter-rouge&quot;&gt;module path&lt;/code&gt; gulpfile을 실행하기 전에 포함할 모듈을 지정합니다. 이 플래그는 빌드전에 transpile 언어를 컴파일 할 때 사용할 수 있습니다. 또한 다중으로 –require 플래그를 사용할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;-gulpfile &lt;code class=&quot;highlighter-rouge&quot;&gt;gulpfile path&lt;/code&gt; 실행할 gulpfile을 직접 지정합니다. gulpfile이 여러 개일 때 유용한 플래그입니다. 그뿐만 아니라 gulpfile 디렉터리를 CWD로 설정합니다.&lt;/li&gt;
  &lt;li&gt;-cwd &lt;code class=&quot;highlighter-rouge&quot;&gt;dir path&lt;/code&gt; CWD를 직접 지정합니다. gulpfile과 포함된 모든 모듈들은 이 디렉터리에서 찾습니다.&lt;/li&gt;
  &lt;li&gt;T or –tasks 로드된 gulpfile의 작업 리스트를 의존성 트리 형태로 표시합니다.&lt;/li&gt;
  &lt;li&gt;-tasks-simple 로드된 gulpfile의 작업 리스트를 간단한 텍스트로 표시합니다.&lt;/li&gt;
  &lt;li&gt;-color gulp와 gulp 플러그인의 색상 로깅을 지원하지 않을 때도 활성화합니다.&lt;/li&gt;
  &lt;li&gt;-no-color gulp와 gulp 플러그인의 색상 로깅을 모두 비활성화합니다.&lt;/li&gt;
  &lt;li&gt;-silent 모든 gulp 로그를 비활성화합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;favorite-gulp-plugin&quot;&gt;favorite &lt;a href=&quot;http://gulpjs.com/plugins/&quot;&gt;gulp plugin&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;gulp는 2000개가 넘는(확인 결과 2846개 등록 됨) plugin을 지원하지만 우리는 그 걸 다 사용하진 않을 것이고, 그리고 그 중에서도 많이 사용되는 것을 사용하지 않을 까라는 차원에서의 정리이다.
&lt;a href=&quot;https://github.com/Pestov/essential-gulp-plugins&quot;&gt;[참고사이트]&lt;/a&gt;
&lt;a href=&quot;https://www.npmjs.com/search?q=gulp&amp;amp;page=1&amp;amp;ranking=optimal&quot;&gt;[npm best overall]&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;gulp-uglify&quot;&gt;&lt;a href=&quot;https://www.npmjs.com/package/gulp-uglify/&quot;&gt;gulp-uglify&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;gulp-uglify는 javascript file을 압축시킨다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var gulp = require('gulp');
var uglify = require('gulp-uglify');
 
gulp.task('compress', function () {
    gulp.src('lib/*.js')
    .pipe(uglify())
    .pipe(gulp.dest('dist'));
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;gulp-uglifycss&quot;&gt;&lt;a href=&quot;https://www.npmjs.com/package/gulp-uglifycss/&quot;&gt;gulp-uglifycss&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;gulp-uglifycss는 css file을 압축시킨다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var uglifycss = require('gulp-uglifycss');
 
gulp.task('css', function () {
  gulp.src('./styles/**/*.css')
    .pipe(uglifycss({
      &quot;maxLineLen&quot;: 80,
      &quot;uglyComments&quot;: true
    }))
    .pipe(gulp.dest('./dist/'));
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;gulp-concat&quot;&gt;&lt;a href=&quot;https://www.npmjs.com/package/gulp-concat/&quot;&gt;gulp-concat&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;gulp-concat은 여러개의 javascript file을 하나로 만들어준다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var concat = require('gulp-concat'); 
var uglifycss = require('gulp-uglifycss');
 
gulp.task('css', function () {
  gulp.src('./styles/**/*.css')
    .pipe(uglifycss({
      &quot;maxLineLen&quot;: 80,
      &quot;uglyComments&quot;: true
    }))
    .pipe(gulp.dest('./dist/'));
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;gulp-sass&quot;&gt;&lt;a href=&quot;https://www.npmjs.com/package/gulp-sass/&quot;&gt;gulp-sass&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;gulp-sass은 scss/sass 파일을 css 파일로 변환시켜주는 preprocesser이다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'use strict';
 
var gulp = require('gulp');
var sass = require('gulp-sass');
 
gulp.task('sass', function () {
  return gulp.src('./sass/**/*.scss')
    .pipe(sass().on('error', sass.logError))
    .pipe(gulp.dest('./css'));
});
 
gulp.task('sass:watch', function () {
  gulp.watch('./sass/**/*.scss', ['sass']);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;gulp-in-idejetbrains-products&quot;&gt;gulp in IDE(Jetbrains products)&lt;/h1&gt;

&lt;p&gt;gulp를 IDE에서 편하게 관리해보자. &lt;a href=&quot;http://wagunblog.com/wp/?p=1823&quot;&gt;[참고 자료]&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;nodejs와 npm은 설치되어있다고 가정한다.&lt;/li&gt;
  &lt;li&gt;IDE Terminal에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;npm init&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;npm install gulp -g&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;npm install gulp --save-dev&lt;/code&gt;를 순차적으로 입력합니다.&lt;/li&gt;
  &lt;li&gt;프로젝트 최상단에 &lt;code class=&quot;highlighter-rouge&quot;&gt;gulpfile.js&lt;/code&gt;를 생성합니다. 그리고 진행 확인을 위해 gulp.task 하나정도를 명세합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gulpfile.js&lt;/code&gt;를 오른쪽마우스로 클릭하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Show Gulp Tasks&lt;/code&gt;를 선택하면 좌측 하단에 Gulp 창이 나타납니다.&lt;/li&gt;
  &lt;li&gt;task를 선택해서 실행하면 됩니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;gulpfile-recipes&quot;&gt;gulpfile recipes&lt;/h1&gt;

&lt;p&gt;gulp github프로젝트의 문서 사항 중 사용목적별로 엄선된(?) 잘 만들어진 gulpfile을 모아놨다. (&lt;a href=&quot;https://github.com/gulpjs/gulp/tree/master/docs/recipes&quot;&gt;링크&lt;/a&gt;)&lt;/p&gt;

&lt;h1 id=&quot;gulpfile-cheat-sheet&quot;&gt;gulpfile cheat sheet&lt;/h1&gt;

&lt;p&gt;어느 훌륭하신 분이 고맙게도 &lt;a href=&quot;https://github.com/osscafe/gulp-cheatsheet&quot;&gt;cheet sheet&lt;/a&gt;를 작성하여 배포하셨으니 참고하길 바람.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/osscafe/gulp-cheatsheet/raw/master/images/en-js-p1.png&quot; alt=&quot;gulp cheat sheet1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/osscafe/gulp-cheatsheet/raw/master/images/en-js-p2.png&quot; alt=&quot;gulp cheat sheet2&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;정리&quot;&gt;정리&lt;/h1&gt;
&lt;p&gt;사용법이 간단해서 내용도 간단할 줄 알았던 저의 착각이 글 발행기일을 넘겨버리는 지경까지 가게되었습니다 ㅠ. 생각보다 많은 리소스를 오픈소스에서 착안한 부분은 아주 인상적이였습니다.&lt;/p&gt;

&lt;p&gt;시간이 된다면 gulp와 관련하여 이런 주제를 진행 하려 합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;vinyl filesystem&lt;/li&gt;
  &lt;li&gt;glob &amp;amp; node-glob&lt;/li&gt;
  &lt;li&gt;Orchestrator&lt;/li&gt;
  &lt;li&gt;compare javascript build tool&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하하 저의 게으름을 고처줄 명약을 찾습니다…
끗!&lt;/p&gt;
</description>
        <pubDate>Mon, 30 Jan 2017 00:00:00 +0000</pubDate>
        <link>http://nGeniuskr.github.io/2017/01/30/preview-gulp.html</link>
        <guid isPermaLink="true">http://nGeniuskr.github.io/2017/01/30/preview-gulp.html</guid>
        
        
      </item>
    
      <item>
        <title>내맘대로 정리해보는 BDD, TDD</title>
        <description>&lt;p&gt;저번주 &lt;a href=&quot;/2017/01/13/review-make-telegram-bot&quot;&gt;telegram bot 만들기&lt;/a&gt;를 하고 이 프로젝트를 통해 많은 것들을 시도해보려 했습니다.&lt;/p&gt;

&lt;p&gt;그 중에 이번주는 TDD를 진행하기로 했습니다만..&lt;/p&gt;

&lt;p&gt;갑작스런 취업으로(게으름에 대한 변명은 아닙니다! … 아니라구요!!ㅠ) 공부를 얼마 진행하지 못하고 글을 작성합니다. (ㅡㅡ)&lt;/p&gt;

&lt;h1 id=&quot;tdd란&quot;&gt;TDD란?&lt;/h1&gt;

&lt;p&gt;TDD(Test Driven Development)는 Test를 통과하는 코드를 작성하자라는 모토로 개발을 진행하는 소프트웨어 개발 방법 중 하나입니다. 간단히 설명하면 구현해야할 기능 Test를 통과하는 코드를 간단하게 작성한 후, 그 코드를 표준에 맞는 좋은 코드로 변환(리펙토링)을 하는 방법입니다.&lt;/p&gt;

&lt;p&gt;프로세스를 요약해본다면 아래와 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;기능 디자인 설계&lt;/li&gt;
  &lt;li&gt;(설계에 충실한) Test코드를 작성.&lt;/li&gt;
  &lt;li&gt;(간신히 돌아가는) 코드 작성&lt;/li&gt;
  &lt;li&gt;코드 리펙토링&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;즉, 설계에 맞는 Test 소스를 만든 후 Test를 통과하는 코드를 작성합니다.&lt;/p&gt;

&lt;h1 id=&quot;bdd란&quot;&gt;BDD란?&lt;/h1&gt;

&lt;p&gt;TDD라는 걸출한 방법론이 있음에도 속속들이 나타나는 xDD들이 나타났는데 그중 하나인 BDD(Behaviour-Driven Development)는 Test를 행동이라는 말로만 바꾼 것입니다. 명세를 테스트 양식을 코드 기준이 아닌 소프트웨어 명세(어플리케이션 사용자의 행동)을 기준으로 테스트를 하는 방법입니다. 제가 이해한 기준으로는 UI양식에 따라서 테스트를 진행하는 것 입니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.jaigurudevaom.net/319&quot;&gt;BDD 참조&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.aliencube.org/ko/2014/04/02/differences-between-bdd-and-tdd/&quot;&gt;TDD와 BDD의 차이점&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;그럼-어떻게-bdd를-진행해볼까&quot;&gt;그럼 어떻게 BDD를 진행해볼까?&lt;/h1&gt;

&lt;p&gt;가장 좋은 하지만 조금 위험한 방법인 “예제를 이용한 설명”을 진행해볼까 합니다.&lt;/p&gt;

&lt;p&gt;가장 만만한 TODO 앱을 BDD기법으로 개발해봅시다.&lt;/p&gt;

&lt;h2 id=&quot;1-todo앱으로-할-수있는-것들을-나열해봅시다&quot;&gt;1. TODO앱으로 할 수있는 것들을 나열해봅시다.&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;TODO를 등록 할 수 있다.&lt;/li&gt;
  &lt;li&gt;등록된 TODO를 볼 수 있다.&lt;/li&gt;
  &lt;li&gt;TODO를 진행완료로 바꿀 수 있다.&lt;/li&gt;
  &lt;li&gt;등록된 TODO를 지울 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-1번에서-크게-나누었던-동작을-세분화-시켜봅시다&quot;&gt;2. 1번에서 크게 나누었던 동작을 세분화 시켜봅시다&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;TODO를 등록 할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;할일 내용을 입력할 수 있다.&lt;/li&gt;
      &lt;li&gt;기한을 정할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;등록된 TODO를 볼 수 있다.
    &lt;ul&gt;
      &lt;li&gt;목록으로 볼 수 있다.&lt;/li&gt;
      &lt;li&gt;상세정보를 볼 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TODO를 진행완료로 바꿀 수 있다.
    &lt;ul&gt;
      &lt;li&gt;진행 한 할일을 진행완료로 바꿀 수 있다.&lt;/li&gt;
      &lt;li&gt;진행완료였던 할 일을 다시 진행 중으로 바꿀 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;등록된 TODO를 지울 수 있다.
    &lt;ul&gt;
      &lt;li&gt;진행 중인 할 일을 지울 수 있다.&lt;/li&gt;
      &lt;li&gt;진행완료된 할 일을 지울 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-그럼-2번을-bdd식-test-case로-작성해-봅시다-mocha---bdd-기준입니다&quot;&gt;3. 그럼 2번을 BDD식 Test case로 작성해 봅시다.( Mocha - bdd 기준입니다.)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// app.spac.js
describe(&quot;TODO APP&quot;, function(){
    describe(&quot;TODO를 등록 할 수 있다.&quot;, function(){
        it(&quot;할일 내용을 입력할 수 있다.&quot;, function(){
            
        })
        it(&quot;기한을 정할 수 있다.&quot;, function(){
        
        })
    })
    describe(&quot;등록된 TODO를 볼 수 있다.&quot;, function(){
        it(&quot;목록으로 볼 수 있다.&quot;, function(){
        
        })
        it(&quot;상세정보를 볼 수 있다.&quot;, function(){
        
        })
    })
    describe(&quot;TODO를 진행완료로 바꿀 수 있다.&quot;, function(){
        it(&quot;진행 한 할일을 진행완료로 바꿀 수 있다.&quot;, function(){
        
        })
        it(&quot;진행완료였던 할 일을 다시 진행 중으로 바꿀 수 있다.&quot;, function(){
        
        })
    })
    describe(&quot;등록된 TODO를 지울 수 있다.&quot;, function(){
        it(&quot;진행 중인 할 일을 지울 수 있다.&quot;, function(){
        
        })
        it(&quot;진행완료된 할 일을 지울 수 있다.&quot;, function(){
        
        })
    })
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;4-test-case에-필요한-것을을-채워-넣습니다&quot;&gt;4. Test case에 필요한 것을을 채워 넣습니다.&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// app.js
var TODOSTORE = [];
var todo = function(_title, _description, _deadline){
    return {
        title: _title,
        description: _description,
        deadline: _deadline,
        inProgress: true
    }
}

// app.spac.js
describe(&quot;TODO APP&quot;, function(){
    describe(&quot;TODO를 등록 할 수 있다.&quot;, function(){
        it(&quot;할일 내용을 입력할 수 있다.&quot;, function(){
            assert.equal(TODOSTORE.length, 0);
            TODOSTORE.push(todo(&quot;할 일&quot;,&quot;음..?&quot;));
            assert.equal(TODOSTORE.length, 1);                
        })
        it(&quot;기한을 정할 수 있다.&quot;, function(){
            TODOSTORE.push(todo(&quot;할 일2&quot;,&quot;음음...&quot;,&quot;2017-01-28&quot;));
            assert.equal(TODOSTORE[TODOSTORE.length-1].deadline, &quot;2017-01-28&quot;);                
        })
    })
    describe(&quot;등록된 TODO를 볼 수 있다.&quot;, function(){
        it(&quot;목록으로 볼 수 있다.&quot;, function(){
            ...
        })
        it(&quot;상세정보를 볼 수 있다.&quot;, function(){
            ...
        })
    })
    describe(&quot;TODO를 진행완료로 바꿀 수 있다.&quot;, function(){
        it(&quot;진행 한 할일을 진행완료로 바꿀 수 있다.&quot;, function(){
            ...
        })
        it(&quot;진행완료였던 할 일을 다시 진행 중으로 바꿀 수 있다.&quot;, function(){
            ...
        })
    })
    describe(&quot;등록된 TODO를 지울 수 있다.&quot;, function(){
        it(&quot;진행 중인 할 일을 지울 수 있다.&quot;, function(){
            ...
        })
        it(&quot;진행완료된 할 일을 지울 수 있다.&quot;, function(){
            ...
        })
    })
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;5-이제-리펙토링을-진행합니다&quot;&gt;5. 이제 리펙토링을 진행합니다.&lt;/h2&gt;

&lt;p&gt;코드는 생략하겠습니다. 일단 todo 함수의 경우에는 module화 시켜서 변수 및 메서드를 정의 하고 객체화 시키는 것도 하나의 방법이라고 할수 있습니다. (여기에 담기에는 홈페이지 공간이 부족(..)하니.. 쿨럭) 또한 저장소를 Array가 아닌 다른 방법으로(DB라던지 파일이라던지 등등) 조건에 맞도록 변경하면 됩니다.&lt;/p&gt;

&lt;h1 id=&quot;정리&quot;&gt;정리&lt;/h1&gt;

&lt;p&gt;간단한게 살펴본 TDD, BDD였습니다. 지금까지 대략적인 방법과 “이렇게 하면 다 된다!” 라는 공식만 주구장창 봐왔던 저에겐 실습책 한권가 실습은 큰 도움이 되었습니다.&lt;/p&gt;

&lt;p&gt;아마 이 글은 게으름이 나아갈 때 쯤 보강이 되지 않을 가 생각합니다. 너무 적은 정보를 서술해놓을 것 도 그렇고 예제로 설명되어있으나 예제에 대한 설명이 없기 떄문에 정보라기보다는 일기에 가까운 글이 되었기 때문입니다.&lt;/p&gt;

&lt;p&gt;이 글을 보고 계신분중에 “TDD, BDD 이런거 고수들이나 하는 거 아닌가?” 이런 생각하시는분들 이런 허술 한 글 보다는 한번 해보시는 것을 추천합니다. 어렵지 않습니다. 이런 저도 이해 하고 실행 할 뿐만 아니라 글도 쓰지 않았습니까? 이상입니다. 끗!&lt;/p&gt;
</description>
        <pubDate>Sat, 21 Jan 2017 00:00:00 +0000</pubDate>
        <link>http://nGeniuskr.github.io/2017/01/21/report-BDD-TDD-by-mystyle.html</link>
        <guid isPermaLink="true">http://nGeniuskr.github.io/2017/01/21/report-BDD-TDD-by-mystyle.html</guid>
        
        
      </item>
    
      <item>
        <title>의식에 흐름대로 적어보는 텔레그램 봇 만들기 후기</title>
        <description>&lt;p&gt;지난주 생각했던 아이디어였던 “그룹 체팅방에 그림을 글자로 옮겨서 보여주기” 아이디어가 여러 사람에 의해 살이 붙어 이 조그만 프로그램을 만들기로 하셨습니다. 원래는 계획을 가지고 실행하려 했으나, 계획을 하면 계획’만’열심히(그러나 성과는 거의 없는)하고 지처서 프로젝트를 진행 하지 않는 저의 게으른 천성(..) 때문에 ‘그냥’만들고 리펙토링을 하는 것으로 결정했습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/RestrictedZone/telegramBot&quot;&gt;소스코드!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;1차-구조-설계&quot;&gt;1차 구조 설계&lt;/h2&gt;

&lt;p&gt;진행 할 언어는 Javascript입니다. telegram bot으로 검색해본결과 많은 수의 bot들이 다양한 언어로 만들어졌는데 주로 사용되는 언어는 Python, PHP, Javascript(node.js)입니다.&lt;/p&gt;

&lt;p&gt;저는 Javascript가 익숙하니 node.js를 이용하여 만들기로 했습니다.&lt;/p&gt;

&lt;p&gt;우선 대략적인 구조를 깔고 가야 프로젝트 진행하기가 수월하기 때문에 방향만 잡는 설계를 진행하였습니다. 필요한 것이 무엇인지 파악하고 다음의 기능이 필요하다는 사실을 알았습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OCR(Optical character recognition:광학문자인식)&lt;/li&gt;
  &lt;li&gt;telegram bot api&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이에 기술조사에 착수하였고 OCR의 경우에는 Google에서 Open Source 라이브러리인 tesseract라는 툴이 가장 범용적으로 쓰이고 한글까지 지원하는 것을 발견하고 이 툴을 사용하기로 합니다.&lt;/p&gt;

&lt;p&gt;Telegram bot의 경우에는 공식적으로 api를 지원하고 있고 많은 서드파티들이 존재했기 때문에 아무거나 골라서 쓰면 되겠다는 생각으로 구조 설계를 마쳤습니다.&lt;/p&gt;

&lt;p&gt;따라서 process의 흐름은 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-01-13-review-make-telegram-bot/process1.png&quot; alt=&quot;process1.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;문제점-발생---이놈에-ocr은-왜-항상-미완성-인가&quot;&gt;문제점 발생 - 이놈에 OCR은 왜 항상 미완성 인가.&lt;/h2&gt;

&lt;p&gt;역시 생각대로 한번에 되는 프로젝트는 없나봅니다 (..) 넓은 그림에 드문드문 있는 글씨로는 tesseract의 인식률은 절망에 가까웠습니다. 제가 인식 시키려고 했던 이미지입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-01-13-review-make-telegram-bot/recent.png&quot; alt=&quot;인식을 해야하는 그림&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그래서 이미지에서 텍스트 영역을 잡아서 인식시키기로 했습니다. 그림을 영역을 잡기 위해 영역을 나누고 잘라 각각의 파일로 나눈 뒤 각각의 그림을 OCR을 돌리기로 했습니다. 그래서 새로운 툴인 graphicmagick라는 툴을 영입하여 사용하기로 했습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OCR(Optical character recognition:광학문자인식)&lt;/li&gt;
  &lt;li&gt;telegram bot api&lt;/li&gt;
  &lt;li&gt;graphicmagick (그림 도구 툴)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-01-13-review-make-telegram-bot/process2.png&quot; alt=&quot;process2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여러번의 시행착오( 처음에 영역은 2개였으나 차츰 늘어 5개가 됨, 방 이름이 영어라서 인식이 안되어 언어팩을 바꿔가며 사용 등등) 끝에 원하는 텍스트를 추출할 수 있게 되었습니다.(만세!)&lt;/p&gt;

&lt;h2 id=&quot;telegram-bot-api는-생각보다-어려웠다&quot;&gt;telegram bot api는 생각보다 어려웠다.&lt;/h2&gt;

&lt;p&gt;현재 이 프로젝트는 node.js의 telegram bot api module인 &lt;code class=&quot;highlighter-rouge&quot;&gt;node-telegram-bot-api&lt;/code&gt;를 이용하여 체팅 봇의 이벤트 리스너를 사용하고 있다.&lt;/p&gt;

&lt;p&gt;이벤트 리스너 기반이라는 것을 알았지만 적용시키는데에는 우리의 봇과 1시간이나 체팅을 하면서 놀아야만 하였다 \=_=//&lt;/p&gt;

&lt;p&gt;우여곡절 끝에 &lt;code class=&quot;highlighter-rouge&quot;&gt;bot.on()&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;bot.onText()&lt;/code&gt;의 차이(on()는 모든 메시지의 반응하는 이벤트리스너이고 onText()는 bot api의 기능중 하나인 command를 사용하기 위해 만들어진 것이였다.)를 알아내었고 “안녕”이라는 키워드에 반응 하도록 하는데 또 1시간이 들었다. 그럼 이제 추출된 값을 보내줄수 있게 되었다!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-01-13-review-make-telegram-bot/process3.png&quot; alt=&quot;process3.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;마지막인가&quot;&gt;마지막인가…?&lt;/h2&gt;

&lt;p&gt;이제 가장 중요한 그림을 가져오는 것만 하면된다. 고맙게도 telegram bot api에선 각 메시지 노드가 어떤 값을 가지고 있는지 잘 구분 할 수 있도록 되어있었고, 그림이나 파일을 올리면 각각의 메시지가 다르게 나오도록 구성해놨다. 또한 메시지로 보내졌던 파일을 바로 받아서 저장할 수 있도록 하였기 때문에 다운로드 받기도 편헀다. 일이 이상하게도(?) 순조롭게 진행 되는 것 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (msg.document) {
    ...
} else if (msg.photo) {
    ...
} else if (mes.text) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같은 코드를 통해 메시지를 분류하여 처리하였다. 일단 계획한 대로 잘 처리되는 프로그램이 완성되었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-01-13-review-make-telegram-bot/process4.png&quot; alt=&quot;process4.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;뭔가-허전한데&quot;&gt;뭔가 허전한데..&lt;/h2&gt;

&lt;p&gt;이 작업을 하루만에(그것도 저녁이 되기전에!) 끝내고 뿌듯해 하고 있을 때, 문득 떠올랐다. “아.. 이거 캘린더 링크 만들어 주기로 했지..”. 무려 구글켈린더를 안쓴다는 한 친구에 말이 같이 떠오르면서…&lt;/p&gt;

&lt;h2 id=&quot;만들면-되지&quot;&gt;만들면 되지!&lt;/h2&gt;

&lt;p&gt;추가 과제가 출몰하였습니다. 구글 켈린더 링크와 애플 켈린더 링크를 보내주는 것 까지를 목표로 하게 되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-01-13-review-make-telegram-bot/process5.png&quot; alt=&quot;process5.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;애플-캘린더는-복잡하구나&quot;&gt;애플 캘린더는 복잡하구나..&lt;/h2&gt;

&lt;p&gt;링크를 어떻게 만들면 좋을까 라는 고민에 문득 떠오른 사이트가 있었으니 그것은 &lt;a href=&quot;http://www.onoffmix.com&quot;&gt;onoffmix&lt;/a&gt;였습니다. 2~3년전 자주 사용했지만 이제는 이용이 뜸해진 그 곳에서는 이벤트 등록 편의를 위해 구글 켈린더 링크와 ics 파일을 다운로드 받을 수 있도록 되어있습니다. 순간 스치는 의문점.. “왜 애플 캘린더는 이벤트 추가 링크가 없지?”라는 생각과 검색 끝에 확실한 정보는 찾을 수 없었지만, 브라우져로 서비스되지 않기 때문이라는 추론만 남긴체 결국 ics파일을 만드는 방향으로 프로세스를 수정합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-01-13-review-make-telegram-bot/process6.png&quot; alt=&quot;process6.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ics는-표준-규격이-존재한다&quot;&gt;ics는 표준 규격이 존재한다.&lt;/h2&gt;

&lt;p&gt;일단 모험심이 강한 필자는 ics파일을 까서 어떤 형식을 취하는 지를 확인하고 내가 (쉽게!) 만들수 있는지를 조사하기로 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-01-13-review-make-telegram-bot/in_icsFile.png&quot; alt=&quot;in_icsFile.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림처럼 얼마안되는 양의 양식이였기 때문에 별로 어렵지 않다고 생각한 필자는 field부분을 어떻게 채워 나가야 하는지 파악하며 나아가는 중 UID부분에서 정보를 찾지 못하였고 결국 npm의 ics 모듈과 노드의 기본모듈인 fs모듈을 사용하여 ics를 만들고 보내는 방식으로 프로그램을 제작하였습니다.&lt;/p&gt;

&lt;h2 id=&quot;역시-갓-구글-찬양하라&quot;&gt;역시 갓 구글! 찬양하라!&lt;/h2&gt;

&lt;p&gt;구글은 짱이다. 구글은 편리하다. 찬양하라 구글! 구글 링크 만드는 코드를 공개합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;eventLinkToGoogle = &quot;http://www.google.com/calendar/render?action=TEMPLATE&amp;amp;text=[이벤트제목]&amp;amp;dates=&quot;+(new Date(시작시간 [YYYY-MM-DD HH:MM])).toISOString().replace(/-|:|\.\d\d\d/g,&quot;&quot;)+&quot;/&quot;+(new Date(종료시간 [YYYY-MM-DD HH:MM])).toISOString().replace(/-|:|\.\d\d\d/g,&quot;&quot;)+&quot;&amp;amp;sprop=name:주최자&amp;amp;location=장소&quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-01-13-review-make-telegram-bot/process7.png&quot; alt=&quot;process7.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;진짜-마지막인가&quot;&gt;진짜 마지막인가…?&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-01-13-review-make-telegram-bot/result.png&quot; alt=&quot;result.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;잘 작동 되는 것이 확인 되었습니다. 이제 라즈베리 파이로 옮기기만 하면 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;끝&quot;&gt;끝!&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-01-13-review-make-telegram-bot/rasp-pi.png&quot; alt=&quot;rasp-pi.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;라즈베리파이에 이식 또한 완료되었습니다!&lt;/p&gt;

&lt;h2 id=&quot;다-쓰고-나서-생각난-이야기&quot;&gt;다 쓰고 나서 생각난 이야기&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;사실 이 프로세스를 진행하는 도중 엉뚱한 이미지 파일을 올리면 저장해놓은 스케쥴 데이터가 망가지는 (..) 사태를 한번 발생 시킨 적이 있습니다.. 그래서 graphicmagick의 compare라는 기능을 이용해 처음 등록되는 스케쥴 이미지와 다를 경우 이미지 분석을 하지 않고 넘기는 기능도 구현해놨습니다.&lt;/li&gt;
  &lt;li&gt;이 프로그램은 2일만에 만들어졌고, 리팩토링을 하기 위해 많은 ‘검색’(좀 그만해 ㅠ)을 하였고, 디렉토리 구조를 바꾸는 일과 함수 쪼게기 등을 진행하였습니다.&lt;/li&gt;
  &lt;li&gt;리팩토링을 진행 하는 도중에 webpack이나 gulp, jankins, travis CI 등등 많은 툴을 조사 하고 적용 시키려고 하였으나, 이건 마치 5천원 짜리 물건에 10만원 짜리 보험을 드는 일 같아 보류하기로 했습니다. 이 프로그램이 조금 더 커지고 리팩토링이 어느정도 진행되어야만 사용 할 수 있을 것 같습니다.&lt;/li&gt;
  &lt;li&gt;사실 이번주에 mocha를 이용하여 TDD를 이용하는 리팩토리를 진행하려고 했습니다.(사실 CI를 돌리려면 필요해서 진행한건 안 비밀..) 하지만 필자는 게을렀고 TDD를 진행해야지라고 생각하고 오늘 좀 보다가 결국 글만 올리게 되었습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;마무리-지으며&quot;&gt;마무리 지으며&lt;/h2&gt;

&lt;p&gt;이 프로그램이 얼마나 더 발전될지는 모르겠지만 (개인적으론 좀 더 가지고 놀 수 있도록, 혹은 많은 사람들이 범용적으로 쓸 수 있도록 개발되었으면 좋겠습니다.) 당분간은 이 프로그램과 다른 프로젝트는 겸하여 진행하려고 합니다. 끗!&lt;/p&gt;
</description>
        <pubDate>Fri, 13 Jan 2017 00:00:00 +0000</pubDate>
        <link>http://nGeniuskr.github.io/2017/01/13/review-make-telegram-bot.html</link>
        <guid isPermaLink="true">http://nGeniuskr.github.io/2017/01/13/review-make-telegram-bot.html</guid>
        
        
      </item>
    
      <item>
        <title>clean code를 읽고 정리해보자 part1</title>
        <description>&lt;p&gt;로버트 C 마틴(이하 엉클 밥)의 “객체지향” 개발의 필독서라고 불리우는(..) clean code를 읽고 있습니다.&lt;/p&gt;

&lt;p&gt;오래전에 사두고 첫 머리말이 너무 재미 없어서(..) 접어두었다가 신년 기획겸 해서 읽고 있습니다.&lt;/p&gt;

&lt;p&gt;역시 대작은 첫 머리말이 너무 지루해요. 왕좌의 게임처럼 말이죠..&lt;/p&gt;

&lt;p&gt;처음 읽으시는 분들이라면 인내심을 가지고 함수(3장)부분까지는 읽어보시는 것을 추천합니다.&lt;/p&gt;

&lt;p&gt;저는 그 후에 책을 스키밍하시면 대략적인 책의 구조를 파악하니 재미가 붙어서 읽게 되었으니 참고하시면 좋으실 것 같습니다.&lt;/p&gt;

&lt;h1 id=&quot;서장-들어가면서&quot;&gt;서장 들어가면서&lt;/h1&gt;

&lt;p&gt;clean code를 작성하는 것은 매우 어려우며 이론만으로는 습득할 수 없고, 이론을 바탕으로하는 실습만이 습득방법임을 자전거 타기와 물리학 실험과 같다고 비교하며 설명한다.&lt;/p&gt;

&lt;p&gt;이외에 이 책은 3부분으로 나뉘어 있으며 2번째 부분이 사례연구인데 이부분의 습득이 없다면 이책의 이론만 공부한 샘이 된다고 설명한다.&lt;/p&gt;

&lt;h1 id=&quot;1장-깨끗한-코드&quot;&gt;1장 깨끗한 코드&lt;/h1&gt;

&lt;p&gt;1장에서는 우선 나쁜 코드의 대한 정의와 부작용 그리고 책의 재목이자 이 책에서 주장하는바인 clean code란 무엇인가에 대해서 여러 유명한 프로그래머의 말을 인용함과 동시에 왜 그렇게 이야기했는지를 설명한다.&lt;/p&gt;

&lt;h3 id=&quot;나쁜코드&quot;&gt;나쁜코드&lt;/h3&gt;

&lt;p&gt;나쁜 코드는 좋지 못한 코드의 전부라고 생각한다(필자 의견). 저자는 나쁜 코드는 소프트웨어의 유지보수를 어렵게하여 생산성을 저하시키고, 결국 기술부채가 쌓여 그 기술이 망하게 되는 결과를 초래하고 재설계라는 결론에 오게 된다고 설명한다. 필자는 원초적 난제인 “나쁜 코드가 업무 속도를 늦추지만, 기한을 맞추기 위해서는 나쁜 코드를 양산해야한다고 느낀다”라는 것은 틀린 생각이라고 말하며 기한을 맞추는 유일한 방법은 코드를 짜는 개발자가 최대한 깨끗한 코드를 유지하는 것을 습관화해야 한다고 말한다.&lt;/p&gt;

&lt;h3 id=&quot;좋은코드란&quot;&gt;좋은코드란?&lt;/h3&gt;

&lt;p&gt;프로그래밍으로 저명한 사람들의 의견을 듣고 그 말을 해석해본다.&lt;/p&gt;

&lt;h4 id=&quot;비야네-스트롭스트룹c-창시자&quot;&gt;비야네 스트롭스트룹(C++ 창시자)&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;나는 &lt;strong&gt;우아하고 효율적인 코드&lt;/strong&gt;를 좋아한다. &lt;strong&gt;논리가 간단&lt;/strong&gt;해야 버그가 숨어들지 못한다. 의존성을 최대한 줄여야 유지보수가 쉬워진다. 오류는 명백한 전략에 의거해 철저히 처리한다. &lt;strong&gt;성능을 최적으로 유지하야 사람들이 원칙 없는 최적화로 코드를 망치려는 유혹에 빠지지 않는다.&lt;/strong&gt; &lt;strong&gt;깨끗한 코드는 한가지를 재대로 한다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;깨끗한 코드 === 우아한 코드 === 보기에 즐거운 코드&lt;/li&gt;
  &lt;li&gt;효율적이지 못한 코드는 결국 다른사람이 손을 보게하도록 “유혹”한다. &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EA%B9%A8%EC%A7%84_%EC%9C%A0%EB%A6%AC%EC%B0%BD_%EC%9D%B4%EB%A1%A0&quot;&gt;(깨진 유리창 이론)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;깨끗한 코드는 한가지를 잘한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;그래디-부치object-oriented-analysis-and-design-with-application-저자&quot;&gt;그래디 부치(Object Oriented Analysis and Design with Application 저자)&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;깨긋한 코드는 단순하고 직접적이다. &lt;strong&gt;깨끗한 코드는 잘 쓴 문장 처럼 읽힌다.&lt;/strong&gt; &lt;strong&gt;꺠긋한 코드는&lt;/strong&gt; 결코 설계자의 의도를 숨기지 않는다. 오히려 &lt;strong&gt;명쾌한 추상화와 단순한 제어문으로 가득하다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;가독성을 강조&lt;/li&gt;
  &lt;li&gt;잘 짜여진 코드는 마치 잘 쓰여진 소설책처럼 잘 읽힌다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;큰-데이브-토마스oti의-창립자이자-이클립스-전략의-대부&quot;&gt;큰 데이브 토마스(OTI의 창립자이자 이클립스 전략의 대부)&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다.&lt;/strong&gt; &lt;strong&gt;단위 테스트 케이스와 인수 테스트 케이스가 존재&lt;/strong&gt;한다. 깨긋한 코드에는 의미 있는 이름이 붙는다. 특정 목적을 달성하는 방법은(여러가지가 아니라) 하나만 제공한다. 의존성은 최소이며 각 의존성을 명확히 정의한다. API는 명확하며 최소로 줄였다. 언어에 따라 필요한 모든 정보를 코드만으로 명확히 표현할 수 없기에 코드는 문학적으로 표현해야 마땅하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;가독성, 특히 고치기 쉬운 코드에 강조.&lt;/li&gt;
  &lt;li&gt;깨끗한 코드 === 태스트 케이스가 존재하는 코드 === 검증된 코드&lt;/li&gt;
  &lt;li&gt;코드는 작을수록 좋다.&lt;/li&gt;
  &lt;li&gt;인간이 읽기 쉬운 코드를 작성하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;마이클-페더스working-effectively-with-legacy-code의-저자&quot;&gt;마이클 페더스(Working Effectively with Legacy Code의 저자)&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;꺠긋한 코드의 특징은 많지만 그 중에서도 모두를 아우르는 특징이 하나 있다. &lt;strong&gt;깨긋한 코드는 언제나 누군가 주의 깊게 짰다는 느낌을 준다. 고치려고 살펴봐도 딱히 손댈 곳이 없다.&lt;/strong&gt; 작성자가 이미 모든 사항을 고려 했으므로. 고칠 궁리를 하다보면 언제나 제자리로 돌아온다. 그리고는 누군가 넘겨준 코드, 누군가 주의 깊게 짜놓은 작품에 감사를 느낀다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;클린한 코드는 주의 깊게 짜여진 코드이다. 이 책의 부재를 붙인다면 “코드를 주의깊게 짜는 방법”이라고 할수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;론-제프리스extreme-programming-installed와-extreme-programming-adventure-in-c의-저자특징-모든-플랫폼에서-모든-언어로-코드를-구현해본사람&quot;&gt;론 제프리스(Extreme Programming Installed와 Extreme Programming Adventure in C#의 저자:특징 모든 플랫폼에서 모든 언어로 코드를 구현해본사람.)&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;최근 들어 나는 켄드 백이 제안한 단순한 코드의 규칙으로 구현을 시작한다.(그리고 같은 규칙으로 구현을 거의 끝낸다.) 중요한 순으로 나열하자면 간단한 코드는&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;모든 테스트를 통과해야한다.&lt;/li&gt;
    &lt;li&gt;중복이 없다.&lt;/li&gt;
    &lt;li&gt;시스템 내 모든 설계 아이디어를 표현한다.&lt;/li&gt;
    &lt;li&gt;클래스, 메서드, 함수 등을 최대한 줄인다.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;물론 &lt;strong&gt;나는 주로 중복에 집중한다.&lt;/strong&gt; 같은 작업을 여러 차례 반복한다면 코드가 아이디어를 제대로 표현하지 못한다는 증거다. 나는 문제의 아이디어를 찾아내 좀더 명확하게 표현하려 애쓴다.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;내게 있어 표현력은 의미 있는 이름을 포함한다.&lt;/strong&gt; 보통 나는 확정하기 전에 이름을 여러 차례 바꾼다. 이클립스와 같은 최신 개발도구는 이름을 바꾸기가 상당히 쉽다. 그래서 별 고충 없이 이름을 바꾼다. 하지만 표현력은 이름에만 국한되지 않는다. 나는 여러 기능을 수행하는 객체나 메서드도 찾는다. 객체가 여러 기능을 수행한다면 여러 객체로 나눈다. 메서드가 여러 기능을 수행한다면 매서드 추출 리팩터링 기법을 적용해 기능을 명확히 기술하는 메서드 하나와 기능을 실제로 수행하는 메서드 여러 개로 나눈다.&lt;/p&gt;

  &lt;p&gt;중복과 표현력만 신경 써도 (내가 생각하는) 깨긋한 코드라는 목표에 성큼 다가선다. 지저분한 코드를 손볼 때 이 두 가지만 고려해도 코드가 크게 나아진다. 하지만 나는 한 가지를 더 고려한다. 이는 설명하기 조금 까다롭다.&lt;/p&gt;

  &lt;p&gt;오랜 경험 끝에 나는 모든 프로그램이 아주 유사한 요소로 이뤄진다는 사실을 깨달았다. 한 가지 예가 ‘집합에서 항목 찾기’다. 직원 정보가 저장된 데이터배이스든, 키/밸류 쌍이 저장된 해시 맵이던, 여러 값을 모아놓은 배열이든, 프로그램을 짜다 보면 어떤 집합에서 특정 항목을 찾아낼 필요가 자주 생긴다. 이런 상황이 발생하면 나는 추상 클래스나 추상 메서드를 만들어 실제 구현을 감싼다. 그러면 여러가지 장점이 생긴다.&lt;/p&gt;

  &lt;p&gt;이제 실제 기능은 아주 간단한 방식으로, 예를 들어 해시 맵으로, 구현해도 괜찮다. 다른 코드는 추상 클래스나 추상 매서드가 제공하는 기능을 사용하므로 실제 구현은 언제든지 바꿔도 괜찮다. 지금은 간단하게 재빨리 구현했다가 나중에 필요할 때 바꾸면 된다.&lt;/p&gt;

  &lt;p&gt;게다가 집합을 추상화하면 ‘진짜’문제에 신경 쓸 여유가 생긴다. 간단한 찾기 기능이 필요한데 온갖 집합 기능을 구현하느라 시간과 노력을 낭비할 필요가 없어진다.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;중복 줄이기,표현력 높이기,초반부터 간단한 추상화 고려하기. 내게는 이 세가지가 깨끗한 코드를 만드는 비결이다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;중복을 피하라. 한기능만 수행하라. 제대로 표현하라. 작게 추상화하라.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;워드-커닝햄위키-창시자-extreme-programmingxp-공동-창시자-smalltalk와-객체지향의-정신적-지도자&quot;&gt;워드 커닝햄(위키 창시자, eXtreme Programming[xp] 공동 창시자, smalltalk와 객체지향의 정신적 지도자.)&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다.&lt;/strong&gt; 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;깨긋한 코드는 읽으면서 놀라는 일이 없어야 한다. 코드를 독해 해야할 일이 없어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;저자로버트-c-마틴&quot;&gt;저자(로버트 C 마틴)&lt;/h4&gt;

&lt;p&gt;이 책은 &lt;strong&gt;오브젝트 멘토 진영이 생각하는 깨끗한 코드&lt;/strong&gt;를 설명한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;개발자는 저자이다.
    &lt;ul&gt;
      &lt;li&gt;개발자는 코드라는 글을 쓰는 저자이다. 글을 쓴다면 그 글을 읽는 “독자”가 존재한다.&lt;/li&gt;
      &lt;li&gt;개발을 하면서 우리는 새로운 코드를 작성하는 시간보다 기존코드를 읽는 시간이 훨씬 더 많다. (자신이 코딩하는 화면을 녹화해서 돌려본다면 이해할 것이다.)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;보이스카우트 규칙
    &lt;blockquote&gt;
      &lt;p&gt;“캠프장은 처음 왔을 때보다 더 깨긋하게 해놓고 떠나라.”&lt;/p&gt;
    &lt;/blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;git 커밋 전이나 소스를 저장하고 자리를 뜨기전에라도 소스를 한번 더 살펴보는 습관을 들이자.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프리퀄과 원칙
    &lt;ul&gt;
      &lt;li&gt;이 책은 저자(엉클 밥)의 책 Agile Software Development: Principles, Patterns, and Practices(PPP)의 프리퀄이다.&lt;/li&gt;
      &lt;li&gt;또한 &lt;a href=&quot;https://ko.wikipedia.org/wiki/SOLID&quot;&gt;SOLID 규칙&lt;/a&gt;을 산발 적으로 거론한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;결론
    &lt;ul&gt;
      &lt;li&gt;예술의 책을 읽는다고 좋은 예술가가 되지 않는다. &lt;strong&gt;연습하라!&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;2장-의미-있는-이름-변수&quot;&gt;2장 의미 있는 이름 (변수)&lt;/h1&gt;

&lt;p&gt;이 장에서 주로 전달하려는 정보는 &lt;strong&gt;이름을 잘 짓는 간단한 규칙&lt;/strong&gt;이다.&lt;/p&gt;

&lt;h3 id=&quot;의도를-분명히-밝혀라&quot;&gt;의도를 분명히 밝혀라&lt;/h3&gt;

&lt;p&gt;변수가 어떤 정보를 저장하는지를 명확히 하는 이름을 짓는 것을 말한다. 코드의 예로 이해를 돕는다. 아래의 코드는 같은 기능을 수행하는 코드이다.&lt;/p&gt;

&lt;h4 id=&quot;1번코드&quot;&gt;1번코드&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public List&amp;lt;int[]&amp;gt; getThem() {
    List&amp;lt;int[]&amp;gt; list1 = new ArrayList&amp;lt;int[]&amp;gt;();
    for (int{] x : theList})
        if (x[0] == 4)
            list1.add(x);
    return list1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2번코드&quot;&gt;2번코드&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; class Cell { ... }

 public List&amp;lt;Cell&amp;gt; getFlaggedCells() {
    List&amp;lt;Cell&amp;gt; flaggedCells = new ArrayList&amp;lt;Cell&amp;gt;();
    for (Cell cell : gameBoard)
        if(cell.isFlagged())
            flaggedCells.add(cell);
    return flaggedCell;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;그릇된-정보를-피하라&quot;&gt;그릇된 정보를 피하라&lt;/h3&gt;

&lt;p&gt;변수를 작성할 때 오해나 혼란을 줄수 있는 단어나 약어들을 사용하지 말아야한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;직각삼각형의 빗변(hypotenuse)을 hp로 줄여서 쓰는 방식은 hp의 의미를 떠오르게 하는데 많은 시간을 들게 함으로 사용시 주의해야한다.&lt;/li&gt;
  &lt;li&gt;변수의 자료형이 list가 아닌데 변수의 이름에 list를 붙이지 말것.&lt;/li&gt;
  &lt;li&gt;서로 흡사한 이름을 사용하지 말것.(ForEffecientHandlingOfString / ForEffecientStorageOfString 두 변수의 차이를 보자마자 구분할 수 있겠는가?)&lt;/li&gt;
  &lt;li&gt;변수 ‘l’과 ‘O’는 각각 1과 0을 연상하게 되므로 사용하지 말것을 권장한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;의미있게-구분하라&quot;&gt;의미있게 구분하라&lt;/h3&gt;

&lt;p&gt;읽는 사람이 각 변수의 차이를 알도록 계열의 변수들을 명명해야한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;불용어 (a1, a2등 아무 의미 없는 글자들)를 사용하지 말것.&lt;/li&gt;
  &lt;li&gt;쓸 때 없이 Info, Data 접미어를 쓰지 말것.(ProductInfo와 ProductData를 구분할 수 있겠는가?)&lt;/li&gt;
  &lt;li&gt;변수안에 예약어(class, string 등 언어가 지정한 키워드)를 사용하지 말 것.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;발음하기-쉬운-이름을-사용하라&quot;&gt;발음하기 쉬운 이름을 사용하라&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;genymdhms를 어떻게 읽은 것인가?&lt;/li&gt;
  &lt;li&gt;위의 변수를 generationTimestamp로 바꾸면 기억하거나 이해하기 더 쉽지 않겠는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;검색하기-쉬운-이름을-사용하라&quot;&gt;검색하기 쉬운 이름을 사용하라&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;기준이 되는 숫자는 상수를 지정해서 사용할 것.&lt;/li&gt;
  &lt;li&gt;변수이름을 최소한 단어로 지정 할 것. (로컬변수라면 상관 없을 수 있음.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;인코딩을-피하라&quot;&gt;인코딩을 피하라&lt;/h3&gt;

&lt;p&gt;피해야하는 인코딩 목록을 나열해본다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://namu.wiki/w/%ED%97%9D%EA%B0%80%EB%A6%AC%EC%95%88%20%ED%91%9C%EA%B8%B0%EB%B2%95&quot;&gt;헝가리식 표기법&lt;/a&gt; : 각 변수에 속성을 변수 앞 접두어로 표기하는 방법.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;맴버변수 접두어 : m_&lt;/p&gt;

    &lt;p&gt;public class Part {
      private String m_dsc; // String description
      void setName(String name){
          m_dsc = name;
      }
  }
—
  public class Part {
      String description;
      void setName(string description){
          this.description = description;
      }
  }&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;인터페이스 클래스와 구현 클래스 : 인터페이스 클래스에 굳이 접두어를 붙일필요 없이 그냥 클래스이름 규칙으로 명명 구현 클레스에 -Impl을 붙여주는 것이 적합.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;자신의-기억력을-자랑하지-마라&quot;&gt;자신의 기억력을 자랑하지 마라&lt;/h3&gt;

&lt;p&gt;똑똑한 프로그래머와 전문가 프로그래머 사이에서 나타나는 차이점 하나만 들자면, 전문가 프로그래머는 &lt;strong&gt;명료함이 최고&lt;/strong&gt;라는 사실을 이해한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;독자(코드를 보는사람)이 코드를 읽으면서 변수 이름을 자신이 아는 이름으로 다시 생각해야한다면 바람직 하지 않은 변수 이름이다.&lt;/li&gt;
  &lt;li&gt;문자 하나만 사용하는 변수는 for문의 i,j,k (l은 절대 안된다.)를 제외하고 문제갸 될 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;클래스-이름&quot;&gt;클래스 이름&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;클래스 이름과 객체 이름은 명사나 명사구가 적합하다.&lt;/strong&gt; Customer, WikiPage, Account, AddressParser 등이 좋은 예.&lt;/li&gt;
  &lt;li&gt;Manager, Processer, Data, Info 등과 같은 단어를 피하고 &lt;strong&gt;동사를 사용하지 않는다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;메서드-이름&quot;&gt;메서드 이름&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;메서드 이름은 동사나 동사구가 적합하다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;접근자, 변경자, 조건자는 &lt;a href=&quot;http://www.oracle.com/technetwork/articles/javaee/spec-136004.html&quot;&gt;javabean 표준&lt;/a&gt;에 따라 get, set, is를 붙인다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;기발한-이름은-피하라&quot;&gt;기발한 이름은 피하라.&lt;/h3&gt;

&lt;p&gt;명확한 정보만 담을 것. 코드에 당신의 재치와 재미를 넣지 말 것.&lt;/p&gt;

&lt;h3 id=&quot;한-개념에-한-단어를-사용하라&quot;&gt;한 개념에 한 단어를 사용하라&lt;/h3&gt;

&lt;p&gt;추상적인 개념 하나에 단어 하나를 선택해서 고수한다. 일관성 있는 어휘는 코드를 사용할 프로그래머가 반갑게 여길 선물이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;똑같은 메서드를 각각의 클래스에서 fetch, retrieve, get으로 제각각 부르면 혼동이 올 수 있다.&lt;/li&gt;
  &lt;li&gt;동일 코드 기반에 controller, manager, driver를 섞어서 쓰면 혼동이 올 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;말장난을-하지-마라&quot;&gt;말장난을 하지 마라&lt;/h3&gt;

&lt;p&gt;한 단어를 두 가지 목적으로 사용하지 마라.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;add를 두 가지 값을 받아 합쳐 하나의 값으로 변환하는 메서드라고 했을 떄 하나의 집합과 하나의 요소를 합쳐 하나의 값으로 변환하는 개념은 add 보다는 insert나 append가 더 정확한 명명이 될 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-영역에서-가져운-이름을-사용하라&quot;&gt;해법 영역에서 가져운 이름을 사용하라&lt;/h3&gt;

&lt;p&gt;코드를 읽을 사람은 프로그래머이다. 프로그래머 영역에서 사용되는 단어가 더 정확한 뜻을 전달한다면 그 용어를 사용하는 것이 좀더 바람직 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;문제-영역에서-가저온-이름을-사용하라&quot;&gt;문제 영역에서 가저온 이름을 사용하라&lt;/h3&gt;

&lt;p&gt;적절한 ‘프로그래머 용어’가 없다면 문제 영역에서 이름을 가져온다. 문제 영역 개념과 관련이 깊은 코드라면 문제 영역에서 이름을 가져와야 한다.&lt;/p&gt;

&lt;h3 id=&quot;의미-있는-맥락을-추가하라&quot;&gt;의미 있는 맥락을 추가하라&lt;/h3&gt;

&lt;p&gt;스스로 의미가 분명한 이름이 없지 않지만 대다수 이름이 의미가 분명하지 않은 경우가 많다. 그래서 클래스,함수, 네임스페이스에 넣어(묶어) 맥락을 부여한다. 마지막 방법으로 접두어를 붙인다.&lt;/p&gt;

&lt;h3 id=&quot;불필요한-맥락을-없애라&quot;&gt;불필요한 맥락을 없애라&lt;/h3&gt;

&lt;p&gt;일반적으로는 짧은 이름이 긴 이름보다 좋다. 단, 의미가 분명한 경우에 한해서다. 할일(todo) 앱을 만든다고 해서 모든 클래스에 TODO라는 접두어를 붙일 필요는 없다.&lt;/p&gt;
</description>
        <pubDate>Sat, 07 Jan 2017 00:00:00 +0000</pubDate>
        <link>http://nGeniuskr.github.io/2017/01/07/clean-code-book-report-part1.html</link>
        <guid isPermaLink="true">http://nGeniuskr.github.io/2017/01/07/clean-code-book-report-part1.html</guid>
        
        
      </item>
    
      <item>
        <title>홈페이지 리뉴얼?</title>
        <description>&lt;p&gt;부트스트랩을 적용시켜봤습니다.&lt;/p&gt;

&lt;p&gt;하하.. 이 게으른 녀석 ㅠ&lt;/p&gt;

&lt;p&gt;글을 1주에 하나 이상 올리도록 노력해봐야겠습니다.&lt;/p&gt;

&lt;p&gt;그럼..&lt;/p&gt;
</description>
        <pubDate>Sat, 31 Dec 2016 04:00:14 +0000</pubDate>
        <link>http://nGeniuskr.github.io/2016/12/31/renewal.html</link>
        <guid isPermaLink="true">http://nGeniuskr.github.io/2016/12/31/renewal.html</guid>
        
        
      </item>
    
      <item>
        <title>React.js를 하기 전에 알아야 할 정보들</title>
        <description>&lt;p&gt;react.js를 공부해보려 사전정보 입수를 위해 구글을 이용해 정보를 찾아서 정리해봅니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;reactjs&quot;&gt;&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React.js&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;facebook에서 주도하고 있는 오픈소스 프로젝트로, facebook과 instagram에 사용되고 있습니다.&lt;/p&gt;

&lt;p&gt;react의 가장 큰 특징은 MVC 페턴에서 V(View) 즉, 화면을 표현하는 부분만 구현하는 라이브러리 입니다.&lt;/p&gt;

&lt;p&gt;MVC 패턴 중 View의 역활만 하기 때문에 Model과 Controller의 역활을 하는 부분을 따로 구현할 수 있습니다.&lt;/p&gt;

&lt;h5 id=&quot;참고문헌&quot;&gt;참고문헌&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://webframeworks.kr/tutorials/react/getting-started/&quot;&gt;react.js 시작하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.bloter.net/archives/233564&quot;&gt;블로터:페이스북의 인기 오픈소스 기술, ‘리액트’란?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;browserify와-webpack&quot;&gt;&lt;a href=&quot;http://browserify.org/&quot;&gt;browserify&lt;/a&gt;와 &lt;a href=&quot;https://webpack.github.io/&quot;&gt;webpack&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;React.js는 만들어 진지 얼마 안된 라이브러리입니다. 그래서 최신기술을 많이 적용 되어있는데&lt;/p&gt;

&lt;p&gt;ES6(ES2015)를 제대로 사용하기 위해 Module builder가 필요하고&lt;/p&gt;

&lt;p&gt;Module builder중 가장 많이 쓰이는 것이 Webpack과 browserify 입니다.&lt;/p&gt;

&lt;p&gt;Module builder를 소개하기 전에 Module에 대해서 설명하자면&lt;/p&gt;

&lt;p&gt;Module은 어떤 하나의 특화된 기능을 하주 잘 수행하는 어떤 독립된 집합체 이며&lt;/p&gt;

&lt;p&gt;대표적으로 jQuery를 들수 있습니다.&lt;/p&gt;

&lt;p&gt;검색을 어느정도 해본결과 react.js는 주로 webpack을 사용하는 경우가 많았으니 참고하시기 바랍니다.&lt;/p&gt;

&lt;h5 id=&quot;참고문헌-1&quot;&gt;참고문헌&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.coderifleman.com/post/112564054684/browserify와-webpack&quot;&gt;browserify와 webpack&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://appletree.or.kr/blog/web-development/javascript/modules-앞으로-javascript-라이브러리가-나아갈-길/&quot;&gt;Modules, 앞으로 JavaScript 라이브러리가 나아갈 길&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://d2.naver.com/helloworld/0239818&quot;&gt;JavaScript 모듈화 도구, webpack&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;es2015es6&quot;&gt;&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ES2015(ES6)&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;JavaScript는 ECMAScript(ECMA262)라는 사양을 기반으로 구현되어있습니다.&lt;/p&gt;

&lt;p&gt;현재 모던한 Web 브라우저는 ECMAScript 5.1th Edition을 기반으로 한 JavaScript실행 엔진을 탑재하고 있습니다.&lt;/p&gt;

&lt;p&gt;그리고 다음 버전인 ECMAScript 6th Edition이 현재 재정중으로, 약칭으로 ES6이라는 명칭이 사용되고 있습니다.&lt;/p&gt;

&lt;p&gt;ES2015라고 불리우는 이유는 2015년에 만들어졌기 때문입니다.&lt;/p&gt;

&lt;p&gt;ES6의 경우 ES5를 사용하면서 불편했던 부분이 많이 해소 되었으며, 최근 모던한 브라우저들에서 지원을 하고 있습니다.&lt;/p&gt;

&lt;h5 id=&quot;참고문헌-2&quot;&gt;참고문헌&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/marocchino/841e2ff62f59f420f9d9&quot;&gt;ES6시대의 JavaScript&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://seokjun.kr/ecmascript-6-features/&quot;&gt;ECMAScript 6 Features&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;babal&quot;&gt;&lt;a href=&quot;https://babeljs.io&quot;&gt;Babal&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Node.js는 어느 정도 ES2015의 지원하고 있지만 웹 브라우저 같은 경우는 ES2015를 모두 지원하는 것은&lt;/p&gt;

&lt;p&gt;아니므로 ES2015로 코드를 작성하면 코드를 트랜스파일 해서 ES5 코드로 바꾸어야 실제로 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;JavaScript에서는 CoffeeScript처럼 비슷한 부류의 언어를 JavaScript로 바꾸는 것을 트랜스파일이라고&lt;/p&gt;

&lt;p&gt;부르고 있고 ES2015의 트랜스파일러(transpiler)로는 구글이 만든 Traceur와 &lt;a href=&quot;https://babeljs.io&quot;&gt;Babel&lt;/a&gt;이 있다.&lt;/p&gt;

&lt;h5 id=&quot;참고문헌-3&quot;&gt;참고문헌&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.outsider.ne.kr/1176&quot;&gt;Babel로 ECMAScript 2015 사용하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://haruair.com/blog/2917&quot;&gt;ECMAScript 6를 위한 Babel 기본 사용법&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://babeljs.io/docs/learn-es2015/&quot;&gt;Learn ES2015 with babal&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;meteorjs&quot;&gt;&lt;a href=&quot;https://www.meteor.com&quot;&gt;Meteor.js&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Meteor는 모던 웹과 모던 어플리케이션을 위한 Full-stack 자바스크립트 플랫폼이라고 정의 되어있습니다.&lt;/p&gt;

&lt;p&gt;Meteor는 javascript 단 하나의 언어를 이용하여 모든 환경(어플리케이션 서버, 웹 서버, 모바일 기기)을&lt;/p&gt;

&lt;p&gt;개발할 수 있다는 점이 가장 큰 장점입니다.&lt;/p&gt;

&lt;h5 id=&quot;참고문헌-4&quot;&gt;참고문헌&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://webframeworks.kr/getstarted/meteorjs/&quot;&gt;Meteor.js 시작하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://mobicon.tistory.com/466&quot;&gt;Meteor 배우는 방법&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;flux&quot;&gt;&lt;a href=&quot;http://facebook.github.io/flux/&quot;&gt;flux&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Flux는 Facebook에서 클라이언트-사이드 웹 어플리케이션을 만들기 위해 사용하는 어플리케이션 아키텍쳐입니다.&lt;/p&gt;

&lt;p&gt;단방향 데이터 흐름을 활용해 뷰 컴포넌트를 구성하는 React를 보완하는 역할을 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://haruair.github.io/flux/img/flux-simple-f8-diagram-explained-1300w.png&quot; alt=&quot;flux 구조 설명&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Flux는 MVC와 다르게 단방향으로 데이터가 흐릅니다. React view에서 사용자가 상호작용을 할 때,&lt;/p&gt;

&lt;p&gt;그 view는 중앙의 dispatcher를 통해 action을 전파하게 됩니다.&lt;/p&gt;

&lt;p&gt;어플리케이션의 데이터와 비지니스 로직을 가지고 있는 store는 action이 전파되면&lt;/p&gt;

&lt;p&gt;이 action에 영향이 있는 모든 view를 갱신한다. 이 방식은 특히 React의 선언형 프로그래밍 스타일&lt;/p&gt;

&lt;p&gt;즉, view가 어떤 방식으로 갱신해야 되는지 일일이 작성하지 않고서도 데이터를 변경할 수 있는 형태에서 편리합니다.&lt;/p&gt;

&lt;h5 id=&quot;참고문헌-5&quot;&gt;참고문헌&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://haruair.github.io/flux/docs/overview.html&quot;&gt;flux Overview&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 02 Jul 2016 00:00:00 +0000</pubDate>
        <link>http://nGeniuskr.github.io/2016/07/02/before-learning-reactjs.html</link>
        <guid isPermaLink="true">http://nGeniuskr.github.io/2016/07/02/before-learning-reactjs.html</guid>
        
        
      </item>
    
  </channel>
</rss>
