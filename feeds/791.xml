<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
<title>Epic Developer</title>
<link>https://epicdevs.com/</link>
<description></description>
<language>ko</language>
<pubDate>Mon, 13 May 2019 04:27:31 +0900</pubDate>
<generator>TISTORY</generator>
<managingEditor>epicdev</managingEditor>
<item>
<title>[Apache Kafka] 5. Zookeeper 트리 분석</title>
<link>https://epicdevs.com/23</link>
<description>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://cfs.tistory.com/custom/blog/154/1543390/skin/images/epicdevs-mobile.css&quot;&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Kafka 클러스터의 모든 분산 처리는 Zookeeper를 매개로 이루어 지기 때문에, Kafka가 사용하는 Zookeeper 트리의 구조를 파악하면 Kafka 클러스터의 동작 방식을 이해하는데 큰 도움이 된다. 아래의 그림은 Kafka가 사용하는 Zookeeper 트리의 주요 노드를 정리해 놓은 것이다. 좀 더 상세한 정보는 Kafka Wiki의 &lt;a href=&quot;https://cwiki.apache.org/confluence/display/KAFKA/Kafka+data+structures+in+Zookeeper&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Kafka data structures in Zookeeper&lt;/a&gt;를 참조하길 바란다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:850px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/2177DE435509538433&quot; filemime=&quot;image/jpeg&quot; filename=&quot;tree.png&quot; height=&quot;1169&quot; style=&quot;&quot; width=&quot;850&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;Zookeeper CLI로 Zookeeper 트리 탐색하기&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Zookeeper 트리는 파일 시스템의 디렉토리 구조와 비슷하기 때문에 Zookeeper 패키지에 포함되어 있는 &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;zkCli.sh&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;라는 CLI 툴을 사용하여 디렉토리를 탐색하듯이 ls 명령어를 통해 Zookeeper 트리를 탐색할 수 있다. (Kafka 패키지에도 이와 비슷한 &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;zookeeper-shell.sh&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;가 들어있는데 자동 완성이나 히스토리 기능이 제공되지 않으므로 이를 제공하는 &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;zkCli.sh&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;를 사용하는 것을 권장한다.)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;우선 아래의 커맨드를 통해 Zookeeper에 접속한다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;bin/zkCli.sh -server kafka-test-001.epicdevs.com:2181&lt;/span&gt;&lt;font face=&quot;돋움&quot;&gt;&lt;span style=&quot;white-space: normal; font-size: 11pt;&quot;&gt;
&lt;/span&gt;&lt;/font&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Zookeeper에 접속하게 되면 여러가지 명령어를 통해 트리 탐색 및 조작이 가능하다. help 명령어를 사용하면 전체 명령어 리스트를 확인할 수 있다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;간단하게는 ls 명령어를 사용하면 트리의 노드를 탐색할 수 있고, get 명령어를 사용하면 노드에 저장된 값을 읽어올 수 있다(위 그림의 사각형 노드).&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;예를 들어&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;ls /brokers/ids&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;를 입력하면&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;[3, 2, 1]&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;라는 broker ID에 해당하는 하위 노드 리스트가 출력되고&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;get /consumers/test-group/offsets/test/0&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;를 입력하면&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;2574&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;라는 offset 값이 출력된다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;zkCli.sh&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;에 대한 상세한 가이드는 &lt;/span&gt;&lt;a href=&quot;http://zookeeper.apache.org/doc/trunk/zookeeperStarted.html#sc_ConnectingToZooKeeper&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;ZooKeeper Getting Started Guide&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;를 참조하길 바란다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;참고자료&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul style=&quot;list-style-type: disc;&quot;&gt;&lt;li&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;/span&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/KAFKA/Kafka+data+structures+in+Zookeeper&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Kafka data structures in Zookeeper&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>Programming Insight</category>
<category>kafka</category>
<category>메시지 큐</category>
<category>메시징 시스템</category>
<category>미들웨어</category>
<category>카프카</category>
<author>epicdev</author>
<guid>https://epicdevs.com/23</guid>
<comments>https://epicdevs.com/23#entry23comment</comments>
<pubDate>Wed, 18 Mar 2015 19:31:55 +0900</pubDate>
</item>
<item>
<title>[Apache Kafka] 4. 모니터링하기</title>
<link>https://epicdevs.com/22</link>
<description>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://cfs.tistory.com/custom/blog/154/1543390/skin/images/epicdevs-mobile.css&quot;&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: Dotum, 돋움;&quot;&gt;Kafka는 기본적으로 JMX 인터페이스를 제공하기 때문에 Kafka에서 제공하는 MBean(managed bean)들의 값을 모니터링할 수 있다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5; font-family: Dotum, 돋움;&quot;&gt;하지만 JMX 툴보다는 Kafka 전용으로 개발된 모니터링 툴을 사용하는 것이 훨씬 간편하고, 중요한 정보들을 좀 더 직관적으로 파악할 수 있기 때문에&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt; font-family: Dotum, 돋움;&quot;&gt;이 글에서는 JMX를 통한 모니터링 대신 &lt;/span&gt;&lt;a href=&quot;http://quantifind.github.io/KafkaOffsetMonitor/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt; font-family: Dotum, 돋움;&quot;&gt;Kafka Offset Monitor&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt; font-family: Dotum, 돋움;&quot;&gt;를 사용하여 Kafka의 상태를 모니터링해 보도록 한다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt; font-family: Dotum, 돋움;&quot;&gt;Kafka Offset Monitor 실행하기&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;a href=&quot;http://quantifind.github.io/KafkaOffsetMonitor/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt; font-family: Dotum, 돋움;&quot;&gt;Kafka Offset Monitor 홈페이지&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt; font-family: Dotum, 돋움;&quot;&gt;에서 jar 파일을 다운 받은 뒤 다음의 커맨드를 통해 Kafka Offset Monitor를 실행한다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;span style=&quot;font-size: 11pt; font-family: Dotum, 돋움;&quot;&gt;java -cp KafkaOffsetMonitor-assembly-0.2.1.jar com.quantifind.kafka.offsetapp.OffsetGetterWeb \
--zk kafka-test-001.epicdevs.com:2181,kafka-test-002.epicdevs.com:2181,kafka-test-003.epicdevs.com:2181 \
--port 8080 --refresh 10.seconds --retain 2.days&lt;/span&gt;&lt;font face=&quot;돋움&quot;&gt;&lt;span style=&quot;white-space: normal; font-size: 11pt; font-family: Dotum, 돋움;&quot;&gt;
&lt;/span&gt;&lt;/font&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; font-family: Dotum, 돋움;&quot;&gt;웹 브라우저로 http://localhost:port에 접속하면 각 topic의 처리 현황, broker와 consumer 현황, Kafka 클러스터 현황 등을 살펴볼 수 있다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:850px;text-align: center; font-size: 9pt; line-height: 1.5;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/2216A04055094FAD2A&quot; filemime=&quot;image/jpeg&quot; filename=&quot;monitor.png&quot; height=&quot;727&quot; style=&quot;text-align: center; font-size: 9pt; line-height: 1.5;&quot; width=&quot;850&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt; font-family: Dotum, 돋움;&quot;&gt;참고자료&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul style=&quot;list-style-type: disc;&quot;&gt;&lt;li&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/KAFKA/Ecosystem&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt; font-family: Dotum, 돋움;&quot;&gt;Kafka Ecosystem&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://quantifind.github.io/KafkaOffsetMonitor/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt; font-family: Dotum, 돋움;&quot;&gt;Kafka Offset Monitor&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>Programming Insight</category>
<category>kafka</category>
<category>메시지 큐</category>
<category>메시징 시스템</category>
<category>미들웨어</category>
<category>카프카</category>
<author>epicdev</author>
<guid>https://epicdevs.com/22</guid>
<comments>https://epicdevs.com/22#entry22comment</comments>
<pubDate>Wed, 18 Mar 2015 19:18:57 +0900</pubDate>
</item>
<item>
<title>[Apache Kafka] 3. Producer/Consumer 구현하기</title>
<link>https://epicdevs.com/21</link>
<description>&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://cfs.tistory.com/custom/blog/154/1543390/skin/images/epicdevs-mobile.css&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;Kafka는 producer와 consumer를 구현할 때 사용할 수 있는 Java 클라이언트를 공식적으로 제공한다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5; font-family: Dotum, 돋움;&quot;&gt;그 외에도 서드파티에서 C, C++, Ruby, Python, Go를 비롯한 &lt;/span&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/KAFKA/Clients&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot; style=&quot;font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;다양한 언어의 클라이언트&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5; font-family: Dotum, 돋움;&quot;&gt;를 제공한다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5; font-family: Dotum, 돋움;&quot;&gt;이 글에서는 Java 클라이언트를 사용하는 법을 다룬다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5; font-family: Dotum, 돋움;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;Producer 구현하기&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14pt; line-height: 1.5; font-family: Dotum, 돋움;&quot;&gt;Hello, World! 예제&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint linenums&quot;&gt;&lt;p&gt;&lt;font face=&quot;Dotum, 돋움&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;package com.epicdevs.kafka;

import java.util.Properties;

import kafka.javaapi.producer.Producer;
import kafka.producer.KeyedMessage;
import kafka.producer.ProducerConfig;

public class ProducerExample {

    public static void main(String[] args) throws Exception {
        Properties props = new Properties();
        props.put(&quot;metadata.broker.list&quot;, &quot;kafka-test-001.epicdevs.com:9092,kafka-test-002.epicdevs.com:9092,kafka-test-003.epicdevs.com:9092&quot;);
        props.put(&quot;serializer.class&quot;, &quot;kafka.serializer.StringEncoder&quot;);

        ProducerConfig producerConfig = new ProducerConfig(props);
        Producer&amp;lt;String, String&amp;gt; producer = new Producer&amp;lt;String, String&amp;gt;(producerConfig);

        KeyedMessage&amp;lt;String, String&amp;gt; message = new KeyedMessage&amp;lt;String, String&amp;gt;(&quot;test&quot;, &quot;Hello, World!&quot;);  
        producer.send(message);
        producer.close();
    }
}&lt;/span&gt;&lt;/font&gt;&lt;font face=&quot;돋움&quot;&gt;&lt;span style=&quot;white-space: normal; font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;
&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;위의 예제는 &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;test&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;라는 topic에 &quot;Hello, World&quot;라는 메시지를 보내는 코드이다.&amp;nbsp;&lt;/span&gt;&lt;b style=&quot;font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;ProducerConfig&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5; font-family: Dotum, 돋움;&quot;&gt;를 생성할 때 설정할 수 있는 프로퍼티들은 다음 절에서 다룬다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5; font-family: Dotum, 돋움;&quot;&gt;Kafka producer API에서는 한꺼번에 여러 메시지를 전송할 수 있는 API 또한 제공한다. 해당 API를 적절히 사용하면 producer의 처리량을 늘릴 수 있다. 아래는 &quot;Hello, World!&quot; 메시지 10개를 한 번에 전송하는 예제이다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;span style=&quot;font-size: 11pt; font-family: Dotum, 돋움;&quot;&gt;List&amp;lt;KeyedMessage&amp;lt;String, String&amp;gt;&amp;gt; messages = new ArrayList&amp;lt;KeyedMessage&amp;lt;String, String&amp;gt;&amp;gt;();
for (int i = 0; i &amp;lt; 10; i++) {
    messages.add(new KeyedMessage&amp;lt;String, String&amp;gt;(&quot;test&quot;, &quot;Hello, World!&quot;));
}
producer.send(messages);
&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 14pt;&quot;&gt;필수 프로퍼티&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;table class=&quot;txc-table&quot; width=&quot;814&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; border=&quot;0&quot; style=&quot;border:none;border-collapse:collapse;;font-family:돋움;font-size:12px&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;width: 131px; height: 24px; border: 1px solid rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: rgb(230, 230, 230);&quot;&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&amp;nbsp;프로퍼티&amp;nbsp;&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 682px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-top-width: 1px; border-top-style: solid; border-top-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: rgb(230, 230, 230);&quot;&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;설명&amp;nbsp;&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 131px; height: 123px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&amp;nbsp;metadata.broker.list&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 682px; height: 123px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;메타데이터를 받아 올 Kafka broker 리스트. &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;호스트1:포트1,호스트2:포트2,호스트3:포트3&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;의 형태로 명시한다.&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;예) kafka-test-001.epicdevs.com:9092,kafka-test-002.epicdevs.com:9092,kafka-test-003.epicdevs.com:9092&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt; line-height: 1.5; background-color: transparent;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt; line-height: 1.5; background-color: transparent;&quot;&gt;여기서 명시하는 broker는 메타데이터를 받아오는 데만 사용하고, 실제 메시지를 전송할 때에는 메타데이터를 기반으로 새로운 connection을 맺은 다음 메시지를 전송한다. 따라서 이 리스트에는 전체 broker 중 일부만 명시해도 무관하다.&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 14pt;&quot;&gt;중요 프로퍼티&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;table class=&quot;txc-table&quot; width=&quot;814&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; border=&quot;0&quot; style=&quot;border:none;border-collapse:collapse;;font-family:돋움;font-size:12px&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;width: 174px; height: 24px; border: 1px solid rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: rgb(230, 230, 230);&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;프로퍼티&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 189px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-top-width: 1px; border-top-style: solid; border-top-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: rgb(230, 230, 230);&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&amp;nbsp;기본 값&amp;nbsp;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 452px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-top-width: 1px; border-top-style: solid; border-top-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: rgb(230, 230, 230);&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;설명&amp;nbsp;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 174px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&amp;nbsp;serializer.class&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 189px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&amp;nbsp;kafka.serializer.DefaultEncoder&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 452px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;메시지를 serialize할 때 사용하는 인코더. &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;DefaultEncoder&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;는 byte[]를 받아서 그대로 전달한다.&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 174px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&amp;nbsp;key.serializer.class&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 189px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&amp;nbsp;serializer.class의 값과 동일&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 452px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;메시지 키를 serialize할 때 사용하는 인코더.&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 174px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&amp;nbsp;partitioner.class&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 189px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&amp;nbsp;kafka.producer.DefaultPartitioner&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 452px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;메시지를 어떤 partition에 전송할지 결정하는 클래스. &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;DefaultPartitioner&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;는 메시지 키의 해시 코드를 기반으로 메시지를 전송할 partition을 결정한다. 메시지 키를 명시하지 않았거나 null 값을 키로 전달할 경우 사용자가 명시한 &lt;/span&gt;&lt;i&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;partitioner.class&lt;/span&gt;&lt;/i&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;를 무시하고 임의의 partition에 메시지를 보내게 된다. 이 때문에 특정 상황에서 전체 partition에 메시지가 제대로 분산되지 않는 현상이 발생할 수 있다. 이에 대한 자세한 사항은 Kafka FAQ의 &lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/KAFKA/FAQ#FAQ-Whyisdatanotevenlydistributedamongpartitionswhenapartitioningkeyisnotspecified?&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;Why is data not evenly distributed among partitions when a partitioning key is not specified?&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;를 참조하길 바란다.&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 174px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&amp;nbsp;request.required.acks&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 189px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&amp;nbsp;0&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 452px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;Producer가 전송한 메시지가 몇 개의 replica에 commit되어야 ack처리(성공적으로 전송된 것으로 간주)를 하는지 결정하는 기준.&lt;/span&gt;&lt;/p&gt;&lt;ul style=&quot;list-style-type: disc;&quot;&gt;&lt;li&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;0: producer는 broker로부터 ack를 기다리지 않고 메시지 전송이 끝나자마자 성공된 것으로 간주한다. 응답 시간은 가장 빠르지만 broker에서 오류가 발생할 경우 메시지가 유실된다.&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;1: leader를 맡고있는 replica에 메시지가 commit되면 ack처리를 한다.&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;N: N개의 replica에 메시지가 commit되면 ack처리를 한다.&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;-1: 모든 replica에 메시지가 commit되면 ack처리를 한다. &lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 174px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&amp;nbsp;compression.codec&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 189px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&amp;nbsp;none&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 452px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;메시지를 압축할 때 사용할 코덱. &lt;/span&gt;&lt;i&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;none&lt;/span&gt;&lt;/i&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;, &lt;/span&gt;&lt;i&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;gzip&lt;/span&gt;&lt;/i&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;, &lt;/span&gt;&lt;i&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;snappy&lt;/span&gt;&lt;/i&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt; 중 하나를 선택할 수 있다. &lt;/span&gt;&lt;i&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;none&lt;/span&gt;&lt;/i&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;을 선택하면 메시지를 압축하지 않는다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 174px; height: 127px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&amp;nbsp;producer.type&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 189px; height: 127px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&amp;nbsp;sync&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 452px; height: 127px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;Producer가 메시지를 동기적으로 전송할지 비동기적으로 전송할지에 대한 설정. 동기적으로 전송하려면 &lt;/span&gt;&lt;i&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;sync&lt;/span&gt;&lt;/i&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;로 명시하고 비동기적으로 전송하려면 &lt;/span&gt;&lt;i&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;async&lt;/span&gt;&lt;/i&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;로 명시한다. 비동기 producer를 사용할 경우 메시지를 일정 시간 큐에 쌓아 두었다가 한 번에 전송하므로 producer의 메시지 처리량을 향상시킬 수 있다. 단, 장애가 발생할 경우 전송하지 않고 쌓아 둔 메시지가 유실될 우려가 있다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 174px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&amp;nbsp;queue.buffering.max.ms&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 189px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&amp;nbsp;5000&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 452px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;비동기 producer를 사용할 경우 몇 ms동안 메시지를 모아둘지 결정하는 값. 비동기 &lt;/span&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;producer&lt;/span&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;는&lt;i&gt; queue.buffering.max.ms&lt;/i&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt; 값에 도달하거나 &lt;/span&gt;&lt;i&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;batch.num.messages&lt;/span&gt;&lt;/i&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt; 값에 도달할 경우 쌓아두었던 메시지를 전송한다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 174px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&amp;nbsp;batch.num.messages&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 189px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&amp;nbsp;200&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 452px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;비동기 producer를 사용할 경우 최대 몇 개의 메시지를 모아둘지 결정하는 값. 비동기 producer는 &lt;/span&gt;&lt;i&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;queue.buffering.max.ms&lt;/span&gt;&lt;/i&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt; 값에 도달하거나 &lt;/span&gt;&lt;i&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;batch.num.messages&lt;/span&gt;&lt;/i&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt; 값에 도달할 경우 쌓아두었던 메시지를 전송한다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;위에서 언급한 필수 프로퍼티와 중요 프로퍼티 외의 항목들은 Kafka 공식 페이지의 &lt;/span&gt;&lt;a href=&quot;http://kafka.apache.org/081/documentation.html#producerconfigs&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot; style=&quot;font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;3.3 Producer Configs&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;를 참고하길 바란다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;라운드 로빈 Partitioner 예제&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;아래는 라운드 로빈 방식으로 동작하는 partitioner를 직접 구현한 예시이다. 코드를 보면 직접 구현한 &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;RoundRobinPartitioner&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;를 &lt;/span&gt;&lt;i&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;partitioner.class&lt;/span&gt;&lt;/i&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt; 프로퍼티로 지정한 것을 확인할 수 있다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;KeyedMessage&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;를 생성할 때 메시지 키를 명시하지 않으면 &lt;/span&gt;&lt;i&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;partitioner.class&lt;/span&gt;&lt;/i&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;에 입력된 값을 무시하기 때문에 공백 값을 메시지 키로 전달하여 &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;RoundRobinPartitioner&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;가 사용되도록 하였다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint linenums&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;package com.epicdevs.kafka;

import java.util.Properties;
import java.util.concurrent.atomic.AtomicInteger;

import kafka.javaapi.producer.Producer;
import kafka.producer.KeyedMessage;
import kafka.producer.Partitioner;
import kafka.producer.ProducerConfig;
import kafka.utils.VerifiableProperties;

public class RoundRobinProducerExample {

    public static void main(String[] args) throws Exception {
        Properties props = new Properties();
        props.put(&quot;metadata.broker.list&quot;, &quot;kafka-test-001.epicdevs.com:9092,kafka-test-002.epicdevs.com:9092,kafka-test-003.epicdevs.com:9092&quot;);
        props.put(&quot;serializer.class&quot;, &quot;kafka.serializer.StringEncoder&quot;);
        props.put(&quot;partitioner.class&quot;, RoundRobinPartitioner.class.getName());

        ProducerConfig producerConfig = new ProducerConfig(props);
        Producer&amp;lt;String, String&amp;gt; producer = new Producer&amp;lt;String, String&amp;gt;(producerConfig);

        KeyedMessage&amp;lt;String, String&amp;gt; message = new KeyedMessage&amp;lt;String, String&amp;gt;(&quot;test&quot;, &quot;&quot;, &quot;Hello, World!&quot;);  
        producer.send(message);
        producer.close();
    }

    public static class RoundRobinPartitioner implements Partitioner {

        private AtomicInteger n = new AtomicInteger(0);

        public RoundRobinPartitioner(VerifiableProperties props) {
        }

        @Override
        public int partition(Object key, int numPartitions) {
            int i = n.getAndIncrement();
            if (i == Integer.MAX_VALUE) {
                n.set(0);
                return 0;
            }
            return i % numPartitions;
        }
    }
}
&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;Consumer 구현하기&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Kafka에서는 consumer 구현에 사용할 수 있는 두 종류의 API를 제공한다. 세부적인 것들은 모두 추상화되어 있어 몇 번의 간단한 함수 호출로 consumer를 구현할 수 있는 &lt;/span&gt;&lt;a href=&quot;http://kafka.apache.org/081/documentation.html#highlevelconsumerapi&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;High Level Consumer API&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;와 offset과 같은 세부적인 부분까지 다룰 수 있지만 이 때문에 구현하기가 상당히 까다로운 &lt;/span&gt;&lt;a href=&quot;http://kafka.apache.org/081/documentation.html#simpleconsumerapi&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Simple Consumer API&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;가 제공된다(이름은 simple이지만 전혀 simple하지 않다).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;이 글에서는 high level consumer API를 사용한 예시만을 다룬다. Simple level consumer API의 구현 예시는 Kafka Wiki의 &lt;/span&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/KAFKA/0.8.0+SimpleConsumer+Example&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;0.8.0 SimpleConsumer Example&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;을 참조하길 바란다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;High Level Consumer API 예제&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint linenums&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;package com.epicdevs.kafka;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import kafka.consumer.Consumer;
import kafka.consumer.ConsumerConfig;
import kafka.consumer.KafkaStream;
import kafka.javaapi.consumer.ConsumerConnector;
import kafka.message.MessageAndMetadata;

public class ConsumerExample {

    private static final String TOPIC = &quot;test&quot;;
    private static final int NUM_THREADS = 20;

    public static void main(String[] args) throws Exception {
        Properties props = new Properties();
        props.put(&quot;group.id&quot;, &quot;test-group&quot;);
        props.put(&quot;zookeeper.connect&quot;, &quot;kafka-test-001.epicdevs.com:2181,kafka-test-002.epicdevs.com:2181,kafka-test-003.epicdevs.com:2181&quot;);
        props.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;);

        ConsumerConfig consumerConfig = new ConsumerConfig(props);
        ConsumerConnector consumer = Consumer.createJavaConsumerConnector(consumerConfig);

        Map&amp;lt;String, Integer&amp;gt; topicCountMap = new HashMap&amp;lt;String, Integer&amp;gt;();
        topicCountMap.put(TOPIC, NUM_THREADS);

        Map&amp;lt;String, List&amp;lt;KafkaStream&amp;lt;byte[], byte[]&amp;gt;&amp;gt;&amp;gt; consumerMap = consumer.createMessageStreams(topicCountMap);
        List&amp;lt;KafkaStream&amp;lt;byte[], byte[]&amp;gt;&amp;gt; streams = consumerMap.get(TOPIC);

        ExecutorService executor = Executors.newFixedThreadPool(NUM_THREADS);

        for (final KafkaStream&amp;lt;byte[], byte[]&amp;gt; stream : streams) {
            executor.execute(new Runnable() {
                @Override
                public void run() {
                    for (MessageAndMetadata&amp;lt;byte[], byte[]&amp;gt; messageAndMetadata : stream) {
                        System.out.println(new String(messageAndMetadata.message()));
                    }
                }
            });
        }

        Thread.sleep(60000);

        consumer.shutdown();
        executor.shutdown();
    }
}&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;위의 코드를 실행하면 consumer가 byte[]로된 메시지를 받아서 String으로 변환한 뒤 standard output에 출력한다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;ConsumerConfig&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;를 생성할 때 설정할 수 있는 프로퍼티들은 다음 절에서 다룬다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;코드 상에는 consumer가 소비할 메시지의 offset과 관련된 내용은 전혀 존재하지 않는다. Offset 값은 Zookeeper에서 별도로 관리하며, high level consumer는 Zookeeper로부터 자신이 속한 consumer group이 몇 번째 메시지 offset을 소비할 차례인지 전달받은 뒤 해당 offset의 메시지부터 소비하기 시작한다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 14pt;&quot;&gt;필수 프로퍼티&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;table class=&quot;txc-table&quot; width=&quot;814&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; border=&quot;0&quot; style=&quot;border: none; border-collapse: collapse; font-size: 12px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;color: rgb(0, 0, 0); width: 131px; height: 24px; border: 1px solid rgb(0, 0, 0); background-color: rgb(230, 230, 230);&quot;&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&amp;nbsp;프로퍼티&amp;nbsp;&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;/td&gt;&lt;td style=&quot;color: rgb(0, 0, 0); width: 682px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-top-width: 1px; border-top-style: solid; border-top-color: rgb(0, 0, 0); background-color: rgb(230, 230, 230);&quot;&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;설명&amp;nbsp;&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;color: rgb(0, 0, 0); width: 131px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;font face=&quot;Dotum, 돋움&quot;&gt;&lt;span style=&quot;font-size: 11pt; line-height: 22px;&quot;&gt;&amp;nbsp;group.id&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;/td&gt;&lt;td style=&quot;width: 682px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;font color=&quot;#000000&quot; face=&quot;Dotum, 돋움&quot;&gt;&lt;span style=&quot;font-size: 11pt; line-height: 22px;&quot;&gt;Consumer가 속한 consumer group의 ID. Zookeeper에서는 각 consumer group의 메시지 offset을 관리하는데, 이 때 이 ID가 키로써 사용된다. 따라서 consumer group ID가 같으면 모두 같은 consumer group에 속한 것으로 간주되며 메시지 offset 값 또한 공유된다.&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;color: rgb(0, 0, 0); width: 131px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(0, 0, 0); background-color: transparent;&quot; rowspan=&quot;1&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;zookeeper.connect&lt;/span&gt;&lt;/td&gt;&lt;td style=&quot;width: 682px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); background-color: transparent;&quot; rowspan=&quot;1&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Zookeeper 인스턴스 리스트. &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;호스트1:포트1,호스트2:포트2,호스트3:포트3&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;의 형태로 명시한다.&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;예)&amp;nbsp;kafka-test-001.epicdevs.com:2181,kafka-test-002.epicdevs.com:2181,kafka-test-003.epicdevs.com:2181&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 14pt;&quot;&gt;중요 프로퍼티&lt;/span&gt;&lt;/p&gt;&lt;table class=&quot;txc-table&quot; width=&quot;814&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; border=&quot;0&quot; style=&quot;border: none; border-collapse: collapse; font-size: 12px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;color: rgb(0, 0, 0); width: 191px; height: 24px; border: 1px solid rgb(0, 0, 0); background-color: rgb(230, 230, 230);&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;프로퍼티&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td style=&quot;color: rgb(0, 0, 0); width: 83px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-top-width: 1px; border-top-style: solid; border-top-color: rgb(0, 0, 0); background-color: rgb(230, 230, 230);&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;기본 값&amp;nbsp;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td style=&quot;color: rgb(0, 0, 0); width: 539px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-top-width: 1px; border-top-style: solid; border-top-color: rgb(0, 0, 0); background-color: rgb(230, 230, 230);&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;설명&amp;nbsp;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;color: rgb(0, 0, 0); width: 191px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;auto.commit.enable&lt;/span&gt;&lt;/td&gt;&lt;td style=&quot;color: rgb(0, 0, 0); width: 83px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;true&lt;/span&gt;&lt;/td&gt;&lt;td style=&quot;color: rgb(0, 0, 0); width: 539px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Consumer가 메시지를 전달받은 뒤 자동으로 offset 값을 commit할지 결정하는 플래그. 메시지가 성공적으로 처리되었을 때만 offset이 commit되도록 하려면 이 값을 &lt;/span&gt;&lt;i&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;false&lt;/span&gt;&lt;/i&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;로 설정해야 한다. 이 값이 &lt;/span&gt;&lt;i&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;true&lt;/span&gt;&lt;/i&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;일 경우 &lt;/span&gt;&lt;i&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;auto.commit.interval.ms&lt;/span&gt;&lt;/i&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt; 값마다 주기적으로 offset을 commit하며, &lt;/span&gt;&lt;i&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;false&lt;/span&gt;&lt;/i&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;일 경우 &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;ConsumerConnector&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;의 &lt;/span&gt;&lt;i&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;commitOffsets&lt;/span&gt;&lt;/i&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt; 메소드를 직접 호출해야 offset이 commit된다&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;color: rgb(0, 0, 0); width: 191px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;auto.commit.interval.ms&lt;/span&gt;&lt;/td&gt;&lt;td style=&quot;color: rgb(0, 0, 0); width: 83px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;60000&lt;/span&gt;&lt;/td&gt;&lt;td style=&quot;color: rgb(0, 0, 0); width: 539px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;i&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;auto.commit.enable&lt;/span&gt;&lt;/i&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;이 &lt;/span&gt;&lt;i&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;true&lt;/span&gt;&lt;/i&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;일 때 offset을 자동으로 commit하는 주기. 이 값을 길게 잡으면 메시지 처리 중에 장애가 발생할 경우 실제로 처리된 메시지 offset과 commit된 offset 간의 격차가 커져서 fail over 후 중복으로 처리되는 메시지의 수가 많아질 가능성이 높으며, 짧게 잡을 경우 잦은 Zookeeper 업데이트로 인한 오버헤드가 발생할 수 있다.&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;color: rgb(0, 0, 0); width: 191px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;auto.offset.reset&lt;/span&gt;&lt;/td&gt;&lt;td style=&quot;color: rgb(0, 0, 0); width: 83px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;largest&lt;/span&gt;&lt;/td&gt;&lt;td style=&quot;width: 539px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p style=&quot;color: rgb(0, 0, 0);&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Consumer가 속한 consumer group의 offset 값이 존재하지 않거나 범위를 벗어나는 값을 전달받았을 경우 어떻게 동작할지를 정하는 값.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;color: rgb(0, 0, 0);&quot;&gt;&lt;/p&gt;&lt;ul style=&quot;list-style-type: disc;&quot;&gt;&lt;li&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;smallest: 가장 작은 offset의 메시지부터 소비한다.&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;largest:&amp;nbsp;가장 큰 offset의 메시지 이후부터 소비한다. (즉, 새롭게 전송되는 메시지부터 소비한다.)&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;위에서 언급한 필수 프로퍼티와 중요 프로퍼티 외의 항목들은 Kafka 공식 페이지의 &lt;/span&gt;&lt;a href=&quot;http://kafka.apache.org/081/documentation.html#consumerconfigs&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot; style=&quot;font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;3.2 Consumer Configs&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;를 참고하길 바란다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;pom.xml&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;아래는 producer와 consumer 예제를 Maven으로 빌드할 때 사용한 pom.xml이다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint linenums lang-xml&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.epicdevs&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;kafka&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

    &amp;lt;name&amp;gt;kafka&amp;lt;/name&amp;gt;
    &amp;lt;url&amp;gt;http://maven.apache.org&amp;lt;/url&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.kafka&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;kafka_2.9.2&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;0.8.1.1&amp;lt;/version&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;artifactId&amp;gt;jmxri&amp;lt;/artifactId&amp;gt;
                    &amp;lt;groupId&amp;gt;com.sun.jmx&amp;lt;/groupId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;artifactId&amp;gt;jmxtools&amp;lt;/artifactId&amp;gt;
                    &amp;lt;groupId&amp;gt;com.sun.jdmk&amp;lt;/groupId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;artifactId&amp;gt;jms&amp;lt;/artifactId&amp;gt;
                    &amp;lt;groupId&amp;gt;javax.jms&amp;lt;/groupId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;pluginManagement&amp;gt;
            &amp;lt;plugins&amp;gt;
                &amp;lt;plugin&amp;gt;
                    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
                    &amp;lt;version&amp;gt;2.5.1&amp;lt;/version&amp;gt;
                    &amp;lt;configuration&amp;gt;
                        &amp;lt;source&amp;gt;1.7&amp;lt;/source&amp;gt;
                        &amp;lt;target&amp;gt;1.7&amp;lt;/target&amp;gt;
                    &amp;lt;/configuration&amp;gt;
                &amp;lt;/plugin&amp;gt;
            &amp;lt;/plugins&amp;gt;
        &amp;lt;/pluginManagement&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;참고자료&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul style=&quot;list-style-type: disc;&quot;&gt;&lt;li&gt;&lt;a href=&quot;http://kafka.apache.org/081/documentation.html&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Kafka 0.8.1 Documentation&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/KAFKA/Index&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Kafka Wiki&lt;/span&gt;&lt;/a&gt;&lt;br /&gt;&lt;span style=&quot;font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;-&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/KAFKA/0.8.0+Producer+Example&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;0.8.0 Producer Example&lt;/span&gt;&lt;/a&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;-&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/KAFKA/Consumer+Group+Example&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Consumer Group Example&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>Programming Insight</category>
<category>kafka</category>
<category>메시지 큐</category>
<category>메시징 시스템</category>
<category>미들웨어</category>
<category>카프카</category>
<author>epicdev</author>
<guid>https://epicdevs.com/21</guid>
<comments>https://epicdevs.com/21#entry21comment</comments>
<pubDate>Wed, 18 Mar 2015 18:59:26 +0900</pubDate>
</item>
<item>
<title>[Apache Kafka] 2. 클러스터 구축하기</title>
<link>https://epicdevs.com/20</link>
<description>&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://cfs.tistory.com/custom/blog/154/1543390/skin/images/epicdevs-mobile.css&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:850px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/21327F38550924462B&quot; filemime=&quot;image/jpeg&quot; filename=&quot;kafka-cluster.png&quot; height=&quot;506&quot; width=&quot;850&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;이 글에서는 위의 그림처럼 3개의 인스턴스로 구성된 클러스터를 구축해 본다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;클러스터를 구성하는 &lt;b&gt;kafka-test-001&lt;/b&gt;, &lt;b&gt;kafka-test-002&lt;/b&gt;, &lt;b&gt;kafka-test-003&lt;/b&gt; 인스턴스는 Zookeeper 인스턴스와 Kafaka broker를 하나씩 가지고 있다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;이 글에서는 3대의 VM을 사용하여 클러스터를 구축하는데 만약 1대의 서버에 테스트 용도로 클러스터를 구축할 경우&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;각 인스턴스의 ID와 사용하는 디렉토리와 포트 번호만 겹치지 않게 설정하면 동일한 방식으로 구축할 수 있다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-size: 14.6667px; vertical-align: baseline; font-family: 'Nanum Gothic', sans-serif; color: rgb(85, 85, 85); line-height: 22px;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-size: 14.6667px; vertical-align: baseline; color: rgb(140, 140, 140);&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-size: 14.6667px; vertical-align: baseline;&quot;&gt;&lt;b style=&quot;margin: 0px; padding: 0px; border: 0px; font-size: 14.6667px; vertical-align: baseline;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-size: 14.6667px; vertical-align: baseline; color: rgb(0, 0, 0);&quot;&gt;내용 추가: 2016.05.22&lt;br /&gt;&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 14.6667px; line-height: 22px;&quot;&gt;이 글에서는 구축과정을 따라가기&amp;nbsp;쉽도록&amp;nbsp;Kafka 클러스터와 Zookeeper 클러스터를 동일한 장비에 구축하고 있는데,&amp;nbsp;실무에서는 Zookeeper 클러스터와&amp;nbsp;Kafka를&amp;nbsp;별도로 구축하길 바란다.&amp;nbsp;또한, Kafka에서는 Zookeeper에 쓰기 연산이 대량으로 발생하므로&amp;nbsp;다른 서비스에서 사용하고 있는 Zookeeper 클러스터를 공유해서 쓰는것 또한 권장하지 않는다. 정리하자면&lt;/span&gt;&lt;span style=&quot;font-size: 14.6667px; line-height: 22px;&quot;&gt;&amp;nbsp;Kafka를 위한 Zookeeper 클러스터를 별도의 장비에 구축하고, 해당 Zookeeper 클러스터는 Kafka만 사용하도록 하는 것을 권장한다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;Zookeeper 클러스터 구축&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Kafka의 대부분의 동작은 Zookeeper와 연계되어 있기 때문에 Zookeeper 없이는 Kafka를 구동할 수 없다. 이 때문에 Kafka 패키지를 받으면 패키지 안에 Zookeeper도 함께 들어있다. 물론 Kafka 패키지 안에 들어있는 Zookeeper 대신 Zookeeper 최신 버전 패키지를 받아서 사용해도 되지만, 패키지 안에 들어있는 Zookeeper는 해당 Kafka 버전과 잘 동작하는 것이 검증된 버전이므로 개인적으로는 패키지 안에 들어있는 Zookeeper의 사용을 권장한다. 그리고 Zookeeper 패키지에 들어있는 sh 파일명과 Kafka 패키지 안에 들어있는 sh 파일명이 다르기 때문에 이 글은 Kafka 패키지에 포함된 Zookeeper를 기준으로 작성하였다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;Zookeeper 설정 및 구동&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Kafka 패키지에 기본적으로 포함되어 있는 &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;config/zookeeper.properties&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;파일은 하나의 Zookeeper 인스턴스를 실행하는데 쓰이는 설정 파일이다. 3개의 인스턴스로 이루어진 클러스터를 구축하기 위해서는 인스턴스 간 통신을 할 때 필요한 설정을 추가해 주어야 한다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;config/zookeeper.properties&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt; 파일을 열면 기본적으로 다음의 항목들이 설정되어 있다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;span style=&quot;font-size: 11pt; font-family: Dotum, 돋움;&quot;&gt;dataDir=/tmp/zookeeper
clientPort=2181
maxClientCnxns=0
&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Dotum, 돋움; font-size: 11pt; line-height: 1.5;&quot;&gt;해당 설정 파일에 다음의 설정을 추가해 준다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;span style=&quot;font-size: 11pt; font-family: Dotum, 돋움;&quot;&gt;initLimit=5
syncLimit=2

server.1=kafka-test-001.epicdevs.com:2888:3888
server.2=kafka-test-002.epicdevs.com:2888:3888
server.3=kafka-test-003.epicdevs.com:2888:3888
&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;인스턴스가 3개인 클러스터를 구축할 예정이므로 &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;server.1&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;, &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;server.2&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;, &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;server.3&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;을 설정해 준다. server.&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;#&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;에서 &lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;#&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;은 인스턴스의 ID이다.&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;설정 파일에 대한 상세한&lt;span style=&quot;font-size: 11pt;&quot;&gt; 내용은 Zookeeper의 &lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;http://zookeeper.apache.org/doc/trunk/zookeeperAdmin.html#sc_configuration&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot; style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Administrator's Guide&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;를 참조하길 바란다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;설&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;정 파일에 인스턴스들에 대한 정보를 입력했지만, 각 인스턴스들은 설정 파일만 가지고서는 자신의 ID가 무엇인지 알 수 없다.&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;이 때문에 인스턴스의 ID를 &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;dataDir&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;디렉토리 아래의 &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;myid&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;라는 파일에 명시해 주어야 한다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size:11pt;&quot;&gt;예를 들어 1번&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt; 인스턴스의 &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;myid&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt; 파일에는 1이 입력되어 있어야 하므로 다음의 커맨드를 실행하여&amp;nbsp;&lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;myid&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;파일을 생성하면 된다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;echo 1 &amp;gt; /tmp/zookeeper/myid
&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;3개의 인스턴스에 모두 각자의 &lt;/span&gt;&lt;b style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;myid&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;를 생성한 뒤 다음의 커맨드를 각 인스턴스에서 실행하면 Zookeeper 클러스터가 구동된다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;bin/zookeeper-server-start.sh config/zookeeper.properties
&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;Kafka 클러스터 구축&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt; line-height: 1.5;&quot;&gt;Broker 설정 및 구동&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Kafka 패키지에 기본적으로 포함되어 있는 &lt;b&gt;config/server.properties&lt;/b&gt;는 하나의 Kafka broker를 실행하는데 쓰이는 설정 파일이다. 3개의 broker로 이루어진 클러스터를 구축하기 위해서는 해당 파일의 설정을 변경해 주어야 한다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Kafka 클러스터 내의 broker 리스트는 Zookeeper가 관리하므로 설정 파일에는 다른 broker에 대한 정보를 입력할 필요 없이 자신의 broker ID만 명시&lt;span style=&quot;font-size: 11pt;&quot;&gt;해 주면 된다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size:11pt;&quot;&gt;별도의 파일에 인스턴스의 ID를 명시해야 하는 Zookeeper와는 달리 Kafka는 설정 파일의 &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;broker.id&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;라는 항목에 인스턴스의 ID를 아래와 같이 명시하면 된다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;broker.id=1
&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;그리고 Zookeeper와 연동을 위하여 &lt;/span&gt;&lt;b style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;zookeeper.connect&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;라는 항목에 Zookeeper 인스턴스들의 정보를 입력한다.&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;zookeeper.connect=kafka-test-001.epicdevs.com:2181,kafka-test-002.epicdevs.com:2181,kafka-test-003.epicdevs.com:2181
&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;위의 설정을 모두 마친 뒤 다음의 커맨드를 각 인스턴스에서 실행하면 Kafka 클러스터가 구동된다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;bin/kafka-server-start.sh config/server.properties
&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;실제 운영에서는 디스크에 메시지를 얼마나 오랫동안 유지할&lt;/span&gt;지 그리고 얼마나 많이 유지할지에 대한 다음의 설정 또한 중요하다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;table class=&quot;txc-table&quot; width=&quot;814&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; border=&quot;0&quot; style=&quot;border:none;border-collapse:collapse;;font-family:돋움;font-size:12px&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;width: 128px; height: 24px; border: 1px solid rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: rgb(230, 230, 230);&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;b&gt;&amp;nbsp;프로퍼티&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 89px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-top-width: 1px; border-top-style: solid; border-top-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: rgb(230, 230, 230);&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;b&gt;기본 값&amp;nbsp;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 596px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-top-width: 1px; border-top-style: solid; border-top-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: rgb(230, 230, 230);&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;b&gt;설명&amp;nbsp;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 128px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;log.retention.hours&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 89px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;168&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 596px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;메시지의 수명. 수명이 지나면 메시지가 삭제된다.&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 128px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;log.retention.bytes&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 89px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;-1&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 596px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;Partition의 물리적 최대 크기. 크기를 초과하면 디스크에서 메시지가 삭제된다. &lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;b&gt;log.retention.bytes&lt;/b&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;b&gt; x partition의 수&lt;/b&gt;는 topic의 물리적 최대 크기가 된다. 이 값이 -1이면 크기는 무제한으로 설정된다.&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;설정 파일에 대한 상세한 내용은 Kafaka 공식 문서의 &lt;/span&gt;&lt;a href=&quot;http://kafka.apache.org/081/documentation.html#brokerconfigs&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot; style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;3.1 Broker Configs&lt;/a&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;를 참조하길 바란다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;Topic 생성하기&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;클&lt;span style=&quot;font-size: 11pt;&quot;&gt;러스터를 구축했으니 이제 topic을 생성해 보자. Partition 20개로 이루어진 &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;test&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;라는 topic을 생성하도록 한다.&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;클러스터를 구성하는 인스턴스는 3대이므로 replication factor는 3으로 설정한다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;bin/kafka-topics.sh --create --zookeeper kafka-test-001.epicdevs.com:2181 --replication-factor 3 --partitions 20 --topic test
&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;위의 커맨드를 실행하&lt;/span&gt;면 아래와&amp;nbsp;같이 20개의 partition이 생성된 것을 확인할 수 있다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;(Kafka 설정 파일의 &lt;/span&gt;&lt;b style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;log.dirs&lt;/b&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;에 명시된 디렉토리에 partition이 생성된다.)&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:829px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/25677E385509244603&quot; filemime=&quot;image/jpeg&quot; filename=&quot;logfiles.png&quot; height=&quot;42&quot; width=&quot;829&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;아래의 커맨드를 실행하면 클러스터 내의 topic 리스트를 확인할 수 있다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;bin/kafka-topics.sh --list --zookeeper kafka-test-001.epicdevs.com:2181
&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;아래의 커맨드를 실행하면 특정 topic의 partition과 replica에 대한 상세 정보를 확인할 수 있다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;bin/kafka-topics.sh --describe --zookeeper kafka-test-001.epicdevs.com:2181 --topic test
&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:579px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/26468638550924471C&quot; filemime=&quot;image/jpeg&quot; filename=&quot;describe.png&quot; height=&quot;292&quot; width=&quot;579&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;아래의&lt;span style=&quot;font-size: 11pt;&quot;&gt; 커맨드를 3번 인스턴스에서 실행하여 3번 broker를 정지시킨 다음 위의 커맨드를 실행하면 3번 broker가 leader이던 partition들이 fail over되면서 leader가 변경된 것을 확인할 수 있다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;bin/kafka-server-stop.sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:568px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/27559B385509244710&quot; filemime=&quot;image/jpeg&quot; filename=&quot;failover.png&quot; height=&quot;293&quot; width=&quot;568&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Isr(in-sync replica)은 현재 정상적으로 구동되고 있는 replica의 목록이다. 현재 3번 broker가 정지되었기 때문에 1번과 2번 broker만 in-sync 상태인 것을 확인할 수 있다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14.6666669845581px; line-height: 22px;&quot;&gt;(위 상황에서 3번 broker가 다시 복구되어 클러스터에 합류할 경우&amp;nbsp;3번 broker는 모든 partition에 대하여 follower가 된다. 즉,&amp;nbsp;3번 broker는&amp;nbsp;leader를 맡은 partition이&amp;nbsp;없는 상황이 되어 부하가 적절하게&amp;nbsp;분산되지 않는 현상이 발생한다. 이 때&amp;nbsp;&lt;b&gt;kafka-preferred-replica-election.sh&lt;/b&gt;를 사용하여 3번 broker가 다시 partition들의&amp;nbsp;leader를 맡도록 할 수 있다. 이에 대한 자세한 사항은&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 14.6666669845581px; line-height: 22px;&quot;&gt;Kafka 공식 문서의 &lt;a href=&quot;http://kafka.apache.org/081/documentation.html#basic_ops_leader_balancing&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Balancing leadership&lt;/a&gt;을 참조하길 바란다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14.6666669845581px; line-height: 22px;&quot;&gt;&lt;span style=&quot;color: rgb(140, 140, 140); background-color: rgb(255, 255, 255);&quot;&gt;&lt;span style=&quot;color: rgb(140, 140, 140);&quot;&gt;&lt;b&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;내용 추가: 2015.03.19&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-size: 14.6666669845581px; line-height: 22px;&quot;&gt;Kafka&amp;nbsp;0.8.2부터는 broker가 복구된 후&amp;nbsp;클러스터에 합류할 경우 자동으로 leader가 분배되도록 변경되었다. 이와 관련된 broker 설정은&amp;nbsp;&lt;b&gt;auto.leader.rebalance.enable&lt;/b&gt;인데 0.8.1까지는 이 값이 &lt;i&gt;false&lt;/i&gt;였는데 0.8.2부터는 이 값이 &lt;i&gt;true&lt;/i&gt;로 변경되었다. 0.8.1까지는 이 값을 &lt;i&gt;true&lt;/i&gt;로 설정할 경우 &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-1294&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;이슈&lt;/a&gt;가 있어서 &lt;i&gt;false&lt;/i&gt;로 해 둔 것이고 0.8.2부터는 이슈가 해결되어 &lt;i&gt;true&lt;/i&gt;로 변경되었다.&lt;/span&gt;&lt;span style=&quot;font-size: 14.6666669845581px; line-height: 22px;&quot;&gt;)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;Topic 설정 변경하기&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;이미 &lt;span style=&quot;font-size: 11pt;&quot;&gt;생성된 topic의 partition 수를 늘리거나 설정을 변경하는 것도 &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;kafka-topics.sh&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;를 통해 가능하다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;아래의 커맨드를 실행하면 &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;test&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;의 partition 수가 20에서 40으로 증가한다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;bin/kafka-topics.sh --alter --zookeeper kafka-test-001.epicdevs.com:2181 --topic test --partitions 40
&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Partition의 수를 늘리는 것 외에도 topic과 관련된 설정을 변경할 수도 있다. 이에 대한 상세한 내용은 Kafaka 공식 문서의 &lt;/span&gt;&lt;a href=&quot;http://kafka.apache.org/081/documentation.html#topic-config&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot; style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Topic-level configuration&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;을 참조하길 바란다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Kafka는 현재 topic의 partition 수나 replication factor를 감소시키는 것은 지원하지 않으므로 topic을 처음 생성할 때 이를 주의해야 한다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;(&lt;/span&gt;&lt;b style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;kafka-reassign-partitions.sh&lt;/b&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;를 사용하면 replication factor를 증가시킬 수 있다.&amp;nbsp;상세한 사항은 Kafka 공식 문서의 &lt;/span&gt;&lt;a href=&quot;http://kafka.apache.org/081/documentation.html#basic_ops_increase_replication_factor&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot; style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Increasing replication factor&lt;/a&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;를 참조하길 바란다.)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;Topic 자동 생성시 주의할 점&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;존재하지 않는 topic에 대하여 메시지를 생산하거나 소비할 경우 broker의 설정 값에 따라 topic이 자동으로 생성될 수 있다. 그런데 topic이 자동으로 생성되도록 설정해 두었을 경우 partition의 수와 replica의 수 또한 설정 값을 따르게 된다. 그런데 이 값을 별도로 설정하지 않을 경우 기본 값을 사용하게 되면서 문제가 발생할 수 있다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;기본 설정 그대로 topic을 자동 생성할 경우 1개의 partition과 replica를 가지는 topic이 생성되는데 이 값은 실제 운영에는 적합하지 않다. 따라서 topic을 사용하기 전에 &lt;b&gt;kafka-topics.sh&lt;/b&gt;를 통해 적절한 설정 값을 가지는 topic을 미리 생성해 둔다면 이와 같은 실수를 미연에 방지할 수 있다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;위 내용과 관련된 broker의 설정은 다음과 같다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;table class=&quot;txc-table&quot; width=&quot;814&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; border=&quot;0&quot; style=&quot;border:none;border-collapse:collapse;;font-family:돋움;font-size:12px&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;width: 211px; height: 24px; border: 1px solid rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: rgb(230, 230, 230);&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 22px;&quot;&gt;&lt;b&gt;프로퍼티&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 115px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-top-width: 1px; border-top-style: solid; border-top-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: rgb(230, 230, 230);&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 22px;&quot;&gt;&lt;b&gt;기본 값&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 487px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-top-width: 1px; border-top-style: solid; border-top-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: rgb(230, 230, 230);&quot;&gt;&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 22px;&quot;&gt;설명&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 211px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 22px;&quot;&gt;auto.create.topics.enable&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 115px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 22px;&quot;&gt;true&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 487px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 22px;&quot;&gt;Topic을 자동으로 생성할지 여부.&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 211px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 22px;&quot;&gt;num.partitions&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 115px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;1&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 487px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 22px;&quot;&gt;Topic을 자동으로 생성할 때 생성할 partition의 수&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 211px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 22px;&quot;&gt;default.replication.factor&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 115px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;1&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 487px; height: 24px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(0, 0, 0); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(0, 0, 0); color: rgb(0, 0, 0); background-color: transparent;&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 22px;&quot;&gt;Topic을 자동으로 생성할 때 생성할 replica의 수&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;Producer/Consumer 테스트&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Kafka 패키지에는 테스트 용도로 사용할 수 있는 producer와 consumer가 포함되어 있다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;둘을 이용하여 간단하게 메시지를 생산하고 소비해 보자.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;메시지 생산하기(Producer)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;아&lt;span style=&quot;font-size: 11pt;&quot;&gt;래의 커맨드를 입력한 뒤 터미널 창에 키보드로 입력하면 메시지가 생산된다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;bin/kafka-console-producer.sh --broker-list kafka-test-001.epicdevs.com:9092 --topic test
&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;메시지 소비하기(Consumer)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;아래의 커맨드를 입력하면 해당 topic의 메시지를 소비한다. 기본적으로 &lt;b&gt;kafka&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;b&gt;-console-consumer.sh&lt;/b&gt;는 실행된 시점 이후에 생산되는 메시지만 소비하기 때문에&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;b style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;from-beginning&lt;/b&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&amp;nbsp;옵션을 주어 해당 topic의 맨 처음 메시지부터 소비하도록 하였다.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;bin/kafka-console-consumer.sh --zookeeper kafka-test-001.epicdevs.com:2181 --topic test --from-beginning&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul style=&quot;list-style-type: disc;&quot;&gt;&lt;li&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;a href=&quot;http://kafka.apache.org/081/documentation.html&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Kafka 0.8.1 Documentation&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>Programming Insight</category>
<category>kafka</category>
<category>메시지 큐</category>
<category>메시징 시스템</category>
<category>미들웨어</category>
<category>카프카</category>
<author>epicdev</author>
<guid>https://epicdevs.com/20</guid>
<comments>https://epicdevs.com/20#entry20comment</comments>
<pubDate>Wed, 18 Mar 2015 17:51:39 +0900</pubDate>
</item>
<item>
<title>[Apache Kafka] 1. 소개및 아키텍처 정리</title>
<link>https://epicdevs.com/17</link>
<description>&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://cfs.tistory.com/custom/blog/154/1543390/skin/images/epicdevs-mobile.css&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:548px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/227E373554FC02CB2D&quot; filemime=&quot;image/jpeg&quot; filename=&quot;kafka.png&quot; height=&quot;120&quot; width=&quot;548&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;a href=&quot;http://kafka.apache.org/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Apache Kafka&lt;/a&gt;(아파치 카프카)&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;는 LinkedIn에서 개발된 분산 메시징 시스템으로써 2011년에 오픈소스로 공개되었다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;대용량의 실시간 로그처리에 특화된 아키텍처 설계를 통하여 기존 메시징 시스템보다 우수한 TPS를 보여주고 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;이 글은 Apache Kafka 공식페이지의 &lt;/span&gt;&lt;a href=&quot;http://kafka.apache.org/081/documentation.html&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot; style=&quot;font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;0.8.1 문서&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;와 2011년에 NetDB에 출판된 논문(&lt;/span&gt;&lt;a href=&quot;http://research.microsoft.com/en-us/UM/people/srikanth/netdb11/netdb11papers/netdb11-final12.pdf&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot; style=&quot;font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Kafka: A distributed messaging system for log processing&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;)을 기반으로 작성하였다.&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;(글 작성 시점인 2015.03.09를 기준으로 0.8.2.0이 최신 버전이지만 아직 출시된 지 한 달 남짓 밖에 되지 않으므로 0.8.1.1을 기준으로 작성하였다.)&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;Kafka의 기본 구성 요소와 동작&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Kafka는 발행&lt;span style=&quot;font-size: 11pt;&quot;&gt;-구독(publish-subscribe) 모델을 기반으로 동작하며 크게 producer, consumer, broker로 구성된다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;clear: none; float: none; text-align: center;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:258px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/253BF244550914E21A&quot; filemime=&quot;image/jpeg&quot; filename=&quot;producer_consumer.png&quot; height=&quot;180&quot; width=&quot;258&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;clear: none; float: none; text-align: center;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;(이미지 출처: &lt;/span&gt;&lt;a href=&quot;http://kafka.apache.org/081/documentation.html&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Apache Kafka 0.8.1 Documentation&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Kafka의 broker는 topic을 기준으로 메시지를 관리한다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Producer는 특정 topic의 메시지를 생성한 뒤 해당 메시지를 broker에 전달한다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Broker가 전달받은 메시지를 topic별로 분류하여 쌓아놓으면, 해당 topic을 구독하는 consumer들이 메시지를 가져가서 처리하게 된다.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Kafka는 확장성(scale-out)과 고가용성(high availability)을 위하여 broker들이 클러스터로 구성되어 동작하도록 설계되어있다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;심지어 broker가 1개 밖에 없을 때에도 클러스터로써 동작한다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;클러스터 내의 broker에 대한 분산 처리는 아래의 그림과 같이 &lt;/span&gt;&lt;a href=&quot;http://zookeeper.apache.org/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Apache ZooKeeper&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;가 담당한다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;clear: none; float: none; text-align: center;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:700px;width: 700px; height: 516px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/270D49435509151E2A&quot; filemime=&quot;image/jpeg&quot; filename=&quot;three-node.jpg&quot; height=&quot;516&quot; style=&quot;width: 700px; height: 516px;&quot; width=&quot;700&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;clear: none; float: none; text-align: center;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;(이미지 출처: &lt;/span&gt;&lt;a href=&quot;http://blog.mmlac.com/log-transport-with-apache-kafka&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;http://blog.mmlac.com/log-transport-with-apache-kafka&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;clear: none; float: none; text-align: left;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 24px; line-height: 36px;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;기존 메시징 시스템과의 차이점&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;div&gt;&lt;span style=&quot;font-size: 11pt; line-height: 22px;&quot;&gt;(기존 메시징 시스템: &lt;a href=&quot;http://activemq.apache.org/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;ActiveMQ&lt;/a&gt;, &lt;a href=&quot;http://www.rabbitmq.com/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;RabbitMQ&lt;/a&gt;&amp;nbsp;등)&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-size: 11pt; line-height: 22px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/div&gt;&lt;ul style=&quot;list-style-type: disc;&quot;&gt;&lt;li style=&quot;line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;대용량의 실시간 로그 처리에 특화되어 설계된 메시징 시스템으로써 기존 범용 메시징 시스템대비 TPS가 매우 우수하다. 단, 특화된 시스템이기 때문에 범용 메시징 시스템에서 제공하는 다양한 기능들은 제공되지 않는다.&lt;br /&gt;&lt;br /&gt;&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;분산 시스템을 기본으로 설계되었기 때문에, 기존 메시징 시스템에 비해 분산 및 복제 구성을 손쉽게 할 수 있다.&lt;br /&gt;&lt;br /&gt;&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;AMQP 프로토콜이나 JMS API를 사용하지 않고 단순한 메시지 헤더를 지닌 TCP기반의 프로토콜을 사용하여 프로토콜에 의한 오버헤드를 감소시켰다.&lt;br /&gt;&lt;br /&gt;&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Producer가 broker에게 다수의 메시지를 전송할 때 각 메시지를 개별적으로 전송해야하는 기존 메시징 시스템과는 달리, 다수의 메시지를 batch형태로 broker에게 한 번에 전달할 수 있어 TCP/IP 라운드트립 횟수를 줄일 수 있다.&lt;br /&gt;&lt;br /&gt;&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot;line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;메시지를 기본적으로 메모리에&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt; 저장하는 기존 메시징 시스템과는 달리 메시지를 파일 시스템에 저장한다.&lt;br /&gt;&lt;br /&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p style=&quot;margin-left: 2em; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;-&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size:11pt;&quot;&gt;파일 시스템에 메시지를 저장하기 때문에 별도의 설정을 하지 않아도 데이터의 영속성(durability)이 보장된다.&lt;br /&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;- 기존 메시징 시스템에서는 처리되지 않고 남아있는 메시지의 수가 많을 수록 시스템의 성능이 크게 감소하였으나, Kafka에서는 메시지를 파일 시스템에 저장하기 때문에 메시지를 많이 쌓아두어도 성능이 크게 감소하지 않는다. 또한 많은 메시지를 쌓아둘 수 있기 때문에, 실시간 처리뿐만 아니라 주기적인 batch작업에 사용할 데이터를 쌓아두는 용도로도 사용할 수 있다.&lt;br /&gt;&lt;/span&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;- Consumer에 의해 처리된 메시지(acknowledged message)를 곧바로 삭제하는 기존 메시징 시스템과는 달리 처리된 메시지를 삭제하지 않고 파일 시스템에 그대로 두었다가 설정된 수명이 지나면 삭제한다. 처리된 메시지를 일정 기간동안 삭제하지 않기 때문에 메시지 처리 도중 문제가 발생하였거나 처리 로직이 변경되었을 경우 consumer가 메시지를 처음부터 다시 처리(rewind)하도록 할 수 있다.&lt;br /&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul style=&quot;list-style-type: disc;&quot;&gt;&lt;li style=&quot;line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;기존의 메시징 시스템에서는 broker가 consumer에게 메시지를 push해 주는 방식인데 반해, Kafka는 consumer가 broker로부터 직접 메시지를 가지고 가는 pull 방식으로 동작한다. 따라서 consumer는 자신의 처리능력만큼의 메시지만 broker로부터 가져오기 때문에 최적의 성능을 낼 수 있다.&lt;br /&gt;&lt;br /&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p style=&quot;margin-left: 2em; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size:11pt;&quot;&gt;- 기존의 push 방식의 메시징 시스템에서는 broker가 직접 각 consumer가 어떤 메시지를 처리해야 하는지 계산하고 어떤 메시지를 처리 중인지 트랙킹하였는데, Kafka에서는 consumer가 직접 필요한 메시지를 broker로부터 pull하므로 broker의 consumer와 메시지 관리에 대한 부담이 경감되었다.&lt;br /&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;- 메시지를 pull 방식으로 가져오므로, 메시지를 쌓아두었다가 주기적으로 처리하는 batch consumer의 구현이 가능하다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;기존 메시징 시스템과의 성능 비교&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14pt; line-height: 1.5;&quot;&gt;Producer 성능&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:600px;width: 600px; height: 475px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/23441B445509177A1F&quot; filemime=&quot;image/jpeg&quot; filename=&quot;producer-perf.png&quot; height=&quot;475&quot; style=&quot;width: 600px; height: 475px;&quot; width=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;(이미지 출처:&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 14.6666669845581px; line-height: 22px;&quot;&gt;&lt;a href=&quot;http://research.microsoft.com/en-us/UM/people/srikanth/netdb11/netdb11papers/netdb11-final12.pdf&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Kafka: A distributed messaging system for log processing&lt;/a&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;붉은 색 그래프는 메시지를 한 번에 50개씩 batch로 전송한 결과이고 연두색 그래프는 한 번에 하나씩 전송한 결과이다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:14pt;&quot;&gt;Consumer 성능&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:600px;width: 600px; height: 479px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/217D7945550917BD0B&quot; filemime=&quot;image/jpeg&quot; filename=&quot;consumer-perf.png&quot; height=&quot;479&quot; style=&quot;width: 600px; height: 479px;&quot; width=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;(이미지 출처:&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 14.6666669845581px; line-height: 22px;&quot;&gt;&lt;a href=&quot;http://research.microsoft.com/en-us/UM/people/srikanth/netdb11/netdb11papers/netdb11-final12.pdf&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Kafka: A distributed messaging system for log processing&lt;/a&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;좀 더 자세히 살펴보기&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14pt; line-height: 1.5;&quot;&gt;Topic과 Partition&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Kafka의 topic은 partition이라는 단위로 쪼개어져 클러스터의 각 서버들에 분산되어 저장되고, 고가용성을 위하여 복제(replication) 설정을 할 경우 이 또한 p&lt;span style=&quot;font-size: 11pt;&quot;&gt;artition 단위로 각 서버들에 분산되어 복제되고 장애가 발생하면 partition 단위로 fail over가 수행된다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:416px;font-size: 9pt; line-height: 1.5;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/213CA13D5509180234&quot; filemime=&quot;image/jpeg&quot; filename=&quot;partition.png&quot; height=&quot;267&quot; style=&quot;font-size: 9pt; line-height: 1.5;&quot; width=&quot;416&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;(이미지 출처:&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;http://kafka.apache.org/081/documentation.html&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Apache Kafka 0.8.1 Documentation&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;위의 그림은 하나의 topic이 3개의 partition에 분산되어 순차적으로 저장되는 모습을 보여주고 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;각 partition은 0부터 1씩 증가하는 offset 값을 메시지에 부여하는데 이 값은 각 partition내에서 메시지를 식별하는 ID로 사용된다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Offset 값은 partition마다 별도로 관리되므로 topic내에서 메시지를 식별할 때는 partition 번호와 offset 값을 함께 사용한다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;Partition의 분산&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:537px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/2558363F5509180F25&quot; filemime=&quot;image/jpeg&quot; filename=&quot;partition1.png&quot; height=&quot;246&quot; width=&quot;537&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6666669845581px; line-height: 22px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6666669845581px; line-height: 22px;&quot;&gt;위의 그림에서는 3개의 broker로 이루어진 클러스터에서 하나의 topic이 3개의 partition P0, P1, P2로 분산되어 저장되어 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6666669845581px; line-height: 22px;&quot;&gt;Producer가 메시지를 실제로 어떤 partition으로 전송할지는 사용자가 구현한 partition 분배 알고리즘에 의해 결정된다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 14.6666669845581px; line-height: 22px;&quot;&gt;예를 들어 라운드-로빈 방식의 partition 분배 알고리즘을 구현하여 각 partition에 메시지를 균등하게 분배하도록 하거나,&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 14.6666669845581px; line-height: 22px;&quot;&gt;메시지의 키를 활용하여 알파벳 A로 시작하는 키를 가진 메시지는 P0에만 전송하고, B로 시작하는 키를 가진 메시지는 P1에만 전송하는 형태의 구성도 가능하다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14.6666669845581px; line-height: 22px;&quot;&gt;좀 더 복잡한 예로써 사용자 ID의 CRC32값을 partition의 수로 modulo 연산을 수행하여(CRC32(ID) % partition의 수) 동일한 ID에 대한 메시지는 동일한 partition에 할당되도록 구성할 수도 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;Partition의 복제&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Kafka에서는 고가용성을 위하여 각 partition을 복제하여 클러스터에 분산시킬 수 있다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;아래의 그림은 해당 topic의 replication factor를 3으로 설정한 상태의 클러스터이다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;각 partition들은 3개의 replica를 가지며 각 replica는 R0, R1, R2로 표시되어 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:535px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/2655FB425509181D07&quot; filemime=&quot;image/jpeg&quot; filename=&quot;partition2.png&quot; height=&quot;239&quot; width=&quot;535&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Replication factor를 N으로 설정할 경우 N개의 replica는 1개의 leader와 N-1개의 follower로 구성된다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;위의 그림에서는 각 partition마다 하나의 leader(붉은색)가 존재하며 2개의 follower(푸른색)가 존재한다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;각 partition에 대한 읽기와 쓰기는 모두 leader에서 이루어지며, follower는 단순히 leader를 복제하기만 한다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;만약 leader에 장애가 발생할 경우 follower 중 하나가 새로운 leader가 된다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Kafka의 복제 모델인 &lt;/span&gt;&lt;a href=&quot;http://kafka.apache.org/081/documentation.html#replication&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot; style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;ISR 모델&lt;/a&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;은 f+1개의 replica를 가진 topic이 f개의 장애까지 버틸 수 있도록 한다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Leader에서만 읽기와 쓰기를 수행한다고 하면 부하 분산이 되지 않는다고 생각할 수 있는데,&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;각 partition의 leader가 클러스터 내의 broker들에 균등하게 분배되도록 알고리즘이 설계되어 있기 때문에 부하는 자연스럽게 분산이 된다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;위의 그림처럼 3개의 broker에 P0, P1, P2의 leader가 균등하게 분배되므로 부하 또한 자연스럽게 분산되게 된다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;Consumer와 Consumer Group&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;메시징 모델은 크게 큐(queue) 모델과 발행-구독(publish-subscribe) 모델로 나뉜다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;큐 모델은 메시지가 쌓여있는 큐로부터 메시지를 가져와서 consumer pool에 있는 consumer 중 하나에 메시지를 할당하는 방식이고,&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;발행-구독 모델은 topic을 구독하는 모든 consumer에게 메시지를 브로드캐스팅하는 방식이다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Kafka에서는 consumer group이라는 개념을 도입하여 두가지 모델을 발행-구독 모델로 일반화하였다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Kafka의 partition은 consumer group당 오로지 하나의 consumer의 접근만을 허용하며, 해당 consumer를 partition owner라고 부른다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;따라서 동일한 consumer group에 속하는 consumer끼리는 동일한 partition에 접근할 수 없다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;한 &lt;span style=&quot;font-size: 11pt;&quot;&gt;번 정해진 partition owner는 broker나 consumer 구성의 변동이 있지 않는한 계속 유지된다.&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Consumer가 추가/제거되면 추가/제거된 consumer가 속한 consumer group 내의 consumer들의 partition 재분배(rebalancing)가 발생하고&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;broker가 추가/제거되면 전체 consumer group에서 partition 재분배가 발생한다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Consumer group을 구성하는 consumer의 수가 partition의 수보다 작으면 하나의 consumer가 여러 개의 partition을 소유하게 되고,&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;반대로 consumer의 수가 partition의 수보다 많으면 여분의 consumer는 메시지를 처리하지 않게되므로 partition 개수와 consumer 수의 적절한 설정이 필요하다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:474px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/224151445509186D25&quot; filemime=&quot;image/jpeg&quot; filename=&quot;consumer-groups.png&quot; height=&quot;252&quot; width=&quot;474&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;(이미지 출처:&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;http://kafka.apache.org/081/documentation.html&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Apache Kafka 0.8.1 Documentation&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;위의 그림과 같이 consumer group에 다수의 consumer를 할당하면 각 consumer마다 별도의 partition으로부터 메시지를 받아오기 때문에,&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;(producer가 각 partition에 메시지를 균등하게 분배한다고 가정&lt;/span&gt;할 경우) consumer group은 큐 모델로 동작하게 된다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;단일 consumer로 이루어진 consumer group을 활용하면 다수의 consumer가 동일한 partition에 동시에 접근하여 동일한 메시지를 액세스하기 때문에 발행-구독 모델을 구성할 수 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;이처럼 하나의 consumer에 의하여 독점적으로 partition이 액세스 되기 때문에 동일 partition 내의 메시지는 partition에 저장된 순서대로 처리된다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;만약 특정 키를 지닌 메시지가 발생 시간 순으로 처리되어야 한다면 partition 분배 알고리즘을 적절하게 구현하여&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;특정 키를 지닌 메시지는 동일한 partition에 할당되어 단일 consumer에 의해 처리되도록 해야한다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;그러나 다른 partition에 속한 메시지의 순차적 처리는 보장되어 있지 않기 때문에,&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;특정 topic의 전체 메시지가 발생 시간 순으로 처리되어야 할 경우 해당 topic이 하나의 partition만을 가지도록 설정해야 한다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14pt;&quot;&gt;파일 시스템을 활용한 고성능 디자인&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Kafka는 기존 메시징 시스템과는 달리 메시지를 메모리대신 파일 시스템에 쌓아두고 관리한다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;기존 메시징 시스템에서는 파일 시스템은 메시지의 영속성을 위해서 성능 저하를 감수하면서도 어쩔 수 없이 사용해야하는 애물단지 같은 존재였다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;그러나 Kafka는 이런 편견을 깨고 파일 시스템을 메시지의 주 저장소로 사용하면서도 기존의 메시징 시스템보다 뛰어난 성능을 보여준다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:766px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/264EE6445509188C1A&quot; filemime=&quot;image/jpeg&quot; filename=&quot;bm.jpg&quot; height=&quot;526&quot; width=&quot;766&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;(이미지 출처:&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 14.6666669845581px; line-height: 22px;&quot;&gt;&lt;a href=&quot;http://queue.acm.org/detail.cfm?id=1563874&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;The Pathologies of Big Data&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;일반적으로 하드디스크는 메모리보다 수백-수천 배 이상 느리다. 그러나 특정 조건에서는 메모리보다 10배 이내로 느리거나 심지어는 빠를 수도 있다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;ACM Queue에 게재된&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;http://queue.acm.org/detail.cfm?id=1563874&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot; style=&quot;font-size: 14.6666669845581px; line-height: 22px; text-align: center;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;The Pathologies of Big Data&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;라는 글에 따르면&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;하드디스크의 순차적 읽기 성능은 메모리에 대한 랜덤 읽기 성능보다 뛰어나며 메모리의 순차적 읽기 성능보다 7배 정도 느리다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;(물론 하드디스크의 랜덤 읽기 성능은 메모리의 랜덤 읽기 성능보다 10만배나 느리다.)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Kafka는 메모리에 별도의 캐시를 구현하지 않고 OS의 페이지 캐시에 이를 모두 위임한다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;OS가 알아서 서버의 유휴 메모리를 페이지 캐시로 활용하여 앞으로 필요할 것으로 예상되는 메시지들을 미리 읽어들여(readahead) 디스크 읽기 성능을 향상 시킨다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Kafka의 메시지는 하드디스크로부터 순차적으로 읽혀지기 때문에 하드디스크의 랜덤 읽기 성능에 대한 단점을 보완함과 동시에 OS 페이지 캐시를 효과적으로 활용할 수 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;메시지를 파일 시스템에 저장함으로써 얻는 부수적인 효과도 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;메시지를 메모리에 저장하지 않기 때문에 메시지가 JVM 객체로 변환되면서 크기가 커지는 것을 방지할 수 있고 JVM의 GC로인한 성능저하 또한 피할 수 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Kafka 프로세스가 직접 캐시를 관리하지 않고 OS에 위임하기 때문에 프로세스를 재시작 하더라도 OS의 페이지 캐시는 그대로 남아있기 때문에 프로세스 재시작 후 캐시를 워밍업할 필요가 없다는 장점도 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;마지막으로 Kafka에서는 파일 시스템에 저장된 메시지를 네트워크를 통해 consumer에게 전송할 때 &lt;/span&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/linux/library/j-zerocopy/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot; style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;zero-copy&lt;/a&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;기법을 사용하여 데이터 전송 성능을 향상시켰다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;일반적으로 파일 시스템에 저장된 데이터를 네트워크로 전송할 땐 아래와 같이 커널모드와 유저모드 간의 데이터 복사가 발생하게 된다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:420px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/2623073E550918D608&quot; filemime=&quot;image/gif&quot; filename=&quot;traditional-copy.gif&quot; height=&quot;368&quot; width=&quot;420&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;(이미지 출처:&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/linux/library/j-zerocopy/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Efficient data transfer through zero copy&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;유저모드로 카피된 데이터를 어플리케이션에서 처리한 뒤 처리된 데이터를 네트워크로 전송한다면 위의 그림과 같이 커널모드와 유저모드 간의 데이터 복사는 당연히 필요하다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;그러나 어플리케이션에서의 별도 처리 없이 파일 시스템에 저장된 데이터 그대로 네트워크로 전송만 한다면 커널모드와 유저모드 간의 데이터 복사는 불필요한 것이 된다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;Zero-copy 기법을 사용하면 위에서 언급한 커널모드와 유저모드 간의 불필요한 데이터 복사를 피할 수 있다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;이 기법을 사용하면 아래와 같이 파일 시스템의 데이터가 유저모드를 거치지 않고 곧바로 네트워크로 전송된다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/library/j-zerocopy/#N1019B&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;벤치마크 결과&lt;/a&gt;에 따르면 zero-copy를 사용한 경우가 그렇지 않은 경우보다 전송 속도가 2-4배 빠른 것으로 나타났다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:350px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/2157B43D5509190B21&quot; filemime=&quot;image/gif&quot; filename=&quot;zero-copy.gif&quot; height=&quot;312&quot; width=&quot;350&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;(이미지 출처:&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/linux/library/j-zerocopy/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Efficient data transfer through zero copy&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 18pt;&quot;&gt;&lt;b&gt;참고자료&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul style=&quot;list-style-type: disc;&quot;&gt;&lt;li&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 14.6666669845581px;&quot;&gt;&lt;a href=&quot;http://kafka.apache.org/081/documentation.html&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Kafka 0.8.1 Documentation&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 14.6666669845581px;&quot;&gt;&lt;span style=&quot;font-size: 14.6666669845581px;&quot;&gt;&lt;a href=&quot;http://research.microsoft.com/en-us/UM/people/srikanth/netdb11/netdb11papers/netdb11-final12.pdf&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Kafka: A distributed messaging system for log processing&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 14.6666669845581px;&quot;&gt;&lt;span style=&quot;font-size: 14.6666669845581px;&quot;&gt;&lt;span style=&quot;font-size: 14.6666669845581px;&quot;&gt;&lt;a href=&quot;http://www.slideshare.net/baniuyao/kafka-24299168&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Something about Kafka - Why Kafka is so fast&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>Programming Insight</category>
<category>kafka</category>
<category>메시지 큐</category>
<category>메시징 시스템</category>
<category>미들웨어</category>
<category>카프카</category>
<author>epicdev</author>
<guid>https://epicdevs.com/17</guid>
<comments>https://epicdevs.com/17#entry17comment</comments>
<pubDate>Sun, 08 Mar 2015 17:12:44 +0900</pubDate>
</item>
<item>
<title>Java와 WAS의 클래스로딩 메커니즘의 차이</title>
<link>https://epicdevs.com/16</link>
<description>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://cfs.tistory.com/custom/blog/154/1543390/skin/images/epicdevs-mobile.css&quot;&gt;
&lt;p&gt;&lt;span style=&quot;font-size:11pt;&quot;&gt;Java에서 클래스로더가 클래스나 리소스를 찾을 땐 부모 클래스로더에게 우선 이를 위임하게 된다. 그래서 부모 클래스로더가 해당 클래스나 리소스를 찾을 수 없게되면 자신이 직접 해당 클래스나 리소스를 찾는 형태로 동작하게 된다. 아래는 이와 관려련하여&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Java 7의 API문서&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;에서 발췌한 내용이다.&lt;/span&gt;&lt;/p&gt;&lt;div class=&quot;alert alert-info&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself.&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 22px; background-color: transparent;&quot;&gt;클래스로더&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;가 복수개 존재할 때 공통으로 사용되는&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;클래스나 리소스들을 모두 각자 로딩한&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;다면 해당 자원들을 중복되게 로딩함으로써&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;JVM의&amp;nbsp;permanent generation를 낭비하게 된다&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;. 하지만 부모&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 22px;&quot;&gt;클래스로더&lt;/span&gt;&lt;span style=&quot;font-size: 9pt; line-height: 1.5; background-color: transparent;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;에서 해당 자원들을 먼저 찾는 방식으로 동작할 경우&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 9pt; line-height: 1.5; background-color: transparent;&quot;&gt;&lt;span style=&quot;font-size:11pt;&quot;&gt;복수개 클래스로더의&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;부모&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;가 모두 같을 경우 부모&lt;/span&gt;&lt;span style=&quot;font-size:11pt;&quot;&gt;에&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;로드된 자원을 함께 사용하게 되므로 자원의 낭비를 막을 수 있다. 이러한 방식의 클래스로딩 메커니즘을 &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;parent-first / child-last 방식&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;이라고 명명하도록 하겠다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 9pt; line-height: 1.5; background-color: transparent;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;하지만 WAS에서는 parent-first / child-last 방식을 사용하지 않는다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:196px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/276ED53553E8E93137&quot; filemime=&quot;image/jpeg&quot; filename=&quot;이미지 1.png&quot; height=&quot;132&quot; width=&quot;196&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;(이미지 출처:&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;a href=&quot;http://tomcat.apache.org/tomcat-8.0-doc/class-loader-howto.html&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Tomcat 클래스로더 How-to&lt;/a&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5; background-color: transparent;&quot;&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 22px; background-color: transparent;&quot;&gt;대표적은 WAS인 Tomcat의 클래스로더 계층구조는 위의 그림과&amp;nbsp;같다.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 22px;&quot;&gt;만약 WAS에서 Java와 같은 parent-first / child-last 방식의 클래스&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 22px;&quot;&gt;로딩 메커니즘을 사용할 경우 각각의 웹앱들은&amp;nbsp;Common 클래스로더에서 로딩된 클래스를 함께 사용하게 된다. 즉, WAS의 lib 폴더에 존재하는 클래스들을 모든 웹앱에서 함께 사용하게 되어버린다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; line-height: 22px;&quot;&gt;웹앱&amp;nbsp;개발 시에 A라는 라이브러리&lt;/span&gt;&lt;span style=&quot;font-size: 9pt; line-height: 1.5; background-color: transparent;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;의 최신 버전인 2.0 버전을 사용했다고 하자. 개발과 검증을 모두 완료하고 해당 웹앱을 WAS에 배포했는데&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 22px; background-color: transparent;&quot;&gt;만약&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 22px; background-color: transparent;&quot;&gt;Common 클래스로더에 이미&amp;nbsp;A라는 라이브러리의 1.0 버전이 로딩되어 있다면 어떻게 될 것인가?&amp;nbsp;1.0과 2.0의 클래스 명(패키지 경로 포함)이 같고 기능이 바뀌었다면&amp;nbsp;2.0기반에서 작업된&amp;nbsp;웹앱은 제대로 동작하지 않을 것이다. 이&lt;/span&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px; background-color: transparent;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;와 같은 문제가 발생할 수 있기 때문에 &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;WAS에서는 parent-first / child-last 방식의 클래스로딩 메커니즘이 아닌 parent-last / child-first 방식의 클래스로딩 메커니즘을 사용&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;한다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;참고로 Tomcat에서는 아래와 같은 순서로 클래스로더를 사용한다. (엄밀히 말하면 parent-last / child-first가 아니라 Common과 웹앱만 순서가 바뀐 것이다.)&lt;/span&gt;&lt;/p&gt;&lt;ul style=&quot;list-style-type: square;&quot;&gt;&lt;li&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;Bootstrap&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;System&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;/WEB-INF/classes&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;/WEB-INF/lib/*.jar&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;Common&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;2014.08.12 추가&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Tomcat이 아닌 다른 WAS들의 경우 모두 parent-last / child-first 방식을 디폴트로&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;따르는 것은 아닌 것 같다. 하지만 그런 WAS들의 경우 어떤 클래스로딩 메커니즘 방식을 사용할지 설정할 수 있다. 자체 서비스를 하는 기업의 경우 이런 설정을 자신들이 변경할 수 있지만 WAR 패키지로 판매하는 제품을 만드는 기업의 경우 WAS의 클래스로딩 메커니즘 설정에 따라 충돌이 발생할 수 있기 때문에 주의해야 한다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 9pt; line-height: 1.5; background-color: transparent;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;b&gt;참고 자료&lt;/b&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;&lt;a href=&quot;http://stackoverflow.com/questions/5650334/java-classloaders-why-search-the-parent-classloader-first&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;왜 Java 클래스로더는 parent-first / child-last 방식인가?&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 9pt; line-height: 1.5; background-color: transparent;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;a href=&quot;http://stackoverflow.com/questions/5445511/how-do-i-create-a-parent-last-child-first-classloader-in-java-or-how-to-overr&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;parent-last / child-first 클래스로더 구현 방법&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 9pt; line-height: 1.5; background-color: transparent;&quot;&gt;&lt;span style=&quot;font-size:11pt;&quot;&gt;&lt;a href=&quot;http://tomcat.apache.org/tomcat-8.0-doc/class-loader-howto.html&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Tomcat 클래스로더 How-to&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 9pt; line-height: 1.5; background-color: transparent;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Java 7 API 문서&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;</description>
<category>Programming Insight</category>
<category>java</category>
<category>Tomcat</category>
<category>WAS</category>
<category>클래스로더</category>
<author>epicdev</author>
<guid>https://epicdevs.com/16</guid>
<comments>https://epicdevs.com/16#entry16comment</comments>
<pubDate>Tue, 12 Aug 2014 01:19:47 +0900</pubDate>
</item>
<item>
<title>Java Performance Fundamental - 김한도</title>
<link>https://epicdevs.com/15</link>
<description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:293px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/274E7E4952D9577D25&quot; filemime=&quot;image/jpeg&quot; filename=&quot;L.jpg&quot; height=&quot;400&quot; width=&quot;293&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;a href=&quot;http://www.yes24.com/24/goods/3577335&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Java Performance Fundamental - 김한도&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Java 프로그래밍을 몇 년간 해 오면서도 JVM이 내부적으로 어떻게 돌아가는지 이해하고 있는 Java 개발자들은 많지 않다. 나도 몇몇 서적들에서 JVM이나 GC에 대해 피상적으로 다루는 내용들은 숙지하고 있었다. 하지만&amp;nbsp;누가 설명을 하라고 하면 추상적인 수준이 아닌&amp;nbsp;구현체 수준에서의 설명은 전혀 하지 못하는 수준이었다.&amp;nbsp;그래서 실제 JVM 구현체가&amp;nbsp;내부적으로 어떻게 동작하는지&amp;nbsp;다루고 있다는 국문 서적이 있다는 정보를 입수하고 이 책을 구매하게 되었다.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;이 책은 다음의 7개의 챕터로 이루어져 있다.&lt;/span&gt;&lt;/p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;
&lt;/span&gt;&lt;blockquote&gt;&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;1. Java virtual machine&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;2. Runtime d&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;ata areas&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;3. Garbage collection&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;4. Class loader&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;5. Execution Engine&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;6. Thread synchronization&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;7. Oracle as datasource&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;
&lt;/span&gt;&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;span style=&quot;background-color: transparent; font-size: 11pt;&quot;&gt;이 책의 각&amp;nbsp;챕터들은 챕터의 주제들에대해&lt;/span&gt;&lt;span style=&quot;background-color: transparent; font-size: 11pt;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;background-color: transparent; font-size: 11pt;&quot;&gt;추상적인 JVM이 어떤 알고리즘에 의해 동작하는지 설명한 뒤 실제 구현체인&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;background-color: transparent; font-size: 11pt;&quot;&gt;HotSpot JVM과 IBM JVM이 내부적으로 어떻게 동작하는지 설명하고 있다. 나 같은 경우엔 추상적인 JVM과 HotSpot JVM에 대해서만 읽었다. (IBM JVM은 내가 당분간 혹은 평생&amp;nbsp;다룰 일이 없을 것 같아서 스킵하였다)&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;책은 상당히 깊은&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;내용을 다루고 있다. 내가 기대했던 것보다 훨씬. 그래서 좋았던 것도 있고 좋지 않았던 것도 있다.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;일단 좋았던 점은 대부분의 책들에서 피상적으로만 다루는 Runtime data areas나 G&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;arbage collection에 대해서 &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;완전 상세히 &lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;서술해 놓았다는 것이다. 이런 내용들은 사실 책으로는 여태껏 접할 수 없었고 Oracle 사이트&amp;nbsp;같은 곳에서만 접할 수 있었기에 상당히 유익했다. 하지만 한편으로는&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;background-color: transparent; font-size: 11pt; line-height: 1.5;&quot;&gt;저자만의 독자적인 해설 방법이 없었기에 차라리&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;background-color: transparent; font-size: 11pt; line-height: 1.5;&quot;&gt;Oracle 사이트를 읽는 것이 낫지 않을까 하는 생각을 불러일으키기도 했다. 그리고 기술서적을 읽는다기 보다는 전공서적을 읽는다는 느낌이 강했다. 나 같은 경우엔 이런 서적들을 읽을 때는 핵심만 기억해두고 금방 까먹을 것 같은 내용들은 그리 상세하게 읽지 않는다. 그런 나의 독서 스타일에 의해 이 책의 절반 정도는 그냥 스킵되어버렸다... 그냥&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px; background-color: transparent;&quot;&gt;이 책에서 잘 다루고 있는 부분만 요약해서 발표자료 100장 정도로 만들어서&amp;nbsp;가지고 있으면 딱 좋을 것 같다.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;span style=&quot;background-color: transparent; font-size: 11pt; line-height: 1.5;&quot;&gt;여튼 이 책은 JVM의 내부 구조를 자세히 알고 싶은 개발자가 읽으면 좋다. 하지만 실무에서는 얼마나 도움이 될지는 잘 모르겠다. 각 챕터의 앞쪽 절반&amp;nbsp;정도는 기억해두면&amp;nbsp;실무에서 어느 정도 도움이 될 것 같다. 하지만 나머지는&amp;nbsp;실무에서 전혀 겪지 못하는 것들이 대부분이기 때문에, 이런 내용들은 누가 옆에서 JVM에 대해서 좀 아는척하면 콧방귀를 뀌면서 더 아는척을 하는 데 말고는 유용하게 쓰이기가 힘들 것 같다... 아니면 직접 JVM을 구현한다거나...&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;span style=&quot;background-color: transparent; font-size: 11pt; line-height: 1.5;&quot;&gt;결론은 이 책은 한 번 정도 읽어 볼 가치는 있으나 발췌독 후 레퍼런스로 책장에 꽂아 놓는 것을 추천하는 바이다.&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left; clear: none; float: none;&quot;&gt;&lt;span style=&quot;background-color: transparent; font-size: 11pt; line-height: 1.5;&quot;&gt;(이런 내용들을 직접 찾아보려면 검색 키워드들을 알고&amp;nbsp;있어야 하고, 키워드들을&amp;nbsp;안다고 하더라도 내용들 찾아보기도 귀찮고 또한 내용들&amp;nbsp;모두 영문으로 되어있는데, 이 책은 그런 것들이 국문으로 정리되어 있기에 레퍼런스의 가치는 한다고 본다)&lt;/span&gt;&lt;/p&gt;</description>
<category>Books</category>
<category>java</category>
<category>JVM</category>
<author>epicdev</author>
<guid>https://epicdevs.com/15</guid>
<comments>https://epicdevs.com/15#entry15comment</comments>
<pubDate>Sat, 18 Jan 2014 01:44:32 +0900</pubDate>
</item>
<item>
<title>객체 지향과 디자인 패턴 - 최범균</title>
<link>https://epicdevs.com/14</link>
<description>&lt;p&gt;&lt;div&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://cfs.tistory.com/custom/blog/154/1543390/skin/images/epicdevs-mobile.css&quot;&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:307px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/222F083D52D5D82804&quot; filemime=&quot;image/jpeg&quot; filename=&quot;L.jpg&quot; height=&quot;400&quot; width=&quot;307&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.yes24.com/24/Goods/9179120?Acode=101&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot; style=&quot;font-size: 15px; line-height: 22px; background-color: transparent;&quot;&gt;개발자가 반드시 정복해야 할 객체 지향과 디자인 패턴 - 최범균&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; background-color: transparent; line-height: 1.5;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt; background-color: transparent; line-height: 1.5;&quot;&gt;회사 책꽂이에 있던 책인데 두께가 얇팍하니 한 3시간이면 다 읽을 수 있을 것 같아서,&amp;nbsp;오랜만에 객체 지향과 디자인 패턴에 대한 복습도 할 겸 대여한 책이다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;실제 독서시간은 예상한 대로 3시간 정도였다. 대부분 아는 내용이라서 예전의 기억을 떠올리는 용도로 사용하기에 딱 좋은 책이었던 것 같다. 내용의 난이도는 객체지향과 패턴에 눈을 뜨기 시작한&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;초/중급 개발자&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;에게 알맞은 것 같다. 하지만 내용에 대한 심도는 그리 깊지 않아서 객체 지향과 디자인 패턴을 다루는 다른 책을 한 권 읽은 후 복습용으로 읽기에 딱 좋은 책인 것 같다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;책을 읽으면서&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;좋았던 부분&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;은 SOLID와 DI/Service Locator를 다루는 챕터들, 그리고&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;SLF4J나 JDBC를 가지고&amp;nbsp;책에서 다루는 디자인 패턴의 실례로써 설명했던 점이다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;반 농담조로 말하자면 이 책에서 가장 좋았던&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;부분은 &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Appendix A. 추천 자료&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size:11pt;&quot;&gt; 파트이다. 개발자들이 필독해야 할 서적들을 나열하고 있는데 나 또한 2권&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;을 제외하고는 모두 소장하고 있는 책들이었다. 그 리스트는 아래와 같다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;좋은 설계와 디자인 패턴에 대한 더 깊은 지식을 원한다면 아래 책들을 읽어보자.&lt;/span&gt;&lt;/b&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;&lt;a href=&quot;http://www.yes24.com/24/goods/2594543?scode=032&amp;amp;OzSrank=2&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;GOF의 디자인 패턴 - Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;&lt;a href=&quot;http://www.yes24.com/24/Goods/2127215?Acode=101&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;실전 코드로 배우는 실용주의 디자인 패턴 - Allen Holub&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;&lt;a href=&quot;http://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Agile Software Development, Principles, Patterns, and Practices - Robert C. Martin&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;좋은 설계는 좋은 코드로부터 나온다. 좋은 코드를 작성하는 방법이 궁금하다면 다음 책을 참고하자.&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;&lt;a href=&quot;http://www.yes24.com/24/goods/2824034?scode=032&amp;amp;OzSrank=3&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;켄트 벡의 구현 패턴 - Kent Beck&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;&lt;a href=&quot;http://www.yes24.com/24/goods/3384342?scode=032&amp;amp;OzSrank=3&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;이펙티브 자바&amp;nbsp;- Joshua Bloch&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;&lt;a href=&quot;http://www.yes24.com/24/goods/11681152?scode=032&amp;amp;OzSrank=2&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Clean Code 클린 코드: 애자일 소프트웨어 장인 정신 - Robert C. Martin&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;다음은 코드를 점진적으로 개선하고 좋은 설계로 바꿔 나가는데 도움을 주는 책이다.&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;&lt;a href=&quot;http://www.yes24.com/24/goods/7951038?scode=032&amp;amp;OzSrank=1&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;리팩토링: 코드 품질을 개선하는 객체지향 사고법 - Martin Fowler&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;&lt;a href=&quot;http://www.yes24.com/24/goods/1437218?scode=032&amp;amp;OzSrank=1&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;테스트 주도 개발: Test-Driven Development - Kent Beck&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;&lt;a href=&quot;http://www.yes24.com/24/Goods/3092523?Acode=101&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;레거시 코드 활용 전략 - Michael Feathers&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;마지막으로 작성한 코드의 설계를 공유하거나 설계 초안을 만들 때 사용되는 다이어그램 작성 방법을 빠르게 익히고 싶다면 아래 책이 제격이다.&lt;/span&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px;&quot;&gt;&lt;a href=&quot;http://www.yes24.com/24/goods/1810885?scode=032&amp;amp;OzSrank=3&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;UML Distilled: 표준 객체 모델링 언어 입문 - Martin Fowler&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span style=&quot;font-size:11pt;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:11pt;&quot;&gt;어쩌면 내가 위의 리스트에 있는 책들을 대부분 읽어보았기 때문에 이 책을 읽으면서 옛날에 공부했던 것들을 복습할 수 있었던 것 같다&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;.&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 15px; line-height: 22px; background-color: transparent;&quot;&gt;(사실 위의 책들을 다 읽었다면 이 책은 읽지 않아도 될 것 같다.&amp;nbsp;아니면 위 책의&amp;nbsp;내용들을 복합적으로 복습하는 용으로 이 책을 읽거나...)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;결론은 어느정도 객체 지향과 디자인 패턴에 대해 아는 초/중급&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;개발자가 짧은 시간 내에 복습을 원할 경우 읽어보면 괜찮은 책인 것 같다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:11pt;&quot;&gt;참고로 나는 디자인 패턴 입문 서적으로&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;http://www.yes24.com/24/Goods/1778966?Acode=101&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Head First Design Patterns&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;를 강추한다. 주변에서 물어보면 무조건 이 책을 추천한다. 개인적으로 Head First 시리즈는 서술이 너무 장황해서&amp;nbsp;그다지 좋아하지 않는데, 디자인 패턴의 경우 오히려 이러한 점이 장점으로&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; background-color: transparent; line-height: 1.5;&quot;&gt;작용한 것 같다. (2005년에 졸트상도 수상했고, 아마존을 비롯한 국내 인터넷 서점들에 존재하는 디자인 패턴 책들 중 가장 많은 별점이 있는 것만으로도&amp;nbsp;이미 책의 퀄리티를 예상할 수 있다.)&lt;/span&gt;&lt;/p&gt;</description>
<category>Books</category>
<category>객체지향</category>
<category>디자인패턴</category>
<author>epicdev</author>
<guid>https://epicdevs.com/14</guid>
<comments>https://epicdevs.com/14#entry14comment</comments>
<pubDate>Thu, 16 Jan 2014 02:16:25 +0900</pubDate>
</item>
<item>
<title>훌륭한 목수(개발자)는 연장을 탓하지 않는다?</title>
<link>https://epicdevs.com/13</link>
<description>&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://cfs.tistory.com/custom/blog/154/1543390/skin/images/epicdevs-mobile.css&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&quot;훌륭한 목수는 연장을 탓하지 않는다&quot;라는 속담이 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;background-color: transparent; font-size: 11pt; line-height: 1.5;&quot;&gt;그런데 이 속담의 함정은 &quot;&lt;/span&gt;&lt;b style=&quot;background-color: transparent; font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;훌륭한 목수는 자신들이 즐겨 사용하는 좋은&amp;nbsp;연장이 있다&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;background-color: transparent; font-size: 11pt; line-height: 1.5;&quot;&gt;&quot;는 점이다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;background-color: transparent; font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;background-color: transparent; font-size: 11pt; line-height: 1.5;&quot;&gt;만약 &quot;연장&quot;이라는 것이 기량과 전혀 관계가 없다면 유명한 연주자들이 왜 수억 원 짜리 악기를 사겠는가? 유명한 운동선수들이 왜 좋은 장비를 사용하겠는가?&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;background-color: transparent; font-size: 11pt; line-height: 1.5;&quot;&gt;자신의 기량을 향상시키려고 노력하다보면 어느 순간 자신의 기량에 영향을 주는 외적인 것들에 관심이 가게된다. 가령, 긍정적으로는 &quot;나는 이 장비보다 더 좋은 걸 쓰면 성적이 더 나올 것 같아&quot;라거나 부정적으로는 &quot;나는 이 장비가 내 실력을 못 따라와서 성적이 더 이상 오르지 않아&quot;처럼.&amp;nbsp;그러면서 결국 선수&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;background-color: transparent; font-size: 11pt; line-height: 1.5;&quot;&gt;자신의 기량이 올라갈&amp;nbsp;수록 장비도 함께 좋아지고, 결국 자신의 기량이 정점을 찍을 때 장비 또한 정점을 찍게 되는 것 같다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;background-color: transparent; font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;background-color: transparent; font-size: 11pt; line-height: 1.5;&quot;&gt;이제 본론으로 돌아와서 개발자의 이야기를 해보자.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;개발자의 연장이라고 한다면 개발자의 PC와 관계된 CPU, 메모리, OS 등등부터 시작해서 개발자와 물리적으로 접촉하는 키보드, 마우스, 모니터 등이 있다. 이 글에서는 개발자와 물리적으로 접촉하는 장비들 중 키보드와 마우스에 대해서만 언급할&amp;nbsp;것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;background-color: transparent; font-size: 11pt; line-height: 1.5;&quot;&gt;Richard Stallman과 Bjarne Stroustrup은&lt;/span&gt;&lt;span style=&quot;background-color: transparent; font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;http://www.leopold.co.kr/?doc=cart/item.php&amp;amp;it_id=1144826998&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;해피해킹&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;을 즐겨쓴다. 사진을 보면 뭔가 키가 많이 빠진 듯한 흰색 키보드가 해피해킹이다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;(나 같은 경우는 주로 Windows 환경에서 작업하기 때문에&amp;nbsp;방향키가 없는&amp;nbsp;해피해킹은 업무시간엔 쓸 수가 없는 제품이다... 언젠가 *NIX 환경에서 작업을 하게 된다면 하나 질러볼 생각이다.)&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:512px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/272E3F5052D5104F17&quot; filemime=&quot;image/jpeg&quot; filename=&quot;richard-stallman-happy-hacking-keyboard-2.jpg&quot; height=&quot;310&quot; width=&quot;512&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:512px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/216A705052D5105033&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Bjarne-Stroustrup-happy-hacking-keyboard.jpg&quot; height=&quot;310&quot; width=&quot;512&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;background-color: transparent; font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;스택 오버플로우의 공동 창립자이자 &lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;a href=&quot;http://www.codinghorror.com/blog/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Coding&lt;/a&gt;&lt;a href=&quot;http://www.codinghorror.com/blog/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&amp;nbsp;Horror&lt;/a&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;를 운영하는 Jeff Atwood는 심지어 자기 입맛에 딱 맞는 &lt;/span&gt;&lt;a href=&quot;http://www.codinghorror.com/blog/2013/08/the-code-keyboard.html&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;CODE&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;라는 키보드를 만들어버렸다. 키보드의 이름은 Jeff Atwood가 좋아하는 Charles Petzold의 명서 &lt;/span&gt;&lt;a href=&quot;http://www.yes24.com/24/Goods/4216805&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;CODE&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;에서 따온 것이라고 한다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;background-color: transparent; font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;(Jeff Atwood는 확실히 나와 생각이 비슷한 것 같다. 그의 책&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;background-color: transparent; font-size: 15px; line-height: 22px;&quot;&gt;&lt;a href=&quot;http://www.yes24.com/24/goods/8611802&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;코딩 호러의 이펙티브 프로그래밍&lt;/a&gt;을 읽어보면, 그가&amp;nbsp;듀얼모니터, 빠른 PC, 키보드/마우스, 편안한 의자등에 대해 매우 중요하게 생각하고 있다는 것을 알 수 있다. 참고로 여기서 말하는 편안한 의자는 가격이 ㅎㄷㄷ하다는&amp;nbsp;&lt;a href=&quot;http://www.hermanmiller.com/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;허먼밀러&lt;/a&gt;다. Jeff Atwood가 언급한 것들 대부분을 가지고 있지만 허먼밀러는&amp;nbsp;내 연봉으론 무리다... ㅠㅠ 그냥 나중에&amp;nbsp;&lt;a href=&quot;http://www.sidiz.com/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;시디즈&lt;/a&gt;나 하나 사야지...&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; background-color: transparent; line-height: 1.5;&quot;&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:720px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/2526FB4B52D516AA28&quot; filemime=&quot;image/jpeg&quot; filename=&quot;6a0120a85dcdae970b01901f0872ad970b-800wi.jpg&quot; height=&quot;245&quot; width=&quot;720&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;background-color: transparent; font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;background-color: transparent; font-size: 11pt; line-height: 1.5;&quot;&gt;이제 나의 이야기를 한 번 해보자.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;background-color: transparent; font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;나는 소위 &quot;장비빨&quot;로 생산성이 1%라도 오를 수 있다면 주저하지 않고 장비를 지르는 성격&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;이다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;아래의 사진은 내가 회사와 집에서 번갈아서 사용하는 &lt;/span&gt;&lt;a href=&quot;http://www.leopold.co.kr/?doc=cart/item.php&amp;amp;it_id=1339556197&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;리얼포스 87&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt; 키보드와 &lt;/span&gt;&lt;a href=&quot;http://www.razerzone.com/gaming-mice/razer-naga/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Razer Naga 게이밍 마우스&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;이다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;원래는 리얼포스 87 블랙과&amp;nbsp;Razer Naga 푸른색 한 쌍만 가지고 있었는데 출퇴근 하면서 들고 다니기가 너무 힘들어서 그냥 한 쌍을 더 사서 집에서만 쓰고있다. 사실 개인 프로젝트를 하려고 야심차게 장만했는데 거의 인터넷 서핑용으로만 쓰고 있다... (언젠가는 빛을 보겠지...)&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;요즘 기계식 키보드를 쓰는 사람들이 많이 늘어나서 좋은 키보드를 사용하는 것에 대한 의문점이 예전보다는 많이 줄었을 것이라 생각한다. 그런데 나는 키보드 말고&amp;nbsp;마우스도 쓸 데 없이(?) 화려한 것을 쓴다. 내가 쓰는 마우스는 사실 WOW같은 MMORPG에서 스킬을 쓰기 쉽도록 하기 위해 고안된 마우스이다. 마우스 좌측에 총 12개의 버튼이 달려있는데, 각 버튼을 누르면 스킬이 발동되는 형태로 게이머들이 많이 사용한다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;개발자들은 개발하는 도중에 마우스를 자주 사용하는 것을&amp;nbsp;좋지 않은 것으로 여기고 있다. 물론 나도 그렇게 생각한다. 개발하는 도중 키보드와 마우스를 번갈아 가면서 조작하다보면 코딩속도가&amp;nbsp;생각의 속도를 못 따라잡기 일쑤다. 하지만 내가 주로 사용하는 OS와 IDE는 마우스가 없으면 작업이 거의 불가능하다. 또, 인터넷을 쉴 새 없이 찾아보면서 코딩을 해야되기 때문에 마우스 조작없이는 코딩이 불가능하다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;그래서 생각해 낸 것이 바로 게이밍 마우스이다. &quot;&lt;b&gt;마우스를 사용하는 것이 불가피 하다면 마우스에서 최대한 손을 안 떼고 최대한 많은 작업을 마우스만으로 할 수 있게 된다면&amp;nbsp;어떨까&lt;/b&gt;&quot;하는 생각이 들었다. 그래서 선택한 것이 무시무시한 개수의 버튼이 붙어있는 Razer Naga 게이밍 마우스였다. 이 마우스에는 일반적인 마우스보다 버튼이 14개 더 붙어있다(좌측 12개 + 왼쪽 버튼 좌측에 2개). 나는 이 버튼들에다가 단축키나 매크로를 지정해서 사용한다. 그래서 코드를 네비게이션할 때나&amp;nbsp;인터넷 서핑시에&amp;nbsp;키보드 + 일반마우스 조합을 사용할 때의 속도를 게이밍 마우스 하나만으로 따라잡고있다.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:580px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/22603A4D52D516CB12&quot; filemime=&quot;image/jpeg&quot; filename=&quot;IMG_20131224_134012.jpg&quot; height=&quot;435&quot; width=&quot;580&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:580px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/217C0C4852D516E91F&quot; filemime=&quot;image/jpeg&quot; filename=&quot;299010_2254597836961_119760101_n.png&quot; height=&quot;298&quot; width=&quot;580&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;background-color: transparent; font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;background-color: transparent; font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;위에서 언급한&amp;nbsp;키보드/마우스는 작업하는데는 최고의 성능을 내지만 덩치가 크기 때문에 휴대하기가 힘들다. 그래서 어쩔 수 없이 출장/외근/카페에서 작업&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;할 때는 속터지는 노트북 키보드와 트랙패드로 작업을 했었다. 그러다가 작년에 레오폴드에서 &lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;http://www.leopold.co.kr/?doc=cart/item.php&amp;amp;it_id=1365736667&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot; style=&quot;font-size: 9pt; line-height: 1.5; background-color: transparent;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;FC660C&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;background-color: transparent; font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;라는 정전용량무접점 방식의 &quot;&lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;방향키가 달린&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&quot;(이게 가장 중요하다)&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;미니키보드를 출시하자마자 구매했다. 그래서 요즘&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&amp;nbsp;밖에서는 노트북 + 미니키보드 조합을 사용한다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:580px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/211D6B4B52D516FD2D&quot; filemime=&quot;image/jpeg&quot; filename=&quot;IMG_20140112_023240.jpg&quot; height=&quot;435&quot; width=&quot;580&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;background-color: transparent; font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;근 3년 동안 이 정도의 장비를 모으게 되었고 여태껏 전혀 후회해 본 적이 없다 (사실 미니키보드 사고 나서 키가 손에 안 익어서 적응할 때까지 좀&amp;nbsp;후회하긴 했다...)&lt;/span&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;.&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;background-color: transparent; font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;b&gt;하루종일 키보드랑 마우스 붙잡고 앉아서 입에 풀칠하고 사는데 적어도 하루종일 붙잡고 있는 것들이라도 좋은 것들로 맞춰야 되지 않겠는가?&lt;/b&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;background-color: transparent; font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;물론 이렇게 비싼 장비들을 사는 걸보고&lt;/span&gt;&lt;span style=&quot;font-size:11pt;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;돈지랄&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;한다는 사람들도 있긴하다. 나도 사실 처음에는 도대체 왜 몇십만원 짜리 키보드를 사는지 이해할 수 없었다. 그래서 왜 사람들이 이렇게 비싼 것들을 쓰는 건지 이유가 있지 않을까 싶어서 호기심에 리얼포스를 처음 구매하게 되었다. 그리고 결과는... 이제 리얼포스가 아니면 타이핑을 하기가 싫어질 정도가 되었다. 단순히 키감이 좋아서 또는&amp;nbsp;손이 편해서만이 아니다.&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; background-color: transparent; line-height: 1.5;&quot;&gt;&quot;&lt;/span&gt;&lt;b style=&quot;font-size: 11pt; background-color: transparent; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;키보드를 타이핑하는게 느낌이 너무 좋아서 코딩을 더 하고 싶은 마음&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt; background-color: transparent; line-height: 1.5;&quot;&gt;&quot;이 들 정도다&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; background-color: transparent; line-height: 1.5;&quot;&gt;. 이 정도의 동기부여만 된다고 해도 적어도 1% 이상의 개발 생산성은 오르는 것이 아닐까 생각한다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;</description>
<category>Developers</category>
<category>FC660C</category>
<category>개발</category>
<category>개발자</category>
<category>리얼포스</category>
<category>연장</category>
<category>장비</category>
<category>정전용량무접점</category>
<category>키보드</category>
<category>해피해킹</category>
<category>허먼밀러</category>
<author>epicdev</author>
<guid>https://epicdevs.com/13</guid>
<comments>https://epicdevs.com/13#entry13comment</comments>
<pubDate>Tue, 14 Jan 2014 20:50:50 +0900</pubDate>
</item>
<item>
<title>웹 프로그래머를 위한 서블릿 컨테이너의 이해 - 최희탁</title>
<link>https://epicdevs.com/12</link>
<description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:277px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/21555936520B64DE2A&quot; filemime=&quot;image/jpeg&quot; filename=&quot;L.jpg&quot; height=&quot;400&quot; width=&quot;277&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;a href=&quot;http://www.hanb.co.kr/ebook/look.html?isbn=9788979149685&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;웹 프로그래머를 위한 서블릿 컨테이너의 이해 - 최희탁&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;평소에 Tomcat이나 Jetty 같은 서블릿 컨테이너를 매일 개발에 사용하면서도 이들의 내부 구동 방식은 전혀 신경 쓰지 않았었다. 그래서인지 코딩을 하거나 디버깅을 하면서 현재 사용하고 있는 웹 프레임워크인 Struts나 Spring보다 좀 더 깊은 단계까지 들어가서 코드를 분석해야 할 경우 시작도 하기 전에 겁을 먹고 중단하기&amp;nbsp;일쑤였다. 이런 일들이 반복되면서&amp;nbsp;무의식 적으로 &lt;/span&gt;&lt;b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;서블릿 컨테이너는 내가 건드려 볼&amp;nbsp;수 없는 수준의 것들이다&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;라고 생각하고 여태껏&amp;nbsp;공부해 볼 생각을 전혀 하지 않았었다.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;그러다가 우연히 홍대의 한 서점에서 &lt;/span&gt;&lt;a href=&quot;http://www.yes24.com/24/goods/1456047?scode=032&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;톰캣 최종분석&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;이라는 책을 접하게 되었다. 이 책은 Tomcat이 내부적으로 어떻게 동작하는지 분석하는 책이었는데,&amp;nbsp;이 책을 처음 훑어&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;보고 든 생각은 &lt;/span&gt;&lt;b style=&quot;font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;서블릿 컨테이너도 사람이 만든 것이니 나도 충분히 분석할 수 있겠구나&lt;/span&gt;&lt;/b&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;라는 것이었다. 그래서 이런 류의 책들이 좀 더 있는지 살펴보다가 발견한 책이 바로 &lt;/span&gt;&lt;span style=&quot;font-size: 11pt; line-height: 1.5;&quot;&gt;이 책이다. 책의 두께도 그다지 두껍지 않았고 내용도 간결하게 설명이 되어있는 것 같아서, 톰캣 최종분석을 읽기 전에 배경지식을 쌓기위해&amp;nbsp;이 책을 읽게 되었다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;일단 이 책은 초보자가 볼만한 책은 아니다. 이 책을 제대로 이해하려면 JAVA를 이용한 네트워크 프로그래밍과&amp;nbsp;병렬 프로그래밍에 대해 어느 정도 지식이 있어야 한다. 또&amp;nbsp;평소에 서블릿 컨테이너를 사용해 본 경험이 어느정도 있어야 책의 내용이 좀 더 빨리 이해가 되고 머릿속에 와닿을 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;이 책은 HTTP 프로토콜에 응답하는 간단한 웹서버 제작을&amp;nbsp;시작으로, 책 마지막 쯤에는&amp;nbsp;직접 간단한&amp;nbsp;서블릿 컨테이너를 제작한다. 처음에는 술술 잘 따라가다가도&amp;nbsp;점점 예제 코드가 길어지고, 성능 향상을 위해&amp;nbsp;병렬 프로그래밍적 요소들이 하나 둘씩 등장하면서 예제를 따라가기가 점점 힘들어 진다. 하지만 그럴 수록 평소에 접하지 못했던 고급 프로그래밍 스킬들과 네트워크 프로그래밍 관련 지식들을 익힐 수 있었기 때문에 고생한 만큼 보람이 있었다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;책을 읽다보면 중간중간 쓸데 없는 내용들도 좀 포함되어 있긴 하지만&amp;nbsp;그런 것들 외에도 건질만한 것들이 매우 많았기 때문에 상당히 유익했던 독서라고 생각한다. 특히나 이 책을 통해서 서블릿 컨테이너가 내부적으로 어떻게 동작하는 지 알게 되었고, 서블릿 컨테이너에 대한 막연한 두려움도 사라지게 되었다.&amp;nbsp;이제 서블릿 컨테이너의 동작원리를 어느정도 알게 되었으니&amp;nbsp;다음 번엔&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;http://www.yes24.com/24/goods/1456047?scode=032&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot; style=&quot;font-size: 9pt; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;톰캣 최종분석&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;을 가지고&amp;nbsp;Tomcat의 내부 구조를&amp;nbsp;심도있게 공부해봐야겠다.&lt;/span&gt;&lt;/p&gt;</description>
<category>Books</category>
<category>java</category>
<category>jetty</category>
<category>jsp</category>
<category>Tomcat</category>
<category>서블릿</category>
<category>서블릿 컨테이너</category>
<category>웹 프로그래밍</category>
<author>epicdev</author>
<guid>https://epicdevs.com/12</guid>
<comments>https://epicdevs.com/12#entry12comment</comments>
<pubDate>Wed, 14 Aug 2013 20:41:17 +0900</pubDate>
</item>
</channel>
</rss>