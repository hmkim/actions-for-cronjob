<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
<title>구사과</title>
<link>https://koosaga.com/</link>
<description></description>
<language>ko</language>
<pubDate>Mon, 13 May 2019 01:21:24 +0900</pubDate>
<generator>TISTORY</generator>
<managingEditor>구사과</managingEditor>
<item>
<title>Peter Gabriel - Don't Give Up (ft. Kate Bush)</title>
<link>https://koosaga.com/230</link>
<description>&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/VjEq-r2agqc&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;(So, 1986)&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;https://genius.com/Peter-gabriel-dont-give-up-lyrics&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;가사&lt;/a&gt;&lt;/p&gt;</description>
<category>음악</category>
<author>구사과</author>
<guid>https://koosaga.com/230</guid>
<comments>https://koosaga.com/230#entry230comment</comments>
<pubDate>Wed, 27 Feb 2019 21:20:21 +0900</pubDate>
</item>
<item>
<title>Petrozavodsk Winter 2019 간단요약</title>
<link>https://koosaga.com/229</link>
<description>&lt;p&gt;뭐 했는지만 대충 알 수 있는 수준의 짧은 요약글로 정리하려고 한다. 다 쓰면 너무 길다.&lt;/p&gt;&lt;h2&gt;Day1&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A: NEERC 2018 B랑 매우 비슷한 General Matching.&lt;/li&gt;
&lt;li&gt;D: 특수한 그래프에서 weighted bipartite matching을 빠르게 계산하는 문제. weighted bipartite matching은 가중치가 큰 순서대로 에지를 추가하면서, 최대 매칭을 증가시키는 것만 넣어주는 식으로 계산할 수 있다. 이렇게 가중치를 없에고 최대 매칭 문제로 환원하면, ARC076F / POI Ice Skates 에 나온 유형처럼, 홀의 결혼 정리 + Segment Tree 로 해결 가능. 사실 생략한 아이디어들이 이것저것 있는데 다 적으면 너무 길어지니 생략.&lt;/li&gt;
&lt;li&gt;E: planar graph에서 random walk를 할 때 n번 정점에 도달하는 시간의 기댓값. $n \le 3000$. 평면 그래프이기 때문에 적당한 행 순서를 잡아 가우스 소거법을 하면 될 것이라 생각하였으나 실패했다. 이런 식의 접근 방법이 의도된 것 같긴 하지만, 계산이 실수를 구하는 것이 아니라 mod p field에서 진행되는 것이라 Black Box Linear Algebra를 사용하면 쉽게 해결할 수 있었다. 나중에 안 사실인데, 적당한 행 순서를 잡아서 가우스 소거법을 하는 방식으로 쉽게 풀리는 문제가 WF 2014 Pachinko라고 한다.&lt;/li&gt;
&lt;li&gt;G: 이해 불가능한 Lemma가 있었다. 이 Lemma를 사용하면 partition number를 계산하는 문제로 환원되고, 이는 Pentagonal Number Theorem으로 $O(N^{1.5})$ 에 된다고 한다 ㅎㄷ&lt;/li&gt;
&lt;li&gt;H: graph를 construction해야 하는 문제. 그래프가 특정한 제약 조건을 만족한다고 생각해도 문제에서 원하는 그래프를 전부 만들 수 있음을 알… 수는 없다. 전혀 비직관적인 제약 조건이라 그게 된다는 게 이해가 안되지만, 아무튼 제약 조건을 만족하는 그래프는 DP로 쉽게 전부 열거해 볼 수 있고, 모든 입력에 대해서 그 DP 테이블이 다 차는 것은 돌려보면 알 수 있다 (…) construction 문제는 구데기니 걸러야 한다는 사실을 배웠다. &lt;/li&gt;
&lt;li&gt;J: APIO 2014 Sequence와 동일한 문제라는 것을 최소반례를 가정한 귀류법 (즉, 수학적 귀납법?) 으로 증명할 수 있다. 이를 $O(N\log N)$ 에 풀어야 한다. 여기까지 들으면 잘 알려진 Aliens trick + CHT 라고 생각하겠지만 역추적이 안된다. 하지만 당신은 할 수 있다. 비용 함수가 monge라는 성질만 사용해도 증명할 수 있다. 더 이상의 자세한 설명은 생략하고, 궁금하면 내 olympiad github에 있는 apio14_sequence_nlgn.cpp 를 참고.&lt;/li&gt;

&lt;/ul&gt;
&lt;h2&gt;Day2&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A: weighted cactus graph가 주어졌을 때, $flow(x, y)$ XOR $x$ XOR $y$ 의 합을 모든 $1 \le x &amp;lt; y \le N$ 에 대해서 구하는 문제이다. 대회 때 식이 너무 못 생겨서, 그리고 못 생긴 풀이밖에 생각이 나지 않아 풀지 못했다. 하지만 알고 보니 깔끔하고 쉬운 문제였다. cactus graph의 한 사이클을 거쳐 흐르는 flow를 생각해 보았을 때, 이 중 하나는 사이클 전체에서 용량이 최소인 간선을 따라 흐를 것이다. 고로, 이러한 flow에 대해서 용량 최소인 간선은 항상 쓰인다. 이는, 이 용량 최소인 간선을 항상 쓰인다고 가정하고 없앤 후, 대응되는 사이클의 간선들에 이 간선의 용량을 더해주면, 트리가 생기고, 이 트리의 max flow와 cactus의 max flow가 같다는 것을 뜻한다. 이제는 구간 최솟값이니 비트를 쪼개서 풀어주면 됨. 이 문제는 tourist도 못 풀었고 솔루션이 대회 초중반을 거쳐서 한번도 안 나온 문제이다. 아이디어가 크게 어렵지 않은데, 식이 대놓고 못 생기면 겁을 먹는게 본성인 것 같다. &lt;/li&gt;
&lt;li&gt;G: 입력이 랜덤이라 랜덤으로 뚫었는데, 알고보니 sparse table을 사용한 깔끔하고 아름다운 deterministic solution이 있었다. &lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;이 외 대부분의 문제들은 알 가치가 없었다.&lt;/p&gt;
&lt;h2&gt;Day3 (MSU Red Panda Contest)&lt;/h2&gt;
&lt;p&gt;이 때는 쉬운 문제밖에 못 풀었고, 풀이 설명도 듣지 못해서, 딱히 후기를 쓸 문제는 없고 업솔빙할 문제만 가득하다...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A: should upsolve&lt;/li&gt;
&lt;li&gt;F: should upsolve. 안 읽었는데 별로 어렵지 않다고 들었다.&lt;/li&gt;
&lt;li&gt;G: should upsolve. Link-cut tree.&lt;/li&gt;
&lt;li&gt;H: should upsolve.&lt;/li&gt;
&lt;li&gt;K: should upsolve.&lt;/li&gt;
&lt;li&gt;M: 신기한 문제. 플레이어의 전략은 각각의 노드에 대해서, 여기서 움직일지 멈출지를 결정하는 이분법적 선택이다. 이렇게 보면 플레이어의 가능한 전략은 $2^N$ 개 존재한다. 하지만, 각 시작점에 대해서, 왼쪽에 있는 가장 먼저 멈추는 위치와, 오른쪽에 있는 가장 먼저 멈추는 위치가 같은 전략들은 모두 동등한 전략으로 취급된다. 고로 각 시작점에 대해서 가능한 전략이 $O(N^2)$ 개 존재한다. 기댓값 식을 써 보면 기하학적 접근이 가능함을 알 수 있고, $O(N)$ 에 해결할 수 있다. USACO Dec18 P1과 너무 비슷해서 쉽게 풀었다. 사실 Red Panda Contest가 오리지널이다 (...)&lt;/li&gt;

&lt;/ul&gt;
&lt;h2&gt;Day4&lt;/h2&gt;
&lt;p&gt;사실상 Combinatorial Optimization Contest였던 거 같다 (..)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C: LR max flow.&lt;/li&gt;
&lt;li&gt;D: Matroid intersection. (Linear independence + Partition)&lt;/li&gt;
&lt;li&gt;E: Caratheodory Theorem의 증명과 비슷하게 시뮬레이션하면 되는 문제인것 같다. 업솔빙할 때 계속 틀렸는데 난 실수오차 문제라고 믿는다 (…) &lt;/li&gt;
&lt;li&gt;F: Planar graph의 max cut을 구하는 문제. max cut은 max bipartite subgraph이다. 평면 그래프가 bipartite하면, 이 그래프의 Dual은 Eulerian이다. max eulerian subgraph는 chinese postman problem과 비슷한 방식으로 weighted general matching을 사용하면 구할 수 있다.&lt;/li&gt;

&lt;/ul&gt;
&lt;h2&gt;Day5 (GP of Gomel)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A: 문제는 짧지만 풀이는 정말 복잡하다. 첫번째 단계는 FFT를 사용해서 어떠한 다항식을 구해야 하고, 이렇게 힘들게 구한 다항식에 대해서 $F(x_1), F(x_2), \cdots, F(x_q)$ 를 전부 빠른 시간에 구할 수 있어야 한다. 결국 다항식에 값을 대입하는 것은 $(x - x_i)$ 로 나눈 나머지를 구하는 것과 같으니, Polynomial Division 코드가 있으면 $(x - x_i)$ 다항식을 노드로 하는 segment tree를 만들어서 문제를 $(Q+N)\log^2 N$ 에 해결할 수 있다. 이렇게 하면 한 반쯤 왔고, 이제 centroid decomposition과 몇가지 조합 카운팅을 몇번 더 해주면 됨. 총 400줄 (9KB) 짜면 AC. 업솔빙할 때 정말 짜릿했다.&lt;/li&gt;&lt;li&gt;B: 그냥 설마 안될까 싶은 그리디가 된다. 그런데 제한이 100이고 푼 팀이 별로 없으면, 나이브가 $O(n \log n)$ 인 그리디를 별로 하고 싶지 않아질거다.. 그렇게 겁을 먹으면, 가정을 조금&amp;nbsp;덜 한 $O(n^3)$ DP를 짜서 맞게 된다.&amp;nbsp;&lt;/li&gt;
&lt;li&gt;C: should upsolve.&lt;/li&gt;
&lt;li&gt;D: 투어리스트 이런거 좀 그만 냈으면...&lt;/li&gt;
&lt;li&gt;H: 정해는 구데기였는데, 100개씩 끊어서 미리 탐색해놓고 범위를 줄이는 별해가 재미있었다.&lt;/li&gt;
&lt;li&gt;I: tournament graph에서 위상 정렬 순서를 찾으면 풀 수 있는 문제인데 (SCC 안에서는 자유롭게) 놀랍게도 $O(n\log n)​$ 에 단순 merge sort를 사용해서 찾을 수 있었다. 정말 재밌고 충격적이었던 문제.&lt;/li&gt;

&lt;/ul&gt;
&lt;h2&gt;Day6 (GP of Belarus)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C: binary search inside of parallel binary search.&lt;/li&gt;
&lt;li&gt;D: 대회때는 사전 지식일 거라고 생각하여 잡지 않았으나 아주 좋은 풀이가 있었다. XOR 쿼리는 쉽고, OR / AND 쿼리는 두 트리를 합치는 연산에 대응된다. 트리 합치기는, 작은 것 큰 것의 요령을 사용하면, 새로 생기는 node의 개수에 비례하는 시간에 전부 합쳐줄 수 있다. 빈 트리를 합치려고 시도하면 시간 복잡도가 깨지기 때문에, 각 depth마다 비지 않은 트리들을 저장하는 Queue를 만들어 주어야 한다.&lt;/li&gt;

&lt;/ul&gt;
&lt;h2&gt;Day7&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;B: construction 문제. 뭔 개똥같은 이상한 생각 열심히 하고,&amp;nbsp;그 생각이 맞는지 아닌지를 논리적으로 검증하는 게 아니라 백으로 검증한 다음에 맞으면&amp;nbsp;그걸로 후보 줄이고, 이거 반복해서 이상한 제약조건 6~7개 찾고, 그걸로 문제 내고, 이제는 내 사고로는&amp;nbsp;이해 불가.&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp;I가 (그리고 I만) 관심이 가는 문제였던 것 같다. 두 문자열 s, t 에 대해서, s 가 t의 부분문자열이거나 반대가 성립하면 두 문자열 쌍은 &quot;비교 가능&quot;하다. 문자열 $S$가 주어졌을 때, 모든 부분문자열의 집합에 존재하는 서로 다른 두 쌍 중, 비교 불가능한 쌍의 개수를 세어야 한다. $|S| \le 10^5$.&lt;/li&gt;

&lt;/ul&gt;
&lt;h2&gt;Day8&lt;/h2&gt;
&lt;p&gt;모든 문제가 쓰레기였으나, 반성할 거리가 있었다.&lt;/p&gt;
&lt;h2&gt;Day9&lt;/h2&gt;
&lt;p&gt;모든 문제가 쓰레기였다.&lt;/p&gt;</description>
<category>공부</category>
<author>구사과</author>
<guid>https://koosaga.com/229</guid>
<comments>https://koosaga.com/229#entry229comment</comments>
<pubDate>Mon, 18 Feb 2019 16:31:49 +0900</pubDate>
</item>
<item>
<title>OS X에 새로 생긴 캡처 딜레이 없애기</title>
<link>https://koosaga.com/228</link>
<description>&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9951ED3D5C4B4ABC02&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2019-01-26 오전 2.41.55.png&quot; height=&quot;493&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;블로그에 글을 쓰다 보면 캡처를 할 일이 정말 많다. 옛날에는 캡쳐를 하면 바로 파일이 생겨서 올릴 수 있었지만, 언젠가부터 캡쳐 후 저런 식으로 우하단에 썸네일을 띄워주기 시작했다. 썸네일 물론 좋으나, 썸네일이 10초동안 계속 화면에 남아 있고, &lt;b&gt;썸네일이 사라지기 전에는 파일 생성이 안된다.&lt;/b&gt; 저거 때문에 짜증난게 한 두번이 아닌데, 마침 얼마전에 이를 없애는 방법을 찾아서 공유하고자 한다.&lt;/p&gt;&lt;ol style=&quot;list-style-type: decimal;&quot;&gt;&lt;li&gt;&lt;b&gt;Cmd + Shift + 5&lt;/b&gt;를 누르면 &lt;i&gt;캡쳐 툴&lt;/i&gt;이 뜬다. Shift + 3/4에 익숙한 사람들은 처음 보는 화면이 뜬다. 모하비 업데이트로 생긴 듯 하다.&lt;br /&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;옵션 -&amp;gt; 미리보기 썸네일 표시&lt;/b&gt; 를 해제한다.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;답답한 사람들이 많았을 것 같다. 이 팁으로 그동안 쌓인 스트레스가 다 해소되었으면 좋겠다.&lt;/p&gt;</description>
<category>생각</category>
<author>구사과</author>
<guid>https://koosaga.com/228</guid>
<comments>https://koosaga.com/228#entry228comment</comments>
<pubDate>Sat, 26 Jan 2019 02:49:56 +0900</pubDate>
</item>
<item>
<title>더불어민규당 Petrozavodsk 2019 Winter 직전 연습</title>
<link>https://koosaga.com/227</link>
<description>&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width initial-scale=1&quot;&gt;
&lt;title&gt;practice_ptzbf&lt;/title&gt;
&lt;h1&gt;1월 22일 연습&lt;/h1&gt;
&lt;h2&gt;오후: ARC 064&lt;/h2&gt;
&lt;figure&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;th&gt;C&lt;/th&gt;&lt;th&gt;D&lt;/th&gt;&lt;th&gt;E&lt;/th&gt;&lt;th&gt;F&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;ainta (guest)&lt;/td&gt;&lt;td&gt;36:35&lt;/td&gt;&lt;td&gt;49:33&lt;/td&gt;&lt;td&gt;43:44&lt;/td&gt;&lt;td&gt;34:33&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;tncks0121&lt;/td&gt;&lt;td&gt;2:48&lt;/td&gt;&lt;td&gt;23:38&lt;/td&gt;&lt;td&gt;9:23&lt;/td&gt;&lt;td&gt;59:19&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;koosaga&lt;/td&gt;&lt;td&gt;3:30&lt;/td&gt;&lt;td&gt;97:56&lt;/td&gt;&lt;td&gt;31:58&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;
&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;실제 연습 환경에서 한 게 아니라 변동 사항이 있을 수 있다. (아인타는 약간 늦게 합류했고, 집중할 수 있는 상황이 아니었고, 등등..)&lt;/p&gt;&lt;p&gt;하지만 내가 문제를 못 푼 건 그래서가 아니었다. 일단 D의 풀이를 보는데 한 30분 정도를 사용했고, F를 보고 풀 수 있다고 생각하고 너무 과도하게 달려들었던 것도 참패 요인이다. &lt;/p&gt;&lt;p&gt;F는 내가 보통 거르고 보는 약수 포배 유형이다. 풀이를 들었는데 웬만큼 잘 생각하지 않았으면 못 풀었을 문제인 것 같다. 그런데 그런 유형인지를 모르고 E를 푼 이후 F로 넘어갔다. 지금 돌아보면 원순열과 비슷하게 rotating한 것중에 같은 것을 빼주는 것이니 약수로 논리 전개를 하는 것이 당연한 것 같은데, 그 때는 잘 몰랐다.&lt;/p&gt;&lt;p&gt;정말 반성해야 할 것은 D인데, 풀이가 상당히 간단하고 그 근처까지 갔던 것 같으나 어째서인지 계속 복잡하게 생각하고 헤메다가 풀이를 찾지 못했다. 초기에 계속 생각이 안 나서 나중에 F를 포기한 이후에야 다시 돌아왔고 그 때 풀었다. &lt;/p&gt;
&lt;h2&gt;밤: JAG Summer Camp 2017 Day3&lt;/h2&gt;&lt;p&gt;
&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99F455395C4B495901&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2019-01-23 오후 6.58.52.png&quot; height=&quot;131&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;ainta는 연습하고는 상관없다.&lt;/p&gt;&lt;p&gt;뻘짓을 여럿 했으나, 셋 돌면서 그런 걸 안 하는 게 더 이상하니 (...) 감안하면 꽤 만족스럽게 했다. 혼자서 올솔하기는 쉽지 않은 셋으로 보인다. &lt;/p&gt;&lt;p&gt;문제는 JAG치고 실망스러웠다. 아이디어를 떠올리는 건 거의 어렵지 않고, 그냥 구현만 엄청 많이 하는 셋.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h1&gt;1월 23일 연습&lt;/h1&gt;
&lt;h2&gt;밤: Asia Yokohama 2018&lt;/h2&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99F4A7395C4B495A01&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2019-01-23 오후 11.49.12.png&quot; height=&quot;95&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;나랑 수찬이랑 팀으로 참가했다. 모든 문제를 풀고 리저널 챔피언도 했다. 최고~~ &lt;/p&gt;&lt;p&gt;E F는 수찬이가 풀고 나머지는 전부 내가 풀었다. 스코어보드 없이 해서 순서가 약간 뒤바뀐 것 같긴 하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;G는 풀이를 잘못 생각해서 말리기 직전까지 갔다. 다 짰는데 반례가 나왔을 때 머리가 띵해졌다 (...) 특히 스코어보드도 없는 상황이라, 정말 무서웠다. 알고 보니 간단한 문제. &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://koosaga.com/209&quot;&gt;구사과 블로그를 성실히 읽은 자는 H를 쉽게 풀 수 있다.&lt;/a&gt; 그냥 5색 정리랑 똑같은 방법으로 Kempe Chain을 잡으면 된다. Kempe Chain 비슷한 걸 더 생각해 보고 싶은 사람은 &lt;a href=&quot;https://www.acmicpc.net/problem/7888&quot;&gt;CERC 2008 Two Professor&lt;/a&gt;를 풀어보면 좋을 듯.&lt;/li&gt;
&lt;li&gt;I는 행렬의 rank를 가지고 잘 사바사바해야 했던 문제이다. 끝까지 풀이가 안 나와서 수찬이랑 계속 이야기를 하면서 풀었다. 완벽한 증명을 하기가 버거워서, 거의 직관에 의존해서 풀이를 접근했고, 다행이도 그 직관이 잘 맞아서 AC.&lt;/li&gt;
&lt;li&gt;J는 do you know dfs ordering. 우리 팀은 저게 E~K 중 가장 쉬운 문제였다. 자료구조 조아.&lt;/li&gt;
&lt;li&gt;K 역시 꽤 쉬운 문제였는데 우리는 게임이라는 키워드가 나와서 한참을 안 읽었다 (...)&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;E / F는&amp;nbsp;말리기 좋은 문제들이었는데 뒤에서 수찬이가 잘 밀어줘서 나머지 문제들을 정말 순조롭게 밀 수 있었다. F는 컴퓨터 빌 때마다 계속 잡는 식으로 하다가 아주 깔끔하게 밀렸다. 팀워크도 괜찮았고 문제도 잘 풀렸고. 오랜만에 대회를 순항해서 기분이 좋았다. &lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h1&gt;1월 24일 연습&lt;/h1&gt;
&lt;h2&gt;아침: 랭작 (...)&lt;/h2&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99F4AB395C4B495A01&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2019-01-25 오후 4.30.02.png&quot; height=&quot;482&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2시간 연습을 하려 했으나 늦잠자서 펑크냈다. 뭐라도 돌려야 하니 1시간동안 간단히 할 만한 12문제 랭작셋을 돌렸다. &lt;/p&gt;&lt;p&gt;강의실 배정 문제에 대해서 좀 늦게나마 변을 풀자면, 코이스터디 버전이 $S_i &amp;lt; T_i$ 로 well-formed되어 있는 점을 보았을 때, 코이스터디에서 문제를 옮길 때 실수가 있었던 것 같다. $S_i \le T_i$ 를 인용하는 버전 역시 well-formed되어 있지만 의도된 풀이에서는 특수한 예외 처리가 필요하다. 조만간 추가 데이터를 지우고, 디스크립션을 고칠 것 같다. 나 혹은 백준님이 안 귀찮으면...&lt;/p&gt;
&lt;h2&gt;오후: SEERC 2017&lt;/h2&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99F4F1395C4B495B01&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2019-01-25 오후 4.52.21.png&quot; height=&quot;586&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;개인 연습이었다. 이번에도 어제처럼 매우 만족스럽게 했다. 디스크립션 상태가 정말 엉망이었다. 그걸 빼면 문제들은 나쁘지 않았던 것 같다. 특히 쉬운 쪽 문제들이 재밌었다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A: simple DP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;B: 재밌는 문제. 어떤 구간을 011111110 으로 만들 수 있는 필요충분이 생각보다 아주 쉽게 결정된다. 이 필요충분을 알면 $n^2$ DP를 설계할 수 있고 보조 배열 하나를 두면 $n+m$ 으로 최적화할 수 있다. 처음 생각했던 풀이의 방향이 저랬는데 필요충분이 어떤지를 생각하는데 오래 걸렸다. 답을 떠올리고 돌아보니 정말 허무했음. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;C: 어렵고 재밌는 문제. 각각의 수에 대해, 그 수들을 span하는 가장 짧은 path에만 칠해주면 된다 (그 Path는 무조건 칠해야 하며 더 칠하는 모험을 할 필요가 전혀 없다.) 그러면 각 수에 대해서 칠하게 될 path가 고정되어 있다. 어떠한 정점에 수가 적혀있다는 것은, 그 정점을 지나는 path들이 그 수보다 먼저 색칠되었다는 것을 의미한다. 여기까지의 관찰을 사용하면 위상정렬로 $O(n^2)$ 에 문제를 해결할 수 있다. 이는 느리니 최적화가 필요하다.&lt;/p&gt;&lt;p&gt;어떠한 수가 위상 정렬의 큐에서 빠진다는 것은, 해당 숫자들에 대해서, 그 숫자를 지나는 path가 하나 (자기 자신) 밖에 없다는 것이다. 각각의 숫자에 대해서, 해당 숫자를 지나는 Path의 count를 들고 있는다고 생각해 보면, 그 카운트가 1일 때 해당 숫자를 &quot;완성&quot; 되었다고 하고, 모든 숫자가 &quot;완성&quot; 되었을 때 큐에 넣어주면 되겠다. &lt;/p&gt;&lt;p&gt;하나의 Path를 제거한 후 새롭게 완성된 수들을 빠르게 찾을 수 있다면 저 알고리즘을 완성할 수 있다. 어떠한 숫자를 지나는 path의 count는 1 이상 $\infty$ 이하의 수라고 가정할 수 있으니, 카운트가 1인 것을 찾는 것은 최솟값을 찍는 수를 찾는 것과 같다. Path가 제거되었을 때는, 구간에 있는 숫자들의 카운트가 감소한다. Heavy-Light Decomposition을 구하고 각 노드에 최솟값 + 구간 덧셈 segment tree를 관리하면 전체 문제 해결. 코드가 짧지 않다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;D: 에휴... $rank(A) = rank(A^T)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;E: 풀이 자체는 재밌으나 워딩과 제한이 최악이었던 문제. 각각의 수에 대해서 해당 수부터 시작해서 덮을 수 있는 segment의 길이를 구할 수 있다 ($12n$). 이걸 따라 단순히 시뮬레이션하면 $O(n^2)$이다. sparse table로 $O(n\log n)$ 도 가능하다. 하지만 아마 느릴 거 같다. 이를 최적화하는 아이디어는 다음과 같다. 한바퀴 도는 해를 아무거나 잡고, 그 해의 가장 짧은 segment 하나를 고르자. 가장 짧지만 아무튼 maximal하니, 이 segment 사이의 길이 중 하나는 잘려야 할 것이다. 고로 다 잘라본다. 답이 $K$이면, 세그먼트 길이는 $\frac{N}{K}$ 이고, brute force하면 곱해져서 선형.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;F: 쉽고 재밌는 문제. $1 \rightarrow 1$ 인 수는 아예 그대로 냅두거나, 아니면 0으로 한번 바꿔서 코스트를 조금 덜고, 다시 1로 바꿔서 꾸는 식으로 할 수 있다. 저런 식으로 $1 \rightarrow 0 \rightarrow 1$로 바꿔가면서까지 코스트를 지불하기 부담스러운 애들은 비싼 비트들일 것이다. 고로 입력을 정렬한 후 가장 비싼 비트들의 모든 prefix에 대해서 바꿔준다. 이렇게 되면 변환이 필요한 남은 원소들은 $1 \rightarrow 0, 0 \rightarrow 1$ 밖에 없고 그건 simple greedy. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;G: 입력 제한이 안 적혀있음 ㅋㅋ&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;H: 관심 없음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I: 문제도 극혐이지만 디스크립션이 틀렸다. 다 코딩했는데 예제가 14로 나온다면, 맨 위 3*3은 절대 채우면 안된다는 것을 기억하자. 물론 디스크립션에는 써져있지 않다. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;J: 쓰레기 문제. 생각해보면 어떠한 수가 1이냐 아니냐가 꽤 중요하다. 반대로, 수가 충분히 크다면 어떤 수가 클지는 별로 상관이 없어 보인다. 백트래킹 돌리면 3 이상인 수가 2개 이상이거나 2 이상인 수가 4개 이상이면 무조건 진다는 것을 알 수 있다. 이제 1/2/3의 개수 경우의 수가 $n$. DP. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;K: 쉽고 재밌는 문제. LIS가 1인 수부터 순서대로 채워나가준다. 증명은 귀납법.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;L: 쉽고 재밌는 문제. 에지가 $2n-2$개고 1개로 못 끊으니까 글로벌 민컷이 2 아니면 3이다. 그리고 한 쪽 트리에서는 무조건 간선 하나만 끊는다. 고로 LCA+변홧값 배열. &lt;/p&gt;
&lt;/li&gt;

&lt;/ul&gt;
&lt;h1&gt;1월 25일 연습&lt;/h1&gt;
&lt;h2&gt;밤: NEERC 2009&lt;/h2&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99F50B395C4B495D01&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2019-01-26 오전 12.06.21.png&quot; height=&quot;614&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;나는 결과에 만족했으나 팀원들에게는 그렇게 만족스러운 결과가 안 나왔던 것 같다. 문제 셋 재밌었다. 실력을 막론하고 추천. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A: 괜찮은 3D 기하 연습 문제. 첫번째로 convex polyhedra의 무게 중심을 구해야 한다. 일반성을 잃지 않고 $x$ 좌표만 구해보자 (나머지는 다 돌리면서 똑같이 하면 됨). 이 때 구해야 하는 건 $\int{\text{($x = T$ 평면으로 잘랐을 때의 넓이)}dx}$, $\int{x \times \text{($x = T$ 평면으로 잘랐을 때의 넓이)}}dx$ 이다. &lt;/p&gt;&lt;p&gt;꼭짓점의 $x$ 좌표를 기준으로 polyhedra를 $x = X$ 평면으로 잘라보면, 결국에 잘린 각각의 모양은 $x$ 가 증가하는 방향으로 봤을 때 convex polygon이 선형적으로 늘어났다 줄어들었다 하는 모양임을 알 수 있다. 이 convex polygon의 꼭짓점이 무엇인지는 각 잘린 구간에 대해서 바뀌지 않으나, 위치가 선형적으로 변한다. 어떠한 convex polygon의 넓이는 점 위치에 대한 외적으로 구할 수 있다. 각 점 위치를 $x$ 에 대해서 매개화하면, 이 넓이 식은 $x$ 에 대한 이차함수 꼴임을 알 수 있다. 그러면, 우리가 구하는 것은 결국 이차함수 / 삼차함수의 적분 값이다.&lt;/p&gt;&lt;p&gt;특정한 $T$ 에 대해서, $x = T$ 평면으로 잘랐을 때의 넓이는 $O(n^2 \log n)$ 시간에 단순 convex hull 알고리즘으로 계산할 수 있다 (설명 생략). 그래서 내가 처음에 생각했던 건, $x = p, x = (p+q)/2, x = q$ 에 대해서 넓이를 계산해 놓고, 이차함수가 유일하게 결정될테니 이를 손으로 잘 써서 (...) 푸는 것이 계획이었다. 하지만 이게 나름 빨리 풀린 문제라서 더 좋은 방법이 있을 거라고 생각했다. &lt;/p&gt;&lt;p&gt;얼핏 생각해 보니 $(q-p)\frac{f(p) + 4f((p+q)/2) + f(q)}{6}$ 로 적분하는 걸 고등학교 시간에 배웠던 것 같았고, 이걸 쓰면 굳이 이차함수를 일일이 계산할 필요가 없었던 것 같았는데, 정확히 무엇인지는 기억이 나지 않아 검색을 해 봤다 (개인 연습은 간단한 구글 검색이 가능하다는 게 그전에 정한 우리 팀 policy였다).  이 방법의 이름은 trapezoidal rule 이었고, 3차함수 이하의 다항함수를 적분할 수 있다는 사실을 배웠다. 그러면 넓이 뿐만 아니라 x * 넓이도 간단하게 해결! 무게 중심을 구할 수 있다.&lt;/p&gt;&lt;p&gt;이제 무게 중심과 표면의 거리를 계산해야 한다. $n$ 이 작아서 비효율적인 방법도 여럿 시도할 수 있고, 나 역시 간단한 $O(n^4)$ 로 풀었다. 세 점을 잡고, 이 점이 이루는 삼각형이 convex polyhedra의 표면에 있는지를 내적으로 확인한다. 있다면, 삼각형과 점과의 거리를 계산할 수 있다. 이를 모든 쌍에 대해 다 하면 $O(n^4)$ 에 convex polyhedra를 전부 탐색할 수 있다.&lt;/p&gt;&lt;p&gt;삼각형과 점과의 거리는 옛날에 짜본 적이 분명 있었으나 이 때는 그 방법을 까먹었다 (...) 하지만 사실 이것도 필요없다! 그냥 삼각형이 이루는 평면과 점과의 거리를 계산하면, 더 작은 답이 나올 일이 없다 (convex polyhedra의 접평면이니까). 그래서 이제는 정말 단순 내적. AC. &lt;/p&gt;
&lt;/li&gt;

&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;B: easy&lt;/li&gt;

&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;C: 재밌는 Interactive. 최솟값과 최댓값을 알면 나머지를 대충 다 찍을 수 있다는 것에서 착안한다. $n = 4$ 일 때 손으로 해 보면, 최솟값 / 두번째 최솟값, 최댓값 / 두번째 최댓값을 구분할 수 없고, 어떤 것이 작은 축에 속하는지 큰 축에 속하는지를 구분할 수 있음을 관찰할 수 있다. 임의의 $n$ 에 대해서도 최솟값 / 두번째 최솟값, 최댓값 / 두번째 최댓값은 서로 구분이 불가능하며, 저 2개 / 2개 원소의 구성을 알고 있으면 전부 답을 찍을 수 있다. 고로, $n = 4$ 일때의 4개 원소의 정보를 손으로 구하고, 하나 하나 추가될 때마다 이 정보를 $O(1)$ 쿼리로 업데이트하면 해결 가능. 쿼리 개수가 널널해서 좋았다 (한편으로 이분 탐색이라고 낚일 뻔하기도 했다. 2000이 적절한 제한이었던 것 같다.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;D: 파싱 후 정렬.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;E: 아주 재밌는 문제였다. 풀린 것에 비해서 그렇게 어렵지 않고 아이디어도 재밌다. Longest Path가 $T$ 라는 것은, 이 그래프를 $T+1$ 개의 독립집합으로 나눌 수 있다는 것과 동치이다. 증명은 어렵지 않다. 이 직관을 얻기 위해서는, Longest Path를 중심으로 그래프의 정점들을 일종의 &quot;레벨&quot; 혹은 &quot;wave&quot; 로 분리했다고 생각하면 좋을 거 같다. 이제 우리가 구하는 것은 그래프의 최소 채색 수이다. 이는 $O(3^V)$ 시간에 Bit DP를 사용해서 간단하게 구할 수 있다. 이제 구한 각각의 독립 집합을 대충 라벨링한 후, 각 에지에 대해서 consistent한 방향을 주면 (말하자면, 색깔 수가 큰 쪽으로 방향을 주면) 간단하게 해결.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;F: 초반부터 많이 풀린 문제였는데 도저히 풀이를 못 찾겠어서 멘붕이 왔다. 멘탈을 정리하기 위해 풀 다른 문제를 열심히 찾다가 J도 풀고, 3D 기하인 A도 풀었다 (...) 돌아와도 제대로 된 풀이는 안 보였고, 그나마 사풀이 중 될것 같이 생긴 게 떠올라서 그걸 짜서 맞았다. 끝나고 확인해 보니 팀원들의 풀이도 나랑 비슷했고 (다만 나보다 조금 더 될 거 같고), 팀원들 중 제대로 증명한 사람은 아무도 없었다. 뭐 어쨌든 증명이 있을 거 같긴 하지만, 좋은 기억으로 남지는 못한 문제. &lt;del&gt;sensible BFS approach&lt;/del&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;G: 흔한 Permutation $N$ 승하는 문제. 그 과정에서 지나온 길에 써져있는 모든 수를 더해야하는 류의 조건이 있지만, 문제는 별로 바뀌지 않는다. 짜증나는 점이 있다면 $N \le 10^{100}$ 이라는 것인데, 일단 큰 수 modulo와 나눗셈을 구현해야 해서 귀찮지만 풀이가 크게 바뀌지는 않는다. 나의 경우에는 사이클을 직접 찾아 지우는 것보다 permutation $N$ 승을 sparse table로 구현하는 걸 선호하는데, 위 경우에는 이진법보다 십진법으로 수를 다루는 게 편하니 sparse table을 $10^k$ 번 거쳐갔을 때의 결과 / 그동안 써진 수의 합 형태로 저장하면 구현이 간단하다.&lt;/p&gt;&lt;p&gt;.. 그런데 이렇게 하니까 메모리를 100MB 써서 MLE가 났고 (옛날 대회라 ML 64MB ㅠㅠ) 엄청나게 당황했다. 하지만, sparse table도 DP니까, 토글링을 하면 된다. 모든 노드를 한꺼번에 처리해 준다면, 모든 $10^k$ 번째 조상을 그때그때 볼 필요 없이 한번에 한 $k$ 에 대한 결과만 필요하다. $10^k$ 번째 조상을 찾을 때는, $10^{k-1}$ 번 조상만을 참고한다. 고로 토글링이 가능하다. AC.&lt;/p&gt;
&lt;/li&gt;

&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;H: 조건부 확률 연습.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I: &lt;a href=&quot;https://amugelab.tistory.com/86&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;이번에도 구사과 블로그에 있는 DAG Path Cover&lt;/a&gt;. 이분 매칭을 팀노트에서 직접 타이핑하지 않는게 우리 팀 개인 연습 policy라서, 평소보다 약간 빨리 풀 수 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;J: 약간의 제약 조건이 걸린 냅색. 일단 제약조건이 없을 때는 $O(m\times n^2 \times maxPercent)$ 시간에 풀린다. 이 때 $maxPercent$ 는 각각의 퍼센트에 대해서 해당 퍼센트가 나오는 정답률 쌍의 개수 최댓값을 뜻하는데, 딱 봐도 작을 거 같다 해서 돌려보면 실제로 작음을 알 수 있다 ($maxPercent = 100$). 난 이렇게 짰고 예제에서 WA를 받았는데 (...), 알고보니 최대 - 최소에 대한 제약 조건이 있었다. 이는 크게 두 가지 방법으로 해결 가능하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$[L, R]$ 구간에 있는 문제 수만으로 냅색이 가능한가? 쿼리를 대답할 수 있다면, inchworm의 요령으로 100번의 쿼리 만에 문제를 해결할 수 있다. 각 쿼리를 응답하려면 냅색을 빠르게 해야 하는데, 마법의 bitset을 사용하면 냅색은 64배 빨라진다 (...) 역추적은 한번이니 그 때는 비트셋 안 써도 그만. 100배 느려지고 64배 빨라졌으니 시간도 별 차이 안 난다. 난 이렇게 고쳐서 금방 맞았고, 짜증나는 문제라고 생각했다.&lt;/li&gt;
&lt;li&gt;팀원들의 풀이는 훨씬 깔끔하고 재미있다. 아마 정해는 이것일 거 같다. $[L, R]$ 구간에서, $L$ 은 항상 $\frac{n}{m}$ 이하임을 알 수 있다. $L$ 이 고정되었을 때 $R$ 을 최소화하는 것은, 냅색의 반환값을 boolean이 아니라 지금까지 나온 $R$ 의 최솟값으로 정의하면 구할 수 있다. 시간 복잡도는 $O(\frac{n}{m} \times m \times n^2 \times maxPercent) = O(n^3 \times maxPercent)$ 로 AC. 알고보니 재밌는 문제였다.&lt;/li&gt;

&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;K: ㅁㄹ&lt;/p&gt;
&lt;/li&gt;

&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>공부</category>
<author>구사과</author>
<guid>https://koosaga.com/227</guid>
<comments>https://koosaga.com/227#entry227comment</comments>
<pubDate>Sat, 26 Jan 2019 02:36:39 +0900</pubDate>
</item>
<item>
<title>Linear Programming Duality</title>
<link>https://koosaga.com/226</link>
<description>&lt;p&gt;
&lt;/p&gt;&lt;p&gt;관련 내용이 &lt;a href=&quot;https://m.blog.naver.com/kks227/220967218183&quot;&gt;이 블로그&lt;/a&gt;에도 매우 잘 나와 있으니 같이 보면 좋을듯. 이 글에서는 LP에 대한 정의를 안다는 것을 가정하기 때문에, 정의를 모른다면 링크한 블로그를 참고해야 한다.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;직관&lt;/h2&gt;
&lt;p&gt;다음과 같은 LP 문제를 생각해 보자.&lt;/p&gt;&lt;p&gt;$\text{Maximize: } 4x + 4y$&lt;/p&gt;&lt;p&gt;$\text{Subject to: } x + y \leq 3,x, y \geq 0 $&lt;/p&gt;&lt;p&gt;이 문제의 답은 굉장히 자명하다. $(x+y) \leq 3$ 이라는 조건이 있으니, $4(x+y) \leq 12$ 를 만족한다. 그 외에 다른 제약 조건은 $x, y \ge 0$ 뿐이니 답은 간단히 12로 결정된다. &lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;이를 조금 더 어려운 예시로 바꿔보자. &lt;/p&gt;&lt;p&gt;$\text{Maximize: } 4x + y $&lt;/p&gt;&lt;p&gt;$\text{Subject to: } x+y \leq 2, 2x+y \leq 3, x, y \geq 0$&lt;/p&gt;&lt;p&gt;위 예시와 다르게 이 문제의 답은 자명하지 않다. 위 문제의 답이 자명할 수 있었던 것은, 제약 조건 항이 유일했으며 그것이 최적화 함수의 형태와 일치했기 때문이다. 지금의 경우에는 제약 조건의 항이 유일하지도 않으며, 최적화 함수와도 독립적이다. &lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;LP Duality의 접근은, 이 식을 최대한 &quot;당연하게&quot; 만드는 것이다. 새로운 변수 $a, b$ 를 도입하자. 그러면, 다음과 같은 것이 성립한다. 이 때 $a, b \geq 0$ 임에 유의하자! 아니면 부등호가 바뀌어서 엉망이 된다. &lt;/p&gt;&lt;p&gt;$a(x + y) \leq 2a, b(2x+y) \leq 3b$&lt;/p&gt;&lt;p&gt;$(a + 2b)x + (a + b)y \leq 2a + 3b​$&lt;/p&gt;&lt;p&gt;직관적으로 생각했을 때, 이 수식을 &quot;끼워맞춰서&quot; $4x+y$ 로 만들기 위해서는 $a+2b = 4, a+b = 1$ 을 만족시켜야 한다. 하지만, 이를 모두 만족시키는 해는 존재하지 않는다. 즉, 이 경우에는 위와 같은 형태의 부등식을 즉각적으로 얻을 수는 없다. 하지만, $4x + 2y \leq 18, 5x + y \leq 18$ 와 같은 제약조건도 답의 상한을 찾기에는 충분히 도움이 되니, 위 제약 조건을 $a + 2b \ge 4, a + b \ge 1$ 로 바꾸자. &lt;/p&gt;&lt;p&gt;이 때 답의 상한을 최대한 낮춰서 많은 정보를 얻으려면, 우변의 항이 최소화되어야 한다. 그렇다면 이것 역시 LP 문제가 된다.&lt;/p&gt;&lt;p&gt;$\text{Minimize: } 2a + 3b $&lt;/p&gt;&lt;p&gt;$\text{Subject to: } a+2b\ge 4, a+b\ge 1, a, b \geq 0$&lt;/p&gt;&lt;p&gt;이 LP를 손으로 풀어보면 $a = 0, b = 2$ 임을 알 수 있다. 이 때 $2a + 3b = 6$ 이므로, 이제 우리는 원래 LP 문제의 답은 적어도 6보다는 작다는 것을 알 수 있다. 실제로 원래 LP를 풀어보면, $x = 1.5, y = 0$ 을 대입하여 답이 정확히 6인 해를 얻을 수 있고, 그것보다 더 큰 해를 얻을 수는 없다.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;우리가 지금까지 한 과정은 LP Duality 개념을 손으로 유도해낸 것이다. 원래 형태의 문제를 Primal 문제, 변형된 형태의 문제를 Dual 문제라고 부르자. 우리는 Primal 문제에서, 답에 대한 상한을 찾기 위해 계수를 맞춰주는 방식으로 Dual 문제를 직접 유도해 냈다. 그리고 이 과정에서 새로운 결론을 얻어냈는데, Primal 문제의 답은 Dual 문제보다 작거나 같다는 것이다. 이러한 결론을 &lt;strong&gt;Weak Duality&lt;/strong&gt; 라고 부른다. 보다시피, &lt;strong&gt;Weak Duality&lt;/strong&gt;는 자명한 과정만을 거쳐서 도입할 수 있기 때문에 정당성도 자명하다. 이보다 더 강한 명제인 &lt;strong&gt;Strong Duality&lt;/strong&gt; 는, 더 나아가서 Primal 문제의 답이 Dual 문제의 답과 같다는 명제이다. Strong Duality는 참이고, 그 증명은 자명하지 않다. &lt;a href=&quot;https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=2&amp;amp;ved=2ahUKEwiekbGm2pXfAhXGMt4KHdUZAToQFjABegQICRAC&amp;amp;url=https%3A%2F%2Fwww.cs.princeton.edu%2F~wayne%2Fkleinberg-tardos%2Fpdf%2FLinearProgrammingII-2x2.pdf&amp;amp;usg=AOvVaw2m8LCgdRJuN9cUGoDkjKt0&quot;&gt;관심이 있다면 이 링크를 참고.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;일반화와 결론&lt;/h2&gt;
&lt;p&gt;위의 예시는 특수한 경우에 불과하니, 이를 일반적인 경우로 바꾼다. 다음과 같은 LP 문제를 생각해 보자.&lt;/p&gt;&lt;p&gt;$\text{Maximize: } c^Tx$&lt;/p&gt;&lt;p&gt;$\text{Subject to: } Ax \leq b, x \geq 0$&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;$\sum_{1 \leq i \leq n}{(y_i \times A_{i, j} )\geq c_j}$앞서 말한 Dual Problem이라는 것은, $Ax \leq b$ 라는 식을 이루는 각 행 벡터에 대해 적당한 선형 결합을 찾아서. 그 값을 $c^Tx$ 보다 크게 하는 것이었다. 다시 한번 이거를 시도해 보자. $i$ 번째 행에 대해서 그 항에 붙일 계수를 $y_i$ 라고 하자. 그러면, 모든 열 $j$ 에 대해서 다음이 성립한다.&lt;/p&gt;&lt;p&gt;$\sum_{1 \leq i \leq n}{(y_i \times A_{i, j} )\geq c_j} \text{ for all }j \implies$
$A^T_{j} \times y \geq c_j \text{ for all }j \implies$
$A^Ty \geq c, y \geq 0$\&lt;/p&gt;&lt;p&gt;각 $y_i$ 에 대해서 계수로 붙었던 것은 $b_i$ 였다. 고로, 최소화해야 할 대상은 $b^Ty$ 이다. 이제 위 Primal 문제에 대응되는 Dual 문제를 다음과 같이 정의할 수 있다.&lt;/p&gt;&lt;p&gt;$\text{Minimize: } b^Ty$&lt;/p&gt;&lt;p&gt;$\text{Subject to: } A^T y \geq c, y \geq 0$&lt;/p&gt;&lt;p&gt;그리고, &lt;strong&gt;Strong Duality&lt;/strong&gt; 에 의해, Primal 문제의 최댓값과 Dual 문제의 최솟값은 동일하다.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;몇 번 문제를 풀어보다 보면 알겠으나, 사실 위 식과 아래 식은 아주 비슷하다. Max 문제를 풀다가 안 풀릴 때는, 풀고 있던 종이를 뒤집어 버리자. 행렬도 돌아가고, $b, c$ 벡터도 돌아가고. 이제 거기서 minimization을 그냥 그대로 풀면 Dual 문제가 되는 것이다. 또 하나의 결론은, Dual Problem을 똑같은 과정으로 변환하면 다시 Primal Problem이 된다는 것이다. 고로 Dual의 Dual은 Primal.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;알아두면 쓸데있는 잡지식&lt;/h2&gt;
&lt;p&gt;$x \geq 0$ 조건이 강제되는 게 걸릴 수 있는데, 저것이 문제라면 양수와 음수를 쪼개는 식의 테크닉을 사용하자. 정확히는, 변수 $x^{+}_i, x^{-}_i$ 를 만든다. $x_i = x^{+}_i - x^{-}_i$ 로 전부 대체해주고, $x^{+}_i, x^{-}_i \geq 0$ 을 적어주자. 그러면 저 조건이 없는 상황에서도 항상 이를 강제시킬 수 있다. &lt;/p&gt;&lt;p&gt;Convex Hull Trick의 모티베이션이 된 &lt;a href=&quot;https://en.wikipedia.org/wiki/Duality_(projective_geometry)&quot;&gt;point-line duality&lt;/a&gt; 랑은 다른 개념이다.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;연습 문제&lt;/h2&gt;
&lt;p&gt;꼭 Duality를 알아야만 풀 수 있는 문제는 많지 않지만, Duality를 사용하면 굉장히 깔끔하게 생각할 수 있는 문제들이 많다. &lt;/p&gt;&lt;p&gt;다음 세 문제는 Duality를 사용하면 바로 기하 문제로 환원할 수 있는 문제들이다. 안 쓰고 안 풀어봐서 모르겠는데, 내가 옛날에 335C 풀었을 때를 생각해 보면 그닥 쉽지 않았던 것 같다..&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://codeforces.com/contest/605/problem/C&quot;&gt;CF Div1 335C. Freelancers Dreams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/13096&quot;&gt;JAG Autumn 2014. Flowers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/16414&quot;&gt;ICPC Pacific NW 2018. Mobilization&lt;/a&gt;&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;다음 문제는 Primal, Dual 모두 효율적인 풀이가 있으나 Dual의 관점에서 생각하는 게 훨신 더 빠르게 풀 수 있는 문제이다. 이 문제에 대해서 &lt;a href=&quot;koosaga.com/224&quot;&gt;이 곳&lt;/a&gt;에 적었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://codeforces.com/blog/entry/63808&quot;&gt;Topcoder SRM 744. CoverTreePaths&lt;/a&gt;&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;다음 두 문제는 Duality를 사용하지 않으면 simplex algorithm이 필요해서 TLE가 나지만, Duality를 사용하면 Min-cost flow로 환원되어서 풀 수 있는 문제들이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1281&quot;&gt;BOJ 1281. 보석상&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/13091&quot;&gt;JAG Autumn 2015. Longest Shortest Path&lt;/a&gt;&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
<category>공부</category>
<author>구사과</author>
<guid>https://koosaga.com/226</guid>
<comments>https://koosaga.com/226#entry226comment</comments>
<pubDate>Mon, 21 Jan 2019 00:35:43 +0900</pubDate>
</item>
<item>
<title>더불어민규당 2019년 신년 연습</title>
<link>https://koosaga.com/225</link>
<description>&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width initial-scale=1&quot;&gt;
&lt;title&gt;&lt;/title&gt;
&lt;h2&gt;1월 1일&lt;/h2&gt;
&lt;h3&gt;심야: Petrozavodsk Winter 2018. ITMO Contest&lt;/h3&gt;&lt;div&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99B8803F5C30637623&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2019-01-05 오후 4.54.08.png&quot; height=&quot;624&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;좋은 셋이냐 하면 그건 잘 모르겠는데... 확실히 배울 건 많은 셋이었다. 그래도 이번 신년 연습 중에서는 이게 그나마 제일 정상이었던 거 같다 (...)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A는 적분 식을 찾았으나 너무 복잡해서 포기했다. 하지만 그 복잡한 적분을 노가다하는게 정해였다고 한다(...) 우웩&lt;/li&gt;
&lt;li&gt;F는 connection 정보를 관리하는 DP를 짜면, 가능한 연결 상태가 약 3000개 ~ 4000개 정도이다. 이걸 directed graph로 모델링하면, 결국 여기서 거리가 $K$ 인 walk를 찾는 문제가 된다. 이는 Berlekamp-Massey를 사용해서 해결할 수 있다. 곧 블로그에 글을 쓸 지도 모름.&lt;/li&gt;
&lt;li&gt;H는 directed mst라고 하는데 대회 때 생각해봤어야 했던 문제다. L에 스노우볼링 당한게 큰 듯.&lt;/li&gt;
&lt;li&gt;K는 Chordal graph에서 maximum feedback vertex set을 찾는 문제이다. 신이시여... Chordal Graph는 maximal clique들이 트리를 이루는 것이고, 이러한 트리를 찾는 방법은 Perfect elimination ordering을 사용하면 가능함이 잘 알려져 있다 (Interval Graph는 maximal clique들이 직선을 이루는 것이라는 걸 상기해 보면 대충 무슨 기작인지 알 수 있음). 하지만 elimination ordering을 어떻게 구하고 구조화는 어떻게 하며 흐음... New Year Contest로 지금 열려 있으니 업솔빙을 해봐야 겠다.&lt;/li&gt;
&lt;li&gt;L을 못푼게 정말 정말 너무 아쉽다. 수찬이가 문제를 푸는 과정에서 올바른 식을 찾았는데, 조금 더 편해질 거라고 생각했는지 이걸 약간 복잡하게 변형해서 팀원들에게 전달했다. 약간이라고 생각했겠지만, 분석하는 입장에서 그 식은 매우 복잡하다! 변형된 식은 성질 분석이나 풀이 찾기가 완전히 불가능한 식. 1시간 정도 때려박았고 내가 그 식의 암호화를 어떻게 풀 뻔도 했으나 (...) 최종적으로는 실패했다. 수찬이가 원래 적혀있는 식을 줬으면 그냥 슥삭하는 문제. 이 문제가 완전히 대회의 운명을 결정했다. 정말 너무 너무 아쉽다.&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;1월 2일&lt;/h2&gt;
&lt;h3&gt;오전: ARC 068&lt;/h3&gt;
&lt;figure&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;th&gt;C&lt;/th&gt;&lt;th&gt;D&lt;/th&gt;&lt;th&gt;E&lt;/th&gt;&lt;th&gt;F&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;tncks0121&lt;/td&gt;&lt;td&gt;7:19&lt;/td&gt;&lt;td&gt;20:23&lt;/td&gt;&lt;td&gt;27:19&lt;/td&gt;&lt;td&gt;58:03&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;koosaga&lt;/td&gt;&lt;td&gt;2:56&lt;/td&gt;&lt;td&gt;10:28&lt;/td&gt;&lt;td&gt;25:44&lt;/td&gt;&lt;td&gt;70:13&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;alex9801&lt;/td&gt;&lt;td&gt;5:20&lt;/td&gt;&lt;td&gt;15:47&lt;/td&gt;&lt;td&gt;38:09&lt;/td&gt;&lt;td&gt;89:20&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;문제는 별로였다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E는 소인수분해 하듯이 각 쿼리를 루트에 하거나, 세그먼트 트리 써서 로그제곱에 하거나, 하는 문제였다. 노잼풀이 자강두천&lt;/li&gt;
&lt;li&gt;F는 백트래킹 돌리면 간단한 규칙이 나온다 카더라 (...) 나만 증명하고 풀었다. 하지만 노잼이라 딱히 증명할 이유는 없는 것 같다.&amp;nbsp;&lt;/li&gt;&lt;/ul&gt;
&lt;h3&gt;오후: MIPT Autumn 2018 Day3&lt;/h3&gt;&lt;div&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99BFEC385C3063992C&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2019-01-05 오후 4.54.55.png&quot; height=&quot;667&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;E는 쉬운 문제인데 말렸다. 복잡한 자료구조인가 생각했으나, 까 보니 깔끔하고 좋은 문제였던 것 같다.&lt;/li&gt;
&lt;li&gt;G는 수찬이가 푼 문제. N &amp;lt;= 15일 때 independent set이 1 ~ 2000개인 정점 15개 이하의 트리를 찍는 문제이다. 15개 이하는 전부 돌기에는 너무 많다 ($n^{n-2}$ 내지는 $n!$). 하지만 집합 개수를 목표로 해서 Hill Climbing을 하면 &quot;대충 잘&quot; 찾을 수 있다. 로컬에서 이걸 몇 분 돌려보면 1700개 정도의 숫자에 대해서 트리를 찾을 수 있고 나머지는 못 찾는다. 탐색이 문제인지, 아니면 정말 저게 끝인지가 의심될 때는, 저런 문제를 낸 세터가 나보다 잘 찾았을 리가 없다고 생각하고 submit. 그리고 AC. 최근에 Petr도 GCJ에 이런 류의 문제를 낸 적이 있다. PS판을 그만 오염시켰으면 좋겠다.&lt;/li&gt;
&lt;li&gt;K는 풀이에 가까웠으나 I랑 같이 하다가 시간이 약간 오버되었다.&lt;/li&gt;
&lt;li&gt;I는 예제부터 문제 조건을 매치하지 않는다. 데이터가 틀렸다고 생각한다. 다른 팀도 많이 틀려서 등수 장난은 의미 없는듯.&lt;/li&gt;&lt;/ul&gt;
&lt;h3&gt;심야: ACM-ICPC Singapore 2018&lt;/h3&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/998D843D5C3063A90D&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2019-01-05 오후 4.55.05.png&quot; height=&quot;448&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Kattis를 한번 써 봤다. 버추얼 안되는거 빼고 상당히 괜찮았다.&lt;/p&gt;&lt;p&gt;E/H 외에는 typing contest라고 생각한다. 하지만 난 I에서 하드하게 말렸다.. ㅠㅠ 그래도 속도가 생각보다 빨라서 자신감을 얻었다. &lt;/p&gt;&lt;p&gt;E를 푸는 데 시간을 많이 썼는데 그 시간이 정말 아깝다. 그냥 허락 맡고 탈주하는 게 이득이었을 듯.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;1월 3일&lt;/h2&gt;
&lt;h3&gt;오후: &lt;a href=&quot;https://atcoder.jp/contests/arc076/tasks&quot;&gt;ARC 077&lt;/a&gt;&lt;/h3&gt;
&lt;figure&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;th&gt;C&lt;/th&gt;&lt;th&gt;D&lt;/th&gt;&lt;th&gt;E&lt;/th&gt;&lt;th&gt;F&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;koosaga&lt;/td&gt;&lt;td&gt;1:56&lt;/td&gt;&lt;td&gt;6:39&lt;/td&gt;&lt;td&gt;15:41&lt;/td&gt;&lt;td&gt;59:08&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;tncks0121&lt;/td&gt;&lt;td&gt;2:52&lt;/td&gt;&lt;td&gt;7:17&lt;/td&gt;&lt;td&gt;23:20&lt;/td&gt;&lt;td&gt;64:17&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;alex9801&lt;/td&gt;&lt;td&gt;2:20&lt;/td&gt;&lt;td&gt;9:56&lt;/td&gt;&lt;td&gt;24:10&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;
&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;문제들이 매우 재밌었다. F가 매우 아름다운 문제이다.&lt;/p&gt;&lt;p&gt;그나저나, D는 내가 카카오 코페 예선에 냈던 &quot;부스터&quot; 랑 매우 비슷한 문제 (약간 더 쉬운 버전) 이었다. 이뭐병;&amp;nbsp;&lt;/p&gt;
&lt;h3&gt;심야: MIPT Autumn 2018 Day5&lt;/h3&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99CBEC385C3063C82C&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2019-01-05 오후 4.55.31.png&quot; height=&quot;770&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;E는 다음과 같은 문제이다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Simple Polygon, 고정된 정수 $R$, 그리고 쿼리가 주어진다. 각 쿼리는 $X_i, Y_i$ 형태인데, $(X_i, Y_i)$ 에 위치한 반지름 $R$ 의 원을 Simple polygon 내부에 완전히 들어가게 움직여야 한다. 원은 자유롭게 움직일 수 있으며 거리는 유클리드 거리를 기준으로 한다. 원이 움직여야 하는 최소 거리를 출력하라. 절대 오차 0.1 이하면 OK. $R$ 을 0.1 이하로 바꿔도 답은 동일. 항상 원이 Polygon 안에 들어가게 할 수 있음을 보장함. 좌표 범위는 $10^6$ 이하, 다각형 크기 / 쿼리 각각 200 이하.&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;풀이가 간단하다고 생각해서 극초반부터 잡았고 3시간을 썼으나 결국 풀지 못했다. 제일 신기했던 건 다른 팀들이 최후반부까지 거의 제출을 안 했고 no solve로 남은 문제였다는 것이다. 그 때 다른 팀들에 주어진 선택지에 비해서 풀이가 매우 간단하다고 생각해서, 무슨 이유였는지 궁금하다. 오차가 빡빡했고 그 팀들에게 그 사실이 명확했거나, 아니면 데이터가 틀려서 clar가 가지 않았을까 생각된다. (자꾸 데이터 얘기를 왜 하냐면.. 이번에도 예제가 문제 조건을 매치하지 않았다)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;B는 아름다운 문제. &lt;a href=&quot;https://atcoder.jp/contests/arc101/tasks/arc101_d&quot;&gt;ARC 101F&lt;/a&gt; 를 최근 푼게 도움이 됐다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;D는 민규가 공식을 찍어서 맞췄다. 입력이 커서 그럴듯한 공식을 찍어보고 계산기로 검증해 볼 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;G는 문제를 잘못 읽어서 못 풀었다 ㅠㅠ.. 확실치는 않은데 그냥 귀찮은 tree dp라고 생각하고 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;H는 확실하게 귀찮은 tree dp다 (...) 케이스를 몇 개를 나눠야 할까..&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I는 흥미로운 문제 같은데 풀이는 모르겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;C J는 쓰레기. 팀원들이 4시간동안 미적분을 정말 열심히 하고 있었다. 눈물이 났다..&lt;/p&gt;
&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;나의 경우에는 E 때문에 시간과 멘탈을 완전히 소모했고, E를 포기하면서 대회를 같이 포기했다. 이 때부터 그냥 재밌어 보이는 문제만 잡자고 생각했고, B I를 스코어보드 상관없이 풀려 시도했으나, 결국 B만 풀 수 있었다. 빡겜하려고 했으면 G 디스크립션을 한번쯤 다시 봤을 거 같긴 하다..&lt;/p&gt;&lt;p&gt;이렇게 MIPT Autumn Camp 연습을 다 돌았다. 야호! &lt;del&gt;함께해서 x같았고 다시는 만나지 말자&lt;/del&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;1월 4일&lt;/h2&gt;
&lt;h3&gt;오전: ARC 063&lt;/h3&gt;
&lt;figure&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;th&gt;C&lt;/th&gt;&lt;th&gt;D&lt;/th&gt;&lt;th&gt;E&lt;/th&gt;&lt;th&gt;F&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;tncks0121&lt;/td&gt;&lt;td&gt;7:58&lt;/td&gt;&lt;td&gt;22:28&lt;/td&gt;&lt;td&gt;39:11&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;alex9801&lt;/td&gt;&lt;td&gt;4:50&lt;/td&gt;&lt;td&gt;11:41&lt;/td&gt;&lt;td&gt;45:04&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;koosaga&lt;/td&gt;&lt;td&gt;4:58&lt;/td&gt;&lt;td&gt;13:48&lt;/td&gt;&lt;td&gt;45:47&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;
&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;나는 E가 구현하기 빡센 문제라고 생각했는데 나만 그렇게 생각한 거 같다 ㅠㅠ&lt;/p&gt;&lt;p&gt;수찬이는 110:32 에 F를 풀었다. 수찬이 풀이에는 증명하지 않은 Lemma 하나가 있었는데, 그대로는 반례가 있었으나 약간 강하게 바꾸니까 쉽게 증명이 되었다 (구현은 강한 형태로 해서 상관 없었음). Lemma의 내용은, 최적해가 항상 바운딩 박스를 반으로 나누는 축평행 직선 둘 중 하나를 지난다는 것이다. 이 Lemma는 공식 풀이에도 없었던 것인데, 이걸 사용하면 구현량과 복잡도가 크게 줄어든다. 나는 Lemma 없이 깡으로 F를 구현하다가 이것 저것 문제만 생기고 대회가 끝났으나, 수찬이는 약간의 추가 시간 이후 무난하게 F를 해결할 수 있었다. 갓.&lt;/p&gt;
&lt;h3&gt;점심: CERC 2018&lt;/h3&gt;&lt;div&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9989573C5C30640828&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2019-01-05 오후 4.55.46.png&quot; height=&quot;743&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;B는 잘 알려진 Dynamic Connectivity 연습 문제였다. 민규가 Path compression을 해서 TLE를 받았다 (...)&lt;/li&gt;
&lt;li&gt;D는 물리였다. 수찬이보다 빨리 풀었다 (자랑 맞음)&lt;/li&gt;
&lt;li&gt;F는 &quot;정의를 이 정도로까지 생략할 수 있구나&quot; 싶은 정도의 문제였다.&lt;/li&gt;
&lt;li&gt;모든 5개의 말에 대해서 서로 다른 케이스를 구현해야 하는 H의 갓문제성에 감탄했다. 심지어 말의 이동 방향은 정의를 안 줬다. 체스를 안 해봐서 이것도 걍 sensible하게 찍었다..&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;독해가 상당히 어려운 셋이었다. 특히, 제대로 정의된 것들이 거의 없어서 문제를 어느 정도 찍어야 했다. 풀이 난이도는 꽤 쉽고, 코딩량은 그저 그런 정도. 역대급 노잼 CERC였다.&lt;/p&gt;</description>
<category>공부</category>
<author>구사과</author>
<guid>https://koosaga.com/225</guid>
<comments>https://koosaga.com/225#entry225comment</comments>
<pubDate>Tue, 15 Jan 2019 01:33:25 +0900</pubDate>
</item>
<item>
<title>2018.12.29 problem solving</title>
<link>https://koosaga.com/224</link>
<description>&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width initial-scale=1&quot;&gt;
&lt;title&gt;&lt;/title&gt;
&lt;h2&gt;Topcoder SRM 744&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Easy는 그대로는 매우 귀찮으나, 2차원 부분합을 구할 때 쓰는 포함 배제 테크닉을 활용하면 조금 덜 귀찮아진다. 물론 그래도 귀찮다. 난 문제를 잘못 읽어서 망했다.&lt;/li&gt;
&lt;li&gt;Medium은 행과 열에 대해서 해당 행 / 열을 뒤집었는가? 를 나타내는 $n+m$ 개의 boolean 변수를 잡으면, 주어진 조건은 $X_i + X_j$ 의 홀짝성에 대한 제약조건으로 바뀐다. 이를 일종의 이분 그래프라고 생각하고 풀어주면 된다... 라는 류의 문제를 한 두 번 본게 아니어서 그냥 아무 생각 없이 코드를 짰으나 문제에 함정이 있다는 것을 늦게 깨달았다. 고치니까 150점.&lt;/li&gt;
&lt;li&gt;Hard는 큰 트리에서 특정한 형태의 선형 계획법 (LP) 를 돌리는 문제이다. small-to-large 트릭을 활용한 그리디 접근법이 있지만 나는 이렇게 해결하지 않았다. LP Duality를 사용하면, Dual Problem이 간단한 Min-cost Max-flow임을 알 수 있다. MCMF라고 하면 복잡도가 매우 클 것 같으나, 그래프가 정말 단순하다. 싱크가 루트고, 소스는 각각의 정점이라서, 경로의 cost는 단순히 각 정점에 부여된 $c_i$ 가 되며 그 최단 경로도 유일하다. 또한, 모든 길이 루트로 가기 때문에 역변도 생기지 않는다! $c_i$ 순으로 정렬하고 유일한 augmenting path를 따라서 흘려주면 $O(n^2)$ 이다. 이렇게 단순한 구성에서는 augmenting 과정이 경로 최솟값 + 경로 덧셈 문제이기 때문에, heavy-light decomposition + segment tree + lazy propagation을 써서 최적화해 주면 된다. $O(n\log^2 n)$. &lt;br /&gt;&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;Hard가 fail되었는데 이유가 참 한심하다. 구글링을 열심히 해 보니 탑코더의 스택 메모리 제한이 8MB라고 한다. 8MB! 그걸로는 주어진 트리에서 DFS도 못 돌린다. 프리오더 구하려면 스택 써야 한다. 웃프다는 말 밖에 할 말이 없다. 탑코더를 할 때마다, 상식적으로 납득 불가능한 기준선에서 내 레이팅이 좌우된다는 느낌을 받을 때가 너무 많다. &lt;del&gt;물론 탑코더보다 스택 메모리 제한이 훨씬 더 답 없는 모 대회도 있다. 그 대회는 심지어 선인장을 내던데... 하지만 그 대회를 비판하는 것은 용납할 수 없다.&lt;/del&gt; 그렇게 5등~7등을 해야 했을 대회를 23등 했으나, 그래도 레이팅이 올랐던 거 같다. ㅋㅋ&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;Atcoder Grand Contest 029&lt;/h2&gt;
&lt;p&gt;거의 1년만에 했는데 잘 했다. 다 풀어서 기분이 좋았다. B E F는 정말 아름다운 문제들이다. A D는 조금 실망스러웠다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A는 사골이다. 어느 정도 사전 지식 문제라고도 생각한다. 왜 안 걸렀는지 모르겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;B는 난이도가 쉬우나 매우 좋은 문제였다. 작은 숫자부터 보면 매칭해야 할 큰 숫자의 가능성이 여럿 있기 때문에 혼란스럽다. 하지만 큰 숫자의 관점에서 보면 매칭해야 할 작은 숫자는 유일하다! $A_i + A_j = 2^K$ 일 때, $i &amp;lt; j$ 라고 하면 $2^{K-1} \le A_j &amp;lt; 2^K$  가 성립한다. $A_j$ 에 대해서 $K$ 가 정해지고 $A_i$ 도 정해진다는 것이다. 이 시점에서부터는 $j$ 를 감소순으로 돌고, 매칭할 수 있으면 무조건 매칭을 시켜 주는 그리디 알고리즘이 가능하다. 그리디 알고리즘은 왜 가능할까? Forest에서 최대 매칭을 찾는 것은 임의의 매칭되지 않은 리프를 잡고 그리디하게 지워 나가는 것을 반복하면 된다. $j$ 에 대해 매칭되는 유일한 $i$ 를 부모라고 생각해 보자. 지금 우리가 하는 것이 정확히 그것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;C는 어려운 문제였다. 조건을 만족하는 임의의 문자열 집합을 생각해 보자. 이 문자열 집합을 Trie에 넣었다고 생각해 보면, 일단은 Trie를 순회했을 때 각 문자열이 순서대로 나올 것이고, 해당 Trie가 필요로 하는 최소 문자 개수는 모든 노드의 자식 개수의 max와 동일하다. 이 관찰을 가지고 답에 대해서 이분탐색 하자. 과정은 그리디하게 Trie를 만드는 과정이라고 해석될 수 있는데, 이는 스택에 해당 노드의 깊이, 자식 개수를 저장하는 식으로 가능하다. 난 이 부분을 깔끔하게 생각하고 구현하는 것이 매우 어려웠고, 결국 푸는 데 상당한 시간을 소모했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;D는 난이도가 B보다 훨씬 쉬우나 (A가 사전 지식임을 감안하면 그것보다도 쉬우나) 그 자리에 있었다. 난이도의 적절성을 떠나서 그냥 문제 자체가 안 좋다. 출제 과정에서 걸러지지 않은 게 이상한 문제. &lt;a href=&quot;https://codeforces.com/blog/entry/63812#comment-476671&quot;&gt;내 생각&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;E는 AGC 레벨의 문제였고 재미있었다. 나는 주최 풀이랑 조금 다른 복잡한 풀이였다. 어떠한 정점에서 루트로 올라간다는 것은, 한번 서브트리를 돌다가 부모를 찍고, 부모 쪽에서 또 돌다가 그 부모를 또 찍는 형태의 경로이다. 여기서 좋은 필요충분을 만들 수 있다. 임의의 정점 $v$ 에 대해서, $v$ 가 돌아다니는 와중에 정점 $w$ 를 만난다는 것은, $(LCA(v, w), w]$ 경로의 최댓값이 $[1, LCA(v, w))$ 간의 경로 최댓값보다 작다는 뜻이다. (포함 관계를 표현하기 위해 개구간 / 폐구간같은 기호를 썼음에 유의). $v$ 랑 상관 없이 LCA에 대해서 모든 것이 결정되기 때문에 저 값을 전처리하면 대략 부모 - 자식 경로 합 문제로 환원할 수 있다. &lt;/p&gt;&lt;p&gt;구해야 하는 것은 각 에지 $(par(w), w)$ 에 대해서 $[1, w)$ 최댓값보다 작은 최댓값을 가지는 정점의 개수이다. Small-to-large의 요령으로 $w$ 에서의 최댓값을 priority queue에 관리할 수 있다. priority_queue 에서 구간 쿼리를 할 수는 없지만, 어떠한 정점이 빠지고 추가되었는지의 수열을 알 수 있다. 이 수열의 길이는 $O(n \log n)$ 이다. DFS로 이 수열을 다시 한번 시뮬레이션 해 보는데, 이제는 priority queue 대신 Fenwick tree를 사용한다. Fenwick tree니까 구간 쿼리를 할 수 있고, 이제 각각의 에지에 대해서 원하는 값을 구해 놓았으니 문제를 푸는 것은 어렵지 않다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;F의 직관은, $K$ 개의 집합을 합집합했을 때 정수가 $K$ 개 이하이면 절대 트리를 절대 만들 수 없다는 것이다 (당연히, 간선이 많아야 $K-1$ 개 생기니까). 임의의 $K$ 개의 집합을 합집합했을 때 정수가 $K+1$ 개 이상이면 항상 트리를 만들 수 있을까? 여기서 홀의 결혼 정리와 analogy를 만들 수 있다. 홀의 결혼 정리는 임의의 $K$ 개의 집합을 합집합했을 때 매칭 가능한 쌍이 $K$ 개 이상이면 항상 답이 존재한다는 내용이다. &lt;/p&gt;&lt;p&gt;홀의 결혼 정리는 constructive한 증명을 가지고 있다. 그렇다면 우리의 추측도 constructive한 증명을 시도하면 도움이 될 것이다. 아무 정점을 루트로 잡고 시작하자. 이 정점을 모든 집합에서 빼도, 임의의 $K$ 개의 집합을 합집합하면 크기가 $K$ 개 이상이다. 고로 홀의 결혼 정리에 의해 각각의 집합에서 루트가 아닌 서로 다른 정점을 고를 수 있다 (직접 구하는 것은 Hopcroft-Karp 이분 매칭을 사용. 이분 매칭이 없으면 자명히 답이 없다.) &lt;/p&gt;&lt;p&gt;위에서 구한 매칭을 토대로 트리를 만드는 것은 아주 간단하다. 루트에서 시작해서, 루트를 포함하는 모든 집합을 돌자. 해당 집합에 매칭된 정점과, 루트를 잇는 간선을 만들어주자. 이렇게 루트에서 모든 가능한 정점들을 이었다면, 이 정점들에 대해서도 자식을 이어줄 필요가 있다. 그래프 탐색을 하듯이, 이들을 큐에 넣어서 BFS를 하고, 그 정점들에 대해서도 똑같은 작업을 시행한다 (물론, 이미 연결된 정점을 다시 이으면 안되는 것은 당연하다.)&lt;/p&gt;&lt;p&gt;이제 알고리즘의 정당성을 증명하기 위해서는 저 과정이 모든 답이 존재하는 트리에 대해서 절대 &quot;실패하지&quot; 않음을 보이는 것으로 충분하다. 저 과정이 실패한다는 것은, 모든 과정이 끝난 이후 루트에서 연결된 정점이 $N$ 개 미만임을 뜻한다. 그 컴포넌트의 크기를 $K$ 라고 하자. 연결된 $K-1$ 개의 정점은 그에 매칭된 $K-1$ 개의 집합을 가지고 있다. 나머지 $N-K$ 개의 집합은 지금 잡은 컴포넌트의 정점을 전혀 포함하고 있지 않다. 만약에 그렇다고 하면, 즉 그러한 집합 중 하나가 컴포넌트 상의 임의의 정점을 포함한다면, 그 집합은 발견되었을 것이고, 그 집합에 매칭된 정점이 추가되었을 것이기 때문에 가정에 모순이다. 즉, 나머지 $N-K$ 개의 집합의 합집합 크기는 $N-K$ 이하이다. 그렇다면 이 트리에서는 답을 구하는 것이 불가능하다.&lt;/p&gt;&lt;p&gt;여담으로, 4번째 문단은 지금 글을 쓰면서 증명하는 것이고, 대회 때는 주어진 시간도 없었고 완전히 증명하기엔 시간이 아깝다고 생각해서 그냥 짰고 맞았다.&lt;/p&gt;
&lt;/li&gt;

&lt;/ul&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;Educational CF #56&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A. $n/2$.&lt;/li&gt;
&lt;li&gt;B. 정렬.&lt;/li&gt;
&lt;li&gt;C. $a_i$ 를 가능한 최소로 유지.&lt;/li&gt;
&lt;li&gt;D. bipartite coloring.&lt;/li&gt;
&lt;li&gt;F는 복잡한 DP 포함 배제였다. 난 매우 복잡했는데 어떻게 그렇게 빨리 풀었는지 잘 모르겠다.. 하다가 힘 빠져서 포기할 뻔 했다.&lt;/li&gt;
&lt;li&gt;G는 abs(x) = max(x, -x) 임을 관찰하면 간단한 구간 최댓값 연습 문제이다. 무슨 약을 먹었기에 E 뒤에 넣었을까..&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;E번은 귀찮은 과정을 통해서 2D 평면에 점 추가 + 제거 + 개수 세기 문제로 환원될 수 있다. 그렇게 좋은 문제는 아니라고 생각하지만, gritukan의 코드를 보다가 매우 간단한 방법을 찾아서 이를 소개하려고 한다. &lt;/p&gt;&lt;p&gt;일단 위 문제는 2차원 Segment Tree를 만들면 이론적으로는 쉽게 풀 수 있다는 것에 주목하자. 2차원 Segment Tree에서 점 추가는 $O(\log N)$ 개의 1차원 Segment Tree 노드 갱신, 구간 쿼리는 $O(\log N)$ 개의 1차원 Segment Tree 노드 쿼리로 환원된다. &lt;/p&gt;&lt;p&gt;이 때, 이 문제가 Offline이니까, 이 과정들을 한번씩 해 주면서 각 쿼리에서 갱신되는 Segment Tree가 무엇이고 구간 합을 구하는 Segment Tree가 무엇인지 알 수 있다. 진짜 갱신을 하고 구간 합을 구하는 게 아니다. 각 노드마다 Segment Tree를 실제로 만들지도 않는다. 그냥 그러는 시늉만 하고, 실제로는 각 노드에 갱신 / 쿼리 sequence만 저장하는 것이다. 이제 모든 문제는 노드에 대해서 독립적이다. 그리고 각 노드에 저장된 것은 1차원 점 갱신, 구간 합 문제이다. 그건 쉬운 문제니까, 각 노드를 돌면서 Fenwick Tree로 그 문제를 &quot;진짜로&quot; 풀어주면 된다. &lt;/p&gt;&lt;p&gt;그동안은 각 노드에 대해 &quot;압축된 BIT&quot; 를 하는 방법만 알았는데, 이 새로운 방법은 다양한 문제에 대해 일반화되고 구현도 매우 간단하며 효율적이다. 오프라인 2차원 쿼리를 하는 이상적인 방법인 것 같다. &lt;/p&gt;&lt;p&gt;여담으로 이러한 오프라인 2차원 쿼리에 대해 나중에 시간이 나면 (...) 튜토리얼을 써 볼 생각이다. 라인 스위핑이 안 되는 상황에서는 위 방법과 분할 정복이 2차원 쿼리를 하는 이상적인 방법으로 보인다. &lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2&gt;COCI 2018/2019 Round 3&lt;/h2&gt;
&lt;p&gt;3번하고 5번 말고는 문제가 별로 재미가 없다. 나는 Educational과 겹쳐서 시간이 별로 없었다. 3번은 상당히 어려운 문제인 것 같은데 굉장히 앞에 있다. bmerry도 이상하게 풀었던데 공식 풀이의 상태가 약간 의심된다.. 고민해 봐야 할 듯.&lt;/p&gt;&lt;p&gt;5번 문제는 괜찮은 튜토리얼 문제인 것 같다. 옛날에 코드포스에 비슷한게 나왔었고 &lt;a href=&quot;http://koosaga.com/131&quot;&gt;그때도 writeup을 했으나&lt;/a&gt; 제대로 안 쓰여 있으니 그냥 다시 쓰도록 하자 (...)&lt;/p&gt;&lt;p&gt;주어진 그래프에 대해서 스패닝 트리를 하나 잡고, 이 스패닝 트리에 있는 간선은 가중치를 바꾸지 않을 것이라 약속하자. 이렇게 하면 스패닝 트리에 없는 나머지 간선들은 연산의 대상이 되고, 이 간선에 &quot;실제로 배정되어야 할 가중치 값&quot; 역시 알 수 있다. 이 가중치 값만 맞추면 문제의 제약 조건이 지켜진다. &lt;/p&gt;&lt;p&gt;각각의 간선에 대해서 독립적인 문제가 되니, 이제는 그래프를 잊고, 다음과 같이 생각할 수 있다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$M-N+1$ 개의 수가 주어진다. subset에 특정한 수를 xor하는 연산을 최소로 실행해서 전체 수를 0으로 만들자.&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;최소가 아니라 적당히 작은 횟수의 연산이라고 하자. 그러면 단순히 1, 2, 4, 8과 같은 $2^k$ 형태의 수를 모두 해보면, 각각의 비트를 하나 하나 끌 수 있다. 많아야 60번의 연산으로 모든 수를 지울 수 있는 것이다. 하지만 이것이 최소는 아니다. &lt;/p&gt;&lt;p&gt;여기부터는 뭐 길게 얘기할 수도 있긴 하나... 그냥 짧게 하자면, 모든 수를 binary vector로 보고, basis를 구해주면 된다. basis 집합은 선형 독립이기 때문에, 개념적으로 $1, 2, 4, 8$ 과 같은 수랑 다를 바가 없다. basis를 크기 감소 순으로 봐주고, basis의 가장 큰 비트가 켜져 있는 숫자들에 모두 연산을 한꺼번에 실행하자. 그러면 각 연산마다 가장 큰 비트를 항상 날려줄 수 있다. 그리고 이 과정이 실패하는 경우는 없다. basis 크기 만큼의 연산으로 문제를 해결할 수 있고, 이보다 더 적은 횟수로 할 수 없음은 그 개념을 안다면 자명할 것이다.&lt;/p&gt;&lt;p&gt;이 전략을 알면, 스패닝 트리를 뭘 잡는 지는 아무 상관이 없다는 것 역시 알 수 있다. 어떤 스패닝 트리를 잡아도, 사이클에 적혀있는 수들은 이 basis의 선형 결합으로 표현되기 때문이다. 고로 스패닝 트리를 아무거나 잡아도 알고리즘이 정당하다. &lt;/p&gt;&lt;p&gt;지금까지 다룬 내용은 기초적인 선형 대수학으로 커버되고, 이 정도 수학은 PS를 포함해 컴퓨터 과학 전반에 매우 유용하게 쓰이기 때문에 상위권을 노린다면 알아두는 것이 좋다. 관련 연습 문제로는 &lt;a href=&quot;http://koosaga.com/132&quot;&gt;XOR Maximization&lt;/a&gt; 이 있다. 최근 고려대 대회에서도 이 XOR Maximization을 약간 응용한 &lt;a href=&quot;https://www.acmicpc.net/problem/16685&quot;&gt;XOR 포커&lt;/a&gt;라는 문제가 나왔다. 이 문제는 여러가지 풀이가 있는데, 내 풀이와 공식 풀이에서 쓰인 아이디어는 간단하지만 상당히 신선했고, 재미있었다.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;Atcoder Study&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&quot;https://atcoder.jp/contests/arc102/tasks/arc102_d&quot;&gt;ARC 102 F. Revenge of BBuBBBlesort!&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;가장 핵심적인 관찰은, 스왑의 대상이 되는 숫자들이 서로 인접할 수 없다는 것이다. 이는 $p_{i-1} &amp;gt; p_i &amp;gt; p_{i+1}$ 조건 때문인데, 엄밀하게는 나도 잘 모르겠고, 대충 해 보면 말이 안되는 것 같다는 것을 알 수 있다 (....) 이 관찰을 하면 문제가 굉장히 접근 가능해진다. 모든 스왑의 대상이 되는 숫자들이 2 / 3 이상 떨어져 있는데, 3 이상 떨어져 있으면 그냥 독립적인 이야기니까 (나랑 섞일 수 있는 수가 아니니까) 2만큼 떨어져 있는 chain들의 집합이 된다.&lt;/p&gt;&lt;p&gt;어떠한 수 $i$ 를 대상으로 해서 스왑을 진행한다는 것은 $swap(p_{i-1}, p_{i+1})$ 을 한다는 것과 똑같은 말이다. 그러면 $i, i+2, i+4, \cdots, i + 2k$ 를 대상으로 스왑한다는 것은, $i, i+2, \cdots, i+2k$ 는 전혀 안 건드리고, $i-1, i+1, i+3, \cdots, i+2k+1$ 만 건드린다는 뜻이다. (이들은 그 값이 &lt;strong&gt;무조건&lt;/strong&gt; 바뀐다. 아니면 3개가 증가하기 때문에 그들 양 옆이 안 통한다..) 이렇게 되면 대충 수열을 partition할 수 있다. 현재 제자리에 없는 수들을 전부 모으고, 이 중에 인접한 것이 없는 지 확인하고 (있으면 무조건 -1), 없으면 이제 거리가 2인 애들끼리 묶어준 후 각각에 대해서 문제를 해결하는 것이다. 이렇게 문제가 많이 단순화된다. &lt;/p&gt;&lt;p&gt;이들에 대해서 인접한 숫자를 교환할 수 있으니까 대충 생각하면 버블 소트처럼 항상 정렬이 될 것 같으나, 사실은 그렇지 않다. 왜냐면 두 수를 교환하기 위해서 $p_{i-1} &amp;gt; p_i &amp;gt; p_{i+1}$ 이라는 조건이 있어서, 두 수 사이에 있는 수의 크기가 교환에 영향을 미친다. 이를 조금 더 살펴보자. 일단 구간 $[i-1, i+2k+1]$ 을 정렬했을 때 모든 숫자가 제자리에 있는지를 확인하자 (당연히 확인해야 한다). 그렇지 않다면 결국 $p_i = i, p_{i+2} = i+2 \ldots$ 를 만족할 것이고, 나머지 숫자들은 모두 제자리에 없을 것이다. 최솟값부터 옮겨 보자. 최솟값을 가장 왼쪽으로 옮기기 위해서는, 그 사이에 있는 수들이 모두 바로 오른쪽에 있는 수보다 커야한다. 두번째 최솟값 역시 그를 만족해야 한다. 이를 위해서는, 두번째 최솟값이 첫번째 최솟값보다 무조건 오른쪽에 있어야 한다.. 이런 식으로 논리를 펼쳐 나가면 대략 결론이 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;최종 위치가 왼쪽으로 가는 애들끼리 ($p_i &amp;lt; i$) 놓고 보았을 때 이들은 증가해야 한다.&lt;/li&gt;
&lt;li&gt;최종 위치가 오른쪽으로 가는 애들끼리 ($p_i &amp;gt; i$) 놓고 보았을 때 이들은 증가해야 한다.&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;저걸 만족하면 항상 정렬이 가능하다. 증명을 제대로 안 했으나 둘을 따로 본다면 어렵지 않을 것으로 보인다. 아무튼 시간 복잡도는 $O(n\log n)​$ 혹은 그 이하.&lt;/p&gt;</description>
<category>공부</category>
<author>구사과</author>
<guid>https://koosaga.com/224</guid>
<comments>https://koosaga.com/224#entry224comment</comments>
<pubDate>Sat, 29 Dec 2018 19:14:11 +0900</pubDate>
</item>
<item>
<title>더불어민규당 2018년 연말 팀연습</title>
<link>https://koosaga.com/223</link>
<description>&lt;p&gt;방학동안 삼성전자 소프트웨어 멤버쉽에서 팀연습을 계속 진행하고 있다. 아래는 그 기록이다.&lt;/p&gt;&lt;h2&gt;12월 23일&lt;/h2&gt;&lt;h3&gt;&lt;a href=&quot;https://atcoder.jp/contests/arc077/tasks&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;아침: Atcoder Regular Contest 077&lt;/a&gt;&lt;br /&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;table class=&quot;txc-table&quot; style=&quot;border:none;border-collapse:collapse;;font-family:&quot; 맑은=&quot;&quot; 고딕&quot;,=&quot;&quot; sans-serif;font-size:13px&quot;=&quot;&quot; width=&quot;784&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;width: 157px; height: 24px; border-color: rgb(204, 204, 204); border-style: solid; border-width: 1px;&quot;&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 157px; height: 24px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204); border-top: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;C&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;border-top:1px solid #ccc;;&quot;&gt;&lt;p&gt;D &lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;border-top:1px solid #ccc;;&quot;&gt;&lt;p&gt;E &lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;border-top:1px solid #ccc;;&quot;&gt;&lt;p&gt;F &lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 157px; height: 24px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204); border-left: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;&amp;nbsp;koosaga&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 157px; height: 24px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;3:04&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;;&quot;&gt;&lt;p&gt;17:04 &lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;;&quot;&gt;&lt;p&gt;26:24&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;;&quot;&gt;&lt;p&gt;- &lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 157px; height: 26px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204); border-left: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;&amp;nbsp;tncks0121&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 157px; height: 26px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;4:51&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 156px; height: 26px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;21:30 &lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 156px; height: 26px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;45:37 &lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 156px; height: 26px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;-&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 157px; height: 24px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204); border-left: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;&amp;nbsp;alex9801&lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 157px; height: 24px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;24:20 &lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;;&quot;&gt;&lt;p&gt;34:13 &lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;;&quot;&gt;&lt;p&gt;47:11 &lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;;&quot;&gt;&lt;p&gt;-&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;점심: GP of Xian&lt;/h3&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/999A69415C2635B82D&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2018-12-28 오후 11.39.23.png&quot; height=&quot;746&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;매우 말려서 루즈한 분위기로 계속 진행했는데 끝나고 나니까 등수가 기대 이상으로 높았다. 대체 왜 높을까..&lt;br /&gt;&lt;/p&gt;&lt;p&gt;* A는 풀이가 궁금한데 아무도 안 적어 준다.&lt;/p&gt;&lt;p&gt;* B는 NEERC 2018 I와 비슷한 유형의 카운팅 문제이다. 수학 못하는 팀이라 대회 때는 아무도 안 잡았다 (그건 잘 한거 같다.) 나중에 NEERC 업솔브 할 일 있으면 비슷한 유형으로 풀어보면 좋을 것 같다.&lt;/p&gt;&lt;p&gt;* C는 쓰레기 문제이다. 대회 때는 수찬이가 치워줬다. bitset에 4의 배수를 memset(bset, 0x11, sizeof(bset)) 으로 마킹하는 등의 삽질을 해서 맞았다. 1ll &amp;lt;&amp;lt; 64 때문에 한번 fail했다.&lt;br /&gt;&lt;/p&gt;&lt;p&gt;* G는 귀찮은 construction인 것 같다. 민규가 계속 잡다가 결국 풀어줬다. v.size() &amp;gt;= k - 2 라는 구문이 k = 1일 때 fail해서 틀렸다. 조심해야 한다. 그때 그때 고민하기 보다는 차라리 매크로를 쓰는 습관을 들이는 게 나을 것 같다.&lt;/p&gt;&lt;p&gt;* J는 잘 알려진 Matrix Game을 LCP array에서 하는 문제이다. 우리는 접근 방향이 잘못되어서 풀지 못했다. 어떠한 상황이어도 풀기는 힘들었을 문제일 것 같다.&lt;br /&gt;&lt;/p&gt;&lt;p&gt;* K는 나이브한 풀이를 적당히 효율적으로 짜면, 그다지알고 싶지 않은 이유로 빠를 것 같았던 문제였다. 더 빠른 풀이를 찾지도 못하겠고 컴퓨터도 비어서 그냥 짰고 맞았다.&lt;/p&gt;&lt;h2&gt;12월 24일&lt;/h2&gt;&lt;h3&gt;&lt;a href=&quot;https://atcoder.jp/contests/arc069/tasks&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;점심: Atcoder Regular Contest 069&lt;/a&gt;&lt;/h3&gt;&lt;table class=&quot;txc-table&quot; style=&quot;border:none;border-collapse:collapse;;font-family:&quot; width=&quot;784&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;width: 157px; height: 24px; border-color: rgb(204, 204, 204); border-style: solid; border-width: 1px;&quot;&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 157px; height: 24px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204); border-top: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;C&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;border-top:1px solid #ccc;;&quot;&gt;&lt;p&gt;D &lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;border-top:1px solid #ccc;;&quot;&gt;&lt;p&gt;E &lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;border-top:1px solid #ccc;;&quot;&gt;&lt;p&gt;F &lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 157px; height: 24px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204); border-left: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;&amp;nbsp;koosaga&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 157px; height: 24px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;2:38&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;;&quot;&gt;&lt;p&gt;12:53&lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;;&quot;&gt;&lt;p&gt;19:18&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;;&quot;&gt;&lt;p&gt;42:12&lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 157px; height: 23px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204); border-left: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;&amp;nbsp;alex9801&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 157px; height: 23px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;3:29&lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 156px; height: 23px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;16:04&lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 156px; height: 23px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;28:53&lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 156px; height: 23px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;-&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 157px; height: 24px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204); border-left: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;&amp;nbsp;tncks0121&lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 157px; height: 24px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;13:01&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;;&quot;&gt;&lt;p&gt;19:08&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;;&quot;&gt;&lt;p&gt;59:54&lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;;&quot;&gt;&lt;p&gt;-&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;F 못푼 거 반성합시다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3&gt;저녁: JAG Autumn 2016&lt;/h3&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99B5DE4E5C263A1D11&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2018-12-28 오후 11.56.54.png&quot; height=&quot;144&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;나 혼자 vs 민규+수찬 팀으로 붙었다.&lt;br /&gt;&lt;/p&gt;&lt;p&gt;나의 경우에는 잔 실수가 많은게 아쉬웠으나 나쁘진 않았다. J는 어찌됐든 대회 시간에 풀기는 쉽지 않았을듯.&lt;/p&gt;&lt;p&gt;  셋은 재밌었고 특히 F/H가 좋은 문제였다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h2&gt;12월 25일: Merry Christmas!&lt;/h2&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;h2&gt;12월 26일&lt;br /&gt;&lt;/h2&gt;&lt;div&gt;&lt;h3&gt;&lt;a href=&quot;https://atcoder.jp/contests/arc078/tasks&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;아침: Atcoder Regular Contest 078&lt;/a&gt;&lt;/h3&gt;&lt;table class=&quot;txc-table&quot; style=&quot;border:none;border-collapse:collapse;;font-family:&quot; width=&quot;784&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;width: 157px; height: 24px; border-color: rgb(204, 204, 204); border-style: solid; border-width: 1px;&quot;&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 157px; height: 24px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204); border-top: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;C&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;border-top:1px solid #ccc;;&quot;&gt;&lt;p&gt;D &lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;border-top:1px solid #ccc;;&quot;&gt;&lt;p&gt;E &lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;border-top:1px solid #ccc;;&quot;&gt;&lt;p&gt;F &lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 157px; height: 24px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204); border-left: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;&amp;nbsp;koosaga&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 157px; height: 24px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204);&quot;&gt;2:54&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;;&quot;&gt;&lt;p&gt;7:18&lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;;&quot;&gt;&lt;p&gt;31:53&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;;&quot;&gt;&lt;p&gt;44:47&lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 157px; height: 23px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204); border-left: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;&amp;nbsp;alex9801&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 157px; height: 23px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;3:35&lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 156px; height: 23px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204);&quot;&gt;8:47&lt;/td&gt;
&lt;td style=&quot;width: 156px; height: 23px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;51:35&lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 156px; height: 23px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;-&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 157px; height: 24px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204); border-left: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;&amp;nbsp;tncks0121&lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 157px; height: 24px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204);&quot;&gt;4:00&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;;&quot;&gt;&lt;p&gt;18:39&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;;&quot;&gt;54:31&lt;/td&gt;
&lt;td style=&quot;width:156;height:24;border-bottom:1px solid #ccc;border-right:1px solid #ccc;;&quot;&gt;&lt;p&gt;-&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;F 못푼 거 반성합시다. (그래도 이번에는 수찬이가 밥먹고 바로 업솔빙을 했다.)&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3&gt;점심: Moscow Workshops 2018 Day 1&lt;/h3&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99233D375C263C6302&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2018-12-29 오전 12.07.51.png&quot; height=&quot;262&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;우리가 할 때는 스코어보드가 고장나서 안 보였다. 수찬이랑 민규는 잘못된 문제를 붙잡고 있었고 (C) 나는 제대로 된 문제를 붙잡았으나 말아먹고 있었다 (A). 거의 반쯤 포기한 상태로 돌았고, 실제로 D같은 건 스코어보드를 안 보면 용기를 내기 힘든 문제라서.. 결과 보니 안 좋은 상황에서도 그런대로 잘 한 거 같다. &lt;br /&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;사실 옛날에 ainta / cki 랑 돈 문제가 4~5개 있어서, 어느 정도 알고 있는 셋이긴 했다. 다행이도 내가 그때 푼 문제는 하나밖에 없었고, 그마저도 그때보다 많은 시간+페널티를 써서 풀어서(...) 상관이 없어졌다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;그나저나 C는 그때 cki가 3시간 안에 푼 문제였다. 역시 존나 잘하면 스코어보드 같은 건 상관 없다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h2&gt;12월 27일&lt;/h2&gt;&lt;h3&gt;심야: NWERC 2018&lt;br /&gt;&lt;/h3&gt;&lt;p&gt;민규와 내가 일정이 있어서 비운 날이었는데, dotorya / ainta가 셋 돌자 그래서 NWERC 2018을 돌았다. 민규는 그 때도 소멤에 없어서, 나랑 수찬이가 각자 돌았다.&lt;/p&gt;&lt;p&gt;opentrains가 갑자기 죽어서 연습이 개판났다. 결국 백준에서 했다. 정신이 없어서 페널티는 못 세고, 문제 수만 세었다.&lt;br /&gt;&lt;/p&gt;&lt;table class=&quot;txc-table&quot; style=&quot;border:none;border-collapse:collapse;;font-family:&quot; 맑은=&quot;&quot; 고딕&quot;,=&quot;&quot; sans-serif;font-size:13px&quot;=&quot;&quot; width=&quot;784&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;width: 204px; height: 24px; border-color: rgb(204, 204, 204); border-style: solid; border-width: 1px;&quot;&gt;&lt;p&gt;&amp;nbsp;dotorya&lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 579px; height: 24px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204); border-top: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;&amp;nbsp;11 (ABCDEFGHIJK). Last AC 233min&lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 204px; height: 24px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204); border-left: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;&amp;nbsp;koosaga&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 579px; height: 24px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;&amp;nbsp;9 (ABC*E*GHIJK). Last AC 240min&lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 204px; height: 24px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204); border-left: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;&amp;nbsp;ainta&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 579px; height: 24px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;&amp;nbsp;9 (ABC**FGHIJK). Last AC 250min &lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;width: 204px; height: 24px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204); border-left: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;&amp;nbsp;tncks0121&lt;/p&gt;&lt;/td&gt;
&lt;td style=&quot;width: 579px; height: 24px; border-bottom: 1px solid rgb(204, 204, 204); border-right: 1px solid rgb(204, 204, 204);&quot;&gt;&lt;p&gt;&amp;nbsp;9 (ABC*E*GHIJK). Last AC 269min &lt;br /&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;* A는 SCPC 기출이라 개꿀빨았다.&lt;/p&gt;&lt;p&gt;* B는 카이스트 가을 대회에 나온 두메랑 비슷하게 풀면 된다. 근데 두메에 비해서 훨씬 간단한 문제라 그냥 대충 해도 두메와 비슷한 결론이 나온다.&lt;/p&gt;&lt;p&gt;* F는 너무 sketchy한 문제였다. 성질 분석이 너무 안 돼서 구현할때까지 긴가민가.. 대회 끝나고 몇 줄 더 짜니까 AC가 나왔다. 흑흑 ㅠㅠ&lt;/p&gt;&lt;p&gt;* J는 너무 짜증나는 문제였다.&lt;/p&gt;&lt;p&gt;* K도 너무 헷갈려서 푸는 데 30분 걸렸다.&lt;br /&gt;&lt;/p&gt;&lt;p&gt;* D는 안읽음.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h2&gt;12월 28일&lt;/h2&gt;&lt;h2&gt;오후: JAG Autumn 2014 + Autumn 2012 HI&lt;br /&gt;&lt;/h2&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/999129385C2640D206&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2018-12-29 오전 12.26.53.png&quot; height=&quot;415&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;수찬이가 어제도 잘 달리더니 오늘은 결국 내가 졌다.&lt;/p&gt;&lt;p&gt;* C 진짜 졸라 싫다... 1시간 이상 낭비했는데 그냥 블랙홀이었고 그냥 처음부터 보지도 않는 게 답이었다. 약간의 수학을 하면 N^2 풀이는 무난하게 찾을 수 있는데, 이 계산을 대충 하면 단위가 너무 커져서, 실수 오차를 잘 관리하면서 풀어야 하는 것이 문제의 핵심이었다. 난 대충 찍어서 했더니 WA가 나와서, 가정이 틀린 거라고 생각하고 그냥 자료구조로 잘 비벼서 어떻게든 실수 오차를 잡으려고 하다가 망했다. 알고 보니 대충 찍은 그걸 잘못 짰고, 제대로 짜면 proof by AC하는 문제. 진짜 너무 싫다.&lt;/p&gt;&lt;p&gt;* F는 좋은 문제.&lt;br /&gt;&lt;/p&gt;&lt;p&gt;* C를 포기해야겠다 생각한 시점에서 이미 문제 하나가 후달려서 열라 달렸다. JK는 그래도 빠르게 밀었다. 28분 남은 시점에서 E를 할까 L을 할까 하다가 바로 풀이가 보였던 L을 잡았다. 대회 끝나기 20초 전에 다 짰는데 틀렸다 ㅠㅠ 그래도 코드가 심하게 틀리진 않았다. (예상치 못한 곳에서 수가 커져 오버플로우가 나고 있었다). 흑흑 ㅠㅠ 28분은 무리데스..&lt;br /&gt;&lt;/p&gt;&lt;p&gt;* M은 연습 만들다 의도치 않게 실수로 넣은 문제다. 샥후님 코드가 9000바이트를 넘는다...&lt;/p&gt;</description>
<category>공부</category>
<author>구사과</author>
<guid>https://koosaga.com/223</guid>
<comments>https://koosaga.com/223#entry223comment</comments>
<pubDate>Sat, 29 Dec 2018 00:38:30 +0900</pubDate>
</item>
<item>
<title>2018.12.01 problem solving</title>
<link>https://koosaga.com/222</link>
<description>&lt;p&gt;난이도 순입니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3&gt;1. &lt;a href=&quot;https://abc051.contest.atcoder.jp/tasks/abc051_b&quot;&gt;ARC 051. Sum of Three Integer&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;$A, B$ 를 정하면, $C = S - A - B$ 로 자동으로 정해집니다. 고로 모든 $A, B$ 를 이중 루프로 순회하고, $0 \leq C \leq K$ 를 확인하면 됩니다. $A, B$의 가짓수가 각각 $K+1$개이니 시간 복잡도는 $O(K^2)$입니다. &lt;/p&gt;&lt;p&gt;포함배제 원리를 사용한 $O(1)$ 풀이도 있지만, 이 문제에서는 필요 없습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;2. &lt;a href=&quot;https://www.acmicpc.net/problem/8094&quot;&gt;POI 1997. Canoes&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;먼저 각각의 사람을 몸무게 순으로 정렬해 놓읍시다. 가장 가벼운 사람은 다른 사람과 보트를 태워 보내는 것이 합리적으로 보이니, 가장 가벼운 사람을 보낼 때는, 다른 사람 한 명을 잡아서 같이 보트를 태워 보냅니다. 같이 탈 수 있는 사람이 여럿이면 물론 몸무게가 무거운 사람을 보내는 것이 현명합니다. 두 번째, 세 번째로 가벼운 사람들에게 이를 반복하고, 같이 태워 보낼 수 있는 사람이 없을 때까지 이를 반복합니다. &lt;/p&gt;&lt;p&gt;이 알고리즘의 구현은, 정렬된 배열에서 현재 보낼 무거운 사람의 “포인터” 를 가지고 있으면 간편합니다. 가벼운 사람이 있을 때, 이 사람의 몸무게를 맞출 수 있을 때까지 포인터를 앞으로 (몸무게가 감소되는 쪽으로) 내려주고, 그 사람과 매칭시킨 후, 포인터를 다시 내려줍니다. 시간 복잡도는 $O(n\log n)$ 정도입니다. 입력 크기가 작아 정렬을 할 때 카운팅 정렬을 써도 됩니다.&lt;/p&gt;&lt;p&gt;이 그리디 알고리즘의 정당성은 다음 Lemma에 의해 보여집니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Lemma&lt;/strong&gt;. 2인 보트를 T번 보낼 때, 가장 가벼운 T명이 서로 다른 2인 보트에 타는 해가 항상 존재한다.  &lt;/p&gt;&lt;p&gt;증명은 귀류법으로 가능합니다. 문제의 난이도에 비해서 증명이 그렇게 쉽지 않습니다. 여기서는 생략합니다. &lt;/p&gt;&lt;p&gt;다른 방법으로는, 답 $T$에 대해서 이진탐색한 후, $a_i + a_{2T-1-i}$가 모든 $0\leq i &amp;lt; T$에 대해서 성립하는 지 보는 것입니다. 역시 시간 복잡도는 $O(n\log n)$이며, 정당성은 위 Lemma에 의해 자명합니다.&lt;/p&gt;&lt;p&gt; &lt;br /&gt;&lt;/p&gt;
&lt;h3&gt;3.  &lt;a href=&quot;https://www.acmicpc.net/problem/16043&quot;&gt;NAIPC 2018. Missing Gnomes&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;결과 수열의 숫자를 왼쪽부터 순서대로 채워 나갑시다. 선택지는 두 가지입니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;현재 부분 수열의 맨 앞에 있는 원소를 골라서 넣기. 이 수를 넣으면 부분 수열의 맨 앞 원소는 사라지고 뒤에 있는 원소가 하나씩 앞으로 밀릴 것입니다 (Queue와 비슷). &lt;/li&gt;
&lt;li&gt;부분 수열에 올라오지 않았던 원소 중 하나를 골라 넣기. 원소를 고를 때는 당연히 가장 작은 원소를 고르는 것이 좋습니다.&lt;/li&gt;

&lt;/ol&gt;
&lt;p&gt;  이 두 가지 경우 중 가장 작은 숫자가 나오는 경우를 그때 그때 Greedy하게 고르면 됩니다. 사전순 비교는 앞에서부터 차례대로 보면서 처음으로 숫자가 다를 때 비교를 멈추기 때문에, 여러 경우가 있다면 맨 앞에 있는 원소를 최소화하는 게 가장 중요합니다. 고로 이러한 Greedy 전략은 올바릅니다. &lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3&gt;4. &lt;a href=&quot;https://codeforces.com/gym/101081/problem/A&quot;&gt;2011 USP Tryouts. Card Show&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;이 문제는 제한이 (아주 작지는 않지만) 작은 편이기 때문에 다양한 풀이가 존재할 수 있습니다. 여기서는 가장 깔끔하고 또한 효율적인 $O(52n + q\log n)$ 풀이를 소개합니다. 더 느리지만 생각하기 쉬운 풀이가 있을 수도 있습니다.&lt;/p&gt;&lt;p&gt;일반적인 구간 갱신 / 구간 합 문제에서 가장 자주 사용되는 구조인 Segment Tree를 사용해 봅시다 (자료 구조에 대한 설명은 생략합니다). 카드 덱의 각 위치에 대해서 구간 합을 저장하는 Segment Tree를 만들어 줍니다. 위치는 52개이니 이러한 Segment Tree를 시간과 공간 제약 안에서 만들 수 있습니다. Segment Tree를 만든 후에는, 구간 합 쿼리를 51번 Segment Tree에 질의를 날리는 것으로 해결할 수 있습니다.&lt;/p&gt;&lt;p&gt;이제 구간에서 두 원소를 바꿔주는 쿼리를 생각해 봅시다. 이 쿼리에는 I번 트리와 J번 트리만이 관여되어 있으니, 이 두 트리에 대해서만 생각해 주면 됩니다. 우리가 원하는 것은 I번 트리의 특정한 구간이 J번 트리의 같은 구간과 교환되는 것입니다. 이 때, I번 트리와 J번 트리가 모양을 바꾸는 구간은 동일하다는 것을 생각해 봅시다. 만약 그것이 생성된 과정이 같다면, 해당 구간에 대응되는 $O(\log n)$ 개의 서브트리 역시 동일한 모양을 가질 것입니다. 고로, 우리는 단순히 이 서브트리들을 떼어서 서로 바꾸어 주면 됩니다. &lt;/p&gt;&lt;p&gt;교환해야 하는 서브트리는 일반적인 구간 쿼리의 요령으로 찾을 수 있습니다. 서브트리 하나를 교환하는 것이 어렵다고 생각할 수도 있으나, 어떠한 노드의 자식을 포인터의 형태로 가지고 있으면, 단순히 루트 노드를 교환하는 것만으로 서브트리 전체를 교환할 수 있으니 간단합니다.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3&gt;5. &lt;a href=&quot;https://www.acmicpc.net/problem/14001&quot;&gt;NEERC 2016 M. Mole Tunnels&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;DP에 기반해서 문제를 풀기에는 문제의 제약 조건이 너무 크고, 효율적인 DP를 고안하기에 상황이 적절하지 않습니다. 한편, 문제의 설정 상 두더지가 한 마리씩 들어올 때마다 올바른 답을 출력해야 합니다. 이러한 설정은 기존보다 문제를 어렵게 하지만, 새로운 두더지가 들어왔을 때, 기존 답을 토대로 어렵지 않게 해결하는 방법이 있음을 시사하기도 합니다. &lt;/p&gt;&lt;p&gt;이러한 방식으로 문제를 접근해 봅시다. $i-1$ 마리의 두더지가 이미 자리를 잡은 상황에서 $i$ 번째 두더지가 들어 왔을 때의 배정을 생각해 봅시다. 가장 가까운 빈 위치에 두더지를 배정하는 것이 먼저 머릿속에 와닿지만, 당연하게도 제대로 되지 않습니다. 나중에 그 위치가 더 효율적인 다른 두더지가 올 수 있기 때문입니다. 올바른 배정 방법을 찾으려면 기존 두더지들이 만들었던 선택을 변형시킬 필요가 있으며, 현재 두더지의 선택도 차후 적용될 변형에 따라서 유동적이어야 합니다. &lt;/p&gt;&lt;p&gt;$i-1$ 마리 두더지 각각에 대해서, 각자의 생활 공간에서 밥을 먹는 위치를 잇는 경로에 화살표를 그어봅시다. 만약에 $i-1$ 마리의 두더지가 최적의 방법으로 식사하고 있다면, 트리 상 각 간선 $u - v$ 에 대해서 $u \rightarrow v$ 방향으로 움직이는 두더지와 $v \rightarrow u$ 방향으로 움직이는 두더지가 같이 존재하지 않습니다. 이 경우 그러한 두더지 두개의 목적지를 바꿔서 더 좋은 답을 찾을 수 있기 때문입니다. &lt;/p&gt;&lt;p&gt;새로운 두더지가 들어왔고, 목적지를 임의의 정점 $v$ 로 두었다고 합시다. 경로를 순서대로 따라갔을 때, 반대 방향으로 향하는 두더지를 중간에 만날 수 있습니다. 이러한 경우, 그 두더지와 목적지를 바꿔주고, 현재 두더지를 그 두더지로 바꿔주면 1만큼 거리를 오히려 줄이는 꼴이 됩니다. 고로, 만약에 경로 상에서 두더지를 반대 방향으로 만났다면 가중치가 -1, 그렇지 않다면 가중치가 1이 됩니다. &lt;/p&gt;&lt;p&gt;이렇게 그래프에 “변형된 가중치” 를 주면, 단순히 가장 거리가 짧은 정점을 찾은 후, 그 곳에 두더지를 배정하면, 현재의 선택이 기존의 선택을 최적화할 수 있으며, 미래의 선택에도 바뀔 수 있는 여지가 생깁니다. 이 알고리즘은 실제로 정당하며, 그 증명에 대해서는 후술합니다. &lt;/p&gt;&lt;p&gt;변형된 가중치는, 각각의 간선에 대해서 현재 이 간선을 윗방향 / 아랫방향으로 지나는 두더지가 몇 마리인지를 관리하면 찾을 수 있습니다. 이제, 트리에서 주어진 점과 가장 가까운 점을 찾는 방법은 단순 DFS로 $O(N)$ 에 가능하고, 간선을 갱신해 주는 것은 $O(\log N)$ 에 가능합니다. 간선 갱신이 $O(\log N)$ 인 이유는 이진 트리라서 경로의 길이가 항상 $O(\log N)$ 이하이기 때문입니다. 현재 시간 복잡도는 $O(NM)$ 입니다. &lt;/p&gt;&lt;p&gt;여기에 DP를 조합하면 시간 복잡도를 줄일 수 있습니다. 각각의 노드에 대해서, DP[i] = (i번 노드의 서브트리 중 i번 노드와 가장 가까운 정점, 그리고 그 거리) 를 저장합시다. 두더지가 새로 들어오는 정점을 $u$라고 하고, 가장 가까운 정점을 $v$ 라고 합시다. $LCA(v, w) = k$ 인 정점들은, 정점 $k$와, $k$의 자식 중 $v$ 와 반대편에 있는 정점의 서브트리들일 겁니다. 첫번째는 단순하게 계산해 주고, 두번째는 DP값을 단순히 참고하면 됩니다. 이를 $v$를 타고 올라가면서 계산해 주면 가장 가까운 정점을 $O(\log N)$ 에 계산할 수 있습니다. 계산이 완료 되면 경로가 추가되고, 가중치가 갱신됩니다. 고로, DP값을 갱신해야 합니다. 이 때는, 변동이 있는 노드들이 $v, w$의 조상들이기 때문에, 이들에 대해서만 새로운 값을 bottom-up으로 구해주면 됩니다. 이 역시 $O(\log N)$ 입니다. 고로, 두더지 하나를 새로 넣는데 $O(\log N)$ 시간이 걸려 시간 복잡도가  $O(M \log N)$이 됩니다. 생각의 과정이 길지만, 코드는 짧은 편입니다. &lt;/p&gt;&lt;p&gt;알고리즘의 정당성 증명은 Minimum Cost Flow라는 개념을 사용합니다. 이보다 더 간단한 방법이 있을 것이라고도 생각이 들지만, 개념을 알고 있다면 가장 쉽고 일반화하기 좋은 증명 방법이 됩니다. 이 문제를 Minimum Cost Flow의 instance로 모델링하면, 사실 위 알고리즘은 Minimum Cost Flow를 트리에서 돌리는 과정을 약간 추상화한 형태에 불과합니다. &lt;/p&gt;&lt;p&gt;대다수의 Greedy 알고리즘은 제한된 형태의 문제만 풀 수 있는 경우가 많지만, Minimum Cost Flow와 같은 Network Flow류 알고리즘은 Greedy 패러다임에 기반해 있으면서도 아주 다양한 조합 최적화 문제를 해결할 수 있는 강력한 해결법입니다. 풀이를 이해하는 데 어려움이 있거나, 비슷한 유형의 풀이에 관심이 있다면 Network Flow / Minimum Cost Flow에 대해서 알아보는 것을 추천합니다. &lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3&gt;6. &lt;a href=&quot;https://www.acmicpc.net/problem/6293&quot;&gt;BOI 2013. Vim&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;먼저 문제의 최적해에 대한 성질을 고찰합시다. 문제에서 왼쪽으로 가는 연산은 모두 h 동작을 사용해야 하고, 오른쪽으로 가는 동작은 모두 f 동작을 사용해야 합니다. 물론 x 동작 역시 매우 중요하지만, 이 문제에서는 그냥 모든 e를 만나게 하고, 그 과정에서 보일 때마다 지워주면 되니 최적해와는 크게 상관이 없다 볼 수 있습니다. 이 때 사용할 수 있는 중요한 성질은 다음과 같습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Lemma 1&lt;/strong&gt;. 최적해에서는, h 동작을 사용해서 두 번 이상 지나치는 점이 없다. &lt;/p&gt;&lt;p&gt;이 때 &quot;h 동작을 사용해서 지나쳤다&quot; 라고 함은, h 동작을 썼던 점이거나, h 동작의 대상이 되었던 점이라는 뜻입니다. Lemma 1의 증명은 은 최단 경로가 단순 경로인 것과 비슷한 이유이고 어렵지 않습니다. 이 Lemma는 문제에서 가장 중요한 핵심 아이디어이고, 문제의 최종 풀이 역시 이와 같은 관찰에 비롯합니다.&lt;/p&gt;&lt;p&gt;하지만 여기서 바로 동적 계획법을 시도하는 것보다는 문제를 조금 더 단순화하는 것이 유리합니다. 위에서 힌트처럼 나왔던 사실은, x 동작이 실제로는 커서의 이동에 큰 영향을 주지 않는다는 것입니다. 여기서 조금 더 나아가, x 동작 자체의 존재 여부를 없애 버릴 수도 있습니다.&lt;/p&gt;&lt;p&gt;여기서 몇가지 아이디어를 생각해 봅시다. 우리는 문자열 상에서의 e의 존재를 명시적으로 없애줄 필요가 없습니다. 문자 자체를 없애기 보다는, 모든 e 문자를 커서가 무조건 거쳐야 한다고 마크해놓은 후, 해당 문자에 들어갔을 때 x 키를 누름으로써 (지우지 않았지만) 사실상 지웠다고 판단해 주어도 됩니다. 이러한 단순화를 한다고 답이 바뀌지는 않지만, 문자열 상 문자를 변형할 필요가 없어서 유리합니다.&lt;/p&gt;&lt;p&gt;더 나아가서, 문자열 자체에서 e의 존재 자체를 지워버릴 수 있습니다. 문자 e를 지우기 위해서는, 이의 오른쪽에 있는 문자를 거쳐야만 합니다. 이 논리를 더 발전시키면, 연속된 e 문자들을 지우기 위해서는 이 연속된 문자들의 오른쪽에 있는 하나의 문자를 무조건 방문해야 하고, 또한 방문하면 이 연속된 문자들을 쉽게 지울 수 있습니다. 그림으로 표현하면 대략 다음과 같습니다.&lt;/p&gt;&lt;p&gt;ccb&lt;em&gt;eeeee&lt;/em&gt;&lt;strong&gt;b&lt;/strong&gt;bb &amp;lt;- 원래 상황 (무조건 거쳐야 하는 문자를 마크)&lt;/p&gt;&lt;p&gt;ccb&lt;strong&gt;e&lt;/strong&gt;eeee&lt;strong&gt;b&lt;/strong&gt;bb &amp;lt;- b를 거쳐 연속 구간의 가장 왼쪽 e를 도달&lt;/p&gt;&lt;p&gt;ccb&lt;strong&gt;b&lt;/strong&gt;bb &amp;lt;- x를 연타&lt;/p&gt;&lt;p&gt;이제 문제에서 문자 e와 동작 x를 완전히 지우고, f / h 동작, 그리고 무조건 지나야 하는 문자의 리스트만 가지고 있어도 문제를 풀 수 있습니다. 다음과 같은 Lemma를 구성할 수 있기 때문입니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Lemma 2&lt;/strong&gt;. &lt;em&gt;변형된 문제의 답 + 2 * (원래 문자열의 e의 개수)&lt;/em&gt; 가 변형 전 문제의 답과 동일하다.  &lt;/p&gt;&lt;p&gt;이제 지금까지 만든 관찰을 통해서 동적 계획법을 시도합니다. 어떻게 동적 계획법 상태를 정의하느냐가 문제의 핵심으로, 상태를 정의하는 방법에 따라서 동적 계획법 자체가 불가능할 수도 있고, 느린 시간 복잡도가 나올 수도 있습니다. &lt;/p&gt;&lt;p&gt;가장 직관적인 방법은 커서의 위치를 따라가는 것이지만, 여기서 사용하는 방법은 커서의 위치와 관계없이 왼쪽부터 오른쪽으로 순서대로 커서의 경로를 만들어 나가는 것입니다. 점프가 되는 형태를 보면, 임의의 두 문자 사이는 h로 움직여지거나 움직여지지 않는데, 그렇지 않은 상태에서는 왼쪽 -&amp;gt; 오른쪽 점프 정확히 한번 만이 존재하고, 그런 상태에서는 h의 오른쪽으로 오는 점프, 그리고 h의 왼쪽에서 탈출하는 점프 두가지가 존재합니다. 동적 계획법의 상태는 고로:&lt;/p&gt;&lt;p&gt;$dp1(x, C)$ : 현재 x번 문자와 x+1번 문자 사이를 h로 건너지 않으며, fC라는 키워드로 건너뛰고 있는 상황&lt;/p&gt;&lt;p&gt;$dp2(x, COUT, CIN)$ : x번 문자와 x+1번 문자 사이를 h로 건너는 상태에서, 두 개의 점프가 가로지르고 있는데, 이 중 한쪽은 fCIN 키워드로 h의 오른쪽 구간 끝을 향해 도착하며, 다른 한쪽은 fCOUT 키워드로 h의 왼쪽 구간 끝에서 출발. &lt;/p&gt;&lt;p&gt;이들의 상태 전이는 구간이 끝나고 시작할 수 있는 몇가지 케이스들을 고려하면 찾을 수 있습니다. 케이스가 약간 많은 편이니 신중하게 구현해야 합니다. 각 상태 전이 개수는 $x$ 하나당 전체 $O(C^2)$ 로, 시간 복잡도는 $O(NC^2)$ 가 됩니다. $C = 10$ 이라 시간 안에 충분히 통과합니다. &lt;/p&gt;</description>
<category>공부</category>
<author>구사과</author>
<guid>https://koosaga.com/222</guid>
<comments>https://koosaga.com/222#entry222comment</comments>
<pubDate>Sat, 01 Dec 2018 00:50:38 +0900</pubDate>
</item>
<item>
<title>ACM-ICPC Jakarta Regional 2018</title>
<link>https://koosaga.com/221</link>
<description>&lt;p&gt;후기 안 쓰려고 했으나 그냥 간단히 써보려고 한다.&lt;/p&gt;
&lt;h3&gt;11월 9일 금요일&lt;/h3&gt;
&lt;p&gt;대전에서 CMP 팀과 함께 인천공항으로 출발했다. &lt;/p&gt;
&lt;p&gt;KTX 탈 때마다 홍보하는 광명역 도심공항터미널을 이용해 보았는데, 안내도 잘 안되어 있고 버스비도 비쌌다. 서울역에서 공항철도 타고 가는게 훨씬 더 싸고 편했을 거 같다.  &lt;/p&gt;
&lt;p&gt;인천공항 게이트 쪽에 일본 사람들이 있었는데 대회 후드인걸 보았을 때 누가 봐도 ICPC를 참가하는 사람들 같았다. 아마 2등한 교토대 팀이었을 것 같다. 하지만 대회 끝날 때까지 말할 기회는 없었다 :(&lt;/p&gt;
&lt;p&gt;숙소는 기숙사라서 기대하지 않았는데, 거의 호텔급이어서 놀랐다. 매우 좋았다. 근데 수건이 2개였다.  &lt;/p&gt;
&lt;h3&gt;11월 10일 토요일&lt;/h3&gt;
&lt;p&gt;단체 사진을 찍고 가이드와 만났다. 한국에 관심이 많은 분이어서 기본적인 한국어는 하실 줄 아셨으나, 의사소통은 조금 힘들어서 영어로 했다.&lt;/p&gt;
&lt;p&gt;Opening Ceremony를 아침에 해서 많이 졸렸다. 이것저것 많았는데 잘 기억이 나지 않는다. 스폰서 톡이 아주 솔직하더라는 것만 기억이 난다... 반응이 한국보다 훨씬 좋았다. Technical Review때 대회 시스템 관련 중요한 이야기들이 많이 나왔으나, 나랑 수찬이는 무슨 생각이었는지 전혀 듣지 않았다. 다행이도 나중에 알고 보니 민규가 다 들어줬다. 개이득&lt;/p&gt;
&lt;p&gt;Practice Session에는 2017년 리저널 문제 2개와 처음 본 문제 하나가 나왔다. 처음 본 문제의 내용은 다음과 같다.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;길이 $N$의 정수 수열이 주어졌을 때, 이 수열의 모든 원소의 최솟값도, 최댓값도, 합도 아닌 음이 아닌 정수를 아무거나 출력하라. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;민규가 그냥 &lt;code&gt;puts(&quot;13105&quot;)&lt;/code&gt; 를 냈고 맞았다. &lt;/p&gt;
&lt;p&gt;Practice Session은 2시간 정도였는데, 끝날 때까지 못 나가게 해서 안에서 매우 지루했다. 끝나고 숙소에서 낮잠을 잤다.&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99F5B9425C00D5A112&quot; filemime=&quot;image/jpeg&quot; filename=&quot;IMG_3610.jpg&quot; height=&quot;615&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;저녁은 가이드 분이 로컬 푸드로 한상 크게 차려주셨다. 기름종이에 싸여서 우아한 자태를 뽐내고 있는 저 음식들은 굉장히 향이 강하고 끈덕지다. 정확히 민규 취향일 듯. 실제로 싱가폴에 산 적이 있던 민규의 추억을 자극하는 소울 푸드였던 것 같다. 다만 아쉽게도 전체적으로는 호불호가 있었다. &lt;/p&gt;
&lt;p&gt;사실 로컬 푸드는 식중독의 위험이 있어서 조심히 먹어야 한다. 난 처음에 신경 안 쓰고 막 집어먹다가 갑자기 그 생각이 나서 그때부터 조심히 먹기 시작했다. 그럼에도 먹은 후 배가 썩 좋지는 않아서 다음날이 걱정됐다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3&gt;11월 11일 일요일&lt;/h3&gt;
&lt;p&gt;오전에 일어나서 대회장으로 갔다. 다들 속이 그렇게 좋지 않았는지 화장실부터 찾았다 (...) 다행이도 그 이후 화장실에 다시 간 사람은 없었다.&lt;/p&gt;
&lt;p&gt;초반은 순조롭게 말렸다. 문제 선택도 잘못됐고 코딩도 밀렸던 것 같다. 2문제에서 올라오지 못해서 20등 밖으로 떨어지고 화면에서 사라지기도 했다. &lt;/p&gt;
&lt;p&gt;45분에 3번째 문제인 L이 늦게 나오고, 이 즈음부터 대충 틀린 문제들이 정리가 되고 풀이들이 나오기 시작했다. 특히 C에 대해서 재밌는 이야기가 나왔는데, 몇 주 전에 종원이형이 휴가 나오면서 민규한테 알려준 &lt;a href=&quot;https://en.wikipedia.org/wiki/De_Bruijn_sequence&quot;&gt;De Bruijn Sequence&lt;/a&gt;를 그대로 구하면 된다는 것이었다. De Bruijn Sequence는 우리 팀원들이 거의 처음 들어본 개념이었고 (고로 다른 팀들에게도 낮설 가능성이 아주 컸고) 이해도 하지 않았으나, 우리 팀노트에는 그걸 구하는 코드가 그대로 있었다. 팀노트를 생각 없이 베끼면 AC가 나오는 엄청난 꿀문제가 있었던 것이다.&lt;/p&gt;
&lt;p&gt;UCPC 2018처럼 스코어보드에 혼란을 주기 위해서 논의가 끝난 즉시 C를 잡았다. 금방 맞았다. 그 사이에 내가 H에 있던 코딩 미스를 고쳐서 5문제로 올라왔다. 이 때부터 시동이 걸렸다. 그 후 K, J, D가 빠르게 완성되어서 8문제로 올라갔다. 이 때 1등을 탈환했다. &lt;/p&gt;
&lt;p&gt;이후 F와 G가 승산이 있어 보여서 이 둘을 잡았다. F는 아이디어가 빨리 나왔으나, 접근에 따라 구현이 헷갈릴 수 있는 문제였고, 그걸 간파하지 못하고 성급하게 코딩해서 (내가 아니라 민규가 ㅎㅎ) 많은 불필요한 WA를 받았다. 누구든간에 이런 일은 있어서는 안된다. G는 $O(n^3)$ 이 될 것 같은데 뭔가 복잡할 것 같았고, 시간 제한이 1초라서 빡빡하지 않을까 싶었다. 약간 복잡하지만 될 거라는 확고한 믿음을 가지고 내가 코딩을 시작했는데, 알고 보니 처음에 불필요한 절차를 고려하고 있었다. 이 절차를 빼니까 매우 간단한 알고리즘이어서 여유롭게 맞았다.&lt;/p&gt;
&lt;p&gt;이후 남은 문제가 B와 E였다. 둘 다 상당히 어려운 문제로 보여서 1등하기 위해 꼭 다 풀고 갈 필요는 없겠다고 생각했다. E의 경우에는 바로 보이는 풀이가 없었고, 그건 B도 마찬가지였다. 하지만 트리에 지루한 쿼리를 날리는 것만큼 재밌는 일이 없기 때문에 내가 B를 열심히 시도했다. 그러다 대략의 접근 방식이 나와서 내가 바로 구현을 시작했고, 팀원들이 남은 부분을 검토하기로 했다. &lt;/p&gt;
&lt;p&gt;열심히 구현하니 최종적으로 7.2KB정도 나왔다. 좀 돌아간 거 같기도 하지만 뭐 대회니까.. DM도 컴퓨터 빌 때 짜 놓았으나, 예제를 그냥 돌려보았더니 맞아서 냈고, 바로 AC! 진짜 짜릿한 순간이었다.&lt;/p&gt;
&lt;p&gt;남은 시간 동안 E를 어떻게 뚫을까 고민했으나 별 생각이 안 나서 그냥 나이브 알고리즘을 구현해 보기로 했다. 아무 의미 없어 보이지만 태국에서 이거 비슷한 방식으로 정말 올솔브를 띄운 적이 있어서 (...) 시도해 보았다. 애석하게도 TLE. ㅠㅠ&lt;/p&gt;
&lt;p&gt;그러고도 정말 시간이 남아서 E의 풀이를 고민했다. 확실히 B보다는 아이디어와 구현 모두 쉬운 문제였다. 남은 시간 34분이면 구현을 시도는 해 볼 수 있었을 것 같다. 이번에는 별 상관 없었으나, World Finals 레벨에서는 내가 B 하고 있을 때 풀이가 나와서 같이 구현하고 맞았어야 한다고 생각한다. &lt;/p&gt;
&lt;p&gt;대충 난이도를 정리하면:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;easy: I &amp;lt; A &amp;lt; L&lt;/li&gt;
&lt;li&gt;easy-med: H = D &amp;lt; J &amp;lt; F &amp;lt; K = G&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;med-hard: C&lt;/li&gt;
&lt;li&gt;hard: E &amp;lt; B&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99F2AB475C00D6562A&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2018-11-30 오후 3.18.32.png&quot; height=&quot;659&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;p&gt;최종 스코어보드는 다음과 같았다. K는 난이도에 비해서 상당히 푼 사람이 적었고, 반면에 G와 C는 그 난이도에 비해 푼 사람이 많았다. 알고 보니 C는 그러한 문자열의 존재성을 믿고 랜덤 + Euler tour로 푸는 풀이가 있었고, 그것이 의도된 풀이었던 것 같다. 우리의 알고리즘보다 구현량은 더 많을 것 같으나 생각하기는 조금 더 쉬웠던 것 같다. G는 $O(n^3\log n)$ 이 통과되었다는 후문을 들어보면 데이터가 약한 것으로 보인다. 그게 결과에 얼마나 영향을 줬는지는 모르겠으나..&lt;/p&gt;&lt;/div&gt;&lt;p&gt;대회가 모두 끝난 후에는 시상식이 있었다. 맨 처음 시작한 것은 퍼솔 시상식이었다. 퍼솔 시상식은 대회 때 퍼솔이 나온 10문제에 대해서만 진행했는데, 우리 팀이 그 중 4개를 먼저 풀어서 6개의 텀블러와 머그컵을 받았다  &lt;/p&gt;
&lt;p&gt;그 다음에는 대망의 본 대회 시상식이 시작되었다. 시상하고 스코어보드 까는 모 이상한 ICPC 리저널과는 다르게, 이 리저널은 바로 리졸버를 켰다. 리졸버는 World Finals의 것을 그대로 사용했고 행사도 거의 동일하게 진행했다. 환호가 여기저기서 터져나오는 분위기의 시끄러운 시상식이었다. 한국도 UCPC 시상식때는 아주 시끄러웠는데, ICPC는 그러기 힘들다 :(&lt;/p&gt;
&lt;p&gt;시상은 월드 파이널과 비슷하게 금메달 3팀, 은메달 4팀, 동메달 5팀을 수상하고, 인도네시아 탑 12팀에 대해서 따로 시상이 진행되는 식이었다. (인도네시아 내부 수상은 메달 팀은 제외하고 시상했던 것으로 기억한다.) 우리는 프리즈 당시 스코어보드를 보는 것만으로도 1등임을 확정할 수 있는 상황이어서 그냥 재미있게 앉아서 지켜보고 있었던 것 같으나, CMP는 다른 상위권 수상자들의 결과에 따라서 메달 색이 바뀔 수 있어서 그것보다는 흥미진진했을 것이다. &lt;/p&gt;
&lt;p&gt;최종적으로 CMP 팀은 4등 (은메달), 우리 팀은 1등 (리저널 챔피언) 으로 대회를 마무리했다. 상품으로는 보조 배터리, 헤드셋, 외장하드, 등등... 액수가 크지 않은 물건들을 여러 개 주는 방향이었다. 갖고 가기는 힘들겠지만 나름대로 왕이 된 기분을 느껴보라고 의도적으로 그렇게 진행하고 있다고 한다 :)&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이후 저녁 식사가 있었으나 일정이 늦어져서 바로 공항으로 달려가야 하는 상황이었다. 저녁 식사는 출장 뷔페가 와서 나름대로 성대하게 차려준 것 같으나 (이건 한국이 더 낫긴 했다.) 그렇게 많이 먹지는 못하고.. 가이드에게 도움을 요청해서 택시 2대를 잡고 출발하였다. 잡고 타는 데 이런저런 문제가 있었으나, 현지 가이드 분들이 정말 성심성의껏 뛰면서 도와주신 덕분에 무사히 탈 수 있었다. 정말 많이 고마웠다. 대회 동안 거의 항상 같이 다녔던 가이드와 작별 인사를 하고, 공항으로 떠나서 한국에 도착했다.&lt;/p&gt;
&lt;p&gt;한국에 도착하니까 현지 대회 organizer에게 우승을 축하한다는 코드포스 DM을 받았다. &lt;del&gt;모 PP 리저널은 organizer가 코드포스 DM으로 &quot;니네 코드에 이거 안넣어서 실수오차로 틀렸음 ㅋㅋ&quot; 라고 보냈다던데&lt;/del&gt; 친절한 메시지에 감동을 받아서 잘 답장해 주었다. 마지막 ICPC 리저널 대회를 즐겁게 보내서 좋고, 대회에 애착이 많은 사람들과 함께 할 수 있어서 기뻤다 :) &lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;문제 셋은 코드포스 Gym에 올라와 있다. 퀄리티는 무난한 편이고, 재밌는 문제들도 있다. 지금까지 진행된 PP 대회 (한국 / 대만 / 인도네시아 / 태국) 중에서는 문제가 제일 좋은 것 같다. &lt;a href=&quot;https://codeforces.com/blog/entry/63220&quot;&gt;링크&lt;/a&gt; &lt;br /&gt;&lt;/p&gt;
&lt;p&gt;대회 풀이 역시 상세하게 잘 적혀 있어서, 특별히 내가 풀이 Writeup을 할 필요가 없다고 생각했다.&lt;/p&gt;</description>
<category>생각</category>
<author>구사과</author>
<guid>https://koosaga.com/221</guid>
<comments>https://koosaga.com/221#entry221comment</comments>
<pubDate>Fri, 30 Nov 2018 15:23:50 +0900</pubDate>
</item>
</channel>
</rss>