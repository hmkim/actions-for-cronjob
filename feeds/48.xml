<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
<title>구사과</title>
<link>https://koosaga.com/</link>
<description></description>
<language>ko</language>
<pubDate>Tue, 14 May 2019 20:47:45 +0900</pubDate>
<generator>TISTORY</generator>
<managingEditor>구사과</managingEditor>
<item>
<title>Linear Programming Duality</title>
<link>https://koosaga.com/226</link>
<description>&lt;p&gt;
&lt;/p&gt;&lt;p&gt;관련 내용이 &lt;a href=&quot;https://m.blog.naver.com/kks227/220967218183&quot;&gt;이 블로그&lt;/a&gt;에도 매우 잘 나와 있으니 같이 보면 좋을듯. 이 글에서는 LP에 대한 정의를 안다는 것을 가정하기 때문에, 정의를 모른다면 링크한 블로그를 참고해야 한다.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;직관&lt;/h2&gt;
&lt;p&gt;다음과 같은 LP 문제를 생각해 보자.&lt;/p&gt;&lt;p&gt;$\text{Maximize: } 4x + 4y$&lt;/p&gt;&lt;p&gt;$\text{Subject to: } x + y \leq 3,x, y \geq 0 $&lt;/p&gt;&lt;p&gt;이 문제의 답은 굉장히 자명하다. $(x+y) \leq 3$ 이라는 조건이 있으니, $4(x+y) \leq 12$ 를 만족한다. 그 외에 다른 제약 조건은 $x, y \ge 0$ 뿐이니 답은 간단히 12로 결정된다. &lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;이를 조금 더 어려운 예시로 바꿔보자. &lt;/p&gt;&lt;p&gt;$\text{Maximize: } 4x + y $&lt;/p&gt;&lt;p&gt;$\text{Subject to: } x+y \leq 2, 2x+y \leq 3, x, y \geq 0$&lt;/p&gt;&lt;p&gt;위 예시와 다르게 이 문제의 답은 자명하지 않다. 위 문제의 답이 자명할 수 있었던 것은, 제약 조건 항이 유일했으며 그것이 최적화 함수의 형태와 일치했기 때문이다. 지금의 경우에는 제약 조건의 항이 유일하지도 않으며, 최적화 함수와도 독립적이다. &lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;LP Duality의 접근은, 이 식을 최대한 &quot;당연하게&quot; 만드는 것이다. 새로운 변수 $a, b$ 를 도입하자. 그러면, 다음과 같은 것이 성립한다. 이 때 $a, b \geq 0$ 임에 유의하자! 아니면 부등호가 바뀌어서 엉망이 된다. &lt;/p&gt;&lt;p&gt;$a(x + y) \leq 2a, b(2x+y) \leq 3b$&lt;/p&gt;&lt;p&gt;$(a + 2b)x + (a + b)y \leq 2a + 3b​$&lt;/p&gt;&lt;p&gt;직관적으로 생각했을 때, 이 수식을 &quot;끼워맞춰서&quot; $4x+y$ 로 만들기 위해서는 $a+2b = 4, a+b = 1$ 을 만족시켜야 한다. 하지만, 이를 모두 만족시키는 해는 존재하지 않는다. 즉, 이 경우에는 위와 같은 형태의 부등식을 즉각적으로 얻을 수는 없다. 하지만, $4x + 2y \leq 18, 5x + y \leq 18$ 와 같은 제약조건도 답의 상한을 찾기에는 충분히 도움이 되니, 위 제약 조건을 $a + 2b \ge 4, a + b \ge 1$ 로 바꾸자. &lt;/p&gt;&lt;p&gt;이 때 답의 상한을 최대한 낮춰서 많은 정보를 얻으려면, 우변의 항이 최소화되어야 한다. 그렇다면 이것 역시 LP 문제가 된다.&lt;/p&gt;&lt;p&gt;$\text{Minimize: } 2a + 3b $&lt;/p&gt;&lt;p&gt;$\text{Subject to: } a+2b\ge 4, a+b\ge 1, a, b \geq 0$&lt;/p&gt;&lt;p&gt;이 LP를 손으로 풀어보면 $a = 0, b = 2$ 임을 알 수 있다. 이 때 $2a + 3b = 6$ 이므로, 이제 우리는 원래 LP 문제의 답은 적어도 6보다는 작다는 것을 알 수 있다. 실제로 원래 LP를 풀어보면, $x = 1.5, y = 0$ 을 대입하여 답이 정확히 6인 해를 얻을 수 있고, 그것보다 더 큰 해를 얻을 수는 없다.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;우리가 지금까지 한 과정은 LP Duality 개념을 손으로 유도해낸 것이다. 원래 형태의 문제를 Primal 문제, 변형된 형태의 문제를 Dual 문제라고 부르자. 우리는 Primal 문제에서, 답에 대한 상한을 찾기 위해 계수를 맞춰주는 방식으로 Dual 문제를 직접 유도해 냈다. 그리고 이 과정에서 새로운 결론을 얻어냈는데, Primal 문제의 답은 Dual 문제보다 작거나 같다는 것이다. 이러한 결론을 &lt;strong&gt;Weak Duality&lt;/strong&gt; 라고 부른다. 보다시피, &lt;strong&gt;Weak Duality&lt;/strong&gt;는 자명한 과정만을 거쳐서 도입할 수 있기 때문에 정당성도 자명하다. 이보다 더 강한 명제인 &lt;strong&gt;Strong Duality&lt;/strong&gt; 는, 더 나아가서 Primal 문제의 답이 Dual 문제의 답과 같다는 명제이다. Strong Duality는 참이고, 그 증명은 자명하지 않다. &lt;a href=&quot;https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=2&amp;amp;ved=2ahUKEwiekbGm2pXfAhXGMt4KHdUZAToQFjABegQICRAC&amp;amp;url=https%3A%2F%2Fwww.cs.princeton.edu%2F~wayne%2Fkleinberg-tardos%2Fpdf%2FLinearProgrammingII-2x2.pdf&amp;amp;usg=AOvVaw2m8LCgdRJuN9cUGoDkjKt0&quot;&gt;관심이 있다면 이 링크를 참고.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;일반화와 결론&lt;/h2&gt;
&lt;p&gt;위의 예시는 특수한 경우에 불과하니, 이를 일반적인 경우로 바꾼다. 다음과 같은 LP 문제를 생각해 보자.&lt;/p&gt;&lt;p&gt;$\text{Maximize: } c^Tx$&lt;/p&gt;&lt;p&gt;$\text{Subject to: } Ax \leq b, x \geq 0$&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;$\sum_{1 \leq i \leq n}{(y_i \times A_{i, j} )\geq c_j}$앞서 말한 Dual Problem이라는 것은, $Ax \leq b$ 라는 식을 이루는 각 행 벡터에 대해 적당한 선형 결합을 찾아서. 그 값을 $c^Tx$ 보다 크게 하는 것이었다. 다시 한번 이거를 시도해 보자. $i$ 번째 행에 대해서 그 항에 붙일 계수를 $y_i$ 라고 하자. 그러면, 모든 열 $j$ 에 대해서 다음이 성립한다.&lt;/p&gt;&lt;p&gt;$\sum_{1 \leq i \leq n}{(y_i \times A_{i, j} )\geq c_j} \text{ for all }j \implies$
$A^T_{j} \times y \geq c_j \text{ for all }j \implies$
$A^Ty \geq c, y \geq 0$\&lt;/p&gt;&lt;p&gt;각 $y_i$ 에 대해서 계수로 붙었던 것은 $b_i$ 였다. 고로, 최소화해야 할 대상은 $b^Ty$ 이다. 이제 위 Primal 문제에 대응되는 Dual 문제를 다음과 같이 정의할 수 있다.&lt;/p&gt;&lt;p&gt;$\text{Minimize: } b^Ty$&lt;/p&gt;&lt;p&gt;$\text{Subject to: } A^T y \geq c, y \geq 0$&lt;/p&gt;&lt;p&gt;그리고, &lt;strong&gt;Strong Duality&lt;/strong&gt; 에 의해, Primal 문제의 최댓값과 Dual 문제의 최솟값은 동일하다.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;몇 번 문제를 풀어보다 보면 알겠으나, 사실 위 식과 아래 식은 아주 비슷하다. Max 문제를 풀다가 안 풀릴 때는, 풀고 있던 종이를 뒤집어 버리자. 행렬도 돌아가고, $b, c$ 벡터도 돌아가고. 이제 거기서 minimization을 그냥 그대로 풀면 Dual 문제가 되는 것이다. 또 하나의 결론은, Dual Problem을 똑같은 과정으로 변환하면 다시 Primal Problem이 된다는 것이다. 고로 Dual의 Dual은 Primal.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;알아두면 쓸데있는 잡지식&lt;/h2&gt;
&lt;p&gt;$x \geq 0$ 조건이 강제되는 게 걸릴 수 있는데, 저것이 문제라면 양수와 음수를 쪼개는 식의 테크닉을 사용하자. 정확히는, 변수 $x^{+}_i, x^{-}_i$ 를 만든다. $x_i = x^{+}_i - x^{-}_i$ 로 전부 대체해주고, $x^{+}_i, x^{-}_i \geq 0$ 을 적어주자. 그러면 저 조건이 없는 상황에서도 항상 이를 강제시킬 수 있다. &lt;/p&gt;&lt;p&gt;Convex Hull Trick의 모티베이션이 된 &lt;a href=&quot;https://en.wikipedia.org/wiki/Duality_(projective_geometry)&quot;&gt;point-line duality&lt;/a&gt; 랑은 다른 개념이다.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;연습 문제&lt;/h2&gt;
&lt;p&gt;꼭 Duality를 알아야만 풀 수 있는 문제는 많지 않지만, Duality를 사용하면 굉장히 깔끔하게 생각할 수 있는 문제들이 많다. &lt;/p&gt;&lt;p&gt;다음 세 문제는 Duality를 사용하면 바로 기하 문제로 환원할 수 있는 문제들이다. 안 쓰고 안 풀어봐서 모르겠는데, 내가 옛날에 335C 풀었을 때를 생각해 보면 그닥 쉽지 않았던 것 같다..&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://codeforces.com/contest/605/problem/C&quot;&gt;CF Div1 335C. Freelancers Dreams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/13096&quot;&gt;JAG Autumn 2014. Flowers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/16414&quot;&gt;ICPC Pacific NW 2018. Mobilization&lt;/a&gt;&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;다음 문제는 Primal, Dual 모두 효율적인 풀이가 있으나 Dual의 관점에서 생각하는 게 훨신 더 빠르게 풀 수 있는 문제이다. 이 문제에 대해서 &lt;a href=&quot;koosaga.com/224&quot;&gt;이 곳&lt;/a&gt;에 적었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://codeforces.com/blog/entry/63808&quot;&gt;Topcoder SRM 744. CoverTreePaths&lt;/a&gt;&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;다음 두 문제는 Duality를 사용하지 않으면 simplex algorithm이 필요해서 TLE가 나지만, Duality를 사용하면 Min-cost flow로 환원되어서 풀 수 있는 문제들이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1281&quot;&gt;BOJ 1281. 보석상&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/13091&quot;&gt;JAG Autumn 2015. Longest Shortest Path&lt;/a&gt;&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
<category>공부</category>
<author>구사과</author>
<guid>https://koosaga.com/226</guid>
<comments>https://koosaga.com/226#entry226comment</comments>
<pubDate>Mon, 21 Jan 2019 00:35:43 +0900</pubDate>
</item>
<item>
<title>2018.12.29 problem solving</title>
<link>https://koosaga.com/224</link>
<description>&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width initial-scale=1&quot;&gt;
&lt;title&gt;&lt;/title&gt;
&lt;h2&gt;Topcoder SRM 744&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Easy는 그대로는 매우 귀찮으나, 2차원 부분합을 구할 때 쓰는 포함 배제 테크닉을 활용하면 조금 덜 귀찮아진다. 물론 그래도 귀찮다. 난 문제를 잘못 읽어서 망했다.&lt;/li&gt;
&lt;li&gt;Medium은 행과 열에 대해서 해당 행 / 열을 뒤집었는가? 를 나타내는 $n+m$ 개의 boolean 변수를 잡으면, 주어진 조건은 $X_i + X_j$ 의 홀짝성에 대한 제약조건으로 바뀐다. 이를 일종의 이분 그래프라고 생각하고 풀어주면 된다... 라는 류의 문제를 한 두 번 본게 아니어서 그냥 아무 생각 없이 코드를 짰으나 문제에 함정이 있다는 것을 늦게 깨달았다. 고치니까 150점.&lt;/li&gt;
&lt;li&gt;Hard는 큰 트리에서 특정한 형태의 선형 계획법 (LP) 를 돌리는 문제이다. small-to-large 트릭을 활용한 그리디 접근법이 있지만 나는 이렇게 해결하지 않았다. LP Duality를 사용하면, Dual Problem이 간단한 Min-cost Max-flow임을 알 수 있다. MCMF라고 하면 복잡도가 매우 클 것 같으나, 그래프가 정말 단순하다. 싱크가 루트고, 소스는 각각의 정점이라서, 경로의 cost는 단순히 각 정점에 부여된 $c_i$ 가 되며 그 최단 경로도 유일하다. 또한, 모든 길이 루트로 가기 때문에 역변도 생기지 않는다! $c_i$ 순으로 정렬하고 유일한 augmenting path를 따라서 흘려주면 $O(n^2)$ 이다. 이렇게 단순한 구성에서는 augmenting 과정이 경로 최솟값 + 경로 덧셈 문제이기 때문에, heavy-light decomposition + segment tree + lazy propagation을 써서 최적화해 주면 된다. $O(n\log^2 n)$. &lt;br /&gt;&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;Hard가 fail되었는데 이유가 참 한심하다. 구글링을 열심히 해 보니 탑코더의 스택 메모리 제한이 8MB라고 한다. 8MB! 그걸로는 주어진 트리에서 DFS도 못 돌린다. 프리오더 구하려면 스택 써야 한다. 웃프다는 말 밖에 할 말이 없다. 탑코더를 할 때마다, 상식적으로 납득 불가능한 기준선에서 내 레이팅이 좌우된다는 느낌을 받을 때가 너무 많다. &lt;del&gt;물론 탑코더보다 스택 메모리 제한이 훨씬 더 답 없는 모 대회도 있다. 그 대회는 심지어 선인장을 내던데... 하지만 그 대회를 비판하는 것은 용납할 수 없다.&lt;/del&gt; 그렇게 5등~7등을 해야 했을 대회를 23등 했으나, 그래도 레이팅이 올랐던 거 같다. ㅋㅋ&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;Atcoder Grand Contest 029&lt;/h2&gt;
&lt;p&gt;거의 1년만에 했는데 잘 했다. 다 풀어서 기분이 좋았다. B E F는 정말 아름다운 문제들이다. A D는 조금 실망스러웠다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A는 사골이다. 어느 정도 사전 지식 문제라고도 생각한다. 왜 안 걸렀는지 모르겠다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;B는 난이도가 쉬우나 매우 좋은 문제였다. 작은 숫자부터 보면 매칭해야 할 큰 숫자의 가능성이 여럿 있기 때문에 혼란스럽다. 하지만 큰 숫자의 관점에서 보면 매칭해야 할 작은 숫자는 유일하다! $A_i + A_j = 2^K$ 일 때, $i &amp;lt; j$ 라고 하면 $2^{K-1} \le A_j &amp;lt; 2^K$  가 성립한다. $A_j$ 에 대해서 $K$ 가 정해지고 $A_i$ 도 정해진다는 것이다. 이 시점에서부터는 $j$ 를 감소순으로 돌고, 매칭할 수 있으면 무조건 매칭을 시켜 주는 그리디 알고리즘이 가능하다. 그리디 알고리즘은 왜 가능할까? Forest에서 최대 매칭을 찾는 것은 임의의 매칭되지 않은 리프를 잡고 그리디하게 지워 나가는 것을 반복하면 된다. $j$ 에 대해 매칭되는 유일한 $i$ 를 부모라고 생각해 보자. 지금 우리가 하는 것이 정확히 그것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;C는 어려운 문제였다. 조건을 만족하는 임의의 문자열 집합을 생각해 보자. 이 문자열 집합을 Trie에 넣었다고 생각해 보면, 일단은 Trie를 순회했을 때 각 문자열이 순서대로 나올 것이고, 해당 Trie가 필요로 하는 최소 문자 개수는 모든 노드의 자식 개수의 max와 동일하다. 이 관찰을 가지고 답에 대해서 이분탐색 하자. 과정은 그리디하게 Trie를 만드는 과정이라고 해석될 수 있는데, 이는 스택에 해당 노드의 깊이, 자식 개수를 저장하는 식으로 가능하다. 난 이 부분을 깔끔하게 생각하고 구현하는 것이 매우 어려웠고, 결국 푸는 데 상당한 시간을 소모했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;D는 난이도가 B보다 훨씬 쉬우나 (A가 사전 지식임을 감안하면 그것보다도 쉬우나) 그 자리에 있었다. 난이도의 적절성을 떠나서 그냥 문제 자체가 안 좋다. 출제 과정에서 걸러지지 않은 게 이상한 문제. &lt;a href=&quot;https://codeforces.com/blog/entry/63812#comment-476671&quot;&gt;내 생각&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;E는 AGC 레벨의 문제였고 재미있었다. 나는 주최 풀이랑 조금 다른 복잡한 풀이였다. 어떠한 정점에서 루트로 올라간다는 것은, 한번 서브트리를 돌다가 부모를 찍고, 부모 쪽에서 또 돌다가 그 부모를 또 찍는 형태의 경로이다. 여기서 좋은 필요충분을 만들 수 있다. 임의의 정점 $v$ 에 대해서, $v$ 가 돌아다니는 와중에 정점 $w$ 를 만난다는 것은, $(LCA(v, w), w]$ 경로의 최댓값이 $[1, LCA(v, w))$ 간의 경로 최댓값보다 작다는 뜻이다. (포함 관계를 표현하기 위해 개구간 / 폐구간같은 기호를 썼음에 유의). $v$ 랑 상관 없이 LCA에 대해서 모든 것이 결정되기 때문에 저 값을 전처리하면 대략 부모 - 자식 경로 합 문제로 환원할 수 있다. &lt;/p&gt;&lt;p&gt;구해야 하는 것은 각 에지 $(par(w), w)$ 에 대해서 $[1, w)$ 최댓값보다 작은 최댓값을 가지는 정점의 개수이다. Small-to-large의 요령으로 $w$ 에서의 최댓값을 priority queue에 관리할 수 있다. priority_queue 에서 구간 쿼리를 할 수는 없지만, 어떠한 정점이 빠지고 추가되었는지의 수열을 알 수 있다. 이 수열의 길이는 $O(n \log n)$ 이다. DFS로 이 수열을 다시 한번 시뮬레이션 해 보는데, 이제는 priority queue 대신 Fenwick tree를 사용한다. Fenwick tree니까 구간 쿼리를 할 수 있고, 이제 각각의 에지에 대해서 원하는 값을 구해 놓았으니 문제를 푸는 것은 어렵지 않다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;F의 직관은, $K$ 개의 집합을 합집합했을 때 정수가 $K$ 개 이하이면 절대 트리를 절대 만들 수 없다는 것이다 (당연히, 간선이 많아야 $K-1$ 개 생기니까). 임의의 $K$ 개의 집합을 합집합했을 때 정수가 $K+1$ 개 이상이면 항상 트리를 만들 수 있을까? 여기서 홀의 결혼 정리와 analogy를 만들 수 있다. 홀의 결혼 정리는 임의의 $K$ 개의 집합을 합집합했을 때 매칭 가능한 쌍이 $K$ 개 이상이면 항상 답이 존재한다는 내용이다. &lt;/p&gt;&lt;p&gt;홀의 결혼 정리는 constructive한 증명을 가지고 있다. 그렇다면 우리의 추측도 constructive한 증명을 시도하면 도움이 될 것이다. 아무 정점을 루트로 잡고 시작하자. 이 정점을 모든 집합에서 빼도, 임의의 $K$ 개의 집합을 합집합하면 크기가 $K$ 개 이상이다. 고로 홀의 결혼 정리에 의해 각각의 집합에서 루트가 아닌 서로 다른 정점을 고를 수 있다 (직접 구하는 것은 Hopcroft-Karp 이분 매칭을 사용. 이분 매칭이 없으면 자명히 답이 없다.) &lt;/p&gt;&lt;p&gt;위에서 구한 매칭을 토대로 트리를 만드는 것은 아주 간단하다. 루트에서 시작해서, 루트를 포함하는 모든 집합을 돌자. 해당 집합에 매칭된 정점과, 루트를 잇는 간선을 만들어주자. 이렇게 루트에서 모든 가능한 정점들을 이었다면, 이 정점들에 대해서도 자식을 이어줄 필요가 있다. 그래프 탐색을 하듯이, 이들을 큐에 넣어서 BFS를 하고, 그 정점들에 대해서도 똑같은 작업을 시행한다 (물론, 이미 연결된 정점을 다시 이으면 안되는 것은 당연하다.)&lt;/p&gt;&lt;p&gt;이제 알고리즘의 정당성을 증명하기 위해서는 저 과정이 모든 답이 존재하는 트리에 대해서 절대 &quot;실패하지&quot; 않음을 보이는 것으로 충분하다. 저 과정이 실패한다는 것은, 모든 과정이 끝난 이후 루트에서 연결된 정점이 $N$ 개 미만임을 뜻한다. 그 컴포넌트의 크기를 $K$ 라고 하자. 연결된 $K-1$ 개의 정점은 그에 매칭된 $K-1$ 개의 집합을 가지고 있다. 나머지 $N-K$ 개의 집합은 지금 잡은 컴포넌트의 정점을 전혀 포함하고 있지 않다. 만약에 그렇다고 하면, 즉 그러한 집합 중 하나가 컴포넌트 상의 임의의 정점을 포함한다면, 그 집합은 발견되었을 것이고, 그 집합에 매칭된 정점이 추가되었을 것이기 때문에 가정에 모순이다. 즉, 나머지 $N-K$ 개의 집합의 합집합 크기는 $N-K$ 이하이다. 그렇다면 이 트리에서는 답을 구하는 것이 불가능하다.&lt;/p&gt;&lt;p&gt;여담으로, 4번째 문단은 지금 글을 쓰면서 증명하는 것이고, 대회 때는 주어진 시간도 없었고 완전히 증명하기엔 시간이 아깝다고 생각해서 그냥 짰고 맞았다.&lt;/p&gt;
&lt;/li&gt;

&lt;/ul&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;Educational CF #56&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A. $n/2$.&lt;/li&gt;
&lt;li&gt;B. 정렬.&lt;/li&gt;
&lt;li&gt;C. $a_i$ 를 가능한 최소로 유지.&lt;/li&gt;
&lt;li&gt;D. bipartite coloring.&lt;/li&gt;
&lt;li&gt;F는 복잡한 DP 포함 배제였다. 난 매우 복잡했는데 어떻게 그렇게 빨리 풀었는지 잘 모르겠다.. 하다가 힘 빠져서 포기할 뻔 했다.&lt;/li&gt;
&lt;li&gt;G는 abs(x) = max(x, -x) 임을 관찰하면 간단한 구간 최댓값 연습 문제이다. 무슨 약을 먹었기에 E 뒤에 넣었을까..&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;E번은 귀찮은 과정을 통해서 2D 평면에 점 추가 + 제거 + 개수 세기 문제로 환원될 수 있다. 그렇게 좋은 문제는 아니라고 생각하지만, gritukan의 코드를 보다가 매우 간단한 방법을 찾아서 이를 소개하려고 한다. &lt;/p&gt;&lt;p&gt;일단 위 문제는 2차원 Segment Tree를 만들면 이론적으로는 쉽게 풀 수 있다는 것에 주목하자. 2차원 Segment Tree에서 점 추가는 $O(\log N)$ 개의 1차원 Segment Tree 노드 갱신, 구간 쿼리는 $O(\log N)$ 개의 1차원 Segment Tree 노드 쿼리로 환원된다. &lt;/p&gt;&lt;p&gt;이 때, 이 문제가 Offline이니까, 이 과정들을 한번씩 해 주면서 각 쿼리에서 갱신되는 Segment Tree가 무엇이고 구간 합을 구하는 Segment Tree가 무엇인지 알 수 있다. 진짜 갱신을 하고 구간 합을 구하는 게 아니다. 각 노드마다 Segment Tree를 실제로 만들지도 않는다. 그냥 그러는 시늉만 하고, 실제로는 각 노드에 갱신 / 쿼리 sequence만 저장하는 것이다. 이제 모든 문제는 노드에 대해서 독립적이다. 그리고 각 노드에 저장된 것은 1차원 점 갱신, 구간 합 문제이다. 그건 쉬운 문제니까, 각 노드를 돌면서 Fenwick Tree로 그 문제를 &quot;진짜로&quot; 풀어주면 된다. &lt;/p&gt;&lt;p&gt;그동안은 각 노드에 대해 &quot;압축된 BIT&quot; 를 하는 방법만 알았는데, 이 새로운 방법은 다양한 문제에 대해 일반화되고 구현도 매우 간단하며 효율적이다. 오프라인 2차원 쿼리를 하는 이상적인 방법인 것 같다. &lt;/p&gt;&lt;p&gt;여담으로 이러한 오프라인 2차원 쿼리에 대해 나중에 시간이 나면 (...) 튜토리얼을 써 볼 생각이다. 라인 스위핑이 안 되는 상황에서는 위 방법과 분할 정복이 2차원 쿼리를 하는 이상적인 방법으로 보인다. &lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2&gt;COCI 2018/2019 Round 3&lt;/h2&gt;
&lt;p&gt;3번하고 5번 말고는 문제가 별로 재미가 없다. 나는 Educational과 겹쳐서 시간이 별로 없었다. 3번은 상당히 어려운 문제인 것 같은데 굉장히 앞에 있다. bmerry도 이상하게 풀었던데 공식 풀이의 상태가 약간 의심된다.. 고민해 봐야 할 듯.&lt;/p&gt;&lt;p&gt;5번 문제는 괜찮은 튜토리얼 문제인 것 같다. 옛날에 코드포스에 비슷한게 나왔었고 &lt;a href=&quot;http://koosaga.com/131&quot;&gt;그때도 writeup을 했으나&lt;/a&gt; 제대로 안 쓰여 있으니 그냥 다시 쓰도록 하자 (...)&lt;/p&gt;&lt;p&gt;주어진 그래프에 대해서 스패닝 트리를 하나 잡고, 이 스패닝 트리에 있는 간선은 가중치를 바꾸지 않을 것이라 약속하자. 이렇게 하면 스패닝 트리에 없는 나머지 간선들은 연산의 대상이 되고, 이 간선에 &quot;실제로 배정되어야 할 가중치 값&quot; 역시 알 수 있다. 이 가중치 값만 맞추면 문제의 제약 조건이 지켜진다. &lt;/p&gt;&lt;p&gt;각각의 간선에 대해서 독립적인 문제가 되니, 이제는 그래프를 잊고, 다음과 같이 생각할 수 있다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$M-N+1$ 개의 수가 주어진다. subset에 특정한 수를 xor하는 연산을 최소로 실행해서 전체 수를 0으로 만들자.&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;최소가 아니라 적당히 작은 횟수의 연산이라고 하자. 그러면 단순히 1, 2, 4, 8과 같은 $2^k$ 형태의 수를 모두 해보면, 각각의 비트를 하나 하나 끌 수 있다. 많아야 60번의 연산으로 모든 수를 지울 수 있는 것이다. 하지만 이것이 최소는 아니다. &lt;/p&gt;&lt;p&gt;여기부터는 뭐 길게 얘기할 수도 있긴 하나... 그냥 짧게 하자면, 모든 수를 binary vector로 보고, basis를 구해주면 된다. basis 집합은 선형 독립이기 때문에, 개념적으로 $1, 2, 4, 8$ 과 같은 수랑 다를 바가 없다. basis를 크기 감소 순으로 봐주고, basis의 가장 큰 비트가 켜져 있는 숫자들에 모두 연산을 한꺼번에 실행하자. 그러면 각 연산마다 가장 큰 비트를 항상 날려줄 수 있다. 그리고 이 과정이 실패하는 경우는 없다. basis 크기 만큼의 연산으로 문제를 해결할 수 있고, 이보다 더 적은 횟수로 할 수 없음은 그 개념을 안다면 자명할 것이다.&lt;/p&gt;&lt;p&gt;이 전략을 알면, 스패닝 트리를 뭘 잡는 지는 아무 상관이 없다는 것 역시 알 수 있다. 어떤 스패닝 트리를 잡아도, 사이클에 적혀있는 수들은 이 basis의 선형 결합으로 표현되기 때문이다. 고로 스패닝 트리를 아무거나 잡아도 알고리즘이 정당하다. &lt;/p&gt;&lt;p&gt;지금까지 다룬 내용은 기초적인 선형 대수학으로 커버되고, 이 정도 수학은 PS를 포함해 컴퓨터 과학 전반에 매우 유용하게 쓰이기 때문에 상위권을 노린다면 알아두는 것이 좋다. 관련 연습 문제로는 &lt;a href=&quot;http://koosaga.com/132&quot;&gt;XOR Maximization&lt;/a&gt; 이 있다. 최근 고려대 대회에서도 이 XOR Maximization을 약간 응용한 &lt;a href=&quot;https://www.acmicpc.net/problem/16685&quot;&gt;XOR 포커&lt;/a&gt;라는 문제가 나왔다. 이 문제는 여러가지 풀이가 있는데, 내 풀이와 공식 풀이에서 쓰인 아이디어는 간단하지만 상당히 신선했고, 재미있었다.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;Atcoder Study&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&quot;https://atcoder.jp/contests/arc102/tasks/arc102_d&quot;&gt;ARC 102 F. Revenge of BBuBBBlesort!&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;가장 핵심적인 관찰은, 스왑의 대상이 되는 숫자들이 서로 인접할 수 없다는 것이다. 이는 $p_{i-1} &amp;gt; p_i &amp;gt; p_{i+1}$ 조건 때문인데, 엄밀하게는 나도 잘 모르겠고, 대충 해 보면 말이 안되는 것 같다는 것을 알 수 있다 (....) 이 관찰을 하면 문제가 굉장히 접근 가능해진다. 모든 스왑의 대상이 되는 숫자들이 2 / 3 이상 떨어져 있는데, 3 이상 떨어져 있으면 그냥 독립적인 이야기니까 (나랑 섞일 수 있는 수가 아니니까) 2만큼 떨어져 있는 chain들의 집합이 된다.&lt;/p&gt;&lt;p&gt;어떠한 수 $i$ 를 대상으로 해서 스왑을 진행한다는 것은 $swap(p_{i-1}, p_{i+1})$ 을 한다는 것과 똑같은 말이다. 그러면 $i, i+2, i+4, \cdots, i + 2k$ 를 대상으로 스왑한다는 것은, $i, i+2, \cdots, i+2k$ 는 전혀 안 건드리고, $i-1, i+1, i+3, \cdots, i+2k+1$ 만 건드린다는 뜻이다. (이들은 그 값이 &lt;strong&gt;무조건&lt;/strong&gt; 바뀐다. 아니면 3개가 증가하기 때문에 그들 양 옆이 안 통한다..) 이렇게 되면 대충 수열을 partition할 수 있다. 현재 제자리에 없는 수들을 전부 모으고, 이 중에 인접한 것이 없는 지 확인하고 (있으면 무조건 -1), 없으면 이제 거리가 2인 애들끼리 묶어준 후 각각에 대해서 문제를 해결하는 것이다. 이렇게 문제가 많이 단순화된다. &lt;/p&gt;&lt;p&gt;이들에 대해서 인접한 숫자를 교환할 수 있으니까 대충 생각하면 버블 소트처럼 항상 정렬이 될 것 같으나, 사실은 그렇지 않다. 왜냐면 두 수를 교환하기 위해서 $p_{i-1} &amp;gt; p_i &amp;gt; p_{i+1}$ 이라는 조건이 있어서, 두 수 사이에 있는 수의 크기가 교환에 영향을 미친다. 이를 조금 더 살펴보자. 일단 구간 $[i-1, i+2k+1]$ 을 정렬했을 때 모든 숫자가 제자리에 있는지를 확인하자 (당연히 확인해야 한다). 그렇지 않다면 결국 $p_i = i, p_{i+2} = i+2 \ldots$ 를 만족할 것이고, 나머지 숫자들은 모두 제자리에 없을 것이다. 최솟값부터 옮겨 보자. 최솟값을 가장 왼쪽으로 옮기기 위해서는, 그 사이에 있는 수들이 모두 바로 오른쪽에 있는 수보다 커야한다. 두번째 최솟값 역시 그를 만족해야 한다. 이를 위해서는, 두번째 최솟값이 첫번째 최솟값보다 무조건 오른쪽에 있어야 한다.. 이런 식으로 논리를 펼쳐 나가면 대략 결론이 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;최종 위치가 왼쪽으로 가는 애들끼리 ($p_i &amp;lt; i$) 놓고 보았을 때 이들은 증가해야 한다.&lt;/li&gt;
&lt;li&gt;최종 위치가 오른쪽으로 가는 애들끼리 ($p_i &amp;gt; i$) 놓고 보았을 때 이들은 증가해야 한다.&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;저걸 만족하면 항상 정렬이 가능하다. 증명을 제대로 안 했으나 둘을 따로 본다면 어렵지 않을 것으로 보인다. 아무튼 시간 복잡도는 $O(n\log n)​$ 혹은 그 이하.&lt;/p&gt;</description>
<category>공부</category>
<author>구사과</author>
<guid>https://koosaga.com/224</guid>
<comments>https://koosaga.com/224#entry224comment</comments>
<pubDate>Sat, 29 Dec 2018 19:14:11 +0900</pubDate>
</item>
<item>
<title>2018.12.01 problem solving</title>
<link>https://koosaga.com/222</link>
<description>&lt;p&gt;난이도 순입니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3&gt;1. &lt;a href=&quot;https://abc051.contest.atcoder.jp/tasks/abc051_b&quot;&gt;ARC 051. Sum of Three Integer&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;$A, B$ 를 정하면, $C = S - A - B$ 로 자동으로 정해집니다. 고로 모든 $A, B$ 를 이중 루프로 순회하고, $0 \leq C \leq K$ 를 확인하면 됩니다. $A, B$의 가짓수가 각각 $K+1$개이니 시간 복잡도는 $O(K^2)$입니다. &lt;/p&gt;&lt;p&gt;포함배제 원리를 사용한 $O(1)$ 풀이도 있지만, 이 문제에서는 필요 없습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;
&lt;h3&gt;2. &lt;a href=&quot;https://www.acmicpc.net/problem/8094&quot;&gt;POI 1997. Canoes&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;먼저 각각의 사람을 몸무게 순으로 정렬해 놓읍시다. 가장 가벼운 사람은 다른 사람과 보트를 태워 보내는 것이 합리적으로 보이니, 가장 가벼운 사람을 보낼 때는, 다른 사람 한 명을 잡아서 같이 보트를 태워 보냅니다. 같이 탈 수 있는 사람이 여럿이면 물론 몸무게가 무거운 사람을 보내는 것이 현명합니다. 두 번째, 세 번째로 가벼운 사람들에게 이를 반복하고, 같이 태워 보낼 수 있는 사람이 없을 때까지 이를 반복합니다. &lt;/p&gt;&lt;p&gt;이 알고리즘의 구현은, 정렬된 배열에서 현재 보낼 무거운 사람의 “포인터” 를 가지고 있으면 간편합니다. 가벼운 사람이 있을 때, 이 사람의 몸무게를 맞출 수 있을 때까지 포인터를 앞으로 (몸무게가 감소되는 쪽으로) 내려주고, 그 사람과 매칭시킨 후, 포인터를 다시 내려줍니다. 시간 복잡도는 $O(n\log n)$ 정도입니다. 입력 크기가 작아 정렬을 할 때 카운팅 정렬을 써도 됩니다.&lt;/p&gt;&lt;p&gt;이 그리디 알고리즘의 정당성은 다음 Lemma에 의해 보여집니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Lemma&lt;/strong&gt;. 2인 보트를 T번 보낼 때, 가장 가벼운 T명이 서로 다른 2인 보트에 타는 해가 항상 존재한다.  &lt;/p&gt;&lt;p&gt;증명은 귀류법으로 가능합니다. 문제의 난이도에 비해서 증명이 그렇게 쉽지 않습니다. 여기서는 생략합니다. &lt;/p&gt;&lt;p&gt;다른 방법으로는, 답 $T$에 대해서 이진탐색한 후, $a_i + a_{2T-1-i}$가 모든 $0\leq i &amp;lt; T$에 대해서 성립하는 지 보는 것입니다. 역시 시간 복잡도는 $O(n\log n)$이며, 정당성은 위 Lemma에 의해 자명합니다.&lt;/p&gt;&lt;p&gt; &lt;br /&gt;&lt;/p&gt;
&lt;h3&gt;3.  &lt;a href=&quot;https://www.acmicpc.net/problem/16043&quot;&gt;NAIPC 2018. Missing Gnomes&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;결과 수열의 숫자를 왼쪽부터 순서대로 채워 나갑시다. 선택지는 두 가지입니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;현재 부분 수열의 맨 앞에 있는 원소를 골라서 넣기. 이 수를 넣으면 부분 수열의 맨 앞 원소는 사라지고 뒤에 있는 원소가 하나씩 앞으로 밀릴 것입니다 (Queue와 비슷). &lt;/li&gt;
&lt;li&gt;부분 수열에 올라오지 않았던 원소 중 하나를 골라 넣기. 원소를 고를 때는 당연히 가장 작은 원소를 고르는 것이 좋습니다.&lt;/li&gt;

&lt;/ol&gt;
&lt;p&gt;  이 두 가지 경우 중 가장 작은 숫자가 나오는 경우를 그때 그때 Greedy하게 고르면 됩니다. 사전순 비교는 앞에서부터 차례대로 보면서 처음으로 숫자가 다를 때 비교를 멈추기 때문에, 여러 경우가 있다면 맨 앞에 있는 원소를 최소화하는 게 가장 중요합니다. 고로 이러한 Greedy 전략은 올바릅니다. &lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3&gt;4. &lt;a href=&quot;https://codeforces.com/gym/101081/problem/A&quot;&gt;2011 USP Tryouts. Card Show&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;이 문제는 제한이 (아주 작지는 않지만) 작은 편이기 때문에 다양한 풀이가 존재할 수 있습니다. 여기서는 가장 깔끔하고 또한 효율적인 $O(52n + q\log n)$ 풀이를 소개합니다. 더 느리지만 생각하기 쉬운 풀이가 있을 수도 있습니다.&lt;/p&gt;&lt;p&gt;일반적인 구간 갱신 / 구간 합 문제에서 가장 자주 사용되는 구조인 Segment Tree를 사용해 봅시다 (자료 구조에 대한 설명은 생략합니다). 카드 덱의 각 위치에 대해서 구간 합을 저장하는 Segment Tree를 만들어 줍니다. 위치는 52개이니 이러한 Segment Tree를 시간과 공간 제약 안에서 만들 수 있습니다. Segment Tree를 만든 후에는, 구간 합 쿼리를 51번 Segment Tree에 질의를 날리는 것으로 해결할 수 있습니다.&lt;/p&gt;&lt;p&gt;이제 구간에서 두 원소를 바꿔주는 쿼리를 생각해 봅시다. 이 쿼리에는 I번 트리와 J번 트리만이 관여되어 있으니, 이 두 트리에 대해서만 생각해 주면 됩니다. 우리가 원하는 것은 I번 트리의 특정한 구간이 J번 트리의 같은 구간과 교환되는 것입니다. 이 때, I번 트리와 J번 트리가 모양을 바꾸는 구간은 동일하다는 것을 생각해 봅시다. 만약 그것이 생성된 과정이 같다면, 해당 구간에 대응되는 $O(\log n)$ 개의 서브트리 역시 동일한 모양을 가질 것입니다. 고로, 우리는 단순히 이 서브트리들을 떼어서 서로 바꾸어 주면 됩니다. &lt;/p&gt;&lt;p&gt;교환해야 하는 서브트리는 일반적인 구간 쿼리의 요령으로 찾을 수 있습니다. 서브트리 하나를 교환하는 것이 어렵다고 생각할 수도 있으나, 어떠한 노드의 자식을 포인터의 형태로 가지고 있으면, 단순히 루트 노드를 교환하는 것만으로 서브트리 전체를 교환할 수 있으니 간단합니다.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3&gt;5. &lt;a href=&quot;https://www.acmicpc.net/problem/14001&quot;&gt;NEERC 2016 M. Mole Tunnels&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;DP에 기반해서 문제를 풀기에는 문제의 제약 조건이 너무 크고, 효율적인 DP를 고안하기에 상황이 적절하지 않습니다. 한편, 문제의 설정 상 두더지가 한 마리씩 들어올 때마다 올바른 답을 출력해야 합니다. 이러한 설정은 기존보다 문제를 어렵게 하지만, 새로운 두더지가 들어왔을 때, 기존 답을 토대로 어렵지 않게 해결하는 방법이 있음을 시사하기도 합니다. &lt;/p&gt;&lt;p&gt;이러한 방식으로 문제를 접근해 봅시다. $i-1$ 마리의 두더지가 이미 자리를 잡은 상황에서 $i$ 번째 두더지가 들어 왔을 때의 배정을 생각해 봅시다. 가장 가까운 빈 위치에 두더지를 배정하는 것이 먼저 머릿속에 와닿지만, 당연하게도 제대로 되지 않습니다. 나중에 그 위치가 더 효율적인 다른 두더지가 올 수 있기 때문입니다. 올바른 배정 방법을 찾으려면 기존 두더지들이 만들었던 선택을 변형시킬 필요가 있으며, 현재 두더지의 선택도 차후 적용될 변형에 따라서 유동적이어야 합니다. &lt;/p&gt;&lt;p&gt;$i-1$ 마리 두더지 각각에 대해서, 각자의 생활 공간에서 밥을 먹는 위치를 잇는 경로에 화살표를 그어봅시다. 만약에 $i-1$ 마리의 두더지가 최적의 방법으로 식사하고 있다면, 트리 상 각 간선 $u - v$ 에 대해서 $u \rightarrow v$ 방향으로 움직이는 두더지와 $v \rightarrow u$ 방향으로 움직이는 두더지가 같이 존재하지 않습니다. 이 경우 그러한 두더지 두개의 목적지를 바꿔서 더 좋은 답을 찾을 수 있기 때문입니다. &lt;/p&gt;&lt;p&gt;새로운 두더지가 들어왔고, 목적지를 임의의 정점 $v$ 로 두었다고 합시다. 경로를 순서대로 따라갔을 때, 반대 방향으로 향하는 두더지를 중간에 만날 수 있습니다. 이러한 경우, 그 두더지와 목적지를 바꿔주고, 현재 두더지를 그 두더지로 바꿔주면 1만큼 거리를 오히려 줄이는 꼴이 됩니다. 고로, 만약에 경로 상에서 두더지를 반대 방향으로 만났다면 가중치가 -1, 그렇지 않다면 가중치가 1이 됩니다. &lt;/p&gt;&lt;p&gt;이렇게 그래프에 “변형된 가중치” 를 주면, 단순히 가장 거리가 짧은 정점을 찾은 후, 그 곳에 두더지를 배정하면, 현재의 선택이 기존의 선택을 최적화할 수 있으며, 미래의 선택에도 바뀔 수 있는 여지가 생깁니다. 이 알고리즘은 실제로 정당하며, 그 증명에 대해서는 후술합니다. &lt;/p&gt;&lt;p&gt;변형된 가중치는, 각각의 간선에 대해서 현재 이 간선을 윗방향 / 아랫방향으로 지나는 두더지가 몇 마리인지를 관리하면 찾을 수 있습니다. 이제, 트리에서 주어진 점과 가장 가까운 점을 찾는 방법은 단순 DFS로 $O(N)$ 에 가능하고, 간선을 갱신해 주는 것은 $O(\log N)$ 에 가능합니다. 간선 갱신이 $O(\log N)$ 인 이유는 이진 트리라서 경로의 길이가 항상 $O(\log N)$ 이하이기 때문입니다. 현재 시간 복잡도는 $O(NM)$ 입니다. &lt;/p&gt;&lt;p&gt;여기에 DP를 조합하면 시간 복잡도를 줄일 수 있습니다. 각각의 노드에 대해서, DP[i] = (i번 노드의 서브트리 중 i번 노드와 가장 가까운 정점, 그리고 그 거리) 를 저장합시다. 두더지가 새로 들어오는 정점을 $u$라고 하고, 가장 가까운 정점을 $v$ 라고 합시다. $LCA(v, w) = k$ 인 정점들은, 정점 $k$와, $k$의 자식 중 $v$ 와 반대편에 있는 정점의 서브트리들일 겁니다. 첫번째는 단순하게 계산해 주고, 두번째는 DP값을 단순히 참고하면 됩니다. 이를 $v$를 타고 올라가면서 계산해 주면 가장 가까운 정점을 $O(\log N)$ 에 계산할 수 있습니다. 계산이 완료 되면 경로가 추가되고, 가중치가 갱신됩니다. 고로, DP값을 갱신해야 합니다. 이 때는, 변동이 있는 노드들이 $v, w$의 조상들이기 때문에, 이들에 대해서만 새로운 값을 bottom-up으로 구해주면 됩니다. 이 역시 $O(\log N)$ 입니다. 고로, 두더지 하나를 새로 넣는데 $O(\log N)$ 시간이 걸려 시간 복잡도가  $O(M \log N)$이 됩니다. 생각의 과정이 길지만, 코드는 짧은 편입니다. &lt;/p&gt;&lt;p&gt;알고리즘의 정당성 증명은 Minimum Cost Flow라는 개념을 사용합니다. 이보다 더 간단한 방법이 있을 것이라고도 생각이 들지만, 개념을 알고 있다면 가장 쉽고 일반화하기 좋은 증명 방법이 됩니다. 이 문제를 Minimum Cost Flow의 instance로 모델링하면, 사실 위 알고리즘은 Minimum Cost Flow를 트리에서 돌리는 과정을 약간 추상화한 형태에 불과합니다. &lt;/p&gt;&lt;p&gt;대다수의 Greedy 알고리즘은 제한된 형태의 문제만 풀 수 있는 경우가 많지만, Minimum Cost Flow와 같은 Network Flow류 알고리즘은 Greedy 패러다임에 기반해 있으면서도 아주 다양한 조합 최적화 문제를 해결할 수 있는 강력한 해결법입니다. 풀이를 이해하는 데 어려움이 있거나, 비슷한 유형의 풀이에 관심이 있다면 Network Flow / Minimum Cost Flow에 대해서 알아보는 것을 추천합니다. &lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3&gt;6. &lt;a href=&quot;https://www.acmicpc.net/problem/6293&quot;&gt;BOI 2013. Vim&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;먼저 문제의 최적해에 대한 성질을 고찰합시다. 문제에서 왼쪽으로 가는 연산은 모두 h 동작을 사용해야 하고, 오른쪽으로 가는 동작은 모두 f 동작을 사용해야 합니다. 물론 x 동작 역시 매우 중요하지만, 이 문제에서는 그냥 모든 e를 만나게 하고, 그 과정에서 보일 때마다 지워주면 되니 최적해와는 크게 상관이 없다 볼 수 있습니다. 이 때 사용할 수 있는 중요한 성질은 다음과 같습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Lemma 1&lt;/strong&gt;. 최적해에서는, h 동작을 사용해서 두 번 이상 지나치는 점이 없다. &lt;/p&gt;&lt;p&gt;이 때 &quot;h 동작을 사용해서 지나쳤다&quot; 라고 함은, h 동작을 썼던 점이거나, h 동작의 대상이 되었던 점이라는 뜻입니다. Lemma 1의 증명은 은 최단 경로가 단순 경로인 것과 비슷한 이유이고 어렵지 않습니다. 이 Lemma는 문제에서 가장 중요한 핵심 아이디어이고, 문제의 최종 풀이 역시 이와 같은 관찰에 비롯합니다.&lt;/p&gt;&lt;p&gt;하지만 여기서 바로 동적 계획법을 시도하는 것보다는 문제를 조금 더 단순화하는 것이 유리합니다. 위에서 힌트처럼 나왔던 사실은, x 동작이 실제로는 커서의 이동에 큰 영향을 주지 않는다는 것입니다. 여기서 조금 더 나아가, x 동작 자체의 존재 여부를 없애 버릴 수도 있습니다.&lt;/p&gt;&lt;p&gt;여기서 몇가지 아이디어를 생각해 봅시다. 우리는 문자열 상에서의 e의 존재를 명시적으로 없애줄 필요가 없습니다. 문자 자체를 없애기 보다는, 모든 e 문자를 커서가 무조건 거쳐야 한다고 마크해놓은 후, 해당 문자에 들어갔을 때 x 키를 누름으로써 (지우지 않았지만) 사실상 지웠다고 판단해 주어도 됩니다. 이러한 단순화를 한다고 답이 바뀌지는 않지만, 문자열 상 문자를 변형할 필요가 없어서 유리합니다.&lt;/p&gt;&lt;p&gt;더 나아가서, 문자열 자체에서 e의 존재 자체를 지워버릴 수 있습니다. 문자 e를 지우기 위해서는, 이의 오른쪽에 있는 문자를 거쳐야만 합니다. 이 논리를 더 발전시키면, 연속된 e 문자들을 지우기 위해서는 이 연속된 문자들의 오른쪽에 있는 하나의 문자를 무조건 방문해야 하고, 또한 방문하면 이 연속된 문자들을 쉽게 지울 수 있습니다. 그림으로 표현하면 대략 다음과 같습니다.&lt;/p&gt;&lt;p&gt;ccb&lt;em&gt;eeeee&lt;/em&gt;&lt;strong&gt;b&lt;/strong&gt;bb &amp;lt;- 원래 상황 (무조건 거쳐야 하는 문자를 마크)&lt;/p&gt;&lt;p&gt;ccb&lt;strong&gt;e&lt;/strong&gt;eeee&lt;strong&gt;b&lt;/strong&gt;bb &amp;lt;- b를 거쳐 연속 구간의 가장 왼쪽 e를 도달&lt;/p&gt;&lt;p&gt;ccb&lt;strong&gt;b&lt;/strong&gt;bb &amp;lt;- x를 연타&lt;/p&gt;&lt;p&gt;이제 문제에서 문자 e와 동작 x를 완전히 지우고, f / h 동작, 그리고 무조건 지나야 하는 문자의 리스트만 가지고 있어도 문제를 풀 수 있습니다. 다음과 같은 Lemma를 구성할 수 있기 때문입니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Lemma 2&lt;/strong&gt;. &lt;em&gt;변형된 문제의 답 + 2 * (원래 문자열의 e의 개수)&lt;/em&gt; 가 변형 전 문제의 답과 동일하다.  &lt;/p&gt;&lt;p&gt;이제 지금까지 만든 관찰을 통해서 동적 계획법을 시도합니다. 어떻게 동적 계획법 상태를 정의하느냐가 문제의 핵심으로, 상태를 정의하는 방법에 따라서 동적 계획법 자체가 불가능할 수도 있고, 느린 시간 복잡도가 나올 수도 있습니다. &lt;/p&gt;&lt;p&gt;가장 직관적인 방법은 커서의 위치를 따라가는 것이지만, 여기서 사용하는 방법은 커서의 위치와 관계없이 왼쪽부터 오른쪽으로 순서대로 커서의 경로를 만들어 나가는 것입니다. 점프가 되는 형태를 보면, 임의의 두 문자 사이는 h로 움직여지거나 움직여지지 않는데, 그렇지 않은 상태에서는 왼쪽 -&amp;gt; 오른쪽 점프 정확히 한번 만이 존재하고, 그런 상태에서는 h의 오른쪽으로 오는 점프, 그리고 h의 왼쪽에서 탈출하는 점프 두가지가 존재합니다. 동적 계획법의 상태는 고로:&lt;/p&gt;&lt;p&gt;$dp1(x, C)$ : 현재 x번 문자와 x+1번 문자 사이를 h로 건너지 않으며, fC라는 키워드로 건너뛰고 있는 상황&lt;/p&gt;&lt;p&gt;$dp2(x, COUT, CIN)$ : x번 문자와 x+1번 문자 사이를 h로 건너는 상태에서, 두 개의 점프가 가로지르고 있는데, 이 중 한쪽은 fCIN 키워드로 h의 오른쪽 구간 끝을 향해 도착하며, 다른 한쪽은 fCOUT 키워드로 h의 왼쪽 구간 끝에서 출발. &lt;/p&gt;&lt;p&gt;이들의 상태 전이는 구간이 끝나고 시작할 수 있는 몇가지 케이스들을 고려하면 찾을 수 있습니다. 케이스가 약간 많은 편이니 신중하게 구현해야 합니다. 각 상태 전이 개수는 $x$ 하나당 전체 $O(C^2)$ 로, 시간 복잡도는 $O(NC^2)$ 가 됩니다. $C = 10$ 이라 시간 안에 충분히 통과합니다. &lt;/p&gt;</description>
<category>공부</category>
<author>구사과</author>
<guid>https://koosaga.com/222</guid>
<comments>https://koosaga.com/222#entry222comment</comments>
<pubDate>Sat, 01 Dec 2018 00:50:38 +0900</pubDate>
</item>
<item>
<title>ACM-ICPC Jakarta Regional 2018</title>
<link>https://koosaga.com/221</link>
<description>&lt;p&gt;후기 안 쓰려고 했으나 그냥 간단히 써보려고 한다.&lt;/p&gt;
&lt;h3&gt;11월 9일 금요일&lt;/h3&gt;
&lt;p&gt;대전에서 CMP 팀과 함께 인천공항으로 출발했다. &lt;/p&gt;
&lt;p&gt;KTX 탈 때마다 홍보하는 광명역 도심공항터미널을 이용해 보았는데, 안내도 잘 안되어 있고 버스비도 비쌌다. 서울역에서 공항철도 타고 가는게 훨씬 더 싸고 편했을 거 같다.  &lt;/p&gt;
&lt;p&gt;인천공항 게이트 쪽에 일본 사람들이 있었는데 대회 후드인걸 보았을 때 누가 봐도 ICPC를 참가하는 사람들 같았다. 아마 2등한 교토대 팀이었을 것 같다. 하지만 대회 끝날 때까지 말할 기회는 없었다 :(&lt;/p&gt;
&lt;p&gt;숙소는 기숙사라서 기대하지 않았는데, 거의 호텔급이어서 놀랐다. 매우 좋았다. 근데 수건이 2개였다.  &lt;/p&gt;
&lt;h3&gt;11월 10일 토요일&lt;/h3&gt;
&lt;p&gt;단체 사진을 찍고 가이드와 만났다. 한국에 관심이 많은 분이어서 기본적인 한국어는 하실 줄 아셨으나, 의사소통은 조금 힘들어서 영어로 했다.&lt;/p&gt;
&lt;p&gt;Opening Ceremony를 아침에 해서 많이 졸렸다. 이것저것 많았는데 잘 기억이 나지 않는다. 스폰서 톡이 아주 솔직하더라는 것만 기억이 난다... 반응이 한국보다 훨씬 좋았다. Technical Review때 대회 시스템 관련 중요한 이야기들이 많이 나왔으나, 나랑 수찬이는 무슨 생각이었는지 전혀 듣지 않았다. 다행이도 나중에 알고 보니 민규가 다 들어줬다. 개이득&lt;/p&gt;
&lt;p&gt;Practice Session에는 2017년 리저널 문제 2개와 처음 본 문제 하나가 나왔다. 처음 본 문제의 내용은 다음과 같다.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;길이 $N$의 정수 수열이 주어졌을 때, 이 수열의 모든 원소의 최솟값도, 최댓값도, 합도 아닌 음이 아닌 정수를 아무거나 출력하라. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;민규가 그냥 &lt;code&gt;puts(&quot;13105&quot;)&lt;/code&gt; 를 냈고 맞았다. &lt;/p&gt;
&lt;p&gt;Practice Session은 2시간 정도였는데, 끝날 때까지 못 나가게 해서 안에서 매우 지루했다. 끝나고 숙소에서 낮잠을 잤다.&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99F5B9425C00D5A112&quot; filemime=&quot;image/jpeg&quot; filename=&quot;IMG_3610.jpg&quot; height=&quot;615&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;저녁은 가이드 분이 로컬 푸드로 한상 크게 차려주셨다. 기름종이에 싸여서 우아한 자태를 뽐내고 있는 저 음식들은 굉장히 향이 강하고 끈덕지다. 정확히 민규 취향일 듯. 실제로 싱가폴에 산 적이 있던 민규의 추억을 자극하는 소울 푸드였던 것 같다. 다만 아쉽게도 전체적으로는 호불호가 있었다. &lt;/p&gt;
&lt;p&gt;사실 로컬 푸드는 식중독의 위험이 있어서 조심히 먹어야 한다. 난 처음에 신경 안 쓰고 막 집어먹다가 갑자기 그 생각이 나서 그때부터 조심히 먹기 시작했다. 그럼에도 먹은 후 배가 썩 좋지는 않아서 다음날이 걱정됐다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3&gt;11월 11일 일요일&lt;/h3&gt;
&lt;p&gt;오전에 일어나서 대회장으로 갔다. 다들 속이 그렇게 좋지 않았는지 화장실부터 찾았다 (...) 다행이도 그 이후 화장실에 다시 간 사람은 없었다.&lt;/p&gt;
&lt;p&gt;초반은 순조롭게 말렸다. 문제 선택도 잘못됐고 코딩도 밀렸던 것 같다. 2문제에서 올라오지 못해서 20등 밖으로 떨어지고 화면에서 사라지기도 했다. &lt;/p&gt;
&lt;p&gt;45분에 3번째 문제인 L이 늦게 나오고, 이 즈음부터 대충 틀린 문제들이 정리가 되고 풀이들이 나오기 시작했다. 특히 C에 대해서 재밌는 이야기가 나왔는데, 몇 주 전에 종원이형이 휴가 나오면서 민규한테 알려준 &lt;a href=&quot;https://en.wikipedia.org/wiki/De_Bruijn_sequence&quot;&gt;De Bruijn Sequence&lt;/a&gt;를 그대로 구하면 된다는 것이었다. De Bruijn Sequence는 우리 팀원들이 거의 처음 들어본 개념이었고 (고로 다른 팀들에게도 낮설 가능성이 아주 컸고) 이해도 하지 않았으나, 우리 팀노트에는 그걸 구하는 코드가 그대로 있었다. 팀노트를 생각 없이 베끼면 AC가 나오는 엄청난 꿀문제가 있었던 것이다.&lt;/p&gt;
&lt;p&gt;UCPC 2018처럼 스코어보드에 혼란을 주기 위해서 논의가 끝난 즉시 C를 잡았다. 금방 맞았다. 그 사이에 내가 H에 있던 코딩 미스를 고쳐서 5문제로 올라왔다. 이 때부터 시동이 걸렸다. 그 후 K, J, D가 빠르게 완성되어서 8문제로 올라갔다. 이 때 1등을 탈환했다. &lt;/p&gt;
&lt;p&gt;이후 F와 G가 승산이 있어 보여서 이 둘을 잡았다. F는 아이디어가 빨리 나왔으나, 접근에 따라 구현이 헷갈릴 수 있는 문제였고, 그걸 간파하지 못하고 성급하게 코딩해서 (내가 아니라 민규가 ㅎㅎ) 많은 불필요한 WA를 받았다. 누구든간에 이런 일은 있어서는 안된다. G는 $O(n^3)$ 이 될 것 같은데 뭔가 복잡할 것 같았고, 시간 제한이 1초라서 빡빡하지 않을까 싶었다. 약간 복잡하지만 될 거라는 확고한 믿음을 가지고 내가 코딩을 시작했는데, 알고 보니 처음에 불필요한 절차를 고려하고 있었다. 이 절차를 빼니까 매우 간단한 알고리즘이어서 여유롭게 맞았다.&lt;/p&gt;
&lt;p&gt;이후 남은 문제가 B와 E였다. 둘 다 상당히 어려운 문제로 보여서 1등하기 위해 꼭 다 풀고 갈 필요는 없겠다고 생각했다. E의 경우에는 바로 보이는 풀이가 없었고, 그건 B도 마찬가지였다. 하지만 트리에 지루한 쿼리를 날리는 것만큼 재밌는 일이 없기 때문에 내가 B를 열심히 시도했다. 그러다 대략의 접근 방식이 나와서 내가 바로 구현을 시작했고, 팀원들이 남은 부분을 검토하기로 했다. &lt;/p&gt;
&lt;p&gt;열심히 구현하니 최종적으로 7.2KB정도 나왔다. 좀 돌아간 거 같기도 하지만 뭐 대회니까.. DM도 컴퓨터 빌 때 짜 놓았으나, 예제를 그냥 돌려보았더니 맞아서 냈고, 바로 AC! 진짜 짜릿한 순간이었다.&lt;/p&gt;
&lt;p&gt;남은 시간 동안 E를 어떻게 뚫을까 고민했으나 별 생각이 안 나서 그냥 나이브 알고리즘을 구현해 보기로 했다. 아무 의미 없어 보이지만 태국에서 이거 비슷한 방식으로 정말 올솔브를 띄운 적이 있어서 (...) 시도해 보았다. 애석하게도 TLE. ㅠㅠ&lt;/p&gt;
&lt;p&gt;그러고도 정말 시간이 남아서 E의 풀이를 고민했다. 확실히 B보다는 아이디어와 구현 모두 쉬운 문제였다. 남은 시간 34분이면 구현을 시도는 해 볼 수 있었을 것 같다. 이번에는 별 상관 없었으나, World Finals 레벨에서는 내가 B 하고 있을 때 풀이가 나와서 같이 구현하고 맞았어야 한다고 생각한다. &lt;/p&gt;
&lt;p&gt;대충 난이도를 정리하면:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;easy: I &amp;lt; A &amp;lt; L&lt;/li&gt;
&lt;li&gt;easy-med: H = D &amp;lt; J &amp;lt; F &amp;lt; K = G&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;med-hard: C&lt;/li&gt;
&lt;li&gt;hard: E &amp;lt; B&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99F2AB475C00D6562A&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2018-11-30 오후 3.18.32.png&quot; height=&quot;659&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;p&gt;최종 스코어보드는 다음과 같았다. K는 난이도에 비해서 상당히 푼 사람이 적었고, 반면에 G와 C는 그 난이도에 비해 푼 사람이 많았다. 알고 보니 C는 그러한 문자열의 존재성을 믿고 랜덤 + Euler tour로 푸는 풀이가 있었고, 그것이 의도된 풀이었던 것 같다. 우리의 알고리즘보다 구현량은 더 많을 것 같으나 생각하기는 조금 더 쉬웠던 것 같다. G는 $O(n^3\log n)$ 이 통과되었다는 후문을 들어보면 데이터가 약한 것으로 보인다. 그게 결과에 얼마나 영향을 줬는지는 모르겠으나..&lt;/p&gt;&lt;/div&gt;&lt;p&gt;대회가 모두 끝난 후에는 시상식이 있었다. 맨 처음 시작한 것은 퍼솔 시상식이었다. 퍼솔 시상식은 대회 때 퍼솔이 나온 10문제에 대해서만 진행했는데, 우리 팀이 그 중 4개를 먼저 풀어서 6개의 텀블러와 머그컵을 받았다  &lt;/p&gt;
&lt;p&gt;그 다음에는 대망의 본 대회 시상식이 시작되었다. 시상하고 스코어보드 까는 모 이상한 ICPC 리저널과는 다르게, 이 리저널은 바로 리졸버를 켰다. 리졸버는 World Finals의 것을 그대로 사용했고 행사도 거의 동일하게 진행했다. 환호가 여기저기서 터져나오는 분위기의 시끄러운 시상식이었다. 한국도 UCPC 시상식때는 아주 시끄러웠는데, ICPC는 그러기 힘들다 :(&lt;/p&gt;
&lt;p&gt;시상은 월드 파이널과 비슷하게 금메달 3팀, 은메달 4팀, 동메달 5팀을 수상하고, 인도네시아 탑 12팀에 대해서 따로 시상이 진행되는 식이었다. (인도네시아 내부 수상은 메달 팀은 제외하고 시상했던 것으로 기억한다.) 우리는 프리즈 당시 스코어보드를 보는 것만으로도 1등임을 확정할 수 있는 상황이어서 그냥 재미있게 앉아서 지켜보고 있었던 것 같으나, CMP는 다른 상위권 수상자들의 결과에 따라서 메달 색이 바뀔 수 있어서 그것보다는 흥미진진했을 것이다. &lt;/p&gt;
&lt;p&gt;최종적으로 CMP 팀은 4등 (은메달), 우리 팀은 1등 (리저널 챔피언) 으로 대회를 마무리했다. 상품으로는 보조 배터리, 헤드셋, 외장하드, 등등... 액수가 크지 않은 물건들을 여러 개 주는 방향이었다. 갖고 가기는 힘들겠지만 나름대로 왕이 된 기분을 느껴보라고 의도적으로 그렇게 진행하고 있다고 한다 :)&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이후 저녁 식사가 있었으나 일정이 늦어져서 바로 공항으로 달려가야 하는 상황이었다. 저녁 식사는 출장 뷔페가 와서 나름대로 성대하게 차려준 것 같으나 (이건 한국이 더 낫긴 했다.) 그렇게 많이 먹지는 못하고.. 가이드에게 도움을 요청해서 택시 2대를 잡고 출발하였다. 잡고 타는 데 이런저런 문제가 있었으나, 현지 가이드 분들이 정말 성심성의껏 뛰면서 도와주신 덕분에 무사히 탈 수 있었다. 정말 많이 고마웠다. 대회 동안 거의 항상 같이 다녔던 가이드와 작별 인사를 하고, 공항으로 떠나서 한국에 도착했다.&lt;/p&gt;
&lt;p&gt;한국에 도착하니까 현지 대회 organizer에게 우승을 축하한다는 코드포스 DM을 받았다. &lt;del&gt;모 PP 리저널은 organizer가 코드포스 DM으로 &quot;니네 코드에 이거 안넣어서 실수오차로 틀렸음 ㅋㅋ&quot; 라고 보냈다던데&lt;/del&gt; 친절한 메시지에 감동을 받아서 잘 답장해 주었다. 마지막 ICPC 리저널 대회를 즐겁게 보내서 좋고, 대회에 애착이 많은 사람들과 함께 할 수 있어서 기뻤다 :) &lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;문제 셋은 코드포스 Gym에 올라와 있다. 퀄리티는 무난한 편이고, 재밌는 문제들도 있다. 지금까지 진행된 PP 대회 (한국 / 대만 / 인도네시아 / 태국) 중에서는 문제가 제일 좋은 것 같다. &lt;a href=&quot;https://codeforces.com/blog/entry/63220&quot;&gt;링크&lt;/a&gt; &lt;br /&gt;&lt;/p&gt;
&lt;p&gt;대회 풀이 역시 상세하게 잘 적혀 있어서, 특별히 내가 풀이 Writeup을 할 필요가 없다고 생각했다.&lt;/p&gt;</description>
<category>생각</category>
<author>구사과</author>
<guid>https://koosaga.com/221</guid>
<comments>https://koosaga.com/221#entry221comment</comments>
<pubDate>Fri, 30 Nov 2018 15:23:50 +0900</pubDate>
</item>
<item>
<title>ACM-ICPC Seoul Regional 2018</title>
<link>https://koosaga.com/220</link>
<description>(2018.11.10: H를 제외한 모든 풀이를 작성하였다.)

&lt;h3&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9908CC4A5BE187E231&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2018-11-06 오후 9.23.48.png&quot; height=&quot;525&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;br /&gt;&lt;/h3&gt;&lt;h3&gt;Result Analysis&lt;/h3&gt;
&lt;p&gt;이번 서울 리저널에서의 각 대학 별 상위 팀은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서울대학교: 789 (순위 외: 2018 WF 은메달)&lt;/li&gt;
&lt;li&gt;도쿄대학교: Gifted Infants (순위 외: 2018 WF 금메달)&lt;/li&gt;
&lt;li&gt;KAIST: Deobureo Minkyu Party (리저널 1등)&lt;/li&gt;
&lt;li&gt;국립 타이완 대학교: waynedisonitau123 (리저널 2등)&lt;/li&gt;
&lt;li&gt;한양대학교: FailedSystemTest (리저널 3등)&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;시상식을 대회 후에 진행해서 엄청나게 김이 빠졌지만... 올해 리저널은 작년에 비해서 흥미로운 결과가 여럿 있었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;서울대학교 내전&lt;/strong&gt;. 789와 Black Cow 모두 평소 연습에서 아주 강한 결과를 보여준 바가 있다. 하지만 Black Cow의 평소 실적이 매우 훌륭했기 때문에, 적어도 나는 올해의 교내경쟁이 2016년과 비슷한 양상을 띌 것이라는 데에 별 의문을 갖지 않았다. 대회 초중반을 거치면서 Black Cow는 789를 계속 압도했으나, 789가 빠르게 따라잡았기 때문에 그 차이가 크지는 않았다. 두 팀 모두 3시간 즈음에 10문제를 완성한 상태에서 후반부로 대회가 접어들었다. 한 문제만 해결하면 이때까지의 승부를 모두 원점으로 돌릴 수 있는 상황에서, 789는 대회 종료 6분 전에 I번 문제를 풀어냈고, 기존의 승부를 원점으로 돌리고 승리를 거머쥐었다. 축하합니다!&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;외침&lt;/strong&gt;. 올해의 강한 해외팀은 동경대의 Gifted Infants, NTU의 waynedisonitau123 이 있었다. Gifted Infants는 평소 다양한 프로그래밍 대회에서 매우 강한 성적을 보여왔던 yosupo, sigma425, maroonrk로 이루어졌고, 올해 WF 메달 가능성이 아주 높은 팀이다. 3등이라는 성적이 절대적으로 높지는 않으나, 올해 서울대의 결과가 매우 강했음을 감안하면 충분히 훌륭한 성적으로 보인다. waynedisonitau123은 Lazy Propagation을 사용하는 문제였던 A를 20분에 First Solve 함으로써 멘붕을 안겨주고, 찍어맞추는 유형의 문제인 C를 140분에 First Solve 함으로써 다른 팀들이 같이 찍어맞출 용기를 주었다. 최종 성적은 5등이지만 스코어보드에 준 영향은 상당히 컸다고 생각한다. Congratulations!&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;한양대학교&lt;/strong&gt; 는 매년 ICPC에서 꾸준히 좋은 성적을 내온 대학 중 하나지만, 올해 대회에서는 9문제를 해결하고 리저널 3등 성적을 냄으로써, World Finals에 진출할 가능성을 확보하였다. 최근 몇년간 리저널 3등 이내에 든 학교는 거의 KAIST / 고려대 / 서울대로 한정되어 있었고, 예외는 kriii님이 있던 성균관대와 2017년의 UNIST 정도였는데, 올해 서울 리저널에서는 한양대학교가 이 리스트에 새롭게 이름을 올렸다. 이후 해당 팀의 해외 리저널 성적과, 다른 대학의 해외 리저널 성적이 이 팀의 운명을 좌우할 것이다. 그러니까 이제 한동안 해외 리저널 보면서 발을 동동 구를 일만... 축하합니다!&lt;/li&gt;

&lt;/ul&gt;
&lt;h3&gt;My story&lt;/h3&gt;
&lt;p&gt;작년 팀원들과는 호흡이 상당히 잘 맞았기 때문에 팀을 깰 생각이 없었다. 혜아가 World Finals를 두번 나가서 다시 출전을 하지 못하는 게 문제였다. 올해 초 여러 복잡한 사건들을 거치면서 내년에는 수찬이와 WF에 가야겠다는 생각을 했다. 그래서 수찬이에게 WF가면 내년 동아리 회장하는 조건으로 (...) 팀원을 제안했고, 수찬이가 받아줘서 그렇게 했다. &lt;/p&gt;&lt;p&gt;팀 이름에는 만족하고 있었으나, 최근 지지율이 떨어지기도 했고 2년 하기에는 약간 식상해서 바꿀 생각이 있었다. 그래서 2시간 정도 회의를 했는데, 재미가 없거나, 지나치게 정치적으로 올바르지 못하다는 이유 등으로 탈락하였다. 좋은 대안을 못 찾아서 그대로 유지.&lt;/p&gt;&lt;p&gt;인터넷 예선 전후 성적을 보면서, WF에 나갈 수 있을 지 없을 지는 몰라도 이대로라면 나가면 안되는 실력이라는 생각이 들었다. 그래서 학기중 바쁜 와중에 &lt;a href=&quot;http://koosaga.com/219&quot;&gt;매우 밀도있는 팀연습&lt;/a&gt;을 진행하였다. 셋 다 몇번 참교육 당하더니 폼이 금방 올라왔다. 지금은 WF에 나가서도 잘 할 것 같다.  &lt;/p&gt;
&lt;h3&gt;Problemset&lt;/h3&gt;
&lt;p&gt;인터넷 예선과 17 대전 리저널 이후 모두의 예상을 깨고 (...) 문제 셋의 수준이 꽤 높게 나왔다. 16년도 대전 리저널과 비교할 수 있다고 생각한다. 문제는 난이도 순으로 정렬했다. 정확히 난이도 순으로 정렬했다고 생각하지만, 이견이 있을 수 있다.&lt;/p&gt;&lt;h4&gt;D. Go Latin (☆)&lt;br /&gt;&lt;/h4&gt;
&lt;p&gt;단수형 라틴어 단어가 주어졌을 때 복수형 라틴어 단어로 변환하는 문제로, 문제에 규칙이 다 나와있기 때문에 이를 구현하면 되는 단순 구현 문제였다. 기초적인 문자열 조작 능력이 있으면 쉽게 풀 수 있으나, 규칙이 여러가지이기 때문에 실수하지 않는 코딩을 하고, 오타를 내지 않는 것이 핵심이다.&lt;/p&gt;
&lt;h4&gt;L. Working Days (★☆)&lt;br /&gt;&lt;/h4&gt;
&lt;p&gt;첫날부터 순서대로 일을 배정한다고 해 보자. 첫 날에는 모든 사람들이 일을 할 수 있는데, 이 중 누구를 골라서 일을 시켜야 할까? 직관적으로 생각해 보면, 가장 할 일이 많은 사람이 첫 날부터 바쁘게 일을 해야 할 것이다. 그렇다면, 가장 할 일이 많은 $a_1$ 명의 사람들에게 일을 시키고. 다음 날로 넘어가자. 다음 날에는 몇명의 사람들은 일을 하거나 쉬는 상황일 것이다. 고로 이러한 사람들을 빼고 가장 할 일이 많은 $a_2$ 명의 사람들에게 일을 시키고... &lt;/p&gt;&lt;p&gt;위와 같은 생각을 연장시키면 단순한 Greedy 전략을 생각해 볼 수 있다. 첫날부터 순서대로 움직이면서, 현재 일 할 수 있는 사람들 중 할 일이 가장 많은 $a_i$ 명의 사람을 골라서 이들에게 일을 시키는 것이다. 실패가 있다면 (사람이 부족하거나 이렇게 해도 일을 다 못하거나) 답은 없는 것이고, 실패가 없다면 이대로 진행하면 된다. &lt;/p&gt;&lt;p&gt;이를 단순하게 구현하면, 각 날에 대해서 일이 많은 $a_i$ 명의 사람을 $O(N\log N)$ 정렬 후 찾을 수 있다. 이 방법의 시간 복잡도는 $O(NM\log M)$ 이다. 정렬은 매우 빠르기 때문에 이러한 단순 구현으로 충분히 AC를 받을 수 있다. 굳이 필요하지 않지만, $a_i \leq N$ 임을 응용해서 Counting Sort를 하면 시간 복잡도에서 log를 없앨 수 있다.&lt;/p&gt;&lt;p&gt;틀릴 수 없어 보이는 이 Greedy는 실제로도 아주 잘 된다. 증명은 일반적인 Exchange Argument인데 여기서는 짧게만 설명한다. 위 Greedy가 틀렸다고 가정하자. 그렇다면, 위 Greedy가 답을 못 찾지만 답이 있는 경우가 존재한다. 실제 답 전략과 Greedy가 다르게 동작하는 마지막 날을 생각해 보자. 이 날 선택되지 않은 일이 가장 많은 사람 $x$, 이 날 선택된 일이 가장 적은 사람 $y$를 고려했을 때, 위 Greedy가 틀렸다는 가정에 의해 $x$의 남은 일의 개수 $D_x$가 $y$의 남은 일의 개수 $D_y$ 이상이다. 이 때, 단순히 $x$의 차후 일 목록과 $y$의 차후 일 목록을 그냥 교환하고, $y$의 차후 $D_x - D_y$ 개의 일을 $x$한테 다시 몰아주자. &quot;마지막 날&quot; 이라는 가정 때문에, 위와 같은 교환은 항상 가능하다. 이를 반복하면 이 &quot;마지막&quot; 날까지의 답 전략을 Greedy한 전략으로 대체할 수 있다. 이를 날짜를 줄여가며 계속 반복하면 (수학적 귀납법) Greedy 전략도 답이 있다는 결론에 도달해서, 가정에 모순이다.&lt;/p&gt;
&lt;h4&gt;F. Parenthesis (★☆)&lt;/h4&gt;
&lt;p&gt;수식이 주어졌을 때, 이 수식이 올바른 C-style 수식인지를 판별하고, 만약 그렇다면 이 수식이 올바르게 괄호가 쳐진 수식인지를 확인하는 문제이다.&lt;/p&gt;&lt;p&gt;먼저, 수식이 올바른 C-style 수식인지 아닌지 (error인지 아닌지) 부터 해결하자. 수식이 무엇인지를 엄밀하게 정의하는 것이 도움이 될 것이다. 괄호 문자열과 비슷하게, 수식은 다음과 같이 재귀적으로 정의된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;한 글자 심볼은 올바른 수식이다.&lt;/li&gt;
&lt;li&gt;$E1$과 $E2$ 가 올바른 수식이면, $E1$ op $E2$ (op는 사칙연산자) 는 올바른 수식이다.&lt;/li&gt;
&lt;li&gt;$E1$이 올바른 수식이면, $(E1)$ 역시 올바른 수식이다. &lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;어떠한 수식이 이 재귀적 정의 안에 들어가는 지를 판별하는 것은 어떻게 할 수 있을까? 후위표현식 변환과 비슷하게 Stack을 사용하여 선형 시간에 하는 방법이 잘 알려져 있으나, 더 간단한 방법도 있다. 주어진 수식을 토큰으로 분할하고, 다음 과정을 반복하자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;심볼 x, y와 사칙연산자 op에 대해, x op y 과 같은 패턴이 있다면, x로 대체한다.&lt;/li&gt;
&lt;li&gt;심볼 x에 대해, (x) 와 같은 패턴이 있다면, x로 대체한다.&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;이는 위 재귀적 과정에 따라서 수식의 크기를 하나씩 줄여나가는 것이라고 생각할 수 있다. (스택을 사용하여 문제를 해결하는 것 역시 위 과정과 근본적으로 동일하다.) 최후에 하나의 심볼이 남는다면 수식은 error가 아니고, 그렇지 않다면 수식은 error이다.&lt;/p&gt;&lt;p&gt;위와 같은 방법을 사용하면 proper / improper의 판별도 똑같이 할 수 있다. 이 경우에는 제약 조건이 붙어서 더 간단하다. 심볼 x, y와 사칙연산자 op에 대해서, (x op y)와 같은 패턴이 있다면 이를 x로 대체하는 것을 반복하자. 최후에 a op b가 남았다면 이는 proper한 수식이고, 그렇지 않다면 improper한 수식이다. 이 때, &quot;a&quot;도 proper함에 유의하라. 시간 복잡도는 $O(n^2)$로, 문제를 풀기 충분하다. &lt;/p&gt;

&lt;h4&gt;K. TV Show Game&amp;nbsp;(★★)&lt;/h4&gt;
&lt;p&gt;3개의 조건 중 2개의 조건을 만족하는 문제 대신, 2개의 조건 중 1개의 조건을 만족하는 문제를 풀어보자. 이 문제는 잘 알려진 2-SAT 문제로, $n$개의 boolean value $p_1, p_2, \cdots p_n$ 을 만든 후, $p_i$ 가 참이면 파란색, 아니면 빨간색으로 색을 칠한다고 하자. 이제 문제에 주어진 모든 조건을 2-CNF 식으로 그대로 변형시킬 수 있다. 2-SAT 문제는 선형 시간 해결 방법이 잘 알려져 있고 이 단락에서는 설명하지 않는다.&lt;/p&gt;&lt;p&gt;이제, 원래 문제로 돌아오자. 3개의 조건 중 2개 이상을 만족시킨다는 조건을 그대로 적용할 수는 없지만. 위 제약된 형태가 2-SAT 문제이니 이 문제도 2-SAT으로 변형하면 된다는 강한 느낌을 받을 수 있다. 실제로, 간단한 변환으로 이를 2-CNF 형태로 만들 수 있다. 논리 식 $a, b, c$ 중 2개 이상이 만족한다는 것은, $a \lor b$, $b \lor c$, $c \lor a$ 가 모두 만족된다는 것과 동치임을 확인할 수 있다. 즉, 각 줄에 있는 조건은 결국 3개의 2-SAT 항으로 변형된다. 이 2-SAT을 해결하면 문제를 해결할 수 있다.&lt;/p&gt;
&lt;h4&gt;A. Circuits (★★☆)&lt;/h4&gt;
&lt;p&gt;축에 평행한 직사각형 $n$개가 주어져 있을 때, $x$축에 평행한 직선 2개를 그어서 최대한 많은 직사각형을 교차시키는 문제이다. 긋는 직선이 $x$축에 평행하니까 당연하게도(...) 직사각형의 $x$좌표는 전혀 중요하지 않고 입력으로 받을 필요도 없다. 결국 문제는, $n$개의 구간이 주어졌을 때, 점 2개를 찍어서 최대한 많은 구간을 교차시키는 것이다.&lt;/p&gt;&lt;p&gt;먼저 해야 할 관찰은, 찍는 점이 어떠한 구간의 끝점 중 하나라고 가정할 수 있다는 것이다. 만약에 찍는 점이 어떠한 구간의 끝점도 아니라면, 이를 끝점이 나올 때까지 왼쪽으로 밀어줘도 상관이 없다. 이렇게 될 경우 가능한 후보가 유한하게 ($O(n^2)$) 로 줄고, 좌표 압축의 논리를 활용할 수 있다는 장점이 있다. 이 상태에서 구간을 좌표압축하고 모든 끝점의 쌍을 시도하면 $O(n^3)$ 알고리즘을 유도할 수 있다.&lt;/p&gt;&lt;p&gt;여기서 문제를 해결할 수 있는 두가지 관점이 있다. 두 관점에 따라서 유도되는 결론은 동일하지만, 이 문제에서는 여러가지 관점을 익히는 것이 매우 중요하다고 생각한다. 고로 둘을 모두 소개한다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;점 하나를 고정&lt;/strong&gt;: 찍은 점 중 하나를 고정시키면 문제를 해결할 수 있을까? 고정한 점을 $p_1$이라고 하자. $p_1$을 포함하는 구간은 모두 교차되었기 때문에 이후 고려하지 않아도 된다, $p_1$을 포함하지 않는 구간들에 대해서, $p_2$를 찍어야 하는 위치는 이들이 가장 많이 교차하는 위치일 것이다. 결과적으로, 우리는 $p_1$을 포함하지 않는 구간이 최대 몇개 동시에 쌓여있는가에 대해 관심이 있다. &lt;/p&gt;&lt;p&gt;이를 자료구조를 통해서 해결해 보자. 구간에 일정한 수를 더하고, 전체 최댓값을 계산할 수 있는 자료구조가 있으면, 우리는 구간들을 모두 더해주고 최댓값을 계산함으로써 문제를 풀 수 있다. 이는 Lazy Propagation을 사용한 Segment Tree를 통해서 해결할 있다. 이 때의 시간 복잡도는 $O(n^2\log n)$ 이다.&lt;/p&gt;&lt;p&gt;여기서 낭비가 되는 부분은, $p_1$을 바꾸는 시점에서 우리가 전체 구간들을 전부 순회한다는 것이다. $p_1$을 순서대로 증가시키면서 해결한다고 생각해 보자. 어떠한 구간 $[s, e]$는 $p_1 &amp;lt; s$일 때는 $p_1$과 교차하지 않다가, $s \leq p_1 \leq e$일 때 $p_1$과 교차하고, $e &amp;lt; p_1$일 때 다시 교차하지 않는다. 고로, $p_1$이 고정되어 있을 때 우리는 굳이 전체 구간을 돌 필요 없이, $p_1 - 1$ 상태에서 변화한 구간들만 갱신시켜 주면 된다. 이렇게 되면 구간이 추가되고 제거되는 이벤트가 총 $2n$개이고, $p_2$는 위에서 만든 Segment Tree를 그대로 관리해 주면 바로 찾을 수 있다. 시간 복잡도는 $O(n\log n)$ 이다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;기하학적 접근&lt;/strong&gt;: $f(p_1, p_2)$ 를, $p_1, p_2$ 에 점을 찍었을 때 교차하는 구간의 개수라고 정의하자. 우리는 모든 $1 \leq p_1, p_2 \leq 2n$ 에 대해서 $f(p_1, p_2)$ 의 최댓값을 계산하고 싶다. 구간 $[s, e]$가 $f(p_1, p_2)$ 에 기여한다는 것은:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$p_1 &amp;lt; s$ 라면, $s \leq p_2 \leq e$ 이어야 이 구간이 $(p_1, p_2)$ 와 교차한다.&lt;/li&gt;
&lt;li&gt;$s \leq p_1 \leq e$ 라면, $p_2$와 상관없이 구간은 교차하니, $1 \leq p_2 \leq 2n$ 이어야 이 구간이 이 구간이 $(p_1, p_2)$ 와 교차한다.&lt;/li&gt;
&lt;li&gt;$e &amp;lt; p_1$ 이라면, $s \leq p_2 \leq e$ 이어야 이 구간이 $(p_1, p_2)$ 와 교차한다.&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt; $x$ 축을 $p_1$, $y$ 축을 $p_2$로 가지는 격자점에 $f(p_1, p_2)$ 를 적었다고 하자. 어떠한 구간 하나가 추가되었을 때, $f(p_1, p_2)$는 이 구간과 교차하는 점들에 대해서 +1이 되고 그렇지 않은 점들에 대해서 0이 된다. 이 때, 구간과 교차하는 점들의 집합은 3개의 겹치지 않는 직사각형으로 표현할 수 있다. 요컨데 $n = 5, [s, e] = [3, 5]$ 라고 하면 (행렬처럼 아래/오른쪽으로 갈수록 $x, y$ 증가)&lt;/p&gt;&lt;p&gt;&lt;code&gt;XXOOOXXXXX&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;XXOOOXXXXX&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;OOOOOOOOOO&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;OOOOOOOOOO&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;OOOOOOOOOO&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;XXOOOXXXXX&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;XXOOOXXXXX&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;XXOOOXXXXX&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;XXOOOXXXXX&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;XXOOOXXXXX&lt;/code&gt;&lt;/p&gt;&lt;p&gt;와 같은 그림이 나올 것이다. O와 겹치는 위치는 +1이 더해질 것이고, 그렇지 않은 위치는 그대로 남을 것이다.&lt;/p&gt;&lt;p&gt;우리가 알고 싶은 것은 $f(p_1, p_2)$ 의 최댓값이다. 고로, 위에서 만든 $3n$ 개의 직사각형 중 가장 많은 직사각형이 겹치는 위치를 알고 싶다. 이는 Plane Sweeping을 통해서 풀 수 있음이 잘 알려져 있다. 고로 위에서 만든 것과 똑같은 Segment Tree를 만들면 $O(n\log n)$ 시간에 문제를 해결할 수 있다.&lt;/p&gt;&lt;p&gt;여담으로, 이 문제는 $k$개의 점을 찍는 경우에도 $O(kn\log n)$ , 심지어는 $O(n\log^2 n)$ 시간 복잡도에 해결할 수 있다. &lt;/p&gt;


&lt;h4&gt;J. Starwars (★★☆)&lt;/h4&gt;
&lt;p&gt;올해 인터넷 예선 K와 거의 동일하지만, 제한이 작아서 조금 더 쉬워졌다는 차이가 있다. 문제가 길어서 읽기 힘들지만, 읽고 나면 이 문제는 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떠한 인간 정점에서 어떠한 기지 정점에 도착하는 경로 $P$&lt;/li&gt;
&lt;li&gt;어떠한 외계인 정점에서 어떠한 기지 정점에 도착하는 경로 $Q$&lt;/li&gt;
&lt;li&gt;$P$에 적힌 알파벳과 $Q$에 적힌 알파벳이 동일  &lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;둘이 출발하는 인간 정점과 외계인 정점을 고정시키면, 두 정점이 같은 수가 적힌 에지를 계속 반복해서 고르면서, 서로 기지 정점에 도착할 수 있는가를 찾는 문제이다. 이는 노드 쌍을 정점으로 하는 깊이 우선 탐색을 구현하면 된다. 현재 보고 있는 정점 쌍이 $(p, q)$ 라면, $p$에 인접한 모든 정점, $q$에 인접한 모든 정점을 보면서, 해당 정점과 연결된 간선이 같은 수가 젹혀있다면 그 간선을 동시에 타고 가서 이동하는 것이다. &lt;/p&gt;&lt;p&gt;둘이 출발하는 정점의 쌍이 여러가지일 수 있으나, 그냥 Flood Fill 하듯이 도달이 될 때까지 모든 쌍을 다 해보면 된다. 아니면, 인간 더미 정점과 외계인 더미 정점을 만든 후, 각 더미 정점에서 대응되는 인간 / 외계인 정점에 대해서 번호 1이 붙어있는 에지를 다 만들어 줘도 된다. 이러면 (인간 더미 정점, 외계인 더미 정점) 에서 한번만 DFS를 해도 문제가 해결된다. &lt;/p&gt;&lt;p&gt;시간 복잡도는&lt;/p&gt;&lt;p&gt; $O(\sum_{i \in V(G)}{\sum_{j \in V(G)}{(deg_i \times deg_j)}}) = O(\sum_{i \in V(G)}{deg_i \times \sum_{j \in V(G)}{deg_j}}) = O(M^2)$ &lt;/p&gt;&lt;p&gt;이다.&lt;/p&gt;&lt;h4&gt;E. LED (★★★)&lt;/h4&gt;
&lt;p&gt;E는 절대적으로는 쉬운 편인 문제에 속하나, 문제에 숨겨져 있는 이상한 함정을 찾는 것이 아주 까다로운 문제였다. 출제 의도를 이해하기 힘든 문제라고 생각한다 (꼼꼼한 건 나름대로 중요하긴 하나..).&lt;/p&gt;&lt;p&gt;최댓값을 최소화하는 것이니 답에 대한 이분 탐색을 사용해야 한다는 생각이 든다. $D$ 이하의 답이 있는지를 판별해 보자. 결국 각각의 점에 대해서 $L_i - D \leq F(v_i) \leq L_i + D$를 만족하는 함수 $F$ 를 찾아야 하는 문제이다. 이는 $n$ 개의 구간이 있을 때, 문제에서 주어진 형태의 함수 중 이 구간을 모두 지나는 함수가 있는지를 판별하는 문제와 동일하다.  &lt;/p&gt;&lt;p&gt;이는 Greedy하게 할 수 있다. 모든 주어진 데이터를 $v_i$ 순으로 정렬하자. 함수의 상태는 크게 3개의 phase가 있다고 해석할 수 있다. phase를 바꾸는 것은 비가역적이니 문제를 해결할 때 현재 함수의 값을 최대한 유지하는 것이 좋다. 즉, $L_i \leq D$ 를 만족할 때까지는 첫번째 phase를 그대로 유지한 후, 현재 phase로는 도저히 그것이 불가능 할 때 구간을 위로 올리고, 그것이 또 불가능해지면 구간을 올리고... 이를 3번 해 본 후, 모든 점이 덮였는지를 보는 것이다.&lt;/p&gt;&lt;p&gt;$L_i \leq D$ 를 만족하지 않아서 첫번째 phase를 깨뜨려야 하는 상황을 생각해 보자. 해당 위치를 포함해서, 그 뒤에 있는 모든 값들 중 최솟값을 생각해 보자. 두번째 phase의 함수값은 이것에 $D$ 를 더한 것보다 무조건 작거나 같아야 한다. 하지만 이보다 작을 이유는 없으니, 이것의 최솟값 + $D$ 를 두번째 phase의 함수값으로 설정한다. 두번째 phase를 깨뜨릴 때도 비슷한 방법으로, 아직 덮이지 않은 점의 $L_i$ 최솟값 + $D$를 함수값으로 설정해 준다. 이를 반복해서 최후에 모든 점이 덮였는지 아닌지를 체크한다. $D$ 는 반정수이기 때문에, 모든 $L_i$ 를 2배 해준 후, 정수라고 가정하고 이분 탐색을 하면 문제가 해결되.. 었을까??&lt;/p&gt;&lt;p&gt;이를 그대로 구현하면 Wrong Answer를 받는다. 반례는 다음과 같다:&lt;/p&gt;&lt;p&gt;1&lt;/p&gt;&lt;p&gt;0 10000&lt;/p&gt;&lt;p&gt;답은 놀랍게도 10000.0 이다. 그 이유는, 첫번째 phase를 0인 위치에서 절대 깨뜨릴 수 없게 문제 디스크립션이 써져있기 때문이다 (부등호를 잘 보자!) 고로, 이에 대해서 특수한 예외 처리가 필요하다. 다행이도, 이 예외처리는 크게 복잡하지 않다. $v_i = 0$ 인 점이 있으면 이 점에 대해서만 예외처리를 해 주면 되기 때문에, 이 때 단순히 이분 탐색의 시작 범위를 $L_i$ 로 설정해 주면 된다. 이를 해결하면 정답을 받을 수 있다.&lt;/p&gt;
&lt;h4&gt;B. Cosmetic Survey (★★★)&lt;/h4&gt;
&lt;p&gt;문제에서 요구하는 것이 꽤 복잡하게 써져 있다. 순서대로 하자. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;일단 문제에서 하라는 대로 따라하면 $d(x, y)$를 구해놓을 수 있다. 문제에서 정의하는 Path는 일반적인 그래프와 똑같은데, $d(x, y) &amp;gt; d(y, x)$일 경우에만 $x \rightarrow y$ 간선이 있는 꼴이니 이 때에만 간선을 만들어 줘야 한다. &lt;/li&gt;
&lt;li&gt;Path의 Preference Index는 Path 상에 있는 모든 간선의 $d(x, y)$ 값 최소다. 우리는 가능한 $X \rightarrow Y$ 경로 중 Preference Index의 최댓값을 $S(X, Y)$ 라고 정의한다. 경로가 없으면 $S(X, Y) = 0$ 이다. &lt;/li&gt;
&lt;li&gt;이걸 모든 $X, Y$ 에 대해 구해놓으면 문제에서 하라는 대로 답을 찍을 수 있는 것 같으니, 이것을 각 쌍에 대해서 구하는 것이 목표이다.&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;이제 문제는 다음과 같이 간략하게 표현 가능하다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;방향성과 가중치가 있는 그래프 $G$가 주어졌을 때, 모든 정점 쌍 $X, Y$ 에 대해서, 가능한 모든 $X \rightarrow Y$  경로 중 간선 가중치의 최솟값을 최대화한 값을 구하라.&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;이는 최단 경로 알고리즘을 응용해서 해결할 수 있다. Dijkstra 알고리즘도 충분하지만, Floyd-Warshall 알고리즘을 사용하면 구현과 이해가 쉽다. 초기 행렬을 $D[i][i] = \infty$, $D[i][j] = 0 (i \neq j)$ 라고 설정하자. Floyd-Warshall의 요령을 그대로 활용해서, $i \in [1, N]$ 와 모든 $1 \leq j, k \leq N$ 에 대해, $i$번 정점을 거치는 $j \rightarrow k$ 경로 중 최솟값을 최대로 하는 경로를 찾는다. 이 경로의 값은 $min(D[j][i], D[i][k])$ 이다. 이를 $j \rightarrow k$ 로 가는 경로의 최댓값에 업데이트하는 것을 계속 반복해 주면 된다. &lt;/p&gt;

&lt;h4&gt;G. Secret Code (★★★☆)&lt;/h4&gt;
&lt;p&gt;문제를 다음과 같이 변형할 수 있다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$[0, S]$ 구간 안에 3개의 점 $p_a, p_b, p_c \in [0, S]$ 를 고른다 (이 점이 정수일 필요는 없다). &lt;/li&gt;
&lt;li&gt;각각의 점에서 시작해서 길이가 $w_a, w_b, w_c$인 구간을 3개 긋는다. 즉, $[p_a, p_a + w_a], [p_b, p_b + w_b], [p_c, p_c + w_c]$ 와 같은 3개의 구간이 있는 것이다. &lt;/li&gt;
&lt;li&gt;이 3개의 구간들을 시작점 순으로 정렬하였을 때, 시작점이 가장 작은 구간과 두번째로 작은 구간이 겹치고, 두번째로 작은 구간과 세번째로 작은 구간이 겹치기를 원한다. &lt;/li&gt;
&lt;li&gt;모든 가능한 $p_a, p_b, p_c \in [0, S]$ 중 원하는 상황이 일어날 확률을 구해야 한다.&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;여기서, 우리는 $p_a \le p_b \le p_c$라고 가정할 수 있다. 그렇지 않은 경우의 확률 역시 세어 줘야 하지만, 이는 거꾸로 모든 가능한 $\{w_a, w_b, w_c\}$의 순열을 돌면 해결할 수 있기 때문이다. &lt;/p&gt;&lt;p&gt;위 가정 덕분에 우리가 원하는 사건을 부등식으로 쓸 수 있다. 가장 작은 구간과 두번째로 작은 구간이 겹친다는 것은 $p_b \leq p_a + w_a$ 를 뜻하고, 두번째와 세번째가 겹침은 $p_c \leq p_b + w_b$ 를 뜻한다. 즉, 우리는 모든 $0 \leq p_a \leq p_b \leq p_c \leq S$ 인 사건 중, $p_b \leq p_a + w_a$, $p_c \leq p_b + w_b$ 를 만족할 확률을 구해야 한다.&lt;/p&gt;&lt;p&gt;식이 참 복잡하니, 조금 정리해 주자. $a = p_a, b = p_b - p_a, c = p_c - p_b$ 라고 정의하면, 결국 $a, b, c \geq 0, a + b + c \leq S$ 인 모든 사건 중, $b \leq w_a, c \leq w_b$ 를 만족할 확률을 계산하는 것이 된다.&lt;/p&gt;&lt;p&gt;정리된 식은 간단할 뿐만 아니라, 기하적인 관찰을 가능하게 한다. $(a, b, c)$ 를 3차원 좌표평면에 편다면, 결국 우리가 계산할 것은, 원점을 중심으로 하는 사각뿔과, 원점을 한 꼭짓점으로 하는 직육면체의 교집합의 넓이를 계산하는 것이다. 초등/중학교 때 배운 공식 $V = \frac{1}{3}Ah$ 를 사용하면 (아니면 고등학교때 배운 적분을 쓰면) 사각뿔의 부피가 $\frac{1}{6}S^3$임은 쉽게 보일 수 있다. 그렇다면 사각뿔과 직육면체의 교집합은 어떨까? 매우 복잡하지 않을까?&lt;/p&gt;&lt;p&gt;사각뿔과 직육면체의 교집합을 계산하는 것은 포함 배제를 사용하면 간단하다. 전체 사건의 부피가 $\frac{1}{6}S^3$ 인 것은 알고 있으니, 여기서 $b$가 잘못된 경우의 부피를 빼고, $c$가 잘못된 경우의 부피를 빼고, 둘 다 잘못된 경우의 부피를 더하자. 예시로 $b, c$가 모두 잘못된 경우를 생각해 보자. $b \geq w_a, c \geq w_b, a \geq 0$ 임과 동시에 $a + b + c \leq S$ 인 부피를 알고 싶은 것인데, 이는 $a, (b - w_a), (c - w_b) \geq 0, a + (b - w_a) + (c - w_b) \leq S - w_a - w_b$ 라는 식과 동일하다. 즉, 위와 동일한 식이다! 이런 식으로 각 경우에 대한 부피를 간단하게 계산할 수 있고, 이들을 다 합해주면 답을 찾을 수 있다.&lt;/p&gt;

&lt;h4&gt;C. Disks Arrangement (★★★★)&lt;br /&gt;&lt;/h4&gt;
&lt;p&gt;최댓값과 최솟값이 4배 이하의 차이를 가진다는 조건 때문에, 두 원이 만나는 복잡한 경우를 가정할 필요가 없다. 원을 수직선과 닿는 순서대로 읽었을 때, 어떠한 원은 그 원의 왼쪽 / 오른쪽에 있는 원과만 인접할 수 있다. 이제 피타고라스의 정리를 사용해서 순서가 고정되었을 때의 답을 단순 수식으로 정리할 수 있다. 반지름의 순서를 $r_1, r_2, \cdots, r_n$ 이라 했을 때, 답은 $r_1 + \sum_{i = 2}^{n}{2\sqrt{r_{i-1}\times r_i}} + r_n$ 이 된다. 이제 우리는 주어진 반지름을 적당히 섞어서 위 식을 최소화해야 한다. 일반성을 잃지 않고 주어진 수열은 정렬되어 있다고 하자.&lt;/p&gt;&lt;p&gt;근호가 들어가니 &lt;del&gt;찾고 싶은 성질이&lt;/del&gt; 찾을 수 있는 성질이 보이지 않는다. 일단은 짜증나는 근호를 한번 빼 보긴 하자. 답을 $ \sum_{i = 2}^{n}{(2r_{i-1}\times r_i)}$ 라고 하자. 네 실수 $a \leq b \leq c \leq d$ 에 대해 $ab + cd \geq ac + bd$ 이기 때문에, 이 때의 답은 대충 $r_1, r_n, r_2, r_{n-1} \cdots, r_{n/2}$ 과 같이 큰 수와 작은 수를 반복하는 형태를 띔을 알 수 있다. 조금 더 구체적으로 들어가면 $r_1, r_n, r_3, r_{n-2}, \cdots, r_{n/2}, \cdots, r_{n-3}, r_4, r_{n-1}, r_2$ 와 같은 식으로 쓸 수도 있겠다. 이런 식의 construction이 조금 더 작은 답을 준다. &lt;/p&gt;&lt;p&gt;직감적으로는 대충 위와 같은 식이 근호가 있는 상황에서도 큰 답을 줄 것 같으나, 증명을 하라 그러면.. 아이고. 심지어 4로 나눈 나머지에 따라서 케이스가 갈리는 저 더러운 패턴이 정확한지조차도 의심된다. 하지만 스코어보드에서 풀려 있으니, 답은 쉬운 곳에 있다고 생각해 보자. 랜덤 데이터에 대해서 백트래킹을 돌려보면, 위에서 나온 construction과 매우 유사한 패턴만이 답으로 출력된다. 이 패턴이 답을 만들어 내는 유일한 경우의 수일까? 대회에서 AC를 받은 팀들과, &lt;a href=&quot;http://jocg.org/index.php/jocg/article/view/361&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;이 논문&lt;/a&gt;에 따르면 (Theorem 6) 그렇다고 한다. 논문의 증명은 읽어보지 않았기 때문에 더 이상의 자세한 설명은 생략하고, 정확한 패턴은 직접 백트래킹을 돌려서 찾아보거나 논문을 읽어보도록 하자.&lt;br /&gt;&lt;/p&gt;&lt;p&gt;여담으로, 제약 조건이 없는 케이스는 &lt;a href=&quot;https://www.acmicpc.net/problem/13433&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;BOJ에도 있는 잘 알려진 문제이다&lt;/a&gt;. 해당 문제는 NP-complete인데, 이 문제에 대한 4/3-approximation 알고리즘이 있다고 한다. 관심이 있다면 위 논문을 읽어 보는 것도 좋을 것 같다.&lt;/p&gt;

&lt;h4&gt;I. Square Root (★★★★★)&lt;/h4&gt;
&lt;p&gt;Bottom-up으로, 트리를 리프에서 루트로 순서대로 만들어 나가는 전략을 취한다. 일단. 충분히 큰 rooted tree에서 트리의 리프를 순서대로 발견하는 방법을 생각해 보자. 여기서 &quot;인접하다&quot; 라고 함은 트리 상의 거리가 2 이하임을 뜻한다. 즉 이는 &lt;strong&gt;자신을 포함한다.&lt;/strong&gt; 어떠한 정점 $v$ 에 대해서 $v$ 와 인접한 정점 집합을 $N(v)$ 라 표현한다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Case 1: $|N(v)| = 3$ 인 정점이 존재한다. 트리가 존재한다면, $v$는 리프이고, $v$의 부모의 차수가 2일 것이다. 이 정점을 제거하고 계속 귀납적으로 진행한다.&lt;/li&gt;
&lt;li&gt;Case 2: 그런 거 없다. 이는 트리 상에 존재하는 모든 리프의 부모의 차수가 3 이상임을 뜻한다. 이 중 가장 깊이가 큰 리프를 한번 보자. 이 리프의 부모에는 여러 개의 리프들이 달려 있을 것이며, 이 리프들은 모두 인접한 정점들의 집합이 동일하다는 성질을 가진다. 그렇다면, $N(v)$가 동일한 정점들은 모두 하나의 부모를 공유하는 리프일까? 트리가 충분히 크다는 가정하에 그렇다. 고로, $N(v)$ 가 동일한 정점 집합을 아무거나 찾은 후, 한꺼번에 제거해 주면 된다. 트리라면 무조건 저러한 집합이 존재한다.&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;위 가정들은 트리가 대부분의 인자에 대해서 충분히 큰 값을 가지고 있음을 가정하니, 현실적인 경우에서 발생하는 degenerate case를 전혀 고려하지 못한다. 엄밀하게 보정하면, &lt;strong&gt;트리의 지름이 4 이상일 때&lt;/strong&gt; 항상 저 둘 중 한 경우가 만족함을 알 수 있다. 여기서 대략 알고리즘의 outline을 잡을 수 있다. 트리의 지름이 4 이상이라면, 임의의 리프(들)을 잡아서 제거하고, 지름이 3 이하일 때는 예외 처리로 일일이 트리를 구한 후, 이 둘을 적당히 합쳐서 트리를 찾는 것이다. 이 과정 중에서 이상한 것이 하나라도 있거나, 만든 트리의 제곱을 찾았을 때 이것이 입력과 매치가 되지 않는다면, 주어진 그래프는 Tree Square가 아니다.&lt;/p&gt;&lt;p&gt;트리의 지름이 3 이하인 경우의 예외 처리는 다음과 같이 진행하면 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;트리의 지름이 1인 경우는 자명하다. &lt;/li&gt;
&lt;li&gt;트리의 지름이 2인 경우는 성게(star graph)밖에 없다. 이 경우는 입력이 완전 그래프일 경우 발생한다. &lt;/li&gt;
&lt;li&gt;트리의 지름이 3인 경우는, 두 정점을 잇는 에지 하나와, 이 두 정점에 연결된 여러 개의 정점과 같은 입력이다 (즉, 성게 2개가 간선으로 붙어 있음). 이 경우 직접 연결되어 있지 않은 임의의 두 정점 쌍 $u, v$ 를 잡는다. $u$와 인접하지 않은 모든 정점을 $S_1$, $v$와 인접하지 않은 모든 정점을 $S_2$ 라 하자. 남은 두 정점은 간선을 이루는데, 두 정점의 집합이 같기 때문에 이를 분리할 수 있는 방법이 없다. 고로 트리를 둘 다 시도해본 후, 제곱이 입력인 트리가 있으면 그거를 출력하고, 없으면 Tree Square가 아니라고 하면 된다.&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;이제 전체 알고리즘으로 돌아오자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;지름이 1, 2인 경우 입력 단에서 잘라준다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;지름이 4 이상일 때까지, 리프를 반복적으로 떼어 나간다, 그리고 그 순서를 관리한다. 이 과정에서 정점의 개수는 확실히 감소하고, 지름의 길이는 1 감소하거나 감소하지 않는다. 고로, 최종적으로 지름이 3인 트리가 남을 것이다. 이 때, 지름이 3인지 아닌지는, $N(v) = V(G)​$ 인 정점의 개수로 판별할 수 있다. 이것이 2개 이상이면 지름이 3 이고, 아니면 지름이 4 이상이다.  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;지름이 3일 경우, 위에 있는 예외처리로 $S_1, S_2$ 를 찾는다. 이들을 트리에서 순서대로 &quot;떼어준다&quot;. 마지막 두 정점 $v_1, v_2$의 순서는 둘 다 시도해 본다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;지름이 3일 경우로 최후에 남았던 서브트리는 그 구성을 전부 알고 있으나 (정확히는 시도해 볼 구성이 2개밖에 없으나) 그 바깥에 있는 정점들에 대해서는 알고 있는 내용이 없다. 이들에 대해 두가지 case가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Case 1. $\{v_1, v_2\} \subset N(v)$. 그렇다면 $v$ 는 $v_1, v_2$ 중 하나와 인접하다. $S_1, S_2$ 중 어느 셋과 인접하지 않은지를 토대로 붙여주면 된다.&lt;/li&gt;
&lt;li&gt;Case 2. 그렇지 않다. 바깥에 있는 정점들을 뗀 sequence를 우리는 갖고 있으니, 여기에 $S_1, S_2, u, v$ 를 순서대로 추가하자. 루트를 $v$라고 하면, 우리는 리프에서 루트로 bottom-up으로 올라온 정점의 sequence를 알아낼 수 있다. Case 1을 처리했으니 루트에서 $v$로의 거리가 2 이상이다. 고로 부모의 부모가 잘 정의된다. $N(v)$를 보자. $N(v)$의 원소들 중 sequence에서 가장 마지막에 등장하는 것은 부모의 부모이고, 그 다음으로 등장하는 것은 부모이다. 고로, $N(v)$ 를 sequence에서의 등장 순서대로 정렬한 후 뒤에서 두번째 원소를 부모로 지정하면 이 노드의 부모를 알 수 있고, 이 정보로 충분하다.&lt;/li&gt;

&lt;/ul&gt;
&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;지금 돌아보면 $\{v_1, v_2\} \subset N(V)$ 인 케이스를 처리 안 해서 WA를 받았던 거 같다. 아무튼 이렇게 하면 다항 시간 알고리즘을 유도할 수 있다. 입력 제한이 크기 때문에 이 알고리즘은 시간 초과를 받는다 (허허...).&lt;/p&gt;&lt;p&gt;마지막으로 필요한 것은 바로 위 연산들을 빠르게 진행하는 것이다. 특히 집합의 동일성에 대해서 여러 가지 연산을 해야 하는데, 이 때 가장 좋은 방법은 Hash를 사용하는 것이라고 생각한다. 랜덤한 64비트 정수 $H_1, H_2, \cdots, H_n$ 을 생성하고, 어떠한 집합의 hash를 이 집합 내부 원소의 $H_i$ 값 XOR로 정의한다. 집합이 같은지를 판별하는 것은 단순 비교로 $O(1)$ 에 가능하다. 삽입 삭제는 단순 비트 연산이다. 이제, 이들 중 중복된 쌍을 찾고, 집합 크기 3인 임의의 원소를 찾는 등의 연산은 dictionary 자료 구조 (set / map)을 많~~~이 만들면 각각 $O(\log N)$ 정도에 가능하다. 시간 복잡도는 $O(M\log N)$ 이다. 정답을 받은 풀이가 아니니, 풀이에 틀린 부분이 있다면 지적을 매우 환영한다.&lt;/p&gt;

&lt;h4&gt;H. Simple Polygon (★★★★★)&lt;/h4&gt;
&lt;p&gt;준비중.&lt;/p&gt;</description>
<category>공부</category>
<author>구사과</author>
<guid>https://koosaga.com/220</guid>
<comments>https://koosaga.com/220#entry220comment</comments>
<pubDate>Tue, 06 Nov 2018 21:22:48 +0900</pubDate>
</item>
<item>
<title>2018.11.02 problem solving</title>
<link>https://koosaga.com/219</link>
<description>&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width initial-scale=1&quot;&gt;
&lt;title&gt;&lt;/title&gt;
&lt;p&gt;리저널 전 연습 기록을 간단하게 적는다. 정말 간단하고 부실하게 적을 예정이다. &lt;/p&gt;
&lt;h3&gt;10/23 화요일&lt;/h3&gt;&lt;p&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99A204475BDF07742F&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2018-11-04 오후 11.23.22.png&quot; height=&quot;511&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;NEERC Southern Subregional 2018을 돌았다. 12/13으로 만족스러웠다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;H는 처음 보고 복잡하게 생각했으나 알고 보니 쉬운 문제였다. &lt;/li&gt;
&lt;li&gt;J는 재밌는 냅색 문제였다. &lt;/li&gt;
&lt;li&gt;I는 쉬운 매칭인데 우리가 무식해서 엄청 돌아갔다. &lt;/li&gt;
&lt;li&gt;L은 못 풀겠어서 답이 2 이하라고 찍고 gaussian elimination을 돌렸다. 다행이도 맞았다. 알고보니 내가 옛날에 풀었던 POI (&lt;a href=&quot;https://www.acmicpc.net/problem/1910&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Two Parties&lt;/a&gt;) 였는데 대회 중에는 전혀 눈치 못챘다. 일찍 슥삭할 수도 있었는데 매우 아쉬웠다. &lt;/li&gt;
&lt;li&gt;M은 모르겠다. &lt;/li&gt;

&lt;/ul&gt;
&lt;h3&gt;10/24 수요일&lt;/h3&gt;&lt;p&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/993F7E465BDF07833E&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2018-11-04 오후 11.24.37.png&quot; height=&quot;511&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;기하 연습을 했다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A는 제한을 보고 당연히 N^3일 줄 알았는데 안 적혀있는 T가 매우 많았다. 그래서 TLE를 많이 받았다. 화가 났다. &lt;/li&gt;
&lt;li&gt;I는 문제를 뒤집어서 생각하면 보기보다 쉬웠다. &lt;/li&gt;
&lt;li&gt;H는 대회 끝나고 15초 뒤에 맞았다. 또 화가 났다. 그래도 dual graph 구성 + segment intersection 류 스윕을 짜는데 자신감이 생겼다. &lt;/li&gt;

&lt;/ul&gt;
&lt;h3&gt;10/26 금요일&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99BDA0505BDF07A00F&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2018-11-04 오후 11.25.21.png&quot; height=&quot;511&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Asia Tokyo Regional 2014을 돌았다. 8/11의 성적을 받았다. 난 잘한 거 같은데 사람들이 나보다 더 잘해서 성적이 낮았다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A: N^2를 짰다. 짜는 데 좀 헷갈렸다. &lt;/li&gt;
&lt;li&gt;F: &lt;a href=&quot;https://en.wikipedia.org/wiki/There_is_no_alternative&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;There is no alternative&lt;/a&gt;. MlogM에 절선을 짜는 게 제일 빠를 것 같아서 그렇게 했다. &lt;/li&gt;
&lt;li&gt;D: 미적분 + 물리는 앞으로 수찬이가 담당하기로 했다. &lt;/li&gt;
&lt;li&gt;G: 딱 떠오른 건 로그제곱이었으나 TLE 날 것 같아서 로그 생각하고 짰다. 근데 로그제곱이 잘 되는 거 같다.  &lt;/li&gt;
&lt;li&gt;I: 아주 재밌게 푼 문제. 답에 대해서 이분 탐색을 하면 (다른 사람들 코드를 보니 필요 없는 것 같지만) 두개의 추가 인자가 들어가는 boolean dp가 나온다. 게임에 대한 관찰을 더하면, 큰 쪽 인자에 대해서 답이 모노톤함을 알 수 있다. 이 구간을 반환값으로 빼주면 simple dp. &lt;/li&gt;
&lt;li&gt;H: pole을 원, 로봇을 점으로 뒤집어 주자. 로봇의 움직임은 원호를 따라가거나 두 원의 접선을 타고 가거나, 둘 중 하나이다. (엄밀하게 증명하라면 모르겠다.) 그렇게 하면 고려해야 할 점이 전체 평면에서 별로 없어서, 이들로 visibility graph를 만든 후 다익스트라. 구현은 고통스러운 기하였고, 실제로 맞기까지 아주 힘들었다. 대회 시간 안에 풀지 못했고 예제를 매우 열심히 디버깅해서 겨우 AC. 삼각함수 실수였고 3글자만 고치면 됐었다. 그 3글자를 찾을 수 없는 게 문제지 ㅠㅠ 그래도 풀고 나니 기하 자신감이 조금 생겼다. &lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;대회 중에는 H 때문에 시간이 밀려서 JK를 시도할 수 없었다. K의 정해를 보고, 어렵지 않은 풀이를 생각한 후 그걸 가능한 가장 복잡한 방법으로 꼬아서 낸 문제라는 생각이 들었다. &lt;/p&gt;
&lt;h3&gt;10/27 토요일&lt;/h3&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99FD8D445BDF07AD2A&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2018-11-04 오후 11.26.24.png&quot; height=&quot;505&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;NCPC 2018을 돌았다. 10/11의 성적을 받았다. 적게 풀린 문제들인 A F G 에 대해서 적어보았다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;G는 보자마자 Vizing임을 깨달았다. 그래서 기분이 좋지 않았다. 팀노트에 비징이 없기에 풀 수 없었다. 그래프가 특수해서 construction이 있을 법도 하다 느꼈고, 실제로도 있었으나, 대회 도중에 다른 거 대신 하는 것이 좋은 선택이 아니라고 생각했다.&lt;/li&gt;
&lt;li&gt;F는 기하 문제였다. 직선을 고정시키면 문제를 O(nlogn)에 풀 수 있었다. 좀 갖고 놀다 보니 좌표 압축으로 나온 격자점의 쌍을 다 해보면 될 거 같았고 O(n^5logn) 알고리즘을 찾았다. 근데 WA. 그렇게 맞왜틀을 하다가 반례를 찾았다. 한 꼭지점을 지나는 직선이 있을 수 있다는 것이다. 이 직선의 후보가 n^3개인데, 여기서 문제점은 이 직선의 후보를 안다고 직선을 specify하는 게 쉽지 않다는 것이다. 다행이도 미적분 담당 수찬이가 closed form을 찾아줘서 이것도 성공. 근데 TLE. n &amp;lt;= 15라 예상도 못했는데 뭔가 느린 것 같았다. 그래서 그냥 직선을 random shuffle한 후 1.9초까지 돌려보는 타임커팅을 냈고 AC. 나중에 다시 생각해 보니까 좌표압축 격자점 쌍을 볼 필요가 없이 주어진 4n개의 점만 해주면 돼서 후보가 n^3개였다. &lt;/li&gt;
&lt;li&gt;A는 그리디한 관찰을 하고 냅색이 된다는 믿음을 가지면 된다. 결론적으로 10^8 단위에서 냅색을 시키는 구데기 문제였다. &lt;/li&gt;

&lt;/ul&gt;
&lt;h3&gt;10/28 일요일&lt;/h3&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9908294C5BDF07D815&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2018-11-04 오후 11.28.52.png&quot; height=&quot;511&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Asia Tsukuba Regional 2017을 돌았다. 2014를 잘 못해서 기대 안했는데 무려 10/11을 했다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E는 간단한 그리디를 생각했는데 틀린 알고리즘이었다. 그래서 말릴 뻔했다. 다행이도 그리디의 관찰을 사용한 n^2 dp 풀이가 있었고, monotone queue를 써서 한 항을 빠르게 구하면 해결. &lt;/li&gt;
&lt;li&gt;J는 내가 안 풀었는데 좋은 문제. 가장 깔끔한 해석은 이것이라고 생각한다. 같다는 relation을 그래프로 이어주자. 한쪽 구간은 겹치지 않으며 이 구간에서 왼쪽에 있는 수로 답이 이어진다. 즉, 한 수에 연결되어 있는 여러 relation을 고려했을 때 왼쪽의 수를 specify하는 relation은 하나밖에 없다. outdegree가 최대 1인 사이클 없는 방향 그래프이다. 트리의 모습을 띈다. 해당 트리의 루트의 위치를 O(구간 갯수)에 구할 수 있다. union find와 비슷하게 루트에 대해서만 정보들을 관리해주면 전체적인 정보를 전부 유지할 수 있다. 위치에 대한 canonical representation을 찾는다는 것이 풀이의 서술 방식이었다. 좋은 표현이다. &lt;/li&gt;
&lt;li&gt;K는 내가 풀었고 좋은 문제. 사이클에 무조건 들어가는 백엣지 set을 고정시키고 생각해보자. 여기에 더해서 simple cycle을 만들 수 있는 트리 간선 subset을 고르는 문제이다. degree 2를 맞춰줘야 하니까, 이제 리프에 대해서 귀납적으로, 쓸모 있는 간선인지 아닌지를 판별할 수 있다. 이를 구현하면 O(N2^16). 트리 압축테크닉을 써서 최적화하면 O(16*2^16). ontak 2015 lampy 문제가 생각났다. 아이디어의 방향성이 달라서 그 문제보다는 구현량이 훨씬 적다.  &lt;/li&gt;
&lt;li&gt;D 문제는 점을 두개 빼서 남은 점의 convex hull perimeter를 최소화하는 문제. 옛날 경기과고 수행평가에 하나 빼서 넓이 최소화 하는 문제를 출제한 적이 있었다. (&lt;a href=&quot;https://www.acmicpc.net/problem/11798&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Stop Making Sense&lt;/a&gt;) 그래서 그 문제의 풀이는 익숙했다. 두개 뺀 경우에서 그 풀이를 그대로 적용하면 N^2일 것처럼 보인다. 하나의 점을 제거하면 여러 점이 컨벡스 헐에 추가될 수 있기 때문이다. 하지만 새로 추가된 점에 대해서만 같은 루틴을 사용하면 NlogN 정도에 된다. 안 될것 같지만 계산해 보면 그랬고 좀 놀라웠다. 실제 구현은 복잡하다. 안 쓴 케이스들이 꽤 있고 모두 서로 다른 코드를 써야 하기 때문이다. 하지만 짜면 매우 뿌듯하다. 구현을 매우 강력히 추천하는 문제이다. &lt;/li&gt;
&lt;li&gt;H 매우 어렵다. 풀이 봤는데 전혀 이해 안감... 공부해야 한다. &lt;/li&gt;

&lt;/ul&gt;
&lt;h3&gt;10/30 화요일&lt;/h3&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99BB8B435BDF07E508&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2018-11-04 오후 11.31.57.png&quot; height=&quot;511&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Northern Subregional 2017을 돌았다.&lt;/p&gt;&lt;p&gt;D: 민규가 굉장히 그럴듯한 그리디를 짜고 틀렸다. 내가 봐도 맞는 거 같은데 왜 틀린지 모르겠다. ㅋㅋ&lt;/p&gt;&lt;p&gt;E: 좋은 그리디 문제. 그래프로 환원하면 쉽다. &lt;/p&gt;&lt;p&gt;F: 난 손 안 댔는데 우리 팀이 많이 말렸고(디스크립션을 한 두번 정도 잘못 읽음) 꽤 많은 시간을 넣었지만 끝까지 풀지 못했다. 그리고 끝난 후 15분 뒤에 풀었다. &lt;/p&gt;&lt;p&gt;G: 내가 손을 댔고 말아먹었다. 민규가 빠르게 풀이를 찾아서 구현했는데, BCC 구현을 묘하게 잘못했고, 긴 코드를 디버깅하는 과정이 쉽지 않았다. 결국 찾는데 한시간 반. BCC 코드를 잘 이해하지 못하면서 너무 성급하게 응용한 게 문제. &lt;/p&gt;&lt;p&gt;J: 양수/음수 항을 떼어주면 2차원 기하 문제 비슷하게 된다. 구간에 있는 점을 고정된 벡터만큼 이동시키고, $ax+by$를 최소화하는 값을 구한다. 이는 몹시 어려운 문제지만, 제한이 작아서, 대충 $O(n^{1.5}\log n)$ 버킷을 짜면 된다. 하지만 FG때문에 짤 시간이 없었다. 이건 끝나고 1시간 뒤에 풀었다. &lt;/p&gt;
&lt;h3&gt;10/31 수요일&lt;/h3&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99665B435BDF07F136&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2018-11-04 오후 11.33.23.png&quot; height=&quot;511&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;기하 연습을 돌았다.&lt;/p&gt;&lt;p&gt;A: 아기 석환  &lt;/p&gt;&lt;p&gt;G: 비밀 요원과 비슷한 segment intersection 류 스윕. 제약조건이 이것 저것 붙어 있어서 쉽게 풀 수 있다.&lt;/p&gt;&lt;p&gt;I: 결론적으로, 직선과 convex polygon이 strict하게 교차하는 지를 판별하는 문제로 환원할 수 있다. 내가 생각했던 방법은 strictly가 아니면 쉬우나 그렇지 않으면 매우 복잡해져서 여러 케이스 처리가 필요했다. 결국 WA를 많이 받고 풀지 못했으나 종원이형이 아주 간단한 방법을 소개하였다. Convex polygon에서 임의의 변을 잡고, 해당 변의 시계방향에 두 직선 점이 모두 있는지를 판별한다. 만약 그렇다면 무조건 교차하지 않는다. 이를 모든 변에 대해서 하자. 이제 반대로, polygon이 선분이 이루는 직선을 기준으로 한 사이드에 전부 있는지를 판별하자. 그렇다면 no, 아니면 yes. 이 알고리즘을 그대로 응용해서, 두 convex polygon이 strict하게 교차하는지도 쉽게 판별할 수 있다 ($O((n+m)\log(n+m))$에!)&lt;/p&gt;&lt;p&gt;K: 푼 줄 알았는데 사풀이었다. 그래서 망함.&lt;/p&gt;

&lt;h3&gt;11/2 금요일&lt;/h3&gt;
&lt;h4&gt;오전: Jakarta 2017&lt;/h4&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99F1134E5BDF080C02&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2018-11-04 오후 11.33.55.png&quot; height=&quot;511&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;카페에서 했는데 엄청나게 혼란스러웠다. 전날에 다같이 술을 좀 많이 마시고 아침에 카페에서 했는데, 프린터 없고 스코어보드도 없고 너무 많은 것이 없었다 (...) 그래서 문제 푼 순서도 엉망이었고, 초반에 별 별 멘탈 나가는 일이 많이 있었다. 극적으로 후반에 복구해서 11/12 1866min으로 마무리. 생각보다 대회 스코어보드가 많이 낮아서 기분이 좋았다 (?)&lt;/p&gt;&lt;p&gt;문제는 전반적으로 무난했으나 구데기성이 좀 있었다. 월파 생각났다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B: 처음에 읽고 Dynamic Shortest Path인 줄 알았다. 그리고 충격에 빠졌다. 물론 완전히 잘못 읽은 거였음. ㅠㅠ.&lt;/li&gt;&lt;li&gt;C: 민규가 옆에서 화를 많이 냈다.&lt;/li&gt;&lt;li&gt;E: 하노이탑과 비슷한 관찰을 하면 단순 구현... 이라고 생각할 수 있으나 문제에서 C를 준 방식 때문에 sequence가 유일하지 않다. 다행이도 여기에 DP를 적용할 수 있다. 그 이후 몇가지 (왜 시키는지 모르겠는) 구현을 더하면 AC&lt;/li&gt;
&lt;li&gt;G: BOI 2016 Park와 같은 간단한 dual graph 문제라고 착각할 수 있으나 현실은 빡센 기하. 가장 힘든 점은 실수 오차 tolerance가 0이라는 것이다  &lt;/li&gt;
&lt;li&gt;H: 트리 압축 (요즘은 사골)&lt;/li&gt;

&lt;/ul&gt;
&lt;h4&gt;오후: OnionPringles + jihoon + koosaga 연습&lt;/h4&gt;&lt;div&gt;&lt;p&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9990E54E5BDF084315&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2018-11-04 오후 11.34.04.png&quot; height=&quot;511&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;A: Store-Keeper라는 문제가 기회의 땅에 있었다. 당시 제한이 100 * 100이었고, naive한 풀이가 n^4인데, 될지 안 될지 모르겠어서 선형 시간에 풀었던 문제이다. 그 기회의 땅 문제 제한을 1500 * 1500으로 늘리고 쿼리를 추가한게 이 버전이다. 그래서 그냥 당시 짠 선형 시간 코드를 복붙했다. 일반적인 그래프 탐색 알고리즘을 사용하면 쿼리 때문에 문제가 특별히 어려워지는 일은 없다.&lt;/li&gt;
&lt;li&gt;B: 선물을 받는 사람들은 입력에서 prefix를 이룬다. prefix의 마지막 원소가 선물을 받으려면, 그 원소 앞에 prefix 맨 뒤로 가는 친구가 최소 1명 있어야 한다. 아니면 안 밀려서 선물을 받을 수가 없다. 그 다음에 맨 뒤 혹은 그 앞에 가는 친구가 (아까 포함) 2명 있어야 한다. 아니면 그 앞으로 못 간다... 이를 반복하면 필요 조건이 나온다. 그리고 이것이 충분하다. 저건 정렬로 체크 가능하고. Prefix 길이에 대해서 binary search하면 해결. 로그 제곱인데 아마 선형 시간도 될 듯.&lt;/li&gt;
&lt;li&gt;D: 두 조건을 모두 만족하는 영역이 각 row마다 interval의 형태를 띈다. 이를 관찰하면 간단한 N^2 풀이를 찾을 수 있다. 시작점과 끝점이 모두 단조적이기 때문에 부분합을 사용해 최적화 할 수 있다. 쉬운 문제였으나 오래 걸렸다. &lt;/li&gt;
&lt;li&gt;E: 팬이에요&lt;/li&gt;
&lt;li&gt;FG: F는 쉬운 트리DP고, G는 쉬운 트리dp를 n번 하면 n^2라 시간 초과이다. 난 잘 모르겠다. ㅠ&lt;/li&gt;
&lt;li&gt;HI: 주어진 제약 조건을 Min Cut의 형태로 formulation할 수 있다. A_i 가 양수 / 음수인 건 적당한 수식 전개로 처리. &lt;/li&gt;

&lt;/ul&gt;&lt;h3&gt;11/3 토요일&lt;/h3&gt;&lt;h4&gt;오전: 서울 리저널 2018&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://koosaga.com/220&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;더 이상의 자세한 설명은 생략한다.&lt;/a&gt;&lt;br /&gt;&lt;/p&gt;&lt;h4&gt;새벽: ainta와 Codechef Snackdown Elimination&lt;/h4&gt;&lt;div&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99DD86485BDF085315&quot; filemime=&quot;image/jpeg&quot; filename=&quot;스크린샷 2018-11-04 오후 11.34.31.png&quot; height=&quot;511&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;Nearest Angle: 빡구대기문제&lt;/li&gt;&lt;li&gt;Strange Transform: 편의상 A를 무한 배열로 생각하자. 간단한 귀납법으로 $f^{2^k}(A)_x = A_x$ XOR $A_{x + 2^k}$ 임을 보일 수 있다. 이를 사용하면 $O(NQ)$ 풀이를 유도할 수 있음. 대략 $[X, N]$ 구간을 돌면서 $i$ 가 $K$의 submask인 모든 $A[i + X]$를 XOR하는 문제임을 알아낼 수 있다. 이를 sqrt decomposition을 통해서 줄일 수 있다. 모든 $X \leq N, K &amp;lt; 2^8$ 에 대해서 $i$ 가 $K$의 submask인 모든 $A[i + X]$의 XOR을 전처리해두자. DP 비슷하게 할 수 있다. 쿼리가 들어올 때마다 모든 submask를 나열할 필요는 없고, 마지막 8비트는 켜 놓고 나머지 10비트에 대한 submask만 나열해주면 된다. 그러면 1024번의 연산으로 해결. 시간 복잡도는 $O(QN^{0.5})$.&lt;/li&gt;&lt;li&gt;Painting Tree: DP를 통해서 해당 트리에 $K$개의 Disjoint Path를 놓는 경우의 수 $F_k$ 를 계산할 수 있다 (단순히 하면 $O(N^3)$ 이지만 &lt;a href=&quot;https://www.acmicpc.net/problem/13120&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;이 문제의 풀이와&lt;/a&gt; 같은 방법을 통해서 $O(N^2)$로 줄일 수 있음). 그러면 모든 가능한 상태 중 $K$개의 Disjoint Path까지 성공적으로 놓은 상태의 개수는 $F_k \times k!$ 임을 알 수 있다. 그렇다면 우리가 $K$ 이상의 답을 받을 확률은 $F_k \times k! \times (\frac{1}{\binom{N+1}{2}})^k$ 이다. 기댓값의 선형성에 의해 답은 이러한 확률들의 합이다. 풀이를 듣고 보면 어려운 내용이 하나도 없으나, 의외로 생각하기 굉장히 까다로운 신기한 문제이다. &lt;br /&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>공부</category>
<author>구사과</author>
<guid>https://koosaga.com/219</guid>
<comments>https://koosaga.com/219#entry219comment</comments>
<pubDate>Fri, 02 Nov 2018 23:51:56 +0900</pubDate>
</item>
<item>
<title>2018.10.16 problem solving</title>
<link>https://koosaga.com/218</link>
<description>&lt;p&gt;최근 카이스트&amp;nbsp;대회 기출 문제가 &lt;a href=&quot;http://run.kaist.ac.kr/contest&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;run.kaist.ac.kr/contest&lt;/a&gt;&amp;nbsp;에 전부 올라와 있습니다. 테스트 데이터나 풀이를 전부 공개하였으니 많은 관심 부탁드립니다! 맨 아래 과거 기출 문제 / Past Problemset 섹션에 모두 올라와 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/16186&quot;&gt;KAIST Contest 2018. Fractions&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;편의상, $A = C = 1$ 이라고 가정합시다. 이렇게 될 경우 $x, y$의 상한만이 존재하고 하한은 존재하지 않습니다. 이 가정을 하더라도 문제를 여전히 해결할 수 있는데, 만약에 위 문제를 해결하는 함수 $f(B, D)$ 가 존재한다면, 우리가 출력해야 하는 답은 포함-배제의 원리를 사용하여 $f(B, D) - f(A-1, D) - f(B, C-1) + f(A-1, C-1)$ 로 계산할 수 있기 때문입니다. (굳이 이렇게 생각하지 않아도 문제를 충분히 해결할 수 있습니다. 하지만 이러한 관점은 여러 문제들을 추상화시키는 데 매우 큰 도움을 주는 경우가 많기 때문에, 이해하고 넘어 가는 것을 추천합니다.)&lt;/p&gt;&lt;p&gt;이제, 문제를 거꾸로 생각해 봅시다. 분모와 분자 합이 1000 미만인 기약분수들을 모두 순회하고, 주어진 범위 안에서, 약분을 했을 때 해당 분모 / 분자가 나오는 분수의 개수를 모두 세어 줍시다. $\frac{p}{q}$ 라는 기약분수에 대해서, 그러한 분수는 $\frac{pN}{qN}$ 의 꼴이며, 고로    $pN \leq B, qN \leq D$ 를 모두 만족합니다.  $pN \leq B, qN \leq D$ 를 모두 만족하는 자연수의 개수는 단순 나눗셈으로 세어 줄 수 있습니다. &lt;/p&gt;&lt;p&gt;어떠한 분수가 기약분수인지를 판별하는 것은, 유클리드 알고리즘으로 최대공약수를 구한 후, 1인지 아닌지를 계산해 주면 됩니다.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;https://cf17-relay-open.contest.atcoder.jp/tasks/relay2_e&quot;&gt;CF 2017 E. White And Blue&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;선거운동을 한 도시의 집합을 $S$ 라고 합시다. ($S$ 는 $\{1, 2, \cdots, n\}$의 부분 집합입니다, 예를 들어, $S = \{1, 3, 7\}$이면 1, 3, 7번 도시에서 선거를 진행합니다.) 이제 득표율이 $P$ 퍼센트 이상이 된다는 조건을 다음과 같은 식으로 쓸 수 있습니다. &lt;/p&gt;&lt;p&gt;$\frac{\sum_{i\in S}{a_i}}{\sum_{i\in S}{a_i} + \sum_{i\notin S}{b_i}} \geq \frac{P}{100}$   &lt;/p&gt;&lt;p&gt;전개하면,&lt;/p&gt;&lt;p&gt;$100(\sum_{i\in S}{a_i}) \geq P(\sum_{i \in S}{a_i} + \sum_{i\notin S}{b_i})$&lt;/p&gt;&lt;p&gt;$100(\sum_{i\in S}{a_i}) \geq P(\sum_{i \in S}{(a_i - b_i)} + \sum_{i=1}^{n}{b_i})$&lt;/p&gt;&lt;p&gt;$(100-P)(\sum_{i\in S}{a_i}) + P(\sum_{i\in S}{b_i}) \geq P(\sum_{i=1}^{n}{b_i})$&lt;/p&gt;&lt;p&gt;$\sum_{i\in S}{((100-P)\times a_i + P\times b_i)}  \geq P(\sum_{i=1}^{n}{b_i})$&lt;/p&gt;&lt;p&gt;우변은 선거운동을 어떻게 하든 바꿀 수 없으며, 입력에서 바로 계산할 수 있습니다. 한편으로, 좌변은 부분집합을 어떻게 골랐는지에 따라서 즉시 정해집니다. $f_i = (100-P)\times a_i + P\times b_i$ 라고 정의하면, 문제는 다음과 같이 바뀝니다.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;$N$ 개의 수 $f_1, f_2, \cdots, f_n$ 이 주어졌을 때, 최소한의 수를 골라서 합이 일정한 숫자를 넘게 하여라. “&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;위 문제는, 합이 넘을 때까지 $f_i$ 가 큰 숫자부터 하나씩 고르면 풀 수 있습니다. 고로 $f_i$ 와 $P(\sum_{i=1}^{n}{b_i})$ 를 계산해 놓은 후 정렬 한번에 문제를 해결할 수 있습니다. &lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3&gt;SRM 736 Medium. MinDegreeSubgraph&lt;/h3&gt;
&lt;p&gt;먼저 간단한 정의를 하고 시작합시다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;. 그래프 $G$ 와 정점의 부분 집합 $S \subset&amp;nbsp;V(G)$ 에 대해서, $S$ 에 속하지 않은 모든 정점들을 간선과 함께 지운 그래프를, &lt;strong&gt;유도된&lt;/strong&gt; &lt;strong&gt;부분그래프&lt;/strong&gt; (&lt;strong&gt;Induced subgraph&lt;/strong&gt;) 라고 부른다. 이를 $G[S]$ 라고 표현한다.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Remark&lt;/em&gt;. 부분 그래프에서, 정점을 몇 개 지운 후, 간선을 전혀 지우지 않은 버전입니다. 처음 들어봤다면 알아두는 것이 좋습니다.&lt;/p&gt;&lt;p&gt;첫번째 과정은, k-좋은 그래프의 표현을 단순하게 하는 것입니다. 부분 그래프라고 함은, 정점의 부분 집합을 고른 후, 부분 집합에 걸린 간선들의 부분 집합을 또 한번 고르는 과정으로 표현할 수 있습니다. 어떠한 정점 부분 집합을 골랐을 때, 최소 차수가 k가 되도록 간선을 적절히 제거하려면 어떻게 해야 할 까요? 최소 차수가 이미 k 미만이면 당연히 할 수 없고, k 이상이면, 최소 차수를 가진 점에서 (최소 차수)–k개의 간선을 아무거나 제거해 주면 최소 차수가 k가 됩니다. 이제 k-좋은 그래프의 정의를 아래와 같이 할 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Lemma 1&lt;/strong&gt;. 그래프 $G$가 $k$-좋은 그래프인 것은, 해당 그래프에 정점의 부분 집합 $S \subset V(G)$ 가 존재해서, $G[S]$ 의 최소 차수가     $k$ 이상이라는 것과 동치이다. &lt;/p&gt;&lt;p&gt;위 간단해진 정의를 통해서 쉽게 알 수 있는 사실은, k-좋은 그래프에 어떤 에지를 추가해도 k-좋은 그래프이며, k-좋지 않은 그래프에 어떤 에지를 제거해도 k-좋지 않은 그래프라는 것입니다. 그렇다면, 가장 작은 / 큰 그래프만 구해놓은 후, 마음대로 간선을 제거하거나 추가해서 개수를 m으로 맞춰두면 되니, 결국 다음 두 개의 문제를 해결하면 됩니다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;정점의 개수 $n$에 대해서, 간선의 개수를 가장 적게 쓰는 $k$-좋은 그래프와, 간선의 개수를 가장 많이 쓰는 $k$-좋은 그래프가 아닌 그래프를 찾아라.&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt;먼저, 간선의 개수를 가장 적게 쓰는 $k$-좋은 그래프는 $k+1$ 크기의 완전 그래프입니다. 이보다 적은 $k$-좋은 그래프가 없음을 쉽게 보일 수 있습니다. 고로 $m \geq k(k+1)/2$ 이면 무조건 $k$-좋은 그래프가 존재합니다.&lt;/p&gt;&lt;p&gt;간선의 개수를 가장 많이 쓰는 $k$-좋지 않은 그래프는 조금 더 복잡합니다. 먼저 주어진 그래프가 $k$-좋은 그래프인지를 판별하는 방법을 생각해봅시다. 현재 주어진 그래프에서 차수가 $k$ 미만인 점이 있다면, 해당 점은 절대 부분 그래프를 이룰 수 없습니다. 이러한 점을 지우는 것을 반복하는 단순한 그리디 알고리즘을 사용하면, 판별이 가능합니다.&lt;/p&gt;&lt;p&gt;우리가 원하는 것은, 위 알고리즘이 차수가 $k$ 미만인 점들 (크기가 크면 좋으니, $k-1$ 인 점들) 을 반복적으로 지우다가, 결국에 마지막에 모든 점을 지워버리는 것을 원합니다. 정점 하나를 지울 때 같이 지울 수 있는 간선의 개수는 최대 $min(k-1, |V(G)| - 1)$ 입니다. 고로, $0 + 1 + \cdots + (k-2) + (k-1) + (k-1) + \cdots = (n-k)(k-1) + k(k-1)/2$ 이 해당 그래프가 가질 수 잇는 간선의 최대 개수가 될 것입니다. 위와 같은 최대 개수의 간선을 가지는 그래프를 만드는 것은, 정점 하나에서 출발하여 단순히 과정을 거꾸로 반복하면서, 차수가 $min(k-1, |V(G)| - 1)$ 인 정점을 반복적으로 이어주는 것으로 가능합니다. 고로 이 역시 판별이 가능합니다. $k = 0, k \geq n$ 일 때의 케이스에 유의하십시오.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/15521&quot;&gt;JAG Autumn 2017. Revenge of the Broken Door&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;문제를 해결하기 앞서서 “전략” 이라는 것을 정리하는 것이 좋습니다. 공사중인 도로가 무엇인지 간파했다면 그 순간 취해야 할 전략은 자명합니다. 공사중인 도로를 제외한 그래프에서 $T$로 가는 최단 경로를 찾고, 그 경로로 가면 됩니다. 공사중인 도로가 무엇인지 간파하지 못했다면, 플레이어의 행동은, $S$ 에서 어떠한 결정된 경로를 따라서 움직이다가, 공사중인 도로를 만나게 되면 그 즉시 최단 경로로 이동하는 것입니다. 이 경로를 미리 정해놓으면, 공사중인 도로를 만나지 않은 이상 이 경로를 단순히 따라가다가, 공사중인 경로를 만나면 그 즉시 $T$ 로 가는 최단 경로로 모드를 전환하면 됩니다. &lt;/p&gt;&lt;p&gt;고로, 전략은 $S$에서 시작하는 어떠한 경로로 표현됩니다. 더 나아가서, 그 경로는 유한하고, $T$ 에서 종료합니다. 이 두 사실의 증명은 어렵지 않습니다. &lt;/p&gt;&lt;p&gt;이제 답을 찾는 것은 특정 조건을 최소화하는 $S-T$ 경로를 찾는 것과 사실상 동일합니다. 최적 전략이  $S-T$ 를 잇는 최단 경로 / 두번째 최단 경로라는 가정은 모두 반례가 존재하니, 명확한 풀이를 제시해야 합니다. &lt;/p&gt;&lt;p&gt;어떠한 전략(경로) 가 최악의 경우 소비하게 되는 시간을 계산해 봅시다. 경로를 정했을 경우, 어떠한 전략이 사용하는 시간은 모든 간선 끊김에 대해서 해당 경로가 사용하게 될 시간의 최댓값입니다. 이를 수식으로 표현하면, 어떠한 경로의 소비 시간은:&lt;/p&gt;&lt;p&gt;$max_{e \in E}((P$에서 간선 $e$ 를 만나는 데 걸리는 시간$) + ($해당 위치에서 $e$ 없이 $T$에 가는 최단 경로의 길이$))$&lt;/p&gt;&lt;p&gt;이것은 경로가 고정되었을 때 문제를 해결하기에는 충분하지만, 이것을 최소화하는 경로를 찾는 문제를 풀기에는 복잡한 식입니다. 가장 어려운 점은, 간선 $e$ 를 경로에서 한 번 이상 만날 수 있어서, 그 시간이 하나로 고정되어 있지 않고 여러 수의 최솟값으로 정의된다는 점입니다. 이 문제를 해결하기 위해서는 다음 Lemma가 필요합니다. (증명은 생략합니다.)&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Lemma 1&lt;/strong&gt;. 경로의 길이는, 최악의 경우 해당 경로에서 소비하는 시간보다 짧거나 같다.&lt;/p&gt;&lt;p&gt;이제 위 내용을 다시 돌아봅시다. 우리는 어떠한 경로 $P$가 소비하는 시간을 다시 정리할 수 있습니다. 모든 간선 $(u, v)\in E(G)$에 대해서, &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;만약에 그 간선이 $P$ 와 교점이 없다면 소비 시간은 $P$의 길이와 동일합니다.&lt;/li&gt;
&lt;li&gt;그렇지 않고, $P$와 교점이 하나라면, 일반성을 잃지 않고 그 교점이 $u$라 하였을 때, ($P$에서 $S-u$ 경로 길이) + ($(u, v)$ 없는 그래프에서 $u-T$ 최단 경로의 길이) 라고 정의할 수 있습니다. &lt;/li&gt;
&lt;li&gt;$P$ 를 이루는 간선이라면, 일반성을 잃지 않고 경로에서 $u$ 가 먼저 등장한다고 합시다. 우리는 $e$ 가 끊겼을 때 걸리는 시간을 $max($($P$에서 $S-u$ 경로 길이) + ($(u, v)$ 없는 그래프에서 $u-T$ 최단 경로의 길이), ($P$에서 $S-v$ 경로 길이) + ($(u, v)$ 없는 그래프에서 $v-T$ 최단 경로의 길이)$)$ 라고 할 수 있습니다. $u$가 나오는 항은 자명히 참입니다. $v$가 나오는 항은, 위 답이 $P$의 길이보다 작거나 같음을 관찰할 수 있습니다. 고로 Lemma 1에 의해서 답에 영향을 끼치지 않습니다.&lt;/li&gt;

&lt;/ul&gt;
&lt;p&gt; 이러한 과정을 통해서, 답을 경로가 지나는 각 정점에 대해서 따로 생각할 수 있습니다. &lt;/p&gt;&lt;p&gt;각각의 정점에 대해서 $f(v) = (v$ 에서 임의의 간선이 제거되었을 때 $T$ 에 도달하는 데 걸리는 최소 시간) 이라고 정의합시다.    $f(*)$ 는 모든 간선을 한번씩 제거해 본 후 Dijkstra 알고리즘을 사용하면 $O(M^2\log M)$ 에 찾을 수 있습니다. 이것이 문제를 해결하기에 충분하지는 않지만, 일단 다항 시간으로 복잡도를 줄여냈으니, 현재로서는 $f(*)$ 를 모두 잘 계산했다고 가정하고 여기서 멈춥니다. &lt;/p&gt;&lt;p&gt;우리가 찾는 경로 $P$는, 경로 상에 있는 모든 정점 $w$에 대해서, $dist(w) + f(w)$ 의 최댓값을 최소화해야 합니다. 답에 대한 이분 탐색을 사용해 봅시다. 답이 $X$이하인지를 판별하는 문제를 해결할 때, 우리는 경로 상의 각 정점 $v$에 대해서 $dist(V) \leq X - f(V)$ 를 만족하는 $S-T$ 경로를 찾아야 합니다. 이는 Dijkstra 알고리즘의 간단한 응용이니, 전체 문제를    $O(M\log M\log X)$ 에 해결할 수 있습니다. $T$에서 거꾸로 Dijkstra를 돌리면 $O(M\log M)$ 역시 가능합니다. 이에 대한 설명은 생략합니다.&lt;/p&gt;&lt;p&gt;마지막으로 우리는 $f(v)$를 빠르게 계산하는 방법을 알아봅시다. 정점 $T$에서 Dijkstra를 돌렸을 때,  $T$가 아닌 모든 정점에 대해서 최단 경로를 따라가는 &quot;포인터&quot; 를 생각해 볼 수 있습니다. 이 포인터를 모두 모으면, 최단 경로를 모두 모으는 트리가 생기게 됩니다. 이를 Shortest Path Tree라고 부릅니다. &lt;/p&gt;&lt;p&gt;첫번째로 관찰해야 할 사실은, Shortest Path Tree 밖에 있는 간선을 끊는다고 최단 경로의 길이가 바뀌지 않는다는 것입니다. Shortest Path Tree상에 있는 간선이 보존되는 한 모든 최단 경로가 보존되기 때문입니다. 고로, 끊어봐야 할 간선은 $N-1$ 개 뿐이니 우리의 알고리즘을 $O(MN\log M)$ 으로 최적화 할 수 있습니다.&lt;/p&gt;&lt;p&gt;어떠한 정점 $v$ 와 이 정점의 조상 $parent(v)$ 로 가는 간선이 끊겼다고 합시다. $v$ 에서 찾을 &quot;대안&quot; 최단 경로는, $v$ 에서 시작해서, 서브트리 안에 있는 정점들을 거치다가, $v$의 서브트리 안과 밖을 잇는 간선을 최소 한번 이상 지나서 서브트리를 탈출하고, 이후 여러 정점을 거치다가 최종적으로 $T$에 도달할 것입니다.&lt;/p&gt;&lt;p&gt;이 과정에서, 서브트리를 탈출하는 첫 순간을 주목하면 재미있는 관찰을 할 수 있습니다. 서브트리를 탈출한 에지가 $(p, q)$이고 $p$가 $v$의 서브트리 안에 있다고 합시다. $q$로 나온 순간, 대안 최단 경로는 Shortest Path Tree상에 있는 경로를 따라가지 않을 이유가 없습니다 (끊기지 않았기 때문), 마찬가지로, $v$에서 $p$로 가는 경로는 $T$에서 $p$로 가는 최단 경로의 일부이고 끊기지 않았기 때문에, 이 역시 Shortest Path Tree를 그대로 사용하면 됩니다.&lt;/p&gt;&lt;p&gt;간선 $(p, q)$의 가중치를 $weight(p, q)$, 두 정점의 최단 거리를 $Dist(p, q)$ 라 정의합시다. 서브트리를 탈출할 때 사용한 간선 $(p, q)$를 고정시키면, $p$와 $q$가 서브트리 안밖을 잇는 모든 $v$에 대해서, $parent(v) - v$로 가는 경로를 $weight(p, q) + Dist(T, q) + Dist(T, p) - Dist(T, v)$ 로 대체할 수 있게 됩니다. 이 정보는 한 번의 Dijkstra로 계산할 수 있으니, 이를 모든 간선과 정점 쌍에 대해서 상수 시간에 계산해 주면 시간 복잡도 $O(NM)$에 문제를 해결할 수 있습니다.&lt;/p&gt;&lt;p&gt;마지막으로, $(p, q)$가 대체 경로로 사용될 수 있는 정점들은, $LCA(p, q)$와 $p$를 잇는 경로 상의 정점들이라는 것을 알아낼 수 있습니다. 고로, 모든 $T$가 아닌 정점 $v$에 대해서, 올바른 &quot;탈출 간선&quot;이 가지는 최소의 $Dist(T, q) + Dist(T, p) + weight(p, q)$을 배열 등에 저장해 두면, 결국 문제는&lt;/p&gt;
&lt;ol start=&quot;&quot;&gt;
&lt;li&gt;LCA를 빠르게 계산하고&lt;/li&gt;
&lt;li&gt;어떠한 조상 - 자식 경로에 대해서, 경로 상 간선에 $ans[v] := min(ans[v], X)$ 쿼리를 반복적으로 수행하는&lt;/li&gt;

&lt;/ol&gt;
&lt;p&gt;문제가 됩니다.&lt;/p&gt;&lt;p&gt;첫번째 문제는 잘 알려진 문제로, Sparse Table 알고리즘을 사용해서 해결할 수 있으며, 두 번째 문제는 쿼리를 오프라인으로 X 순으로 정렬한 후, 각 경로에 대해서 Path Compression을 사용해 주면 됩니다. Path Compression에 대한 간략한 정보는 &lt;a href=&quot;http://codeforces.com/blog/entry/21476&quot; target=&quot;_blank&quot; class=&quot;url&quot;&gt;http://codeforces.com/blog/entry/21476&lt;/a&gt; 에서 확인할 수 있습니다.&lt;/p&gt;&lt;p&gt;$f(*)$ 를 효율적으로 구할 수 있으니, 이제 모든 문제가 $O(M\log M\log X)$ 에 해결됩니다. 수고하셨습니다. :D&lt;/p&gt;</description>
<category>공부</category>
<author>구사과</author>
<guid>https://koosaga.com/218</guid>
<comments>https://koosaga.com/218#entry218comment</comments>
<pubDate>Tue, 16 Oct 2018 20:43:14 +0900</pubDate>
</item>
<item>
<title>내가 문제풀이를 연습하는 방법</title>
<link>https://koosaga.com/217</link>
<description>&lt;p&gt;(2018.11.07: ICPC 대회 난이도에 별점을 매겼습니다. 사실 제일 중요한 건 난이도인거 같아서 마음에 좀 걸렸는데, 이렇게 하면 조금 더 가시성이 있지 않을까 싶네요.)&lt;/p&gt;
&lt;p&gt;공부하기 싫어서, 제가 평소에 어떻게 연습하는 지에 대해서 간략히 글을 씁니다.&lt;/p&gt;
&lt;p&gt;이 글은 연습 방법론, 예를 들어 하루에 몇 시간씩 하는지 / 풀이는 언제 보는지 / 뭐 먹고 사는지 (...) / Secret Tip이 있는지 (……) 에 대해서는 전혀 언급하지 않습니다. 저러한 내용에 과도하게 걱정하시는 분들이 참 많은데, 별로 안 좋은 습관이라고 딱 잘라 말하겠습니다. 보통 상위권이라고 저런 거에 대단한 철학이 있지는 않습니다. 개인 성격 따라 제각기 하는 방법이 다릅니다. 본인 성격에 맞는 방법을 찾기 위해서는 시행착오 말고는 답이 없으니까 그런 거 걱정할 시간에 문제를 많이 풉시다. &lt;/p&gt;
&lt;p&gt;대신, 이 글은 어디서 공개하는 무슨 무슨 사이트와 무슨 문제들이 좋은지에 대한 정리를 목표로 합니다. 상위권과 하위권에서의 정보 격차라고 하면 이런 정보의 부재가 제일 중요하다고 봅니다. 물론 이것 역시 보통 시행착오를 통해서 알아나가는 것이고 특별한 답은 없습니다. 그래도 아름다움 / 편리함의 기준은 그나마 사람마다 비슷한 편이라, 이 글을 통해서 시행착오를 어느 정도 줄일 수 있겠네요.&lt;/p&gt;
&lt;p&gt;저 혼자 작성한 리스트고 개인적인 취향이 반영되어 있음을 명시해 주세요.&lt;/p&gt;
&lt;h3&gt;Online Contest&lt;/h3&gt;
&lt;p&gt;주기적으로 열리는 온라인 대회는 정기적으로 실력을 점검하고, 경험을 쌓는 데 도움이 되며... 사실 그냥 재미있습니다. 꾸준히 리마인드 될 수 있다는 게 제일 좋은 것 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;강력 추천&lt;/strong&gt; &lt;a href=&quot;http://atcoder.jp&quot;&gt;AtCoder&lt;/a&gt;: 까일 부분이 딱히 없는 아주 좋은 사이트입니다. 문제 수준도 높고 풀이도 항상 제공하고 채점도 잘 됩니다. 문제 수준의 하한이 높다는 점이 특히 강점입니다. 앳코더는 진행 상황을 볼 수 있는 &lt;a href=&quot;https://kenkoooo.com/atcoder/?user=koosaga&quot;&gt;Atcoder Problems&lt;/a&gt; 라는 사이트가 있는데 이게 정말 좋습니다. 나쁜 문제가 별로 없고, 문제 난이도도 다양한 편이라, 세로 줄 하나 잡고 올클 스터디 해도 좋아요.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;추천&lt;/strong&gt; &lt;a href=&quot;https://csacademy.com&quot;&gt;CSAcademy&lt;/a&gt;: 여기도 아주 괜찮습니다. 앳코더의 마이너 열화판.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;추천&lt;/strong&gt; &lt;a href=&quot;https://codeforces.com&quot;&gt;Codeforces&lt;/a&gt;: 툭하면 까이지만 그래도 이만한 사이트가 없습니다. 비합리성이 꽤 있으나 (semi-rated 사건 등), 그래도 2018년 기준으로 문제 수준도 괜찮고 풀이도 다 제공합니다. 특히 (적당히 거른다는 가정 하에) 커뮤니티에 유용한 정보가 꽤 많습니다. &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Topcoder: 요즘 열심히 까이고 있으나 여전히 많이 고평가 되어 있는 사이트입니다. 레드 근처 아니면 할 필요가 없다고 생각합니다. 시간이 짧은 건 좋다면 좋고 나쁘다면 나쁜건데 요즘 탑코더 문제 수준을 보면 장점에 더 가까운듯… 하지만 AtCoder 수준의 좋은 문제들이 가끔 나오는 건 사실입니다. 링크 달고 싶은데 뭘 링크라고 해야 할 지 모르겠네요. 코드포스 눈팅하시면 Topcoder SRM 알림 글이 가끔씩 뜨니까 그거 보고 참가하시면 됩니다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.codechef.com&quot;&gt;Codechef&lt;/a&gt;: 구데기로&amp;nbsp;악명이 높고 실제로도 그렇지만, 최근 롱 챌린지를 읽어보면 약간 저평가 되어 있는 것 같습니다. 문제 수준은 탑코더와 비슷합니다 (가끔 좋은 문제가 나오는 것 포함). 다만 탑코더 대비해서 시간은 훨씬 더 잡아먹습니다. 레드 미만은 할 필요가 없고, Long Challenge 한정 온라인 저지 느낌으로 접근하면 좋은 것 같습니다. 여담으로 롱 챌린지에서는 상위 입상자에게 돈을 주는데, 보통 돈을 받으려면 구데기 MM 문제를 풀어야 합니다. 우웩&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.hackerrank.com/contests&quot;&gt;Hackerrank&lt;/a&gt;: Codechef와 비슷. 여기는 코드셰프보다 시간을 조금 덜 뺏고, 돈을 좀 더 많이 줍니다. 돈 주는 대회 있으면 보통 저 혼자 조용히 칩니다. ^^&lt;/p&gt;&lt;/li&gt;

&lt;/ul&gt;
&lt;h3&gt;Olympiad&lt;/h3&gt;
&lt;p&gt;ICPC와 더불어 대회 양대산맥입니다. 개인이 5시간동안 3문제씩 푸는 대회 유형이다 보니 키보드에서 손 놓고 죽어라 생각하는 타입의 문제들이 보통 많이 나옵니다. 저는 OI가 알고리즘 문제 풀이의 정수라고 생각합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;강력 추천&lt;/strong&gt; &lt;a href=&quot;http://koosaga.com/174&quot;&gt;OI Checklist&lt;/a&gt;: 어려운 거 / POI 채점이 잘 안되는 거 빼고는 정말 괜찮다고 생각합니다. 초보자용은 아니나 문제 퀄도 전반적으로 괜찮고 스터디 용으로 사용하기에도 좋습니다. 많이 풀어주세요.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;추천&lt;/strong&gt; &lt;a href=&quot;http://www.usaco.org&quot;&gt;USA Computing Olympiad&lt;/a&gt;: 전통의 소 농장은 여전히 훌륭한 트레이닝 사이트고 특별히 거를 게 없습니다. 특히 튜토리얼 삼을 문제가 많아 PS 입문/초심자 분들에게 강력히! 추천합니다. 다만 최상위권한테는 약간 애매한듯. 모든 문제에 대해서 풀이를 제공해 주고, 채점도 BOJ 및 공식 사이트가 잘 해줍니다. 겨울에는 온라인 대회를 열어주기 때문에 Online Contest와도 겹치네요.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;추천&lt;/strong&gt; &lt;a href=&quot;http://hsin.hr/coci/&quot;&gt;Croatian Open Contest in Informatics&lt;/a&gt; : 역시 전통의 COCI는 풀이도 항상 제공해 주고 문제도 괜찮습니다. 요즘은 풀이 제공도 불성실하고 문제 수준도 애매한 것 같으나.. 아무튼 얘는 USACO랑 컨셉이 비슷합니다. BOJ에 여전히 문제가 많고, 특히 그 중 대다수가 번역이 되어 있어서, 업솔빙은 여전히 추천. 역시 겨울에는 온라인 대회를 열어주기 때문에 Online Contest와도 겹치네요.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;추천&lt;/strong&gt; &lt;a href=&quot;https://www.acmicpc.net/category/55&quot;&gt;한국정보올림피아드&lt;/a&gt; 불친절해서 그렇지 문제는 꽤 괜찮습니다. 국산 사랑해 줍시다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://sio2.mimuw.edu.pl/c/oi25-3/contest/&quot;&gt;ONTAK Training Camp&lt;/a&gt;: 인생에 자극이 필요하신 분들에게 추천합니다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/category/94&quot;&gt;Balkan Olympiad in Informatics&lt;/a&gt;: 2011/2012년 문제가 아주 좋습니다.&amp;nbsp;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://oj.uz/problems/source/24&quot;&gt;International Zhautykov Olympiad&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;h3&gt;ICPC-style&lt;/h3&gt;
&lt;p&gt;역시 대회 양대산맥입니다. 팀으로 5시간동안 12문제 정도 푸는 유형입니다. 굉장히 넓은 분야의 지식이 테스트되며 시간당 구현량이 높은 편입니다. 대신 쉬운 문제들도 많이 나와서 OI보다 훨씬 더 다양한 스펙트럼의 사람들을 수용할 수 있습니다. OI가 질이면, ICPC는 양으로 승부한다고 보면 됩니다. 종류가 매우 많아서 이쪽 단락은 좀 깁니다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;강력 추천&lt;/strong&gt; &lt;a href=&quot;https://www.acmicpc.net/category/13&quot;&gt;CERC&lt;/a&gt;: 개인적으로 CERC 문제를 아주 좋아합니다. OI 이상의 퀄리티로 꾸준히 출제되는 거의 유일한 ICPC 대회라고 생각합니다. BOJ에 2010년 이후 문제는 전부 올라와 있으며, 풀이 슬라이드도 대부분 제공이 됩니다. (난이도: ★★★★★)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;추천&lt;/strong&gt; &lt;a href=&quot;https://www.acmicpc.net/category/337&quot;&gt;Japan Alumni Group&lt;/a&gt;: Asia Regional Practice / Spring Contest / Summer Camp가 있습니다. 각각에 대한 설명은 따로 아래에 후술합니다. 문제 수준은 전반적으로 높습니다. 풀이는.. 일본어로 친절하게 써져 있습니다.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Asia Regional Practice는 리저널 대비 문제입니다. 문제가 재밌습니다. 백준에서 그냥 풀어보면 되니 많이 해 보세요. (난이도: ★★★★)&lt;/li&gt;
&lt;li&gt;Spring Contest는 월파처럼 독한 문제들이 출제됩니다. 충격적인 문제가 꽤 있었으나 요즘은 안 하는 것 같군요. 이 친구는 어려워서 더 재밌는 것 같습니다. (난이도: ★★★★★)&lt;/li&gt;
&lt;li&gt;Summer Camp는 앳코더를 잘 뒤져봐야 나옵니다. 찾기만 하면 독하고 재미있는 문제들을 많이 푸실 수 있습니다. (난이도: ★★★★)&lt;/li&gt;

&lt;/ul&gt;
&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;추천&lt;/strong&gt; &lt;a href=&quot;https://www.acmicpc.net/category/90&quot;&gt;NAIPC&lt;/a&gt;: 2016년 이후 문제는 상당히 재밌습니다. 다만 풀이는 불친절. 난이도는 어렵습니다. (난이도: ★★★★)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;추천&lt;/strong&gt; &lt;a href=&quot;https://www.acmicpc.net/category/4&quot;&gt;World Finals&lt;/a&gt;: 월파는 보통 좋은 문제가 꾸준히 출제되었고, 2015 / 2017년 문제들은 매우 좋은 셋입니다. 하지만 나쁜 문제들도 자주 출제되는 것이 함정입니다. 뭐 그래도 평균적으로 좋은 셋에 가깝습니다. 난이도는 당연히 어렵습니다. (난이도: ★★★★★)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;추천&lt;/strong&gt; &lt;a href=&quot;https://www.acmicpc.net/category/11&quot;&gt;NEERC&lt;/a&gt;: 년도나 세터를 타는 것 같지만 좋은 문제가 꾸준히 있는 편입니다. 특히 2012 / 2015 / 2016년을 추천. 난이도는 어렵습니다. (난이도: ★★★★)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NEERC Subregional: 아주 많은 Subregional들이 있으나 일반적으로 Southern / Northern / Moscow 세 곳만 언급이 됩니다. 나머지는 대회가 이상하거나 아니면 돌려보는 것이 불가능할 거에요. Southern Subregional은 재밌습니다. 항상 풀면 뿌듯했던 것 같습니다. Northern / Moscow는 전 많이 안 해 봤습니다. 사실 저는 별로 좋은 기억이 없는데, 코드포스에 보면 상당히 많은 사람들이 연습 셋으로 사용하는 것 같네요. 난이도는 중간 / 약간 어려운 편입니다. 링크는 Gym에서 찾아보면 잘 나와요. (난이도: ★★★)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/category/15&quot;&gt;NWERC + Subregional&lt;/a&gt;: NWERC Subregional (BAPC / GCPC / NCPC / UKIEPC)은 대회 난이도가 다른 대회에 비해 쉬운 편이고, 풀이가 항상 제공되어서 실력을 높이기 좋은 셋 중 하나입니다. 백준에서 채점하기도 쉽네요. 다만 상위권에게는 애매한 것 같습니다. Subregional 중에서는 NCPC가 제일 유명하고 문제 수준도 높습니다. NWERC는 그렇게 난이도가 낮지 않고요.. 셋은 뭐 그냥 괜찮습니다. (난이도: ★★ ~ ★★★)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/category/33&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Pacific Northwest Regional Contest&lt;/a&gt;: 2014년 이후 대회는 Div 1 / 2가 모두 있고 풀이도 전부 제공합니다. Div 1도 쉬운 편이고, Div 2는 대놓고 프로그래밍 대회 초심자를 타깃으로 한 대회니 입문하기에는 가장 좋은 것 같습니다. 문제 퀄리티는 2014년 이후로 괜찮습니다. NWERC Subregional과 함께 초보자에게 추천하기 좋은 연습 셋입니다. (난이도: ★ / ★★)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/category/103&quot;&gt;Latin America Regional Contest&lt;/a&gt;: 저는 많이 안 풀어봤으나 제 주위에서 추천을 많이 받았습니다. 문제 수준이 높고, 난이도도 적당해서 실력을 높이기 좋은 셋이라고 알고 있습니다. 대충 찾아보니 풀이는 좀 불친절한 것 같군요. (난이도: ★★)&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/category/211&quot;&gt;Korea Regional&lt;/a&gt;: 문제 수준은 평균적으로 크게 나쁘지 않습니다. 이것은 &lt;a href=&quot;https://codeforces.com/blog/entry/61519#comment-454816&quot;&gt;rng도 인정한 팩트 (...)&lt;/a&gt; 다만 문제 수준에 변동성이 크고 (ex: 2015년 대전) 잡음도 꽤 나오는 리저널입니다. 친절한 리저널도 아니어서 연습하기도 쉽지 않으나 그래도 BOJ와 다양한 기여자 분들 덕분에 많이 나아졌습니다. &lt;strike&gt;올해 대회는 좋을까요? 저는 잘 모르겠습니다.&lt;/strike&gt; 괜찮았다고 합니다. ㅋㅋ (난이도: ★★★)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/category/43&quot;&gt;Japan Regional&lt;/a&gt;: JOI / JAG / 앳코더 영향을 받고 있는지 문제 수준이 갈수록 높아지고 있습니다. 그래서 아주 좋은 문제들도 많아요. 옛날 문제는 구데기인 거 같습니다… 문제는 구데기일 때도 어려웠고 지금도 어렵습니다. (난이도: ★★★★)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://opencup.ru&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;OpenCup&lt;/a&gt;: 러시아의 마조히스트들이 만들어낸 애증의 오픈컵입니다. 여기 짧게 설명하기에는 너무 독특한 시스템이군요… 말이 많지만 아무튼 월드 파이널 레벨에서 팀으로 연습하고 싶다면 꼭 거쳐가야 할 곳이라고 생각합니다. 궁금하신 분은 개인 연락 주세요. (난이도: ★★★★★)&lt;/p&gt;&lt;/li&gt;

&lt;/ul&gt;
&lt;h3&gt;Online Judges&lt;/h3&gt;
&lt;p&gt;시간 제한 없이 집에서 손 놓고 자유롭게 문제 푸는 공간입니다. 문제를 하루고 일주일이고 풀어도 아무도 뭐라고 안하는 좋은 사이트입니다. 그만큼 풀 수 있는 문제 선택지도 무지막지하게 많습니다. 단점은 뭘 풀어야 할지 모르겠다는 것. 야생과도 같은 공간입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;강력 추천&lt;/strong&gt; &lt;a href=&quot;https://oj.uz/problems/source/162&quot;&gt;oj.uz&lt;/a&gt;: Olympiad 섹션의 문제들이 많이 올라와 있다는 것 외의 추가적인 장점은. 가끔씩 갓갓분들이 좋은 대회를 던지고 간다는 점 같습니다. &lt;a href=&quot;https://oj.uz/problems/source/162&quot;&gt;여기서 확인 가능.&lt;/a&gt; 저 문제들은 ojuz에서만 독점적으로 채점이 됩니다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;강력 추천&lt;/strong&gt; &lt;a href=&quot;https://www.acmicpc.net&quot;&gt;Baekjoon OJ&lt;/a&gt;: 더 이상의 자세한 설명은 생략한다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://szkopul.edu.pl/p/default/problemset&quot;&gt;Szkopul&lt;/a&gt;: 예전 ONTAK / POI, 그리고 AMPPZ / PA 라는 대회가 있습니다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://dmoj.ca/problems/?order=-points&quot;&gt;DMOJ&lt;/a&gt;: 일반적인 문제들은 무난한 OI 스타일입니다. 하지만 이 저지의 핵심은 그게 아니라 40~50 point 대의 심히 뒤틀린 문제들에 있는데…. 예를 들면 &lt;a href=&quot;https://dmoj.ca/problem/ds5&quot;&gt;이런거&lt;/a&gt; &lt;a href=&quot;https://dmoj.ca/problem/mockccc15s5&quot;&gt;이런거&lt;/a&gt; &lt;a href=&quot;https://dmoj.ca/problem/cco08p6&quot;&gt;이런거&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://uoj.ac&quot;&gt;UOJ&lt;/a&gt;: 여기부터는 저도 소문만 들었습니다. 엄청난 것들이 있다고 들었습니다. ONTAK으로 만족이 안되는 마조히스트들에게 추천합니다. &lt;a href=&quot;https://codeforces.com/blog/entry/51462&quot;&gt;matthew99의 설명을 들어보면&lt;/a&gt; NOI / 清华集训 / WC / CTSC가 붙어있는 게 핵심인 거 같네요. 흠. 저도 잘 모르겠습니다. 누가 후기 좀… &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemsets/acmsguru&quot;&gt;SGU&lt;/a&gt;: 여기 문제가 여전히 풀만하다는 이야기를 가끔씩 듣고 있습니다. 전 잘 모르겠는데 후기 좀..&lt;/p&gt;&lt;/li&gt;

&lt;/ul&gt;

&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>공부</category>
<author>구사과</author>
<guid>https://koosaga.com/217</guid>
<comments>https://koosaga.com/217#entry217comment</comments>
<pubDate>Tue, 09 Oct 2018 23:05:46 +0900</pubDate>
</item>
<item>
<title>ACM-ICPC Seoul Preliminary 2018</title>
<link>https://koosaga.com/216</link>
<description>&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width initial-scale=1&quot;&gt;
&lt;title&gt;pre&lt;/title&gt;
&lt;h3&gt;Scoreboard&lt;/h3&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99B0083A5BBEC0262B&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Screenshot from 2018-10-11 12-14-01.png&quot; height=&quot;521&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;지끈..&lt;/p&gt;&lt;p&gt;뭐라 뭐라 더 쓰고 싶으나, 내 블로그가 불편한 이야기를 쓰기에 적합한 장소는 아니라고 생각이 든다.  &lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;
&lt;/p&gt;&lt;h3&gt;Problems / Solution Sketch&lt;/h3&gt;
&lt;p&gt;이번에는 문제 난이도가 비슷한 문제들이 많아서, 사람들이 느끼는 난이도에 이견이 매우 클 수 있다고 생각했다. 마음 같으면 스코어보드 읽고 많이 푼 순서대로 정렬하고 싶으나, 스코어보드가 공개되지 않은 상황이라 그냥 블로그 주인장 마음대로 정렬한다. &lt;/p&gt;
&lt;h4&gt;I. Registration&lt;/h4&gt;
&lt;h4&gt;B. Farm&lt;/h4&gt;
&lt;p&gt;양의 수 $i$를 1부터 $N-1$ 사이의 정수로 고정하면, 염소의 수는 $N - i$ 마리이다. 그러면 그들이 먹는 음식의 양도 계산할 수 있다. 음식의 양을 $w$ 로 가지는 양의 수의 개수를 세어 주고, 유일하면 그 수를 출력하면 된다. 시간 복잡도는 $O(N)$ 이다. $O(1)$도 되지만 귀찮으니 생략.&lt;/p&gt;
&lt;h4&gt;L. Three Robots&lt;/h4&gt;
&lt;p&gt;각각의 정점에서 모이는 데 걸리는 시간은 max(로봇 1에서의 최단 거리, 로봇 2에서의 최단 거리, 로봇 3에서의 최단 거리) 이다. 고로 세 로봇의 위치를 기준으로 한 최단 경로를 계산하면 알 수 있다. 이는 Dijkstra's Algorithm으로 해결할 수 있다. 시간 복잡도는 $O(M\log M)$. $O(N^2)$도 되&lt;/p&gt;&lt;p&gt;지 않았을까 싶다.&lt;/p&gt;&lt;h4&gt;H. Path Embedding&lt;/h4&gt;&lt;p&gt;주어진 $N-1$개의 정점 쌍에 대해서 거리의 최댓값을 출력하면 된다. 거리가 4 이상인 경우에는 99를 찍으면 되니, 사실상 거리가 3 이하라고 가정하면 된다. 정의를 따라 단순히 각 쌍에 대해서 DFS를 하면 $O(N^2)$ 알고리즘이 된다. 고로 효율적인 알고리즘을 찾아야 하는 문제이다.&lt;/p&gt;&lt;p&gt;이 문제는 rooted tree의 LCA에 대한 기본적인 이해가 있으면 풀 수 있는 문제이다. 이 개념에 대해서 익숙치 않다면, 친절하게 해설해 놓은 다른 블로그(&lt;a href=&quot;https://m.blog.naver.com/PostView.nhn?blogId=kks227&amp;amp;logNo=220820773477&amp;amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F&quot; target=&quot;_blank&quot; class=&quot;url&quot;&gt;https://m.blog.naver.com/PostView.nhn?blogId=kks227&amp;amp;logNo=220820773477&amp;amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F&lt;/a&gt;) 를 찾아 보는 것을 추천한다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;LCA는 부모를 단순히 따라가는 방법을 사용하면 O(N)이지만, Sparse Table이라고 불리는 DP를 사용하면 $O(\log N)$ 에도 해결할 수 있다. Sparse Table을 그대로 구현하면 $O(N\log N)$ 시간 복잡도에 문제를 해결할 수 있으며, &quot;거리 3 이하&quot; 의 조건을 사용하면 단순한 방법을 약간 응용해서 $O(N)$ 시간 복잡도에도 풀 수 있다. Sparse Table 방법을 잘 모른다면 이번 기회에 알아보는 것을 추천한다.&amp;nbsp;&lt;/p&gt;
&lt;h4&gt;G. Passport Control&lt;/h4&gt;&lt;p&gt;문제가 약간 이해하기 힘든데, 결론부터 말하자면 주어진 수열을 $K$개의 증가 수열로 덮을 수 있는지에 대한 이야기이다. 즉, 수열이 주어졌을 때, 각 수열을 최대 $K$개의 색으로 칠해서, 각각의 색이 칠해진 수만을 보았을 때 그것들이 증가 수열을 이루게 할 수 있는지를 판별하는 것이다. 색과 심사 창구가 일대일 대응이라고 생각하면 비유가 이해가 갈 것이다.&lt;/p&gt;
&lt;p&gt;크게 3가지 풀이가 있다.&lt;/p&gt;&lt;ul&gt;&lt;ol start=&quot;&quot;&gt;&lt;/ol&gt;&lt;li&gt;&lt;b&gt;대충 그리디.&lt;/b&gt;&amp;nbsp;가장 생각하기 쉽고 코딩도 어렵지 않다. 다만 증명이 조금 어려울 수 있다. 증가 수열을 순서대로 만들어 나갈 것이다. std::set과 같은 자료 구조에 현재 증가 수열의 맨 마지막 원소를 저장했다고 하자. 하나의 원소 $x$ 를 증가 수열에 뒤에 붙일 때, 증가 폭이 적은 (즉, $x$보다는 작지만 가장 큰) 원소의 뒤에 붙이는 것이 이득일 것이라고 직관을 만들 수 있다. 고로, 그러한 원소를 제거한 후 $x$ 를 삽입하면 된다. 시간 복잡도는 $O(N\log N)$&amp;nbsp;언저리이다.&lt;/li&gt;&lt;ol start=&quot;&quot;&gt;&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;/ol&gt;&lt;li&gt;&lt;b&gt;DAG Path Cover.&lt;/b&gt;&amp;nbsp;$i &amp;lt; j, P_i &amp;lt; P_j$ 를 만족하는 $(i, j)$ 쌍에 대해서 $i \rightarrow j$ 방향의 간선을 그어주자. 수열을 $K$개의 증가 수열로 덮는다는 것과, 이 그래프의 모든 정점을 $K$개 이하의 path로 덮는다는 것이 동치가 된다. 이는 이분 매칭으로 구할 수 있다. 자세한 것은&amp;nbsp;&lt;a href=&quot;http://koosaga.com/86&quot; target=&quot;_blank&quot; class=&quot;url&quot;&gt;http://koosaga.com/86&lt;/a&gt;&amp;nbsp;참조. 시간 복잡도는 $O(N^3)$ 언저리이다.&amp;nbsp;&lt;/li&gt;&lt;ol start=&quot;2&quot;&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot;&gt;&lt;/ol&gt;&lt;li&gt;&lt;b&gt;Dilworth's Theorem.&lt;/b&gt;&amp;nbsp;2번에서 DAG Path Cover 문제로 환원을 했다면 Dilworth's Theorem을 사용할 수 있다. Dilworth's Theorem에 의하면 DAG의 최소 Path Cover는 최대 반사슬의 길이와 동일하다. 이 문제에서 반사슬의 최대 길이는 최대 감소 부분수열(LDS)의 길이와 동일하다. 이는 최대 증가 부분수열 (LIS)와 같은 문제이고, $O(N^2)$ 내지는 $O(N\log N)$ 풀이가 잘 알려져 있다. 이렇게 최대 감소 부분수열의 길이를 구한 후 K 이하인지 비교해 주면 된다.&amp;nbsp;&lt;/li&gt;&lt;ol start=&quot;3&quot;&gt;&lt;/ol&gt;&lt;/ul&gt;&lt;p&gt;Dilworth Theorem은 1번 풀이의 쉬운 증명이 된다. 1번 풀이가 사실은 LDS를 $O(N\log N)$에 구하는 알고리즘과 동일하기 때문이다.&lt;/p&gt;&lt;h4&gt;A. Black Chain&lt;/h4&gt;&lt;p&gt;이게 블록체인 뭐시기인가...&amp;nbsp;블랙 고리에서 1을 떼어내는 연산의 횟수 $K$를 정해 두고, $K$번의 연산으로 모든 수를 생성하는 것이 가능한지를 확인해 본다. $K$개의 1을 떼어 내면, 남은 체인들이 최대 $K+1$ 생길 것이다. 이 $K+1$ 개의 수에 $N - K$ 를 적절히 배정해서 조건을 만족시킬 수 있는지를 찾으면 된다.&lt;/p&gt;&lt;p&gt;$K$개의 1만 가지고 만들 수 있는 수는 $\{0, 1, \cdots, K, N - K, N - K + 1, \cdots, N\}$ 이다. 그렇다면 $K+1$번째 수의 첫 항은, 가장 작은 표현할 수 없는 수인 $K+1$ 로 잡아야 한다. 이렇게 되면 양 끝에서 표현할 수 있는 수들의 구간이 커진다. (다음 항이 $2K+2, 4K+4$ 의 꼴로 나올 것이다.) 이를 반복해서 $[0, N]$ 을 전부 덮으면 된다. $K+1$ 개의 수를 다 쓰고도 표현할 수 없는 수가 있으면 답은 불가능이다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;위 과정을 따라가면 $K \leq \log N$ 정도에서 답이 나온다는 결론을 내릴 수 있다. 고로 $O(\log N)$ ~ $O(\log^2 N)$ 정도에 해결 가능하다.&lt;/p&gt;
&lt;h4&gt;F. Parcel&lt;/h4&gt;&lt;div&gt;&lt;p&gt;먼저 단순한 4중 루프를 생각한다. 모든 $1 \leq i &amp;lt; j &amp;lt; k &amp;lt; l \leq N$ 에 대해서, $A_i + A_j + A_k + A_l = W$ 가 되는 쌍의 존재 여부를 찾고 싶은 것이니, 이를 그대로 코드로 옮기면 된다.&lt;/p&gt;
&lt;p&gt;이를 3중 루프로 줄일 수 있다. 모든 $1 \leq j &amp;lt; k &amp;lt; l \leq N$ 에 대해서, $W - A_j - A_k - A_l = A_i$ 가 되는 $1 \leq i &amp;lt; j$ 가 존재하는 지를 찾는 문제로 이를 변환시킬 수 있다. 3중 루프에서 $j$가 증가하면 가능한&amp;nbsp;$i$의 범위가 하나씩 증가한다. 고로 $j$가 증가할 때마다 $A_i$ 들의 리스트가 자라나게 된다. 이 문제에서는 $W$와 $A_i$가 작기 때문에 이러한 $A_i$를 배열에 저장해 놓을 수 있다. $mark[X] = (i &amp;lt; j, A_i = X$ 인 $A_i$ 가 존재) 라고 하면, 단순히 이 배열에 마킹하고, 이 배열의 원소가 true / false인지를 판별하는 식으로 문제를 해결할 수 있다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;이를 2중 루프로 줄일 수 있다. 모든 $1 \leq&amp;nbsp;k &amp;lt; l \leq N$ 에 대해서, $W - A_k - A_l = A_i + A_j$ 가 되는 $1 \leq i &amp;lt; j &amp;lt; k$ 가 존재하는 지를 찾는 문제로 이를 변환시킬 수 있다. 2중 루프에서 $k$가 증가하면 가능한&amp;nbsp;$j$의 범위가 하나씩 증가한다. 고로&amp;nbsp;$A_i + A_j$ 들의 리스트가 자라나게 된다. 이들을 똑같이 배열에 저장해 나간다. 2중 루프는 당연히 $O(N^2)$에 돌고, $A_i + A_j$의 개수는&amp;nbsp;많아야 $O(N^2)$ 이니 이들을 마킹하는 데도 그리 많은 시간이 들지 않는다. 고로 시간 복잡도 $O(N^2)$에 문제가 해결된다.&amp;nbsp;&lt;/p&gt;&lt;/div&gt;
&lt;h4&gt;E. Panokseon&lt;/h4&gt;&lt;div&gt;&lt;p&gt;각 partition이 $W$를 넘으면 안 되고, 넘지 않는다면 최소 partition의 크기를 최대화해야 한다. 고로 답에 대한 이분 탐색 접근을 시도할 수 있다. 모든 partition의 크기가&amp;nbsp;$[W-X, W]$ 구간 안에 들어가게 할 수 있는지를 판별하는 문제를 생각해 보자. 이 문제를 해결한다면 $X \in [0, W-1]$ 구간에서 해당 판별 문제가 참이 되는 최소 $X$를 찾은 후 $X^2$ 를 출력하면 된다.&lt;/p&gt;
&lt;p&gt;이 결정 문제는 동적 계획법으로 해결할 수 있다. $DP[i] = ([1, i]$ 구간을 쪼갤 수 있는가) 라고 하자. $sum(i, j) = \sum_{k = i}^{j}{A_k}$ 라 하면&amp;nbsp;점화식은 다음과 같다.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;$DP[i] = OR_{W-X \leq&amp;nbsp;sum(j + 1, i)&amp;nbsp;\leq W}(DP[j])$&amp;nbsp;&lt;/p&gt;
&lt;p&gt;(OR 항은 해당 조건을 만족하는 모든 $DP[j]$ 중 참인 값이 하나라도 있으면 $DP[i]$ 가 참이라는 뜻이다.)&lt;/p&gt;
&lt;p&gt;부분 배열의 합은 부분 합을 사용해서 깔끔하게 표현할 수 있다. $S_i = \sum_{j=1}^{i}{A_j}$ 라 표현하자. $S_i = S_{i-1} + A_i$ 식을 사용해서 $S_i$ 배열을 선형 시간에 전처리 해 두면,&lt;/p&gt;
&lt;p&gt;$DP[i] = OR_{W-X \leq S_i - S_j&amp;nbsp;\leq W}(DP[j])$&amp;nbsp;&lt;/p&gt;&lt;p&gt;이렇게 되면 시간 복잡도가 $O(N^2\log W)$ 이고 너무 느리다. $\log X$ 번의 호출이 있기 때문에 이 DP를 $O(N)$ 정도로 최적화해야 할 것이다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;최적화를 위해서는 두 가지 사실이 필요하다. 첫 번째로,&amp;nbsp;$S_i - S_j \leq W$ 를 만족하는 최소 $j$를 $l$, $S_i - S_j &amp;lt; W - X$ 를 만족하는 최소 $j$를 $r$ 이라고 하자. $i$가 증가하면 이 $l$과 $r$ 도 따라 증가한다. 고로 $l = r = 0$으로 처음에 설정해 둔 후&amp;nbsp;$i$가 증가함에 따라서 $l, r$을 증가시켜 나가면 $l, r$은&amp;nbsp;전체 DP 과정에서&amp;nbsp;$O(N)$ 번만 갱신된다. 이러한 류의 방법을 inchworm / two pointers라 부른다. 이 방법을 사용하면 $DP[i] = OR_{l \leq j &amp;lt; r}(DP[j])$ 와 같이, $i$에 대응될 수 있는 $j$의 구간을 알아낼 수 있다.&lt;/p&gt;
&lt;p&gt;두 번째로, $[l, r-1]$ 구간에 참인 DP값이 하나 이상 있는지를 판별하는 것은 위에서 사용한 부분 합을 이용해서 똑같이 할 수 있다. 위 경우에는 DP 배열을 처음에 전부 알지는 못하나, 우리가 알고 싶어하는 구간에 대한 DP값은 모두 알려져 있을 것이다. 고로&amp;nbsp;DP에 대한 부분합 배열을 DP 계산 과정에서 만들어 나가면 문제를 해결할 수 있다.&lt;/p&gt;&lt;/div&gt;&lt;h4&gt;K. Suffix-Free Strings&lt;/h4&gt;&lt;div&gt;&lt;p&gt;DFA가 Suffix-Free인지 아닌 지를 복잡하게 생각하면 꼬이지만, 사실 Suffix 쌍의 존재 여부를 출력하는 문제라고 생각하면 명료하다. 결국 어떠한 문자열은 DFA 상의 Path에 대응되므로, Suffix 쌍이 존재한다는 것은 DFA 상에서 두 경로&amp;nbsp;p, q가 존재해서, 둘 다 0에서 시작해서 terminal에서 끝나고, 경로 $p$의 뒤쪽 길이 $length(q)$&amp;nbsp;문자열이 $q$의 문자열과 동일함을 의미한다. (일반성을 잃지 않고 $length(p)$ &amp;gt; $length(q)$라 가정)&lt;/p&gt;&lt;p&gt;두 Suffix 쌍 문자열을 찾는다는 것은&lt;/p&gt;&lt;p&gt;&amp;nbsp;* $p$에서 $length(p) - length(q)$ 길이 prefix를 따라서 어떠한 노드&amp;nbsp;$V$ 로 이동한 후&lt;/p&gt;&lt;p&gt;&amp;nbsp;* 해당 노드 $V$와 루트 노드 $0$에서 $length(q)$ 길이의 동일한 문자열을 따라 가서, 둘 다 어떠한 Terminal 노드에 도착&lt;/p&gt;&lt;p&gt;하는 경로를 찾는 것이다. 이 과정에서 해당 문자열이 어떻게 생겼는지는 중요하지 않다. 비어 있지만 않으면 된다. 고로 문제를 완전히 그래프에 두고 생각할 수 있다.&lt;/p&gt;&lt;p&gt;먼저 모든 가능한 $V$의 집합을 찾아보자. 이는 0번 정점에서 시작해서 하나 이상의 에지를 타고 방문할 수 있는 정점들의 집합과 동일하니 단순 DFS로 가능하다. 가능한 $V$를 찾았으면, 두 노드 쌍 $(0, V)$에서&amp;nbsp;동일한 문자열을 따라가서 두 노드를 모두 Terminal로 보낼 수 있는지를 판별하면 된다. 이는 두 노드 pair를 정점으로 하는 그래프에서 탐색 알고리즘을 돌리면&amp;nbsp;판별할 수 있다. 시간 복잡도는 $O(NM)$.&amp;nbsp;&lt;/p&gt;&lt;/div&gt;&lt;h4&gt;D. Matching&lt;/h4&gt;&lt;div&gt;&lt;p&gt;이건 되는지 잘 모르니 간단하게만 서술. 직선의 각도&amp;nbsp;$\theta$ 가 고정되면 translation을 적당히 해서 distance function의 값을&amp;nbsp;$max(f(A), f(B))$로 만들어 줄 수 있으니,&amp;nbsp;결국 문제는&amp;nbsp;$max(f(A), f(B))$ 를 최소화하는 각도 $\theta$ 를 찾는 문제이다. 이 때, $A, B$가 컨벡스 헐이라고 가정해도 문제가 없다. 컨벡스 헐 안에 있는 점은&amp;nbsp;distance function에 영향을 주지 않기 때문이다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;함수 $f(A)$, $f(B)$는 $A$와 $B$의 각 변에 대한 piecewise 삼각 함수 형태로&amp;nbsp;표현할 수 있다. Rotating Callipers와 같이 $\theta$를 변화시키면서 $f(A)$의 추이를 보자. 만약에 해당 직선이 주어진 볼록 다각형의 변과 만나지 않는다면, 해당 직선이 닿고 있는 두 점만이 $f(A)$ 를 계산하는 데 영향을 준다. 그리고 이 때의 $f(A)$는 삼각 함수로 모델링 할 수 있다. 이렇게 되면 $f(A)$는 $O(N)$ 개의 삼각 함수들의 집합, $f(B)$는 $O(M)$ 개의 삼각 함수들의 집합이다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;이들 중 최댓값을 계산할 때는, 각 piecewise function이 겹치는 $O(N+M)$ 개의 구간에&amp;nbsp;대해서 따로 계산해 준 후 이를 합치는 방법을 사용한다. 각 구간에서 위 삼각 함수들은 대략 볼록한 형태를 띄기 때문에, 두 볼록 함수 최댓값의 최솟값은 정의역의 양 끝이거나 두 함수가 만나는 지점이 된다. 이 부분은 수치 계산의 문제가 된다. 이분 탐색으로 열심히 비비면 된다고 들었으나 자세한 디테일은 알지 못하고 알고 싶지도 않다.&lt;/p&gt;&lt;p&gt;더 간단한 풀이가 있다고 생각할 수도 있지만,&amp;nbsp;확실한 건 정의역의 양 끝만 보는 풀이는 반례가 존재한다.&lt;/p&gt;&lt;/div&gt;&lt;h4&gt;J. Sliding Blocks&lt;/h4&gt;&lt;div&gt;&lt;p&gt;꽤나 깔끔한 풀이가 있다.&amp;nbsp;cki86201이 이에 대해 친절하게 슬라이드를 만들어 주어서, 이를 첨부하는 것으로 풀이를 대신한다.&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;;height:auto;max-width:100%&quot;&gt;&lt;a href=&quot;https://koosaga.com/attachment/cfile10.uf@9926C1505BB9C16333DC10.pdf&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/tistory_admin/assets/blog/55b90b5e7bcae6a80d3ea96e1079ef229f2ae5b2/blogs/image/extension/pdf.gif?_version_=55b90b5e7bcae6a80d3ea96e1079ef229f2ae5b2&quot; alt=&quot;&quot; style=&quot;vertical-align: middle;&quot; /&gt; Jsol.pdf&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;h4&gt;C. Lucid Strings&lt;/h4&gt;&lt;p&gt;풀이 모름. 대회장에서는 Naive 알고리즘에 가까운&amp;nbsp;$O(N^2 / K)$가 뚫렸다고 한다. 아마&amp;nbsp;K = rand() % (N - 1) + 2&amp;nbsp;하신 듯 하다. 물데이터&amp;nbsp;꺼억~&lt;/p&gt;&lt;p&gt;+ 예비소집때 검증해 봤는데 N / K &amp;lt;= 50 assertion이 통과했다. $O(N^2logN / K)$ 도 이상없음 (꺼억)&lt;br /&gt;&lt;/p&gt;</description>
<category>공부</category>
<author>구사과</author>
<guid>https://koosaga.com/216</guid>
<comments>https://koosaga.com/216#entry216comment</comments>
<pubDate>Sun, 07 Oct 2018 15:02:16 +0900</pubDate>
</item>
<item>
<title>ARC 103 F. Distance Sums</title>
<link>https://koosaga.com/215</link>
<description>&lt;p&gt;&lt;a href=&quot;https://beta.atcoder.jp/contests/arc103/tasks/arc103_d&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;https://beta.atcoder.jp/contests/arc103/tasks/arc103_d&lt;/a&gt;&lt;/p&gt;&lt;p&gt;일단 일반성을 잃지 않고 $D_1 &amp;lt; D_2 &amp;lt; \cdots &amp;lt; D_N$ 을 만족하게 정렬할 수 있다. 그러면 결국 1번 노드는 centroid가 되고, 1번 노드를 루트로 하였을 때 $i &amp;gt; 1$ 번 노드의 부모는 $i$번 보다 작은 번호를 가진다. 이 부분의 증명은 생략한다. Centroid의 성질을 생각해 보면 그렇게 어렵지 않다.&lt;/p&gt;&lt;p&gt;고로 루트 (centroid)&amp;nbsp;를 기준으로&amp;nbsp;하나 하나 노드를 붙여나가는 식의 풀이가 될 것이라고 생각할 수 있으나, 생각처럼&amp;nbsp;잘 안된다. 어떠한 노드를 추가할 때 무슨 노드를 부모로 삼을 지가 명확하지 않다.&lt;/p&gt;&lt;p&gt;여기서 발상을 전환시켜서, 위 과정을&amp;nbsp;반대 방향으로 해 보자.&amp;nbsp;$N$번 노드의 부모를 알고 싶다고 해 보자. $N$ 번 노드는 자명히 리프이니, $N$ 번 노드의 부모가 될 노드는 $D_j = D_N - (N - 2)$ 를 만족한다. 모든 $D_i$ 가 서로 다르기 때문에 이를 만족하는 $j$는 유일하다! 고로 $N$번 노드의 부모를 알 수 있다.&amp;nbsp;&lt;/p&gt;&lt;p&gt;일반적으로, $i$번 노드의 부모는 $D_j = D_i - N + 2 * sub(i)$ 를 만족한다. 이 때 $sub(i)$ 는 $i$번 노드를 루트로 한 서브트리의 크기이다.&amp;nbsp;$N$에서 $i+1$까지&amp;nbsp;순서대로 부모를 찾았다고 하면 $sub(i)$ 를 쉽게 알 수 있다. 고로 $D_j$ 를 알 수 있고, 임의의 $i$번 노드의 부모를 알 수 있다.&lt;/p&gt;&lt;p&gt;답을 만족할 가능성이 있는 유일한 트리를 알아냈으니, 이제 검증을 하면 된다. 검증을 단순히 하면 $O(N^2)$ 이 되지만, 잘 생각해 보면 $D_{par(i)}&amp;nbsp;= D_i - N + 2 * sub(i)$ 가 항상 만족하기 때문에, $D_{par(i)}$ 가 맞으면 $D_i$가 맞다. 고로 $D_1$ 이 맞는지만 검증해 주면 모든 답이 맞는다. 이는 단순 DFS로 $O(N)$ 에 판별 가능하다.&amp;nbsp;&lt;/p&gt;</description>
<category>공부</category>
<author>구사과</author>
<guid>https://koosaga.com/215</guid>
<comments>https://koosaga.com/215#entry215comment</comments>
<pubDate>Sat, 29 Sep 2018 23:17:33 +0900</pubDate>
</item>
</channel>
</rss>