<?xml version="1.0" encoding="ISO-8859-1"?>
<?xml-stylesheet type="text/xsl" media="screen" href="/~d/styles/rss2full.xsl"?><?xml-stylesheet type="text/css" media="screen" href="http://feeds.feedburner.com/~d/styles/itemcontent.css"?><rss version="2.0"><channel><title>The Yearly Prophet</title><link>http://theyearlyprophet.com/</link><description>Technical blog/article archive of JongMan Koo</description><lastBuildDate>Sun, 29 Apr 2018 23:48:52 GMT</lastBuildDate><generator>PyRSS2Gen-1.1.0</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="self" type="application/rss+xml" href="http://feeds.feedburner.com/theyearlyprophet/GGGO" /><feedburner:info xmlns:feedburner="http://rssnamespace.org/feedburner/ext/1.0" uri="theyearlyprophet/gggo" /><atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="hub" href="http://pubsubhubbub.appspot.com/" /><item><title>당신과 당신의 연구</title><link>http://theyearlyprophet.com/research.html</link><description>&lt;p&gt;트위터에서 마주친 &lt;a href="http://ropas.snu.ac.kr/~kwang/quote/hamming.html"&gt;당신과 당신의 연구&lt;/a&gt;를 읽었다. 요즘의 개인 상황과 겹쳐 와 닿는 부분이 많았다. (Inspiring quote로 가득한 글이었는데, 의미 있게 느껴지는 부분만 잘라붙여 다시 번역해 보았다. (그렇게 하면 이해가 더 잘 가길래..) 관심이 간다면 전문을 읽기를 추천한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;How about having lots of `brains?' It sounds good. Most of you in this room probably have more than enough brains to do first-class work. But great work is something else than mere brains. Brains are measured in various ways. In mathematics, theoretical physics, astrophysics, typically brains correlates to a great extent with the ability to manipulate symbols. And so the typical IQ test is apt to score them fairly high. On the other hand, in other fields it is something different. For example, Bill Pfann, the fellow who did zone melting, came into my office one day. He had this idea dimly in his mind about what he wanted and he had some equations. It was pretty clear to me that this man didn't know much mathematics and he wasn't really articulate. His problem seemed interesting so I took it home and did a little work. I finally showed him how to run computers so he could compute his own answers. I gave him the power to compute. He went ahead, with negligible recognition from his own department, but ultimately he has collected all the prizes in the field. Once he got well started, his shyness, his awkwardness, his inarticulateness, fell away and he became much more productive in many other ways. Certainly he became much more articulate.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;성공적인 과학자가 되려면 똑똑해야 한다는 주장도 있지요. 그럴싸한 이야깁니다. 허나 제가 보기엔 이 방에 있는 여러분 중 대부분은 최상급의 연구를 수행하기에 충분한 머리를 갖고 있을 겁니다. 머리가 좋은 연구의 전부는 아닙니다. 수학이나 이론물리학, 천체물리학 같은 분야에서 대부분 머리가 좋다는 것은 기호들을 머릿속에서 조작하는 능력과 상관관계가 크다고 여겨집니다. 그래서 일반적인 IQ 테스트는 그런 능력을 높이 평가하지요. 한편 다른 분야에서는 머리가 좋다는 것은 다른 의미를 갖습니다. Zone melting  연구를 하던 Bill Pfann이라는 동료가 있습니다. 어느 날 제 오피스에 들어와 도움을 요청하더군요. 어떤 것을 표현하고 싶은지도 선명하지 않고, 수식들도 명료하지 않아 이 사람이 수학을 잘 모른다는 것을 확실히 느낄 수 있었어요. 하지만 그 문제가 재밌어 보여서 집에 가서 좀 들여다보고, 컴퓨터로 어떻게 자신이 원하는 답을 계산해 줄 수 있는지 알려줬지요. 계산을 할 수 있는 능력을 준 겁니다. 이 친구가 하는 일은 자기 부서에서는 별 관심도 없는 일이었지만, 결과적으로 이 친구는 자기 분야에 있는 모든 상이란 상은 다 휩쓸었어요. 한번 일을 시작하고 나니 소극적인 태도, 명료하지 못한 표현 등의 단점들은 모두 사라져버리고, 다른 방향에서 훨씬 생산적이 된 것이죠. 성공하고 난 뒤에는 그도 엄청나게 명료해졌습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;What Bode was saying was this: "Knowledge and productivity are like compound interest.'' Given two people of approximately the same ability and one person who works ten percent more than the other, the latter will more than twice outproduce the former. The more you know, the more you learn; the more you learn, the more you can do; the more you can do, the more the opportunity - it is very much like compound interest. I don't want to give you a rate, but it is a very high rate. Given two people with exactly the same ability, the one person who manages day in and day out to get in one more hour of thinking will be tremendously more productive over a lifetime. I took Bode's remark to heart; I spent a good deal more of my time for some years trying to work a bit harder and I found, in fact, I could get more work done.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Bode가 의미했던 것은 이겁니다. "지식과 생산성은 복리로 쌓이는 이자와 같다." 비슷한 능력을 가진 두 사람 중 한 사람이 다른 사람보다 10퍼센트 더 일을 한다면, 다른 사람보다 두 배는 넘는 성과를 낼 겁니다. 더 많이 알고 있으면 더 많이 배울 수 있지요. 더 많이 배우면 더 많은 일을 할 수 있고, 더 많은 기회를 얻습니다. 정말 복리와 같이 움직이지요. 정확히 연리 몇 퍼센트인지는 말씀 드릴 수 없겠지만, 엄청나게 높은 이율입니다. 비슷한 능력으로 시작한다고 해도, 별의 별 고생을 해서라도 하루에 한 시간 더 생각할 시간을 갖는 사람은 평생으로 따지자면 비할 수 없이 많은 일들을 이뤄낼 겁니다. 저도 Bode의 조언을 깊이 새겨듣고 좀 더 열심히, 잘 일하려고 노력했지요. 결과적으로 더 많은 일들을 이뤄낼 수 있었고요.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In the first place if you do some good work you will find yourself on all kinds of committees and unable to do any more work. You may find yourself as I saw Brattain when he got a Nobel Prize. The day the prize was announced we all assembled in Arnold Auditorium; all three winners got up and made speeches. The third one, Brattain, practically with tears in his eyes, said, "I know about this Nobel-Prize effect and I am not going to let it affect me; I am going to remain good old Walter Brattain.'' Well I said to myself, "That is nice.'' But in a few weeks I saw it was affecting him. Now he could only work on great problems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;훌륭한 일들을 하다 보면, 이런저런 위원회를 비롯한 다양한 일들에 치여서 제대로 된 연구는 오히려 하지 못하는 경우가 많습니다. 노벨상을 탔을 때의 Brattain이 생각나는군요. 노벨상 수상자가 발표되었을 때, 우리는 Arnold 오디토리움에 모여 수상자들의 소감을 들었습니다. 세 번째로 발표했던 Brattain은 거의 우는 듯한 말투로 "이 노벨상 효과에 대해 너무 잘 알고 있습니다. 절대 저에게는 그 영향이 닿지 않도록 할 겁니다. 여러분이 오랫동안 알아온 Walter Brattain으로 계속 남을 겁니다."라고 말하더군요. 좋은 태도라고 생각했죠. 하지만 몇 주 지나니 이미 노벨상에 휘둘리고 있는 그를 볼 수 있었습니다. 이제는 엄청나게 큰 문제들만을 풀 수 있게 된 것이죠.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I had worked with one of the fellows, Dave McCall; furthermore he was courting our secretary at the time. I went over and said, "Do you mind if I join you?'' They can't say no, so I started eating with them for a while. And I started asking, "What are the important problems of your field?'' And after a week or so, "What important problems are you working on?'' And after some more time I came in one day and said, "If what you are doing is not important, and if you don't think it is going to lead to something important, why are you at Bell Labs working on it?'' I wasn't welcomed after that; I had to find somebody else to eat with! That was in the spring.&lt;/p&gt;
&lt;p&gt;In the fall, Dave McCall stopped me in the hall and said, "Hamming, that remark of yours got underneath my skin. I thought about it all summer, i.e. what were the important problems in my field. I haven't changed my research,'' he says, "but I think it was well worthwhile.'' And I said, "Thank you Dave,'' and went on. I noticed a couple of months later he was made the head of the department. I noticed the other day he was a Member of the National Academy of Engineering. I noticed he has succeeded. I have never heard the names of any of the other fellows at that table mentioned in science and scientific circles. They were unable to ask themselves, "What are the important problems in my field?''&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그 중의 하나인 Dave McCall과는 전에 같이 일한 적도 있었고, 그가 요즘 저희 부서의 비서분에게 관심을 갖고 있는 것도 알고 있었습니다. 다가가 물었죠. "같이 식사해도 되겠습니까?" 물론 그들은 거절을 할 수 없기 때문에, 당분간 같이 점심을 먹게 되었어요. 그리고 질문하기 시작했죠. "당신 분야에 있는 중요한 문제들은 뭔가요?" 그리고 일 주가 지나, "당신은 어떤 중요한 문제에 대해 연구하고 있나요?" 그리고 시간이 더 지나 어느 날 물어봤죠. "만약 지금 하는 일이 중요하지도 않고, 중요한 일로 연결되지도 않을 거라고 생각한다면, 그 일을 대체 왜 벨 랩같은 곳에서 하고 있는 거죠?" 그 후로는 그들과 밥을 같이 먹을 수 없었고 결국 점심을 같이 먹을 새로운 사람을 찾아야 했죠! 이게 봄 얘깁니다.&lt;/p&gt;
&lt;p&gt;가을이 되어 Dave가 저를 복도에서 불러세우더니 말하더군요. "해밍, 당신 얘기가 내 속을 긁어놓긴 했지만, 여름 내내 그 생각을 하게 되더라구요. 내 분야에서 정말 중요한 문제가 무엇인지. 아직 그것으로 내 연구가 크게 변하진 않았지만, 생각해볼 만 한 질문이었던 것 같아요." 두어 달 뒤, 그가 그 부서의 장이 된 것을 알았고, 나중에는 공학 학술원 회원도 되었구요. 성공적인 커리어를 이어간 것이죠. 하지만 거기서 점심을 같이 먹던 다른 사람들의 이름은 들어 본 적이 없었어요. 스스로에게 "내 분야의 중요한 문제는 무엇일까?" 라는 질문을 할 수 없었던 것이죠.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Along those lines at some urging from John Tukey and others, I finally adopted what I called "Great Thoughts Time.'' When I went to lunch Friday noon, I would only discuss great thoughts after that. By great thoughts I mean ones like: "What will be the role of computers in all of AT&amp;amp;T?'', "How will computers change science?''&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;John Tukey와 다른 사람들의 격려에 힘입어, "큰 그림을 그리는 시간"을 갖기로 했죠. 금요일 점심을 먹으러 갈 때부터는 쭉 엄청나게 큰 질문들만을 스스로에게 하기로 한 겁니다. "AT&amp;amp;T에서 컴퓨터의 역할은 앞으로 변화할까?" "컴퓨너는 어떻게 과학을 바꿔놓을까?" 같은 질문들이죠.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You should do your job in such a fashion that others can build on top of it, so they will indeed say, "Yes, I've stood on so and so's shoulders and I saw further.''&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;다른 사람이 자신이 한 일에서 도움을 받고, 더 발전시킬 수 있는 형태의 일을 해야 합니다. "네, 누구누구의 어깨에 올라서서 (뉴튼같이) 더 멀리 볼 수 있었죠." 라는 말이 나오게끔요.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Well, one of the reasons is drive and commitment. The people who do great work with less ability but who are committed to it, get more done that those who have great skill and dabble in it, who work during the day and go home and do other things and come back and work the next day. They don't have the deep commitment that is apparently necessary for really first-class work. They turn out lots of good work, but we were talking, remember, about first-class work. There is a difference. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;자신이 선택한 일에 전념하는 것, 그리고 추진력이 그 이유 중 하나죠. 능력이 좀 부족하더라도 자신이 하는 일에 전념하고 몰입하는 사람은, 능력이 출중하더라도 적당히 발만 담그는 사람, 낮 동안 적당히 일하고 집에 가서 다른 일 하다 출근하는 사람보다 훌륭한 결과를 얻어냅니다. 그런 사람들에게는 정말로 최상급의 연구를 하기 위해 필요한 깊은 집중과 헌신이 없죠. 물론 그들도 좋은 결과를 얻어냅니다만, 우리가 얘기하는 진정한, 놀라운, 최상급의 연구는 아닙니다. 그 둘 사이엔 분명한 차이가 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In summary, I claim that some of the reasons why so many people who have greatness within their grasp don't succeed are: they don't work on important problems, they don't become emotionally involved, they don't try and change what is difficult to some other situation which is easily done but is still important, and they keep giving themselves alibis why they don't. They keep saying that it is a matter of luck. I've told you how easy it is; furthermore I've told you how to reform. Therefore, go forth and become great scientists!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;정리해 말하죠. 위대해질 가능성이 있는 수 많은 사람들이 그렇게 하지 못하는 이유는 다음과 같습니다. 중요한 문제를 풀지 않거나, 감정적으로 문제에 이입하지 않거나, 운이 좋지 않아서 좋은 연구를 하지 못하는 것이라고 스스로에게 면죄부를 주는 것이죠. (다른 이유도 하나 말했는데 이해가 안감..) 자, 이제 얼마나 쉬운지 알았고, 어떻게 변화할지도 알았습니다. 이제 가서 훌륭한 과학자가 됩시다!&lt;/p&gt;</description><guid isPermaLink="true">research.html</guid><pubDate>Sun, 29 Apr 2018 00:00:00 GMT</pubDate></item><item><title>발표자료, 슬라이드들</title><link>http://theyearlyprophet.com/slides.html</link><description>&lt;h3 id="lecture-notes"&gt;Lecture Notes&lt;/h3&gt;
&lt;p&gt;아래는 대략 10년 전 (..) 제가 한 학원에서 강의할 때 썼던 강의자료들입니다. 이 내용 중 일부는 제 책의 씨앗이 되기도 했습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Slide Day 1: &lt;a href="slide01.pdf"&gt;slide01.pdf&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;문제 해결 개관: 모델링, 알고리즘 설계 및 증명, 도구의 사용, 코드 작성의 4단계를 소개&lt;/li&gt;
&lt;li&gt;좋은 코드의 조건 소개&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Slide Day 2: &lt;a href="slide02.pdf"&gt;slide02.pdf&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Discrete Optimization Problems&lt;/li&gt;
&lt;li&gt;완전 탐색 (exhaustive search) 과 분할 정복 (divide &amp;amp; conquer)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Slide Day 3: &lt;a href="slide03.pdf"&gt;slide03.pdf&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Discrete Optimization Problems #2&lt;/li&gt;
&lt;li&gt;동적 계획법 (dynamic programming)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Slide Day 4: &lt;a href="slide04.pdf"&gt;slide04.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Slide Day 5: &lt;a href="slide05.pdf"&gt;slide05.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Slide Day 6: &lt;a href="slide061.pdf"&gt;slide061.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="talks"&gt;Talks&lt;/h3&gt;
&lt;p&gt;다음은 개발자 모임이나 사내 세미나, 컨퍼런스 등에서 발표한 자료들입니다. 
발표에 관심 있으시면 위 연락처로 연락 주세요.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2014년 9월 넥슨 사내 세미나&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/jongman/2014-pycon-kr-widaehan-dict-ihaehago-sayonghagi"&gt;2014년 8월 파이콘 코리아: 위대한 dict 이해하고 사용하기&lt;/a&gt;, &lt;a href="http://www.youtube.com/watch?v=E4bF3tPxeDE"&gt;동영상&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/jongman/writing-correct-code"&gt;2014년 7월 LG전자 사내 세미나: Writing Correct Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/jongman/algorijeum-gisul-sahoeyi-yeongeumsul"&gt;2014년 7월 스쿱미디어 스타트업 세미나: 알고리즘 - 기술 사회의 연금술&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://github.com/jongman/altlang"&gt;2014년 대안언어축제 정기모임: 도메인 전문가와 일하기 관련 자료&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/jongman/oegugin-falsedongjayi-salm"&gt;2014년 전국 대학생 프로그래밍 대회 동아리 연합회 세미나: 외국인 노동자의 삶&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://andromeda-express.com/wfcamp/#slide1"&gt;2014년 ICPC 결승 진출팀 캠프 수업자료: 수학 part 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://andromeda-express.com/ioi2014/"&gt;2014년 IOI 계절학교 강연&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/jongman/oegugin-falsedongjayi-salm"&gt;2011년 알고스팟 겨울캠프: 동적 계획법&lt;/a&gt; (with Being)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위 주제 외의 다른 주제들에 관해서도 발표 가능합니다. 다음은 예제 주제들입니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;알고리즘 문제 해결 입문&lt;/li&gt;
&lt;li&gt;점진적으로 발전하기: 단순한 접근에서 복잡한 알고리즘까지&lt;/li&gt;
&lt;li&gt;알고리즘 문제 해결 과정 뜯어보기&lt;/li&gt;
&lt;/ul&gt;</description><guid isPermaLink="true">slides.html</guid><pubDate>Mon, 19 Mar 2018 00:00:00 GMT</pubDate></item><item><title>Writeup: Learning From Data (한글 정리)</title><link>http://theyearlyprophet.com/lfd.html</link><description>&lt;p&gt;학부 수준의 좋은 머신러닝 교과서인 Learning From Data(Abu-Mostafa, et al)와 &lt;a href="http://work.caltech.edu/telecourse.html"&gt;온라인 강의&lt;/a&gt;를 개인적으로 정리한 것이다. 과거에 올려뒀던 버전이 어딘가 돌아다니는지 이메일로 찾는 분이 몇 분 있어서 올려본다.&lt;/p&gt;
&lt;p&gt;&lt;a href="learning-from-data-learning-theory-kr.pdf"&gt;PDF&lt;/a&gt;&lt;/p&gt;</description><guid isPermaLink="true">lfd.html</guid><pubDate>Fri, 30 Jan 2015 00:00:00 GMT</pubDate></item><item><title>Heavy-Light Decomposition</title><link>http://theyearlyprophet.com/heavy-light-decomposition.html</link><description>&lt;p&gt;작년에 1년동안 쉬면서 한 여러 가지 일 중 하나가, 오랜만에 다시 프로그래밍 대회에 참가하는 것이었다. 비록 연습만 열심히 하고 대회에 제대로 참가하진 못했지만, 최근 나온 문제들을 풀어볼 기회가 되어서 좋았다. 최근 문제 출제 경향은 과거에 비해 꽤 바뀌었음을 느꼈는데, 기존에 출제되지 않았던 테크닉들이 당연하다는 듯이 여러 대회에 나오고 있었다. &lt;/p&gt;
&lt;p&gt;그 중 하나가 바로 Heavy-light decomposition이다. 이런저런 연습 문제를 풀면서 공부한 김에 새 블로그 포스팅으로 쓰기로 했는데, 다 쓰기 싫어서 반년 동안 내버려 두다가 이제야 마무리해서 올려본다.&lt;/p&gt;
&lt;h2 id="tldr"&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;$N$개의 정점을 가진 트리가 있다고 하자. 이 때 임의의 두 정점에 대해 이들을 잇는 경로는 $O(N)$개의 간선을 가진다.  Heavy light decomposition은 트리의 간선들을 적절히 일자 경로인 "묶음"들로 잘라, 임의의 두 간선 사이 경로를 $O(\lg N)$개의 묶음으로 표현할 수 있게 해 준다. 이것을 세그먼트 트리 등의 일차원 자료 구조와 결합함으로써, 임의의 두 정점 사이의 경로에 대한 연산을 $O(\lg^2N)$에 할 수 있다.&lt;/p&gt;
&lt;h2 id="_1"&gt;개관&lt;/h2&gt;
&lt;p&gt;간단한 예제 문제를 들어 보자. 가중치 간선을 갖는 트리가 있다. 문제는 다음의 두 가지 연산을 구현하는 것이다. (이 문제는 &lt;a href="https://algospot.com/judge/problem/read/NAVI"&gt;여기&lt;/a&gt;에서 채점받을 수 있다.)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Update(u, v, cost): 간선 (u, v) 의 가중치를 cost로 갱신한다.&lt;/li&gt;
&lt;li&gt;Query(u, v): 두 정점을 잇는 경로에 포함된 간선 중 최대 가중치를 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이것을 구현하는 가장 간단한 방법은, Query가 호출될 때마다 두 정점 사이의 경로를 따라 걸으며 만나는 가중치의 최대값을 구하는 것이다. 두 정점 u, v사이의 경로는 두 정점의 LCA(최소 공통 조상, least common ancestor)로 올라가는 두 개의 경로로 분할할 수 있으므로, 다음과 같이 간단히 구현할 수 있다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 정점의 개수&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAXN&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// 부모 정점의 번호. 루트라면 -1&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAXN&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// 부모 정점으로 가는 간선의 가중치&lt;/span&gt;

&lt;span class="c1"&gt;// u와 v의 최소 공통 조상(least common ancestor)을 반환한다.&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;lca&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// 간선 (u,v)의 가중치를 cost로 갱신한다.&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cost&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cost&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// u와 v를 잇는 간선 중 최대 가중치를 반환한다.&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;max_weight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lca&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;max_weight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_weight&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;max_weight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_weight&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;max_weight&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;update()는 상수 시간에 동작한다. 그렇다면 query()의 시간 복잡도는 얼마일까? query()는 두 정점에서 LCA까지 가는 경로를 걸어 올라가므로, 시간 복잡도는 두 정점의 깊이에 비례한다고 하겠다. 허나 트리가 브랜치 하나 일렬로 쭉 늘어서 있다면 깊이는 $O(N)$이 된다. 이 문제의 제약 조건에서는 이것은 너무 느리다. 어떻게 하면 좋을까?&lt;/p&gt;
&lt;h2 id="1"&gt;1차원인 경우&lt;/h2&gt;
&lt;p&gt;만약 이 문제가 트리가 아닌 1차원 배열을 다룬다면 어떻게 될까? 1차원 배열 $A$가 있고, 배열의 원소들이 계속 바뀔 때 구간의 최대값을 구하는 문제가 된다. 이것을 구간 최대 쿼리(RMQ, Range Maximum Query)라고 부르는데, 구간 트리(segment tree)를 이용하면 쉽게 풀 수 있는 문제다. (구간 트리의 소개에 관해서는 &lt;a href="http://book.algospot.com"&gt;내 책&lt;/a&gt;의 24장을 보면 된다.)&lt;/p&gt;
&lt;p&gt;이를 구현하는 구간 트리를 다음과 같이 구현할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;SegmentTree&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;SegmentTreeNode&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 이 노드가 덮는 구간은 [first, last]이다.&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;max_value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 이 구간의 최대값&lt;/span&gt;
    &lt;span class="n"&gt;SegmentTreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;SegmentTreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;max_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;SegmentTreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;SegmentTreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="c1"&gt;// 터미널 노드인 경우 값을 바로 업데이트&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;max_value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="c1"&gt;// 아닌 경우 적절한 가지에 값을 전파하고 구간 최대값을 업데이트 &lt;/span&gt;
      &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
          &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;max_value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;max_value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;max_value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="c1"&gt;// [lo,hi]와 [first,last]의 교집합이 없는 경우&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="c1"&gt;// [lo,hi]가 [first,last]를 포함하는 경우&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;max_value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="c1"&gt;// 이외의 경우 각각 나눠 최대값 찾고, 최대치를 반환&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nf"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;};&lt;/span&gt;

  &lt;span class="n"&gt;SegmentTreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;SegmentTree&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;SegmentTreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// pos위치의 값을 value로 바꾼다.&lt;/span&gt;
  &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// [lo, hi] 범위의 값 중 최대값을 구한다.&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;그런데 생뚱맞게 왜 1차원 경우에 대한 방법을 얘기했을까? HLD를 이용하면 임의의 두 정점 사이의 경로를 1차원 배열 여러 개로 분리할 수 있기 때문이다. 그리고 각 1차원 배열에 대해서 위의 구간 트리를 이용해 RMQ를 풀면 된다. 대충 감이 오는가?&lt;/p&gt;
&lt;h2 id="_2"&gt;간선 분류&lt;/h2&gt;
&lt;p&gt;우리의 목적은 트리의 간선을 무거운 간선과 가벼운 간선으로 나누는 것이다. 무거운 간선이란 무엇일까? 한 정점의 무게를 해당 정점을 루트로 하는 서브트리에 속한 정점의 수라고 하자. 부모 u에서 자식 v로 가는 간선이 있을 때, v의 무게가 u의 절반 이상이라면 이 간선은 무거운 간선, 이외의 경우는 가벼운 간선이 된다.&lt;/p&gt;
&lt;p&gt;아까 링크했던 &lt;a href=""&gt;문제&lt;/a&gt;의 예제 데이터를 그림으로 그리면 아래와 같다.&lt;/p&gt;
&lt;p&gt;&lt;img src="hld1.png"/&gt;&lt;/p&gt;
&lt;p&gt;각 서브트리의 무게를 구하고, 무거운 간선을 굵은 선으로 표현하면 다음과 같다.&lt;/p&gt;
&lt;p&gt;&lt;img src="hld2.png"/&gt;&lt;/p&gt;
&lt;p&gt;(이제 각 정점에는 해당 정점의 무게가 표시되어 있다는 점에 유의하자.) 몇 가지 사실을 눈치챌 수 있다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사실 1: 한 정점에서 자손으로 내려가는 무거운 간선이 두개일 수는 없다. 두 자손의 무게가 각각 절반 이상이라면 모순이 되기 때문이다. (만약 자손이 둘 있는데 이들의 무게가 N으로 같다고 하더라도, 부모의 무게는 2N+1이므로 절반이 될 수 없다.)&lt;/li&gt;
&lt;li&gt;사실 2: 가벼운 간선을 따라 부모에서 자식으로 내려가면 노드의 무게는 항상 절반 이상 줄어든다. 노드의 무게는 항상 1 이상이기 때문에, 따라서 루트에서 잎으로 가는 어떤 경로에도 가벼운 간선은 너무 많을 수 없다. 정확하게는 가벼운 간선의 수는 $O(\lg N)$개라는 것을 알 수 있다. 이 사실은 잠시 후 1차원 배열의 개수를 찾는 데 유용하게 쓰인다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_3"&gt;트리 분해&lt;/h2&gt;
&lt;p&gt;간선을 분류하고 나면, 트리의 간선들을 여러 개의 묶음으로 분해할 수 있다. 우선 인접한 무거운 간선들을 하나로 묶자. 이렇게 묶은 결과를 "무거운" 경로라고 부르자. 위에서 언급한 사실1에 의해, 이 결과는 항상 1자 경로가 된다. 위 그림에서 각 무거운 경로를 다음과 같이 구분할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src="hld3.png"/&gt;&lt;/p&gt;
&lt;p&gt;엄밀히 정의에는 어긋나지만, 편의상 무거운 경로의 맨 윗 정점에서 그 부모로 올라가는 간선들도 해당 무거운 경로에 포함시키기로 하자. 무거운 간선에 인접하지 않은 정점은 길이가 0인 경로라고 가정하면, 모든 간선이 정확히 하나의 무거운 경로에 포함되도록 할 수 있다. 다음 그림이 이와 같은 분해 결과를 보여준다.&lt;/p&gt;
&lt;p&gt;&lt;img src="hld4.png"/&gt;&lt;/p&gt;
&lt;p&gt;파란색과 녹색 무거운 경로의 최상위 정점에서 위로 올라가는 간선들이 각각 파란색과 녹색으로 색칠된 것에 유의하자. 그러면 모든 간선은 이제 정확히 하나의 무거운 경로에 속한다.&lt;/p&gt;
&lt;p&gt;이제 각 무거운 경로들을 잘라내 일렬로 펼쳐 보자. 아래 그림을 얻을 수 있다. &lt;/p&gt;
&lt;p&gt;&lt;img src="flattened.png"/&gt;&lt;/p&gt;
&lt;p&gt;이 때 임의의 두 정점 u, v를 잇는 경로는 이 무거운 경로들의 일부들을 모아 표현할 수 있다. 예를 들어 &lt;/p&gt;
&lt;p&gt;&lt;img src="hld5.png"&gt;&lt;/p&gt;
&lt;p&gt;이 그림에서 분홍색으로 표시된 두 정점 간의 경로는 &lt;font color="blue"&gt;파란색 경로&lt;/font&gt;의 일부와 &lt;font color="green"&gt;초록색 경로&lt;/font&gt;의 일부, 그리고 &lt;font color="cyan"&gt;하늘색 경로&lt;/font&gt;를 모아 표현할 수 있다.&lt;/p&gt;
&lt;p&gt;이 때 임의의 두 정점 u, v를 잇는 경로에는 몇 개의 무거운 경로가 포함될까? u, v의 최소 공통 조상이 t라고 하자. t에서 u로 트리를 따라 내려가다 보면, 무거운 경로가 끊어지는 것은 가벼운 간선을 만날 때 뿐이다. 그런데 위에서 언급한 사실2에 의해, 가벼운 간선은 $\lg N$개 이상 만날 수 없다. 따라서 u-v를 잇는 경로 상에 있는 무거운 경로의 수는 최대 $2\lg N$라는 사실을 알게 된다.&lt;/p&gt;
&lt;h2 id="hld"&gt;HLD로 문제 풀기&lt;/h2&gt;
&lt;p&gt;이 점을 깨닫고 나면 앞에서 제시한 문제를 어떻게 풀어야 할지 알 수 있다. 먼저 트리를 무거운 경로들의 집합으로 쪼갠다. 각 무거운 경로들은 1자 경로이니, 각 경로마다 하나의 구간 트리를 만들어 각 간선의 가중치를 저장한다. 그러면 이 문제에서 지원해야 하는 두 개의 연산들을 다음과 같이 수행할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Update 연산&lt;/strong&gt;: 해당 간선이 포함된 무거운 경로를 찾고, 이 경로에서 해당 간선이 몇 번째로 오는지를 찾아낸다. 그리고 나면 해당 무거운 경로를 표현하는 구간 트리의 해당 원소를 갱신해 주면 된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Query 연산&lt;/strong&gt;: 두 정점을 잇는 경로를 무거운 경로의 조각들로 쪼갠다. 이 조각들은 이렇게 생겼을 것이다: [무거운 경로 번호, 경로 내에서 첫 번째 간선의 번호, 경로 내에서 마지막 간선의 번호]. 조각들을 순회하며 만들어 둔 구간 트리를 이용해 해당 조각의 최대치를 찾고, 이 중 최대치를 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="hld_1"&gt;HLD 계산하기&lt;/h2&gt;
&lt;p&gt;HLD 결과를 어떻게 저장해야 할까? 다양한 방법이 있겠지만, 여기에서 제공하는 예제 구현은 트리가 주어질 때 다음과 같은 값들을 계산한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;각 정점의 깊이와, 해당 정점을 루트로 하는 서브트리의 크기  &lt;/li&gt;
&lt;li&gt;무거운 경로의 목록: 각 무거운 경로마다, 경로에 포함된 정점들의 목록을 트리의 위쪽에서부터 저장한다.&lt;/li&gt;
&lt;li&gt;각 정점에 대해, 부모로 가는 간선이 속한 무거운 경로의 번호&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이것을 다음과 같이 선언할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// 입력으로 주어지는 값들&lt;/span&gt;
&lt;span class="c1"&gt;// ======================&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 정점의 수 &lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAXN&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// 각 정점에 대해 부모의 번호를 저장한다. 루트는 -1&lt;/span&gt;
&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;children&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAXN&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// 각 정점마다 자식 정점의 목록을 저장한다.&lt;/span&gt;

&lt;span class="c1"&gt;// HLD가 계산하는 값들&lt;/span&gt;
&lt;span class="c1"&gt;// ===================&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;subtree_size&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAXN&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// 해당 정점을 루트로 하는 서브트리의 크기 (= 정점의 무게)&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;depth&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAXN&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// 트리에서 해당 정점의 깊이. 루트의 깊이는 0.&lt;/span&gt;

&lt;span class="c1"&gt;// 각 무거운 경로마다, 경로에 포함된 정점의 목록. 무거운 경로 맨 위에서 그&lt;/span&gt;
&lt;span class="c1"&gt;// 선조로 가는 가벼운 간선을 포함한다.&lt;/span&gt;
&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;heavy_paths&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;span class="c1"&gt;// 이 정점에서 부모로 가는 간선을 포함된 무거운 경로의 번호. &lt;/span&gt;
&lt;span class="c1"&gt;// heavy_paths 내에서의 인덱스를 가리킨다.&lt;/span&gt;
&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;heavy_path_index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;임의의 간선을 가리키기 위해 두 정점 중 &lt;strong&gt;자손의 번호를 사용한다는 데 유의하자&lt;/strong&gt;. 부모에서 자손으로 가는 간선은 여러 개가 있을 수 있지만, 한 자손에서 부모로 가는 간선의 번호는 유일하기 때문에 자손의 번호를 이용하면 간선과 1:1 관계를 쉽게 유지할 수 있다. &lt;/p&gt;
&lt;p&gt;HLD를 계산하는 간단한 방법은 루트에서 시작해 너비 우선 탐색을 하며, 각 경로를 만들어 나가는 것이다. 너비 우선 탐색이 정점을 방문할 때마다, 이 정점에서 부모로 올라가는 간선을 어디에 추가할지를 결정하면 된다. 이 간선이 무겁다면, 부모에서 끝나는 무거운 경로의 맨 뒤에 추가해 주면 되고, 가볍다면 이 간선에서 시작하는 무거운 경로를 새로 만들면 된다. 이와 같은 구현을 다음 코드에서 볼 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// depth[]와 subtree_size[]는 이미 계산되어 있다고 가정한다.&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;heavy_light_decomposition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// 초기화&lt;/span&gt;
  &lt;span class="n"&gt;heavy_paths&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clear&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;heavy_path_index&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="c1"&gt;// 너비 우선 탐색을 하며 heavy_paths와 heavy_path_index를 계산한다.&lt;/span&gt;
  &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;here&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;child&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;children&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
      &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;child&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// here에서 자신의 부모로 올라가는 간선을 적절한 heavy_paths에 추가하자.&lt;/span&gt;
    &lt;span class="c1"&gt;// 우선 here가 트리의 루트라 부모로 올라가는 간선이 없는 경우는 무시한다.&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;continue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="c1"&gt;// here에서 p로 올라가는 간선은 어떤 heavy_paths에 들어가야 할까?&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;subtree_size&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;subtree_size&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="c1"&gt;// 1. 이 간선이 무겁다면, 부모에서 끝나는 무거운 경로의 맨 끝에 들어간다.&lt;/span&gt;
      &lt;span class="c1"&gt;// (예외: 부모가 루트인 경우에는 부모에서 끝나는 무거운 경로가 아직&lt;/span&gt;
      &lt;span class="c1"&gt;// 없으므로 새 무거운 경로를 만들어야 한다.)&lt;/span&gt;
      &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;parent_path_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heavy_path_index&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
      &lt;span class="n"&gt;heavy_paths&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;parent_path_index&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;heavy_path_index&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parent_path_index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="c1"&gt;// 2. 이 간선이 가볍다면, 이 간선으로 시작하는 새 무거운 경로를 만든다.&lt;/span&gt;
      &lt;span class="n"&gt;heavy_path_index&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heavy_paths&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
      &lt;span class="n"&gt;heavy_paths&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
      &lt;span class="n"&gt;heavy_paths&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;heavy_paths&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="_4"&gt;구간 트리 만들기&lt;/h2&gt;
&lt;p&gt;이렇게 트리를 무거운 경로들로 분리하고 나면, 각 경로를 순회하며 각 경로에 포함된 간선의 길이에 해당하는 구간 트리를 만든다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// 각 무거운 경로에 해당하는 구간 트리. segment_trees[i]는 heavy_paths[i]에&lt;/span&gt;
&lt;span class="c1"&gt;// 대응된다.&lt;/span&gt;
&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;SegmentTree&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;segment_trees&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;initialize_trees&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;segment_trees&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clear&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;segment_trees&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reserve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heavy_paths&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
  &lt;span class="c1"&gt;// 각 무거운 경로마다 구간 트리를 만들고 모든 간선에 대해 값을 1로 지정한다.&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nl"&gt;path&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;heavy_paths&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// 경로에 포함된 정점의 개수가 m개일 때, 간선의 개수는 m-1개이다.&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;segment_trees&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SegmentTree&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;segment_trees&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="update"&gt;Update 연산의 구현&lt;/h2&gt;
&lt;p&gt;Update 연산을 구현하는 것은 간단하다. 우선 해당 간선이 포함된 무거운 경로의 번호를 찾고, 경로 내에서 이 간선이 몇 번째인지 찾는다. 우리는 경로 중 가장 위에 있는 간선을 0번으로 하고, 아래로 내려오며 번호를 매기기로 하자. 이렇게 하면 경로 중 가장 위에 있는 정점의 깊이를 이용해 쉽게 간선의 번호를 얻고, 구간 트리를 업데이트할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// v에서 그 부모로 올라가는 간선은 이 무거운 경로에서 몇 번째의 간선일까?&lt;/span&gt;
&lt;span class="c1"&gt;// 이 경로의 맨 위에 있는 정점의 깊이와 부모의 깊이를 비교하면 쉽게 알 수 있다.&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;find_edge_in_path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;path_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;top_of_path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heavy_paths&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;path_index&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;depth&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;depth&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;top_of_path&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cost&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// 항상 u가 v의 부모이도록 하자.&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="c1"&gt;// (u,v) 가 속한 경로의 번호는?&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;path_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heavy_path_index&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="c1"&gt;// (u,v)는 이 경로에서 몇 번째 간선일까? &lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index_in_path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;find_edge_in_path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="c1"&gt;// 이 경로에 대응되는 구간 트리의 해당 원소를 갱신한다.&lt;/span&gt;
  &lt;span class="n"&gt;segment_trees&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;path_index&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index_in_path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cost&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="query"&gt;Query 연산의 구현&lt;/h2&gt;
&lt;p&gt;흥미로운 부분은 Query 연산이다. 우선 구현을 간단하게 하기 위해, u와 v 사이의 경로를 최소 공통 선조 t에서 쪼개자. 그리고 각각의 조각들에 대해 계산한 뒤 최대치를 구하면, 실제로 구현할 때는 항상 한 정점이 다른 정점의 조상이라고 가정하고 코드를 짤 수 있다. &lt;/p&gt;
&lt;p&gt;아래 코드에서 &lt;code&gt;query&lt;/code&gt;는 두 정점의 최소 공통 선조 t를 구한 뒤, &lt;code&gt;query_topdown&lt;/code&gt;을 이용해 두 경로 &lt;code&gt;u~t&lt;/code&gt;와 &lt;code&gt;t~v&lt;/code&gt;의 최대치를 각각 찾는다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// u와 v를 잇는 경로 중 최대값을 반환한다.&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lca&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query_topdown&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;query_topdown&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;query_topdown&lt;/code&gt;은 어떻게 구현할까? 만약 이 두 정점 사이의 경로가 하나의 무거운 경로로 구성되어 있다면 구간 트리를 이용해 간단히 답을 구할 수 있을 것이다. 이외의 경우에는, v에서 u를 만날 때까지 트리를 따라 올라가며 최대치를 찾는다. 이 때, 물론 한 칸씩 올라가는 것이 아니라, 한 번마다 무거운 경로를 하나씩 떼어낸다. &lt;code&gt;v&lt;/code&gt;에서 &lt;code&gt;parent[v]&lt;/code&gt;로 올라가는 것이 아니라, 이 간선이 속한 무거운 경로의 맨 윗점으로 올라가는 것을 반복하면 된다. 물론 이 때, 구간 트리를 이용해 떼어낸 부분 중의 최대치를 구할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// u에서 v로 내려가는 경로 중 최대값을 반환한다.&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;query_topdown&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// u와 v가 같다면 경로에는 아무 간선도 포함되어 있지 않다.&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// 만약 u와 v가 같은 무거운 경로에 속한다면 구간 트리로 해결 가능&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heavy_path_index&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;heavy_path_index&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;path_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heavy_path_index&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="c1"&gt;// u에서 그 부모로 올라가는 간선은 [u,v] 구간에 포함되지 않고,&lt;/span&gt;
    &lt;span class="c1"&gt;// 그 다음 간선부터 포함되므로 first_edge에 1을 더해 준다.&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;first_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;find_edge_in_path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;last_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;find_edge_in_path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;segment_trees&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;path_index&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first_edge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;last_edge&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// v에서 부모로 올라가는 간선이 포함된 무거운 경로의 맨 위 정점까지 올라간다.&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;path_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heavy_path_index&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;top_of_path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heavy_paths&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;path_index&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

  &lt;span class="c1"&gt;// v == top_of_path 인 경우는 없다. 왜일까?&lt;/span&gt;
  &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;top_of_path&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;last_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;find_edge_in_path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query_topdown&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;top_of_path&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
             &lt;span class="n"&gt;segment_trees&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;path_index&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;last_edge&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 무거운 경로를 하나 떼낸 뒤, 남는 부분의 최대치를 구하기 위해 재귀호출을 이용한다. &lt;/p&gt;
&lt;h2 id="_5"&gt;최소 공통 조상 찾기&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;query&lt;/code&gt;는 내부적으로 두 정점의 최소 공통 조상을 반환하는 함수인 &lt;code&gt;lca()&lt;/code&gt;를 반환한다. 이 함수를 구현하는 방법에는 여러 가지가 있지만, 그 중 비교적 간단한 것은 다음과 같은 배열을 이용하는 것이다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;exp_ancestor[i][j]&lt;/code&gt; = 정점 $i$에서 부모로 가는 연결을 $2^j$번 따라갔을 때 만나는 정점의 번호&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 배열은 깊이 우선 탐색을 하면서 간단히 계산할 수 있고, 이를 이용하면 $O(\lg N)$ 시간만에 두 정점의 최소 공통 조상을 찾을 수 있다. 자세한 것은 아래 소스 코드를 참조하자.&lt;/p&gt;
&lt;h2 id="_6"&gt;시간 복잡도 분석&lt;/h2&gt;
&lt;p&gt;임의의 두 정점 사이의 경로는 $O(\lg N)$개의 무거운 경로들로 나눠질 수 있다. 각 경로에 대해 구간 트리의 연산은 전부 $O(\lg N)$의 시간이 걸리므로, 모든 구간 트리에 대해 연산하는 시간은 $O(\lg^2 N)$이 된다.&lt;/p&gt;
&lt;h2 id="_7"&gt;전체 소스 코드&lt;/h2&gt;
&lt;p&gt;다음은 &lt;a href="https://algospot.com/judge/problem/read/NAVI"&gt;이 문제&lt;/a&gt;를 해결하는 예제 C++ 코드이다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;cassert&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;map&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;set&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;time.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stack&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;queue&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;utility&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;cmath&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;SegmentTree&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;SegmentTreeNode&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 이 노드가 덮는 구간은 [first, last]이다.&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;max_value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 이 구간의 최대값&lt;/span&gt;
    &lt;span class="n"&gt;SegmentTreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;SegmentTreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;max_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;SegmentTreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;SegmentTreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="c1"&gt;// 터미널 노드인 경우 값을 바로 업데이트&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;max_value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="c1"&gt;// 아닌 경우 적절한 가지에 값을 전파하고 구간 최대값을 업데이트 &lt;/span&gt;
      &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
          &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;max_value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;max_value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;max_value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="c1"&gt;// [lo,hi]와 [first,last]의 교집합이 없는 경우&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="c1"&gt;// [lo,hi]가 [first,last]를 포함하는 경우&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;max_value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="c1"&gt;// 이외의 경우 각각 나눠 최대값 찾고, 최대치를 반환&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nf"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;};&lt;/span&gt;

  &lt;span class="n"&gt;SegmentTreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;SegmentTree&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;SegmentTreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// pos위치의 값을 value로 바꾼다.&lt;/span&gt;
  &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="c1"&gt;// [lo, hi] 범위의 값 중 최대값을 구한다.&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;MAXN&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;50000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// 입력으로 주어지는 값들&lt;/span&gt;
&lt;span class="c1"&gt;// ======================&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 정점의 수 &lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAXN&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// 각 정점에 대해 부모의 번호를 저장한다. 루트는 -1&lt;/span&gt;
&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;children&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAXN&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// 각 정점마다 자식 정점의 목록을 저장한다.&lt;/span&gt;

&lt;span class="c1"&gt;// HLD가 계산하는 값들&lt;/span&gt;
&lt;span class="c1"&gt;// ===================&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;subtree_size&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAXN&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// 해당 정점을 루트로 하는 서브트리의 크기 (= 정점의 무게)&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;depth&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAXN&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// 트리에서 해당 정점의 깊이. 루트의 깊이는 0.&lt;/span&gt;

&lt;span class="c1"&gt;// 각 무거운 경로마다, 경로에 포함된 정점의 목록. 무거운 경로 맨 위에서 그&lt;/span&gt;
&lt;span class="c1"&gt;// 선조로 가는 가벼운 간선을 포함한다.&lt;/span&gt;
&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;heavy_paths&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;span class="c1"&gt;// 이 정점에서 부모로 가는 간선을 포함된 무거운 경로의 번호. &lt;/span&gt;
&lt;span class="c1"&gt;// heavy_paths[] 의 인덱스를 가리킨다.&lt;/span&gt;
&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;heavy_path_index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// exp_ancestor[i][j] = i에서 부모로 가는 간선을 2^j번 따라갔을 때 나오는 정점의&lt;/span&gt;
&lt;span class="c1"&gt;// 번호. lca() 를 위해 계산해 둔다.&lt;/span&gt;
&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;exp_ancestor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAXN&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="c1"&gt;// 문제를 풀기 위해 계산하는 값들&lt;/span&gt;
&lt;span class="c1"&gt;// ==============================&lt;/span&gt;

&lt;span class="c1"&gt;// 각 무거운 경로에 해당하는 구간 트리. segment_trees[i]는 heavy_paths[i]에&lt;/span&gt;
&lt;span class="c1"&gt;// 대응된다.&lt;/span&gt;
&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;SegmentTree&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;segment_trees&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// HLD의 구현&lt;/span&gt;
&lt;span class="c1"&gt;// ==========&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;dfs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;subtree_size&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// exp_ancestor[here]를 계산한다.&lt;/span&gt;
  &lt;span class="n"&gt;exp_ancestor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;log_jump&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;log_jump&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// 2^log_jump번 올라가 만난 정점&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arrived&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;exp_ancestor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;log_jump&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="c1"&gt;// 2^log_jump번 더 올라갈 수 없다면 종료&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;exp_ancestor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;arrived&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;log_jump&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// 여기서 2^log_jump번 더 올라가면 2^(log_jump+1)번 올라간 셈이 된다.&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;exp_ancestor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;arrived&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;log_jump&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;exp_ancestor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;child&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;children&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;depth&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;child&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;depth&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;child&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;subtree_size&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;subtree_size&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;child&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// depth[]와 subtree_size[]는 이미 계산되어 있다고 가정한다.&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;heavy_light_decomposition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// 초기화&lt;/span&gt;
  &lt;span class="n"&gt;heavy_paths&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clear&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;heavy_path_index&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="c1"&gt;// 너비 우선 탐색을 하며 heavy_paths와 heavy_path_index를 계산한다.&lt;/span&gt;
  &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;here&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;child&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;children&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
      &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;child&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// here에서 자신의 부모로 올라가는 간선을 적절한 heavy_paths에 추가하자.&lt;/span&gt;
    &lt;span class="c1"&gt;// 우선 here가 트리의 루트라 부모로 올라가는 간선이 없는 경우는 무시한다.&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;continue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="c1"&gt;// here에서 p로 올라가는 간선은 어떤 heavy_paths에 들어가야 할까?&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;subtree_size&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;subtree_size&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="c1"&gt;// 1. 이 간선이 무겁다면, 부모에서 끝나는 무거운 경로의 맨 끝에 들어간다.&lt;/span&gt;
      &lt;span class="c1"&gt;// (예외: 부모가 루트인 경우에는 부모에서 끝나는 무거운 경로가 아직&lt;/span&gt;
      &lt;span class="c1"&gt;// 없으므로 새 무거운 경로를 만들어야 한다.)&lt;/span&gt;
      &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;parent_path_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heavy_path_index&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
      &lt;span class="n"&gt;heavy_paths&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;parent_path_index&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;heavy_path_index&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parent_path_index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="c1"&gt;// 2. 이 간선이 가볍다면, 이 간선으로 시작하는 새 무거운 경로를 만든다.&lt;/span&gt;
      &lt;span class="n"&gt;heavy_path_index&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heavy_paths&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
      &lt;span class="n"&gt;heavy_paths&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
      &lt;span class="n"&gt;heavy_paths&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;heavy_paths&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;initialize_trees&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;segment_trees&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clear&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;segment_trees&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reserve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heavy_paths&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
  &lt;span class="c1"&gt;// 각 무거운 경로마다 구간 트리를 만들고 모든 간선에 대해 값을 1로 지정한다.&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nl"&gt;path&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;heavy_paths&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// 경로에 포함된 정점의 개수가 m개일 때, 간선의 개수는 m-1개이다.&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;segment_trees&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SegmentTree&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;segment_trees&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;lca&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// 편의를 위해, u와 v의 깊이가 같거나 v가 더 아래 있다고 가정한다.&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;depth&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;depth&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="c1"&gt;// 우선 u와 v의 깊이가 다르면 같아질 때까지 v를 올린다.&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;diff&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;depth&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;depth&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;diff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;diff&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; 
      &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;exp_ancestor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

  &lt;span class="c1"&gt;// 만약 이 때 u == v라면 u가 v의 선조.&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// u와 v가 같아지지 않는 한도 내에서 최대한 위로 올라간다.&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;exp_ancestor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;exp_ancestor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;exp_ancestor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;exp_ancestor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;exp_ancestor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
      &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;exp_ancestor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// 위 루프가 종료하면 u와 v는 LCA 바로 아래 위치하게 된다.&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;exp_ancestor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;read_input&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;MAXN&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;children&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;clear&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

  &lt;span class="n"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;here&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;here&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;par&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;par&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;par&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;par&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;children&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;par&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// v에서 그 부모로 올라가는 간선은 이 무거운 경로에서 몇 번째의 간선일까?&lt;/span&gt;
&lt;span class="c1"&gt;// 이 경로의 맨 위에 있는 정점의 깊이와 부모의 깊이를 비교하면 쉽게 알 수 있다.&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;find_edge_in_path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;path_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;top_of_path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heavy_paths&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;path_index&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;depth&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;depth&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;top_of_path&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cost&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// 항상 u가 v의 부모이도록 하자.&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="c1"&gt;// (u,v) 가 속한 경로의 번호는?&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;path_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heavy_path_index&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="c1"&gt;// (u,v)는 이 경로에서 몇 번째 간선일까? &lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index_in_path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;find_edge_in_path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="c1"&gt;// 이 경로에 대응되는 구간 트리의 해당 원소를 갱신한다.&lt;/span&gt;
  &lt;span class="n"&gt;segment_trees&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;path_index&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index_in_path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cost&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// u에서 v로 내려가는 경로 중 최대값을 반환한다.&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;query_topdown&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// u와 v가 같다면 경로에는 아무 간선도 포함되어 있지 않다.&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// 만약 u와 v가 같은 무거운 경로에 속한다면 구간 트리로 해결 가능&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heavy_path_index&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;heavy_path_index&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;path_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heavy_path_index&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="c1"&gt;// u에서 그 부모로 올라가는 간선은 [u,v] 구간에 포함되지 않고,&lt;/span&gt;
    &lt;span class="c1"&gt;// 그 다음 간선부터 포함되므로 first_edge에 1을 더해 준다.&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;first_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;find_edge_in_path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;last_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;find_edge_in_path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;segment_trees&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;path_index&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first_edge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;last_edge&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// v에서 부모로 올라가는 간선이 포함된 무거운 경로의 맨 위 정점까지 올라간다.&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;path_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heavy_path_index&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;top_of_path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heavy_paths&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;path_index&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

  &lt;span class="c1"&gt;// v == top_of_path 인 경우는 없다. 왜일까?&lt;/span&gt;
  &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;top_of_path&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;last_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;find_edge_in_path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query_topdown&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;top_of_path&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
             &lt;span class="n"&gt;segment_trees&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;path_index&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;last_edge&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// u와 v를 잇는 경로 중 최대값을 반환한다.&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lca&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query_topdown&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;query_topdown&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cases&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;cases&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cases&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;read_input&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;// HLD를 계산한다.&lt;/span&gt;
    &lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;heavy_light_decomposition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// 각 무거운 경로에 대해 구간 트리를 만들어 둔다.&lt;/span&gt;
    &lt;span class="n"&gt;initialize_trees&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;queries&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;queries&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;queries&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;update&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cost&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;cost&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cost&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="_8"&gt;연습 문제&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SRM624 Hard - TreeColoring&lt;/li&gt;
&lt;li&gt;Codeforces - &lt;a href="http://codeforces.com/gym/100298/problem/E"&gt;Motorways&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ipsc.ksp.sk/2009/real/problems/l.html"&gt;IPSC 2009 L - Let there be Rainbows!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><guid isPermaLink="true">heavy-light-decomposition.html</guid><pubDate>Wed, 21 Jan 2015 00:00:00 GMT</pubDate></item><item><title>Writeup: Singular Value Decomposition</title><link>http://theyearlyprophet.com/svd.html</link><description>&lt;p&gt;이 문서는 작년에 선형대수 수업을 공부하다 작성한 writeup이다. 개인적으로 이해한 것을 좀 더 직관적으로 정리하려는 목적으로 편하게 썼기 때문에 오타는 물론이고 완전 틀린 내용들도 있을 것이다. (...)&lt;/p&gt;
&lt;p&gt;&lt;a href="svd.pdf"&gt;PDF&lt;/a&gt;&lt;/p&gt;</description><guid isPermaLink="true">svd.html</guid><pubDate>Mon, 19 Jan 2015 00:00:00 GMT</pubDate></item><item><title>Writeup: Linear Algebra</title><link>http://theyearlyprophet.com/linalg.html</link><description>&lt;p&gt;이 문서는 작년에 &lt;a href="http://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/"&gt;Linear Algebra OCW 코스&lt;/a&gt;를 들으면서 작성한 writeup이다. 개인적으로 이해한 것을 좀 더 직관적으로 정리하려는 목적으로 편하게 썼기 때문에 오타는 물론이고 완전 틀린 내용들도 있을 것이다. (...)&lt;/p&gt;
&lt;p&gt;&lt;a href="linalg.pdf"&gt;PDF&lt;/a&gt;&lt;/p&gt;</description><guid isPermaLink="true">linalg.html</guid><pubDate>Mon, 19 Jan 2015 00:00:00 GMT</pubDate></item><item><title>Writeup: Statistical Inference</title><link>http://theyearlyprophet.com/inference.html</link><description>&lt;p&gt;이 문서는 작년에 &lt;a href="http://www.amazon.com/Statistical-Inference-George-Casella/dp/0534243126"&gt;Statistical Inference&lt;/a&gt;를 혼자 공부하면서 작성한 writeup이다. 개인적으로 이해한 것을 좀 더 직관적으로 정리하려는 목적으로 편하게 썼기 때문에 오타는 물론이고 완전 틀린 내용들도 있을 것이다. (...)&lt;/p&gt;
&lt;p&gt;&lt;a href="inference.pdf"&gt;PDF&lt;/a&gt;&lt;/p&gt;</description><guid isPermaLink="true">inference.html</guid><pubDate>Mon, 19 Jan 2015 00:00:00 GMT</pubDate></item><item><title>Writeup: Gaussian Processes</title><link>http://theyearlyprophet.com/gaussian-process.html</link><description>&lt;p&gt;&lt;a href="murphy-gaussian-processes.pdf"&gt;PDF&lt;/a&gt;&lt;/p&gt;</description><guid isPermaLink="true">gaussian-process.html</guid><pubDate>Mon, 19 Jan 2015 00:00:00 GMT</pubDate></item><item><title>Writeup: The Statistical Sleuth</title><link>http://theyearlyprophet.com/sleuth.html</link><description>&lt;p&gt;이 메모는 &lt;a href="http://www.proaxis.com/~panorama/home.htm"&gt;이 책&lt;/a&gt;에 언급된 내용들에 대한 간략한 cheat sheet이다. 이 글은 남에게 보여주기 위해 쓴 것이 아니라 단지 개인적인 용도를 위해 정리한 것이고, 나는 통계학의 전문가와는 거리가 아주 멀기 때문에, 틀린 내용이 얼마든지 있을 수 있다. 틀린 점은 이메일이나 트위터로 알려주면 고맙겠다.&lt;/p&gt;
&lt;p&gt;[&lt;a href="http://theyearlyprophet.com/sleuth.html"&gt;read more&lt;/a&gt;]&lt;/p&gt;</description><guid isPermaLink="true">sleuth.html</guid><pubDate>Wed, 01 May 2013 00:00:00 GMT</pubDate></item><item><title>가장 가까운 원소 찾기</title><link>http://theyearlyprophet.com/closest_element.html</link><description>&lt;p&gt;며칠 전, 시카고 파이썬 사용자 메일링 리스트에 다음과 같은 질문이 올라왔다:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;340만개 쯤 되는 정렬된 자연수 배열 A랑, 30만개쯤 되는 자연수 배열 B가 있는데, B의 각 원소에 대해서 A중 가장 가까운 원소를 찾고 싶어요. 이런 데이터가 여러 개 있어서 가능한 빠르게 짰으면 좋겠는데 어떻게 하면 좋을까요?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;예를 들어 A가 &lt;code&gt;[1, 4, 7, 12, 18]&lt;/code&gt;이고 B가 &lt;code&gt;[3, 10, 17]&lt;/code&gt;이라면 답은 &lt;code&gt;[4, 12, 18]&lt;/code&gt;이란 얘기다.&lt;/p&gt;
&lt;p&gt;(문제와는 별 상관 없지만 자연수 배열 A은 유전자 염기서열에서 특정 부분이 출현하는 위치의 목록이었다고 한다.)&lt;/p&gt;
&lt;p&gt;이렇게 간단한 문제이지만 푸는 여러 가지 방법이 있다. 메일링 리스트에 답신을 쓴 김에 여기에도 다양한 방법들을 소개해 보도록 하겠다.&lt;/p&gt;
&lt;h3 id="_1"&gt;무식하게 풀기&lt;/h3&gt;
&lt;p&gt;내 책을 보신 분들은 알겠지만, 내게 있어 항상 가장 좋은 방법은 시간 안에 돌아가면서 가장 간단한 방법이다. 무식하게 풀면 어떨까? B의 각 원소에 대해 A의 각 원소들을 순회하면서 가장 가까운 원소들을 찾는다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def closer(a1, a2, b):
    "a1 과 a2 중 b에 더 가까운 값을 반환한다."
    if a1 is None: return a2
    if a2 is None: return a1
    return a1 if abs(a1 - b) &amp;lt; abs(a2 - b) else a2

def brute_force(A, B):
    C = []
    for b in B:
        closest = None
        for a in A:
            closest = closer(closest, a, b)
        C.append(closest)
    return C
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;별 특이한 것은 없지만, 두 원소 중 어느 쪽이 b와 더 가까운지 확인하는 &lt;code&gt;closer()&lt;/code&gt; 함수를 따로 만든 것을 눈여겨 보자. 물론 if문 내에 이것을 풀어 쓸 수도 있지만, &lt;code&gt;closest&lt;/code&gt;는 처음에 &lt;code&gt;None&lt;/code&gt;일 수 있기 때문에 if문 내용이 복잡해지게 된다. 이렇게 if문 내용이 길어질 경우 이렇게 함수로 만들어 뽑아내면 간결하고 알아보기도 쉬워진다.&lt;/p&gt;
&lt;p&gt;이 알고리즘의 시간 복잡도는 $O(|A|\cdot|B|)$임을 쉽게 알 수 있다. (시간 복잡도 분석이란 말만 나와도 골치가 아프다면, &lt;a href="http://book.algospot.com/"&gt;제 책을 사세요&lt;/a&gt;... 쿨럭) A와 B의 크기를 여기에 대입해 보면 대략 1조 정도 된다. 아무리 반복문의 내부가 단순함을 감안하더라도 &lt;s&gt;죽기 전에 답을 얻을 가능성이 없다는 것을&lt;/s&gt; 몇 시간은 족히 걸릴 거라는 것을 알 수 있다.&lt;/p&gt;
&lt;h3 id="_2"&gt;이진 탐색&lt;/h3&gt;
&lt;p&gt;물론 이보다 훨씬 나은 방법이 있다. B에 포함된 숫자 b가 주어질 때, A에서 답이 될 수 있는 수를 쉽게 줄이는 방법이 있다. 이진 탐색을 쓰는 방법이다.&lt;/p&gt;
&lt;p&gt;이진 탐색은 A에 b가 포함되어 있을 경우 이것을 쉽게 찾아낼 수 있지만, A에 포함되어 있지 않은 경우엔 어떨까? 이 경우 어떤 값을 반환해야 할까? 표준 라이브러리에 포함된 이진 탐색 알고리즘들은 대개 다음과 같이 정의된다:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$binsearch(A[], x)$: $A[i-1] &amp;lt; x \le A[i]$인 $i$를 반환한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;다시 말해 배열에서 $x$를 삽입할 수 있는 첫 번째 위치를 반환한다는 뜻이다. 배열에 $x$가 포함되어 있을 경우 반환값은 첫 번째 $x$의 위치고, 없는 경우 $x$보다 큰 첫 번째 원소의 위치가 된다.&lt;/p&gt;
&lt;p&gt;(이진 탐색 얘기할 때 빼놓을 수 없는 이야기가 &lt;a href="http://www.yes24.com/24/goods/329227?scode=032&amp;amp;OzSrank=1"&gt;생각하는 프로그래밍&lt;/a&gt;에 소개된 일화이다. 저자인 벤틀리가 수많은 직업 프로그래머들에게 이진 탐색을 짜라고 시켰는데, 그 중 10%만이 제대로 짰다는 충격 스토리!)&lt;/p&gt;
&lt;p&gt;따라서 이 반환값이 있으면 결과값은 둘 중의 하나로 좁혀진다. 파이썬 표준 라이브러리의 &lt;code&gt;bisect.bisect&lt;/code&gt;를 이용하면 다음과 같이 짤 수 있다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import bisect
def binary_search(A, B):
    clip = lambda idx: max(min(len(A) - 1, idx), 0)
    C = []
    for b in B:
        idx = bisect.bisect(A, b)
        # A[idx-1] &amp;lt; b &amp;lt;= A[idx]
        C.append(closer(A[clip(idx - 1)], A[clip(idx)], b))
    return C
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;clip&lt;/code&gt;은 인덱스가 주어질 때 &lt;code&gt;[0, len(A) - 1]&lt;/code&gt; 범위 내로 옮겨준다. 이진 탐색의 결과값인 &lt;code&gt;idx&lt;/code&gt;가 &lt;code&gt;len(A)&lt;/code&gt;이거나 0일 경우를 해결하는 것이다. (언제 이런 값이 반환될까?)&lt;/p&gt;
&lt;p&gt;이 방법의 시간 복잡도는 $O\left( |B|\cdot \lg |A| \right)$ 임을 쉽게 알 수 있다. A와 B의 크기를 대입해 보면 6백만 정도가 된다. 내 책에서 언급했지만 (책 광고 하려고 만든 블로그니 이해하시길.. ㅠ.ㅠ) 현대의 컴퓨터에서 1초에 수행할 수 있는 연산량은 대~~충 잡아도 충분히 1억 이상이므로, 눈 깜짝할 사이에 문제를 해결할 수 있다.&lt;/p&gt;
&lt;h3 id="_3"&gt;스위핑&lt;/h3&gt;
&lt;p&gt;하지만 이보다 빠른 방법은 따로 있다. 이진 탐색도 쓰지 않고 선형 탐색을 하는데, 이진 탐색보다 빠르다! 어떻게? 바로 우리가 가지고 있는 정보를 버리지 않으면 가능하다. &lt;/p&gt;
&lt;p&gt;우선 B의 원소가 오름차순으로 정렬되어 있다고 가정해 보자. 이 때 B의 첫 번째 원소에 대해 가장 가까운 원소를 선형 탐색으로 찾는다. 그리고 나서 두 번째 원소에 대해 다시 문제를 풀자. 그런데 이 때 A의 맨 처음부터 찾아나갈 필요가 없을까? &lt;/p&gt;
&lt;p&gt;물론 없다. B가 정렬되어 있다면 &lt;code&gt;B[1] &amp;gt; B[0]&lt;/code&gt;이고 &lt;code&gt;B[1]&lt;/code&gt;의 답이 &lt;code&gt;B[0]&lt;/code&gt;의 답 이전에 있을 가능성은 없기 때문이다. 따라서 마지막에 가장 가까운 원소를 찾은 위치를 저장해 두고, 여기에서부터 시작하면 된다.&lt;/p&gt;
&lt;p&gt;이것을 여러 가지 방법으로 구현할 수 있지만 내가 좋아하는 방법은 다음과 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def sweeping(A, B):
    # assume B is sorted
    clip = lambda idx: max(min(len(A) - 1, idx), 0)
    C = []
    idx_a = 0
    for b in B:
        while idx_a + 1 &amp;lt; len(A) and A[idx_a + 1] &amp;lt; b:
            idx_a += 1
        C.append(closer(A[clip(idx_a)], A[clip(idx_a + 1)], b))
    return C
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 함수는 각 b에 대해 위에서 이진 검색의 결과에 해당하는 위치를 선형 탐색으로 찾는다. &lt;/p&gt;
&lt;p&gt;이 알고리즘의 수행 시간을 분석하는 방법은 멋있게는 분할 상환 분석(amortized analysis)이라고 부르는데, 별건 아니다. &lt;code&gt;idx_a += 1&lt;/code&gt;은 최대 몇 번이나 실행될까? &lt;code&gt;idx_a&lt;/code&gt;가 A의 크기에 도달하면 더 이상 실행될 수 없다. &lt;code&gt;C.append()&lt;/code&gt;는 B의 각 원소마다 한 번씩만 수행된다. 따라서 반복문 안의 모든 문장들이 실행되는 회수를 합하면 $O(|A|+|B|)$가 된다!&lt;/p&gt;
&lt;p&gt;입력의 크기에 따라 다르지만 (예를 들어, A의 크기가 B에 비해 훠얼씬 훨씬 크다면 이진 탐색이 더 빨라질 수도 있을 것이다) 이 경우 이 방법은 이진 탐색보다도 더 빠르다.&lt;/p&gt;
&lt;h3 id="numpy"&gt;numpy를 이용한 이진 탐색&lt;/h3&gt;
&lt;p&gt;하지만 나라면 두 구현 모두 쓰지 않을 것이다. 대신 &lt;a href="http://www.numpy.org/"&gt;numpy&lt;/a&gt;의 배열을 사용할 것이다. numpy는 파이썬을 위한 행렬/벡터 구현 등을 제공하는 라이브러리인데, 여기에서 그치지 않고 다양한 연산들의 "벡터화"된 버전을 제공한다. 예를 들어 &lt;code&gt;numpy.minimum()&lt;/code&gt;은 두 개 이상의 크기가 같은 벡터를 입력받아 각 원소별로 최소값을 구해 주는 셈이다.&lt;/p&gt;
&lt;p&gt;numpy에도 &lt;code&gt;searchsorted&lt;/code&gt;라는 이진 탐색 함수가 있는데, &lt;code&gt;bisect&lt;/code&gt;와 달리 찾는 값이 배열인 경우 배열을 반환한다!&lt;/p&gt;
&lt;p&gt;이를 이용하면 다음과 같이 간결하게 (.. 사실 길이 차이는 별로 나지 않는 것 같군..) 이진 탐색을 이용한 답안을 짤 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import numpy as np
def binary_search_np(A, B):
    # assume A and B are numpy arrays
    idx2 = np.minimum(len(A) - 1, np.searchsorted(A, B)) 
    idx1 = np.maximum(0, idx2 - 1)
    idx2_is_better = np.abs(A[idx1] - B) &amp;gt; np.abs(A[idx2] - B)
    np.putmask(idx1, idx2_is_better, idx2)
    return A[idx1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 함수가 어떻게 동작하는지 &lt;a href="http://docs.scipy.org/doc/numpy/reference/"&gt;numpy reference&lt;/a&gt;를 보면서 확인해 보자. :-)&lt;/p&gt;
&lt;p&gt;아마도 이 함수는 스위핑 버전보다도 빨리 동작할 것이다. numpy의 함수들은 모두 C나 포트란으로 작성되어 있어 무지하게 빠르기 때문이다.&lt;/p&gt;</description><guid isPermaLink="true">closest_element.html</guid><pubDate>Sun, 13 Jan 2013 00:00:00 GMT</pubDate></item><item><title>대문자 O 표기법과 퀵 정렬의 시간 복잡도</title><link>http://theyearlyprophet.com/big-oh-time-complexity.html</link><description>&lt;p&gt;&lt;a href="http://ko.wikipedia.org/wiki/%EC%A0%90%EA%B7%BC_%ED%91%9C%EA%B8%B0%EB%B2%95#.EB.8C.80.EB.AC.B8.EC.9E.90_O_.ED.91.9C.EA.B8.B0.EB.B2.95"&gt;대문자 O 표기법&lt;/a&gt;은 가장 널리 사용되는 알고리즘의 시간 복잡도 표기 방법이다. 그 자세한 정의는 수학적으로 약간 까다롭지만, 흔히 잊지 않고 기억하는 것은 이것이다:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;대문자 O 표기법은 수행 시간의 상한을 나타낸다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 말이 틀린 말은 아니지만, 이 정의는 혼란을 가져오기 쉽다. 바로 &lt;a href="http://soyoja.com/248#comment1562759"&gt;다음과 같은 질문&lt;/a&gt;이 나오는 배경이 되기 때문이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"우리가 흔히 $O(n\lg n)$ 정렬이라고 말하는 &lt;a href="http://ko.wikipedia.org/wiki/%ED%80%B5_%EC%A0%95%EB%A0%AC"&gt;퀵 정렬&lt;/a&gt;의 경우 Worst Case는 $O(n^2)$이 된다. 교수님이 설명하시길 알고리즘의 시간 복잡도는 Worst Case를 기준으로 측정한다고 얘기했는데 퀵 정렬은 Average Case를 기준으로 할 때만 $O(n\lg n)$이 되는 것인데, 그렇다면 과연 퀵 정렬을 $O(n \lg n)$ 정렬이라고 부르는 것이 맞는가?"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;듣고 보면 그럴 듯 하다. (구현 방법에 따라 다르지만) 퀵 정렬은 최악의 경우 $n^2$에 비례하는 시간이 걸리는데, 왜 $O(n \lg n)$이라고 쓰는 걸까?&lt;/p&gt;
&lt;p&gt;이 직관이 왜 틀렸을까? 대문자 O 표기법은 그냥 정확하게 쓰자면 너무 길고 복잡한 함수를 "적당히 정확하게" 표현하는 방법일 뿐, 최악의 경우/평균적인 경우의 시간 복잡도와는 아무런 관계가 없는 개념이기 때문이다. &lt;/p&gt;
&lt;p&gt;잘 알고 있듯이, 알고리즘의 시간 복잡도는 입력의 크기에 대한 함수로 정의된다. 이 때 어떤 입력이 주어지느냐에 따라서 알고리즘의 수행 시간이 변한다면, 우리는 각각 최선의 경우, 평균적인 경우, 그리고 최악의 경우를 흔히 계산하곤 한다. 이 때 이 세 수행 시간은 세 개의 각각 다른 함수이다. 퀵 정렬의 평균적인 경우의 시간 복잡도는 $n\lg n$이 중간에 포함된 복잡한 함수이고, 최악의 경우의 시간 복잡도는 $n^2$가 어딘가에 포함된 복잡한 함수이다. $O(n\lg n)$과 $O(n^2)$는 이들을 간단하게 표현하기 위한 방법일 뿐이다.&lt;/p&gt;
&lt;p&gt;따라서 앞에서 말한 질문의 경우, "알고리즘의 (최악/최선/평균) 경우의 시간 복잡도는 그 상한을 대문자 O 표기법으로 쓴다"는 기준을 "알고리즘의 시간 복잡도는 그 상한을 기준으로 쓴다"라고 혼동해서 나온 질문이라고 할 수 있다.&lt;/p&gt;
&lt;p&gt;왜 퀵 소트에 대해서만 이런 착각을 하게 되는 것일까? 알고리즘 입문 시간에 처음 배우는 간단한 알고리즘의 경우 기대치와 최악의 수행 시간이 다르지 않다. 예를 들면 &lt;a href="http://ko.wikipedia.org/wiki/%EC%84%A0%ED%83%9D_%EC%A0%95%EB%A0%AC"&gt;선택 정렬&lt;/a&gt; 같은 경우가 그러하다. 선택 정렬은 어떤 배열이 주어지더라도 $\frac{N\cdot(N-1)}{2}$번의 비교를 수행하게 된다. 따라서 최악의 경우와 평균적인 경우, 최선의 경우 시간 복잡도는 모두 $O(n^2)$로 쓸 수 있다. 따라서 퀵 정렬을 배우는 것은 잘못된 착각을 눈치챌 첫 번째 기회인 셈이다.&lt;/p&gt;
&lt;p&gt;처음에 설명한 대문자 O 표기법에 대한 문장을 고쳐 쓰면 다음과 같을 것이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;대문자 O 표기법은 주어진 (최악/최선/평균) 경우의 수행 시간의 상한을 나타낸다.&lt;/p&gt;
&lt;/blockquote&gt;</description><guid isPermaLink="true">big-oh-time-complexity.html</guid><pubDate>Wed, 02 Jan 2013 00:00:00 GMT</pubDate></item><item><title>메모: t-test를 통한 가설 검증 레시피</title><link>http://theyearlyprophet.com/t-test.html</link><description>&lt;p&gt;개인적으로 학부 졸업하고 나서 가장 아쉬운 것 중 하나가 학부 다닐 때 통계학을 제대로 공부하지 않은 것이다. 통계가 왜 중요한가? 어떤 것을 잘 하기 위해 필요한 첫 번째 단계는 그것을 얼마나 잘 하고 있는 지 재는 것이고, 이것을 제대로 재기 위해서는 통계가 필요하기 때문이다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 프로그램에 새로운 최적화 기술을 적용했다고 하자. 1000개의 패킷에 대해 처리 시간을 수집했는데, 최적화 전에는 평균 50.6us였지만 최적화 후 50.1us로 줄었다고 하자. 과연 0.5us 빨라진 걸까? 아니면 그냥 운인 것이고 전혀 빨라진 게 아닐까?&lt;/li&gt;
&lt;li&gt;웹 애플리케이션 첫 페이지를 새로 디자인했다. 새 디자인과 옛 디자인을 A/B 테스트한 결과 각각의 가입 비율을 찾았는데, 이전 디자인에서는 45% 였지만 새 디자인에서는 50% 였다고 하자. 이 상승이 얼마나 의미가 있는지, 운이 아닌지 확인할 방법이 있을까?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 메모는 &lt;a href="http://www.proaxis.com/~panorama/home.htm"&gt;이 책&lt;/a&gt;을 읽으면서 가설 검증에 관련된 챕터 내용들을 정리한 것이다. 이 글은 남에게 보여주기 위해 쓴 것이 아니라 단지 개인적인 용도를 위해 정리한 것이고, 나는 통계학의 전문가와는 거리가 아주 멀기 때문에, 틀린 내용이 얼마든지 있을 수 있다. 틀린 점은 이메일이나 트위터로 알려주면 고맙겠다.&lt;/p&gt;
&lt;p&gt;[&lt;a href="http://theyearlyprophet.com/t-test.html"&gt;read more&lt;/a&gt;]&lt;/p&gt;</description><guid isPermaLink="true">t-test.html</guid><pubDate>Tue, 01 Jan 2013 00:00:00 GMT</pubDate></item><item><title>터미널 사용자를 위한 유용한 프로그램들</title><link>http://theyearlyprophet.com/love-your-terminal.html</link><description>&lt;p&gt;리눅스 프로그래머가 가장 많은 시간을 보내는 곳은 아마도 터미널일 것이다. 터미널에서 어떤 쉘을 쓰느냐, 어떻게 셋업해서 쓰느냐, 어떤 프로그램을 쓰느냐는 개발자의 생산성에 엄청난 영향을 미친다. 한 시간만 들여서 새로운 도구를 몇 개 깔고 커스터마이즈하자. 인생이 달라진다.&lt;/p&gt;
&lt;p&gt;추가로 소개하면 좋을 만한 다른 팁이나 프로그램들이 있다면 트위터로 알려주면 추가하겠다.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;[&lt;a href="http://theyearlyprophet.com/love-your-terminal.html"&gt;read more&lt;/a&gt;]&lt;/p&gt;</description><guid isPermaLink="true">love-your-terminal.html</guid><pubDate>Tue, 01 Jan 2013 00:00:00 GMT</pubDate></item><item><title>글쓴이 소개</title><link>http://theyearlyprophet.com/about.html</link><description>&lt;h3 id="_1"&gt;구종만&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;뉴욕의 &lt;a href="http://twosigma.com"&gt;Two Sigma Investments&lt;/a&gt;에서 HFT 개발자로 일하고 있습니다. &lt;/li&gt;
&lt;li&gt;2007년부터 &lt;a href="http://algospot.com/"&gt;알고스팟&lt;/a&gt; 운영에 참여하고 있습니다.&lt;/li&gt;
&lt;li&gt;이 블로그는 &lt;a href="http://matt.might.net/articles/"&gt;http://matt.might.net/articles/&lt;/a&gt;를 모델로 해 만들었습니다.&lt;/li&gt;
&lt;li&gt;로켓펀치 &lt;a href="http://rocketpun.ch/blog/2014/03/05/developer-interview16/"&gt;인터뷰 1&lt;/a&gt;, &lt;a href="http://rocketpun.ch/blog/2014/03/12/developer-interview17/"&gt;인터뷰 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;프로그래밍 대회를 통한 프로그래밍 교육, 기계학습 및 통계, 웹 애플리케이션 개발, 저지연(low latency) 애플리케이션 개발 등등에 관심이 있습니다. &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_2"&gt;책 홍보&lt;/h3&gt;
&lt;p&gt;지난 10여년동안 국내외의 많은 프로그래밍 대회에 참가해 왔습니다. 그 경험을 바탕으로 2012년 11월에 "&lt;a href="http://book.algospot.com"&gt;프로그래밍 대회에서 배우는 알고리즘 문제 해결&lt;/a&gt;"이라는 책을 냈습니다. 많이 사주세요. 굽신 굽신.&lt;/p&gt;
&lt;h3 id="_3"&gt;연락하기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이메일: jongman@gmail.com&lt;/li&gt;
&lt;li&gt;&lt;a href="http://github.com/jongman"&gt;github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://twitter.com/jongman"&gt;twitter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.linkedin.com/in/jongman"&gt;linkedin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="talks"&gt;Talks&lt;/h3&gt;
&lt;p&gt;다음은 개발자 모임이나 사내 세미나, 컨퍼런스 등에서 발표한 자료들입니다. 
발표에 관심 있으시면 위 연락처로 연락 주세요.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2014년 9월 넥슨 사내 세미나&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/jongman/2014-pycon-kr-widaehan-dict-ihaehago-sayonghagi"&gt;2014년 8월 파이콘 코리아: 위대한 dict 이해하고 사용하기&lt;/a&gt;, &lt;a href="http://www.youtube.com/watch?v=E4bF3tPxeDE"&gt;동영상&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/jongman/writing-correct-code"&gt;2014년 7월 LG전자 사내 세미나: Writing Correct Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/jongman/algorijeum-gisul-sahoeyi-yeongeumsul"&gt;2014년 7월 스쿱미디어 스타트업 세미나: 알고리즘 - 기술 사회의 연금술&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://github.com/jongman/altlang"&gt;2014년 대안언어축제 정기모임: 도메인 전문가와 일하기 관련 자료&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/jongman/oegugin-falsedongjayi-salm"&gt;2014년 전국 대학생 프로그래밍 대회 동아리 연합회 세미나: 외국인 노동자의 삶&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://andromeda-express.com/wfcamp/#slide1"&gt;2014년 ICPC 결승 진출팀 캠프 수업자료: 수학 part 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://andromeda-express.com/ioi2014/"&gt;2014년 IOI 계절학교 강연&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/jongman/oegugin-falsedongjayi-salm"&gt;2011년 알고스팟 겨울캠프: 동적 계획법&lt;/a&gt; (with Being)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위 주제 외의 다른 주제들에 관해서도 발표 가능합니다. 다음은 예제 주제들입니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;알고리즘 문제 해결 입문&lt;/li&gt;
&lt;li&gt;점진적으로 발전하기: 단순한 접근에서 복잡한 알고리즘까지&lt;/li&gt;
&lt;li&gt;알고리즘 문제 해결 과정 뜯어보기&lt;/li&gt;
&lt;/ul&gt;</description><guid isPermaLink="true">about.html</guid><pubDate>Tue, 01 Jan 2013 00:00:00 GMT</pubDate></item><item><title>알고리즘 인터뷰 가이드 1: 준비편</title><link>http://theyearlyprophet.com/interviews-101-preparation.html</link><description>&lt;p&gt;구글이나 마이크로소프트, 페이스북 같은 회사들은 면접에서 알고리즘 문제들을 풀고 구현하도록 시키는 것으로 유명하다. 개인적으로는 이런 주제로 면접을 보는 것이 특정 분야나 환경에 국한되지 않고 프로그래머의 역량을 볼 수 있는 기회라고 생각하지만, 막상 현업에서 항상 사용되지는 않는 주제들이다 보니 쉽게 적응하기 어려운 경우들도 있는 것 같다. 특히 면접이란 실제 업무와 다른 포맷을 갖기 때문에, 충분히 역량 있는 사람들도 면접의 '프로토콜'을 이해하지 못하면 떨어지기가 쉽다. 요즘 그런 안타까운 상황을 많이 보다 이렇게 글을 쓰게 되었다.&lt;/p&gt;
&lt;p&gt;나도 면접을 많이 본 편은 아니지만.. 내가 면접 볼 때 준비했던 것들을 간략하게 정리해 보려고 한다. 그 외에도 문제 유형별로 준비할 점을 간략하게 요약하고, 인터넷에서 찾을 수 있거나 주변 지인에게 들은 인터뷰 문제들을 어떻게 풀어야 할지 예를 들어 보려고 한다.&lt;/p&gt;
&lt;p&gt;여기서는 먼저 중요한 인터뷰 요령과 준비할 때 공부해야 할 주제들을 간단하게 소개하고, 관련된 문제들을 소개하겠다. 나의 해답은 다음 편에.. :-)&lt;/p&gt;
&lt;h2 id="_1"&gt;면접의 원칙들&lt;/h2&gt;
&lt;h4 id="_2"&gt;면접과 필기 시험은 다르다&lt;/h4&gt;
&lt;p&gt;내 생각에 알고리즘 인터뷰를 할 때 가장 중요한 원칙은 자신이 생각하는 과정을 &lt;strong&gt;입 밖으로 내서 말하는 것이다&lt;/strong&gt;. 면접과 필기 시험은 다르다. 필기 시험에서는 혼자 머릿속에서 고민에 고민을 거듭해 낸 답이 정확하기만 하면 되지만, 면접에서는 그래서는 안 된다. 면접의 가장 기본적인 목적은 면접자의 문제 해결 능력을 확인하는 것인데, 이것을 보여줄 수 있는 가장 좋은 방법은 생각하는 방향을 입밖에 내서 설명하는 것이기 때문이다. 맞는 방향을 잡지 못하고 좀 헤매더라도 상관 없으니, 능동적으로 문제를 해결해 나가는 과정을 보여주는 것이 중요하다. 흔히 곰돌이 디버깅이라고 하는 것처럼, 이렇게 자신의 사고 과정을 설명하다 보면 풀기 어려워 보였던 문제도 풀 수 있는 경우가 빈번하다.&lt;/p&gt;
&lt;p&gt;물론 쉼없이 떠들어야 한다는 말은 아니다. 특히 모국어가 아닌 말로 면접을 봐야 할 경우 더더욱 중요해지는데, 첫 마디를 꺼내기 전에 잠깐 멈춰서 무슨 말을 할 지 되새김질 해 보면 도움이 된다. &lt;/p&gt;
&lt;h4 id="_3"&gt;생각의 프레임워크&lt;/h4&gt;
&lt;p&gt;자신이 생각하는 "과정"을 이야기해야 한다는 것을 부담스러워 하는 사람들이 종종 있는 것 같다. 많은 사람들은 딱히 자신이 문제를 푸는 과정이 어떤지 생각해 본 적이 없기 때문이다. 문제를 보고 적당히 고민을 해 보고 답이 떠오르면 푸는거고 아니면 말고... 이런 생각을 하는 사람들이 너무 많다. 문제를 보고 나서 답이 곧장 떠오르지 않는다면.. 아니, 답이 곧장 떠오르는 경우에도 어느 정도 체계적인 구조 안에서 자신의 해결 과정을 설명하는 것이 도움이 될 때가 있다. 예를 들어 다음과 같은 원칙들이 그것이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;단순화한 문제를 푸는 것은 많은 경우 문제 해결을 위해 필요한 직관을 얻는 데 도움이 된다. 예를 들어 두 개의 변수를 정하는 문제라면 한 개를 고정하고 다른 한 개만 찾는다거나, 입력의 크기를 아주 크게 줄인다거나 하는 방법이 있다. 이럴 때는 "문제가 쉽지 않은데, 이렇게 이렇게 더 간단한 버전부터 풀어 보고 이걸 일반화할 수 있을지 한 번 보는 것이 좋을 것 같습니다.." 라고 이야기하고 단순화한 문제를 풀어 보면 된다.&lt;/li&gt;
&lt;li&gt;효율적인 알고리즘을 생각해 내는 문제라면, 처음부터 효율적인 방법을 찾아내야 하는 문제도 있지만 간단하고 비효율적인 방법에서 시작해서 그걸 최적화해 나가는 방법도 많은 경우에 유효하다. "이 문제를 푸는 가장 단순한 방법은 ~~~겠네요. 그런데 이 방법의 시간 복잡도는 ~~라서 너무 느린데, ~~ 부분을 ~~~ 자료 구조를 대신 써서 최적화하면.." 같은 식으로 설명하면 된다.&lt;/li&gt;
&lt;li&gt;혹시라도 비슷한 문제를 들어 본 적이 있다면, "오, 그거랑 비슷한 문제를 과거에 들어본 적이 있네요. 그 문제는 ~~ 해서 풀었는데, 이 문제의 답과 연관이 있을 것 같습니다.." 라고 시작하면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;다행히 인터뷰에서 주어지는 문제들은 비교적 짧은 과정을 통해 답을 얻을 수 있는 경우가 많다. 지금 이야기한 세 가지 접근 방법만 잘 써도 많은 경우 문제를 풀 수 있을 것이고.. 아닌 경우에도, 인터뷰어가 상식적일 경우 당신의 체계적인 접근 방법에 추가 점수 조금은 줄 것이다. ㅋㅋ&lt;/p&gt;
&lt;p&gt;문제 해결 과정에 대해 더 알고 싶으면 &lt;a href="http://book.algospot.com/index.html"&gt;내 책&lt;/a&gt;을 보면 된다. ^^;;&lt;/p&gt;
&lt;h4 id="_4"&gt;적절한 가정 혹은 질문하기&lt;/h4&gt;
&lt;p&gt;면접관도 사람이라 그 문제가 모호하거나 불완전한 구석이 있을 수 있다. 문제의 답에 관련된 부분이 모호하다고 생각하면 질문을 하자! 이 때 적당한 가정을 할 수 있으면 가정을 하고, 이것 또한 입밖으로 내서 확인을 받아야 한다.&lt;/p&gt;
&lt;p&gt;예를 들어 알고리즘을 설계하는 문제를 질문으로 받았다면 입력의 크기는 얼마나 되는지, 얼마나 빨리 수행해야 하는 일인지, 메모리는 얼마나 사용해도 되는지 등등을 물어볼 수 있다. 애초에 입력의 크기가 작거나 시간 제한이 느슨하다면 무식하게 풀어도 되니까. &lt;/p&gt;
&lt;h4 id="_5"&gt;전화 인터뷰&lt;/h4&gt;
&lt;p&gt;외국 회사랑 면접하게 되면 흔히 있는 것이 바로 전화 인터뷰다. 외국 회사랑 면접하면 당연히 한국어를 쓸 수 없으니 전화 영어는 더더욱 답답해지는데.. 이 때는 최소한 핸즈프리랑 펜, 종이 정도를 준비하고 인터뷰에 임하는 것이 좋다. 면접 보면서 구글 검색할 생각은 왠만하면 포기하는 게 좋고. 그 외 인터넷에서 들은 충고 중 하나로, 일어서서 전화통화를 하라는 것이 있었다. 별 것 아닌거 같지만 좀 더 자신감 있는 목소리를 내게 해 준다고 한다. &lt;/p&gt;
&lt;h2 id="_6"&gt;문제의 유형들&lt;/h2&gt;
&lt;p&gt;프로그래밍 인터뷰에 흔히 출현하는 문제 유형은 대개 다음과 같은 것 같다.&lt;/p&gt;
&lt;h2 id="_7"&gt;알고리즘 설계 및 구현하기&lt;/h2&gt;
&lt;p&gt;프로그래밍 인터뷰에 흔히 출현하는 것이 이런이런 문제를 푸는 알고리즘을 설계하고 시간 복잡도를 분석하라는 것이다. 뭐 교과서에 나오는 알고리즘도 나올 수 있고, 알고리즘을 직접 고안해야 할 수도 있고 (다행히 이런 경우는 문제가 좀 더 쉬운 경우가 많다) 자료 구조 관련 문제들도 많을 것이다.&lt;/p&gt;
&lt;p&gt;이 때 유의할 것은 대부분의 경우 실제 컴퓨터를 주고 코드를 짜는 것이 아니라 화이트보드에 설명해야 한다는 것이다. 화이트보드에 코드를 작성하는 것은 IDE에서 코드를 짜는 것과 느낌이 매우 다르니까.. 면접을 준비할 때 미리 연습해 두는 것이 좋다. 대부분의 경우 &lt;a href="http://en.wikipedia.org/wiki/Pseudocode"&gt;의사코드&lt;/a&gt;를 화이트보드에 쓰는 것으로 충분하지만, 세미콜론까지 꽉 채워서 C++ 코드를 쓰라고 한 면접관도 있었으니.. 자신이 잘 한다고 적어낸 언어는 손 코딩을 좀 연습해 두면 좋을 것이다.&lt;/p&gt;
&lt;p&gt;이런 유형으로 나오는 문제에서 90% 정도의 질문은 학부 자료 구조+알고리즘 과목 커리큘럼으로 커버 가능하다. 다음과 같은 주제들은 정말로 단골 손님이니 동작 원리에 대해 공부해 두면 좋다. 화이트보드에 의사코드를 일사천리로 써나가고 설명할 수 있다면 두려울 게 없을 것이다.&lt;/p&gt;
&lt;h4 id="_8"&gt;배열 조작 관련 알고리즘&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;정렬 알고리즘: 학부 졸업생에게 &lt;a href="http://en.wikipedia.org/wiki/Quicksort"&gt;퀵소트&lt;/a&gt;나 &lt;a href="http://en.wikipedia.org/wiki/Mergesort"&gt;머지소트&lt;/a&gt; 구현해 보라는 문제 정도는 흔히 나온다. 구현은 물론이고, 이들의 공통점(둘다 &lt;a href="http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm"&gt;분할 정복&lt;/a&gt; 알고리즘이다)과 차이점(퀵소트는 분할 과정이 복잡하고, 머지소트는 병합 과정이 복잡하다) 도 알아두면 좋다.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Binary_search_algorithm"&gt;이분 탐색&lt;/a&gt; 알고리즘: &lt;a href="http://en.wikipedia.org/wiki/Jon_Bentley"&gt;벤틀리&lt;/a&gt;가 직업 프로그래머들에게 이분 탐색을 구현하게 시켰더니 &lt;a href="http://reprog.wordpress.com/2010/04/19/are-you-one-of-the-10-percent/"&gt;90%는 제대로 못짜더라&lt;/a&gt;라는 일화는 유명하다. 이만큼 구현하기 까다로우니까 신경 써서 한번 구현해 보면 좋다. &lt;a href="http://www.aladin.co.kr/shop/wproduct.aspx?ISBN=8995300930"&gt;생각하는 프로그래밍&lt;/a&gt;에서 아주 잘 다루고 있다.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Selection_algorithm"&gt;k번째 원소 선택 알고리즘&lt;/a&gt;: 퀵소트의 응용판인데 아주 유용하다. 원리를 이해해 두면 다른 문제 푸는 데도 여럿 응용 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="_9"&gt;자료 구조&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;스택, 큐&lt;/li&gt;
&lt;li&gt;해시: ~~에서 ~~를 빠르게 찾으려면 어떻게 할까요? 라는 질문의 절반 정도는 그냥 "해시 쓰면 안되나요?" 라고 대답할 수 있다. &lt;/li&gt;
&lt;li&gt;이진 트리: ~~에서 ~~보다 작은/큰 원소를 빠르게 찾으려면 어떻게 할까요? 라는 질문의 절반 정도는 그냥 "이진 트리 쓰면 안되나요?" 라고 대답할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;해시나 이진 트리는 특성이나 시간 복잡도를 잘 공부해 두는 것이 좋다.&lt;/p&gt;
&lt;h4 id="_10"&gt;그외 준비할 것&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;재귀 호출: 길이 N인 모든 순열 생성하기, 미로에서 길 찾기 등의 문제들은 꽤 자주 볼 수 있다. 능숙하게 쓸 수 있도록 하자.&lt;/li&gt;
&lt;li&gt;시간 복잡도 분석: 이건 뭐.. 뭘 하든 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_11"&gt;브레인티저&lt;/h2&gt;
&lt;p&gt;다음으로 흔한 문제 유형은 흔히 브레인 티저라고 부르는 퍼즐이다. 이런 문제들은 99.9%의 프로그래머의 현업과 아무 상관 없기 때문에, 면접에 이런 문제가 나오면 격분하는 사람들을 종종 볼 수 있다. 위에서도 말했지만, 이런 문제를 내는 것은 이 문제를 해결하는 과정을 보기 위한 것이다. 따라서 감이 안 오더라도 멍하게 있지 말고 이렇게 하면 어떨까, 저렇게 하면 어떨까 하는 식으로 문제에 접근해 가는 과정을 보여줘야 한다. 그정도는 되어야 면접관도 힌트라도 하나 더 주고 올바른 방향으로 당겨줄 수 있다. "생각의 프레임워크"에서 언급한 접근 방법을 써 보는 것도 좋다.&lt;/p&gt;
&lt;p&gt;이거 관련해서 문제집이 여러 개 있는데 그 중 제일 유명한건 &lt;a href="http://www.google.com/products/catalog?q=heard+on+the+street&amp;amp;hl=en&amp;amp;prmd=ivnsb&amp;amp;bav=on.2,or.r_gc.r_pw.r_cp.&amp;amp;biw=650&amp;amp;bih=899&amp;amp;um=1&amp;amp;ie=UTF-8&amp;amp;tbm=shop&amp;amp;cid=12860625007172099261&amp;amp;sa=X&amp;amp;ei=eBBjTu7aCcvogQfk3sWQCg&amp;amp;ved=0CF0Q8wIwAA"&gt;이것&lt;/a&gt;... 물론 개발자 면접에서 이것까지 보는 건 좀 오버인 거 같긴 하다.&lt;/p&gt;
&lt;h2 id="_12"&gt;디자인 문제들&lt;/h2&gt;
&lt;p&gt;디자인 문제는 주어진 작업을 수행하는 프로그램의 구조를 설명하기를 요구한다. 대개 OOP 패러다임 안에서 프로그램의 구조를 적절히 설명하면 된다. 사실 이것은 적절한 입코딩의 영역이라 내가 뭐라고 할 수 있는 주제는 아니다. 하지만 가능한한 간단한 답안을 작성하고, 요구 사항이 변함에 따라 적절히 설계를 변경해 주는 센스가 필요하다. 면접관이 보고 싶은 것은 클래스가 뭔지, protected 가 뭔지 이런 것을 아는가가 아니라, 적절한 구조를 만들어 내는가이기 때문이다. 그냥 "이렇게 해도 되긴 될텐데 이렇게 짜죠?" 가 아니라 "이런 식으로 디자인하는 것이 더 이해하기 쉽고 더 직관적이고 더 현실 세계와 가깝기 때문에 이렇게 짜죠?" 라고 말할 수 있는 것이 중요하다는 이야기다.&lt;/p&gt;
&lt;p&gt;이런 부분 관련해서 읽어볼 수 있는 좋은 책으로 &lt;a href="http://www.yes24.com/24/goods/3732893"&gt;클린 코드&lt;/a&gt;가 있다.&lt;/p&gt;
&lt;h2 id="_13"&gt;차회예고&lt;/h2&gt;
&lt;p&gt;다음 포스트에서는 내가 들어본 문제들과 구글링으로 얻을 수 있는 구글 인터뷰 문제들을 풀어보도록 하겠다.&lt;/p&gt;</description><guid isPermaLink="true">interviews-101-preparation.html</guid><pubDate>Fri, 07 Oct 2011 00:00:00 GMT</pubDate></item><item><title>철자 교정기 작성하기</title><link>http://theyearlyprophet.com/spell-correct.html</link><description>&lt;p&gt;블로그 개장 기념으로 역시 내가 좋아하는 또다른 에세이 중 하나인 &lt;a href="http://norvig.com/"&gt;Peter Norvig&lt;/a&gt;의 &lt;a href="http://norvig.com/spell-correct.html"&gt;How to Write a Spelling Corrector&lt;/a&gt;를 번역해 보았다. 영문을 대상으로 한 철자 교정기라서 국문에 그대로 적용할 수는 없지만, 굉장히 흥미롭게 읽을 수 있다.&lt;/p&gt;
&lt;p&gt;나는 이 글이 정말 굉장히 좋은 글이라고 생각하는데, 단순히 이론을 잘 설명하고 있으며, 코드가 간결하고 우아하다는 표면적인 이유 외에도 딱히 정답이 없는 문제에 접근하기 위한 사고 과정을 잘 설명하고 있다는 것이다. 동작할 수 있는 가장 단순한 방법을 만들고, 이것의 성능을 측정하고, 어떻게 이것을 개선하면 좋을지에 대해서도 잘 설명하고 있다. 우리 시대의 가장 &lt;a href="http://norvig.com/bio.html"&gt;유명한 인공지능 연구자 중 하나&lt;/a&gt;가 이런 문제 해결 과정을 직접 설명해 주는 것을 듣기란 쉽지 않다.&lt;/p&gt;
&lt;p&gt;번역상의 오탈자는 코멘트로 신고 바란다. &lt;/p&gt;
&lt;p&gt;[&lt;a href="http://theyearlyprophet.com/spell-correct.html"&gt;read more&lt;/a&gt;]&lt;/p&gt;</description><guid isPermaLink="true">spell-correct.html</guid><pubDate>Wed, 24 Aug 2011 00:00:00 GMT</pubDate></item><item><title>커피스크립트</title><link>http://theyearlyprophet.com/coffeescript.html</link><description>&lt;p&gt;&lt;a href="http://javascript.crockford.com/popular.html"&gt;더글러스 크록포드&lt;/a&gt; 아저씨가 &lt;a href="http://javascript.crockford.com/popular.html"&gt;어떤 글&lt;/a&gt;에서 말했듯이, 자바스크립트는 지금 가장 중요한 언어 중의 하나가 되었다. &lt;a href="http://en.wikipedia.org/wiki/Google_Chrome_OS"&gt;크롬 OS&lt;/a&gt;는 자바스크립트로 작성된 웹 앱들로 운영체제의 네이티브 앱을 대체하려고 들고, 그것도 모자라 &lt;a href="http://nodejs.org/"&gt;node.js&lt;/a&gt;는 서버도 자바스크립트로 작성하려고 한다. 지난 2년 사이에 꽤나 유명해진 문서 기반 데이터베이스인 &lt;a href="http://www.mongodb.org/"&gt;MongoDB&lt;/a&gt;는 아예 쉘에서 자바스크립트를 지원한다.&lt;/p&gt;
&lt;p&gt;이렇게 자바스크립트의 사용이 점점 늘어가지만 자바스크립트에는 여러 고질적인 문제들이 있다. 자바스크립트의 대표적인 옹호자 중 하나인 더글러스 옹께서도 위에서 언급한 글에서 "JavaScript is an astonishing language, in the very worst sense. (자바스크립트는 정말 끝내주는 언어다. 안 좋은 의미로.)" 라고 할 정도니 말 다 했다. DOM에의 의존성 등의 거창한 이유를 언급하지 않아도 자바스크립트에는 너무 많은 함정이 널려 있다. &lt;/p&gt;
&lt;p&gt;얼마 전에 자바스크립트의 함정들에 대해 다루는 &lt;a href="http://blog.cheol.net/post/9208860498"&gt;좋은 글&lt;/a&gt;을 보았다. 사실 이런 글들은 엄청 많은데 &lt;a href="http://www.fitzblog.com/bid/2127/Nine-Javascript-Gotchas"&gt;여기&lt;/a&gt;나 &lt;a href="http://stackoverflow.com/questions/2749952/what-are-the-top-javascript-pitfalls"&gt;여기&lt;/a&gt;도 한번씩 보도록 하자. &lt;/p&gt;
&lt;p&gt;이런 점들을 잘 알고 피해가는 것도 중요하지만, 더 좋은 방법은 &lt;a href="http://www.codinghorror.com/blog/2007/08/falling-into-the-pit-of-success.html"&gt;성공의 함정에 빠지도록&lt;/a&gt; 도와 주는 언어를 사용하는 것이라고 생각한다.&lt;/p&gt;
&lt;p&gt;그런 목적으로 등장한 언어가 있으니 바로 &lt;a href="http://jashkenas.github.com/coffee-script/"&gt;커피스크립트&lt;/a&gt;다. 커피스크립트는 &lt;strong&gt;자바스크립트로 컴파일되는&lt;/strong&gt; 스크립트 언어로써, 단순히 &lt;a href="http://en.wikipedia.org/wiki/Syntactic_sugar"&gt;syntactic sugar&lt;/a&gt;라고 생각할 수도 있지만 다른 언어에 익숙한 개발자가 제정신을 유지하고 자바스크립트를 작성할 수 있도록 많은 기능들을 지원한다. &lt;a href="http://jashkenas.github.com/coffee-script/"&gt;커피스크립트 홈페이지&lt;/a&gt;에 잘 설명되어 있지만, 우선 개인적으로 느끼기에 의미 있는 장점들을 우선 소개해 보겠다.&lt;/p&gt;
&lt;p&gt;[&lt;a href="http://theyearlyprophet.com/coffeescript.html"&gt;read more&lt;/a&gt;]&lt;/p&gt;</description><guid isPermaLink="true">coffeescript.html</guid><pubDate>Tue, 23 Aug 2011 00:00:00 GMT</pubDate></item><item><title>스도쿠 문제 전부 풀기</title><link>http://theyearlyprophet.com/solving-every-sudoku-puzzle.html</link><description>&lt;p&gt;블로그를 개장한 기념으로 과거에 번역한 적이 있던 에세이를 올려본다.&lt;/p&gt;
&lt;p&gt;이 글은 &lt;a href="http://norvig.com/"&gt;Peter Norvig&lt;/a&gt; 이 쓴 &lt;a href="http://norvig.com/sudoku.html"&gt;Solving Every Sudoku Puzzle&lt;/a&gt; 을 번역한 것이다. 번역상의 오탈자는 &lt;a href="mailto:theyearlyprophet@gmail.com"&gt;번역자&lt;/a&gt; 에게 신고 바란다.&lt;/p&gt;
&lt;p&gt;[&lt;a href="http://theyearlyprophet.com/solving-every-sudoku-puzzle.html"&gt;read more&lt;/a&gt;]&lt;/p&gt;</description><guid isPermaLink="true">solving-every-sudoku-puzzle.html</guid><pubDate>Sat, 20 Aug 2011 00:00:00 GMT</pubDate></item></channel></rss>
