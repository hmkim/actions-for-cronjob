<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	>

<channel>
	<title>Just hack&#039;em</title>
	<atom:link href="https://justhackem.wordpress.com/feed/" rel="self" type="application/rss+xml" />
	<link>https://justhackem.wordpress.com</link>
	<description>프로그래머 이규원의 블로그</description>
	<lastBuildDate>
	Sat, 05 Jan 2019 08:23:02 +0000	</lastBuildDate>
	<language>ko-KR</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
<cloud domain='justhackem.wordpress.com' port='80' path='/?rsscloud=notify' registerProcedure='' protocol='http-post' />
<image>
		<url>https://s0.wp.com/i/buttonw-com.png</url>
		<title>Just hack&#039;em</title>
		<link>https://justhackem.wordpress.com</link>
	</image>
	<atom:link rel="search" type="application/opensearchdescription+xml" href="https://justhackem.wordpress.com/osd.xml" title="Just hack&#039;em" />
	<atom:link rel='hub' href='https://justhackem.wordpress.com/?pushpress=hub'/>
	<item>
		<title>코딩 시험과 TDD</title>
		<link>https://justhackem.wordpress.com/2019/01/05/coding-test-and-tdd/</link>
				<comments>https://justhackem.wordpress.com/2019/01/05/coding-test-and-tdd/#comments</comments>
				<pubDate>Fri, 04 Jan 2019 16:00:38 +0000</pubDate>
		<dc:creator><![CDATA[Gyuwon]]></dc:creator>
				<category><![CDATA[일반]]></category>
		<category><![CDATA[coding test]]></category>
		<category><![CDATA[tdd]]></category>
		<category><![CDATA[testing]]></category>

		<guid isPermaLink="false">http://justhackem.wordpress.com/?p=8237</guid>
				<description><![CDATA[구직 과정에 코딩 시험이 있었다. 면접관의 컴퓨터와 응사자의 컴퓨터가 코딩 시험 도구로 연결되어 면접관이 응시자의 코딩을 지켜보거나 개입할 수 있는 환경이었다. 어떤 문제의 답 코드를 쓰다 10줄 이상이 되니 자신감이 떨어져 TDD를 사용하기로 했다. 여기서 나는 흥미로운 경험을 했다. 물론 코딩 시험에 테스팅 도구는 주어지지 않았다. TDD는 테스팅 도구가 있어야만 할 수 있는 것이 아니다. [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>구직 과정에 코딩 시험이 있었다. 면접관의 컴퓨터와 응사자의 컴퓨터가 코딩 시험 도구로 연결되어 면접관이 응시자의 코딩을 지켜보거나 개입할 수 있는 환경이었다. 어떤 문제의 답 코드를 쓰다 10줄 이상이 되니 자신감이 떨어져 TDD를 사용하기로 했다. 여기서 나는 흥미로운 경험을 했다.</p>
<blockquote><p>
  물론 코딩 시험에 테스팅 도구는 주어지지 않았다. TDD는 테스팅 도구가 있어야만 할 수 있는 것이 아니다.</p>
<p>  이 글에서 테스트 케이스는 테스트 코드가 아니라 테스트 데이터를 의미한다.
</p></blockquote>
<p><span id="more-8237"></span></p>
<p>나는 시험 문제를 반영한 간단한 테스트 함수를 만들고 제시된 테스트 케이스와 몇가지 임의의 테스트 케이스를 추가했다. 답 코드를 쓰는 과정에서 지속적으로 테스트를 실행했고 모든 테스트 케이스가 성공한 후 면접관에게 코딩이 끝났다고 말했다.</p>
<p>즉시 면접관 중 한 명이 버그가 있으니 수정해 달라고 얘기했다. 나는 버그를 찾기 위해 무의식적으로 답 코드가 아니라 시험 문제 지문과 테스트 케이스 목록을 확인했다. 잠깐 살펴봤지만 안타깝게도 나는 버그를 발견하지 못했다. 면접관에게 버그를 찾지 못했다고 말하자 면접관은 버그를 설명하는 대신 테스트 케이스 하나를 추가했다. 나는 추가된 테스트 케이스가 실패하는 것을 확인한 후 답 코드에 논리 하나를 추가했다. 다시 테스트를 실행했고 모든 테스트 케이스에 대해 성공 표시가 출력됐다.</p>
<p>이것이 나에게 흥미로운 이유는 코딩 시험 과정이 소프트웨어를 만드는 한가지 유용한 프로세스 사례의 축소판이 되었기 때문이다. 프로그래머는 구현 코드가 아니라 요구사항과 요구사항의 구체적인 사례에 더 집중한다. 도메인 전문가나 품질 책임자는 발견된 버그를 재현 방법과 함께 프로그래머에 전달한다. 프로그래머는 버그를 반복 재현하며 코드를 고친다. 작업의 완료와 <a href="https://en.wikipedia.org/wiki/Software_regression">소프트웨어 회귀(software regression)</a>가 없음은 자동화된 테스팅을 통해 확인한다.</p>
<p>항상 코딩 시험의 평가자 역할을 수행하다 정말 오랜만에 응시자가 되었는데 이런 놀라운 경험을 하게 될 것이라고는 전혀 생각하지 못했다. 처음부터 버그 없는 답을 썼어도 좋았겠지만 나는 원래 완벽한 코드를 쓸 수 있는 사람이 아니다. 오히려 이번 경험이 앞으로 나에게 큰 영향을 줄 것으로 생각된다.</p>
]]></content:encoded>
							<wfw:commentRss>https://justhackem.wordpress.com/2019/01/05/coding-test-and-tdd/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/e94263d4b902a36e1e8bef828d8af42a?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">gyuwonyi</media:title>
		</media:content>
	</item>
		<item>
		<title>소프트웨어 테스팅의 False Positive</title>
		<link>https://justhackem.wordpress.com/2018/12/20/false-positive-in-software-testing/</link>
				<comments>https://justhackem.wordpress.com/2018/12/20/false-positive-in-software-testing/#comments</comments>
				<pubDate>Wed, 19 Dec 2018 16:52:57 +0000</pubDate>
		<dc:creator><![CDATA[Gyuwon]]></dc:creator>
				<category><![CDATA[일반]]></category>
		<category><![CDATA[false positive]]></category>
		<category><![CDATA[testing]]></category>

		<guid isPermaLink="false">http://justhackem.wordpress.com/?p=8222</guid>
				<description><![CDATA[False Positive는 이진 분류(binary classification) 실험 오류 중 하나로 통계 실험에서는 1종 오류(Type I Error)라고도 부르며 소프트웨어 테스팅에서도 쓰이는 용어다. 하지만 이진 분류와 통계 실험에 대한 배경지식이 없는 경우 소프트웨어 테스팅의 False Positive는 본래의 뜻과 반대의 의미로 잘 못 사용되곤 한다. 언어가 잘 못 사용되면 당연히 의사소통 장애로 이어진다. False Positive의 &#8216;positive&#8217;를 &#8216;긍정적&#8217;으로 이해하면 이런 [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>False Positive는 이진 분류(binary classification) 실험 오류 중 하나로 통계 실험에서는 1종 오류(Type I Error)라고도 부르며 소프트웨어 테스팅에서도 쓰이는 용어다. 하지만 이진 분류와 통계 실험에 대한 배경지식이 없는 경우 소프트웨어 테스팅의 False Positive는 본래의 뜻과 반대의 의미로 잘 못 사용되곤 한다. 언어가 잘 못 사용되면 당연히 의사소통 장애로 이어진다.</p>
<p><span id="more-8222"></span></p>
<p>False Positive의 &#8216;positive&#8217;를 &#8216;긍정적&#8217;으로 이해하면 이런 문제가 발생한다. 고민할 것 없이 &#8216;false&#8217;는 &#8216;거짓&#8217;이고 테스트 케이스의 성공은 프로그래머 입장에서 긍정적인 결과이니, False Positive를 테스트 케이스가 버그를 잡아내지 못하고 성공하는 상황이라 생각하는 것이다. 안타깝게도 이것은 완전히 오해다.</p>
<p>False Positive의 &#8216;positive&#8217;는 &#8216;양성&#8217;을 뜻한다. 테스트 케이스에게 양성반응이란 단언(assertion)이 참이라는 가설(귀무가설, null hypothesis)을 기각하고 프로그래머에게 &#8216;이봐, 내가 뭔가 발견했어!&#8217;라고 알려주는 것이다. 쉽게 말해 테스트 케이스 실패다. 그러니까 소프트웨어 테스팅에서 False Positive는 대상 코드가 정상이지만 테스트 케이스가 실패하는 경우를 뜻한다. 다음 표를 확인하자.</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>테스트 실패</strong></th>
<th><strong>테스트 성공</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>비정상 코드</strong></td>
<td>참 양성(True Positive)</td>
<td><strong><em>거짓 음성(False Negative)</em></strong></td>
</tr>
<tr>
<td><strong>정상 코드</strong></td>
<td><strong><em>거짓 양성(False Positive)</em></strong></td>
<td>참 음성(True Negative)</td>
</tr>
</tbody>
</table>
<blockquote><p>
  비슷하게 코드 분석기가 문제 없는 코드를 지적하는 것 역시 False Positive라고 부를 수 있다.
</p></blockquote>
<p>False Alarm이 False Positive와 동의어라는 것을 기억하면 False Negative(Type II Error)와의 혼동을 피할 수 있을 것이다. 테스트 케이스는 실패할 때 우리에게 경보(alarm)를 준다. 만약 이 경보가 거짓이라면 False Positive라는 용어로 상황을 표현할 수 있다.</p>
]]></content:encoded>
							<wfw:commentRss>https://justhackem.wordpress.com/2018/12/20/false-positive-in-software-testing/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/e94263d4b902a36e1e8bef828d8af42a?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">gyuwonyi</media:title>
		</media:content>
	</item>
		<item>
		<title>TDD가 해결해 주는 것들</title>
		<link>https://justhackem.wordpress.com/2018/06/24/what-tdd-solves/</link>
				<comments>https://justhackem.wordpress.com/2018/06/24/what-tdd-solves/#comments</comments>
				<pubDate>Sun, 24 Jun 2018 02:04:06 +0000</pubDate>
		<dc:creator><![CDATA[Gyuwon]]></dc:creator>
				<category><![CDATA[일반]]></category>
		<category><![CDATA[tdd]]></category>
		<category><![CDATA[testing]]></category>

		<guid isPermaLink="false">http://justhackem.wordpress.com/?p=8169</guid>
				<description><![CDATA[2014년에 DHH는 &#8216;TDD is dead. Long live testing.&#8217;이라는, 제목이 아니라 내용이, 다소 황당한 글을 썼고 얼마 후 Kent Beck은 관련된 글을 썼다. RIP TDD DHH가 TDD를 죽여서 TDD를 대신할 방법을 찾아야 한다는 글인데, 제대로 읽었다면 누구도 이것이 Kent Beck이 TDD를 떠난다고 말하는 글이라고는 생각하지 않을 것이다. 내 가설의 증거는 댓글들이다. 재미있으니 댓글들도 한 번 읽어보기를 [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>2014년에 DHH는 &#8216;TDD is dead. Long live testing.&#8217;이라는, 제목이 아니라 내용이, 다소 황당한 글을 썼고 얼마 후 Kent Beck은 관련된 글을 썼다.</p>
<h1><a href="https://www.facebook.com/notes/kent-beck/rip-tdd/750840194948847">RIP TDD</a></h1>
<p>DHH가 TDD를 죽여서 TDD를 대신할 방법을 찾아야 한다는 글인데, 제대로 읽었다면 누구도 이것이 Kent Beck이 TDD를 떠난다고 말하는 글이라고는 생각하지 않을 것이다. 내 가설의 증거는 댓글들이다. 재미있으니 댓글들도 한 번 읽어보기를 추천한다.</p>
<p>그럼 실제 내용은 뭘까? 프로그래머가 TDD를 통해 얻을 수 있는 가치의 나열이 대부분이고 나머지 조금은 DHH에 대한 조롱이다. 나는 여기에 나열된 TDD의 효과 모두를 느껴왔고 그래서 TDD를 사용한다. 그리고 이 가치들이 더욱 알려지기를 바라는 마음에 한국어로 번역했다. 내 영어 실력은 아주 형편 없어서, 노력했지만 두 구절은 충분히 이해하지 못해 직역했다. 표시해 뒀으니 좋은 해석 의견이 있다면 대환영이다. 이후로는 모두 내 글이 아니라 번역이다.</p>
<p><span id="more-8169"></span></p>
<p><em>DHH는 TDD를 역사의 단편으로 보내버렸습니다. 나는 슬픕니다. 내가 처음부터 역사의 단편에서 TDD를 구해 냈기 때문이 아니라, 프로그래밍 할 때 많은 문제를 해결할 수 있는 새로운 기법을 찾아야 하기 때문입니다.</p>
<ul>
<li>오버 엔지니어링. 나는 내가 &#8220;필요하게 될&#8221; 거라고 &#8220;알고 있는&#8221; 기능을 추가하려는 성향이 있습니다. 하나의 빨간(실패한) 테스트를 녹색으로(성공하도록) 만드는 것은 딱 충분한 만큼만 구현하도록 도와줍니다. 나는 집중을 유지할 새로운 방법을 찾아야 합니다.</p>
</li>
<li>API 피드백. 내 API 결정에 대한 빠른 피드백을 얻으려면 새로운 방법을 찾아야 합니다.</p>
</li>
<li>
<p>논리 오류. 내가 만들어내는 성가신 <a href='#comment-1'>*</a>테스트 감각 오류를 잡아낼 새로운 방법을 찾아야 합니다.</p>
</li>
<li>
<p>문서화. 내가 어떻게 API가 사용되기를 기대하는지 전달하고 개발 중에 생각했던 것을 기록하는 새로운 방법을 찾아야 합니다.</p>
</li>
<li>
<p><a href='#comment-2'>**</a>막막함. TDD를 사용해, 설사 구현을 상상할 수 없더라도 거의 언제나 테스트 작성법을 알아낼 수 있었던 방식을 그리워 할 것입니다. 나는 산을 한 걸음 더 오를 새로운 방법을 찾아야 합니다.</p>
</li>
<li>
<p>구현 사고와 인터페이스의 분리. 나는 구현의 추측으로 API 디자인 결정을 오염시키는 성향이 있습니다. 두 사고 수준을 분리하는 동시에 그것들 사이의 피드백을 신속하게 제공할 새로운 방법을 찾아야 합니다.</p>
</li>
<li>
<p>합의. 나는 프로그래밍 파트너와 내가 푸는 문제에 대해 명확해 질 수 있는 새로운 해결책을 찾아야 합니다.</p>
</li>
<li>
<p>걱정. 아마도 내가 가장 그리워 할 대상은 TDD가 즉각적인 &#8220;다 괜찮지?&#8221; 버튼을 제공한다는 것입니다.</p>
</li>
</ul>
<p>나는 이 모든 문제를 해결할 다른 방법을 찾을 수 있을 것이라 확신합니다. 때가 오면. 고통이 사라질 것입니다. 잘 가 오랜 친구 TDD.</p>
<p><span id='comment-1'>*</span> sense-of-test<br />
<span id='comment-2'>**</span> Feeling overwhelmed</em></p>
]]></content:encoded>
							<wfw:commentRss>https://justhackem.wordpress.com/2018/06/24/what-tdd-solves/feed/</wfw:commentRss>
		<slash:comments>4</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/e94263d4b902a36e1e8bef828d8af42a?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">gyuwonyi</media:title>
		</media:content>
	</item>
		<item>
		<title>Visual Studio Code를 사용해 Git 커밋 메시지 작성하기</title>
		<link>https://justhackem.wordpress.com/2018/01/30/writing-git-commit-messages-using-vscode/</link>
				<comments>https://justhackem.wordpress.com/2018/01/30/writing-git-commit-messages-using-vscode/#comments</comments>
				<pubDate>Tue, 30 Jan 2018 05:00:16 +0000</pubDate>
		<dc:creator><![CDATA[Gyuwon]]></dc:creator>
				<category><![CDATA[일반]]></category>
		<category><![CDATA[git]]></category>

		<guid isPermaLink="false">http://justhackem.wordpress.com/?p=7897</guid>
				<description><![CDATA[많은 팀이 그렇듯 지금 일하는 팀 역시 소스 관리를 위해 Git을 사용한다. 난 커밋 메시지를 중요하게 생각한다. 코드는 쓰는 것보다 읽는 것이 중요하다. 코드 자체에 의도를 담는 것이 최선이지만 코드를 통해 동작을 표현하기는 쉬운 반면 코드의 작성과 변경의 이유는 표현하기 어려운데 커밋 메시지는 좋은 대안이다. GitHub의 Blame이나 Visual Studio의 CodeLens는 코드 읽기를 도와주는 강력한 도구이지만 [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>많은 팀이 그렇듯 지금 일하는 팀 역시 소스 관리를 위해 Git을 사용한다. 난 커밋 메시지를 중요하게 생각한다. 코드는 쓰는 것보다 읽는 것이 중요하다. 코드 자체에 의도를 담는 것이 최선이지만 코드를 통해 동작을 표현하기는 쉬운 반면 코드의 작성과 변경의 이유는 표현하기 어려운데 커밋 메시지는 좋은 대안이다. GitHub의 <a href="https://help.github.com/articles/tracing-changes-in-a-file/">Blame</a>이나 Visual Studio의 <a href="https://docs.microsoft.com/en-us/visualstudio/ide/find-code-changes-and-other-history-with-codelens#find-changes-in-your-code">CodeLens</a>는 코드 읽기를 도와주는 강력한 도구이지만 이 역시 충실히 작성된 커밋 메시지가 뒷받침되어야 한다. 우리 팀은 양질의 커밋 메시지를 작성하려는 노력의 일환으로 <a href="http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">&#8217;50/72 규칙&#8217;</a>을 사용한다. 그런데 우리는 한글과 관련된 문제를 발견했다.</p>
<p><span id="more-7897"></span></p>
<p>&#8217;50/72 규칙&#8217;의 가장 중요한 내용만 설명하면 이렇다. 첫 줄에 50자 이내로 커밋 내용을 요약한다. 이것은 매우 유용하다. <code>git log --oneline</code>, <code>git rebase --interactive</code>, Blame, CodeLens 등의 도구를 사용할 때 한 줄의 짧은 요약이나 제목은 거의 필수다. 50자의 유래는 Linux 커널 커밋 메시지 길이의 산술평균 근사치라고 한다.</p>
<p>50자 요약으로 커밋을 설명하기에 부족하면 두번째 줄을 비우고 세번째 줄부터 상세 내용을 적는다. 세번째 줄부터는 한 줄을 72자 이내로 제한한다. 72자는 Git이 커밋 메시지를 보여줄 때 4자 들여쓰기를 하기 때문에 80자 출력을 기준으로 커밋 메시지를 중앙에 위치시키는 것이 목적이다.</p>
<p>사실 난 50과 72에 큰 의미를 두지는 않는다. 단지 Git을 사용하면서 커밋 메시지 줄 길이를 적정 수준에서 제한할 필요를 분명히 느껴왔기 때문에 잘 알려진 규칙을 선택한 것이다. 다른 팀원(프로그래머)들 모두 커밋 메시지 작성 규칙이 필요하다고 말한다. 우리는 Pull Request를 작성할 때에도 제목과 본문에 &#8217;50/72 규칙&#8217;을 적용한다. Pull Request가 완료되면 병합 커밋을 만드는 것이 정책이고 이때 Pull Request의 제목과 본문이 그대로 커밋 메시지가 되기 때문이다.</p>
<p>다음은 커밋 메시지의 한 사례다.</p>
<pre class="brush: plain; title: ; notranslate">
UserCommand 추상 기반 클래스를 추가한다

다음 명령 클래스가 UserCommand 클래스를 상속하도록 변경한다.
- CreateUserWithEmail
- ChangeUsername
- ChangeEmail
</pre>
<p>그런데 커밋 메시지를 작성할 때마다 각 줄의 글자 수를 세는 것은 괴로운 일이다. 현실적으로 불가능하다. 50과 72는 모두 반각 모양(halfwidth form) 기준이라는 것도 중요하다. 한글은 항상 전각 모양(fullwidth form)으로 출력되기 때문에 한글로 커밋 메시지를 작성할 때 &#8217;50/72 규칙&#8217;은 글자 수 기준이 아니게 된다. 더 심각한 문제는 한글을 고려해서 만들어진 글꼴이 아닌 경우 한글 문자의 너비가 정확히 반각 모양 너비의 두 배가 사용됨을 보장하지 않는다는 것이다.</p>
<p><img data-attachment-id="8005" data-permalink="https://justhackem.wordpress.com/2018/01/30/writing-git-commit-messages-using-vscode/halfwidth-vs-fullwidth/" data-orig-file="https://justhackem.files.wordpress.com/2018/01/halfwidth-vs-fullwidth.png?w=625" data-orig-size="1920,1720" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="halfwidth-vs-fullwidth" data-image-description="" data-medium-file="https://justhackem.files.wordpress.com/2018/01/halfwidth-vs-fullwidth.png?w=625?w=300" data-large-file="https://justhackem.files.wordpress.com/2018/01/halfwidth-vs-fullwidth.png?w=625?w=625" class="alignnone size-full wp-image-8005" src="https://justhackem.files.wordpress.com/2018/01/halfwidth-vs-fullwidth.png?w=625" alt="halfwidth-vs-fullwidth" srcset="https://justhackem.files.wordpress.com/2018/01/halfwidth-vs-fullwidth.png?w=625 625w, https://justhackem.files.wordpress.com/2018/01/halfwidth-vs-fullwidth.png?w=1250 1250w, https://justhackem.files.wordpress.com/2018/01/halfwidth-vs-fullwidth.png?w=150 150w, https://justhackem.files.wordpress.com/2018/01/halfwidth-vs-fullwidth.png?w=300 300w, https://justhackem.files.wordpress.com/2018/01/halfwidth-vs-fullwidth.png?w=768 768w, https://justhackem.files.wordpress.com/2018/01/halfwidth-vs-fullwidth.png?w=1024 1024w" sizes="(max-width: 625px) 100vw, 625px"   /></p>
<p>왼쪽 상단부터 시계 방향으로 Git Bash, 메모장, Visual Studio Code, Visual Studio에서 한글 문자의 너비를 확인한 그림이다. 모두 글꼴은 Consolas, 9pt로 동일한데 한글 문자 너비는 제각각이다. 오직 Git Bash만 한글 문자 하나에 반각 모양 두 배의 너비를 할애한다.</p>
<p>진심으로 고맙게도 네이버가 만든 <a href="https://github.com/naver/d2codingfont">D2 Coding 글꼴</a>은 한글을 고려해 만든 고정폭 글꼴이며 누구나 자유롭게 사용할 수 있도록 배포하고 있다. 우리 팀은 이 글꼴이 한글 문자를 반각 모양의 정확히 두 배 너비로 그리는 것을 다양한 환경에서 확인했다. 안타까운 사실이 있다면 우리 중 누구도 이 글꼴을 좋아하지 않는다는 것이다. 보기 싫은 글꼴을 사용해 코딩하는 것은 많은 프로그래머에게 고문과 같다.</p>
<p>다행히 Visual Studio Code는 우리가 가진 모든 문제를 해결한다. 우선 다음 명령을 사용해 Git의 편집기를 Visual Studio Code로 설정한다.</p>
<pre class="brush: plain; title: ; notranslate">
$ git config --global core.editor "code --wait"
</pre>
<p>이제 <code>-m</code> 인자를 생략하고 <code>git commit</code> 명령을 입력하면 Visual Studio Code 창이 열리고 커밋 메시지를 작성할 수 있다. 커밋 메시지 작성을 완료하고 파일을 저장한 후 탭이나 창을 닫으면 커밋이 완료된다. 이 때 Visual Studio Code는 편집기 언어 모드를 Git Commit Message로 선택한다.</p>
<p>Visual Studio Code는 편집기 언어 모드 별 설정을 제공한다. Git Commit Message 언어에 대해 다음과 같이 설정하면 편집기의 언어 모드가 Git Commit Message일 때만 D2 Coding 글꼴을 사용하고 반각 모양 기준 50자 눈금자와 72자 눈금자를 보여준다. D2 Coding 글꼴을 좋아하지 않는 프로그래머도 커밋 메시지를 작성하는 잠깐 동안은 견딜 수 있을 것이다.</p>
<pre class="brush: plain; title: ; notranslate">
{
    "[git-commit]": {
        "editor.fontFamily": "D2Coding",
        "editor.rulers": [
            50,
            72
        ]
    }
}
</pre>
<p>다음 그림의 왼쪽 편집기 언어 모드는 Plain Text이고 오른쪽 편집기 언어 모드는 Git Commit Message다. 왼쪽 편집기의 글꼴은 Consolas임에 반해 오른쪽 편집기의 글꼴은 D2 Coding이고 50자 눈금자와 72자 눈금자가 그려진다.</p>
<p><img data-attachment-id="8083" data-permalink="https://justhackem.wordpress.com/2018/01/30/writing-git-commit-messages-using-vscode/plaintext-vs-gitcommitmessage/" data-orig-file="https://justhackem.files.wordpress.com/2018/01/plaintext-vs-gitcommitmessage.png?w=625" data-orig-size="2450,924" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="plaintext-vs-gitcommitmessage" data-image-description="" data-medium-file="https://justhackem.files.wordpress.com/2018/01/plaintext-vs-gitcommitmessage.png?w=625?w=300" data-large-file="https://justhackem.files.wordpress.com/2018/01/plaintext-vs-gitcommitmessage.png?w=625?w=625" class="alignnone size-full wp-image-8083" src="https://justhackem.files.wordpress.com/2018/01/plaintext-vs-gitcommitmessage.png?w=625" alt="plaintext-vs-gitcommitmessage" srcset="https://justhackem.files.wordpress.com/2018/01/plaintext-vs-gitcommitmessage.png?w=625 625w, https://justhackem.files.wordpress.com/2018/01/plaintext-vs-gitcommitmessage.png?w=1250 1250w, https://justhackem.files.wordpress.com/2018/01/plaintext-vs-gitcommitmessage.png?w=150 150w, https://justhackem.files.wordpress.com/2018/01/plaintext-vs-gitcommitmessage.png?w=300 300w, https://justhackem.files.wordpress.com/2018/01/plaintext-vs-gitcommitmessage.png?w=768 768w, https://justhackem.files.wordpress.com/2018/01/plaintext-vs-gitcommitmessage.png?w=1024 1024w" sizes="(max-width: 625px) 100vw, 625px"   /></p>
<p>이제 한글이 포함된 커밋 메시지를 작성할 때 D2 Coding 글꼴과 눈금자의 도움을 받아 &#8217;50/72 규칙&#8217;을 쉽게 지킬 수 있다.</p>
<p>이렇게 우리 팀은 &#8217;50/72 규칙&#8217;과 Visual Studio Code를 사용해 Git 커밋 메시지를 관리한다. 한 번 더 얘기하지만 코드는 쓰는 것보다 읽는 것이 중요하다. 커밋 역시 마찬가지다. 좋은 커밋 메시지를 작성하기 위해 들이는 노력은 품질 낮은 메시지를 가진 커밋들을 읽는 수고스러움에 비해면 아주 저렴하다. 커밋 메시지 관리를 위해 반드시 &#8217;50/72 규칙&#8217;을 채택할 필요는 없다. 각 팀 실정에 맞는 규칙을 선택해 지켜나가면 된다. 기본적인 규칙들을 기억하고 준수하는 것이 좋은 코드베이스를 확보하는 유일한 방법임을 잊지말자.</p>
]]></content:encoded>
							<wfw:commentRss>https://justhackem.wordpress.com/2018/01/30/writing-git-commit-messages-using-vscode/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/e94263d4b902a36e1e8bef828d8af42a?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">gyuwonyi</media:title>
		</media:content>

		<media:content url="https://justhackem.files.wordpress.com/2018/01/halfwidth-vs-fullwidth.png" medium="image">
			<media:title type="html">halfwidth-vs-fullwidth</media:title>
		</media:content>

		<media:content url="https://justhackem.files.wordpress.com/2018/01/plaintext-vs-gitcommitmessage.png" medium="image">
			<media:title type="html">plaintext-vs-gitcommitmessage</media:title>
		</media:content>
	</item>
		<item>
		<title>그게 통합 테스트라고? 정말?</title>
		<link>https://justhackem.wordpress.com/2018/01/16/is-that-integration-test-really/</link>
				<comments>https://justhackem.wordpress.com/2018/01/16/is-that-integration-test-really/#comments</comments>
				<pubDate>Tue, 16 Jan 2018 08:52:35 +0000</pubDate>
		<dc:creator><![CDATA[Gyuwon]]></dc:creator>
				<category><![CDATA[일반]]></category>

		<guid isPermaLink="false">http://justhackem.wordpress.com/?p=7604</guid>
				<description><![CDATA[글을 시작하며 우선 참회한다. 나는 오래 전 mockist였다. 당시의 나를 비롯해 mockist들은 단위 테스팅에 많은 테스트 대역(test double)을 등장시키고 그래야만 단위 테스팅이며 그렇지 않으면 통합 테스팅이라고 주장한다. 하지만 미안, 난 이제 변절자야. 예전에 &#8216;단위 테스팅과 통합, 승인, 기능 테스팅&#8217;이란 글을 작성했다. 제목처럼 단위 테스팅, 통합 테스팅, 기능 테스팅이란 용어를 설명하는 글이다. 그런데 다른 용어에 비해 [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>글을 시작하며 우선 참회한다. 나는 오래 전 mockist였다.</p>
<p>당시의 나를 비롯해 mockist들은 단위 테스팅에 많은 테스트 대역(test double)을 등장시키고 그래야만 단위 테스팅이며 그렇지 않으면 통합 테스팅이라고 주장한다. 하지만 미안, 난 이제 변절자야.</p>
<p><span id="more-7604"></span>예전에 <a href="https://justhackem.wordpress.com/2016/05/23/unit-integration-acceptance-and-functional-testing/">&#8216;단위 테스팅과 통합, 승인, 기능 테스팅&#8217;</a>이란 글을 작성했다. 제목처럼 단위 테스팅, 통합 테스팅, 기능 테스팅이란 용어를 설명하는 글이다. 그런데 다른 용어에 비해 통합 테스팅은 상대적으로 내용이 간소하다. 길게 설명하고 싶지 않았기 때문인데 불친절하게도 그 이유에 대해서는 적지 않았다.</p>
<p>나는 대부분의 코드를 TDD로 작성하지만 요즘은 테스팅이나 TDD와 관련된 이슈에 별 관심이 없다. 테스팅과 TDD에 대해 더 알고 싶은 것이 없기 때문이다. 모든 것을 알고있는 것이 아니라 코드를 작성하거나 주변의 테스팅 관련 논의를 지켜보면서 이해하지 못해 불편한 것이 발견되지 않는 것이다. 예를 들어 더이상 mockist가 아니게 된 후로 나는 단위 테스트 코드와 통합 테스트 코드를 잘 구별하지 못하게 되었지만 상관없다. 게다가 둘을 구별하는 것은 이제 나에게 별로 중요하지 않다. 그러다보니 통합 테스팅에 대해 잘 얘기하지 않는다.</p>
<p>나는 테스트 케이스를 작성할 때 단위 테스팅을 할지 통합 테스팅을 할지 심각하게 판단하지 않는다. 다시 말하지만 그건 나에게 별 의미가 없는 고민이다. 중요한 것은 테스트 케이스가 없음으로 인해 불안함을 느끼는지다. 불안함의 원인은 주로 두가지다. 코드가 복잡해 요구사항을 충족시키는지 확신하지 못하거나 쉬운 코드이지만 행여나 잘 못 되었을 때 그 피해가 심각한 경우. 이 기준을 따르면 단위 테스팅과 통합 테스팅의 차이는 주요 관심사가 아니게 된다.</p>
<p>세 가지 시나리오를 살펴보자.</p>
<hr />
<h2>시나리오 1</h2>
<p>여러 개의 상품 가격 합계를 계산해 JSON 형식으로 출력하는 시스템(응집된 코드 집합)을 작성한다. JSON 직렬화 도구로 .NET 생태계에서 가장 보편적으로 쓰이고 긴 역사를 가진 Json.NET을 선택했다. 이 시스템의 단위 테스트 케이스를 작성하기 위해 Json.NET의 테스트 대역을 만들지는 않을 것이다. 사용하기 쉽고 올바른 동작을 기대할 수 있는 패키지이기 때문이다. 더 극단적인 예로, <code>+</code> 연산자의 테스트 대역을 만드는 것은 어리석은 짓이다. 제정신인가?</p>
<hr />
<h2>시나리오 2</h2>
<p>서비스 시스템과 이 시스템을 이용하는 클라이언트 시스템을 만든다. 서비스 시스템은 클라이언트 시스템과 동일한 프로세스에서 구동되는 개체이며 어렵지 않게 인스턴스를 생성할 수 있다. 서비스 시스템의 공개 API는 설계가 완료되었지만 서비스 시스템을 개발할 프로그래머가 휴무라 API를 기준으로 클라이언트 시스템이 먼저 개발된다. 아직 서비스 시스템은 만들어지지 않았기 때문에 클라이언트 시스템을 단위 테스트 하기 위해 서비스 시스템의 테스트 대역을 사용한다. 이후 서비스 시스템이 만들어지고 모든 요구사항에 대해 테스트 된다. 두 시스템이 모두 테스트 되었지만 두 시스템이 통합되었을 때에도 요구사항을 제대로 만족할지는 확신할 수 없다. 불안함을 느낀 프로그래머는 클라이언트 시스템이, 테스트 대역이 아닌, 실제 서비스 시스템 인스턴스를 사용하도록 설정해 통합 테스팅을 수행한다.</p>
<hr />
<h2>시나리오 3</h2>
<p>시나리오 2와 동일한 프로그램을 개발하지만 이번 시나리오에서는 서비스 시스템이 먼저 개발된다. 서비스 시스템이 요구사항을 모두 만족하는 것을 단위 테스팅을 통해 검증한다. 이제 클라이언트 시스템을 만들 차례고 단위 테스팅도 함께 진행한다. 이번엔 클라이언트 시스템을 단위 테스트 하기 위해 서비스 시스템의 테스트 대역을 만들지는 않는다. 시나리오 1에서 Json.NET이나 <code>+</code> 연산자의 테스트 대역을 만들지 않는 것과 동일한 이유에서다. 서비스 시스템은 충분히 테스트 되어 신뢰할 수 있고 테스트 코드에서 사용하기 쉽기 때문이다.</p>
<hr />
<p>시나리오 1을 통해 테스트 대역이 사용되지 않는다고 해서 그것이 항상 통합 테스팅이라고 볼 수 없다는 것을 보였고 시나리오 3을 통해 신뢰할 수 있는 시스템이 단위 테스팅에 이용되는 것은 문제될 것이 없다는 것을 설명했다. 또한 시나리오 2의 통합 테스트 케이스와 시나리오 3의 클라이언트 시스템 단위 테스트 케이스는 그 결과물이 동일하거나 거의 다르지 않다는 것 또한 유추할 수 있다.</p>
<blockquote><p>
  시나리오 3의 클라이언트 시스템 단위 테스트와 같은 유형을 &#8216;Sociable Unit Tests&#8217;라고 부른다. Martin Fowler의 <a href="https://martinfowler.com/bliki/UnitTest.html">이 글</a>을 참고하라.
</p></blockquote>
<p>물론 통합 테스팅으로 확실히 분류될 수 있는 경우도 있다. 하지만 테스트 대역을 사용하지 않으면 통합 테스팅이라는 주장은 받아들일 수 없다. 기능 테스팅과는 달리 이런 테스팅의 상당수는 테스트 케이스의 작성 및 실행 비용을 증가시키지도 않는다.</p>
<p>내가 mockist가 아니라는 것이 테스트 대역을 절대 사용하지 않는다는 것을 의미하지는 않는다. 원격 서비스에 의존하는 개체를 단위 테스트 하기 위해 실제 서비스를 구동시키는 것은 어리석은 짓이다. 하지만 가급적 자제하고 필요하다고 생각되는 곳에만 사용한다. Kent Beck도 테스트 대역을 잘 사용하지 않는다고 말했는데 내가 classicist가 된 주요 계기 중 하나로 작용했다. 테스트 대역은 일종의 가정이고 가정이 늘어날 수록 실제 결과는 예측하기 어려워진다.</p>
<p>나는 새 코드를 작성할 때 단위 테스트 케이스를 작성하고, 이미 작성된 둘 이상의 시스템이 조립되어 잘 동작하는지 확인할 때 통합 테스트 케이스를 작성한다. 목적이 둘의 구분 기준이다. 형식은 중요하지 않다.</p>
<p>Write tests. Mostly unit.</p>
<p>참고 글</p>
<ul>
<li><a href="https://martinfowler.com/articles/mocksArentStubs.html">Mocks Aren&#8217;t Stubs</a></li>
<li><a href="https://www.thoughtworks.com/insights/blog/mockists-are-dead-long-live-classicists">Mockists Are Dead. Long Live Classicists.</a></li>
</ul>
]]></content:encoded>
							<wfw:commentRss>https://justhackem.wordpress.com/2018/01/16/is-that-integration-test-really/feed/</wfw:commentRss>
		<slash:comments>6</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/e94263d4b902a36e1e8bef828d8af42a?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">gyuwonyi</media:title>
		</media:content>
	</item>
		<item>
		<title>테스트 주도 개발 실천</title>
		<link>https://justhackem.wordpress.com/2017/10/31/practicing-test-driven-development/</link>
				<comments>https://justhackem.wordpress.com/2017/10/31/practicing-test-driven-development/#comments</comments>
				<pubDate>Tue, 31 Oct 2017 08:30:46 +0000</pubDate>
		<dc:creator><![CDATA[Gyuwon]]></dc:creator>
				<category><![CDATA[일반]]></category>
		<category><![CDATA[tdd]]></category>
		<category><![CDATA[testing]]></category>

		<guid isPermaLink="false">http://justhackem.wordpress.com/?p=7586</guid>
				<description><![CDATA[테스트 주도 개발 실천 테스트 주도 개발(test-driven development)은 점진적으로 검증하며 코드를 작성하는 소프트웨어 개발 방법이다. 자신이 작성한 코드의 동작을 직접 확인하는 것은 어쩌면 프로그래머의 기본 미덕이고 테스트 주도 개발은 이 미덕의 실천을 프로그래밍 과정 속에 자연스레 녹여낸다. 또한 테스트 주도 개발은 좋은 설계의 강력한 지원자다. 테스트 주도 개발 자체가 좋은 설계를 유도하는 것은 아니지만 프로그래머가 [&#8230;]]]></description>
								<content:encoded><![CDATA[<h1>테스트 주도 개발 실천</h1>
<p>테스트 주도 개발(test-driven development)은 점진적으로 검증하며 코드를 작성하는 소프트웨어 개발 방법이다. 자신이 작성한 코드의 동작을 직접 확인하는 것은 어쩌면 프로그래머의 기본 미덕이고 테스트 주도 개발은 이 미덕의 실천을 프로그래밍 과정 속에 자연스레 녹여낸다. 또한 테스트 주도 개발은 좋은 설계의 강력한 지원자다. 테스트 주도 개발 자체가 좋은 설계를 유도하는 것은 아니지만 프로그래머가 좋은 설계를 위해 노력할 수 있도록 든든히 뒷받침한다.</p>
<p>하지만 테스트 주도 개발은 어렵다. 전통적인 프로그래밍 절차와 상이할 뿐 아니라 긴 시간동안 몸에 밴 나쁜 버릇들이 억제되며 답답함이 느껴지기도 한다. 개념을 이해했다 하더라도 현장에서 실천하는 데에는 많은 장벽들이 있다. 이 글은 가상의 예제가 아니라 간단하지만 실제 서비스 개발에 사용된 사례를 통해 현장에서 테스트 주도 개발이 어떻게 적용되는지 보여준다.</p>
<p><span id="more-7586"></span></p>
<p>사용되는 코드는 계정 관리를 담당하는 도메인 모델의 초기 버전이다. 도메인 모델은 <code>CreateUserWithEmail</code> 명령을 전달받아 <code>UserCreated</code> 도메인 이벤트와 <code>EmailChanged</code> 도메인 이벤트를 발생시키는데 이 과정에 사용되는 일부 코드가 대상이다. 도메인 모델은 이벤트 소싱을 사용하고 코드는 C#으로 작성되지만 이벤트 소싱 패턴과 .NET 기술에 대한 사전 지식이 필수는 아니다. 이 글의 목적은 깊은 기술적 이해가 아니라 현장의 프로젝트에서 테스트 주도 개발이 실천되는 과정과 설계를 개선하는 사례를 소개하는 것이다. 이를 이해하기 위해 필요한 지식은 적당한 수준에서 설명한다.</p>
<h1>UserCreated 도메인 이벤트</h1>
<p>먼저 <code>UserCreated</code> 도메인 이벤트를 작성한다. 완성된 코드를 미리 확인하면 다음과 같다.</p>
<pre class="brush: csharp; title: ; notranslate">
public class UserCreated : DomainEvent, IUniqueIndexedDomainEvent
{
    public string Username { get; set; }

    [JsonIgnore]
    public IReadOnlyDictionary&lt;string, string&gt; UniqueIndexedProperties
        =&gt; new Dictionary&lt;string, string&gt;
        {
            [nameof(Username)] = Username
        };
}
</pre>
<p><code>UserCreated</code> 클래스는 <code>DomainEvent</code> 클래스를 상속해 이벤트 소싱의 도메인 이벤트 역할을 수행하며 <code>IUniqueIndexedDomainEvent</code> 인터페이스를 구현해 <code>Username</code> 속성이 유일성 제약에 적용받게 한다. 이 클래스는 총 5개의 테스트 케이스를 통해 작성되었다. 그 과정을 살펴보자.</p>
<h2>테스트 케이스: DomainEvent 클래스를 상속한다.</h2>
<h3>테스트 케이스 실패</h3>
<p><code>UserCreated</code> 클래스를 작성하면서 가장 먼저 추가된 테스트 케이스다.</p>
<pre class="brush: csharp; title: ; notranslate">
[Fact]
public void sut_inherits_DomainEvent()
{
    typeof(UserCreated).BaseType.Should().Be(typeof(DomainEvent));
}
</pre>
<p><code>[Fact]</code>는 테스트 프레임워크 <a href="https://xunit.github.io">xUnit.net</a>에서 매개변수를 가지지 않는 테스트 케이스 메서드를 의미한다.</p>
<p>SUT는 &#8216;system under test&#8217;의 약자로 테스트 대상을 의미한다. 테스트 대상은 테스트 케이스에 따라 형식, 개체, 속성, 메서드 등 다양한 코드 요소가 될 수 있다.</p>
<p>C#은 강력한 형 체계 기반의 언어다. 따라서 위 테스트 케이스가 컴파일되고 실행되려면 <code>UserCreated</code> 클래스가 존재해야 한다. 테스트 케이스를 실행하기 위한 최소한의 프로덕션 코드를 작성한다.</p>
<pre class="brush: csharp; title: ; notranslate">
public class UserCreated
{
}
</pre>
<p>테스트 케이스를 실행하면 다음 오류 메시지와 함께 실패한다.</p>
<pre class="brush: plain; title: ; notranslate">
Test Name:  sut_inherits_DomainEvent
Test FullName:  Conto.Identity.Events.UserCreated_specs.sut_inherits_DomainEvent
Test Source:    C:\Users\gyuwon\Documents\Projects\Conto\source\Identity\Conto.Identity.Tests.Unit\Identity\Events\UserCreated_specs.cs : line 15
Test Outcome:   Failed
Test Duration:  0:00:00.026

Result StackTrace:  
at FluentAssertions.Execution.XUnit2TestFramework.Throw(String message)
   at FluentAssertions.Execution.AssertionScope.FailWith(String message, Object[] args)
   at FluentAssertions.Types.TypeAssertions.Be(Type expected, String because, Object[] becauseArgs)
   at Conto.Identity.Events.UserCreated_specs.sut_inherits_DomainEvent() in C:\Users\gyuwon\Documents\Projects\Conto\source\Identity\Conto.Identity.Tests.Unit\Identity\Events\UserCreated_specs.cs:line 12
Result Message: Expected type to be Khala.EventSourcing.DomainEvent, but found System.Object.
</pre>
<p>중요한 것은 마지막 줄의 결과 메시지다. 메시지는 형식(<code>UserCreated</code> 클래스의 기반 클래스)이 <code>Khala.EventSourcing.DomainEvent</code>일 것으로 기대했지만 실제로는 <code>System.Object</code>라는 내용을 담는다. 즉 <code>UserCreated</code> 클래스가 <code>DomainEvent</code>를 상속받지 않았기 때문에 테스트 케이스가 실패한 것이다. 테스트 케이스의 검증력을 보여주는 결과이므로 다음 단계로 진행할 수 있다. 이것을 확인하는 것은 매우 중요하다. 엉터리 테스트 케이스를 작성하고서 테스트 케이스가 실패했으니 괜찮다고 착각하는 우를 범하지 말자.</p>
<h3>테스트 케이스 성공</h3>
<p>테스트 케이스를 성공시키는 가장 쉽고 확실한 방법은 <code>UserCreated</code> 클래스의 기반 클래스를 <code>DomainEvent</code>로 만드는 것이다.</p>
<pre class="brush: csharp; title: ; notranslate">
public class UserCreated : DomainEvent
{
}
</pre>
<p>이제 <code>sut_inherits_DomainEvent</code> 테스트 케이스를 실행하면 성공한다.</p>
<h2>테스트 케이스: Username 속성을 가진다.</h2>
<p>사용자 엔터티가 생성될 때 사용자 이름을 필수 정보로 설계했기 때문에 <code>UserCreated</code> 도메인 이벤트는 <code>Username</code> 문자열 속성을 가져야 한다.</p>
<h3>테스트 케이스 실패</h3>
<pre class="brush: csharp; title: ; notranslate">
[Fact]
public void sut_has_Username_property()
{
    typeof(UserCreated).Should().HaveProperty&lt;string&gt;(&quot;Username&quot;);
}
</pre>
<h3>테스트 케이스 성공</h3>
<p><code>UserCreated</code> 클래스에 <code>Username</code> 속성을 추가하면 <code>sut_has_Username_property</code> 테스트 케이스는 성공한다.</p>
<pre class="brush: csharp; title: ; notranslate">
public class UserCreated : DomainEvent
{
    public string Username { get; set; }
}
</pre>
<h2>테스트 케이스: IUniqueIndexedDomainEvent 인터페이스를 구현한다.</h2>
<p>사용자 이름은 도메인 모델 내에서 유일해야 한다고 설계했다. 일반적으로 이벤트 소싱은 쓰기 모델에서 속성 값의 유일성을 고려하지 않지만 우리가 사용한 이벤트 소싱 프레임워크는 관계형 데이터베이스를 이벤트 저장소로 사용하는 경우 <code>IUniqueIndexedDomainEvent</code> 인터페이스를 통해 문자열 속성의 유일성 제약을 지원한다.</p>
<h3>테스트 케이스 실패</h3>
<pre class="brush: csharp; title: ; notranslate">
[Fact]
public void sut_implements_IUniqueIndexedDomainEvent()
{
    typeof(UserCreated).Should().Implement&lt;IUniqueIndexedDomainEvent&gt;();
}
</pre>
<h3>테스트 케이스 성공</h3>
<p><code>UserCreated</code> 클래스가 <code>IUniqueIndexedDomainEvent</code> 인터페이스를 구현하게 한다. 도메인 모델 설계에 의하면 <code>UniqueIndexedProperties</code> 속성이 사용자 이름 정보를 담아야 하지만 테스트 케이스 <code>sut_implements_IUniqueIndexedDomainEvent</code>는 멤버 구현에는 관여하지 않는다. 따라서 이 단계에서 <code>UniqueIndexedProperties</code> 속성의 구현은 컴파일이 실패하지 않을 만큼만 작성해야 한다.</p>
<pre class="brush: csharp; title: ; notranslate">
public class UserCreated : DomainEvent, IUniqueIndexedDomainEvent
{
    public string Username { get; set; }

    public IReadOnlyDictionary&lt;string, string&gt; UniqueIndexedProperties
        =&gt; new Dictionary&lt;string, string&gt;();
}
</pre>
<p>이제 <code>sut_implements_IUniqueIndexedDomainEvent</code> 테스트 케이스는 성공한다.</p>
<h2>테스트 케이스: UniqueIndexedProperties 속성이 사용자 이름 정보를 포함한다.</h2>
<p><code>UserCreated</code> 도메인 이벤트는 <code>IUniqueIndexedDomainEvent</code> 인터페이스를 구현하지만 <code>UniqueIndexedProperties</code> 속성이 <code>Username</code> 속성 정보를 포함해야 사용자 이름이 유일하다는 설계가 모두 반영된다.</p>
<h3>테스트 케이스 실패</h3>
<pre class="brush: csharp; title: ; notranslate">
[Fact]
public void UniqueIndexedProperties_contains_Username_property()
{
    var sut = new UserCreated { Username = GenerateUsername() };
    IReadOnlyDictionary&lt;string, string&gt; actual = sut.UniqueIndexedProperties;
    actual.Should().Contain(p =&gt; p.Key == &quot;Username&quot; &amp;&amp; p.Value == sut.Username);
}

private string GenerateUsername() =&gt; $&quot;Username-{Guid.NewGuid()}&quot;;
</pre>
<p>테스트 케이스 <code>UniqueIndexedProperties_contains_Username_property</code>는 임의의 사용자 이름을 사용해 <code>UserCreated</code> 개체를 생성하고 <code>UniqueIndexedProperties</code> 속성이 <code>Username</code> 정보를 포함하는지 검사한다. 테스트 케이스를 실행하면 실패한다.</p>
<h3>테스트 케이스 성공</h3>
<pre class="brush: csharp; title: ; notranslate">
public class UserCreated : DomainEvent, IUniqueIndexedDomainEvent
{
    public string Username { get; set; }

    public IReadOnlyDictionary&lt;string, string&gt; UniqueIndexedProperties
        =&gt; new Dictionary&lt;string, string&gt;
        {
            [nameof(Username)] = Username
        };
}
</pre>
<p>이제 <code>UniqueIndexedProperties</code> 속성이 반환하는 사전은 <code>Username</code> 속성 정보를 포함한다. 테스트 케이스 <code>UniqueIndexedProperties_contains_Username_property</code>를 실행하면 성공한다.</p>
<h2>테스트 케이스: UniqueIndexedProperties 속성은 JSON 직렬화 대상이 아니다.</h2>
<p>도메인 이벤트는 메시지다. 메시지는 프로세스 범위를 넘어 전달되고 이 과정에 직렬화가 사용된다. 그런데 <code>UniqueIndexedProperties</code> 속성은 다른 속성을 통해 계산되는 속성이기 때문에 직렬화하지 않으면 메시지 전달 및 기록 비용을 줄일 수 있다.</p>
<h3>테스트 케이스 실패</h3>
<p>우리는 직렬화를 위해 JSON을 사용한다. 속성이 <code>[JsonIgnore]</code> 특성으로 수식되면 JSON 직렬화기는 해당 속성을 직렬화에서 제외시킨다. 다음 테스트 케이스는 <code>UniqueIndexedProperties</code> 속성이 <code>[JsonIgnore]</code> 특성으로 수식되는지 검사한다.</p>
<pre class="brush: csharp; title: ; notranslate">
[Fact]
public void UniqueIndexedProperties_is_decorated_with_JsonIgnore()
{
    typeof(UserCreated)
        .GetProperty(&quot;UniqueIndexedProperties&quot;)
        .Should()
        .BeDecoratedWith&lt;JsonIgnoreAttribute&gt;();
}
</pre>
<p>아직 <code>UniqueIndexedProperties</code> 속성은 <code>[JsonIgnore]</code> 특성으로 수식되지 않기 때문에 테스트 케이스는 실패한다.</p>
<h3>테스트 케이스 성공</h3>
<p><code>UniqueIndexedProperties</code> 속성을 <code>[JsonIgnore]</code> 특성으로 수식한다.</p>
<pre class="brush: csharp; title: ; notranslate">
public class UserCreated : DomainEvent, IUniqueIndexedDomainEvent
{
    public string Username { get; set; }

    [JsonIgnore]
    public IReadOnlyDictionary&lt;string, string&gt; UniqueIndexedProperties
        =&gt; new Dictionary&lt;string, string&gt;
        {
            [nameof(Username)] = Username
        };
}
</pre>
<p>테스트 케이스 <code>UniqueIndexedProperties_is_decorated_with_JsonIgnore</code>를 실행하면 성공한다.</p>
<h1>CreateUserWithEmail 명령</h1>
<p>이벤트 소싱에서 도메인 이벤트는 이미 발생한 돌이킬 수 없는 과거의 사실이기 때문에 검증 대상이 아니지만 명령은 실행되기 전에 반드시 검증되어야 한다. 우리는 명령에 불변성을 부여하고 상태 검증은 생성자 매개변수 방어구문 대신 <code>System.ComponentModel.DataAnnotations.Validator</code> 클래스를 사용하기로 결정했다. 명령에 불변성을 부여하면 명령 상태에 대한 검증은 명령 처리 절차의 진입점에서만 수행하면 된다.</p>
<blockquote><p>
  명령 상태 검증에 생성자 매개변수 방어구문을 사용하지 않는 이유가 있지만 테스트 주도 개발과 직접 관련된 문제가 아니라 이 글에서 설명하지 않는다.
</p></blockquote>
<p><code>CreateUserWithEmail</code> 명령의 <code>Email</code> 속성을 만드는 과정을 소개한다. <code>Email</code> 속성이 추가되기 전의 <code>CreateUserWithEmail</code> 클래스는 다음과 같다.</p>
<pre class="brush: csharp; title: ; notranslate">
public class CreateUserWithEmail : IValidatableObject
{
    public CreateUserWithEmail(Guid userId, string username)
    {
        UserId = userId;
        Username = username;
    }

    public Guid UserId { get; }

    [Required]
    [Username]
    public string Username { get; }

    IEnumerable&lt;ValidationResult&gt; IValidatableObject.Validate(ValidationContext validationContext)
    {
        if (UserId == Guid.Empty)
        {
            yield return new ValidationResult(&quot;Value cannot be empty.&quot;, new[] { nameof(UserId) });
        }
    }
}
</pre>
<h2>테스트 케이스: Email 속성을 가진다.</h2>
<p>우선 <code>CreateUserWithEmail</code> 명령은 <code>Email</code> 문자열 속성을 정의해야 한다.</p>
<h3>테스트 케이스 실패</h3>
<pre class="brush: csharp; title: ; notranslate">
[Fact]
public void sut_has_Email_property()
{
    typeof(CreateUserWithEmail)
        .Should()
        .HaveProperty&lt;string&gt;(&quot;Email&quot;)
        .Which
        .Should()
        .NotBeWritable();
}
</pre>
<p>명령 개체가 불변성을 가져야 하기 때문에 테스트 케이스 <code>sut_has_Email_property</code>는 <code>CreateUserWithEmail</code> 클래스가 <code>Email</code> 속성을 갖는지 여부와 더불어 해당 속성이 쓰기 접근자를 가지지 않는지도 검사한다. <code>CreateUserWithEmail</code> 클래스는 아직 <code>Email</code> 속성을 가지지 않기 때문에 테스트 케이스는 실패한다.</p>
<h3>테스트 케이스 성공</h3>
<p><code>CreateUserWithEmail</code> 클래스에 읽기 접근자만 가지는 <code>Email</code> 속성을 추가한다.</p>
<pre class="brush: csharp; title: ; notranslate">
public class CreateUserWithEmail : IValidatableObject
{
    public CreateUserWithEmail(Guid userId, string username)
    {
        UserId = userId;
        Username = username;
    }

    public Guid UserId { get; }

    [Required]
    [Username]
    public string Username { get; }

    public string Email { get; }

    IEnumerable&lt;ValidationResult&gt; IValidatableObject.Validate(ValidationContext validationContext)
    {
        if (UserId == Guid.Empty)
        {
            yield return new ValidationResult(&quot;Value cannot be empty.&quot;, new[] { nameof(UserId) });
        }
    }
}
</pre>
<p>테스트 케이스 <code>sut_has_Email_property</code>를 실행하면 성공한다.</p>
<h2>테스트 케이스: 생성자는 Email 속성 값을 올바르게 설정한다.</h2>
<p><code>CreateUserWithEmail</code> 명령은 불변 개체이기 때문에 추가된 <code>Email</code> 속성 값은 생성자 매개변수로 전달받아 설정되어야 한다.</p>
<h3>테스트 케이스 실패</h3>
<pre class="brush: csharp; title: ; notranslate">
[Fact]
public void constructor_sets_Email_correctly()
{
    string email = GenerateEmail();
    var sut = new CreateUserWithEmail(Guid.NewGuid(), GenerateUsername(), email);
    sut.Email.Should().Be(email);
}

public static string GenerateUsername() =&gt; $&quot;Username{Guid.NewGuid().ToString(&quot;n&quot;).Substring(0, 8)}&quot;;

public static string GenerateEmail() =&gt; $&quot;email{Guid.NewGuid().ToString(&quot;n&quot;).Substring(0, 8)}@test.com&quot;;
</pre>
<p>테스트 케이스 <code>constructor_sets_Email_correctly</code>는 임의의 이메일 주소를 사용해 <code>CreateUserWithEmail</code> 명령을 생성하고 <code>Email</code> 속성이 잘 설정되었는지 검사한다. 기존의 <code>CreateUserWithEmail</code> 생성자는 이메일 주소를 매개변수로 받지 않기 때문에 테스트 케이스를 컴파일 하고 실행하려면 생성자를 수정해야 한다.</p>
<pre class="brush: csharp; title: ; notranslate">
public CreateUserWithEmail(Guid userId, string username, string email)
{
    UserId = userId;
    Username = username;
}
</pre>
<p>생성자에 <code>email</code> 매개변수가 추가되었지만 사용되지는 않기 때문에 테스트 케이스는 실패한다.</p>
<h3>테스트 케이스 성공</h3>
<p><code>CreateUserWithEmail</code> 생성자가 매개변수 <code>email</code> 값을 <code>Email</code> 속성에 대입하면 테스트 케이스 <code>constructor_sets_Email_correctly</code>는 성공한다.</p>
<pre class="brush: csharp; title: ; notranslate">
public CreateUserWithEmail(Guid userId, string username, string email)
{
    UserId = userId;
    Username = username;
    Email = email;
}
</pre>
<h2>테스트 케이스: 개체 검증은 이메일 주소 유효성을 판단한다.</h2>
<p>이 글의 메인 이벤트 격인 테스트 케이스다. 이메일 주소를 사용한 사용자 생성 절차는 이메일 주소 필드가 올바른 형식을 따르는지 검사해야 한다. 제품이 출시될 때까지 이메일 주소 형식 검증 규칙은 점진적으로 개선되겠지만 우선 <a href="https://blogs.msdn.microsoft.com/testing123/2009/02/06/email-address-test-cases/">이 글</a>에 있는 사례들을 이용해 초기화한다.</p>
<h3>테스트 케이스 실패</h3>
<p><code>[Theory]</code> 특성은 매개변수를 가진(parameterized) 테스트 메서드를 의미한다. 테스트 케이스에 필요한 매개변수 인자는 <a href="https://xunit.github.io">xUnit.net</a>에 내장된 데이터 제공 특성을 통해 입력한다. 여기서는 <code>[MemberData]</code> 특성을 사용한다.</p>
<p>우선 테스트 케이스 데이터를 제공하는 클래스를 만든다.</p>
<pre class="brush: csharp; title: ; notranslate">
// Test cases from https://blogs.msdn.microsoft.com/testing123/2009/02/06/email-address-test-cases/
public static class EmailTestCases
{
    public static IEnumerable&lt;object[]&gt; InvalidEmails()
    {
        return new[]
        {
            new[] { &quot;plainaddress&quot;, &quot;Missing @ sign and domain&quot; },
            new[] { &quot;#@%^%#$@#$@#.com&quot;, &quot;Garbage&quot; },
            new[] { &quot;@domain.com&quot;, &quot;Missing username&quot; },
            new[] { &quot;Joe Smith &lt;email@domain.com&gt;&quot;, &quot;Encoded html within email is invalid&quot; },
            new[] { &quot;email.domain.com&quot;, &quot;Missing @&quot; },
            new[] { &quot;email@domain@domain.com&quot;, &quot;Two @ sign&quot; },
            new[] { &quot;.email@domain.com&quot;, &quot;Leading dot in address is not allowed&quot; },
            new[] { &quot;email.@domain.com&quot;, &quot;Trailing dot in address is not allowed&quot; },
            new[] { &quot;email..email@domain.com&quot;, &quot;Multiple dots&quot; },
            new[] { &quot;あいうえお@domain.com&quot;, &quot;Unicode char as address&quot; },
            new[] { &quot;email@domain.com (Joe Smith)&quot;, &quot;Text followed email is not allowed&quot; },
            new[] { &quot;email@domain&quot;, &quot;Missing top level domain (.com/.net/.org/etc)&quot; },
            new[] { &quot;email@-domain.com&quot;, &quot;Leading dash in front of domain is invalid&quot; },
            new[] { &quot;email@domain.web&quot;, &quot;.web is not a valid top level domain&quot; },
            new[] { &quot;email@111.222.333.44444&quot;, &quot;Invalid IP format&quot; },
            new[] { &quot;email@domain..com&quot;, &quot;Multiple dot in the domain portion is invalid&quot; },
        };
    }
}
</pre>
<p><code>InvalidEmails()</code> 메서드는 올바르지 않은 형식의 이메일 주소와 올바르지 않은 이유의 집합 컬렉션 반환한다.</p>
<pre class="brush: csharp; title: ; notranslate">
[Theory]
[MemberData(&quot;InvalidEmails&quot;, MemberType = typeof(EmailTestCases))]
public void given_invalid_email_then_validation_fails(string email, string reason)
{
    var sut = new CreateUserWithEmail(Guid.NewGuid(), GenerateUsername(), email);
    Action action = () =&gt; Validate(sut);
    action.ShouldThrow&lt;ValidationException&gt;();
}

private static void Validate(object instance)
{
    Validator.ValidateObject(
        instance,
        new ValidationContext(instance),
        validateAllProperties: true);
}
</pre>
<p>테스트 프레임워크는 <code>EmailTestCases.InvalidEmails()</code> 메서드가 반환한 데이터 집합 컬렉션을 반복하며 하나의 데이터 집합 당 테스트 케이스 <code>given_invalid_email_then_validation_fails</code>를 한 번씩 실행한다. 하나의 데이터 집합은 이메일 주소와 이메일 주소가 올바르지 않은 이유로 구성되는데 이 정보는 각각 테스트 케이스의 <code>email</code> 매개변수와 <code>reason</code> 매개변수로 전달된다. 그리고 테스팅 도구에 의해 표현되는 테스트 케이스 이름은 다음과 같다.</p>
<pre class="brush: plain; title: ; notranslate">
given_invalid_email_then_validation_fails(email: &quot;email@-domain.com&quot;, reason: &quot;Leading dash in front of domain is invalid&quot;)
</pre>
<p>아직 <code>Email</code> 속성을 검증하는 어떠한 규칙도 적용되지 않았기 때문에 <code>Validator</code>는 <code>CreateUserWithEmail</code> 개체를 검증할 때 <code>ValidationException</code>을 던지지 않고 테스트 케이스는 실패한다.</p>
<h3>테스트 케이스 성공</h3>
<p>테스트 케이스 <code>given_invalid_email_then_validation_fails</code>는 테스트 데이터에 의해 정의되는 테스트 케이스의 집합으로 볼 수 있다. 이런 경우 테스트 주도 개발 주기를 여러 번 반복해 구현할 수도 있다. 이 글에서는 편의상 한 번의 주기로 구현한다.</p>
<p>테스트 케이스 <code>given_invalid_email_then_validation_fails</code>의 사례들이 모두 통과하도록 점진적으로 규칙들을 추가했고 결과 코드는 다음과 같다.</p>
<pre class="brush: csharp; title: ; notranslate">
public class CreateUserWithEmail : IValidatableObject
{
    public CreateUserWithEmail(Guid userId, string username, string email)
    {
        UserId = userId;
        Username = username;
        Email = email;
    }

    public Guid UserId { get; }

    [Required]
    [Username]
    public string Username { get; }

    [EmailAddress]
    public string Email { get; }

    IEnumerable&lt;ValidationResult&gt; IValidatableObject.Validate(ValidationContext validationContext)
    {
        if (UserId == Guid.Empty)
        {
            yield return new ValidationResult(&quot;Value cannot be empty.&quot;, new[] { nameof(UserId) });
        }

        string email = Email;

        if (ContainsWhiteSpaceCharacter(email))
        {
            yield return new ValidationResult(&quot;Value cannot contain white space characters.&quot;, new[] { nameof(Email) });
        }

        if (EmailContainsMultipleDots(email))
        {
            yield return new ValidationResult(&quot;Multiple dots found.&quot;, new[] { nameof(Email) });
        }

        if (EmailLocalPartHasLeadingDot(email))
        {
            yield return new ValidationResult(&quot;Leading dot in local part is not allowed.&quot;, new[] { nameof(Email) });
        }

        if (EmailLocalPartHasTrailingDot(email))
        {
            yield return new ValidationResult(&quot;Trailing dot in local part is not allowed.&quot;, new[] { nameof(Email) });
        }

        if (EmailDomainPartHasLeadingDash(email))
        {
            yield return new ValidationResult(&quot;Leading dash in domain part is not allowed.&quot;, new[] { nameof(Email) });
        }

        if (EmailHasTopLevelDomain(email) == false)
        {
            yield return new ValidationResult(&quot;Top level domain is missing.&quot;, new[] { nameof(Email) });
        }

        if (EmailHasInvalidTopLevelDomain(email))
        {
            yield return new ValidationResult(&quot;Top level domain is invalid.&quot;, new[] { nameof(Email) });
        }

        if (EmailIPFormatIsInvalid(email))
        {
            yield return new ValidationResult(&quot;IP format is invalid.&quot;, new[] { nameof(Email) });
        }

        if (EmailLocalPartContainsUnicodeCharacter(email))
        {
            yield return new ValidationResult(&quot;Local part contains a unicode character.&quot;, new[] { nameof(Email) });
        }
    }

    private static bool ContainsWhiteSpaceCharacter(string s)
    {
        for (int i = 0; i &lt; s.Length; i++)
        {
            char c = s[i];
            if (char.IsWhiteSpace(c))
            {
                return true;
            }
        }

        return false;
    }

    private static bool EmailContainsMultipleDots(string email)
    {
        return email.Contains(&quot;..&quot;);
    }

    private static bool EmailLocalPartHasLeadingDot(string email)
    {
        return email.StartsWith(&quot;.&quot;);
    }

    private static bool EmailLocalPartHasTrailingDot(string email)
    {
        int atIndex = email.IndexOf(&#039;@&#039;);
        if (atIndex &lt; 0)
        {
            return false;
        }

        string localPart = email.Substring(0, atIndex);
        return localPart.EndsWith(&quot;.&quot;);
    }

    private static bool EmailDomainPartHasLeadingDash(string email)
    {
        int atIndex = email.IndexOf(&#039;@&#039;);
        if (atIndex &lt; 0)
        {
            return false;
        }

        string domainPart = email.Substring(atIndex + 1);
        return domainPart.StartsWith(&quot;-&quot;);
    }

    private static bool EmailHasTopLevelDomain(string email)
    {
        int atIndex = email.IndexOf(&#039;@&#039;);
        if (atIndex &lt; 0)
        {
            return false;
        }

        string domainPart = email.Substring(atIndex + 1);
        string[] fragments = domainPart.Split(&#039;.&#039;);
        return fragments.Length &gt;= 2;
    }

    private static bool EmailHasInvalidTopLevelDomain(string email)
    {
        int atIndex = email.IndexOf(&#039;@&#039;);
        if (atIndex &lt; 0)
        {
            return false;
        }

        string domainPart = email.Substring(atIndex + 1);
        string[] fragments = domainPart.Split(&#039;.&#039;);
        string topLevelDomain = fragments.Skip(1).LastOrDefault();
        return topLevelDomain?.Equals(&quot;web&quot;, StringComparison.OrdinalIgnoreCase) ?? false;
    }

    private static bool EmailIPFormatIsInvalid(string email)
    {
        int atIndex = email.IndexOf(&#039;@&#039;);
        if (atIndex &lt; 0)
        {
            return false;
        }

        string domainPart = email.Substring(atIndex + 1);
        string[] fragments = domainPart.Split(&#039;.&#039;);
        if (fragments.Length == 4)
        {
            int?[] ipv4 = fragments
                .Select(f =&gt; int.TryParse(f, out int value) ? value : (int?)null)
                .ToArray();
            if (ipv4.All(e =&gt; e.HasValue))
            {
#pragma warning disable SA1131 // Use readable conditions
                return ipv4.Any(e =&gt; e &lt; 0 || 255 &lt; e);
#pragma warning restore SA1131 // Use readable conditions
            }
        }

        return false;
    }

    private static bool EmailLocalPartContainsUnicodeCharacter(string email)
    {
        int atIndex = email.IndexOf(&#039;@&#039;);
        if (atIndex &lt; 0)
        {
            return false;
        }

        string localPart = email.Substring(0, atIndex);
        return localPart.Any(c =&gt; c &gt; 127);
    }
}
</pre>
<p>우선 <code>Email</code> 속성을 <code>System.ComponentModel.DataAnnotations</code> 네임스페이스가 제공하는 <code>[EmailAddress]</code> 특성으로 수식한다. <code>[EmailAddress]</code> 특성은 <code>Validator</code>에 의해 사용되어 <code>Email</code> 속성 값이 이메일 주소 형식에 적합한지 검사한다. 하지만 우리의 이메일 주소 형식 규칙은 <code>[EmailAddress]</code> 특성의 규칙보다 엄격하기 때문에 <code>[EmailAddress]</code> 특성은 일부 테스트 케이스는 성공시키지만 나머지는 그러지 못한다. 그래서 모든 테스트 케이스들을 성공시키기 위해 <code>[EmailAddress]</code> 특성이 검출하지 못하는 규칙들이 <code>Validate()</code> 메서드에 포함된다.</p>
<h3>리팩터링</h3>
<p>테스트 주도 개발에서 리팩터링은 매우 중요한 단계다. 리팩터링은 테스트 우선 개발(test first development)과 테스트 주도 개발이 구분되는 기준이기도 하다. 지금까지의 테스트 케이스들은 프로덕션 코드 구현이 간단했기 때문에 리팩터링이 필요하지 않았지만 테스트 케이스 <code>given_invalid_email_then_validation_fails</code>는 상황이 다르다.</p>
<p>테스트 케이스 성공 단계에서 코드는 오로지 모든 테스트 케이스에 녹색 불이 들어오는 것을 목표로 작성된다. 설계는 고려사항이 아니다. 그 결과 <code>CreateUserWithEmail</code> 명령은 메시지임에도 불구하고 아주 많은 논리를 포함한다. 문제는 그 뿐만이 아니다. 사용자의 이메일 주소는 초기에 설정된 후 변경될 수 있도록 설계했다. 이 설계를 반영하려면 앞으로 <code>ChangeEmail</code> 명령이 필요할 것이다. 그런데 <code>ChangeEmail</code> 명령 역시 <code>Email</code> 속성을 가지며 이 속성 값을 <code>CreateUserWithEmail</code> 명령의 경우와 동일한 규칙으로 검증해야 하는데 이 과정에서 많은 코드 중복이 발생한다. 이메일 주소 형식 규칙은 최종 결정된 것이 아니라 제품이 출시될 때가지 점진적으로 개선될 계획이기 때문에 유지 비용이 큰 코드 중복은 가급적 피해야 한다.</p>
<blockquote><p>
  Kent Beck은 테스트 주도 개발을 위한 단순한 규칙 두 개를 정의했다.<br />
  &#8211; First, you should write new business code only when an automated test has failed.<br />
  &#8211; Second, you should eliminate any duplication that you find.
</p></blockquote>
<p>이런 문제를 가진 설계를 개선하기 위해 <code>[EmailAddress]</code> 특성에 포함된 규칙과 그렇지 않는 규칙을 모두 반영한 새 특성(<code>[Email]</code>)을 만들어 적용하는 리팩터링을 수행한다.</p>
<pre class="brush: csharp; title: ; notranslate">
public class CreateUserWithEmail : IValidatableObject
{
    public CreateUserWithEmail(Guid userId, string username, string email)
    {
        UserId = userId;
        Username = username;
        Email = email;
    }

    public Guid UserId { get; }

    [Required]
    [Username]
    public string Username { get; }

    [Email]
    public string Email { get; }

    IEnumerable&lt;ValidationResult&gt; IValidatableObject.Validate(ValidationContext validationContext)
    {
        if (UserId == Guid.Empty)
        {
            yield return new ValidationResult(&quot;Value cannot be empty.&quot;, new[] { nameof(UserId) });
        }
    }
}
</pre>
<pre class="brush: csharp; title: ; notranslate">
[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, AllowMultiple = false)]
public sealed class EmailAttribute : DataTypeAttribute
{
    private static readonly EmailAddressAttribute StandardAttribute = new EmailAddressAttribute();
    private static readonly IEnumerable&lt;Func&lt;string, bool&gt;&gt; Rules = new Func&lt;string, bool&gt;[]
    {
        SatisfiesStandardRules,
        DoesNotContainWhiteSpaceCharacter,
        DoesNotContainMultipleDots,
        DomainPartDoesNotHaveLeadingDash,
        HasValidTopLevelDomain,
        IfIPv4DomainIsUsedThenValid,
        LocalPartDoesNotHaveLeadingDot,
        LocalPartDoesNotHaveTrailingDot,
        LocalPartDoesNotContainUnicodeCharacter
    };

    public EmailAttribute()
        : base(DataType.EmailAddress)
    {
    }

    public override bool IsValid(object value)
    {
        string email = value as string;
        return Rules.All(rule =&gt; rule.Invoke(email));
    }

    private static bool SatisfiesStandardRules(string email)
    {
        return StandardAttribute.IsValid(email);
    }

    private static bool DoesNotContainWhiteSpaceCharacter(string email)
    {
        for (int i = 0; i &lt; email.Length; i++)
        {
            char c = email[i];
            if (char.IsWhiteSpace(c))
            {
                return false;
            }
        }

        return true;
    }

    private static bool DoesNotContainMultipleDots(string email)
    {
        return email.Contains(&quot;..&quot;) == false;
    }

    private static bool DomainPartDoesNotHaveLeadingDash(string email)
    {
        int atIndex = email.IndexOf(&#039;@&#039;);
        string domainPart = email.Substring(atIndex + 1);
        return domainPart.StartsWith(&quot;-&quot;) == false;
    }

    private static bool HasValidTopLevelDomain(string email)
    {
        int atIndex = email.IndexOf(&#039;@&#039;);
        string domainPart = email.Substring(atIndex + 1);
        string[] fragments = domainPart.Split(&#039;.&#039;);
        string topLevelDomain = fragments.Skip(1).LastOrDefault();
        return topLevelDomain != null
            &amp;&amp; topLevelDomain.Equals(&quot;web&quot;, StringComparison.OrdinalIgnoreCase) == false;
    }

    private static bool IfIPv4DomainIsUsedThenValid(string email)
    {
        int atIndex = email.IndexOf(&#039;@&#039;);
        string domainPart = email.Substring(atIndex + 1);
        string[] fragments = domainPart.Split(&#039;.&#039;);
        if (fragments.Length == 4)
        {
            int?[] ipv4 = fragments
                .Select(f =&gt; int.TryParse(f, out int value) ? value : (int?)null)
                .ToArray();
#pragma warning disable SA1131 // Use readable conditions
            return ipv4.Any(e =&gt; e.HasValue == false)
                || ipv4.All(e =&gt; 0 &lt;= e &amp;&amp; e &lt;= 255);
#pragma warning restore SA1131 // Use readable conditions
        }

        return true;
    }

    private static bool LocalPartDoesNotHaveLeadingDot(string email)
    {
        return email.StartsWith(&quot;.&quot;) == false;
    }

    private static bool LocalPartDoesNotHaveTrailingDot(string email)
    {
        int atIndex = email.IndexOf(&#039;@&#039;);
        string localPart = email.Substring(0, atIndex);
        return localPart.EndsWith(&quot;.&quot;) == false;
    }

    private static bool LocalPartDoesNotContainUnicodeCharacter(string email)
    {
        int atIndex = email.IndexOf(&#039;@&#039;);
        string localPart = email.Substring(0, atIndex);
        return localPart.All(c =&gt; c &lt;= 127);
    }
}

</pre>
<p>리팩터링은 단순히 코드를 옮기는 것 뿐 아니라 일관된 설계를 위한 내부 변경이 포함되었다. 비교식의 부등호 방향이 바뀌었고 어떤 <code>if</code> 블럭은 삭제되었다. 과감하게 이런 변경을 적용할 수 있는 이유는 테스트 케이스를 통해 새 코드가 리팩터링 전의 기능을 온전히 수행함을 보장받기 때문이다. 실제로 리팩터링을 하면서 민감한 부분의 실수가 있었지만 테스트 케이스가 깨졌기 때문에 오류를 즉시 인지하고 올바르게 수정할 수 있었다.</p>
<p>설계 변경으로 인해 <code>CreateUserWithEmail</code> 클래스는 원래 목적에 맞게 메시지로서의 기능에 충실하게 되었다. 이메일 주소 검사 규칙은 재활용하기 쉬워졌다. 테스트 케이스는 설계 변경이 기능 변경을 일으키지 않음을 확인했다.</p>
<h1>마무리</h1>
<p>테스트 주도 개발을 통해 현장에서 사용되는 코드를 작성하는 과정을 살펴봤다. 속성 정의 같은 아주 간단한 사례부터 매개변수를 사용한 테스팅이 적용되고 리팩터링이 수행된 사례도 있었다. 각 테스트 케이스 제목을 나열해 보면 그것들이 요구사항이나 설계 내역의 세부 요소라는 것을 알 수 있을 것이다. 그런 의미에서 테스트 주도 개발을 통해 작성된 테스트 케이스는 자가 검증되는 요구사항 및 설계다.</p>
<p>테스트 주도 개발의 실천 사례를 소개한다는 목적으로 작성된 코드와 글이기 때문에 어떤 테스트 케이스는 과도하게 촘촘하다고 느껴질 수도 있다. 이것들이 최고의 실천 사례라고 할 수는 없으며 검증 수준은 상황에 따라 적절히 조절하는 것이 현명하다. 하지만 테스트 주도 개발을 처음 연습하려 한다면 아주 간단하고 작은 코드를 대상으로도 실천해 보는 것을 권장한다.</p>
<p>테스트 주도 개발이 유용할 것이라 생각하지만 막상 실전에 적용하려면 어디서 어떻게 시작해야 하는지 감을 잡기 어렵다는 얘기를 자주 접한다. 이런 어려움을 느끼는 프로그래머들에게 이 글이 도움이 되기를 바란다.</p>
]]></content:encoded>
							<wfw:commentRss>https://justhackem.wordpress.com/2017/10/31/practicing-test-driven-development/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/e94263d4b902a36e1e8bef828d8af42a?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">gyuwonyi</media:title>
		</media:content>
	</item>
		<item>
		<title>비공개 메서드를 테스트 해야 하는가?</title>
		<link>https://justhackem.wordpress.com/2017/09/29/should-private-methods-be-tested/</link>
				<comments>https://justhackem.wordpress.com/2017/09/29/should-private-methods-be-tested/#comments</comments>
				<pubDate>Fri, 29 Sep 2017 00:39:51 +0000</pubDate>
		<dc:creator><![CDATA[Gyuwon]]></dc:creator>
				<category><![CDATA[일반]]></category>
		<category><![CDATA[design]]></category>
		<category><![CDATA[oop]]></category>
		<category><![CDATA[tdd]]></category>
		<category><![CDATA[testing]]></category>

		<guid isPermaLink="false">http://justhackem.wordpress.com/?p=7168</guid>
				<description><![CDATA[TDD(Test-Driven Development, 테스트 주도 개발)에 익숙하지 않은, 개체지향 프로그래밍 언어를 사용하는, 프로그래머들은 간혹 이런 질문을 한다. 비공개(private) 메서드도 테스트 해야 하는가? 이 질문의 대답은 &#8216;그렇다&#8217; 또는 &#8216;아니다&#8217;보다 좀 더 길다. 비공개 메서드의 인터페이스는 테스트 하지 않지만 비공개 메서드의 구현은 테스트 대상이다. 혼란스러울 수 있다. 어쩌라는 말인가? 이 혼란을 해결해 줄 대답은 TDD를 사용하는 프로그래머가 비공개 [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>TDD(Test-Driven Development, 테스트 주도 개발)에 익숙하지 않은, 개체지향 프로그래밍 언어를 사용하는, 프로그래머들은 간혹 이런 질문을 한다.</p>
<blockquote><p>
  비공개(private) 메서드도 테스트 해야 하는가?
</p></blockquote>
<p>이 질문의 대답은 &#8216;그렇다&#8217; 또는 &#8216;아니다&#8217;보다 좀 더 길다. 비공개 메서드의 인터페이스는 테스트 하지 않지만 비공개 메서드의 구현은 테스트 대상이다. 혼란스러울 수 있다. 어쩌라는 말인가?</p>
<p><span id="more-7168"></span></p>
<p>이 혼란을 해결해 줄 대답은 TDD를 사용하는 프로그래머가 비공개 메서드를 만드는 목적과 과정에 있다. 우선 TDD에서 반복되는 3단계 과정을 요약하면 이렇다.</p>
<ol>
<li>구현하고자 하는 아주 작은 기능 하나를 정의 또는 선택한 후 이 기능을 검증하는 테스트 케이스를 작성하고 작성된 테스트 케이스가 대상 기능이 구현되지 않은 이유로 실패하는지 확인한다.</li>
<li>전 단계에서 작성된 테스트 케이스를 비롯해 모든 테스트 케이스가 성공하도록, 그리고 성공할 만큼만 기능 코드를 작성한다.</li>
<li>모든 테스트 케이스가 성공하는 것을 확인하며 코드를 리팩터 한다.</li>
</ol>
<p>이 과정을 흔히 Red-Green-Refactor라고 부른다.</p>
<p>개체지향 프로그래밍은 인터페이스를 노출하고 구현을 숨긴다. 테스트 케이스는 인터페이스에 의존적이며 구현에 독립적이다. 여기서 말하는 인터페이스는 개체의 공개(public) 멤버이다. 따라서 테스트 케이스는 개체의 공개 멤버를 통해서만 동작하며 내부 구현과는 직접 연결되지 않는다. Green 단계에서 프로그래머는 오로지 모든 테스트 케이스를 성공시키는 목적으로만 코드를 작성한다. 설계는 고려 대상이 아니다.</p>
<p>이후 Refactor 단계에서는 테스트 케이스 코드와 결과에 영향을 주지 않는 범위 내에서 구현을 다시 설계한다. 재설계 목적은 코드 품질을 높이는 것이다. 가독성을 높이고, 코드의 의도를 명확히 드러내고, 중복 코드를 제거하고, 코드 덩어리를 적당한 크기로 분배한다.(&#8216;Factor&#8217;는 &#8216;인수 분해하다&#8217;라는 의미의 동사다.) 테스트 케이스가 있기 때문에 프로그래머는 안심하고 과감하게 코드를 리팩터 할 수 있다. 비공개 메서드는 이 과정에서 만들어진다. 따라서 비공개 메서드에 담긴 코드는 이미 테스트 케이스를 통해 완전히 검증된 후 재배치된 것이다. 테스트 케이스가 비공개 메서드의 인터페이스에 대해 전혀 알지 못함에도 불구하고 말이다.</p>
<p>예를 들어, 최근에 작성한 <a href="https://github.com/Reacture/Khala.Processes/blob/2c7e70cbe69e4f9f0d8c73ce48745e784f6a8d67/source/Khala.Processes.Sql/Processes/Sql/SqlCommandPublisher.cs#L29"><code>FlushCommands</code> 메서드</a>는 6개의 비공개 메서드로 구성된다. 이 비공개 메서드들이 가진 모든 코드는 빠짐 없이 <a href="https://github.com/Reacture/Khala.Processes/blob/2c7e70cbe69e4f9f0d8c73ce48745e784f6a8d67/source/Khala.Processes.Tests/Processes/Sql/SqlCommandPublisher_specs.cs">테스트 클래스</a>에 의해 검증되는데, 테스트 케이스들은 <code>FlushCommands</code>라는 공개 인터페이스를 통해서만 대상 개체와 소통한다. 테스트 케이스가 공개 인터페이스에만 의존하기 때문에 내부 구현은 숨겨지고 언제든 더 나은 구조로 변경될 수 있다. 이런 특성은 개체지향 원리와도 맞닿아 있다. 테스트 케이스는 클라이언트 코드다. 물론 이 비공개 메서드들은 모두 TDD의 Refactor 단계에서 하나씩 차근차근 만들어졌다는 것을 잊지 말자.</p>
<p>다시 질문의 답을 한 문장으로 정리하면 이렇다.</p>
<blockquote><p>
  비공개 메서드의 모든 코드를 비공개 메서드에 독립적인 방법으로 테스트 하라.
</p></blockquote>
]]></content:encoded>
							<wfw:commentRss>https://justhackem.wordpress.com/2017/09/29/should-private-methods-be-tested/feed/</wfw:commentRss>
		<slash:comments>4</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/e94263d4b902a36e1e8bef828d8af42a?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">gyuwonyi</media:title>
		</media:content>
	</item>
		<item>
		<title>적은 코드가 항상 더 좋지는 않다</title>
		<link>https://justhackem.wordpress.com/2017/07/16/less-code-is-not-always-better/</link>
				<comments>https://justhackem.wordpress.com/2017/07/16/less-code-is-not-always-better/#respond</comments>
				<pubDate>Sat, 15 Jul 2017 17:33:30 +0000</pubDate>
		<dc:creator><![CDATA[Gyuwon]]></dc:creator>
				<category><![CDATA[일반]]></category>
		<category><![CDATA[design]]></category>

		<guid isPermaLink="false">http://justhackem.wordpress.com/?p=6778</guid>
				<description><![CDATA[예상했던 일이지만 소셜 미디어에서 정적 기록자(static logger) 변수를 그만 사용하자는 의견에 반발이 거세다. 모든 의견에 하나하나 대응해 줄 여유가 없음이 안타깝다. 그 중 다음 한가지 의견에 대해 답해 본다. &#8220;우리 응용프로그램은 수백 개의 클래스로 구성된다. 정적 기록자를 사용하지 않기 위해 모든 클래스에 DI(dependency injection) 설정을 하는 것은 비현실적이다.&#8221; 우선 수백 개의 클래스가 이미 정적 기록자 [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>예상했던 일이지만 소셜 미디어에서 <a href="https://justhackem.wordpress.com/2017/07/07/no-more-static-logger/">정적 기록자(static logger) 변수를 그만 사용하자는 의견</a>에 반발이 거세다. 모든 의견에 하나하나 대응해 줄 여유가 없음이 안타깝다. 그 중 다음 한가지 의견에 대해 답해 본다.</p>
<p>&#8220;우리 응용프로그램은 수백 개의 클래스로 구성된다. 정적 기록자를 사용하지 않기 위해 모든 클래스에 DI(dependency injection) 설정을 하는 것은 비현실적이다.&#8221;</p>
<p><span id="more-6778"></span>우선 수백 개의 클래스가 이미 정적 기록자 변수를 사용하고 있다면, 설령 내 의견에 동의하더라도, 문제가 발생하기 전까지는 그냥 두자. 필요하지 않은 곳에 비싼 프로그래머의 자원을 소비하는 것은 합리적이지 않다. 과거의 코드는 나름의 역사와 이유가 있다. 존중하고 이해하자.</p>
<p>어떤 기법에 대해 비현실적이라 말하는 것은 정말 비현실적이거나 충분히 현실적이지만 특정 개인이나 조직이 비현실적으로 느끼는 경우일 수 있다. 후자의 예로 나는 TDD(test-driven development)가 비현실적이라는 주장을 많이 접했는데 사실은 시도해 보지도 않고 지레 겁먹었거나 TDD를 충분히 이해하지 못한 것이었다.</p>
<p>백 개의 클래스가 있고 모두 기록자를 직접 사용한다는 가장 끔찍한 악몽같은 경우를 가정하자. 기록자 DI 설정을 위해 클래스당 두 줄의 코드가 필요하다면 200줄이 추가된다. 비현실적으로 많은가? 그럼 이건 어떤가? 백 개의 클래스가 모두 SRP(single responsibility principle)를 충실히 따랐다고 하더라도 테스트 케이스가 천 개 정도는 될 것이다. 그러면 테스트 코드는 모두 몇 줄일까? 백 개의 클래스를 위한 천 개의 테스트 케이스를 작성하는 것도 비현실적인가? 누군가에게는 일상적이고 또 다른 이에게는 비현실적이다.</p>
<blockquote><p>
  정말 문제는 백 개의 클래스 모두가 기록자를 직접 사용하는 설계다.
</p></blockquote>
<p>동일한 기능(feature)을 전제로 코드가 없는 것은 그 어떤 코드보다 더 좋다. 하지만 적은 코드가 더 많은 코드보다 항상 더 좋은 것은 아니다. 게다가 사용성(usability)과 적응성(adaptability), 테스트 용이성(testability)은 기능이다. 코드 몇 줄로 유용한 기능을 확보할 수 있다면 결코 비현실적이지 않다. 긴 코드보다 나쁜 설계를 두려워하라.</p>
]]></content:encoded>
							<wfw:commentRss>https://justhackem.wordpress.com/2017/07/16/less-code-is-not-always-better/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/e94263d4b902a36e1e8bef828d8af42a?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">gyuwonyi</media:title>
		</media:content>
	</item>
		<item>
		<title>정적 기록자는 이제 그만</title>
		<link>https://justhackem.wordpress.com/2017/07/07/no-more-static-logger/</link>
				<comments>https://justhackem.wordpress.com/2017/07/07/no-more-static-logger/#comments</comments>
				<pubDate>Thu, 06 Jul 2017 15:03:32 +0000</pubDate>
		<dc:creator><![CDATA[Gyuwon]]></dc:creator>
				<category><![CDATA[일반]]></category>
		<category><![CDATA[architecture]]></category>
		<category><![CDATA[cloud]]></category>
		<category><![CDATA[design]]></category>

		<guid isPermaLink="false">http://justhackem.wordpress.com/?p=6603</guid>
				<description><![CDATA[수십년간 적응력있는 소프트웨어를 만들기 위한 노력이 지속되고 있다. 우리는 많은 원칙들과 패턴들을 도출했고 또 일부는 퇴출시켰다. 도메인은 가장 높은 적응력을 가져야 하는 소프트웨어 구성요소로 거론되고 있다. 간혹 도메인을 호스팅하는 웹 응용프로그램 코드가 도메인 코드보다 물리적으로 더 큰 비중을 차지하더라도 도메인의 중요성은 여전히 가장, 그리고 월등히, 높다. 아키텍처는 점점 다양해지고 그 수명은 점점 짧아진다. 변화하는 비즈니스 [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>수십년간 적응력있는 소프트웨어를 만들기 위한 노력이 지속되고 있다. 우리는 많은 원칙들과 패턴들을 도출했고 또 일부는 퇴출시켰다. 도메인은 가장 높은 적응력을 가져야 하는 소프트웨어 구성요소로 거론되고 있다. 간혹 도메인을 호스팅하는 웹 응용프로그램 코드가 도메인 코드보다 물리적으로 더 큰 비중을 차지하더라도 도메인의 중요성은 여전히 가장, 그리고 월등히, 높다.</p>
<p>아키텍처는 점점 다양해지고 그 수명은 점점 짧아진다. 변화하는 비즈니스 상황에 따라 동일한 도메인 논리는 다양한 호스팅 환경으로 확산되어 구동된다. 서비스 초기에는 단순한 웹 응용프로그램 호스트면 충분하다. 그러다 아마 곧 반응성에 대한 사용자들의 불만이 생겨날 것이고, 도메인 구성요소의 일부를 작업자 프로세스로 이동시켜 비동기적으로 실행해 반응성을 높여야 한다. 서비스가 성장하면 이제 도메인은 외부 서비스들과 교류하게 되고 개방형 API와 웹 훅을 통해 도메인 논리가 트리거된다. 아, 그렇지! 지금은 클라우드 시대다. FaaS(Function as a Service)를 빠뜨릴 수 없다. 다시 한 번 언급하면 도메인 논리는 동일하다. 외부 변화에 따라 다른 아키텍처로 이동되거나 확산될 뿐이다.</p>
<p>물론 상당수의 서비스는 성장하지 못하고 생을 다한다. 하지만 성장의 기회가 왔을 때 정적 기록자(static logger) 변수 따위가 도메인의 발목을 잡는다면 모습이 우스을 것이다. 그것도 화려하고 무거운 무언가를 도입하는 것이 아니라 고작 담백한 한 두 줄 코드 추가가 부담되어 그랬다면 말이다.</p>
<p><span id="more-6603"></span></p>
<p>예를 들어보자. 클라우드 작업자 호스트 서비스나 FaaS는 간단하게 도메인을 호스팅한다. 작은 연산 단위로 격리된 절차가 수행되고 이것들의 조합이 시스템을 이룬다. 호스트는 각 연산마다 독립된 기록자를 제공하고 모든 연산의 수행 과정은 개별 파일에 독립적으로 기록이 남는다. 수행된 연산 목록 중 실패했거나 조사가 필요한 것을 발견했다면 당신은 그저 해당 연산의 기록이 담긴 텍스트 파일 하나를 열어보면 된다.</p>
<pre class="brush: csharp; title: ; notranslate">
[QueueTrigger(&quot;job-queue&quot;)]
public static void ProcessPayload(string payload, ILogger logger)
{
    var domain = AssembleModule&lt;DomainModule&gt;(logger);
    domain.Run(payload);
}
</pre>
<p>도메인 모듈이 명시적으로 공유된 정적 기록자 변수에 중요한 이벤트를 기록하도록 되어있다면,</p>
<pre class="brush: csharp; title: ; notranslate">
public class DomainModule
{
    private static readonly ILogger _staticLogger = GetLogger();
}
</pre>
<p>어쩌면 그것들이 모두 증발해 버렸거나 어딘가에 기록되었더라도 당신은 수많은 프로세스와 스레드가 경쟁적으로 섞어놓은 문자들의 더미 속에서 단서를 조합하기 위해 수고할 것이다. 그에 앞서 <code>GetLogger()</code> 메서드가 실패할 가능성도 높다.</p>
<p>반면 기록자에 의존관계 역전 원칙(dependency inversion principle)을 적용했다면,</p>
<pre class="brush: csharp; title: ; notranslate">
public class DomainModule
{
    private readonly ILogger _logger;

    public DomainModule(ILogger logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }
}
</pre>
<p>당신의 도메인 모듈은 호스팅 환경이 제공하는 기능을 멋지게 활용해 당신에게 양질의 피드백을 제공한다. 당신은  그저 조사하고 싶은 연산의 기록 파일을 더블클릭하기만 하면 된다.</p>
<p>테스트 케이스 또한 각각 아주 유용한 도메인 호스트 응용프로그램이다. 기록자에 의해 기록되는 이벤트 중 일부는 도메인의 주요 특징(feature)이고 테스트 대상이다. 정적 변수에 담긴 자원은 테스트 케이스에게는 공유 메모리 모델 만큼이나 아주 곤욕스러운 대상이다. 특히 병렬 테스팅에서는 더욱 그렇다.</p>
<p>특정 응용프로그램 플랫폼이나 프레임워크는 정적 기록자 변수를 지원한다. 그런데, 만약 당신의 도메인이 그것에 종속된다면 다양한 원칙과 멋진 패턴들은 얼마나 가치가 있을까? 계층을 나누고 결합도를 낮추어 무엇을 얻을까? 그저 작은 컨트롤러 하나면 모두 구현할 수 있는 것은 아닐까? 이것을 과도한 우려라고 말하기에는 도메인 설계를 정적 기록자 변수로부터 보호하는 방법은 너무나 소박하고 평범하다(plain-old). 적응력있고(adaptive) 확장성을 가지며(scalable) 테스트하기 쉬운(testable) 도메인을 원한다면 정적 기록자는 이제 그만 버리자.</p>
]]></content:encoded>
							<wfw:commentRss>https://justhackem.wordpress.com/2017/07/07/no-more-static-logger/feed/</wfw:commentRss>
		<slash:comments>4</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/e94263d4b902a36e1e8bef828d8af42a?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">gyuwonyi</media:title>
		</media:content>
	</item>
		<item>
		<title>싱글턴은 정적이지 않다</title>
		<link>https://justhackem.wordpress.com/2017/07/05/singleton-is-not-static/</link>
				<comments>https://justhackem.wordpress.com/2017/07/05/singleton-is-not-static/#comments</comments>
				<pubDate>Tue, 04 Jul 2017 15:18:57 +0000</pubDate>
		<dc:creator><![CDATA[Gyuwon]]></dc:creator>
				<category><![CDATA[일반]]></category>
		<category><![CDATA[dependency injection]]></category>
		<category><![CDATA[design]]></category>
		<category><![CDATA[ioc]]></category>
		<category><![CDATA[singleton]]></category>
		<category><![CDATA[testing]]></category>

		<guid isPermaLink="false">http://justhackem.wordpress.com/?p=6547</guid>
				<description><![CDATA[얼마전 페이스북에서 많은 프로그래머들이 당연시하게 기록자(logger)를 정적(static)으로 사용하는 것을 비판했는데, 비슷한 주장을 하는 다른 분의 글에서 기록자는 인스턴스 범위(scope)에 있지 않고 클래스 범위에 있다는 반론을 발견했다. 나는 반론 제기자에게 그것은 논점을 벗어나니 의존성 역전 원칙(dependency inversion principle)를 공부하라고 조언했다. 아쉽지만 반응에 의하면 아마 내 조언은 무시된 것 같았다. 응용프로그램 또는 프로세스와 생명주기를 함께하는 단일 서비스 [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>얼마전 페이스북에서 많은 프로그래머들이 당연시하게 기록자(logger)를 정적(static)으로 사용하는 것을 비판했는데, 비슷한 주장을 하는 다른 분의 글에서 기록자는 인스턴스 범위(scope)에 있지 않고 클래스 범위에 있다는 반론을 발견했다. 나는 반론 제기자에게 그것은 논점을 벗어나니 의존성 역전 원칙(dependency inversion principle)를 공부하라고 조언했다. 아쉽지만 반응에 의하면 아마 내 조언은 무시된 것 같았다.</p>
<p><span id="more-6547"></span></p>
<p>응용프로그램 또는 프로세스와 생명주기를 함께하는 단일 서비스 인스턴스는 상태를 가지지 않거나 공유 가능한 비싼 자원을 관리하거나 하는 경우에 유용하다. 그런데 이 하나의 서비스 인스턴스는 반드시 정적 변수에 담겨야 하는 걸까? 아니다. 그렇게 하지 말라. 특히 IoC 컨테이너를 사용하고 있다면 그래야 할 이유도 없다. 정적 변수에 담긴 인스턴스는 명시적으로 공유되는 자원임을 의미한다. 이런 자원을 사용하는 클라이언트 코드는 사용하기 어렵고 재사용하기 어렵고 테스트하기 어렵다.</p>
<p>그렇다면 클라이언트 시스템은 싱글턴 서비스 인스턴스에 어떻게 접근해야 할까? 고민할 것 없다. 다른 서비스와 마찬가지로 생성자를 통해 주입하라. 다음 예제 코드를 살펴보자.</p>
<pre class="brush: csharp; title: ; notranslate">
using System;

public class SingletonService
{
    public string GetMessage() =&gt; &quot;Hello World&quot;;
}

public class ClientModule
{
    private readonly SingletonService _service;

    public ClientModule(SingletonService service)
    {
        _service = service ?? throw new ArgumentNullException(nameof(service));
    }

    public void PrintMessage() =&gt; Console.WriteLine(_service.GetMessage());
}

public class IocContainer
{
    private readonly Func&lt;ClientModule&gt; _factory;

    public IocContainer(Func&lt;ClientModule&gt; factory)
    {
        _factory = factory ?? throw new ArgumentNullException(nameof(factory));
    }

    public ClientModule GetModule() =&gt; _factory.Invoke();
}

public class Program
{
    public static void Main(string[] args)
    {
        var singleton = new SingletonService();
        var container = new IocContainer(() =&gt; new ClientModule(singleton));
        Run(container);
    }

    private static void Run(IocContainer container)
    {
        for (int i = 0; i &lt; 5; i++)
        {
            ClientModule module = container.GetModule();
            Execute(module);
        }
    }

    private static void Execute(ClientModule module) =&gt; module.PrintMessage();
}
</pre>
<p>어떤가? 응용프로그램은 <code>SingletonService</code> 인스턴스를 단 하나만 가지지만 코드 어디에도 정적 필드는 존재하지 않는다. <code>ClientModule</code>은 API를 통해 <code>SingletonService</code>에의 의존성이 명시적으로 드러나고 이 의존성이 해결되지 않으면 개체를 생성할 수 없도록 엄격히 설계되었으며 테스트하기 쉽다.</p>
<p>항상 최고의 코드 품질을 유지하는 것은 다양한 이유로 비현실적이다. 정적 기록자 변수를 사용한 프로그래머가 처벌 대상은 아니다. 나름의 사정이 있었을 것이다. 하지만 바람직한 기술 조직은 더 나은 설계에 대해 지속적으로 고민하고 실천하려 노력한다.</p>
]]></content:encoded>
							<wfw:commentRss>https://justhackem.wordpress.com/2017/07/05/singleton-is-not-static/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
						
		<media:content url="https://2.gravatar.com/avatar/e94263d4b902a36e1e8bef828d8af42a?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">gyuwonyi</media:title>
		</media:content>
	</item>
	</channel>
</rss>
