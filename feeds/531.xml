<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
<title>토이팹</title>
<link>http://toyfab.tistory.com/</link>
<description>안윤호의 신변잡기와 관심사를 적어놓는 블로그입니다, 
관심사는 프로그래밍 , diy , fab  ,lisp ,scheme , 
오디오  , 사진  ,자동차 , 기계 , 사회의 각종 현상등입니다.
잡다하며 가끔 말도 안되는 이야기를 공유하려  할  것입니다.</description>
<language>ko</language>
<pubDate>Tue, 31 May 2016 11:49:22 +0900</pubDate>
<generator>TISTORY</generator>
<managingEditor>toyfab</managingEditor>
<image>
<title>토이팹</title>
<url>http://cfile5.uf.tistory.com/image/157F020C49B7DE897BFF76</url>
<link>http://toyfab.tistory.com</link>
<description>안윤호의 신변잡기와 관심사를 적어놓는 블로그입니다, 
관심사는 프로그래밍 , diy , fab  ,lisp ,scheme , 
오디오  , 사진  ,자동차 , 기계 , 사회의 각종 현상등입니다.
잡다하며 가끔 말도 안되는 이야기를 공유하려  할  것입니다.</description>
</image>
<item>
<title>변수에 대해 생각해보기 (2) Teach Yourself Scheme in Fixnum Days</title>
<link>http://toyfab.tistory.com/entry/%EB%B3%80%EC%88%98%EC%97%90-%EB%8C%80%ED%95%B4-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EA%B8%B0-2-Teach-Yourself-Scheme-in-Fixnum-Days</link>
<description>&lt;P&gt;오늘은 지난번의 동적 바인딩 생각해보기 (1) 에 대해 변수에 대해 생각해보기 (2)라는 제목으로 적어 봐야 할 것 같다. &lt;br /&gt;
오늘은 let 에 대한 부분을 정리하기 위해 스킴의 문헌 Teach Yourself Scheme in Fixnum Days 의 5장을 인용한다. &lt;br /&gt;
&lt;br /&gt;스킴의 교과서로 출판된 것은 아니지만 일정한 날자안에 스킴을 배울 수 있게 해준다는 책이다. &lt;br /&gt;
일단 책으로 여겨야 할 것 같다. &lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;A href=&quot;http://images.google.co.kr/imgres?imgurl=http://download.plt-scheme.org/doc/208/html/t-y-scheme/leaf.gif&amp;amp;imgrefurl=http://download.plt-scheme.org/doc/208/html/t-y-scheme/&amp;amp;usg=__z5LbiDsNTMcfzXW_DMIS-s3LosE=&amp;amp;h=106&amp;amp;w=120&amp;amp;sz=7&amp;amp;hl=ko&amp;amp;start=2&amp;amp;um=1&amp;amp;tbnid=ihhvQoDBIPBEaM:&amp;amp;tbnh=78&amp;amp;tbnw=88&amp;amp;prev=/images%3Fq%3Dteach%2Byourself%2Bscheme%2Bin%2Bfixnum%2Bdays%2Bpdf%26hl%3Dko%26rlz%3D1T4ADBR_koKR313KR313%26sa%3DN%26um%3D1%26newwindow%3D1&quot; target=_blank&gt;&lt;/A&gt;&lt;IMG src=&quot;http://download.plt-scheme.org/doc/208/html/t-y-scheme/leaf.gif&quot;&gt;&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
Teach Yourself Scheme in Fixnum Days 라는 제목으로 보아서는 킬러 앱스인데 사실 그렇게 많이 보지는 않는다. 스킴의 사용자들이 한정되어 있기 때문이다.&amp;nbsp; 그리고 21 days가 아니고 fixnum days라고 적은 것은 들여다보고 있으면 언젠가는&amp;nbsp; 이해할 수 있을 것이라는 사실을 알기 때문이라고 생각한다.&amp;nbsp; 언제인가는..&lt;br /&gt;
아무튼 책들을 많이 펼치지 않고 스킴의 많은 부분을 요약할 수 있다. 그 이유는 이 글(책)이 r5rs의 요약본이나 마찬가지기 때문이다.&amp;nbsp;&amp;nbsp;&lt;br /&gt;
&lt;br /&gt;결론은 매우 잘 쓴 책이며 간결하게 정리되어 있다. 예제들도 적당하다. 분명히 도움이 되는 사람들도 있을 것이다. 가끔 비교 검토할 가치는 충분하다.&lt;br /&gt;
&lt;br /&gt;SICP의 무서움은 이런 절차를 무시하고 바로 총을 주고 전쟁터로 보내는 방식이다. 간결하지도 않으며 예제들도 어렵다. 그리고 중요한 차이점들은 연습문제로 남겨 놓는다. 설명이 연습문제에 있는 경우도 있으며 전혀 친절하지도 않다.&lt;br /&gt;
(하지만 둘 다 좋은 책이다.&amp;nbsp;가르치는 방법도 여러가지이며 배우는 방법도 여러가지이고 대가 학생은 선생을 찾아 다닌다. ) &lt;br /&gt;
&lt;br /&gt;&lt;A href=&quot;http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html&quot;&gt;http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html&lt;/A&gt;&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;br /&gt;5&lt;br /&gt;
&lt;br /&gt;&lt;A href=&quot;http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme-Z-H-1.html#node_toc_node_chap_5&quot;&gt;Lexical variables&lt;/A&gt;&lt;/P&gt;
&lt;P&gt;&lt;A name=node_idx_268&gt;&lt;/A&gt;&lt;A name=node_idx_270&gt;&lt;/A&gt;&lt;A name=node_idx_272&gt;&lt;/A&gt;스킴의 변수들은 렉스컬 스코프를 따른다.&amp;nbsp; 아래의 예제들은 람다 인자를 사용한 지역변수들이다. 이들은 프로시저 호출에서 바인딩을 일으키며 그 범위는 프로시저의 몸이다. &lt;br /&gt;
&lt;br /&gt;
&lt;P&gt;&lt;/P&gt;(&lt;SPAN class=keyword&gt;define&lt;/SPAN&gt; &lt;SPAN class=variable&gt;x&lt;/SPAN&gt; &lt;SPAN class=selfeval&gt;9&lt;/SPAN&gt;)&lt;br /&gt;
(&lt;SPAN class=keyword&gt;define&lt;/SPAN&gt; &lt;SPAN class=variable&gt;add2&lt;/SPAN&gt; (&lt;SPAN class=keyword&gt;lambda&lt;/SPAN&gt; (&lt;SPAN class=variable&gt;x&lt;/SPAN&gt;) (&lt;SPAN class=variable&gt;+&lt;/SPAN&gt; &lt;SPAN class=variable&gt;x&lt;/SPAN&gt; &lt;SPAN class=selfeval&gt;2&lt;/SPAN&gt;)))&lt;br /&gt;
&lt;br /&gt;&lt;SPAN class=variable&gt;x&lt;/SPAN&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;FONT color=teal&gt;&lt;TT&gt;&lt;STRONG&gt;=&amp;gt;&lt;/STRONG&gt;&lt;/TT&gt;&lt;/FONT&gt;&amp;nbsp; &lt;SPAN class=selfeval&gt;9&lt;/SPAN&gt;&lt;br /&gt;
&lt;br /&gt;(&lt;SPAN class=variable&gt;add2&lt;/SPAN&gt; &lt;SPAN class=selfeval&gt;3&lt;/SPAN&gt;) &lt;FONT color=teal&gt;&lt;TT&gt;&lt;STRONG&gt;=&amp;gt;&lt;/STRONG&gt;&lt;/TT&gt;&lt;/FONT&gt;&amp;nbsp; &lt;SPAN class=selfeval&gt;5&lt;/SPAN&gt;&lt;br /&gt;
(&lt;SPAN class=variable&gt;add2&lt;/SPAN&gt; &lt;SPAN class=variable&gt;x&lt;/SPAN&gt;) &lt;FONT color=teal&gt;&lt;TT&gt;&lt;STRONG&gt;=&amp;gt;&lt;/STRONG&gt;&lt;/TT&gt;&lt;/FONT&gt;&amp;nbsp; &lt;SPAN class=selfeval&gt;11&lt;/SPAN&gt;&lt;br /&gt;
&lt;br /&gt;&lt;SPAN class=variable&gt;x&lt;/SPAN&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;FONT color=teal&gt;&lt;TT&gt;&lt;STRONG&gt;=&amp;gt;&lt;/STRONG&gt;&lt;/TT&gt;&lt;/FONT&gt;&amp;nbsp; &lt;SPAN class=selfeval&gt;9&lt;/SPAN&gt;&lt;br /&gt;
&lt;br /&gt;글로벌 x가 있고 로컬인 x 가 있다.&amp;nbsp; 그리고 x 라는 변수를 받는 add2 가 있다.&amp;nbsp; 먼저 글로벌 x 는 9 이다.&amp;nbsp; 그 다음 add2에 2를 입력하면 5가 나오고 x를 입력하면 9에 2를 더한 &amp;nbsp;11 이 나온다.&amp;nbsp;&amp;nbsp;로컬의 x 와 글로벌x는 다르기 때문에 글로벌 값은 영향받지 않고 9가 나온다. 당연해 보인다. &amp;nbsp;&lt;br /&gt;
&lt;br /&gt;그다음의 예제 &lt;CODE class=scheme&gt;&lt;SPAN class=keyword&gt;set!&lt;/SPAN&gt;&lt;/CODE&gt;&amp;nbsp;을 톱레벨에서 실행하면 x의 값을 20을 바꾼다. &lt;br /&gt;
&amp;nbsp;&lt;br /&gt;
(&lt;SPAN class=keyword&gt;set!&lt;/SPAN&gt; &lt;SPAN class=variable&gt;x&lt;/SPAN&gt; &lt;SPAN class=selfeval&gt;20&lt;/SPAN&gt;)&lt;br /&gt;
&lt;br /&gt;글로벌 변수 x 는 이제 9에서 &amp;nbsp;20이 되었다. 
&lt;P&gt;&lt;/P&gt;
&lt;P&gt;&lt;/P&gt;
&lt;P&gt;만약&amp;nbsp; &lt;CODE class=scheme&gt;&lt;SPAN class=keyword&gt;set!&lt;/SPAN&gt;&lt;/CODE&gt; 이&amp;nbsp;&lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;add2의 몸체 안에서 작용하면 어떻게 될까?&lt;br /&gt;
&lt;/SPAN&gt;&lt;/CODE&gt;&lt;br /&gt;
(&lt;SPAN class=keyword&gt;define&lt;/SPAN&gt; &lt;SPAN class=variable&gt;add2&lt;/SPAN&gt;&lt;br /&gt;
&amp;nbsp; (&lt;SPAN class=keyword&gt;lambda&lt;/SPAN&gt; (&lt;SPAN class=variable&gt;x&lt;/SPAN&gt;) (&lt;SPAN class=keyword&gt;set!&lt;/SPAN&gt; &lt;SPAN class=variable&gt;x&lt;/SPAN&gt; (&lt;SPAN class=variable&gt;+&lt;/SPAN&gt; &lt;SPAN class=variable&gt;x&lt;/SPAN&gt; &lt;SPAN class=selfeval&gt;2&lt;/SPAN&gt;))&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;SPAN class=variable&gt;x&lt;/SPAN&gt;))&lt;br /&gt;
&lt;br /&gt;&lt;SPAN class=keyword&gt;&lt;FONT face=&quot;Courier New&quot;&gt;set!&lt;/FONT&gt;&lt;/SPAN&gt; 은 에제 로컬 변수에 2를 더하고 그 값을 되돌린다.&amp;nbsp; 효과면에서 새로운&amp;nbsp;&amp;nbsp;&lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;add2는 변한 것이 없다.&lt;br /&gt;
&lt;br /&gt;&lt;/SPAN&gt;&lt;/CODE&gt;이제 &amp;nbsp;&lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;add2&lt;/SPAN&gt;&lt;/CODE&gt;&amp;nbsp;에 글로벌 &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;x를 적용하자.&lt;/SPAN&gt;&lt;/CODE&gt;&lt;/P&gt;
&lt;P&gt;&lt;/P&gt;&lt;PRE class=scheme&gt;(&lt;SPAN class=variable&gt;add2&lt;/SPAN&gt; &lt;SPAN class=variable&gt;x&lt;/SPAN&gt;) &lt;FONT color=teal&gt;&lt;TT&gt;&lt;STRONG&gt;=&amp;gt;&lt;/STRONG&gt;&lt;/TT&gt;&lt;/FONT&gt;  &lt;SPAN class=selfeval&gt;22&lt;/SPAN&gt;
&lt;/PRE&gt;
&lt;P&gt;&lt;/P&gt;
&lt;P&gt;&lt;CODE class=scheme&gt;&lt;SPAN class=keyword&gt;&lt;SPAN class=variable&gt;add2안에서 &lt;/SPAN&gt;set!&lt;/SPAN&gt;&lt;/CODE&gt; 이 작용한 것은 로컬변수이다. (x는 프로시저를 만들면서 같이 만들어진 로컬 변수다.)&lt;br /&gt;

&lt;P&gt;&lt;/P&gt;&lt;SPAN class=variable&gt;그래서 글로벌 x는 변하지 않는다. &lt;br /&gt;
&lt;br /&gt;x&lt;/SPAN&gt; &lt;FONT color=teal&gt;&lt;TT&gt;&lt;STRONG&gt;=&amp;gt;&lt;/STRONG&gt;&lt;/TT&gt;&lt;/FONT&gt;&amp;nbsp; &lt;SPAN class=selfeval&gt;20&lt;/SPAN&gt;&lt;br /&gt;
&lt;br /&gt;여기까지도 뻔한 내용이다. &lt;br /&gt;
&lt;br /&gt;아래는 로컬 x 가 그로벌 변수를 샤도우 했다는 내용이다. 이&amp;nbsp; 내용은 sicp 3장의 시작부에 잘 나타난다. 
&lt;P&gt;&lt;/P&gt;
&lt;P&gt;&lt;/P&gt;
&lt;P&gt;Note that we had all this discussion because we used the same identifier for a local variable and a global variable. In any text, an identifier named &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;x&lt;/SPAN&gt;&lt;/CODE&gt; refers to the lexically closest variable named &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;x&lt;/SPAN&gt;&lt;/CODE&gt;. This will &lt;EM&gt;shadow&lt;/EM&gt; any outer or global &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;x&lt;/SPAN&gt;&lt;/CODE&gt;'s. Eg, in &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;add2&lt;/SPAN&gt;&lt;/CODE&gt;, the parameter &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;x&lt;/SPAN&gt;&lt;/CODE&gt; shadows the global &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;x&lt;/SPAN&gt;&lt;/CODE&gt;.&lt;br /&gt;
&lt;/P&gt;
&lt;P&gt;그러나 로컬 변수가 아니면 이야기는 달라진다. &lt;br /&gt;
&lt;br /&gt;A procedure's body can access and modify variables in its surrounding scope provided the procedure's parameters don't shadow them. This can give some interesting programs. Eg,&lt;/P&gt;
&lt;P&gt;&lt;/P&gt;&lt;PRE class=scheme&gt;(&lt;SPAN class=keyword&gt;define&lt;/SPAN&gt; &lt;SPAN class=variable&gt;counter&lt;/SPAN&gt; &lt;SPAN class=selfeval&gt;0&lt;/SPAN&gt;)

(&lt;SPAN class=keyword&gt;define&lt;/SPAN&gt; &lt;SPAN class=variable&gt;bump-counter&lt;/SPAN&gt;
  (&lt;SPAN class=keyword&gt;lambda&lt;/SPAN&gt; ()
    (&lt;SPAN class=keyword&gt;set!&lt;/SPAN&gt; &lt;SPAN class=variable&gt;counter&lt;/SPAN&gt; (&lt;SPAN class=variable&gt;+&lt;/SPAN&gt; &lt;SPAN class=variable&gt;counter&lt;/SPAN&gt; &lt;SPAN class=selfeval&gt;1&lt;/SPAN&gt;))
    &lt;SPAN class=variable&gt;counter&lt;/SPAN&gt;))
&lt;/PRE&gt;
&lt;P&gt;&lt;/P&gt;
&lt;P&gt;The procedure &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;bump-counter&lt;/SPAN&gt;&lt;/CODE&gt; is a zero-argument procedure (also called a &lt;EM&gt;thunk&lt;/EM&gt;). It introduces no local variables, and thus cannot shadow anything. Each time it is called, it modifies the &lt;EM&gt;global&lt;/EM&gt; variable &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;counter&lt;/SPAN&gt;&lt;/CODE&gt; -- it increments it by 1 -- and returns its current value. Here are some successive calls to &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;bump-counter&lt;/SPAN&gt;&lt;/CODE&gt;:&lt;/P&gt;
&lt;P&gt;&lt;/P&gt;&lt;PRE class=scheme&gt;(&lt;SPAN class=variable&gt;bump-counter&lt;/SPAN&gt;) &lt;FONT color=teal&gt;&lt;TT&gt;&lt;STRONG&gt;=&amp;gt;&lt;/STRONG&gt;&lt;/TT&gt;&lt;/FONT&gt;  &lt;SPAN class=selfeval&gt;1&lt;/SPAN&gt;
(&lt;SPAN class=variable&gt;bump-counter&lt;/SPAN&gt;) &lt;FONT color=teal&gt;&lt;TT&gt;&lt;STRONG&gt;=&amp;gt;&lt;/STRONG&gt;&lt;/TT&gt;&lt;/FONT&gt;  &lt;SPAN class=selfeval&gt;2&lt;/SPAN&gt;
(&lt;SPAN class=variable&gt;bump-counter&lt;/SPAN&gt;) &lt;FONT color=teal&gt;&lt;TT&gt;&lt;STRONG&gt;=&amp;gt;&lt;/STRONG&gt;&lt;/TT&gt;&lt;/FONT&gt;  &lt;SPAN class=selfeval&gt;3&lt;br /&gt;


&lt;/SPAN&gt;&lt;/PRE&gt;&lt;PRE class=scheme&gt;여기서는 로컬 변수가 없고 counter는 글로벌 변수를 참조한다.  (이런 용법을 free 변수라고 하며 &lt;/PRE&gt;&lt;PRE class=scheme&gt;bump-cpunter는 글로벌이자 free변수인 counter를 증가시킨다. free변수는 람다에 의해 바인딩되지 &lt;/PRE&gt;&lt;PRE class=scheme&gt;변수다.  프리변수는 많은 언어에서 적법하지 않은 요소지만 리스프에서는 예전부터 사용한 변수다.  &lt;/PRE&gt;&lt;PRE class=scheme&gt;나중에 funarg를 정리하면서 반드시 생각해 보아야 할 숙제이기도 하다. )&lt;/PRE&gt;&lt;PRE class=scheme&gt; 
&lt;/PRE&gt;
&lt;P&gt;&lt;/P&gt;
&lt;P&gt;&lt;A name=node_idx_274&gt;&lt;/A&gt;&lt;A name=node_idx_276&gt;&lt;/A&gt;&lt;/P&gt;&lt;A name=node_sec_5.1&gt;&lt;/A&gt;
&lt;H2&gt;&lt;A href=&quot;http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme-Z-H-1.html#node_toc_node_sec_5.1&quot;&gt;5.1&amp;nbsp;&amp;nbsp;&lt;CODE class=scheme&gt;&lt;SPAN class=keyword&gt;let&lt;/SPAN&gt;&lt;/CODE&gt; and &lt;CODE class=scheme&gt;&lt;SPAN class=keyword&gt;let*&lt;/SPAN&gt;&lt;/CODE&gt;&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;&lt;br /&gt;
아래의 내용은 특별한 것이 없다. let과 let*의 차이점이다.&amp;nbsp; let* 이 사실상 let (let ( 처럼 let 안의 let&amp;nbsp; 형태라는 것은 sicp의 연습문제에도 나온다.&amp;nbsp; sicp를 보지 않아도 아래의 예제 정도면 충분하다. &lt;br /&gt;
&lt;br /&gt;Local variables can be introduced without explicitly creating a procedure. The special form &lt;CODE class=scheme&gt;&lt;SPAN class=keyword&gt;let&lt;/SPAN&gt;&lt;/CODE&gt; introduces a list of local variables for use within its body:&lt;/P&gt;
&lt;P&gt;&lt;/P&gt;&lt;PRE class=scheme&gt;(&lt;SPAN class=keyword&gt;let&lt;/SPAN&gt; ((&lt;SPAN class=variable&gt;x&lt;/SPAN&gt; &lt;SPAN class=selfeval&gt;1&lt;/SPAN&gt;)
      (&lt;SPAN class=variable&gt;y&lt;/SPAN&gt; &lt;SPAN class=selfeval&gt;2&lt;/SPAN&gt;)
      (&lt;SPAN class=variable&gt;z&lt;/SPAN&gt; &lt;SPAN class=selfeval&gt;3&lt;/SPAN&gt;))
  (&lt;SPAN class=variable&gt;list&lt;/SPAN&gt; &lt;SPAN class=variable&gt;x&lt;/SPAN&gt; &lt;SPAN class=variable&gt;y&lt;/SPAN&gt; &lt;SPAN class=variable&gt;z&lt;/SPAN&gt;))
&lt;FONT color=teal&gt;&lt;TT&gt;&lt;STRONG&gt;=&amp;gt;&lt;/STRONG&gt;&lt;/TT&gt;&lt;/FONT&gt;  (&lt;SPAN class=selfeval&gt;1&lt;/SPAN&gt; &lt;SPAN class=selfeval&gt;2&lt;/SPAN&gt; &lt;SPAN class=selfeval&gt;3&lt;/SPAN&gt;)
&lt;/PRE&gt;
&lt;P&gt;&lt;/P&gt;
&lt;P&gt;As with &lt;CODE class=scheme&gt;&lt;SPAN class=keyword&gt;lambda&lt;/SPAN&gt;&lt;/CODE&gt;, within the &lt;CODE class=scheme&gt;&lt;SPAN class=keyword&gt;let&lt;/SPAN&gt;&lt;/CODE&gt;-body, the local &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;x&lt;/SPAN&gt;&lt;/CODE&gt; (bound to &lt;CODE class=scheme&gt;&lt;SPAN class=selfeval&gt;1&lt;/SPAN&gt;&lt;/CODE&gt;) shadows the global &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;x&lt;/SPAN&gt;&lt;/CODE&gt; (which is bound to &lt;CODE class=scheme&gt;&lt;SPAN class=selfeval&gt;20&lt;/SPAN&gt;&lt;/CODE&gt;).&lt;/P&gt;
&lt;P&gt;The local variable initializations -- &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;x&lt;/SPAN&gt;&lt;/CODE&gt; to &lt;CODE class=scheme&gt;&lt;SPAN class=selfeval&gt;1&lt;/SPAN&gt;&lt;/CODE&gt;; &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;y&lt;/SPAN&gt;&lt;/CODE&gt; to &lt;CODE class=scheme&gt;&lt;SPAN class=selfeval&gt;2&lt;/SPAN&gt;&lt;/CODE&gt;; &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;z&lt;/SPAN&gt;&lt;/CODE&gt; to &lt;CODE class=scheme&gt;&lt;SPAN class=selfeval&gt;3&lt;/SPAN&gt;&lt;/CODE&gt; -- are not considered part of the &lt;CODE class=scheme&gt;&lt;SPAN class=keyword&gt;let&lt;/SPAN&gt;&lt;/CODE&gt; body. Therefore, a reference to &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;x&lt;/SPAN&gt;&lt;/CODE&gt; in the initialization will refer to the global, not the local &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;x&lt;/SPAN&gt;&lt;/CODE&gt;:&lt;/P&gt;
&lt;P&gt;&lt;/P&gt;&lt;PRE class=scheme&gt;(&lt;SPAN class=keyword&gt;let&lt;/SPAN&gt; ((&lt;SPAN class=variable&gt;x&lt;/SPAN&gt; &lt;SPAN class=selfeval&gt;1&lt;/SPAN&gt;)
      (&lt;SPAN class=variable&gt;y&lt;/SPAN&gt; &lt;SPAN class=variable&gt;x&lt;/SPAN&gt;))
  (&lt;SPAN class=variable&gt;+&lt;/SPAN&gt; &lt;SPAN class=variable&gt;x&lt;/SPAN&gt; &lt;SPAN class=variable&gt;y&lt;/SPAN&gt;))
&lt;FONT color=teal&gt;&lt;TT&gt;&lt;STRONG&gt;=&amp;gt;&lt;/STRONG&gt;&lt;/TT&gt;&lt;/FONT&gt;  &lt;SPAN class=selfeval&gt;21&lt;/SPAN&gt;
&lt;/PRE&gt;
&lt;P&gt;&lt;/P&gt;
&lt;P&gt;This is because &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;x&lt;/SPAN&gt;&lt;/CODE&gt; is bound to &lt;CODE class=scheme&gt;&lt;SPAN class=selfeval&gt;1&lt;/SPAN&gt;&lt;/CODE&gt;, and &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;y&lt;/SPAN&gt;&lt;/CODE&gt; is bound to the &lt;EM&gt;global&lt;/EM&gt; &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;x&lt;/SPAN&gt;&lt;/CODE&gt;, which is &lt;CODE class=scheme&gt;&lt;SPAN class=selfeval&gt;20&lt;/SPAN&gt;&lt;/CODE&gt;.&lt;/P&gt;
&lt;P&gt;Sometimes, it is convenient to have &lt;CODE class=scheme&gt;&lt;SPAN class=keyword&gt;let&lt;/SPAN&gt;&lt;/CODE&gt;'s list of lexical variables be introduced in sequence, so that the initialization of a later variable occurs in the &lt;EM&gt;lexical scope&lt;/EM&gt; of earlier variables. The form &lt;CODE class=scheme&gt;&lt;SPAN class=keyword&gt;let*&lt;/SPAN&gt;&lt;/CODE&gt; does this:&lt;/P&gt;
&lt;P&gt;&lt;/P&gt;&lt;PRE class=scheme&gt;(&lt;SPAN class=keyword&gt;let*&lt;/SPAN&gt; ((&lt;SPAN class=variable&gt;x&lt;/SPAN&gt; &lt;SPAN class=selfeval&gt;1&lt;/SPAN&gt;)
       (&lt;SPAN class=variable&gt;y&lt;/SPAN&gt; &lt;SPAN class=variable&gt;x&lt;/SPAN&gt;))
  (&lt;SPAN class=variable&gt;+&lt;/SPAN&gt; &lt;SPAN class=variable&gt;x&lt;/SPAN&gt; &lt;SPAN class=variable&gt;y&lt;/SPAN&gt;))
&lt;FONT color=teal&gt;&lt;TT&gt;&lt;STRONG&gt;=&amp;gt;&lt;/STRONG&gt;&lt;/TT&gt;&lt;/FONT&gt;  &lt;SPAN class=selfeval&gt;2&lt;/SPAN&gt;
&lt;/PRE&gt;
&lt;P&gt;&lt;/P&gt;
&lt;P&gt;The &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;x&lt;/SPAN&gt;&lt;/CODE&gt; in &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;y&lt;/SPAN&gt;&lt;/CODE&gt;'s initialization refers to the &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;x&lt;/SPAN&gt;&lt;/CODE&gt; just above. The example is entirely equivalent to -- and is in fact intended to be a convenient abbreviation for -- the following program with nested &lt;CODE class=scheme&gt;&lt;SPAN class=keyword&gt;let&lt;/SPAN&gt;&lt;/CODE&gt;s:&lt;/P&gt;
&lt;P&gt;&lt;/P&gt;&lt;PRE class=scheme&gt;(&lt;SPAN class=keyword&gt;let&lt;/SPAN&gt; ((&lt;SPAN class=variable&gt;x&lt;/SPAN&gt; &lt;SPAN class=selfeval&gt;1&lt;/SPAN&gt;))
  (&lt;SPAN class=keyword&gt;let&lt;/SPAN&gt; ((&lt;SPAN class=variable&gt;y&lt;/SPAN&gt; &lt;SPAN class=variable&gt;x&lt;/SPAN&gt;))
    (&lt;SPAN class=variable&gt;+&lt;/SPAN&gt; &lt;SPAN class=variable&gt;x&lt;/SPAN&gt; &lt;SPAN class=variable&gt;y&lt;/SPAN&gt;)))
&lt;FONT color=teal&gt;&lt;TT&gt;&lt;STRONG&gt;=&amp;gt;&lt;/STRONG&gt;&lt;/TT&gt;&lt;/FONT&gt;  &lt;SPAN class=selfeval&gt;2&lt;/SPAN&gt;
&lt;/PRE&gt;
&lt;P&gt;&lt;/P&gt;
&lt;P&gt;The values bound to lexical variables can be procedures:&lt;/P&gt;
&lt;P&gt;&lt;/P&gt;&lt;PRE class=scheme&gt;(&lt;SPAN class=keyword&gt;let&lt;/SPAN&gt; ((&lt;SPAN class=variable&gt;cons&lt;/SPAN&gt; (&lt;SPAN class=keyword&gt;lambda&lt;/SPAN&gt; (&lt;SPAN class=variable&gt;x&lt;/SPAN&gt; &lt;SPAN class=variable&gt;y&lt;/SPAN&gt;) (&lt;SPAN class=variable&gt;+&lt;/SPAN&gt; &lt;SPAN class=variable&gt;x&lt;/SPAN&gt; &lt;SPAN class=variable&gt;y&lt;/SPAN&gt;))))
  (&lt;SPAN class=variable&gt;cons&lt;/SPAN&gt; &lt;SPAN class=selfeval&gt;1&lt;/SPAN&gt; &lt;SPAN class=selfeval&gt;2&lt;/SPAN&gt;))
&lt;FONT color=teal&gt;&lt;TT&gt;&lt;STRONG&gt;=&amp;gt;&lt;/STRONG&gt;&lt;/TT&gt;&lt;/FONT&gt;  &lt;SPAN class=selfeval&gt;3&lt;/SPAN&gt;
&lt;/PRE&gt;
&lt;P&gt;&lt;/P&gt;
&lt;P&gt;Inside this &lt;CODE class=scheme&gt;&lt;SPAN class=keyword&gt;let&lt;/SPAN&gt;&lt;/CODE&gt; body, the lexical variable &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;cons&lt;/SPAN&gt;&lt;/CODE&gt; adds its arguments. Outside, &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;cons&lt;/SPAN&gt;&lt;/CODE&gt; continues to create dotted pairs.&lt;/P&gt;
&lt;P&gt;&lt;A name=node_idx_278&gt;&lt;/A&gt;&lt;/P&gt;
&lt;P&gt;&lt;/P&gt;&lt;A name=node_sec_5.2&gt;&lt;/A&gt;
&lt;H2&gt;&lt;A href=&quot;http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme-Z-H-1.html#node_toc_node_sec_5.2&quot;&gt;5.2&amp;nbsp;&amp;nbsp;&lt;CODE class=scheme&gt;&lt;SPAN class=keyword&gt;fluid-let&lt;/SPAN&gt;&lt;/CODE&gt;&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;&lt;/P&gt;
&lt;P&gt;&lt;br /&gt;
그런데 렉시컬 변수도 때로는 일정한 값으로 유지되는 편이 나을지도 모른다.&amp;nbsp; fluid -let 은 이런 경우에 사용된다.&lt;br /&gt;
fluid 라는 이름은 지난번에 설명한 다이나믹 바인딩과 유사한 성격이다.&lt;br /&gt;
&lt;CODE class=scheme&gt;&lt;SPAN class=keyword&gt;fluid-let 은 글로벌 변수를 가리는 (샤도우하는 ) 것이 아니라 counter를 임시로 99로 세팅한다. &lt;br /&gt;
&lt;/SPAN&gt;&lt;/CODE&gt;&lt;br /&gt;
(&lt;SPAN class=keyword&gt;fluid-let&lt;/SPAN&gt; ((&lt;SPAN class=variable&gt;counter&lt;/SPAN&gt; &lt;SPAN class=selfeval&gt;99&lt;/SPAN&gt;))&lt;br /&gt;
&amp;nbsp; (&lt;SPAN class=variable&gt;display&lt;/SPAN&gt; (&lt;SPAN class=variable&gt;bump-counter&lt;/SPAN&gt;)) (&lt;SPAN class=variable&gt;newline&lt;/SPAN&gt;)&lt;br /&gt;
&amp;nbsp; (&lt;SPAN class=variable&gt;display&lt;/SPAN&gt; (&lt;SPAN class=variable&gt;bump-counter&lt;/SPAN&gt;)) (&lt;SPAN class=variable&gt;newline&lt;/SPAN&gt;)&lt;br /&gt;
&amp;nbsp; (&lt;SPAN class=variable&gt;display&lt;/SPAN&gt; (&lt;SPAN class=variable&gt;bump-counter&lt;/SPAN&gt;)) (&lt;SPAN class=variable&gt;newline&lt;/SPAN&gt;))&lt;br /&gt;
&lt;/P&gt;
&lt;P&gt;&lt;/P&gt;
&lt;P&gt;&lt;/P&gt;&lt;PRE class=verbatim&gt;100&amp;nbsp;
101&amp;nbsp;
102&amp;nbsp;
&lt;/PRE&gt;
&lt;P&gt;&lt;/P&gt;
&lt;P&gt;&amp;nbsp;&lt;CODE class=scheme&gt;&lt;SPAN class=keyword&gt;fluid-let&lt;/SPAN&gt;&lt;/CODE&gt; 을 사용한 식의 계산이 끝나면 global counter의 값은 다시 원래로 돌아간다. &lt;SPAN class=variable&gt;&lt;br /&gt;
&lt;br /&gt;counter&lt;/SPAN&gt; &lt;FONT color=teal&gt;&lt;TT&gt;&lt;STRONG&gt;=&amp;gt;&lt;/STRONG&gt;&lt;/TT&gt;&lt;/FONT&gt;&amp;nbsp; &lt;SPAN class=selfeval&gt;3&lt;/SPAN&gt;&lt;br /&gt;
&lt;br /&gt;&lt;SPAN class=keyword&gt;&lt;FONT face=&quot;Courier New&quot;&gt;fluid-let&lt;/FONT&gt;&lt;/SPAN&gt; 은 let과 다르다. let처럼 완전히 새로운&amp;nbsp; 렉시컬 변수를 만드는 것이 아니라 현재의 렉시컬 변수의 바인딩만 바꾼다. &lt;/P&gt;
&lt;P&gt;&lt;/P&gt;
&lt;P&gt;
&lt;P&gt;&lt;/P&gt;이제&amp;nbsp; 다시 원점으로 돌아와서 let을 사용한 예제를 돌려보자. &lt;br /&gt;
&lt;br /&gt;(&lt;SPAN class=keyword&gt;let&lt;/SPAN&gt; ((&lt;SPAN class=variable&gt;counter&lt;/SPAN&gt; &lt;SPAN class=selfeval&gt;99&lt;/SPAN&gt;))&lt;br /&gt;
&amp;nbsp; (&lt;SPAN class=variable&gt;display&lt;/SPAN&gt; (&lt;SPAN class=variable&gt;bump-counter&lt;/SPAN&gt;)) (&lt;SPAN class=variable&gt;newline&lt;/SPAN&gt;)&lt;br /&gt;
&amp;nbsp; (&lt;SPAN class=variable&gt;display&lt;/SPAN&gt; (&lt;SPAN class=variable&gt;bump-counter&lt;/SPAN&gt;)) (&lt;SPAN class=variable&gt;newline&lt;/SPAN&gt;)&lt;br /&gt;
&amp;nbsp; (&lt;SPAN class=variable&gt;display&lt;/SPAN&gt; (&lt;SPAN class=variable&gt;bump-counter&lt;/SPAN&gt;)) (&lt;SPAN class=variable&gt;newline&lt;/SPAN&gt;))&lt;br /&gt;

&lt;P&gt;&lt;/P&gt;
&lt;P&gt;&lt;/P&gt;
&lt;P&gt;
&lt;P&gt;&lt;/P&gt;&lt;SPAN class=selfeval&gt;결과는&lt;br /&gt;
&lt;br /&gt;4&lt;/SPAN&gt;&lt;br /&gt;
&lt;SPAN class=selfeval&gt;5&lt;/SPAN&gt;&lt;br /&gt;
&lt;SPAN class=selfeval&gt;6&lt;/SPAN&gt;&lt;br /&gt;
&lt;br /&gt;글로벌 변수&amp;nbsp; &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;counter는 아무런 영향을 받지 않았다. bump-counter를 호출하기는 했으나 bump-counter의&amp;nbsp;counter는 글로벌 변수를 참조했으며 아무런 영향이 없었던 것이다. 그러나 fluid-let은&amp;nbsp;일시적으로 모든 counter 변수의 바인딩을 유지했다.&lt;br /&gt;
&lt;br /&gt;(이것은 지난번의 dynamic 변수 예제를 보고 다시&amp;nbsp;한번 대조해 보면 이해할 수 있을 것이다.)&lt;br /&gt;
&amp;nbsp;&lt;/SPAN&gt;&lt;/CODE&gt; 
&lt;P&gt;&lt;/P&gt;
&lt;P&gt;&lt;/P&gt;
&lt;P&gt;Ie, the global, which is initially &lt;CODE class=scheme&gt;&lt;SPAN class=selfeval&gt;3&lt;/SPAN&gt;&lt;/CODE&gt;, is updated by each call to &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;bump-counter&lt;/SPAN&gt;&lt;/CODE&gt;. The new lexical variable &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;counter&lt;/SPAN&gt;&lt;/CODE&gt;, with its initialization of &lt;CODE class=scheme&gt;&lt;SPAN class=selfeval&gt;99&lt;/SPAN&gt;&lt;/CODE&gt;, has no impact on the calls to &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;bump-counter&lt;/SPAN&gt;&lt;/CODE&gt;, because although the calls to &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;bump-counter&lt;/SPAN&gt;&lt;/CODE&gt; are within the scope of this local &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;counter&lt;/SPAN&gt;&lt;/CODE&gt;, the body of &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;bump-counter&lt;/SPAN&gt;&lt;/CODE&gt; isn't. The latter continues to refer to the &lt;EM&gt;global&lt;/EM&gt; &lt;CODE class=scheme&gt;&lt;SPAN class=variable&gt;counter&lt;/SPAN&gt;&lt;/CODE&gt;, whose final value is &lt;CODE class=scheme&gt;&lt;SPAN class=selfeval&gt;6&lt;/SPAN&gt;&lt;/CODE&gt;.&lt;/P&gt;
&lt;P&gt;&lt;/P&gt;&lt;PRE class=scheme&gt;&lt;SPAN class=variable&gt;counter&lt;/SPAN&gt; &lt;FONT color=teal&gt;&lt;TT&gt;&lt;STRONG&gt;=&amp;gt;&lt;/STRONG&gt;&lt;/TT&gt;&lt;/FONT&gt;  &lt;SPAN class=selfeval&gt;6&lt;/SPAN&gt;
&lt;/PRE&gt;
&lt;P&gt;&lt;/P&gt;
&lt;P&gt;counter는 이제 6이 되었다. 99로 세팅한 로컬 변수는 아무런 영향을 미치지 못했다. &lt;br /&gt;
&lt;br /&gt;아주 좋은 예이긴 하지만 실감이 나지 않을지도 모른다. 하지만&amp;nbsp; 중요한&amp;nbsp; 차이점이다. &lt;br /&gt;
좋은 예를 만들어 내는 것은 중요한 일이지만 일단 이 정도 예제로 대부분 이해하고 있으니 오늘은 여기까지 ..&lt;br /&gt;
&lt;br /&gt;(fluid-let은 비표준형의 스페셜 폼이며 마크로로 만들었다. 8.3 장에 만드는 방법이 있다.)&amp;nbsp;&lt;/P&gt;&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;a href=&quot;http://creativecommons.org/licenses/by/4.0/deed.ko&quot; target=&quot;_blank&quot; style=&quot;text-decoration: none&quot;&gt;
	&lt;img id=&quot;ccl-icon-105-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-fr/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-fr/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/DerivativeWorks&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
	&lt;/a&gt;
&lt;/div&gt;
</description>
<category>lisp</category>
<author>toyfab</author>
<guid>http://toyfab.tistory.com/105</guid>
<comments>http://toyfab.tistory.com/entry/%EB%B3%80%EC%88%98%EC%97%90-%EB%8C%80%ED%95%B4-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EA%B8%B0-2-Teach-Yourself-Scheme-in-Fixnum-Days#entry105comment</comments>
<pubDate>Thu, 26 Mar 2009 22:03:42 +0900</pubDate>
</item>
<item>
<title>동적 바인딩 생각해 보기 (1)</title>
<link>http://toyfab.tistory.com/entry/1416-DYNAMIC-SCOPING</link>
<description>리스프에서 아마 가장 많은 문제를 일으킨 부분이 동적 바인딩과 FUNARG 문제일 것이다. &lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
14.16 DYNAMIC SCOPING&lt;br /&gt;
&lt;br /&gt;14.16 은 gentle intro to symbolic computation 의 사실상 &amp;nbsp;마지막 부분에 해당한다. 몇페이뒤의 4.18에서 책의 본문이 끝나기 &amp;nbsp;때문이다.&amp;nbsp;&amp;nbsp;이해하기가 조금 애매한 부분이기도 하다.&amp;nbsp; 아무튼 개인적인 생각으로는 이 책의 설명이 제일 나은 것 같다. 다시 말하지만 개인적인 생각이다. &lt;br /&gt;
&lt;br /&gt;책의 마지막에 이르기까지&amp;nbsp;동적(dynamic) 스코프를 사용하지 않고 설명을 했고 저자는&amp;nbsp;마지막 부분에서 렉시컬 스코프와 동적 스코프의 구분을 하고 있다. &lt;br /&gt;
&lt;br /&gt;대부분의 언어들은 렉시컬 스코프를 적용하고 있고&amp;nbsp;동적 스코프는 별로 쓰이지 않는다. &lt;br /&gt;
그러나 한때는 리스프에서&amp;nbsp;동적 스코프가 표준이었다.&amp;nbsp;&lt;br /&gt;
&lt;br /&gt;동적 스코프에 대해서는 많은 오해가 있기 때문에 설명할 필요가 있다.&amp;nbsp;&amp;nbsp; 글을 쓰고 있는 사람도 예외가 아니다. 그러나 생각해 보면 매우 자연스럽기도 하다.&amp;nbsp; 과거의 리스프 해커들은 동적 스코프를 썼을 뿐만 아니라 응용하고 기법화하기 조차 했다. &lt;br /&gt;
&lt;br /&gt;책의 해설을 잠깐 옮기면 foo 라는 함수가 X라는 변수에&amp;nbsp;접근하려면 foo라는 함수는 X라는 변수가 정의된&amp;nbsp;문맥 안에 존재해야 한다는 점이다.&amp;nbsp; 만약 foo가&amp;nbsp;toplevel&amp;nbsp;에서 정의되었다면 foo가 접근할 수 있는 변수는 글로벌 변수와 함수안에서 정의된 로칼변수뿐이다. &amp;nbsp;그러나 bar 라는 함수안에 어떤 람다식으로 정의된 함수가&amp;nbsp;있다면 이 함수는 bar의&amp;nbsp;변수에 접근할 수 있고 자신의 로컬 변수에도 접근할 수 있다. Bar의 바깥에 정의된 함수들은 bar의 변수들에 접근할 수 없다, &lt;br /&gt;
&lt;br /&gt;동적 변수는 때로 스페셜변수라고도 부른다. 일단 변수 이름이 스페셜로 선언되면 이 변수는 어떤 함수에 대해서도 로컬변수가 아니다.&amp;nbsp; (이점은 정말 중요하다.) 변수는 어디서나 접근할 수 있는 것이다.&amp;nbsp; 그러나 렉시컬 스코프의 변수는 정의된&amp;nbsp; 몸체에서만 접근할 수 있다.&amp;nbsp;&lt;br /&gt;
&lt;br /&gt;스페셜 변수를 정의하는 방법의 하나는&amp;nbsp; DEFVAR macro 를 사용하는 것이다. 이를테면 (defvar birds) &lt;br /&gt;
&lt;br /&gt;이제 예를 들어보자 &lt;br /&gt;
BIRDS 는&amp;nbsp; 동적 스코프의 변수이고&amp;nbsp;FISH 는 렉시컬 스코프의 변수라고 하자.이제 이들에게 적당한 값을 주고 이들을 사용하는 함수도 하나 만들어 보자.&lt;br /&gt;
&lt;br /&gt;먼저 동적 변수를 하나 선언한다.&lt;br /&gt;
(defvar birds) &lt;br /&gt;
&lt;br /&gt;적당한 값을 만든다. &lt;br /&gt;
&lt;br /&gt;(setf fish ’(salmon tuna))&lt;br /&gt;
(setf birds ’(eagle vulture))&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
(defun ref-fish ()&lt;br /&gt;
fish)&lt;br /&gt;
&lt;br /&gt;(defun ref-birds ()&lt;br /&gt;
birds)&lt;br /&gt;
&lt;br /&gt;두개의 함수는 동적인 변수와&amp;nbsp; 렉시컬 변수를 돌려준다. &lt;br /&gt;
&lt;br /&gt;(ref-fish)&amp;nbsp;&lt;br /&gt;
--&amp;gt; (salmon tuna)&lt;br /&gt;
(ref-birds)&amp;nbsp;&lt;br /&gt;
--&amp;gt; (eagle vulture)&lt;br /&gt;
&lt;br /&gt;이제 렉시컬 변수를 시험하는 함수를 만들어 보자. &lt;br /&gt;
&lt;br /&gt;(defun test-lexical (fish)&lt;br /&gt;
(list fish (ref-fish)))&lt;br /&gt;
&lt;br /&gt;인자로 받은 fish와 reffish 함수의 결과를 다시 리스트로 만든다. &lt;br /&gt;
&lt;br /&gt;&amp;gt; (test-lexical ’(guppy minnow))&lt;br /&gt;
((GUPPY MINNOW) (SALMON TUNA))&lt;br /&gt;
&lt;br /&gt;결과는 로컬 변수 fish를 돌려준다. 그리고 이 로컬 변수는 ref-fish에서는 접근할 수 없는 값으로 톱레벨에서 정의된 ref-fish는 글로벌 환경의 fish를 돌려준다. 그결과 로컬 변수로 (GUPPY MINNOW)를 글로벌 변수인 (SALMON TUNA)를 보여준다. &lt;br /&gt;
&lt;br /&gt;각각 다른 스코프를 쓰고 있다는 것을 보여준다. &lt;br /&gt;
책의 437 페이지에 있는 그림을 보면&amp;nbsp; 동작 원리를 eval-trace 그림으로 보여준다. &lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
동적스코프를 글로벌 변수와 혼동해서 설명하는 사람들이 많지만 사실은 다르다. &lt;br /&gt;
&lt;br /&gt;동적 스코프의 경우 (이전에 birds를 동적변수로 정의했다.)&amp;nbsp; 결과는 하나는 같고 하나는 달라진다.&amp;nbsp; 이차이는 defvar가 birds를 스페셜 변수로 만들어 놓았기 때문이다.&lt;br /&gt;
&lt;br /&gt;먼저 함수를 정의하자 . 이 함수는 birds를 사용한다. &lt;br /&gt;
&lt;br /&gt;(defun test-dynamic (birds)&lt;br /&gt;
(list birds (ref-birds)))&lt;br /&gt;
&lt;br /&gt;인자로 '(robin sparrow)를 사용했다. &lt;br /&gt;
&lt;br /&gt;&amp;gt; (test-dynamic ’(robin sparrow))&lt;br /&gt;
&lt;br /&gt;결과는&amp;nbsp; 다음과 같다. &lt;br /&gt;
((ROBIN SPARROW) (ROBIN SPARROW))&lt;br /&gt;
&lt;br /&gt;&amp;nbsp;&amp;nbsp;ref-birds가&amp;nbsp; 주어진 인자와 같은 값을 낸 것이다.&amp;nbsp; &lt;br /&gt;
&lt;br /&gt;식의 계산이 끝나고&amp;nbsp;ref-birds는&amp;nbsp; 원래의 값을 다시 돌려준다. 수행중에는 아니었다. &lt;br /&gt;
&amp;gt; (ref-birds)&lt;br /&gt;
(EAGLE VULTURE)&lt;br /&gt;
&lt;br /&gt;이런 이상한 답을 내어준 것은 다름이 아니다. TEST-DYNAMIC으로 진입하면서 스페셜 변수로 정의된 BIRDS 가 만들어진 것이고 몸체를 빠져 나가기 전까지 BIRDS는 이 값을 갖게된다. TEST-DYNAMIC 의 밖에 있는 함수 (ref-birds) 에서도 마찬가지다.&amp;nbsp;BIRDS 라는 이름의 원래의 글로변 변수는 동적인 변수가 있는한 접근가능하지 않다.&amp;nbsp; test-dynamic&amp;nbsp; 함수를 빠져 나오면서 함수의&amp;nbsp;인자인 BIRDS가 사라지면&amp;nbsp; 원래의 BIRDS 값이&amp;nbsp;복원된다. &lt;br /&gt;
&lt;br /&gt;동적이라는 이름이 붙은 것은 REF-BIRDS의 BIRDS라는 이름의 변수의 값이 한 변수에 영구적으로 고정된 것이 아니라는 점이다. FISH 의 경우에는 고정되어 있었다, 그러나&amp;nbsp; BIRDS는 TEST-DYNAMIC로 들어가며 변수의 값이 새로 고정되고 나중에 원래의 값으로 돌아갔다.&amp;nbsp; &lt;br /&gt;
&lt;br /&gt;(이 과정은 바인딩이 일어날 때마다 항상 변한다. 예측이 불가능한 경우도 있다. 만약에 중간에 다른 바인딩이 일어났으면 도대체 어떤 BIRDS를 바인딩하고 있을지 정말 애매하다. &lt;br /&gt;
&lt;br /&gt;그리고 한가지 더 첨부하자면 birds는 함수의 범위를 무시하고 글로벌 함수인 ref-fish의 동작까지 영향을 주다가&amp;nbsp; 영향력을 상실했다.)&lt;br /&gt;
&lt;br /&gt;스페셜 변수는 조심스레 사용되어야 한다. 초기의 리스프들에서&amp;nbsp; 동적 스코프가 기본이었을 당시 한 함수는 다른 함수가 만든 변수의 값을 바꾸는 경우가 있었고 드물지만 문제를 일으키곤 했다.&amp;nbsp; 렉시컬에서는 이런 일은 일어나지 않는다. 하지만 가끔씩은 동적 스코프의 변수의 사용이 합당한 경우가 있고 이들은 4.18에서 볼 것이다. &lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
- 이제 4.16을 이해했으면 4.18을 이해하는 것은 아무런 문제가 없다. &lt;br /&gt;
이런 동적 바인딩과 렉시컬 바인딩을 차이나게 하는&amp;nbsp; 근본적인 이유는&amp;nbsp; 새로운 환경을 만드는 방법에 달려있다. &lt;br /&gt;
&lt;br /&gt;BIND함수가 환경을 어떻게 바인드하느냐에 따라 달라진다. &lt;br /&gt;
나중에 TAOI에서 자세히 설명하겠다. &lt;br /&gt;
&lt;br /&gt;만약 그때까지 기다리기가 어려우면 다른 자료들을 열심히 찾아보면 된다.&lt;br /&gt;
(그러나 이 글을 다시 한번 읽게 될 것이다. )&lt;br /&gt;&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;a href=&quot;http://creativecommons.org/licenses/by/4.0/deed.ko&quot; target=&quot;_blank&quot; style=&quot;text-decoration: none&quot;&gt;
	&lt;img id=&quot;ccl-icon-100-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-fr/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-fr/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/DerivativeWorks&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
	&lt;/a&gt;
&lt;/div&gt;
</description>
<category>lisp</category>
<author>toyfab</author>
<guid>http://toyfab.tistory.com/100</guid>
<comments>http://toyfab.tistory.com/entry/1416-DYNAMIC-SCOPING#entry100comment</comments>
<pubDate>Sat, 21 Mar 2009 21:10:49 +0900</pubDate>
</item>
<item>
<title>anatomy of lisp</title>
<link>http://toyfab.tistory.com/entry/anatomy-of-lisp</link>
<description>&lt;br /&gt;
sicp의 참고문헌에 맨 위에 뜨는 책이다. &lt;br /&gt;
저자의 이름은 John Allen 이다. &lt;br /&gt;
절판되었으나 아마존에서 구할 수 있다. 가격은 110 달라에서 150 달러 사이인 것 같다. &lt;br /&gt;
ACM classic 20선중에 들어 있기도 했다.&amp;nbsp; &lt;br /&gt;
&lt;br /&gt;&lt;IMG src=&quot;http://g-ecx.images-amazon.com/images/G/01/ciu/e2/de/097fb340dca0bf2d71367010._AA240_.L.jpg&quot;&gt;&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
책의 출판년도는 1978년으로 되어있거나 1979년으로 되어 있다. &lt;br /&gt;
Knuth가 책의 조판을 도와주었다고 적혀 있다. LaTEK 의 초기 버전으로 만들어져서 인쇄된 결과물이 엉망이다. &lt;br /&gt;
&lt;br /&gt;이책의 특징은 프로그램을 어떻게 분석하는가를 알려준다.&amp;nbsp; &lt;br /&gt;
프로그래밍이 아니라 컴퓨테이션을 가르친다고 보면 된다. &lt;br /&gt;
알렌은 이 책으로 학생들을 위한 입문과정을 가르쳤다. &lt;br /&gt;
이 책을 가르칠 수 있으려면 아주 우수한&amp;nbsp;강의자가 필요한 것은 분명하다. &lt;br /&gt;
&lt;br /&gt;책의 난이도는 상당히 높다.&amp;nbsp; 수식을 보면 공포스러울 정도다. 책이 중시하는 것은 mathematical thinking이다. &lt;br /&gt;
같은 내용이라도 수식처럼 만들어 놓은 식을 보면 무서운 것은 아마 나만의 일은 아닐 것이다. &lt;br /&gt;
정교함의 댓가라고 할 수 있다.&amp;nbsp; &lt;br /&gt;
&lt;br /&gt;스킴의 저자들은 알렌으로부터&amp;nbsp;많은 영향을 받았다. 알렌은 초기 리스프의 구현멤버이기도 했다.&amp;nbsp; &lt;br /&gt;
책의 평가는 극과 극이다. sicp와 마찬가지다.&amp;nbsp; &lt;br /&gt;
&lt;br /&gt;리스프에 대한 클래식이고 정교한 동작에 대해 관심이 있는 사람은 읽어 볼만한 책이다.&lt;br /&gt;
혹자는 Lisp In Small Pieces가 요즘 시대에 맞다고 하는데 이 책은 시대와는 상관이 없다. &lt;br /&gt;
정교하고 엄밀한 evaluation 에 대한 여러 방향의 &amp;nbsp;분석을 시도한다. &lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;br /&gt;&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;a href=&quot;http://creativecommons.org/licenses/by/4.0/deed.ko&quot; target=&quot;_blank&quot; style=&quot;text-decoration: none&quot;&gt;
	&lt;img id=&quot;ccl-icon-98-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-fr/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-fr/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/DerivativeWorks&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
	&lt;/a&gt;
&lt;/div&gt;
</description>
<category>lisp</category>
<author>toyfab</author>
<guid>http://toyfab.tistory.com/98</guid>
<comments>http://toyfab.tistory.com/entry/anatomy-of-lisp#entry98comment</comments>
<pubDate>Sat, 21 Mar 2009 17:27:17 +0900</pubDate>
</item>
<item>
<title>A Gentle Introduction to Symbolic Computation</title>
<link>http://toyfab.tistory.com/entry/A-Gentle-Introduction-to-Symbolic-Computation</link>
<description>&lt;CENTER&gt;
&lt;H1&gt;&lt;A href=&quot;http://www.cs.cmu.edu/~dst/LispBook/index.html&quot;&gt;&lt;SPAN style=&quot;FONT-SIZE: 11pt&quot;&gt;http://www.cs.cmu.edu/~dst/LispBook/index.html&lt;/SPAN&gt;&lt;/A&gt;&lt;/H1&gt;
&lt;H3&gt;&lt;SPAN style=&quot;FONT-SIZE: 11pt&quot;&gt;David S. Touretzky의 책으로 마음의 여유만 있으면 쉽게 리스프를 배울 수 있는 좋은 책이다. &lt;/SPAN&gt;&lt;STRONG&gt;&lt;SPAN style=&quot;FONT-SIZE: 11pt&quot;&gt;그레이엄의 유명한 on lisp은 이 책에 나오는 마크로 부분이&amp;nbsp;부족한 부분이 있다고 생각하던 &lt;/SPAN&gt;&lt;SPAN style=&quot;FONT-SIZE: 11pt&quot;&gt;David S. Touretzky 와 그레이엄의 공저라고 볼 수 있다.&lt;br /&gt;
물론 ansi common lisp 는 좋은 책이지만 이 책은 공짜라는 점에서 그리고 친절한 설명이 지나칠 정도라는 점에서 아주 좋은 책이다.&amp;nbsp; 그러나 어떤 부분의 설명은 아주 예리하다. 너무 쉽다고&amp;nbsp;평가절하하는 리뷰를 믿지 않았으면 한다. &lt;br /&gt;
(개인적인 의견을 덧붙이자면 ansi common lisp 은 날카롭지만 비싸며&amp;nbsp; practical common lisp은 가끔 예리하지 않은 주제로 혼동을 준다.&amp;nbsp; 하지만 둘다 좋은 책이다.&amp;nbsp; 그 두책만큼 이 책도 우수하다. 사람들이 좋다고 하는 리스프 교과서들은 사실 어느 정도는 다 비슷하다. 이 정도로도 초보자들은 몇개월은 재미있게 읽을 수 있다. &lt;br /&gt;
한글로 된 쉽고 우수한 교과서가 있으면 좋겠지만 없는 것 같다. )&lt;br /&gt;
&lt;/SPAN&gt;&lt;/STRONG&gt;&lt;/H3&gt;
&lt;P&gt;&amp;nbsp;&lt;/P&gt;
&lt;H1&gt;&amp;nbsp;&lt;/H1&gt;
&lt;H1&gt;Common Lisp: A Gentle Introduction to Symbolic Computation&lt;/H1&gt;
&lt;H3&gt;David S. Touretzky&lt;/H3&gt;&lt;/CENTER&gt;&lt;IMG src=&quot;http://www.cs.cmu.edu/~dst/LispBook/frontcover.jpg&quot; align=left&gt; &lt;FONT size=+2&gt;&lt;br /&gt;
This book may be distributed in hardcopy form, for non-profit educational purposes, provided that no fee is charged to the recipient beyond photocopying costs. All other rights reserved. You may &lt;I&gt;not&lt;/I&gt; redistribute the Postscript file, e.g., you may not put a copy on another web page, or include it on a CD-ROM.&lt;br /&gt;
&lt;br /&gt;&lt;A href=&quot;http://www.cs.cmu.edu/~dst/LispBook/book.ps&quot;&gt;Entire book -- Postscript&lt;/A&gt; (1.75 MB file)&lt;br /&gt;
&lt;br /&gt;&lt;A href=&quot;http://www.cs.cmu.edu/~dst/LispBook/book.pdf&quot;&gt;Entire book -- PDF&lt;/A&gt; (1 MB file)&lt;br /&gt;
&lt;br /&gt;&lt;A href=&quot;http://www.cs.cmu.edu/~dst/Lisp&quot;&gt;Free software&lt;/A&gt; accompanying this book is also available.&lt;br /&gt;
&lt;br /&gt;Materials provided by &lt;A href=&quot;http://www.cs.cmu.edu/~dst&quot;&gt;David S. Touretzky&lt;/A&gt;, Carnegie Mellon University. &lt;/FONT&gt;&lt;BR clear=all&gt;&lt;br /&gt;&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;a href=&quot;http://creativecommons.org/licenses/by/4.0/deed.ko&quot; target=&quot;_blank&quot; style=&quot;text-decoration: none&quot;&gt;
	&lt;img id=&quot;ccl-icon-97-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-fr/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-fr/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/DerivativeWorks&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
	&lt;/a&gt;
&lt;/div&gt;
</description>
<category>lisp</category>
<author>toyfab</author>
<guid>http://toyfab.tistory.com/97</guid>
<comments>http://toyfab.tistory.com/entry/A-Gentle-Introduction-to-Symbolic-Computation#entry97comment</comments>
<pubDate>Fri, 20 Mar 2009 23:55:33 +0900</pubDate>
</item>
<item>
<title>The Y Combinator</title>
<link>http://toyfab.tistory.com/entry/The-Y-Combinator</link>
<description>&lt;DIV style=&quot;TEXT-ALIGN: left&quot;&gt;
&lt;H2&gt;&lt;SPAN style=&quot;FONT-SIZE: 11pt&quot;&gt;Recursion의 본질에 해당하는 Y 컴비네이터는 &lt;/SPAN&gt;&lt;/H2&gt;
&lt;CENTER&gt;&lt;/CENTER&gt;&lt;/DIV&gt;
&lt;DIV style=&quot;TEXT-ALIGN: left&quot;&gt;
&lt;CENTER&gt;
&lt;DIV&gt;
&lt;DIV style=&quot;TEXT-ALIGN: justify&quot;&gt;
&lt;CENTER&gt;&lt;/CENTER&gt;&lt;/DIV&gt;
&lt;DIV style=&quot;TEXT-ALIGN: left&quot;&gt;
&lt;P&gt;&lt;SPAN style=&quot;FONT-SIZE: 11pt&quot;&gt;하스켈 커리가 발견했다&lt;/SPAN&gt;.&amp;nbsp;&lt;br /&gt;
영어판 위키백과에 나오는 Y combinator 에는&amp;nbsp; 다음과 같은 내용이 있다.&amp;nbsp;&lt;br /&gt;
&lt;br /&gt;One well-known (and perhaps the simplest) fixed point combinator in the &lt;A class=mw-redirect title=&quot;Untyped lambda calculus&quot; href=&quot;http://en.wikipedia.org/wiki/Untyped_lambda_calculus&quot;&gt;untyped lambda calculus&lt;/A&gt; is called the &lt;B&gt;Y&lt;/B&gt; combinator. It was discovered by &lt;A title=&quot;Haskell Curry&quot; href=&quot;http://en.wikipedia.org/wiki/Haskell_Curry&quot;&gt;Haskell B. Curry&lt;/A&gt;, and is defined as&lt;/P&gt;
&lt;DL&gt;
&lt;DD&gt;&lt;B&gt;Y&lt;/B&gt; = λf·(λx·f (x x)) (λx·f (x x)) &lt;/DD&gt;&lt;/DL&gt;
&lt;P&gt;We can see that this function acts as a fixed point combinator by expanding it for an example function &lt;I&gt;g&lt;/I&gt;:&lt;/P&gt;&lt;PRE&gt;&lt;B&gt;Y&lt;/B&gt; g = (λf . (λx . f (x x)) (λx . f (x x))) g
&lt;B&gt;Y&lt;/B&gt; g = (λx . g (x x)) (λx . g (x x)) (β-reduction of λf - applied main function to g)
&lt;B&gt;Y&lt;/B&gt; g = (λy . g (y y)) (λx . g (x x)) (α-conversion - renamed bound variable)
&lt;B&gt;Y&lt;/B&gt; g = g ((λx . g (x x)) (λx . g (x x))) (β-reduction of λy - applied left function to right function)
&lt;B&gt;Y&lt;/B&gt; g = g (&lt;B&gt;Y&lt;/B&gt; g) (definition of &lt;B&gt;Y&lt;/B&gt;)
&lt;/PRE&gt;
&lt;P&gt;&lt;br /&gt;
&lt;SPAN style=&quot;FONT-SIZE: 10pt&quot;&gt;&lt;SPAN style=&quot;FONT-SIZE: 10pt&quot;&gt;Y combinator&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;SPAN style=&quot;FONT-SIZE: 10pt&quot;&gt;는&amp;nbsp;&amp;nbsp;Fixed Point 의 본질에 해당하는 부분으로 설명할 내용이 많다.&amp;nbsp;&lt;/SPAN&gt;&lt;br /&gt;
&lt;FONT size=5&gt;&lt;SPAN style=&quot;FONT-SIZE: 11pt&quot;&gt;&lt;SPAN style=&quot;FONT-SIZE: 10pt&quot;&gt;픽스드포인트는 sicp 에도 나오지만 f(x)=x ; f&amp;nbsp; (f (x)) =f(x) =x ;&amp;nbsp;&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;br /&gt;
&lt;SPAN style=&quot;FONT-SIZE: 11pt&quot;&gt;&lt;SPAN style=&quot;FONT-SIZE: 10pt&quot;&gt;이런 식으로 만들어 낼 수 있는 함수의 성질이다&lt;/SPAN&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;br /&gt;
&lt;br /&gt;&lt;SPAN style=&quot;FONT-SIZE: 10pt&quot;&gt;리스프의 가장 본질적인&amp;nbsp;재귀처리는 label 함수로 처리한다, 그 본질은 결국 Y&amp;nbsp;컴비네이터와 같다.&amp;nbsp;&lt;/SPAN&gt;&lt;br /&gt;
&lt;SPAN style=&quot;FONT-SIZE: 10pt&quot;&gt;이 문제는 TAOI에도 나온다.&amp;nbsp; TAOI의 맨 마지막 페이지에 나온다. &lt;/SPAN&gt;&lt;br /&gt;
&lt;br /&gt;좋은 예제를 찾고 있었으나 최근에 발견한&amp;nbsp;설명중 가장 좋은 예는 J.Franco라는 UC 교수님의 글이다.&amp;nbsp;&lt;br /&gt;
정말 잘 쓴 예라고 생각한다.&amp;nbsp;&lt;br /&gt;
이 글과 Why of Y&amp;nbsp;라는 Friedman의&amp;nbsp;글 그리고&amp;nbsp;root of lisp을&amp;nbsp;같이 놓고 생각하면&amp;nbsp;윤곽을 잡을 수 있을 것이다.&amp;nbsp;&amp;nbsp;&lt;br /&gt;
자기자신에 스스로를 대입하는 함수는 신기한 것 같지만 별다른 것이 아니다. &lt;br /&gt;
그 설명이 아래에 있다. 몇일 동안 궁금하던 것을 글을 읽고 바로 이해했다. 정말 기뻤다. &lt;br /&gt;
&lt;br /&gt;예전의 root of lisp 의 소개글에서 eval (e, a) 는 식 (e) 와 &amp;nbsp;환경(a)를&amp;nbsp; 놓고 계산하는 것인데 (예전의 리스프에 대한 생각들 - 두번째 이야기에 해당한다. )&lt;br /&gt;
&lt;/P&gt;&lt;/DIV&gt;
&lt;DIV style=&quot;TEXT-ALIGN: left&quot;&gt;&lt;XMP&gt;(eval. '((label firstatom (lambda (x) 
(cond ((atom x) x)    
('t (firstatom (car x)))))) 
y) 
'((y ((a b) (c d))))) 

==&gt;
 
(eval. '((lambda (x) 
(cond ((atom x) x) 
('t (firstatom (car x))))) 
y) 
'((firstatom 
(label firstatom (lambda (x) 
(cond ((atom x) x) 
('t (firstatom (car x))))))) 
(y ((a b) (c d))))) 
&lt;/XMP&gt;
&lt;P&gt;&lt;br /&gt;
여기서 중요한 것은 firstatom 이라는 람다식이 그대로 환경에 등록되어 결국은 firstatom 내에서 일종의 텍스트치환이 일어나는 것처럼 동작한다.&amp;nbsp; 초기의 리스프부터&amp;nbsp; recursion은 이런 식으로 해결되었다. 나중에는 set!을&amp;nbsp;써서 환경을&amp;nbsp;직접 고쳤다. 결국 변수문제는 환경문제다.&amp;nbsp; 리스프와 스킴의 변수 문제는 깊은 통찰을 제공한다.&amp;nbsp;&lt;br /&gt;
&lt;br /&gt;&amp;nbsp;&lt;br /&gt;
&lt;br /&gt;스킴에서는 letrec 이라는 것으로 해결할 수 있는데&amp;nbsp; letrec이 별다른 것이 아니다. Richard P. Gabriel 의 why of y 에 보면 &lt;br /&gt;
&lt;br /&gt;(define fact&lt;br /&gt;
&amp;nbsp;(lambda (n)&lt;br /&gt;
&amp;nbsp; (if (&amp;lt; n 2) 1 (* n (fact (- n 1))))))&lt;br /&gt;
&lt;br /&gt;은&amp;nbsp; 다음과 같이 만들 수도 있는데 &lt;br /&gt;
(letrec&lt;br /&gt;
&amp;nbsp;((f (lambda (n)&lt;br /&gt;
&amp;nbsp;&amp;nbsp; (if (&amp;lt; n 2) 1 (* n (f (- n 1)))))))&lt;br /&gt;
(f 10))&lt;br /&gt;
&lt;br /&gt;결국 let 과&amp;nbsp; set! 으로 구현하는 경우가 많다. &lt;br /&gt;
&lt;br /&gt;(letrec ((f (lambda ...))) ...)&lt;br /&gt;
&lt;br /&gt;은&amp;nbsp; 다음과 등가이다. &lt;br /&gt;
&lt;br /&gt;(let ((f &amp;lt;undefined&amp;gt;)) (set! f (lambda ...)) ...)&lt;br /&gt;
&lt;br /&gt;define은 인터프리터의 구현에서 set! 를 사용하고 letrec도 마찬가지다. &lt;br /&gt;
그러나 label 과 letrec을 사용하지 않고 recursion을 구현할 수도 있는데 그것은 Y 컴비네이터를 사용하는 방법이다.&amp;nbsp; Y는 recursion과 fixed point 의 본질이다.&amp;nbsp; &lt;br /&gt;
&lt;br /&gt;따지고 보면 앞의 label은 같은 일을 하는 것으로 볼 수 있다.&amp;nbsp; &lt;br /&gt;
머리가 나쁜&amp;nbsp; 이유로 몇번을 보고서야 이해 비슷한 것을 얻을 수 있었다. &lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;/P&gt;&lt;/DIV&gt;&lt;/DIV&gt;&lt;/CENTER&gt;&lt;/DIV&gt;
&lt;DIV style=&quot;TEXT-ALIGN: left&quot;&gt;
&lt;CENTER&gt;
&lt;DIV&gt;
&lt;DIV style=&quot;TEXT-ALIGN: left&quot;&gt;
&lt;DIV style=&quot;TEXT-ALIGN: justify&quot;&gt;
&lt;CENTER&gt;
&lt;H2&gt;&amp;nbsp;&lt;/H2&gt;
&lt;P&gt;&amp;nbsp;&lt;/P&gt;
&lt;H2&gt;The Y Combinator&lt;/H2&gt;&lt;/CENTER&gt;&lt;/DIV&gt;
&lt;P&gt;In this file we derive the Y combinator, one of the fundamental results of recursive procedure theory. You already know that in some cases it is not necessary to give a procedure a name. For example, 
&lt;P&gt;&lt;PRE&gt;  ((lambda (x) (+ x 1)) 6)
&lt;/PRE&gt;
&lt;P&gt;adds 1 to 6 without naming the procedure that does it. But, what about a recursive procedure? For example, 
&lt;P&gt;&lt;PRE&gt;  (define fact
    (lambda (n)
      (if (zero? n)
          1
          (* n (fact (- n 1))))))
&lt;/PRE&gt;
&lt;P&gt;which computes the factorial of a number n, seems to need the name &quot;fact&quot; so that in the last line of the procedure it can recurse on itself. But, we will see this is not necessary and, in the process, will develop a lot of intuition about using Scheme. We proceed step by step, changing &quot;fact&quot; slightly on each step. &lt;br /&gt;

&lt;P&gt;&lt;B&gt;------------------------------------------------&lt;/B&gt; 
&lt;P&gt;영어판 위키백과에 나오는 Y combinator 에는&amp;nbsp; 다음과 같은 내용이 있다.&amp;nbsp;&lt;br /&gt;
&lt;br /&gt;
&lt;P&gt;Consider the factorial function (under &lt;A title=&quot;Church encoding&quot; href=&quot;http://en.wikipedia.org/wiki/Church_encoding&quot;&gt;Church encoding&lt;/A&gt;). The usual recursive mathematical equation is&lt;/P&gt;
&lt;DL&gt;
&lt;DD&gt;&lt;B&gt;fact&lt;/B&gt;(&lt;I&gt;n&lt;/I&gt;) = if &lt;I&gt;n&lt;/I&gt;=0 then 1 else &lt;I&gt;n&lt;/I&gt; * &lt;B&gt;fact&lt;/B&gt;(&lt;I&gt;n&lt;/I&gt;-1) &lt;/DD&gt;&lt;/DL&gt;
&lt;P&gt;We can express a &quot;single step&quot; of this recursion in lambda calculus as&lt;/P&gt;
&lt;DL&gt;
&lt;DD&gt;&lt;B&gt;F&lt;/B&gt; = λf. λx. (ISZERO x) 1 (MULT x (f (PRED x))), &lt;/DD&gt;&lt;/DL&gt;
&lt;P&gt;where &quot;f&quot; is a place-holder argument for the factorial function to be passed to itself. The function &lt;B&gt;F&lt;/B&gt; performs a single step in the evaluation of the recursive formula. Applying the &lt;B&gt;fix&lt;/B&gt; operator gives&lt;/P&gt;
&lt;DL&gt;
&lt;DD&gt;&lt;B&gt;fix&lt;/B&gt;(&lt;B&gt;F&lt;/B&gt;)(n) = &lt;B&gt;F&lt;/B&gt;(&lt;B&gt;fix&lt;/B&gt;(&lt;B&gt;F&lt;/B&gt;))(n) 
&lt;DD&gt;&lt;B&gt;fix&lt;/B&gt;(&lt;B&gt;F&lt;/B&gt;)(n) = λx. (ISZERO x) 1 (MULT x (&lt;B&gt;fix&lt;/B&gt;(&lt;B&gt;F&lt;/B&gt;) (PRED x)))(n) 
&lt;DD&gt;&lt;B&gt;fix&lt;/B&gt;(&lt;B&gt;F&lt;/B&gt;)(n) = (ISZERO n) 1 (MULT n (&lt;B&gt;fix&lt;/B&gt;(&lt;B&gt;F&lt;/B&gt;) (PRED n))) &lt;/DD&gt;&lt;/DL&gt;
&lt;P&gt;We can abbreviate &lt;B&gt;fix&lt;/B&gt;(&lt;B&gt;F&lt;/B&gt;) as &lt;B&gt;fact&lt;/B&gt;, and we have&lt;/P&gt;
&lt;DL&gt;
&lt;DD&gt;&lt;B&gt;fact&lt;/B&gt;(n) = (ISZERO n) 1 (MULT n (&lt;B&gt;fact&lt;/B&gt;(PRED n))) &lt;/DD&gt;&lt;/DL&gt;
&lt;P&gt;So we see that a fixed-point operator really does turn our non-recursive &quot;factorial step&quot; function into a recursive function satisfying the intended equation.&lt;/P&gt;
&lt;P&gt;&lt;STRONG&gt;-------------------------------------------------&lt;/STRONG&gt; 
&lt;P&gt;&lt;B&gt;Step 1&lt;/B&gt;. The first idea is simply to pass &quot;fact&quot; in as an argument in much the same way that we did for 
&lt;P&gt;&lt;PRE&gt;  (define op-maker
    (lambda (op)
      (lambda (x y)
        (op x y))))
&lt;/PRE&gt;
&lt;P&gt;The first lambda passes the name of the operation and the second lambda is the nameless operation. Let's try this with &quot;fact&quot;. The first attempt is 
&lt;P&gt;&lt;PRE&gt;  (define fact-maker
    (lambda (procedure)
      (lambda (n)
        (if (zero? n)
            1
            (* n (procedure (- n 1)))))))
&lt;/PRE&gt;
&lt;P&gt;The idea will be to pass &quot;fact-maker&quot; in through &quot;procedure&quot;. Thus, what we would like to do is invoke (fact-maker fact-maker) to produce our nameless (well, almost nameless) factorial procedure. This would allow us to write, for example 
&lt;P&gt;&lt;PRE&gt;  &amp;gt;((fact-maker fact-maker) 5)
  120
&lt;/PRE&gt;
&lt;P&gt;But, this doesn't work because &quot;fact-maker&quot; is a procedure which takes as input one argument that is a procedure but &quot;procedure&quot;, which is supposed to be identical to &quot;fact&quot;, requires a numeric argument. The solution is the following: 
&lt;P&gt;&lt;PRE&gt;  (define fact-maker
    (lambda (procedure)
      (lambda (n)
         (if (zero? n)
             1
             (* n ((procedure procedure) (- n 1)))))))
&lt;/PRE&gt;
&lt;P&gt;Try this, for example, with &lt;PRE&gt; &amp;gt;((fact-maker fact-maker) 5)&lt;/PRE&gt;
&lt;P&gt;Well, we got the name out of the body of the procedure but we still have to pass the procedure in and so far we have been using a name to do that. So let's try to get the whole dependence on a name out. 
&lt;P&gt;&lt;B&gt;Step 2&lt;/B&gt;. Recall we demand that &quot;fact&quot; be identical to (procedure procedure) which in turn must be identical to (fact-maker fact-maker) (recall the example ((fact-maker fact-maker) 5) which gives the same result as (fact 5)). Thus, we can write &quot;fact-maker&quot; in the following way, making use of the result of step 1. 
&lt;P&gt;&lt;PRE&gt;  (define fact
    ((lambda (procedure)
       (lambda (n)
         (if (zero? n)
             1
             (* n ((procedure procedure) (- n 1))))))
     (lambda (procedure)
       (lambda (n)
         (if (zero? n)
             1
             (* n ((procedure procedure) (- n 1))))))))
&lt;/PRE&gt;
&lt;P&gt;Try this with &amp;gt;(fact 5) 
&lt;P&gt;Consider the following: 
&lt;P&gt;&lt;PRE&gt;  (((lambda (procedure)
      (lambda (n)
        (if (zero? n)
            1
            (* n ((procedure procedure) (- n 1))))))
    (lambda (procedure)
      (lambda (n)
        (if (zero? n)
            1
            (* n ((procedure procedure) (- n 1)))))))
   5)
&lt;/PRE&gt;
&lt;P&gt;This produces the factorial of 5 because the procedure which is invoked (the huge mess) is exactly the definition of &quot;fact.&quot; But, lo and behold, there is no name for this procedure anywhere! 
&lt;P&gt;In what follows, we try to generalize this to all procedures and wind up with the dreaded applicative-order Y-combinator. 
&lt;P&gt;&lt;B&gt;Step 3&lt;/B&gt;. First, we need to separate out the part that pertains to computing the factorial. The goal is to write this part in one place and when code for other problems is substituted for the factorial code, the result will be a new recursive procedure. This step is a little tricky because we insist on using, with no significant changes, code that was designed assuming a procedure name. The section of factorial code we currently have, from step 2, is 
&lt;P&gt;&lt;PRE&gt;  (define F
    (lambda (n)
      (if (zero? n)
          1
          (* n ((procedure procedure) (- n 1))))))
&lt;/PRE&gt;
&lt;P&gt;This is different from what we want because it contains a (procedure procedure) where we would like to see a plain old procedure. So, we use a trick to get it out. In general, isn't 
&lt;P&gt;&lt;PRE&gt;  (f arg)
&lt;/PRE&gt;
&lt;P&gt;identical to 
&lt;P&gt;&lt;PRE&gt;  ((lambda (x) (f x)) arg) ?
&lt;/PRE&gt;
&lt;P&gt;The second statement is a little strange, though, because it makes you pass &quot;arg&quot; into a procedure so that the procedure which would be applied to it anyway is applied. Why do we want to do such a thing? Watch! This means that 
&lt;P&gt;&lt;PRE&gt;  ((procedure procedure) (- n 1))
&lt;/PRE&gt;
&lt;P&gt;is the same as 
&lt;P&gt;&lt;PRE&gt;  ((lambda (arg) ((procedure procedure) arg)) (- n 1))
&lt;/PRE&gt;
&lt;P&gt;and we substitute this into our current version of F to get 
&lt;P&gt;&lt;PRE&gt;  (define F
    (lambda (n)
      (if (zero? n)
          1
          (* n ((lambda (arg) ((procedure procedure) arg)) (- n 1))))))
&lt;/PRE&gt;
&lt;P&gt;How has this helped? Well, the (lambda (arg)...) is ONE procedure and procedures can be passed as arguments so F can be defined as 
&lt;P&gt;&lt;PRE&gt;  (define F
    ((lambda (func-arg)
       (lambda (n)
         (if (zero? n)
             1
             (* n (func-arg (- n 1))))))
     (lambda (arg) ((procedure procedure) arg))))
&lt;/PRE&gt;
&lt;P&gt;Yes, it's the same F but the old definition looked like this: 
&lt;P&gt;&lt;PRE&gt;  (define F (lambda (n) ... &amp;lt; procedure &amp;gt;))
&lt;/PRE&gt;
&lt;P&gt;and the new definition looks like this: 
&lt;P&gt;&lt;PRE&gt;  (define F ((lambda (func-arg) (lambda (n) ...)) &amp;lt; procedure &amp;gt;))
&lt;/PRE&gt;
&lt;P&gt;where &amp;lt; procedure &amp;gt; is the (lambda (arg) ((procedure... ) ...) ...) expression 
&lt;P&gt;&lt;B&gt;Step 4&lt;/B&gt;. - Now we are ready to take the result of step 3 and apply it to the result of step 2. Writing out the whole thing, we get: 
&lt;P&gt;&lt;PRE&gt;  (define fact
    ((lambda (procedure)
       ((lambda (func-arg)
          (lambda (n)
            (if (zero? n)
                1
                (* n (func-arg (- n 1))))))
        (lambda (arg) ((procedure procedure) arg))))
     (lambda (procedure)
       ((lambda (func-arg)
          (lambda (n)
            (if (zero? n)
                1
                (* n (func-arg (- n 1))))))
        (lambda (arg) ((procedure procedure) arg))))))
&lt;/PRE&gt;
&lt;P&gt;You will probably want to study this carefully. Notice the double left parens in front of ((lambda (func-arg)... This is because we are writing 
&lt;P&gt;&lt;PRE&gt;   ...
   ((lambda (func-arg) &amp;lt; body-using-func-arg &amp;gt;) (lambda (arg) ...))
&lt;/PRE&gt;
&lt;P&gt;which has the same form as 
&lt;P&gt;&lt;PRE&gt;  ((lambda (arg) ((procedure procedure) arg)) (- n 1))
&lt;/PRE&gt;
&lt;P&gt;but is different in that a procedure is passed as an &quot;arg&quot; instead of an integer. 
&lt;P&gt;The two expressions beginning with (lambda (func-arg) ...) are exactly the pieces of code that correspond to the factorial code and they are in exactly the right form. So we can get them out of the definition of fact in the following way: 
&lt;P&gt;&lt;PRE&gt;  (define F*
    (lambda (func-arg)
      (lambda (n)
        (if (zero? n)
            1
            (* n (func-arg (- n 1)))))))
&lt;/PRE&gt;
&lt;P&gt;&lt;PRE&gt;  (define fact
    ((lambda (procedure)
       (F* (lambda (arg) ((procedure procedure) arg))))
     (lambda (procedure)
       (F* (lambda (arg) ((procedure procedure) arg))))))
&lt;/PRE&gt;
&lt;P&gt;This is significant because we can now use any procedure in place of F* to change functionality to whatever we want. The only problem is that, as written, we still need to name F*. This is easily remedied in the next step. &lt;br /&gt;
&lt;br /&gt;-----------------------------------------------------------------------------&lt;br /&gt;
영어판 위키백과에 나오는 Y combinator 의 예제는 이번의 예제가&amp;nbsp; application - order라는 것을 설명하고 있다. &lt;br /&gt;

&lt;P&gt;A version of the &lt;B&gt;Y&lt;/B&gt; combinator that can be used in call-by-value (&lt;A class=mw-redirect title=&quot;Applicative-order evaluation&quot; href=&quot;http://en.wikipedia.org/wiki/Applicative-order_evaluation&quot;&gt;applicative-order&lt;/A&gt;) evaluation is given by &lt;A class=mw-redirect title=&quot;Eta expansion&quot; href=&quot;http://en.wikipedia.org/wiki/Eta_expansion&quot;&gt;η-expansion&lt;/A&gt; of part of the ordinary &lt;B&gt;Y&lt;/B&gt; combinator:&lt;/P&gt;
&lt;DL&gt;
&lt;DD&gt;&lt;B&gt;Z&lt;/B&gt; = λf. (λx. f (λy. x x y)) (λx. f (λy. x x y)) &lt;/DD&gt;&lt;/DL&gt;
&lt;P&gt;..&lt;/P&gt;
&lt;P&gt;-----------------------------------------------------------------------------&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;

&lt;P&gt;&lt;B&gt;Step 5&lt;/B&gt;. Jackpot! Now we write the dreaded applicative-order Y-combinator: 
&lt;P&gt;&lt;PRE&gt;  (define Y
    (lambda (X)
      ((lambda (procedure)
         (X (lambda (arg) ((procedure procedure) arg))))
       (lambda (procedure)
         (X (lambda (arg) ((procedure procedure) arg)))))))
&lt;/PRE&gt;
&lt;P&gt;Notice that the procedure which does our computation is X (we stopped using F* to emphasize this code can be applied to any procedure) and that is passed in as an argument. 
&lt;P&gt;&lt;B&gt;Step 6&lt;/B&gt;. We can write &quot;fact&quot; in terms of the Y-combinator as follows: 
&lt;P&gt;&lt;PRE&gt;  (define fact (Y F*))
&lt;/PRE&gt;
&lt;P&gt;Try &amp;gt;(fact 5) to check the result. For that matter, try &amp;gt;((Y F*) 5). But Y is general and F* is specific to factorial but with no name! If we wrote the whole thing out it would be 
&lt;P&gt;&lt;PRE&gt;  (((lambda (X)
      ((lambda (procedure)
         (X (lambda (arg) ((procedure procedure) arg))))
       (lambda (procedure)
         (X (lambda (arg) ((procedure procedure) arg))))))
    (lambda (func-arg)
      (lambda (n)
        (if (zero? n)
            1
            (* n (func-arg (- n 1)))))))
   5)
&lt;/PRE&gt;
&lt;P&gt;Look Ma! No name! Just to show the generality of all this let's use the Y combinator to define another procedure. Say findmax - finding the largest integer in a list. 
&lt;P&gt;&lt;PRE&gt;  (define findmax
    (lambda (l)
      (if (null? l)
          'no-list
          (if (null? (cdr l))
              (car l)
              (max (car l) (findmax (cdr l)))))))
&lt;/PRE&gt;
&lt;P&gt;First, create the analog of F* for fact, call it M for max. 
&lt;P&gt;&lt;PRE&gt;  (define M
    (lambda (func-arg)
      (lambda (l)
        (if (null? l)
            'no-list
            (if (null? (cdr l))
                (car l)
                (max (car l) (func-arg (cdr l))))))))
&lt;/PRE&gt;
&lt;P&gt;Now try ((Y M) '(4 5 6 3 4 8 6 2)) to see if it works. If you want to build it out it looks like this: 
&lt;P&gt;&lt;PRE&gt;  (((lambda (X)
      ((lambda (procedure)
         (X (lambda (arg) ((procedure procedure) arg))))
       (lambda (procedure)
         (X (lambda (arg) ((procedure procedure) arg))))))
    (lambda (func-arg)
      (lambda (l)
        (if (null? l)
            'no-list
            (if (null? (cdr l))
                (car l)
                (max (car l) (func-arg (cdr l))))))))
   '(4 5 6 3 4 8 6 2))
&lt;/PRE&gt;
&lt;P&gt;As an assignment for the interested student, write findamx without using the procedure name &quot;max&quot;. Just how many of the remaining names in findmax do you think can be disposed of? Talk about a nameless society... &lt;/P&gt;&lt;br /&gt;
조금 더 유명했던 글로&amp;nbsp; 리처드 가브리엘(&lt;FONT face=Arial size=2&gt;Richard P. Gabriel&lt;/FONT&gt;)의 Why of Y 가 있다. 이글 역시 대단한 개념글로&amp;nbsp; 유명한 연구자가 쓴 글이다.&amp;nbsp;&amp;nbsp;비슷하게 유명한 Daniel Friedman 이 쓴 (Y Y) works! 라는 글도 있으나&amp;nbsp; Little Lisper 라는 책이&amp;nbsp; 정이 붙지 않는 것과 비슷하게 적응하기 힘들었다. &lt;br /&gt;
&lt;br /&gt;글의 형태를 간단하게 카피앤페이스트 하기 위해 ddj에 있는 것을 옮겼으나 웹에서는 pdf 문서를 구할 수 있다. &lt;br /&gt;
주석만 달겠다. 많은 부분이 겹치기 때문이다.&amp;nbsp; &lt;br /&gt;
&lt;br /&gt;&lt;FONT size=5&gt;The Why of Y&lt;/FONT&gt; 
&lt;P&gt;&lt;FONT size=4&gt;One way to derive Y.&lt;/FONT&gt;&lt;br /&gt;

&lt;P&gt;&lt;FONT face=geneva,arial,helvetica size=2&gt;By Richard P. Gabriel,&amp;nbsp; &lt;!-- remove http:// substring (if present) from the url --&gt;&lt;A href=&quot;http://www.ddj.com/;jsessionid=WNHF4QDX5RSIAQSNDLOSKHSCJUNN2JVN&quot; target=_blank&gt;Dr. Dobb's Journal &lt;/A&gt;&lt;br /&gt;
4Ô 22, 2007 &lt;br /&gt;
URL:&lt;A href=&quot;http://www.ddj.com/architect/199200394&quot;&gt;http://www.ddj.com/architect/199200394 &lt;/A&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/FONT&gt;
&lt;P&gt;&lt;!-- ARTICLE BODY --&gt;&lt;I&gt;Richard P. Gabriel is a Distinguished Engineer at IBM Research, looking into the architecture, design, and implementation of extraordinarily large, self-sustaining systems. He can be contacted at &lt;A href=&quot;http://www.dreamsongs.com/Bio.html&quot;&gt;www.dreamsongs.com&lt;/A&gt;.&lt;/I&gt; 
&lt;HR&gt;

&lt;P&gt;
&lt;P&gt;Did you ever wonder how Y works and how anyone could ever have thought of it? In this article, I explain not only how it works, but how someone could have invented it in the first place. I'll use &lt;A href=&quot;http://www.schemers.org/&quot;&gt;Scheme&lt;/A&gt; notation because when functions passed as arguments are applied, &lt;B&gt;Y&lt;/B&gt; is easier to understand. 
&lt;P&gt;&lt;B&gt;Y&lt;/B&gt;'s goal is to provide a mechanism to write self-referential progra ms without any special built-in means. Scheme has several mechanisms for writing such programs, including global function definitions and &lt;B&gt;letrec&lt;/B&gt;. One way you can write the factorial function in Scheme is: 
&lt;P&gt;&lt;PRE&gt;(define fact (lambda (n) (if (&amp;lt; n 2) 1 (* n (fact (- n 1))))))
&lt;/PRE&gt;
&lt;P&gt;This function works because a global variable, fact, has its value set to the value of the lambda expression. When the variable fact in the body of the function is evaluated to determine which function to invoke, the value is found in the global variable. Using a global variable as a function name can be rather unpleasant because it relies on a global, and thus vulnerable, resource -- that is, the global variable space. The Scheme self-reference form &lt;B&gt;letrec&lt;/B&gt; usually is implemented using a side effect; it is easier to reason about programming languages and programs that have no side effects. Therefore, it is of theoretical interest to establish the ability to write recursive functions without using side effects. A program that uses &lt;B&gt;letrec&lt;/B&gt; is: &lt;/P&gt;&lt;PRE&gt;(letrec ((f (lambda (n) (if (&amp;lt; n 2) 1 (* n (f (- n1))))))) (f 10))
&lt;/PRE&gt;
&lt;P&gt;This program computes &lt;B&gt;10!&lt;/B&gt;. The reference inside the lambda express &lt;B&gt;ion&lt;/B&gt; is to the binding of &lt;B&gt;f&lt;/B&gt;, as established by the &lt;B&gt;letrec&lt;/B&gt;. You can implement &lt;B&gt;letrec&lt;/B&gt; using &lt;B&gt;let&lt;/B&gt; and &lt;B&gt;set!&lt;/B&gt;: &lt;/P&gt;&lt;PRE&gt;(letrec ((f (lambda ...))) ...)
&lt;/PRE&gt;
&lt;P&gt;which is equivalent to: &lt;/P&gt;&lt;PRE&gt;(let ((f &lt;UNDEFINED&gt;)) (set! f (lambda ...)) ...)
&lt;/PRE&gt;
&lt;P&gt;All references to &lt;B&gt;f&lt;/B&gt; in the lambda expression are to the value of the lambda expression. &lt;B&gt;Y&lt;/B&gt; takes a function describing another recursive or self-referential function and returns another function that implements the recursive function. &lt;B&gt;Y&lt;/B&gt; is used to compute &lt;B&gt;10!&lt;/B&gt; with: &lt;/P&gt;&lt;PRE&gt;(let ((f (y (lambda (n) (lambda (n) (if (&amp;lt; n 2) 1 (* n (h (- n 1))))) )))))) (f 10))
&lt;/PRE&gt;
&lt;P&gt;The function passed as an argument to &lt;B&gt;Y&lt;/B&gt; takes a function as an argument and returns a function that looks like the factorial function we want to define. That is, the function passed to &lt;B&gt;Y&lt;/B&gt; is &lt;B&gt;(lambda (h) ...)&lt;/B&gt;. The body of this function looks like the factorial function, except that where we would expect a recursive call to the factorial function, &lt;B&gt;h&lt;/B&gt; is called instead. &lt;B&gt;Y&lt;/B&gt; arranges for an appropriate value to be supplied as the value of &lt;B&gt;h&lt;/B&gt;. 
&lt;P&gt;People call &lt;B&gt;Y&lt;/B&gt; the &quot;applicative-order fixed-point operator for functionals.&quot; Let's take a closer look at what this means in the factorial example. 
&lt;P&gt;
&lt;P&gt;Suppose &lt;B&gt;M&lt;/B&gt; is the true mathematical factorial function, possibly in Plato's heaven. Let &lt;B&gt;F&lt;/B&gt; denote the function: 
&lt;P&gt;&lt;PRE&gt;F = (lambda (h) (lambda (n) (if (&amp;lt; n 2) 1 (* n (h (- n 1))))))
&lt;/PRE&gt;
&lt;P&gt;Then: &lt;/P&gt;&lt;PRE&gt;((F M) n) = (M n).
&lt;/PRE&gt;
&lt;P&gt;That is, &lt;B&gt;M&lt;/B&gt; is a fixed point of &lt;B&gt;F&lt;/B&gt;: &lt;B&gt;F&lt;/B&gt; maps (in some sense) &lt;B&gt;M&lt;/B&gt; onto &lt;B&gt;M&lt;/B&gt;. &lt;B&gt;Y&lt;/B&gt; satisfies the property: &lt;/P&gt;&lt;PRE&gt;((F (Y F)) X) = ((Y F) X)
&lt;/PRE&gt;
&lt;P&gt;This property of &lt;B&gt;Y&lt;/B&gt; is very important. Another important property is that the least defined fixed point for functionals is unique; therefore, &lt;B&gt;(Y F)&lt;/B&gt; and &lt;B&gt;M&lt;/B&gt; are in some sense the same. Applicative-order &lt;B&gt;Y&lt;/B&gt; is not the same as classical &lt;B&gt;Y&lt;/B&gt;, which is a combinator. Some texts refer to &lt;B&gt;Y&lt;/B&gt; as &lt;B&gt;Z&lt;/B&gt;. To derive &lt;B&gt;Y&lt;/B&gt;, I will start with a recursive function example, factorial. In the derivation I will use three techniques: &lt;/P&gt;
&lt;UL&gt;
&lt;LI&gt;The first one passes an additional argument to avoid using any self-reference primitives from Scheme. 
&lt;LI&gt;The second technique converts multiple-parameter functions to nested single-parameter functions to separate manipulations of the self-reference and ordinary parameters. 
&lt;LI&gt;The third technique introduces functions through abstraction. &lt;/LI&gt;&lt;/UL&gt;
&lt;P&gt;All code examples will use the variables &lt;B&gt;n&lt;/B&gt; and &lt;B&gt;m&lt;/B&gt; to refer to integers, the variable &lt;B&gt;x&lt;/B&gt; to refer to an unknown but undistinguished argument, and the variables &lt;B&gt;f, g, h, q&lt;/B&gt;, and &lt;B&gt;r&lt;/B&gt; to refer to functions. The basic form of the factorial function is: &lt;/P&gt;&lt;PRE&gt;(lambda (n) (if (&amp;lt; n 2) 1 (* n (h (- n1)))))
&lt;/PRE&gt;
&lt;P&gt;The &lt;B&gt;h&lt;/B&gt; variable should refer to the function we wish to invoke when a recursive call is made, which is the factorial function itself. Since we have no way to make &lt;B&gt;h&lt;/B&gt; refer directly to the correct function, let's pass it in as an argument: &lt;/P&gt;&lt;PRE&gt;(lambda (h n) (if (&amp;lt; n 2) 1 (* n (h h (- n 1)))))
&lt;/PRE&gt;
&lt;P&gt;--------------------------------------------------------------------------&lt;br /&gt;
&lt;br /&gt;앞의 첫번째 예제가 h,n 을&amp;nbsp; 개별적인 lambda 를 사용한 것과 달리 h 는 함수로 n은 &lt;br /&gt;
팩토리얼의 인자로 사용했다. &lt;br /&gt;
&lt;br /&gt;그 결과 (h h (- n 1)) 은&amp;nbsp; (lambda (h n) 에서 인자로 받은 h 에 h와 n-1 을 다시 적용하는 &lt;br /&gt;
(* n (h h (- n 1))) 형태가 된다. (h h (- n 1))&amp;nbsp; 은 새로운 recursion 을 일으킨다. &lt;br /&gt;
&lt;br /&gt;-------------------------------------------------------------------------&lt;br /&gt;
&lt;br /&gt;In the recursive call to &lt;B&gt;h&lt;/B&gt;, the first argument will also be &lt;B&gt;h&lt;/B&gt; because we want to pass on the correct function to use in the recursive situation for later invocations of the function. Therefore, to compute &lt;B&gt;10!&lt;/B&gt; we would write: &lt;/P&gt;&lt;PRE&gt;(let ((g (lambda (h n) (if (&amp;lt; n 2) 1 (* n (h h (- n 1))))))) (g g 10) )
&lt;/PRE&gt;
&lt;P&gt;&lt;br /&gt;
-------------------------------------------------------------------------------------&lt;br /&gt;
앞의 식을 g 로 만들고&amp;nbsp; (g g 10) 을 대입한다. &lt;br /&gt;
실제로 이 코드를 돌려보면 3628800 이&amp;nbsp; 나온다. &lt;br /&gt;
-------------------------------------------------------------------------------------&lt;br /&gt;
&lt;br /&gt;During the evaluation of the body of &lt;B&gt;g&lt;/B&gt;, &lt;B&gt;h&lt;/B&gt;'s value is the same as the value of g established by let; that is, during execution of &lt;B&gt;g, h&lt;/B&gt; refers to the executing function. When the function call &lt;B&gt;(h h (- n 1))&lt;/B&gt; happens, the same value is passed along as an argument to &lt;B&gt;h&lt;/B&gt;; &lt;B&gt;h&lt;/B&gt; passes itself to itself. We want to split the management of the function's self-reference fr om the management of other arguments. In this particular case, we want to separate the management of h from that of &lt;B&gt;n&lt;/B&gt;. A technique called &quot;currying&quot; is the standard way to handle this separation. Before we curry this example, let's look at another example of currying. Here is a program that also computes &lt;B&gt;10!&lt;/B&gt;, but in a slightly more clever way: &lt;/P&gt;&lt;PRE&gt;(letrec ((f (lambda (n m) (if (&amp;lt; n 2) m (f (- n 1) (* m n)))))) (f 10 1))
&lt;/PRE&gt;
&lt;P&gt;The trick is to use an accumulator, &lt;B&gt;m&lt;/B&gt;, to compute the result. Let's curry the definition of &lt;B&gt;f&lt;/B&gt;: &lt;/P&gt;&lt;PRE&gt;(letrec ((f (lambda (n) (lambda (m) (if (&amp;lt; n 2) m ((f (- n 1)) (* m n ))))))) ((f 10) 1))
&lt;/PRE&gt;
&lt;P&gt;-------------------------------------------------------&lt;br /&gt;
아래의 몇줄의 문항은 closure 와 currying 을 적용하겠다는 것이다.&lt;br /&gt;
currying은&amp;nbsp; 영어판 위키 백과에도 나온다.&lt;br /&gt;
-----------------------------------------------------&lt;br /&gt;
&lt;br /&gt;The idea of currying is that every function has one argument. Passing multiple arguments is accomplished with nested function application: the first application returns a function that takes the second argument and completes the computation of the value. In the previous piece of code, the recursive call: &lt;/P&gt;&lt;PRE&gt;((f (- n 1)) (* m n))
&lt;/PRE&gt;
&lt;P&gt;has two steps: the proper function to apply is computed and applied to the right argument. We can use this idea to curry the other factorial program: &lt;/P&gt;&lt;PRE&gt;(let ((g (lambda (h) (lambda (n) (if (&amp;lt; n 2) 1 (* n ((h h) (- n 1)))) ))) ((g g) 10))
&lt;/PRE&gt;
&lt;P&gt;&lt;br /&gt;
----------------------------------------------------------------------------------&lt;br /&gt;
let 이 lambda 의 syntactic sugar 라는 말은 sicp 에 여러&amp;nbsp;번 나온다,&lt;br /&gt;
결국 (labmda (g)&amp;nbsp; ( (g g) 10 ) (lambda (h) (....))&lt;br /&gt;
----------------------------------------------------------------------------------&lt;br /&gt;
&lt;br /&gt;In this piece of code, the recursive call also computes and applies the proper function. But that proper function is computed by applying a function to itself. Applying a function to itself is the process by which we get the basic functionality of a self-reference. The self-application &lt;B&gt;(g g)&lt;/B&gt; in the last line of the program calls &lt;B&gt;g&lt;/B&gt; with &lt;B&gt;g&lt;/B&gt; itself as an argument. This returns a closure in which the variable h is bound to the outside &lt;B&gt;g&lt;/B&gt;. This closure takes a number and does the basic factorial comput ation. If the computation needs to perform a recursive call, it invokes the closed-over &lt;B&gt;h&lt;/B&gt; with the closed-over has an argument, but all the &lt;B&gt;h&lt;/B&gt;s are bound to the function &lt;B&gt;g&lt;/B&gt; as defined by the &lt;B&gt;let&lt;/B&gt;. To summarize this technique, suppose we have a self-referential function using &lt;B&gt;letrec&lt;/B&gt; as in the following code skeleton: &lt;/P&gt;&lt;PRE&gt;(letrec ((f (lambda (x) ... f ...))) ... f ...)
&lt;/PRE&gt;
&lt;P&gt;This skeleton can be turned into a self-referential function that uses let where &lt;B&gt;r&lt;/B&gt; is a fresh identifier: &lt;/P&gt;&lt;PRE&gt;(let ((f (lambda (r) (lambda (x) ... (r r) ...)))) ... (f f) &lt;/PRE&gt;
&lt;P&gt;&lt;br /&gt;
----------------------------------------------------------------------------------------&lt;br /&gt;
위의 letrec과 let 의 차이를 설명하는 결정적인 커멘트는 매우 중요한&amp;nbsp;것인데 썰렁하게 설명하고 있다,&lt;br /&gt;
앞의 label 함수 부분을 다시 한번 살펴 보라!&lt;br /&gt;
----------------------------------------------------------------------------------------&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
For the next step, let's examine how to separate further the management of &lt;B&gt;h&lt;/B&gt; in our factorial function from the management of &lt;B&gt;n&lt;/B&gt;. Recall that the factorial program looks like: 
&lt;P&gt;&lt;br /&gt;
(let ((g (lambda (h) &lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp; (lambda (n)&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; (if (&amp;lt; n 2) 1 (* n ((h h) (- n 1))))))))&lt;br /&gt;
&amp;nbsp; ((g g) 10))&lt;/P&gt;&lt;/DIV&gt;&lt;/DIV&gt;&lt;/CENTER&gt;&lt;/DIV&gt;
&lt;DIV style=&quot;MARGIN-LEFT: 4em; TEXT-ALIGN: left&quot;&gt;
&lt;CENTER&gt;
&lt;DIV&gt;
&lt;DIV style=&quot;TEXT-ALIGN: left&quot;&gt;&lt;FONT face=&quot;Courier New&quot;&gt;&lt;/FONT&gt;&amp;nbsp;&lt;/DIV&gt;&lt;/DIV&gt;&lt;/CENTER&gt;&lt;/DIV&gt;
&lt;DIV style=&quot;TEXT-ALIGN: left&quot;&gt;
&lt;CENTER&gt;
&lt;DIV&gt;
&lt;DIV style=&quot;TEXT-ALIGN: left&quot;&gt;
&lt;P&gt;Our plan of attack is to abstract the if expression over &lt;B&gt;(h h)&lt;/B&gt; and &lt;B&gt;n&lt;/B&gt;, which will accomplish two things: the resulting function will become independent of its surrounding bindings and the management of the control argument will become separated from the numeric argument. The result of the abstraction is: &lt;/P&gt;&lt;PRE&gt;(let ((g (lambda (h) &lt;/PRE&gt;&lt;PRE&gt;   (lambda (n) &lt;/PRE&gt;&lt;PRE&gt;      (let ((f (lambda (q n) &lt;/PRE&gt;&lt;PRE&gt;         (if (&amp;lt; n 2) 1 (* n (q (- n 1))))))) (f (h h) n)))))) &lt;/PRE&gt;&lt;PRE&gt;((g g) 10))
&lt;/PRE&gt;
&lt;P&gt;We can curry the definition of &lt;B&gt;f&lt;/B&gt;, which also changes its call: &lt;/P&gt;&lt;PRE&gt;(let ((g (lambda (h) &lt;/PRE&gt;&lt;PRE&gt;       (lambda (n) &lt;/PRE&gt;&lt;PRE&gt;          (let ((f (lambda (q) &lt;/PRE&gt;&lt;PRE&gt;            (lambda (n) &lt;/PRE&gt;&lt;PRE&gt;               (if (&amp;lt; n 2) 1 (* n (q (- n 1)))))))) ((f (h h)) n)))))) &lt;/PRE&gt;&lt;PRE&gt;((g g) 10))
&lt;/PRE&gt;
&lt;P&gt;Notice that the definition of the function &lt;B&gt;f&lt;/B&gt; need not be deeply embedded in the function &lt;B&gt;g&lt;/B&gt;. Therefore, we can extract the main part of the function -- the part that computes factorial -- from the rest of the code. &lt;/P&gt;&lt;PRE&gt;(let ((f (lambda (q) (lambda (n) (if (&amp;lt; n 2) 1 (* n (q (- n 1)))))))) &lt;/PRE&gt;&lt;PRE&gt;  (let ((g (lambda (h) (lambda (n) ((f (h h)) n))))) &lt;/PRE&gt;&lt;PRE&gt;     ((g g) 10)))
&lt;/PRE&gt;
&lt;P&gt;The form of &lt;B&gt;f&lt;/B&gt; is once again the parameterized form of factorial, and we can abstract this expression over &lt;B&gt;f&lt;/B&gt;, which produces &lt;B&gt;Y&lt;/B&gt; as follows: &lt;/P&gt;&lt;PRE&gt;(define Y (lambda (f) &lt;/PRE&gt;&lt;PRE&gt;           (let ((g (lambda (h) &lt;/PRE&gt;&lt;PRE&gt;                     (lambda (x) ((f (h h)) x)) ))) &lt;/PRE&gt;&lt;PRE&gt;                      (g g))))
&lt;/PRE&gt;
&lt;P&gt;This is one way to derive &lt;B&gt;Y&lt;/B&gt;. &lt;!-- /ARTICLE BODY --&gt;&lt;/P&gt;
&lt;P&gt;&lt;br /&gt;
------------------------------------------------------&lt;br /&gt;
결론은 둘다 &amp;nbsp;같다. &lt;br /&gt;
그리고 전체 다시 한두번 더 읽어 보기를 권한다. &lt;br /&gt;
머리 속에도 다시 한 번 이 내용을 apply 해서 계산을 일으킬 필요가 있다.&amp;nbsp;&lt;br /&gt;
&lt;br /&gt;두 글의 결론은?&lt;br /&gt;
람다 함수는 치환으로 모든 것을 해결한다는 것이다. &lt;br /&gt;
&lt;br /&gt;이렇게 끝난다.&amp;nbsp;&lt;br /&gt;
조만간 한글로된 정리판을&amp;nbsp;만들 예정이지만&amp;nbsp;&lt;br /&gt;
그때까지는 이 정도로 참는 수 밖에 없겠다. &lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
-------------------------------------------------------&lt;br /&gt;
&lt;br /&gt;추가:)&lt;br /&gt;
&lt;br /&gt;람다를&amp;nbsp; 쓰다보니 형식은 자유롭다. 그중에는 &lt;br /&gt;
&lt;br /&gt;&lt;A href=&quot;http://www.rosettacode.org/wiki/Y_combinator#Scheme&quot;&gt;http://www.rosettacode.org/wiki/Y_combinator#Scheme&lt;/A&gt;&lt;br /&gt;
&lt;br /&gt;&lt;SPAN class=sy0&gt;&amp;gt;&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=kw1&gt;define&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;Y &lt;SPAN class=kw1&gt;f&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=kw1&gt;lambda&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;x&lt;SPAN class=br0&gt;)&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;x x&lt;SPAN class=br0&gt;)&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=kw1&gt;lambda&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;y&lt;SPAN class=br0&gt;)&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=kw1&gt;f&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=kw1&gt;lambda&lt;/SPAN&gt; args &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;apply &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;y y&lt;SPAN class=br0&gt;)&lt;/SPAN&gt; args&lt;SPAN class=br0&gt;)&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt;&lt;br /&gt;
&lt;SPAN class=sy0&gt;&amp;gt;&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=kw1&gt;define&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;fac &lt;SPAN class=kw1&gt;f&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=kw1&gt;lambda&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;n&lt;SPAN class=br0&gt;)&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=kw1&gt;if&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=sy0&gt;=&lt;/SPAN&gt; n &lt;SPAN class=nu0&gt;0&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt; &lt;SPAN class=nu0&gt;1&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=sy0&gt;*&lt;/SPAN&gt; n &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=kw1&gt;f&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=sy0&gt;-&lt;/SPAN&gt; n &lt;SPAN class=nu0&gt;1&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt;&lt;br /&gt;
&lt;SPAN class=sy0&gt;&amp;gt;&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=br0&gt;(&lt;/SPAN&gt;Y fac&lt;SPAN class=br0&gt;)&lt;/SPAN&gt; &lt;SPAN class=nu0&gt;5&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt;&lt;br /&gt;
&lt;SPAN class=nu0&gt;120&lt;/SPAN&gt;&lt;br /&gt;
&lt;SPAN class=sy0&gt;&amp;gt;&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=kw1&gt;define&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;fib &lt;SPAN class=kw1&gt;f&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt; &lt;/P&gt;&lt;PRE class=scheme style=&quot;FONT-FAMILY: monospace&quot;&gt;&lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=kw1&gt;lambda&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;n&lt;SPAN class=br0&gt;)&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=kw1&gt;cond&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=sy0&gt;=&lt;/SPAN&gt; n &lt;SPAN class=nu0&gt;0&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt; &lt;SPAN class=nu0&gt;0&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=sy0&gt;=&lt;/SPAN&gt; n &lt;SPAN class=nu0&gt;1&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt; &lt;SPAN class=nu0&gt;1&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=kw1&gt;else&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=sy0&gt;+&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=kw1&gt;f&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=sy0&gt;-&lt;/SPAN&gt; n &lt;SPAN class=nu0&gt;1&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=kw1&gt;f&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=sy0&gt;-&lt;/SPAN&gt; n &lt;SPAN class=nu0&gt;2&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;br /&gt;
&lt;/SPAN&gt;&lt;/PRE&gt;&lt;PRE class=scheme style=&quot;FONT-FAMILY: monospace&quot;&gt;&lt;br /&gt;
&lt;SPAN class=sy0&gt;&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;br /&gt;&amp;gt;&lt;/SPAN&gt; &lt;SPAN class=br0&gt;(&lt;/SPAN&gt;&lt;SPAN class=br0&gt;(&lt;/SPAN&gt;Y fib&lt;SPAN class=br0&gt;)&lt;/SPAN&gt; &lt;SPAN class=nu0&gt;8&lt;/SPAN&gt;&lt;SPAN class=br0&gt;)&lt;/SPAN&gt;&lt;br /&gt;
&lt;SPAN class=nu0&gt;21&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;/SPAN&gt;&lt;/PRE&gt;
&lt;P&gt;(lambda&amp;nbsp; args (apply ..) ...) 의 형태는 괄호가 없는데 r5rs 9 페이지에 나오는 설명이 있다. &lt;br /&gt;
args 는 임의의 숫자로 정할 수 있다. &lt;br /&gt;
&lt;br /&gt;The procedure takes any number of arguments;&lt;br /&gt;
when the procedure is called, the sequence&lt;br /&gt;
of actual arguments is converted into a newly allocated&lt;br /&gt;
list, and the list is stored in the binding of the&lt;br /&gt;
variable.&lt;br /&gt;
&lt;br /&gt;&lt;/P&gt;&lt;/DIV&gt;&lt;/DIV&gt;&lt;/CENTER&gt;&lt;/DIV&gt;&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;a href=&quot;http://creativecommons.org/licenses/by/4.0/deed.ko&quot; target=&quot;_blank&quot; style=&quot;text-decoration: none&quot;&gt;
	&lt;img id=&quot;ccl-icon-72-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;//i1.daumcdn.net/cfs.tistory/resource/4191/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-fr/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-fr/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/DerivativeWorks&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
	&lt;/a&gt;
&lt;/div&gt;
</description>
<category>lisp</category>
<author>toyfab</author>
<guid>http://toyfab.tistory.com/72</guid>
<comments>http://toyfab.tistory.com/entry/The-Y-Combinator#entry72comment</comments>
<pubDate>Fri, 13 Mar 2009 20:37:20 +0900</pubDate>
</item>
</channel>
</rss>