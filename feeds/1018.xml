<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="http://nicewoong.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="http://nicewoong.github.io/" rel="alternate" type="text/html" /><updated>2018-04-09T10:56:31+00:00</updated><id>http://nicewoong.github.io/</id><title type="html">nicewoong</title><subtitle>welcome to nicewoong blog!</subtitle><entry><title type="html">Ubuntu(우분투) 기본세팅</title><link href="http://nicewoong.github.io/development/2018/03/06/ubuntu-setting/" rel="alternate" type="text/html" title="Ubuntu(우분투) 기본세팅" /><published>2018-03-06T12:00:00+00:00</published><updated>2018-03-06T12:00:00+00:00</updated><id>http://nicewoong.github.io/development/2018/03/06/ubuntu-setting</id><content type="html" xml:base="http://nicewoong.github.io/development/2018/03/06/ubuntu-setting/">&lt;h3 id=&quot;필요한-패키지들&quot;&gt;필요한 패키지들&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    # apt-get install vim
    # apt-get install gcc
    # apt-get install net-tools
    # apt-get install g++
    # apt-get install openssh-client openssh-server
    # apt-get install python
    # apt-get install git
    # apt-get install build-essential
    # apt-get install sudo
    # apt-get install telnet
    # apt-transport-https
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>nicewoong</name></author><category term="development" /><category term="linux" /><category term="c" /><category term="docker" /><category term="ubuntu" /><summary type="html">필요한 패키지들</summary></entry><entry><title type="html">Docker(도커) 컨테이너 커밋, 이미지 푸쉬하기</title><link href="http://nicewoong.github.io/development/2018/03/06/docker-commit-container/" rel="alternate" type="text/html" title="Docker(도커) 컨테이너 커밋, 이미지 푸쉬하기" /><published>2018-03-06T12:00:00+00:00</published><updated>2018-03-06T12:00:00+00:00</updated><id>http://nicewoong.github.io/development/2018/03/06/docker-commit-container</id><content type="html" xml:base="http://nicewoong.github.io/development/2018/03/06/docker-commit-container/">&lt;h3 id=&quot;1-docker-컨테이너container-커밋commit하기&quot;&gt;1. Docker 컨테이너(Container) 커밋(Commit)하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;현재까지 작업해 놓은 ubuntu 컨테이너를 그대로 저장하고 싶다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;실행중인 컨테이너를 커밋해보자.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker commit CONTAINER IMAGE_NAME&lt;/code&gt; 명령 이용.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ docker commit ubuntu-cpp-driver ubuntu-cpp-driver
  sha256:85b8eb5a23e6c850c4f4d298119275ec5a85bc43c78414372aee2859e9ad9e54
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;container 이름이 ubuntu-cpp-driver 였고, 이를 이미지로 저장할 때 이미지 이름도 동일하게 했다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker images&lt;/code&gt;로 확인해보자.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ docker images
  REPOSITORY                  TAG                 IMAGE ID            CREATED              SIZE
  ubuntu-cpp-driver           latest              85b8eb5a23e6        About a minute ago   582MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-docker-이미지image-push하기&quot;&gt;2. Docker 이미지(Image) Push하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Docker cloud 에 로그인 하기&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ docker login
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker user id 변수 지정해놓기&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ export DOCKER_ID_USER=&quot;nicewoong&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Docker Image 에 태그 달기&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ docker tag ubuntu-cpp-driver $DOCKER_ID_USER/ubuntu-cpp-driver
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Tag 가 적용되어 있는 Image 를 Docker Cloud 에 Push&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ docker push $DOCKER_ID_USER/ubuntu-cpp-driver
  The push refers to a repository [docker.io/nicewoong/ubuntu-cpp-driver]
  441a4ecb7164: Pushing [==================================================&amp;gt;]  472.2MB
  7f7a065d245a: Mounted from nicewoong/ubuntu-bluecoat 
  f96e6b25195f: Mounted from nicewoong/ubuntu-bluecoat 
  c56153825175: Mounted from nicewoong/ubuntu-bluecoat 
  ae620432889d: Mounted from nicewoong/ubuntu-bluecoat 
  a2022691bf95: Mounted from nicewoong/ubuntu-bluecoat 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>nicewoong</name></author><category term="development" /><category term="linux" /><category term="c" /><category term="docker" /><category term="container" /><summary type="html">1. Docker 컨테이너(Container) 커밋(Commit)하기</summary></entry><entry><title type="html">Docker(도커) 이미지 만들기</title><link href="http://nicewoong.github.io/development/2018/02/28/docker-image/" rel="alternate" type="text/html" title="Docker(도커) 이미지 만들기" /><published>2018-02-28T12:00:00+00:00</published><updated>2018-02-28T12:00:00+00:00</updated><id>http://nicewoong.github.io/development/2018/02/28/docker-image</id><content type="html" xml:base="http://nicewoong.github.io/development/2018/02/28/docker-image/"></content><author><name>nicewoong</name></author><category term="development" /><category term="linux" /><category term="c" /><category term="docker" /><category term="container" /><summary type="html"></summary></entry><entry><title type="html">Cassandra(카산드라) C 드라이버 설치 튜토리얼</title><link href="http://nicewoong.github.io/development/2018/02/25/cassandra-c-driver-tutorial/" rel="alternate" type="text/html" title="Cassandra(카산드라) C 드라이버 설치 튜토리얼" /><published>2018-02-25T12:00:00+00:00</published><updated>2018-02-25T12:00:00+00:00</updated><id>http://nicewoong.github.io/development/2018/02/25/cassandra-c-driver-tutorial</id><content type="html" xml:base="http://nicewoong.github.io/development/2018/02/25/cassandra-c-driver-tutorial/">&lt;p&gt;직접 깃허브에 정리해놓은 한글 튜토리얼과 샘플코드를 참고하십시오.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/nicewoong/cassandra_c_driver&quot;&gt;Cassandra C driver 튜토리얼&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;참고-링크&quot;&gt;참고 링크&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.datastax.com/en/developer/cpp-driver/2.8/topics/&quot;&gt;공식 설명 문서(v2.8) - DataStax C/C++ Driver for Apache Cassandra&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://downloads.datastax.com/cpp-driver/ubuntu/16.04/cassandra/v2.8.1/&quot;&gt;cpp-drivere 우분투 v2.8 다운로드 서버&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://downloads.datastax.com/cpp-driver/ubuntu/16.04/dependencies/&quot;&gt;cpp-driver 우분투 디펜던시 다운로드 서버(최신거)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cpp-driver&lt;/code&gt; 다운로드 서버와 &lt;code class=&quot;highlighter-rouge&quot;&gt;dependancies&lt;/code&gt; 다운로드 서버에 접속하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;.deb&lt;/code&gt; 파일이 각 세 개씩 올라가 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;deb-파일이란&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.deb&lt;/code&gt; 파일이란?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.deb&lt;/code&gt;은 데비안의 소프트웨어 패키지 포맷의 확장자&lt;/li&gt;
  &lt;li&gt;패키지 관리 시스템&lt;/li&gt;
  &lt;li&gt;데비안 소프트웨어 포맷의 &lt;code class=&quot;highlighter-rouge&quot;&gt;바이너리 패키지&lt;/code&gt;에서 가장 자주 사용되는 파일 이름이다.&lt;/li&gt;
  &lt;li&gt;데비안 패키지는 데비안 기반의 &lt;code class=&quot;highlighter-rouge&quot;&gt;GNU&lt;/code&gt;/리눅스 배포판 (&lt;code class=&quot;highlighter-rouge&quot;&gt;우분투&lt;/code&gt; 등)에서 동작한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;deb-파일-설치&quot;&gt;deb 파일 설치&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    # dpkg -i [deb파일]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;패키지-삭제&quot;&gt;패키지 삭제&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    # dpkg -r [패키지 이름]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;설치된-패키지-검색&quot;&gt;설치된 패키지 검색&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    # dpkg -l
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;deb-파일-모두-다운받기&quot;&gt;.deb 파일 모두 다운받기.&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;wget&lt;/code&gt; 명령어를 이용해서 다운로드 서버에서 단운로드 한다.
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;url 은 위 다운로드 서버에서 해당 파일을 오른쪽 클릭해서 링크를 얻어왔다.&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo wget http://downloads.datastax.com/cpp-driver/ubuntu/16.04/cassandra/v2.8.1/cassandra-cpp-driver_2.8.1-1_amd64.deb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Cassandra-cpp-driver패키지와 cpp-driver-dependancies 에 &lt;code class=&quot;highlighter-rouge&quot;&gt;...-dbg&lt;/code&gt; 랑 &lt;code class=&quot;highlighter-rouge&quot;&gt;...-dev&lt;/code&gt; 파일 등을 모두 다운로드 한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그러면 총 여섯개의 파일이 다운로드된다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ ls -l
  -rw-r--r-- 1 root root  419554 Feb 15 02:48 cassandra-cpp-driver_2.8.1-1_amd64.deb
  -rw-r--r-- 1 root root 8651010 Feb 15 02:48 cassandra-cpp-driver-dbg_2.8.1-1_amd64.deb
  -rw-r--r-- 1 root root  535830 Feb 15 02:48 cassandra-cpp-driver-dev_2.8.1-1_amd64.deb
  -rw-r--r-- 1 root root   60990 Feb 15 02:48 libuv_1.18.0-1_amd64.deb
  -rw-r--r-- 1 root root  197746 Feb 15 02:48 libuv-dbg_1.18.0-1_amd64.deb
  -rw-r--r-- 1 root root   80032 Feb 15 02:48 libuv-dev_1.18.0-1_amd64.deb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;다운로드-받은-deb-파일-설치하기&quot;&gt;다운로드 받은 .deb 파일 설치하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dpkg&lt;/code&gt;를 통해 설치를 시도했는데 아래와 같은 오류가 발생&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # dpkg -i cassandra-cpp-driver_2.8.1-1_amd64.deb 
  Selecting previously unselected package cassandra-cpp-driver.
  (Reading database ... 5073 files and directories currently installed.)
  Preparing to unpack cassandra-cpp-driver_2.8.1-1_amd64.deb ...
  Unpacking cassandra-cpp-driver (2.8.1-1) ...
  dpkg: dependency problems prevent configuration of cassandra-cpp-driver:
   cassandra-cpp-driver depends on libuv; however:
    Package libuv is not installed.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;libuv 가 필요하다고 한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그렇다. libuv 파일을 &lt;code class=&quot;highlighter-rouge&quot;&gt;dpkg&lt;/code&gt;를 통해 설치하고나서 cpp-driver를 설치하니깐 에러 없이 순식간에 끝이났다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # dpkg -i cassandra-cpp-driver_2.8.1-1_amd64.deb 
  (Reading database ... 5083 files and directories currently installed.)
  Preparing to unpack cassandra-cpp-driver_2.8.1-1_amd64.deb ...
  Unpacking cassandra-cpp-driver (2.8.1-1) over (2.8.1-1) ...
  Setting up cassandra-cpp-driver (2.8.1-1) ...
  Processing triggers for libc-bin (2.23-0ubuntu10) ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;테스트-코드-작성해보기&quot;&gt;테스트 코드 작성해보기.&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;샘플코드는 아래 링크를 참조하십시오.
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/nicewoong/cassandra_c_driver/blob/master/sample_modularized.c&quot;&gt;샘플코드바로가기&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;test.c &lt;/code&gt;를 만들어서 &lt;code class=&quot;highlighter-rouge&quot;&gt;#include &amp;lt;cassandra.h&amp;gt;&lt;/code&gt; 를 포함시켜서 컴파일 해봤다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;          # gcc test.c -o test 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;하지만 test 코드에서 사용된 함수들을 못찾겠다고 컴파일 에러…;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # gcc test.c
  /tmp/ccBWYYkU.o: In function `main':
  test.c:(.text+0xe): undefined reference to `cass_cluster_new'
  test.c:(.text+0x1c): undefined reference to `cass_session_new'
  test.c:(.text+0x31): undefined reference to `cass_cluster_set_contact_points'
  test.c:(.text+0x44): undefined reference to `cass_session_connect'
  test.c:(.text+0x54): undefined reference to `cass_future_error_code'
  test.c:(.text+0x61): undefined reference to `cass_error_desc'
  test.c:(.text+0x7f): undefined reference to `cass_future_free'
  test.c:(.text+0x8b): undefined reference to `cass_session_free'
  test.c:(.text+0x97): undefined reference to `cass_cluster_free'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;경로를 지정해줘야하는건가?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그래서 아래 명령어로 &lt;code class=&quot;highlighter-rouge&quot;&gt;cassandra-cpp-driver~.deb&lt;/code&gt; 파일을 설치했을 때 만들어낸 파일 목록을 펼쳐봤다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # dpkg -c cassandra-cpp-driver_2.8.1-1_amd64.deb 
  drwxr-xr-x root/root         0 2018-02-14 16:14 ./
  drwxr-xr-x root/root         0 2018-02-14 16:14 ./usr/
  drwxr-xr-x root/root         0 2018-02-14 16:14 ./usr/share/
  drwxr-xr-x root/root         0 2018-02-14 16:14 ./usr/share/doc/
  drwxr-xr-x root/root         0 2018-02-14 16:14 ./usr/share/doc/cassandra-cpp-driver/
  -rw-r--r-- root/root       845 2018-02-14 16:11 ./usr/share/doc/cassandra-cpp-driver/copyright
  -rw-r--r-- root/root       212 2018-02-14 16:11 ./usr/share/doc/cassandra-cpp-driver/changelog.Debian.gz
  drwxr-xr-x root/root         0 2018-02-14 16:14 ./usr/lib/
  drwxr-xr-x root/root         0 2018-02-14 16:14 ./usr/lib/x86_64-linux-gnu/
  -rw-r--r-- root/root   1535928 2018-02-14 16:14 ./usr/lib/x86_64-linux-gnu/libcassandra.so.2.8.1
  lrwxrwxrwx root/root         0 2018-02-14 16:14 ./usr/lib/x86_64-linux-gnu/libcassandra.so.2 -&amp;gt; libcassandra.so.2.8.1 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;검색하다가… 아래와 같이 입력했더니 컴파일은 완료 되었다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # gcc test.c -o test -L/usr/lib/ -lcassandra
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;test 실행파일을 실행하면 아래와 같이 출력이 된다. 근데 connect result에 아무것도 출력 안 된다..;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # ./test 
  Connect result: 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그렇다. 이것은 성공한 것이었다. 쿼리하는 코드를 추가해보니 잘 적용이 됐다 .하하. 굿~&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Installation 설명에 아래와 같이 적혀있는데, 무슨 뜻이지!!!????&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: CentOS and Ubuntu use the version of OpenSSL provided with the distribution.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>nicewoong</name></author><category term="development" /><category term="linux" /><category term="c" /><category term="language" /><category term="programming" /><category term="c++" /><category term="library" /><category term="cassandra" /><summary type="html">직접 깃허브에 정리해놓은 한글 튜토리얼과 샘플코드를 참고하십시오.</summary></entry><entry><title type="html">Linux GCC 옵션</title><link href="http://nicewoong.github.io/development/2018/02/24/linux-gcc-option/" rel="alternate" type="text/html" title="Linux GCC 옵션" /><published>2018-02-24T12:00:00+00:00</published><updated>2018-02-24T12:00:00+00:00</updated><id>http://nicewoong.github.io/development/2018/02/24/linux-gcc-option</id><content type="html" xml:base="http://nicewoong.github.io/development/2018/02/24/linux-gcc-option/">&lt;h2 id=&quot;gcc-옵션정리&quot;&gt;gcc 옵션정리&lt;/h2&gt;

&lt;h3 id=&quot;gcc-전역-옵션&quot;&gt;gcc 전역 옵션&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;옵션
    &lt;ul&gt;
      &lt;li&gt;설명&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-E &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;전처리 과정 화면에 출력&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-S &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;어셈블리 파일 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-c&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;오브젝트 파일 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-v &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;컴파일 과정 화면에 출력&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--save-temps &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;컴파일시 생성되는 중간 파일 저장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-da &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;컴파일 과정에서 생성되는 중간 코드 생성(RTL파일 등 생성)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;전처리기cpp0옵션&quot;&gt;전처리기(cpp0)옵션&lt;/h3&gt;

&lt;p&gt;옵션 
설명&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-l[패스] &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;헤더 파일을 탐색할 디렉토리 지정 ex_ -l/opt/include&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-include [헤더 파일 패스] &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;해당 헤더 파일을 모든 소스 내 추가 ex_ -include /root/my.h&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-D[매크로] &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;외부에서 #define 지정 ex_ -DDEBUG&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-D[매크로]=[매크로 값] &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;외부에서 해당 매크로를 정의하고 값을 지정 ex_ -DDEBUG=1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-U[매크로] &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;외부에서 #undef 지정 ex_ -UDEBUG&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-M 또는 -MM &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;make 기술파일을 위한 소스 파일의 종속 항목 출력&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-nostdinc &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;표준 C 헤더 파일을 include 하지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-C &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;전처리 과정에서 주석을 제거하지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-Wp,[옵션 리스트] &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;옵션 리스트를 전처리기에 바로 전달&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;c-컴파일러cc1-옵션&quot;&gt;C 컴파일러(cc1) 옵션&lt;/h3&gt;

&lt;h4 id=&quot;--c언어-옵션&quot;&gt;- C언어 옵션&lt;/h4&gt;

&lt;p&gt;옵션 
설명&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-ansi   &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;ANSI C 문법으로 문법 검사&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-std=[C 표준] &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;지정한 C 표준으로 문법검사(표준:c89, c99, gnu89, gnu99 등)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-traditional &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;K&amp;amp;R C 문법으로 문법 검사&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-fno-asm &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;asm, inline, typeof 키워드를 사용하지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;--경고옵션&quot;&gt;- 경고옵션&lt;/h4&gt;

&lt;p&gt;옵션 
설명&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-Wall -W&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;모든 경고 메시지 출력&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-w &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;모든 경고 메시지 제거&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-Werror &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;모든 경고를 오류로 취급하여 컴파일 중단&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-pedantic &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;C89 표준에서 요구하는 모든 경고 메시지를 표시&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-pedantic-error &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;C89 표준에서 요구하는 모든 오류 메시지를 표시&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-Wtraditional&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;ANSI C와 K&amp;amp;R C 간에 서로 다른 결과를 가져올수 있는 부분이 있다면 경고&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;최적화-옵션&quot;&gt;최적화 옵션&lt;/h4&gt;

&lt;p&gt;옵션 
설명&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-O0 &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;아무런 최적화를 수행치 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-O1&lt;/code&gt; 또는&lt;code class=&quot;highlighter-rouge&quot;&gt; -O&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;최적화 레벨 1수행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-O2 &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;최적화 레벨 2 수행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-O3&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;최적화 레벨 3 수행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-Os&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;사이즈 최적화 수행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;디버깅 옵션&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;옵션 
설명&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-g &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;바이너리 파일에 디버깅 정보 삽입&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-pg &lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;프로파일을 위한 코드 삽입&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;(유닉스, 리눅스 프로그래밍) 필수 유틸리티 : vi, make, gcc, gdb, cvs, rpm&lt;/li&gt;
&lt;/ul&gt;</content><author><name>nicewoong</name></author><category term="development" /><category term="linux" /><category term="c" /><category term="language" /><category term="programming" /><category term="c++" /><summary type="html">gcc 옵션정리</summary></entry><entry><title type="html">[시행착오 기록] Cassandra(카산드라) C 드라이버 설치</title><link href="http://nicewoong.github.io/development/2018/02/24/cassandra-c-driver/" rel="alternate" type="text/html" title="[시행착오 기록] Cassandra(카산드라) C 드라이버 설치 " /><published>2018-02-24T12:00:00+00:00</published><updated>2018-02-24T12:00:00+00:00</updated><id>http://nicewoong.github.io/development/2018/02/24/cassandra-c-driver</id><content type="html" xml:base="http://nicewoong.github.io/development/2018/02/24/cassandra-c-driver/">&lt;h2 id=&quot;직접-빌드-하는-것-말고-바이너리-패키지-다운로드-받아보기&quot;&gt;직접 빌드 하는 것 말고, 바이너리 패키지 다운로드 받아보기&lt;/h2&gt;

&lt;p&gt;(2018-02-26)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;위에서는 깃허브에서 클론한 프로젝트를 직접 빌드하는 과정을 거쳤다.&lt;/li&gt;
  &lt;li&gt;아무것도 모르고 해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;c library&lt;/code&gt; 사용 및 빌드하는 과정이 너무 생소했다. 그래서 멘붕이었다.&lt;/li&gt;
  &lt;li&gt;gcc 컴파일 옵션, make, c library 에 대해 대략적으로 어제 다시 공부하긴 했다.&lt;/li&gt;
  &lt;li&gt;그래서 다시 빌드하면 이제 잘 할 수 있을 거 같다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그리고 공부한 덕분에 교수님께서 작성해놓으신 프로젝트 &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt; 을 건드려야 할 때가 분명 올텐데, 
그 때 잘 할 수 있을 것 같다.대강 이해가 된다 이제.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;그럼 직접 패키지를 다운받아서 c driver 를 사용해보도록 하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;참고-링크&quot;&gt;참고 링크&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.datastax.com/en/developer/cpp-driver/2.8/topics/&quot;&gt;공식 설명 문서(v2.8) - DataStax C/C++ Driver for Apache Cassandra&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://downloads.datastax.com/cpp-driver/ubuntu/16.04/cassandra/v2.8.1/&quot;&gt;cpp-drivere 우분투 v2.8 다운로드 서버&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://downloads.datastax.com/cpp-driver/ubuntu/16.04/dependencies/&quot;&gt;cpp-driver 우분투 디펜던시 다운로드 서버(최신거)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위 서버로 접속하면 cpp-driver 도 그렇고, dependancies 도 그렇고 모두 .deb 파일이 올라가 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그럼 이걸 어쩌란 말인가?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그리고 디펜던시는 도대체 뭐 어쩌라고 올려두는건가?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;디펜던시도 다운받아야 하는건가? 그럼 그걸 어떻게 왜 어디다가 쓰는건가!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;위 다운로드 서버에 접속하면 .deb 파일로 다운로드할 파일들이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;deb-파일이란&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.deb&lt;/code&gt; 파일이란?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.deb&lt;/code&gt;은 데비안의 소프트웨어 패키지 포맷의 확장자&lt;/li&gt;
  &lt;li&gt;패키지 관리 시스템&lt;/li&gt;
  &lt;li&gt;데비안 소프트웨어 포맷의 &lt;code class=&quot;highlighter-rouge&quot;&gt;바이너리 패키지&lt;/code&gt;에서 가장 자주 사용되는 파일 이름이다.&lt;/li&gt;
  &lt;li&gt;데비안 패키지는 데비안 기반의 &lt;code class=&quot;highlighter-rouge&quot;&gt;GNU&lt;/code&gt;/리눅스 배포판 (&lt;code class=&quot;highlighter-rouge&quot;&gt;우분투&lt;/code&gt; 등)에서 동작한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;deb-파일-설치&quot;&gt;deb 파일 설치&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    # dpkg -i [deb파일]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;패키지-삭제&quot;&gt;패키지 삭제&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    # dpkg -r [패키지 이름]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;설치된-패키지-검색&quot;&gt;설치된 패키지 검색&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    # dpkg -l
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;cli에서-url-을-통해-deb파일-다운받기&quot;&gt;CLI에서 URL 을 통해 &lt;code class=&quot;highlighter-rouge&quot;&gt;.deb&lt;/code&gt;파일 다운받기.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.deb&lt;/code&gt; 파일이 무엇인지 알겠다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그렇다면 위의 카산드라 c 드라이버 다운로드 서버에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;.deb&lt;/code&gt; 파일을 다운받아보자.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;어떻게?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;url경로를 통해 파일을 다운로드 할 땐 &lt;code class=&quot;highlighter-rouge&quot;&gt;wget&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;lftpget&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt;명령어를 사용한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;wget&lt;/code&gt;은 간단하게 특정 url에 있는 파일을 다운로드 할 수 있는 어플리케이션&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;우선 &lt;code class=&quot;highlighter-rouge&quot;&gt;wget&lt;/code&gt;을 이용해보자.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;cassandra-cpp-driver 를 먼저 단운로드 한다.
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;(링크) - &lt;a href=&quot;http://downloads.datastax.com/cpp-driver/ubuntu/16.04/cassandra/v2.8.1/&quot;&gt;cpp-drivere 우분투 v2.8 다운로드 서버&lt;/a&gt;&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo wget http://downloads.datastax.com/cpp-driver/ubuntu/16.04/cassandra/v2.8.1/cassandra-cpp-driver_2.8.1-1_amd64.deb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;url 은 위 다운로드 서버에서 해당 파일을 오른쪽 클릭해서 링크를 얻어왔다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;아 근데 &lt;code class=&quot;highlighter-rouge&quot;&gt;...-dbg&lt;/code&gt; 랑 &lt;code class=&quot;highlighter-rouge&quot;&gt;...-dev&lt;/code&gt; 파일도 있는데 이것들 다 다운로드 해야하는 건가?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위 명령어를 통해서 다운로드 하면 현재 폴더에 &lt;code class=&quot;highlighter-rouge&quot;&gt;.deb&lt;/code&gt;파일이 다운로드 된 것을 확인 가능&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ ls
  cassandra-cpp-driver_2.8.1-1_amd64.deb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그리고 &lt;code class=&quot;highlighter-rouge&quot;&gt;dpkg&lt;/code&gt;를 통해 설치를 시도해봤는데 안 된다….&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;일단 Cassandra-cpp-driver패키지와 cpp-driver-dependancies 에 있는 것들 세 가지씩 모두 다운 받았다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ ls -l
  -rw-r--r-- 1 root root  419554 Feb 15 02:48 cassandra-cpp-driver_2.8.1-1_amd64.deb
  -rw-r--r-- 1 root root 8651010 Feb 15 02:48 cassandra-cpp-driver-dbg_2.8.1-1_amd64.deb
  -rw-r--r-- 1 root root  535830 Feb 15 02:48 cassandra-cpp-driver-dev_2.8.1-1_amd64.deb
  -rw-r--r-- 1 root root   60990 Feb 15 02:48 libuv_1.18.0-1_amd64.deb
  -rw-r--r-- 1 root root  197746 Feb 15 02:48 libuv-dbg_1.18.0-1_amd64.deb
  -rw-r--r-- 1 root root   80032 Feb 15 02:48 libuv-dev_1.18.0-1_amd64.deb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;하.. 그냥 docker 로 ubuntu 하나 새로 팠다. 아마 패키지가 꼬였는 거 같은데 어떻게 해결 방법을 찾을라면 막막해서…&lt;/li&gt;
  &lt;li&gt;다시 위 파일들을 다운받고.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dpkg&lt;/code&gt;를 통해 설치를 시도했는데 아래와 같은 오류가 발생&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # dpkg -i cassandra-cpp-driver_2.8.1-1_amd64.deb 
  Selecting previously unselected package cassandra-cpp-driver.
  (Reading database ... 5073 files and directories currently installed.)
  Preparing to unpack cassandra-cpp-driver_2.8.1-1_amd64.deb ...
  Unpacking cassandra-cpp-driver (2.8.1-1) ...
  dpkg: dependency problems prevent configuration of cassandra-cpp-driver:
   cassandra-cpp-driver depends on libuv; however:
    Package libuv is not installed.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;libuv 가 필요하다고 한다. 다운받은 패키지를 설치하면 되는걸까?&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그렇다. libuv 파일을 &lt;code class=&quot;highlighter-rouge&quot;&gt;dpkg&lt;/code&gt;를 통해 설치하고나서 cpp-driver를 설치하니깐 에러 없이 순식간에 끝이났다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # dpkg -i cassandra-cpp-driver_2.8.1-1_amd64.deb 
  (Reading database ... 5083 files and directories currently installed.)
  Preparing to unpack cassandra-cpp-driver_2.8.1-1_amd64.deb ...
  Unpacking cassandra-cpp-driver (2.8.1-1) over (2.8.1-1) ...
  Setting up cassandra-cpp-driver (2.8.1-1) ...
  Processing triggers for libc-bin (2.23-0ubuntu10) ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;아 근데 우분투에 너무 아무것도 설치가 안 돼 있다…&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # apt-get install vim
  # apt-get install gcc
  # apt-get install net-tools
  # apt-get install g++
  # apt-get install openssh-client openssh-server
  # apt-get install python
  # apt-get install git
  # apt-get install build-essential
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;vi 설정도 해줬음. &lt;code class=&quot;highlighter-rouge&quot;&gt;vi ~/.vimrc&lt;/code&gt;를 통해 설정파일을 열어 아래 것들을 입력해준다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  set number          
  set ai                  
  set si                   
  set cindent           
  set shiftwidth=4     
  set tabstop=4        
  set ignorecase      
  set hlsearch         
  set expandtab      
  set background=dark 
  set nocompatible   
  set fileencodings=utf-8,euc-kr    
  set bs=indent,eol,start   
  set history=1000    
  set ruler             
  set nobackup    
  set title             
  set showmatch    
  set nowrap 
  set wmnu          
  syntax on  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;또 기본 세팅 더 해주자. 추후에.
    &lt;ul&gt;
      &lt;li&gt;https://blog.shako.net/ubuntu-server-16-04-initial-setup-guide/&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;test.c &lt;/code&gt;를 만들어서 &lt;code class=&quot;highlighter-rouge&quot;&gt;#include &amp;lt;cassandra.h&amp;gt;&lt;/code&gt; 를 포함시켜서 컴파일 해봤다.&lt;/li&gt;
  &lt;li&gt;에러가 발생했다. &lt;code class=&quot;highlighter-rouge&quot;&gt;cassandra.h&lt;/code&gt;를 찾을 수 없단다.&lt;/li&gt;
  &lt;li&gt;경로를 지정해줘야하는건가?&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그래서 아래 명령어로 &lt;code class=&quot;highlighter-rouge&quot;&gt;cassandra-cpp-driver~.deb&lt;/code&gt; 파일을 설치했을 때 만들어낸 파일 목록을 펼쳐봤다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # dpkg -c cassandra-cpp-driver_2.8.1-1_amd64.deb 
  drwxr-xr-x root/root         0 2018-02-14 16:14 ./
  drwxr-xr-x root/root         0 2018-02-14 16:14 ./usr/
  drwxr-xr-x root/root         0 2018-02-14 16:14 ./usr/share/
  drwxr-xr-x root/root         0 2018-02-14 16:14 ./usr/share/doc/
  drwxr-xr-x root/root         0 2018-02-14 16:14 ./usr/share/doc/cassandra-cpp-driver/
  -rw-r--r-- root/root       845 2018-02-14 16:11 ./usr/share/doc/cassandra-cpp-driver/copyright
  -rw-r--r-- root/root       212 2018-02-14 16:11 ./usr/share/doc/cassandra-cpp-driver/changelog.Debian.gz
  drwxr-xr-x root/root         0 2018-02-14 16:14 ./usr/lib/
  drwxr-xr-x root/root         0 2018-02-14 16:14 ./usr/lib/x86_64-linux-gnu/
  -rw-r--r-- root/root   1535928 2018-02-14 16:14 ./usr/lib/x86_64-linux-gnu/libcassandra.so.2.8.1
  lrwxrwxrwx root/root         0 2018-02-14 16:14 ./usr/lib/x86_64-linux-gnu/libcassandra.so.2 -&amp;gt; libcassandra.so.2.8.1 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;그리고 서버에서 다운받은 모든 cpp-driver 의 .dep 파일을 모두 설치해줫다! 그러니깐 일딴 cassandra.h 를 인클루듷 ㅏ는 것은 문제 없었따.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;하지만 test 코드에서 사용된 함수들을 못찾겠다고 컴파일 에러…;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # gcc test.c
  /tmp/ccBWYYkU.o: In function `main':
  test.c:(.text+0xe): undefined reference to `cass_cluster_new'
  test.c:(.text+0x1c): undefined reference to `cass_session_new'
  test.c:(.text+0x31): undefined reference to `cass_cluster_set_contact_points'
  test.c:(.text+0x44): undefined reference to `cass_session_connect'
  test.c:(.text+0x54): undefined reference to `cass_future_error_code'
  test.c:(.text+0x61): undefined reference to `cass_error_desc'
  test.c:(.text+0x7f): undefined reference to `cass_future_free'
  test.c:(.text+0x8b): undefined reference to `cass_session_free'
  test.c:(.text+0x97): undefined reference to `cass_cluster_free'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;검색하다가… 아래와 같이 입력했더니 컴파일은 완료 되었다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # gcc test.c -o test -L/usr/lib/ -lcassandra
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;아니 근데.. usr/lib 는 기본 참조 디렉터리라서 라이브러리경로 명시안해줘도 되는 줄 알았는데!?? ㅠㅠ&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;test 실행파일을 실행하면 아래와 같이 출력이 된다. 근데 connect result에 아무것도 출력 안 된다..;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # ./test 
  Connect result: 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그렇다. 이것은 성공한 것이었다. 쿼리하는 코드를 추가해보니 잘 적용이 됐다 .하하. 굿~&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Installation 설명에 아래와 같이 적혀있는데, 무슨 뜻이지!!!????&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: CentOS and Ubuntu use the version of OpenSSL provided with the distribution.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;기타&quot;&gt;기타&lt;/h3&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;참고로 몽고디비는 빌드하고나서 아래와 같이 참조하여 라이브러리를 사용한다.
    &lt;ul&gt;
      &lt;li&gt;(출처) - http://cheonbrave.blogspot.kr/2017/06/mongodb-c-driver-1.html&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;그럼 컴파일할때 어떻게 참조 하나요 ? 
만약 C 로 코딩해서 test.c 라는 소스를 작성했다고 했을 때 
아래와같이 수행하면 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    gcc -o test test.c -I/usr/local/include/libmongoc-1.0 -I/usr/local/include/libbson-1.0 -L/usr/local/lib/ -L/usr/lib64 -lmongoc-1.0 -lbson-1.0 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;그렇다면 설치한 cassandra c driver 라이브러리가 어느 경로에 설치됐는지 알면 되겠지!?&lt;/li&gt;
&lt;/ul&gt;</content><author><name>nicewoong</name></author><category term="development" /><category term="linux" /><category term="c" /><category term="language" /><category term="programming" /><category term="c++" /><category term="library" /><category term="cassandra" /><summary type="html">직접 빌드 하는 것 말고, 바이너리 패키지 다운로드 받아보기</summary></entry><entry><title type="html">리눅스 - make, makefile 이란</title><link href="http://nicewoong.github.io/development/2018/02/24/linux-makefile/" rel="alternate" type="text/html" title="리눅스 - make, makefile 이란" /><published>2018-02-24T12:00:00+00:00</published><updated>2018-02-24T12:00:00+00:00</updated><id>http://nicewoong.github.io/development/2018/02/24/linux-makefile</id><content type="html" xml:base="http://nicewoong.github.io/development/2018/02/24/linux-makefile/">&lt;h2 id=&quot;make-란&quot;&gt;Make 란?&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt;는 파일 관리 유틸리티&lt;/li&gt;
  &lt;li&gt;반복적인 명령 자동화를 위한 것.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;이 있는 디렉토리에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 만 치면 컴파일된다.&lt;/li&gt;
  &lt;li&gt;파일 간의 종속관계를 파악하여 
&lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;( 기술파일 )에 적힌 대로 컴파일러에 명령하여 SHELL 명령 순차적으로 실행&lt;/li&gt;
  &lt;li&gt;프로그램의 종속 구조를 빠르게 파악&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;makefile&quot;&gt;Makefile&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;구조
    &lt;ul&gt;
      &lt;li&gt;목적파일(Target) : 명령어가 수행되어 나온 결과를 저장할 파일&lt;/li&gt;
      &lt;li&gt;의존성(Dependency) : 목적파일을 만들기 위해 필요한 재료&lt;/li&gt;
      &lt;li&gt;명령어(Command) : 실행 되어야 할 명령어들&lt;/li&gt;
      &lt;li&gt;매크로(macro) : 코드를 단순화 시키기 위한 방법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;cmake&quot;&gt;cmake&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 는 범용적인 컴파일 명령어 이고요&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gmake&lt;/code&gt;는 리눅스에서 make 와 같고요 gmake=make&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cmake&lt;/code&gt;는 input 파일들을 자동 생성 하며 컴파일 하는 autotool 컴파일 방식
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cmake&lt;/code&gt;는 make file을 생성해주는 툴 중 하나입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;참고&lt;/strong&gt; (자세한 cmake 에 대한 설명) - https://tuwlab.com/ece/27234&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://bowbowbow.tistory.com/12#make-와-makefile&quot;&gt;블로그 - 멍멍멍&lt;/a&gt; &amp;lt;- 설명이 진짜 잘 돼 있음.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://tuwlab.com/ece/27234&quot;&gt;CMake 소개와 예제, 내부 동작 원리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>nicewoong</name></author><category term="development" /><category term="linux" /><category term="c" /><category term="language" /><category term="programming" /><category term="c++" /><category term="library" /><summary type="html">Make 란?</summary></entry><entry><title type="html">c 라이브러리 파일, gcc 컴파일</title><link href="http://nicewoong.github.io/development/2018/02/24/c-library-gcc-compile/" rel="alternate" type="text/html" title="c 라이브러리 파일, gcc 컴파일" /><published>2018-02-24T12:00:00+00:00</published><updated>2018-02-24T12:00:00+00:00</updated><id>http://nicewoong.github.io/development/2018/02/24/c-library-gcc-compile</id><content type="html" xml:base="http://nicewoong.github.io/development/2018/02/24/c-library-gcc-compile/">&lt;h3 id=&quot;gcc-옵션-라이브러리-관련&quot;&gt;GCC 옵션 라이브러리 관련&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-l&lt;/code&gt; 옵션 (소문자 엘)
    &lt;ul&gt;
      &lt;li&gt;링크할 라이브러리를 명시하는 옵션이다.&lt;/li&gt;
      &lt;li&gt;정적 라이브러리를 링크시키는데 사용되며 대상 라이브러리 파일의 이름에서 앞의 &lt;code class=&quot;highlighter-rouge&quot;&gt;lib&lt;/code&gt;와 뒤의 &lt;code class=&quot;highlighter-rouge&quot;&gt;.a&lt;/code&gt;를 때고 인식한다.&lt;/li&gt;
      &lt;li&gt;예를 들어 &lt;code class=&quot;highlighter-rouge&quot;&gt;libmylib.a&lt;/code&gt; 라는 라이브러리 파일을 링크시키려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;-lmylib&lt;/code&gt; 로 옵션을 주면 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-L&lt;/code&gt; 옵션 (대문자 엘)
    &lt;ul&gt;
      &lt;li&gt;라이브러리 위치를 정해주는 옵션이다.&lt;/li&gt;
      &lt;li&gt;사용은 다음과 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;-L&amp;lt;디렉토리명&amp;gt;&lt;/code&gt; 으로 한다.&lt;/li&gt;
      &lt;li&gt;기본적으로 리눅스는 &lt;code class=&quot;highlighter-rouge&quot;&gt;/lib, /usr/lib, /usr/local/lib&lt;/code&gt; 만을 검색해서 라이브러리를 찾는다.&lt;/li&gt;
      &lt;li&gt;그러므로 추가적으로 디렉토리를 검색하도록 하려면 -L 옵션을 사용하면 된다.-l 옵션 (소문자 엘)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;(출처) - http://yjaeseok.tistory.com/86&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;c-라이브러리-파일-만들기&quot;&gt;c 라이브러리 파일 만들기&lt;/h3&gt;

&lt;h4 id=&quot;1라이브러리-파일-만들기&quot;&gt;1.라이브러리 파일 만들기&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;리눅스 상에서 GCC컴파일러를 이용해 라이브러리를 만드려면 다음과 같은 컴파일 과정을 통해서 오브젝트 파일을 생성한다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ gcc -c filename.c (.cpp 파일을 컴파일 할 경우 g++ -c filename.cpp)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컴파일이 제대로 끝났다면 확장자가 &lt;code class=&quot;highlighter-rouge&quot;&gt;.o&lt;/code&gt;인 &lt;code class=&quot;highlighter-rouge&quot;&gt;filename.o&lt;/code&gt;파일이 만들어 질것이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이번에는 생성된 오브젝트 파일을 이용하여 라이브러리를 만들도록 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이 때 사용하는 명령어는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ar&lt;/code&gt;로 라이브러리 작성에 사용된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;아래와 같이 ar옵션 그리고 생성하고자 하는 라이브러리의 이름, 마지막으로 오브젝트 파일들의 이름을 나열한후 실행 한다. 
(※ 윈도우에서 라이브러리 파일의 확장자는 .lib이지만 리눅스에서는 .a확장자를 지닌다.)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ ar crv libfile.a filename.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-라이브러리-파일의-사용&quot;&gt;2. 라이브러리 파일의 사용&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;이때 라이브러리의 이름은 lib라는 말과 확장자 .a를 생략하여 사용할수 있다. 즉, libfile.a의 경우 그냥 file이라고 쓰면 된다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ gcc -o executefile uselib.c -L. -l file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이때 만일 라이브러리 파일이 &lt;code class=&quot;highlighter-rouge&quot;&gt;/home/user&lt;/code&gt; 디렉토리 밑에 있다면 -L 옵션을 다음과 같이 주면 된다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  -L /home/user
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;출처: http://kukuta.tistory.com/52 [HardCore in Programming]&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;정적라이브러리와-동적라이브러리&quot;&gt;정적라이브러리와 동적라이브러리&lt;/h3&gt;

&lt;h4 id=&quot;정적-라이브러리또는-archive&quot;&gt;정적 라이브러리(또는 Archive)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;정적라이브러리(또는 Archive)파일이라 불리우고 .a의 확장자를 가진다.&lt;/li&gt;
  &lt;li&gt;여러개의 오브젝트 파일들을 하나로 묶어 사용하기 때문에 Archive파일이라고 부름&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;컴파일 시간&lt;/code&gt;에 코드를 포함하여 결정하기 때문에 정적 라이브러리라고 부른다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcc -c test.c
  gcc -c app.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;test.o 파일과 app.o 파일이 생성됨.&lt;/li&gt;
  &lt;li&gt;test.o 파일을 Archive로 묶어 보자.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;라이브러리 파일의 작명법은 &lt;code class=&quot;highlighter-rouge&quot;&gt;lib&lt;/code&gt;뒤에 이름을 붙임&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ar cr libtest.a test.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;libtest.a&lt;/code&gt; 파일이 생성됨.&lt;/li&gt;
  &lt;li&gt;이 라이브러리를 사용하여 컴파일 할려면 아래와 같이 한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-ltest&lt;/code&gt;가 &lt;code class=&quot;highlighter-rouge&quot;&gt;libtest.a&lt;/code&gt;를 지정하게 된다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-L.&lt;/code&gt; 은 현재 폴더 가리킴&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  #gcc -o  app app.o -L. -ltest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;동적-라이브러리&quot;&gt;동적 라이브러리&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;실 행 시간에 라이브러리 파일을 찾아 코드를 포함하기 때문에 동적라이브러리라고 부름&lt;/li&gt;
  &lt;li&gt;즉, 정적 라이브러리는 컴파일 시간에 코드를 결정하기 때문에 소스가 변경되면 새로 컴파일 해야하지만,&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;동적 라이브러리의 경우 라이브러리만 교체하는 것으로도 변경이 가능하다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcc -c -fPIC test.c
  gcc -c app.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-fPIC&lt;/code&gt;옵션은 Position-Independent Code의 약자이며 &lt;code class=&quot;highlighter-rouge&quot;&gt;test.o&lt;/code&gt;파일을 동적라이브러리로 사용하도록 컴파일 하는 옵션이다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이렇게 컴파일된 오브젝트 파일을 .so파일로 묶으면 된다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # gcc -shared -fPIC -o libtest.so test.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컴파일은 아래와 같이 하면 된다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # gcc -o app app.o -L. -ltest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;만 일 &lt;code class=&quot;highlighter-rouge&quot;&gt;libtest.a&lt;/code&gt; 파일과 &lt;code class=&quot;highlighter-rouge&quot;&gt;libtest.so&lt;/code&gt; 파일이 같이 있을 경우 gcc 컴파일러는 &lt;code class=&quot;highlighter-rouge&quot;&gt;libtest.so&lt;/code&gt; 파일을 먼저 지정하게 된다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;만일 libtest.a를 사용하여 컴파일 하고 싶으면 아래와 같이 실행하면 된다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # gcc -static -o app app.o -L. -ltest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;출처: http://blueamor.tistory.com/707 [51%의 가능성]&lt;/li&gt;
&lt;/ul&gt;</content><author><name>nicewoong</name></author><category term="development" /><category term="c" /><category term="language" /><category term="programming" /><category term="c++" /><category term="library" /><summary type="html">GCC 옵션 라이브러리 관련</summary></entry><entry><title type="html">중국 정말 무섭다. 미/중 인공지능 양강시대</title><link href="http://nicewoong.github.io/thoughts/2018/02/22/scary-of-china/" rel="alternate" type="text/html" title="중국 정말 무섭다. 미/중 인공지능 양강시대" /><published>2018-02-22T12:00:00+00:00</published><updated>2018-02-22T12:00:00+00:00</updated><id>http://nicewoong.github.io/thoughts/2018/02/22/scary-of-china</id><content type="html" xml:base="http://nicewoong.github.io/thoughts/2018/02/22/scary-of-china/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;중국-무섭다-미-중-인공지능-양강시대&quot;&gt;중국, 무섭다! 미, 중 인공지능 양강시대.&lt;/h2&gt;

&lt;p&gt;오래전부터 중국이 앞으로 더욱더 발전하고 경쟁력을 갖출 것이라는 이야기를 많이 들었다. 
그런데 그건 생각보다 훨씬 급격히 진행되었고, 이미 상상을 초월하는 수준이다.&lt;/p&gt;

&lt;p&gt;많은 사람들은 아직도 중국이 짝퉁 나라라고 인식하는 것 같다.  큰 문제다.&lt;br /&gt;
그 인식을 바꿔야 한다. 인공지능뿐만 아니라, SW, HW 그리고 스타트업 분야까지 중국이 장악하고 있다. 
중국은 단순히 국가의 힘뿐만 아니라, 전 분야에 있어서 우리나라에 앞서고 있다. 
오히려 중국인들이 한국인들을 무시하고 있다. 실상을 몰라도 너무 모르는 사람들이 많다. 
특히 우리나라 기업들에겐 엄청난 위기다. 
스마트폰이나 SW 나 각종 중국산 프로덕트에 대해서 우리가 무시할 수 없는 수준에 이르렀다. 
예전엔 저렴하기만 했다면, 이젠 품질까지 갖추고 있다. 
오리지널 제품들과 큰 차이가 나지 않는다. 이젠 중국을 하찮은 모방 대륙이라고 볼 수 없다.&lt;/p&gt;

&lt;p&gt;또한 많은 기술적인 분야에서 우리나라를 앞서고도 남았고, 세상을 선도하고 있다. 
반도체 시장은 아직 우리나라 기술력이 앞서고 있지만, 빠른 시간 안에 추월당할 가능성이 크다.&lt;/p&gt;

&lt;p&gt;우리는 중국을 주목해야 한다. 우리 기업들은 이미 주목하고, 위기의식을 많이 느끼고 있을 것이다. 
일반 시민들도 그 인식을 바꿔서 중국을 주목해야 한다. 
특히 정부의 역할이 큰데, 각종 새로운 산업과 규제에 대한 태도를 보면 큰 차이가 난다. 
우리 정부도 수준을 높여야 한다. 배울 것은 배워야 한다.&lt;/p&gt;

&lt;p&gt;알리바바, 텐센트, 바이두는 IT 공룡 기업이다. 미국의 아마존, 구글, 애플에 대항하는 존재다. 
한국은 아직 그런 기업 없다. 
이와 같은 중국 기업들은, 창업자와 구성원들이 훌륭하고 시장의 파이가 처음부터 큰 것이 영향인 것도 있다. 
하지만 무엇보다 중요한 것은 국가가 이를 돕고 있다는 것. 중국 정부.&lt;/p&gt;

&lt;p&gt;한마디로 정리하면, 무섭다. 중국이 무섭다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;아래-글들은-퍼-온-글들-출처--임정욱-스얼-센터장님-페이스북&quot;&gt;아래 글들은 퍼 온 글들! (출처 : 임정욱 스얼 센터장님 페이스북)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;카이후 리가 말하는 미중 인공지능 양강시대 https://estimastory.com/2018/02/17/aiduopoly/
    &lt;ul&gt;
      &lt;li&gt;지난 연말 MIT에서 있었던 카이후 리의 중국 인공지능업계의 현황에 대한 강연을 유튜브에서 보고 메모.&lt;/li&gt;
      &lt;li&gt;중국최고의 수재들이 경영-경제학과를 안가고 수학과나 컴퓨터공학과로 간다. 인공지능붐의 영향.&lt;/li&gt;
      &lt;li&gt;이런 AI천재들이 만든 회사들이 잘 나간다. 얼굴인식기술을 가진 FACE++는 20대들이 창업. 지난해 10월 5천억 추가펀딩.&lt;/li&gt;
      &lt;li&gt;전세계의 인공지능 주요 논문중에서 중국계 학자가 쓴 논문이 전체의 43%에 이를 정도.&lt;/li&gt;
      &lt;li&gt;중국은 데이터의 보고이기 때문에 인공지능 기술 개발에 유리.&lt;/li&gt;
      &lt;li&gt;미국보다 3배의 스마트폰 사용. 모바일페이 50배, 음식주문 10배 등 이런 실생활데이터가 인공지능 알고리즘 개선에 도움.&lt;/li&gt;
      &lt;li&gt;공유자전거 모바이크는 불과 10개월만에 하루 2천만회의 사용량을 달성했다. 중국의 공유자전거붐에 대해서 미국에서 보도되는 많은 (부정적인 내용의) 기사는 틀렸다. 공유자전거는 고객을 위해 가치를 만들어내고 있고 친환경적이다. 오래지 않아 돈을 많이 벌 수 있는 비즈니스모델을 만들어낼 것이다.&lt;/li&gt;
      &lt;li&gt;모바일페이는 중국에 있어서 구조적인 변화를 만들어내고 있다. (중국의 소상공인들에게) 개인간 거래이기 때문에 3% 수수료도 없는 모바일페이는 엄청나게 빠르게 보급됐다. 그리고 모바일페이 덕분에 소비가 너무 쉬워지면서 중국의 경제는 Saving economy(저축경제)에서 Spending economy(소비경제)로 변했다.&lt;/li&gt;
      &lt;li&gt;그런 영향으로 OMO가 뜨고 있다. 인공지능 기술을 통해 온라인과 오프라인이 통합되고 있는 것이다. 알리바바, 텐센트, 디디추싱 등 온라인기업들이 이제는 인공지능기술을 기반으로 오프라인에 진출하고 있다.&lt;/li&gt;
      &lt;li&gt;이제 중국은 미국과 어깨를 나란히 하는 혁신국가가 됐다. 처음에는 미국의 인터넷기업들을 베껴서 바이두, 넷이즈, 시나, 소후 등이 시작. 그러다가 미국의 회사들을 모방했지만 더 나은 기능으로 개선된 웨이보(트위터), 지후(Quora), 타오바오, 알리페이, 위챗 등의 서비스가 나오기 시작. 그리고 토우티아오, 모바이크 등 인공지능을 기반으로 중국만의 혁신이 나왔다. 이제는 아이메시지(미국), 라임바이크(미국), 토코피디아(인도네시아), 페이티엠(인도) 등 세계각국에서 중국의 혁신을 모방한 제품이 나오기 시작하는 단계까지 왔다.&lt;/li&gt;
      &lt;li&gt;중국 주식시장에서 주가를 봐도 이제는 중국의 AI회사들이 잘 나가고 미국을 앞서고 있다. 중국 5억명이 사용한다는 음성인식 기술을 제공하는 iFlyTek은 비슷한 기술회사인 미국의 Nuance의 시총을 앞섰다. iFlyTek은 이제 11조원이 넘는 규모고 뉴앙스는 5조가 되지 않는다.&lt;/li&gt;
      &lt;li&gt;중국정부는 AI산업을 키우는데 최우선 순위를 두고 밀어주고 있다. 미국은 오바마정권때 2016년 나온 백서이후에는 별다른 얘기가 없는데 중국 정부는 2017년 7월 AI산업발전 계획을 발표하고 19회 공산당대회에서 시진핑 주석이 구체적인 계획을 밝혔다.&lt;/li&gt;
      &lt;li&gt;중국정부는 이미 훌륭한 성공사례가 있다. 2010년 세계최대규모의 고속철도 시스템을 만들겠다는 목표를 정했는데 2016년에 2595대의 열차로 전세계 고속철의 60% 이상을 점유하는 실적을 올렸다.&lt;/li&gt;
      &lt;li&gt;무엇보다도 중국정부는 기술친화적(Pro-Tech)이다. 알리바바가 처음 나왔을때 말이 많았다. 세금문제는 어떻게 하냐. 알리바바가 금융을 할 수 있냐 등등. 그런데 정부는 성장하도록 놔두었다. 새로운 기술이 나오면 정부는 정책을 써서 규제하기 보다 어느 정도 성장할때까지 놔두었다가 그 다음에 규제를 고려한다.&lt;/li&gt;
      &lt;li&gt;그리고 중국정부는 빠른 실험에 우호적이다. 다른 나라에서는 도덕적 문제나 형평성 문제, 프라이버시 문제 등을 먼저 따진다. 하지만 중국에서는 일단 제품을 만들어서 해본다. 해보고 나서 어떤 문제가 나오면 그 데이터를 가지고 고쳐나간다. 이런 방법이 옳다 그르다는 가치판단은 여기서 하지 않겠다. 중국에서는 그렇게 한다는 팩트만 이야기하는 것이다.&lt;/li&gt;
      &lt;li&gt;그래서 결론적으로 말하면 인공지능시대에 중국과 미국의 양강시대는 피할 수 없는 것이 아니라 이미 그렇게 됐다고 말하고 싶다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;중국의 Geely 회장 리슈푸가 독일의 다임러 지분 9.69%를 약 10조원을 들여 사들였다고. 
최대주주로 부상. https://www.reuters.com/…/geely-chairman-builds-9-billion-s…
길리는 스웨덴 볼보를 인수한 회사. 저 자금력은 도대체 어디서… 이제 벤츠도 중국브랜드로 만드려는 것인가. 
중국의 야심이 정말 무섭다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;중국이 제조업이 강한 독일회사들을 사들이는데 큰 관심을 보이고 있다는 독일다큐멘터리를 본 일이 있음.
    &lt;ul&gt;
      &lt;li&gt;https://youtu.be/G3F-0C7bTbc&lt;/li&gt;
      &lt;li&gt;독일인들도 경계하고 있는데 이번 Geely의 다임러 지분인수를 보면 확실히 
중국회사들의 독일회사에 대한 욕심이 큰 것으로 보임. 
중국회사들이 인수했다가 갑자기 철수하거나 하면 고용안정성은 어떻게 되느냐고 
우려하는 독일 근로자들의 말이 나오는데 우리의 상황이 오버랩.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;“글로벌인재 유턴땐 10억원 지원”…中 ‘천인계획’ 위력 http://news.mk.co.kr/newsRead.php…
    &lt;ul&gt;
      &lt;li&gt;정부지원으로 해외에서 박사를 한 중국인재를 귀국시키는 계획. 2014년까지는 저조한 성과, 
그런데 최근 몇년간 지원자가 몰리며 성과를 내고 있다고. 
그런데 중국은 이미 민간의 인재영입이 뜨거워서 정부지원이 필요한 단계는 지난 것 같음.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>nicewoong</name></author><category term="china" /><category term="AI" /><category term="ICT" /><category term="thoughts" /><summary type="html">중국, 무섭다! 미, 중 인공지능 양강시대.</summary></entry><entry><title type="html">Cassandra(카산드라) 내부 구조</title><link href="http://nicewoong.github.io/development/2018/02/11/cassandra-internal/" rel="alternate" type="text/html" title="Cassandra(카산드라) 내부 구조" /><published>2018-02-11T12:00:00+00:00</published><updated>2018-02-11T12:00:00+00:00</updated><id>http://nicewoong.github.io/development/2018/02/11/cassandra-internal</id><content type="html" xml:base="http://nicewoong.github.io/development/2018/02/11/cassandra-internal/">&lt;h1 id=&quot;cassandra-내부적으로-read--write-는-어떻게-작동하는지-알아보자&quot;&gt;Cassandra 내부적으로 Read / Write 는 어떻게 작동하는지 알아보자.&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;칼럼 단위로 TimeStamp가 있다는 걸 인지하고 시작합시다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; {
  name: &quot;userName&quot;,
  value: &quot;Dave Jones&quot;,
  timestamp: 125555555 
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;storage-engine&quot;&gt;Storage Engine&lt;/h2&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;일반적인 DB에서 쓰이는 &lt;code class=&quot;highlighter-rouge&quot;&gt;B-Tree&lt;/code&gt; 대신 Cassandra 에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Log-Structured Merge Tree (LSM Tree)&lt;/code&gt; 를 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;log-structured-merge-tree-lsm-tree&quot;&gt;&lt;strong&gt;Log-Structured Merge Tree (LSM Tree)&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;주로 RDBMS에서 사용 되고 있는 B+Tree와 비교해서 &lt;strong&gt;쓰기(Write) 성능&lt;/strong&gt;이 우수하다는 특징을 가지고 있다.&lt;/li&gt;
  &lt;li&gt;현대의 Store에 많이 사용되는 자료구조 &lt;strong&gt;(BigTable, Cassandra, HBase, Riak, … )&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MemTable&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;SSTable&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Commit Log&lt;/code&gt;라는 3개의 저장 공간을 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;sstablesorted-string-table&quot;&gt;&lt;strong&gt;SSTable(Sorted String Table)&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MemTable&lt;/code&gt;이 가득 차게 되면, 디스크에 &lt;code class=&quot;highlighter-rouge&quot;&gt;SSTable&lt;/code&gt;을 생성&lt;/li&gt;
  &lt;li&gt;변하지 않는(immutable) 파일&lt;/li&gt;
  &lt;li&gt;내부 데이터는 &lt;strong&gt;key&lt;/strong&gt;를 기준으로 정렬 되어짐&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Index block&lt;/code&gt;을 배치하여 원하는 block을 &lt;strong&gt;이진탐색&lt;/strong&gt;으로 검색&lt;/li&gt;
  &lt;li&gt;Bloomfilter 지원&lt;/li&gt;
  &lt;li&gt;여러 SSTable을 합(compaction) 할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;bloomfilter-란&quot;&gt;&lt;strong&gt;Bloomfilter 란?&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;(참고) - &lt;a href=&quot;http://d2.naver.com/helloworld/749531&quot;&gt;Bloomfilter 란?(Naver D2 블로그) &lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;(참고) - &lt;a href=&quot;http://www.mimul.com/pebble/default/2012/03/30/1333089490367.html&quot;&gt;Bloom Filter 개요(개인 블로그 글)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Bloom Filter는 어떤 원소 bloomfilter2가 어떤 집합 bloomfilter1의 원소인지 확률적으로 판단하는 표시함수 이다.&lt;/li&gt;
  &lt;li&gt;그러나 Bloom Filter를 이용하여 어떤 원소  bloomfilter2에 대한 membership query를 수행했을 때, 
수행 결과가 ‘참’이라고 해도, 반드시 bloomfilter2가 bloomfilter1에 포함되는 것은 아니다&lt;strong&gt;(false positive)&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;(false positive)&lt;/strong&gt;.
    &lt;ul&gt;
      &lt;li&gt;없다고 하면 확실히 없는 것, 있다고 하면 있을 수도 있고 없을 수도 있다.&lt;/li&gt;
      &lt;li&gt;(참고: false positive : 없는데 있다고 하는 것. false negative : 있는데 없다고 하는 것. )&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;그러나 false positive가 발생하는 경우 데이터베이스를 조회하여 
데이터 존재 여부(원소 포함 여부)를 판단할 수 있기 때문에, 
시스템 전체적으로는 항상 정해를 도출할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;이런 특성 때문에 Bloom Filter는 단독으로 사용하는 것보다는 
확률적인 방법이 아닌 다른 방법을 보조하는 역할로 사용하는 것이 적합&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Bloom Filter의 주목적은 ‘데이터베이스가, 원소(키)가 존재하지 않는다는 것을 파악하는 데 
소모되는 자원의 낭비를 줄이는 것’이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;간략 내용
    &lt;ul&gt;
      &lt;li&gt;bit배열 V가 있다. (0 ~ m-1까지의 index를 가진다)&lt;/li&gt;
      &lt;li&gt;A라는 데이터가 있다&lt;/li&gt;
      &lt;li&gt;여러개(k개)의 hash함수가 있다.&lt;/li&gt;
      &lt;li&gt;A라는 데이터를 k개의 hash 함수에 의해 나오는 k개의 결과가 bit배열 V의 index가 된다.&lt;/li&gt;
      &lt;li&gt;hash를 통해 나오는 결과는 0 ~ (m-1) 까지의 숫자가 되겠다.&lt;/li&gt;
      &lt;li&gt;bit배열 V에서 해당 index에 맞는 자리에 비트가 1로 지정된다.&lt;/li&gt;
      &lt;li&gt;추후 데이터 A가 있는지 검사하기 위해 k개의 hash함수를 통과시키고 나오는 결과 k개를 가지고 
bit배열 V에 해당 index가 1인지 살펴본다.&lt;/li&gt;
      &lt;li&gt;배열V의 index 자리 비트가 모두 1이라면 A라는 데이터가 존재한다. (true를 반환)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;많은 비트를 할당할수록 성능은 좋을 수 있으나 많은 메모리가 필요,&lt;/li&gt;
  &lt;li&gt;해싱 함수를 늘리게 되면 연산이 많아지게 되어 성능은 느리나 메모리를 덜 차지하게 되는 trade-off 관계가 존재한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;b-tree란&quot;&gt;&lt;strong&gt;B-tree란?&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;참고 - &lt;a href=&quot;https://dohkstalks.blogspot.kr/2016/01/b-b-tree.html&quot;&gt;자료구조 :: B-트리(블로그 포스팅)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Balanced Tree&lt;/strong&gt;로 균형을 유지하는 트리를 말한다.&lt;/li&gt;
  &lt;li&gt;B 트리는 자식을 두개만 가질 수 잇는 Binary Search Tree 를 확장하여 더 많은 자식을 가질 수 있게 고안한 것&lt;/li&gt;
  &lt;li&gt;오라클과 같은 상용 DB에서 많이 사용하는 자료구조&lt;/li&gt;
  &lt;li&gt;외부 검색(주 저장장치인 메모리 외의 저장장치에서의 검색)에 유용하다.&lt;/li&gt;
  &lt;li&gt;Binary Tree같은 경우 한 쪽으로 치우치는 구조가 되면 연산의 시간복잡도가 O(NxLogN) 최악의경우 -&amp;gt; O(NxN) 이 나온다 
(데이터가 Sorting되어 입력될 경우 밸런스가 안 맞음)&lt;/li&gt;
  &lt;li&gt;하나의 노드가 여러 데이터를 가진다.&lt;/li&gt;
  &lt;li&gt;한 노드에 최대 M개의 자료가 배치될 수 있으면 M차 B트리라고 한다.&lt;/li&gt;
  &lt;li&gt;노드내의 데이터는 반드시 정렬된 상태여야 한다.&lt;/li&gt;
  &lt;li&gt;노드의 데이터 왼쪽에 연결된 노드에 있는 모든 데이터는 더 작다. 오른쪽에 연결된 노드에 있는 모든 데이터는 더 크다.&lt;/li&gt;
  &lt;li&gt;하나의 노드가 가지는 데이터 갯수가 많을 수록 트리의 높이가 낮아진다. 탐색 시간이 줄어든다.&lt;/li&gt;
  &lt;li&gt;항상 O(logm N)의 성능을 보장한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;쓰기-구조-how-is-data-written&quot;&gt;쓰기 구조 (How is data written)&lt;/h2&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Coordinator 노드&lt;/code&gt; :  요청을 받게 되는 최초의 노드
    &lt;ul&gt;
      &lt;li&gt;(참고) - http://meetup.toast.com/posts/60&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Coordinator&lt;/code&gt;는 해당 데이터의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Row key&lt;/code&gt;를 hashing하여 어느 노드들에 데이터를 Write해야 하는지 확인합니다.&lt;/li&gt;
      &lt;li&gt;해당 쿼리에 지정된 &lt;code class=&quot;highlighter-rouge&quot;&gt;Consistency Level&lt;/code&gt;에 따라 몇 개의 노드에 Write해야하는지 참고하여 
현재의 데이터를 Write해야 할 노드들의 status가 정상인지를 확인&lt;/li&gt;
      &lt;li&gt;특정 노드의 status가 정상이 아니라면 Consistency Level에 따라 &lt;code class=&quot;highlighter-rouge&quot;&gt;hint hand off&lt;/code&gt;라는 로컬 &lt;strong&gt;임시&lt;/strong&gt;
저장공간에 Write 할 데이터를 저장&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hint hand off&lt;/code&gt;에 데이터를 백업했다면, 
Coordinator 노드는 Cassandra의 topology를 확인하여 어느 데이터 센터의 어느 &lt;code class=&quot;highlighter-rouge&quot;&gt;렉&lt;/code&gt;에 있는 노드에
먼저 접근 할 것인지 결정하여 데이터와 함께 Write를 요청&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실제로 데이터 저장하게 될 &lt;code class=&quot;highlighter-rouge&quot;&gt;노드 내&lt;/code&gt;에서는,
    &lt;ul&gt;
      &lt;li&gt;Write 요청이 오면 혹시 모를 장애에 대비하여, &lt;code class=&quot;highlighter-rouge&quot;&gt;CommitLog&lt;/code&gt;라고 불리는 로컬 &lt;strong&gt;디스크의 파일&lt;/strong&gt;에 기록&lt;/li&gt;
      &lt;li&gt;그 다음 &lt;code class=&quot;highlighter-rouge&quot;&gt;MemTable&lt;/code&gt;이라는 이름의 &lt;strong&gt;메모리&lt;/strong&gt; 저장공간에 데이터를 Write한 뒤, 
성공 메시지를 돌려줌으로써 Write 요청에 대한 동작은 마무리&lt;/li&gt;
      &lt;li&gt;(MemTable은 임시저장공간입니다.)&lt;/li&gt;
      &lt;li&gt;MemTable에 데이터가 충분히 쌓이면 &lt;strong&gt;디스크&lt;/strong&gt; 버전의 MemTable이라고 할 수 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;SSTable&lt;/code&gt;에 데이터를 Flush합니다.&lt;/li&gt;
      &lt;li&gt;(SSTable은 Immutable 합니다.)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.datastax.com/en/cassandra/3.0/cassandra/dml/dmlHowDataWritten.html#dmlHowDataWritten__bloomfilter&quot;&gt;공식 Document (Datastax)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;logging-writes-and-memtable-storage&quot;&gt;Logging writes and memtable storage&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;카산드라는 write 할 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;Memtable&lt;/code&gt; 이라는 memory structure에 저장한다.&lt;/li&gt;
  &lt;li&gt;그리고 configurable durability 를 제고하기위해 disk 의 commit log 에 write operation을 추가한다.&lt;/li&gt;
  &lt;li&gt;commit log 는 카산드라 노드에 요청되는 모든 write을 기록한다.&lt;/li&gt;
  &lt;li&gt;이 durable writes 는 전원이 다운되더라도 영구적으로 유지된다.&lt;/li&gt;
  &lt;li&gt;The memtable is a &lt;code class=&quot;highlighter-rouge&quot;&gt;write-back cache&lt;/code&gt; of data partitions that Cassandra looks up by key.&lt;/li&gt;
  &lt;li&gt;Memtable은 (configurable) limit에 달할때 까지 writes이 &lt;strong&gt;정렬되어 저장&lt;/strong&gt;된다.&lt;/li&gt;
  &lt;li&gt;limit에 꽉차면 SSTable로 flushed된다.&lt;/li&gt;
  &lt;li&gt;(참고) - &lt;a href=&quot;file:///Users/woongbook/Downloads/Write%20Through%20Vs%20Write%20Back.pdf&quot;&gt;Write back / Write through cache &lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Wirte-Through&lt;/strong&gt;는 cache에 데이터를 쓰는 동시에 메모리에도 저장하는 방식 (안정적이지만 느리다)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Write-Back&lt;/strong&gt;은 일단 cache만 데이터를 업데이트하고 추후 cache를 비워내면서 
한 번에 메모리또는 디스크로 데이터를 저장한다. (빠르지만 무결성에 문제가 있을 위험).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;(참고) - &lt;a href=&quot;https://wiki.apache.org/cassandra/Durability&quot;&gt;Durability &lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;Durability 는 write이 완료되면 서버가 다운되더라도 &lt;strong&gt;영구적으로 유지되는 속성&lt;/strong&gt;.&lt;/li&gt;
      &lt;li&gt;이를 위한 방법은 매번 write이 일어날 때마다 permanent storage device 에 fsync 해주는 것인데, 
Physical Platter의 write location 에 쓰기 위해서는 disk가 random seek을 해야되기 때문에 매우 느리다. 
(각 seek 은 5-10ms 가 소요된다.)&lt;/li&gt;
      &lt;li&gt;그래서 다른 modern system 과 마찬가지로  카산드라는, 
Commit log 에 먼저 write 을 추가하면서 Durability를 제공한다.&lt;/li&gt;
      &lt;li&gt;Commit log는 append only 이므로 seeking 이 필요없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;flushing-data-from-the-memtable&quot;&gt;Flushing data from the memtable&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;flush 과정에서 data가 Memtable에서 정렬된 그대로 (memtable-sorted order) disk에(&lt;code class=&quot;highlighter-rouge&quot;&gt;SStable에&lt;/code&gt;) 쓰인다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Token&lt;/code&gt;을 디스크의 위치에 매핑하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;partition index&lt;/code&gt; (디스크에 저장되는 자료구조) 도 
함께 디스크에 생성된다.&lt;/li&gt;
  &lt;li&gt;이 토큰을 말하는건지? - &lt;a href=&quot;[https://www.quora.com/What-is-a-token-in-Cassandra&quot;&gt;What-is-a-token-in-Cassandra&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Commit log 공간이 설정한 용량을 초과하거나, memtable을 설정한 한계를 넘어서면 
the memtable is put in a queue that is flushed to disk.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;커밋 로그(CommitLog)&lt;/code&gt;의 데이터는 &lt;code class=&quot;highlighter-rouge&quot;&gt;memtable&lt;/code&gt;의 해당 데이터가 디스크의 &lt;code class=&quot;highlighter-rouge&quot;&gt;SSTable&lt;/code&gt;로 플러시 된 후에 제거된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;storing-data-on-disk-in-sstables-sorted-string-table-&quot;&gt;Storing data on disk in SSTables (Sorted String Table )&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;테이블 마다 &lt;code class=&quot;highlighter-rouge&quot;&gt;Memtables&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;SSTables&lt;/code&gt;가 유지된다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Commit Log&lt;/code&gt;는 테이블간 공유된다.&lt;/li&gt;
  &lt;li&gt;SSTables는 변경 불가능하며, memtable이 플러시 된 후에 다시 쓰여지지 않습니다.&lt;/li&gt;
  &lt;li&gt;결과적으로 Partition은 일반적으로 여러개의 SSTable에 저장된다.&lt;/li&gt;
  &lt;li&gt;그리고 여러개의 Structure가 읽기(Read) 를 돕기 위해 존재한다.
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;데이터 (Data.db)&lt;/strong&gt;: SSTable 데이터&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Primary Index (Index.db)&lt;/strong&gt; : 데이터 파일의 위치에 대한 포인터가있는 Row key 의 index&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Bloom filter (Filter.db)&lt;/strong&gt; : 디스크의 SSTables에 액세스하기 전에 Row데이터가 memtable(메모리)에 있는지 확인하는 메모리에 저장된 구조&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Compression Information (CompressionInfo.db)&lt;/strong&gt; : 압축되지 않은 데이터 길이, 청크 오프셋 및 기타 압축 정보에 대한 정보가 들어있는 파일&lt;/li&gt;
      &lt;li&gt;**Statistics (Statistics.db) **: SSTable의 내용에 대한 통계 메타 데이터&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Digest (Digest.crc32, Digest.adler32, Digest.sha1)&lt;/strong&gt; : 데이터 파일의 adler32 체크섬을 보관하는 파일&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;CRC (CRC.db)&lt;/strong&gt;; 압축되지 않은 파일에 청크 용 CRC32가 들어있는 파일입니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;SSTable Index Summary (SUMMARY.db)&lt;/strong&gt; : 메모리에 저장되어 있는 A sample of the partition index&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;SSTable Table of Contents (TOC.txt)&lt;/strong&gt; : SSTable TOC의 모든 구성 요소 목록을 저장하는 파일&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Secondary Index&lt;/strong&gt; (SI_.*.db) : 기본 제공 보조 색인. SSTable 당 여러 개의 Secondary Index 가있을 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SSTable&lt;/code&gt;은 디스크에 저장되는 File 이다.&lt;/li&gt;
  &lt;li&gt;data files은 &lt;code class=&quot;highlighter-rouge&quot;&gt;data directory&lt;/code&gt;에 저장된다.&lt;/li&gt;
  &lt;li&gt;data directory 안에 Key-Space 마다 directory를 가지며 해당 directory에 각 table을 저장한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/data/data/keyspace1/table1-5be396077b811e3a3ab9dc4b9ac088d/la-1-big-Data.db
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;keyspace1 은 Keyspace name 이다.&lt;/li&gt;
      &lt;li&gt;A hexadecimal string, 5be396077b811e3a3ab9dc4b9ac088d in this example, is appended to table names to represent unique table IDs.&lt;/li&gt;
      &lt;li&gt;카산드라는 각 테이블에 대하여 하위 디렉토리를 생성하여 [a chosen physical drive or data volume] 에 테이블을 Symlink할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;데이터-유지how-is-data-maintained-&quot;&gt;데이터 유지(How is data maintained? )&lt;/h2&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.datastax.com/en/cassandra/3.0/cassandra/dml/dmlHowDataMaintain.html&quot;&gt;참고 - (Datastax, Compaction과정이 설명되어 있다. )&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Write을 할 때 SSTables 라고 불리는 file에 데이터를 저장한다.&lt;/li&gt;
  &lt;li&gt;SSTables are immutable.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;inserts&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;updates&lt;/code&gt;로 기존에 존재하는 row에 overwrite 하는 대신, 
카산드라는 새로운 &lt;code class=&quot;highlighter-rouge&quot;&gt;timestampe&lt;/code&gt;를 가지는 버전의 updated 데이터를  new SSTables에 추가한다.&lt;/li&gt;
  &lt;li&gt;카산드라는 deleted 데이터를 제거하지 않고,
&lt;code class=&quot;highlighter-rouge&quot;&gt;Tombstone&lt;/code&gt;로 표시한다.
    &lt;ul&gt;
      &lt;li&gt;(Tombstone : A marker in a row that indicates a column was deleted. During compaction, marked columns are deleted.)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이렇게 시간이 지남에 따라 카산드라는 &lt;strong&gt;여러 버전의 row를&lt;/strong&gt; 추가하게 된다.&lt;/li&gt;
  &lt;li&gt;Each version may have a unique set of columns stored with a different timestamp.&lt;/li&gt;
  &lt;li&gt;SSTable이 누적될 때 마다, Complete row를 조회하기 위해서는 더 많은 SSTable에 분산된 데이터에 엑세스가 필요하다.&lt;/li&gt;
  &lt;li&gt;데이터베이스를 정상적인 상태로 유지하기 위해 Cassandra는 주기적으로 SSTable을 병합하고 이전 데이터를 버립니다.&lt;/li&gt;
  &lt;li&gt;이 프로세스를 &lt;code class=&quot;highlighter-rouge&quot;&gt;Compaction&lt;/code&gt; 이라고합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;compaction&quot;&gt;Compaction&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Compaction&lt;/code&gt;은 ```SSTable`` 간에 일어납니다.&lt;/li&gt;
  &lt;li&gt;Compaction은 Unique Row에 대한 모든 version을 모두 모아서 하나의 Complete row로 assemble합니다.&lt;/li&gt;
  &lt;li&gt;각 Row의 Column마다 갖고있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;timestamp&lt;/code&gt;를 이용해서 가장 최신버전의 것으로 말이죠.&lt;/li&gt;
  &lt;li&gt;merge process는 효율적입니다.
    &lt;ul&gt;
      &lt;li&gt;왜냐면 각 row는  &lt;code class=&quot;highlighter-rouge&quot;&gt;Partition key&lt;/code&gt;에 의해 각 &lt;code class=&quot;highlighter-rouge&quot;&gt;SSTable&lt;/code&gt;에 &lt;strong&gt;정렬된 상태&lt;/strong&gt;로 저장되어있고,&lt;/li&gt;
      &lt;li&gt;Merge 과정은 Random I/o를 사용하지 않기 때문이죠.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이렇게 새로운 version의 Row가 조합되어 새로운 SSTable에 저장됩니다.&lt;/li&gt;
  &lt;li&gt;Old version의 row들은 old SSTable에 남아있고,&lt;/li&gt;
  &lt;li&gt;pending reads(이전에 요청되어 처리중인?대기중인? read 작업을 말하는 것 같음)가 완료되자마자 모두 삭제됩니다.&lt;/li&gt;
  &lt;li&gt;이과정은 일시적으로 Disk space usage 와 disk I/O에 Spike를 발생시킵니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;merge가 완료되자마자 old version의 SSTable 가 차지하던 공간을 확보합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;모든 Compaction 과정이 끝나기 전이라도, Cassandra는 기다리지 않고 새로운 SSTable에서 read를 할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;As Cassandra processes writes and reads, it replaces the old SSTables with new SSTables in the page cache&lt;/li&gt;
  &lt;li&gt;The process of caching the new SSTable, while directing reads away from the old one, is incremental 
it does not cause a the dramatic cache miss.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;삭제-구조-how-is-data-deleted&quot;&gt;삭제 구조 (How is data deleted)&lt;/h2&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;카산드라는 &lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;insert&lt;/code&gt;로 간주합니다.&lt;/li&gt;
  &lt;li&gt;DELETE 명령어로 추가된 데이터는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Tombstone&lt;/code&gt; 이라고 불리는 deletion marker이다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Write&lt;/code&gt;과 같은 방식으로 SSTable 에 추가된다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tombstone&lt;/code&gt;은 Built-in expiration data/time을 가진다.
    &lt;ul&gt;
      &lt;li&gt;expiration 기간이 만기되면  SSTable의 Normal compaction process 과정에서 삭제된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Cassandra record(row또는 Column)를 TTL(time) value를 설정할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;지정해둔 시간이 끝나면 tombstone 마크가 record에 표시된다.&lt;/li&gt;
      &lt;li&gt;이 역시  compaction과정에서 삭제된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;멀티노드 클러스터에서 카산드라는 replica를 다른 노드에 저장이 가능하다.&lt;/li&gt;
  &lt;li&gt;이는 데이터 손실을 예방하지만, Delete를 복잡하게한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;읽기-구조-how-is-data-read&quot;&gt;읽기 구조 (How is data read)&lt;/h2&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;(참고) - &lt;a href=&quot;https://docs.datastax.com/en/cassandra/3.0/cassandra/dml/dmlAboutReads.html&quot;&gt;How is data read&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ima src=&quot;http://nicewoong.github.io/assets/cassandra_caching-reads_12&quot; alt=&quot;cassandra_cahching-reads_12.png&quot; /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Read&lt;/code&gt; 요청이 들어오면 먼저 key 갑을 이용해서 생성된 Hash값을 기반으로 
Cluster Ring 내에 데이터가 저장된 노드를 찾습니다.&lt;/li&gt;
  &lt;li&gt;데이터를 해당 노드로부터 읽어옵니다.&lt;/li&gt;
  &lt;li&gt;복제된 다른 노드로 부터도 데이타를 읽어 옵니다.&lt;/li&gt;
  &lt;li&gt;각 레플리케이션에서 읽어온 값들을 &lt;strong&gt;비교&lt;/strong&gt;합니다.&lt;/li&gt;
  &lt;li&gt;그리고 그 값이 다르다면 최신 값을 반환해줍니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;노드 내&lt;/code&gt;에서는
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MemTable&lt;/code&gt;에 데이터가 있으면 바로 리턴&lt;/li&gt;
      &lt;li&gt;MemTable에 없으면 디스크의 &lt;code class=&quot;highlighter-rouge&quot;&gt;SSTable&lt;/code&gt; 을 확인&lt;/li&gt;
      &lt;li&gt;SSTable내의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bloom Filter&lt;/code&gt; 에서 해당 데이터의 유무 정보를 얻을 수 있다.&lt;/li&gt;
      &lt;li&gt;Bloom Filter 가 해당 데이터의 존재를 알려주면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index File&lt;/code&gt; 에서 그 위치를 얻고&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Data File&lt;/code&gt;에서 해당 위치의 데이터를 읽어서 반환한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Read 요청에 대해 카산드라는 Active Memtable의 결과와 여러개의 SSTable(디스크)의 결과를 합칩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Memtable부터 SSTable까지 몇 단계를 거쳐서 데이터를 읽는 과정을 거칩니다.
    &lt;ul&gt;
      &lt;li&gt;Memtable 을 먼저 체크합니다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;row cache&lt;/code&gt;를 확인합니다. (if enabled)&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Bloom filter&lt;/code&gt;를 체크합니다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;partition key cache&lt;/code&gt;를 확인합니다.( if enabled)&lt;/li&gt;
      &lt;li&gt;partition key cache 에서 partition key를 찾으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;compression offset map&lt;/code&gt;으로 갑니다.&lt;/li&gt;
      &lt;li&gt;partition key를 못 찾았다면,  &lt;code class=&quot;highlighter-rouge&quot;&gt;partition summary(memory)&lt;/code&gt;를 확인해봅니다.&lt;/li&gt;
      &lt;li&gt;그리고 나서 &lt;code class=&quot;highlighter-rouge&quot;&gt;partition index(disk)&lt;/code&gt;를 거쳐서 &lt;code class=&quot;highlighter-rouge&quot;&gt;compression offset map(memory)&lt;/code&gt; 으로 갑니다.&lt;/li&gt;
      &lt;li&gt;compression offset map을 이용해서 디스크에 데이터가 위치한 곳으로 접근합니다.&lt;/li&gt;
      &lt;li&gt;해당  SSTable로부터 데이터를 리턴합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;각-컴포넌트에-대해-좀-더-자세히-알아보자&quot;&gt;각 컴포넌트에 대해 좀 더 자세히 알아보자.&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;memtable&quot;&gt;memtable&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;memtable 에 데이터가 있으면 가져와서 SSTable에서 가져온 데이터와 merge된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;row-cache&quot;&gt;Row Cache&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Read는 대부분의 in-demand 데이터가 메모리에 위치할 때 가장 빠르다.&lt;/li&gt;
  &lt;li&gt;row cache는 95%의 load가 read 인 &lt;code class=&quot;highlighter-rouge&quot;&gt;read-intensive operation&lt;/code&gt;에서 성능향상을 제공한다.&lt;/li&gt;
  &lt;li&gt;row cache가 enable 되어있을 경우 SSTable의 partition data의 일부분(subset)을 메모리에 저장합니다.&lt;/li&gt;
  &lt;li&gt;Off-heap에 저장되어 JVM의 garbage collection 의 관리대상이 아닙니다.
    &lt;ul&gt;
      &lt;li&gt;(참고) - &lt;a href=&quot;https://stackoverflow.com/questions/6091615/difference-between-on-heap-and-off-heap&quot;&gt;Off-heap/ On-heap&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;캐쉬가 가득차면 Row Cache는 LRU (least-recently-used) Eviction을 수행하여 메모리공간을 확보합니다.&lt;/li&gt;
  &lt;li&gt;Row cache 사이즈와 row 갯수는 설정가능합니다&lt;/li&gt;
  &lt;li&gt;Row Cache가 enable 되어 있으면 원하는 데이터는 row cache로 부터 read 합니다.&lt;/li&gt;
  &lt;li&gt;Row cache에 저장되는 row는 자주 엑세스 되는 row입니다.  SSTable에 엑세스 될 때 merge되어 저장된 것들 입니다.&lt;/li&gt;
  &lt;li&gt;데이터가 row cache에 저장된 후, 이후의 쿼리에 의해 또 접근될 수 있습니다.&lt;/li&gt;
  &lt;li&gt;row cache는 write-through 가 아닙니다.&lt;/li&gt;
  &lt;li&gt;해당 row에 대해서 write 요청이 들어오면 해당 row에 대한 cache는 유효하지 않습니다.&lt;/li&gt;
  &lt;li&gt;그리고row가 다음 read가 될때까지 캐쉬되지 않습니다.&lt;/li&gt;
  &lt;li&gt;마찬가지로 partition이 업데이트 되면 partion 전체가 cache에서 제거됩니다.&lt;/li&gt;
  &lt;li&gt;원하는 데이터가 Row Cache에 없으면 bloom filter를 확인하는 단계가 진행됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;boom-filter&quot;&gt;Boom Filter&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;먼저, Cassandra는 Bloom 필터를 검사하여 어떤 SSTables가 요청 데이터를 가질 가능성이 있는지를 확인합니다.&lt;/li&gt;
  &lt;li&gt;Boom Filter는 off-heap memory 에 저장됩니다.&lt;/li&gt;
  &lt;li&gt;각각의 SSTable에 연관된 bloom filter가 있습니다.&lt;/li&gt;
  &lt;li&gt;Bloom 필터는 확률 적 기능이기 false positive 가  발생할 수 있습니다. (없는데 있다고 함)&lt;/li&gt;
  &lt;li&gt;If the Bloom filter does not rule out an SSTable, Cassandra checks the partition key cache&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;partition-key-cache&quot;&gt;Partition Key Cache&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Partition Key Cache 가 enable 되어 있으면 off-heap memory에 partition index를 캐쉬에 저장합니다.&lt;/li&gt;
  &lt;li&gt;Key Cache 는 작은 공간을 차지합니다.&lt;/li&gt;
  &lt;li&gt;Partition Key가 Partition Key Cache에 있으면 compression offset map 으로 바로 가서 데이터가 저장되있는 디스크 Compressed Block을 찾아봅니다.&lt;/li&gt;
  &lt;li&gt;Partition Key를 Partition Key Cache에서 못 찾으면 partition summary 로 갑니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;partition-summary&quot;&gt;Partition Summary&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Partition Summary는 off-heap in-memory structure 입니다.&lt;/li&gt;
  &lt;li&gt;sampling of the partition index 를 저장합니다.&lt;/li&gt;
  &lt;li&gt;디스크의 partition index는 모든 partition key를 포함하는 반면, Partition Summary는 모든 X key를 샘플링하고, X번째 key의 위치를 index file 에 매핑합니다.&lt;/li&gt;
  &lt;li&gt;만약 Partion Summary가 every 20 keys를 샘플링하도록 설정되었다면, 첫 번째 키의 위치를 SSTable 파일의 시작부분으로 저장합니다. 그리고 20번째 key를 ….뭔소린지 모르겠따…&lt;/li&gt;
  &lt;li&gt;Partition key의 위치를 ​​아는 것만큼 정확하지는 않지만, Partition Summary는 데이터 위치를 찾기 위한 검색을 단축 할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;고정 된 양의 메모리는 index_summary_capacity_in_mb 를 사용하여 설정 할 수 있으며 Default는 힙 크기의 5 %입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;partition-index&quot;&gt;Partition Index&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Partition Index 는 디스크에 있으며, Offset에 매핑되는 모든 Partition Key의 인덱스를 저장합니다.&lt;/li&gt;
  &lt;li&gt;원하는 데이터의 인덱스를 찾으면 compression offset map 으로가서 디스크의 데이터가 저장된 compressed block 을 찾습니다.&lt;/li&gt;
  &lt;li&gt;이렇게 Partition Index 를 거치는 경우 Disk Seek 이 두 번 일어나게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;compression-offset-map&quot;&gt;Compression offset map&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Compression offset map 은 데이터가 저장되어있는 디스크의 정확한 위치를 저장하고 있습니다.&lt;/li&gt;
  &lt;li&gt;off-heap memory 에 저장되어 있습니다.&lt;/li&gt;
  &lt;li&gt;partition key cache 또는 the partition index 에 의해 엑세스 됩니다.&lt;/li&gt;
  &lt;li&gt;Compression offset map 에서 디스크의 정확한 위치를 찾으면 올바른  correct SSTable(s) 에서 원하는 데이터를 가져옵니다.&lt;/li&gt;
  &lt;li&gt;The compression offset map grows to 1-3 GB per terabyte compressed&lt;/li&gt;
  &lt;li&gt;compression offset map이 CPU리소스를 소모하더라도 Compression 은 Default로 enable 되어있다.&lt;/li&gt;
  &lt;li&gt;이는 page cache 를 효율을 높인다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;udate--delete&quot;&gt;Udate / Delete&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;SSTable 은 Immutable 하다.&lt;/li&gt;
  &lt;li&gt;그래서 변경이나 삭제가 불가능&lt;/li&gt;
  &lt;li&gt;Delete의 경우 tombstom 이라는 marking 방식을 이용.&lt;/li&gt;
  &lt;li&gt;해당 record에 Delete Mark를 True로 표기해서 insert한다.&lt;/li&gt;
  &lt;li&gt;그럼 기존의 동일한 record도 남아있고, 해당 record랑 같은 값을 가지면서 Delete Mark 표시된 녀석이 또 하나 추가된 것.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;timestamp를 보고 최신 것이 delete mark 가 돼있다면 해당 record는 삭제된 것으로 간주.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그럼 이것들이 계속 쌓이는 건가!? 저장공간을 차지하는 건가?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Compaction&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;카산드라는 두 개의 SSTable을 병합하면서 삭제된 레코드는 빼고 새로운 SSTable을 생성한다.&lt;/li&gt;
      &lt;li&gt;이렇게 Compaction 후에는 Delete mark 가 표시된 record는 존재하지 않는다.&lt;/li&gt;
      &lt;li&gt;SSTable은 sort된 상태이기 때문에 병합이 빠르다고 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.datastax.com/en/cassandra/3.0/cassandra/dml/dmlManageOndisk.html&quot;&gt;Datastax Official document &lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://teddyma.gitbooks.io/learncassandra/content/model/cql_and_data_structure.html&quot;&gt;CQL &amp;amp; Data Structure&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://books.google.co.kr/books?id=uW-PDAAAQBAJ&amp;amp;pg=PA64&amp;amp;lpg=PA64&amp;amp;dq=cassandra+timestamp&amp;amp;source=bl&amp;amp;ots=588LYGOI1H&amp;amp;sig=0sak--3nipwnp5wANCX7ySJoSX4&amp;amp;hl=ko&amp;amp;sa=X&amp;amp;ved=0ahUKEwiOtb7X87vXAhUCULwKHQDaD8g4HhDoAQgtMAE#v=onepage&amp;amp;q=cassandra%20timestamp&amp;amp;f=false&quot;&gt;Book(The definition guide ..)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>nicewoong</name></author><category term="development" /><category term="cassandra" /><category term="database" /><category term="nosql" /><summary type="html">Cassandra 내부적으로 Read / Write 는 어떻게 작동하는지 알아보자.</summary></entry></feed>