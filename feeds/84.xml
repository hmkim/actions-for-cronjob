<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by elice dev on Medium]]></title>
        <description><![CDATA[Stories by elice dev on Medium]]></description>
        <link>https://medium.com/@futureofdev?source=rss-e4427987f5b------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*HBh-g0QHC4Uicqvtigz1Mw@2x.jpeg</url>
            <title>Stories by elice dev on Medium</title>
            <link>https://medium.com/@futureofdev?source=rss-e4427987f5b------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Sun, 12 May 2019 07:11:37 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@futureofdev" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[반갑습니다^^]]></title>
            <link>https://medium.com/@futureofdev/%EB%B0%98%EA%B0%91%EC%8A%B5%EB%8B%88%EB%8B%A4-29dfbfa81424?source=rss-e4427987f5b------2</link>
            <guid isPermaLink="false">https://medium.com/p/29dfbfa81424</guid>
            <dc:creator><![CDATA[elice dev]]></dc:creator>
            <pubDate>Wed, 20 Jun 2018 15:29:25 GMT</pubDate>
            <atom:updated>2018-06-20T15:29:25.552Z</atom:updated>
            <content:encoded><![CDATA[<p>반갑습니다^^</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=29dfbfa81424" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[네 맞습니다^^]]></title>
            <link>https://medium.com/@futureofdev/%EB%84%A4-%EB%A7%9E%EC%8A%B5%EB%8B%88%EB%8B%A4-ccbd44069abd?source=rss-e4427987f5b------2</link>
            <guid isPermaLink="false">https://medium.com/p/ccbd44069abd</guid>
            <dc:creator><![CDATA[elice dev]]></dc:creator>
            <pubDate>Wed, 09 May 2018 06:47:01 GMT</pubDate>
            <atom:updated>2018-05-09T06:47:01.854Z</atom:updated>
            <content:encoded><![CDATA[<p>네 맞습니다^^</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ccbd44069abd" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[감사합니다^^]]></title>
            <link>https://medium.com/@futureofdev/%EA%B0%90%EC%82%AC%ED%95%A9%EB%8B%88%EB%8B%A4-612f3bf78506?source=rss-e4427987f5b------2</link>
            <guid isPermaLink="false">https://medium.com/p/612f3bf78506</guid>
            <dc:creator><![CDATA[elice dev]]></dc:creator>
            <pubDate>Fri, 27 Apr 2018 11:58:09 GMT</pubDate>
            <atom:updated>2018-04-27T11:58:09.547Z</atom:updated>
            <content:encoded><![CDATA[<p>감사합니다^^</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=612f3bf78506" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Android ConstraintLayout 쉽게 알아가자]]></title>
            <link>https://medium.com/@futureofdev/android-constraintlayout-%EC%89%BD%EA%B2%8C-%EC%95%8C%EC%95%84%EA%B0%80%EC%9E%90-62d2ded79c17?source=rss-e4427987f5b------2</link>
            <guid isPermaLink="false">https://medium.com/p/62d2ded79c17</guid>
            <category><![CDATA[android]]></category>
            <category><![CDATA[android-layout]]></category>
            <category><![CDATA[constraintlayout]]></category>
            <dc:creator><![CDATA[elice dev]]></dc:creator>
            <pubDate>Fri, 27 Apr 2018 09:08:20 GMT</pubDate>
            <atom:updated>2018-04-27T12:08:16.258Z</atom:updated>
            <content:encoded><![CDATA[<p>LinearLayout이나 RelativeLayout을 쓰다보면 ConstraintLayout을 왜쓰면 좋을지 궁금증을 가지게 됩니다. 저도 그랬고, 새로 학습해야해서 잠깐 미뤄뒀는데, 직접 써보니 이게 왠걸, 정말 재미있는 레이아웃입니다.</p><p>ConstraintLayout을 쓰면서 어려웠던 부분 3가지를 설명 드리겠습니다. 제 설명만 들으면 ConstraintLayout 금방쉽게 쓰실 수 있을겁니다.</p><p>먼저, 제가 학습하면서 가장 도움이 되었던 출처를 알려드립니다.</p><p><a href="https://academy.realm.io/kr/posts/constraintlayout-it-can-do-what-now/">안드로이드 ConstraintLayout 개념과 사용법 정복하기 - 개발자 직강</a></p><p>가장 먼저, ConstraintLayout을 쓰기 위해서는 단어를 이해하는게 중요합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*EaMsG-K68lAQ7w4DJi69VA.png" /><figcaption>ConstraintLayout의 배치를 위한 기준값</figcaption></figure><pre>&lt;Button android:id=&quot;@+id/button1&quot; ...<br>         app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt;</pre><p><strong>app:layout_constraintRight_toRightOf=”parent” </strong>이게 무슨 의미일까요. 저는 처음에 이부분부터 헷갈렸습니다. 여기서 단어뜻의 이해가 매우 중요합니다. button1 right의 constraint를 줄건데, 이건 parent의 right다. 라는 의미입니다. 즉, 아래 레이아웃처럼 <em>parent layout의 오른쪽으로 배치를 할거다</em>라는 의미입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/550/1*3-t28GllqL9wzxUQ65RDkw.png" /><figcaption>app:layout_constraintRight_toRightOf=&quot;parent&quot; 을 설정한 button의 모습</figcaption></figure><p>그러면 두번째로 궁금증이 생깁니다. 일렬로 서로 붙어있는 버튼 2개배치하고 싶으면 어떻게 해야할까. 하나의 버튼에는 바로 위처럼 right를 주고, 다른 하나의 버튼에는 left를 설정해주면 될까요? 한번 해보겠습니다.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;<br>  android:layout_width=&quot;match_parent&quot;<br>  android:layout_height=&quot;match_parent&quot;<br>  xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;<br><br>  &lt;Button<br>    android:id=&quot;@+id/button1&quot;<br>    android:layout_width=&quot;wrap_content&quot;<br>    android:layout_height=&quot;wrap_content&quot;<br>    <strong>app:layout_constraintRight_toRightOf=&quot;parent&quot;</strong>/&gt;<br>  <br>  &lt;Button<br>    android:id=&quot;@+id/button2&quot;<br>    android:layout_width=&quot;wrap_content&quot;<br>    android:layout_height=&quot;wrap_content&quot;<br>    <strong>app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</strong>/&gt;<br><br>&lt;/android.support.constraint.ConstraintLayout&gt;</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/558/1*KoE43wCTWHvC9I3OGpqZfg.png" /><figcaption>위의 레이아웃으로 코딩했을 때 모습</figcaption></figure><p>저렇게 두개의 버튼이 떨어져 보이게 됩니다. 그럼 붙이고 싶은데 어떻게 하면 될까요? 여기서 제가 강조하고 싶은 ConstraintLayout Chain에 대해 설명해드리겠습니다. 참고로 더 정확히 설명되어있는 <a href="https://constraintlayout.com/basics/create_chains.html">공식 사이트</a> 알려드릴게요.</p><p>Chain의 단어뜻이 중요합니다. 생각하시는 아래와 같은 체인입니다. 서로가 연결되어있는 것이죠. 동그라미 하나가 뷰 하나라고 생각하시면 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/512/1*AbDO5bf1uRTjzCuCIStejA.png" /></figure><p>저는 button1과 button2를 서로 연결하고 싶습니다. 보다 정확히 말하자면 두개의 버튼이 붙어있었으면 좋겠습니다. 그럼 어떻게 해야할까요?</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;<br>  xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;<br>  android:layout_width=&quot;match_parent&quot;<br>  android:layout_height=&quot;match_parent&quot;&gt;<br><br>  &lt;Button<br>    android:id=&quot;@+id/button1&quot;<br>    android:layout_width=&quot;wrap_content&quot;<br>    android:layout_height=&quot;wrap_content&quot;<br>    app:layout_constraintRight_toRightOf=&quot;parent&quot;<br>    <strong>app:layout_constraintLeft_toRightOf=&quot;@+id/button2&quot;</strong> /&gt;<br><br>  &lt;Button<br>    android:id=&quot;@+id/button2&quot;<br>    android:layout_width=&quot;wrap_content&quot;<br>    android:layout_height=&quot;wrap_content&quot;<br>    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;<br>    <strong>app:layout_constraintRight_toLeftOf=&quot;@id/button1&quot;</strong> /&gt;<br><br>&lt;/android.support.constraint.ConstraintLayout&gt;</pre><p>처음 레이아웃 코드와는 다르게 @id값을 참조하고 있습니다. button1의 왼쪽은 button2의 오른쪽에 있고, button2의 오른쪽은 button1의 왼쪽에 있게 하는 설정값을 준것입니다. 그럼 레이아웃은 어떻게 보일까요?</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/540/1*b1RByMQNiBdxzewW5VwnVw.png" /><figcaption>위의 코드대로 작성한 레이아웃</figcaption></figure><p>실제 가운데 chain 모양이 보이시나요? button1과 2사이에 제가 첨부했던 chain사진과 같은 모양으로 chain이 설정된것을 볼 수 있습니다. 참 디테일하네요!</p><p>저는 근데, 두개의 버튼을 붙이고 싶었습니다. 그러면 의도했던대로 나온 것을 아니네요. 여기서 chainStyle을 알고가셔야 합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Vk3Vu2dzN38yDuhTaecSRA.png" /><figcaption>출처: <a href="https://constraintlayout.com/basics/create_chains.html">공식사이트</a></figcaption></figure><p>설명보다 그림이 훨씬 잘 이해되죠? 3가지 종류의 chain이 있는데, 제가 의도한 붙어있는 버튼을 만들고 싶을때는 3번째 그림처럼 Packed Chain 을 사용하면됩니다.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;<br>  xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;<br>  android:layout_width=&quot;match_parent&quot;<br>  android:layout_height=&quot;match_parent&quot;&gt;<br><br>  &lt;Button<br>    android:id=&quot;@+id/button1&quot;<br>    android:layout_width=&quot;wrap_content&quot;<br>    android:layout_height=&quot;wrap_content&quot;<br>    android:text=&quot;button1&quot;<br>    app:layout_constraintRight_toRightOf=&quot;parent&quot;<br>    app:layout_constraintLeft_toRightOf=&quot;@+id/button2&quot; /&gt;<br><br>  &lt;Button<br>    android:id=&quot;@+id/button2&quot;<br>    android:text=&quot;button2&quot;<br>    android:layout_width=&quot;wrap_content&quot;<br>    android:layout_height=&quot;wrap_content&quot;<br>    <strong>app:layout_constraintHorizontal_chainStyle=&quot;packed&quot;</strong><br>    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;<br>    app:layout_constraintRight_toLeftOf=&quot;@id/button1&quot; /&gt;<br><br>&lt;/android.support.constraint.ConstraintLayout&gt;</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/540/1*WeqqW4I6Cvc16V1ba3mf-Q.png" /><figcaption>위의 코드대로 나타난 레이아웃</figcaption></figure><p>오, 이제 두개의 버튼이 붙었네요. 하지만 가운데로 정렬이 되어있네요. 왜냐하면 각 버튼의 왼쪽과 오른쪽이 parent가 기준이 되고 있기 때문입니다. 이때 왼쪽으로 붙여서 쓸수있는 속성을 알려드릴게요.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;<br>  xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;<br>  android:layout_width=&quot;match_parent&quot;<br>  android:layout_height=&quot;match_parent&quot;&gt;<br><br>  &lt;Button<br>    android:id=&quot;@+id/button1&quot;<br>    android:layout_width=&quot;wrap_content&quot;<br>    android:layout_height=&quot;wrap_content&quot;<br>    android:text=&quot;button1&quot;<br>    app:layout_constraintRight_toRightOf=&quot;parent&quot;<br>    app:layout_constraintLeft_toRightOf=&quot;@+id/button2&quot; /&gt;<br><br>  &lt;Button<br>    android:id=&quot;@+id/button2&quot;<br>    android:text=&quot;button2&quot;<br>    android:layout_width=&quot;wrap_content&quot;<br>    android:layout_height=&quot;wrap_content&quot;<br>    <strong>app:layout_constraintHorizontal_bias=&quot;0&quot;</strong><br>    app:layout_constraintHorizontal_chainStyle=&quot;packed&quot;<br>    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;<br>    app:layout_constraintRight_toLeftOf=&quot;@id/button1&quot; /&gt;<br><br>&lt;/android.support.constraint.ConstraintLayout&gt;</pre><p>app:layout_constraintHorizontal_bias=&quot;0&quot; 만 추가하면 됩니다. default값은 0.5입니다. 그것보다 작으면 왼쪽으로, 크면 오른쪽으로 배치가 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/560/1*p1cqwpoC48zGpWixkBZZFA.png" /><figcaption>app:layout_constraintHorizontal_bias=”0&quot;을 설정한 모습</figcaption></figure><p>자, 어떠신가요. 기본적인 레이아웃 설정은 확실히 이해가 되셨나요? 그럼 마지막 세번째!!! 제가 진짜 소개하고 싶었던, 제가 2일에 걸쳐 삽질했던 내용을 알려드릴게요. 이거 진짜 꿀팁, 초 핵심부분입니다.</p><p>먼저 디자인의 요구사항은 1)왼쪽에 텍스트가 있고, 오른쪽에 이미지가 있는상황, 2) text maxline 은 1줄이고, text가 길어지든 짧아지든 text바로옆에 이미지가 있어야 함/ 예를 들면 아래와 같은 상황이었습니다.(사실 더 복잡했는데, 포인트인 상황만 소개합니다)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*uX5eLesdIBHJtvTX1qIxoQ.png" /><figcaption>문제를 겪었던 예시상황</figcaption></figure><p>사실 이부분은 Linearlayout의 width를 0으로 주고, weight를 설정하는데, 이걸 ConstraintLayout에서는 어떻게 해야할까요? 똑같이 0을 주고 weight를 하면 될까요?</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;<br>  xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;<br>  android:layout_width=&quot;match_parent&quot;<br>  android:layout_height=&quot;match_parent&quot;&gt;<br><br>  &lt;Button<br>    android:id=&quot;@+id/button1&quot;<br>    android:layout_width=&quot;wrap_content&quot;<br>    android:layout_height=&quot;wrap_content&quot;<br>    android:text=&quot;button1&quot;<br>    app:layout_constraintRight_toRightOf=&quot;parent&quot;<br>    app:layout_constraintLeft_toRightOf=&quot;@+id/button2&quot; /&gt;<br><br>  &lt;TextView<br>    android:id=&quot;@+id/button2&quot;<br>    android:text=&quot;button2&quot;<br>    <strong>android:layout_width=&quot;0dp&quot;</strong><br>    <strong>app:layout_constraintHorizontal_weight=&quot;1&quot;</strong><br>    android:layout_height=&quot;wrap_content&quot;<br>    app:layout_constraintHorizontal_bias=&quot;0&quot;<br>    app:layout_constraintHorizontal_chainStyle=&quot;packed&quot;<br>    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;<br>    app:layout_constraintRight_toLeftOf=&quot;@id/button1&quot; /&gt;<br><br>&lt;/android.support.constraint.ConstraintLayout&gt;</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/556/1*4cwniKsecfNvrsfDS5Ocug.png" /></figure><p>전혀 제가 의도한 대로 되지 않네요, 텍스트가 짧은데 버튼은 맨 오른쪽에만 가있는 얄미운 상황입니다.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;<br>  xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;<br>  android:layout_width=&quot;match_parent&quot;<br>  android:layout_height=&quot;match_parent&quot;&gt;<br><br>  &lt;TextView<br>    android:id=&quot;@+id/text1&quot;<br>    android:text=&quot;button2button2button2button2&quot;<br>    <strong>android:layout_width=&quot;wrap_content&quot;</strong><br>    android:layout_height=&quot;wrap_content&quot;<br>    android:maxLines=&quot;1&quot;<br>    <strong>app:layout_constrainedWidth=&quot;true&quot;</strong><br>   <strong> app:layout_constraintHorizontal_weight=&quot;1&quot;<br>    </strong>app:layout_constraintHorizontal_bias=&quot;0&quot;<br>    app:layout_constraintHorizontal_chainStyle=&quot;packed&quot;<br>    app:layout_constraintStart_toStartOf=&quot;parent&quot;<br>    app:layout_constraintEnd_toStartOf=&quot;@id/button1&quot; /&gt;<br><br>  &lt;Button<br>    android:id=&quot;@+id/button1&quot;<br>    android:layout_width=&quot;wrap_content&quot;<br>    android:layout_height=&quot;wrap_content&quot;<br>    android:text=&quot;button1&quot;<br>    app:layout_constraintEnd_toEndOf=&quot;parent&quot;<br>    app:layout_constraintStart_toEndOf=&quot;@id/text1&quot; /&gt;<br><br>&lt;/android.support.constraint.ConstraintLayout&gt;</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/562/1*nUxjQUPknAJnxuEvA-loew.png" /><figcaption>텍스트가 짧아도 오른쪽에 버튼 위치</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/550/1*YIlF4obPPvbCEdTnwhqhrQ.png" /><figcaption>텍스트가 길어도 오른쪽에 버튼이 사라지지 않아요!</figcaption></figure><p>width를 0dp로 설정하고 weight를 1로 설정해도 버튼이 계속 사라지는 문제 가있는데, 이걸 <strong>android:layout_width=”wrap_content”와 app:layout_constrainedWidth=”true” </strong>으로 해결할 수 있습니다. 사실 여기서 더 중요한건 ConstraintLayout 버전입니다. <strong>꼭 최신 1.1.0으로 업데이트 하세요!! (이전 버전인 경우, </strong><em>layout_constraintWidth_default=”wrap” 을 설정)</em></p><p>ConstraintLayout을 사용해본 후기로, <strong>학습난이도</strong>가 꽤 있었다고 생각됩니다. 제가 설명한 속성외에도 정말 다양하게 많거든요. 속성값만 이해해도 충분히 자유자재로 사용하실수 있습니다. 그리고 풍부한 표현식으로 <strong>레이아웃의 유연함</strong>을 더 높였다고 생각됩니다.</p><p>그럼, 다른 레이아웃보다 더 좋을까?에 대한 의문은 제 개인적인 생각보다 <a href="https://academy.realm.io/kr/posts/cool-constraintlayout-droidcon-boston-2017/">다른 참고 사이트</a>를 보시는것도 좋을것 같네요.</p><p>제가 2~3일에 걸쳐 삽질하고 학습한 ConstraintLayout 설명을 마치겠습니다. 제 글을 보고 삽질을 줄이셨으면 좋겠습니다. 영어로 된 사이트들의 설명이 제일 잘되어있었지만, 한글로 기본적인 부분을 쉽게 설명해주는 글을 많이 못본것같아 이렇게 글을 쓰게 되었습니다. 혹시 틀린부분 있다면 알려주세요! 그리고 도움되셨다면 하단에 clap 눌러주세요!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=62d2ded79c17" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Release keyhash — Google app signing]]></title>
            <link>https://medium.com/@futureofdev/release-keyhash-google-app-signing-f010e65cea37?source=rss-e4427987f5b------2</link>
            <guid isPermaLink="false">https://medium.com/p/f010e65cea37</guid>
            <category><![CDATA[google-apps]]></category>
            <category><![CDATA[keyhash]]></category>
            <category><![CDATA[android]]></category>
            <category><![CDATA[singing]]></category>
            <dc:creator><![CDATA[elice dev]]></dc:creator>
            <pubDate>Sun, 18 Mar 2018 11:50:05 GMT</pubDate>
            <atom:updated>2018-03-18T11:50:05.257Z</atom:updated>
            <content:encoded><![CDATA[<p>개발중인 앱에 kakaoLink API를 연동해서 ‘공유하기&#39; 기능을 추가했습니다. 그리고 google app store에 출시를 했는데, 개발자 계정 이메일에 삼성전자로부터 메일이 와있었습니다. 확인해보니 카카오톡 공유하기 클릭 시에, 아래와 같이 토스트 메시지가 나오는것을 캡쳐해서 보내주셨습니다.</p><pre>android keyhash mismatched!<br>check out registered keyhash.</pre><p><a href="https://developers.kakao.com/docs/android#%ED%82%A4%ED%95%B4%EC%8B%9C-%EB%93%B1%EB%A1%9D">카카오 API 가이드</a>로 다시 가보니, 릴리즈 키해시 등록하는 방법이 있었고, terminal로 아래와같이 keyhash를 추출해서 등록했으나 문제는 그대로였습니다.</p><pre>keytool -exportcert -alias &lt;release_key_alias&gt; -keystore &lt;release_keystore_path&gt; | openssl sha1 -binary | openssl base64</pre><p>그런데, 가이드에서 아래와 같은 문구를 발견했습니다.</p><pre>만약 구글 플레이 개발자 콘솔에서 <a href="https://support.google.com/googleplay/android-developer/answer/7384423?hl=ko"><strong>Google play app signing</strong></a> 기능을 활성화시키셨다면 구글 플레이에 앱이 릴리즈되기 전에 <strong>개발자의 로컬 개발 환경에서 릴리즈 키스토어의 시그너쳐가 삭제되고 구글 서버에 저장되어 있는 사이닝키의 시그너쳐로 교체</strong>됩니다. 그렇기 때문에 이 사이닝키로 생성한 키해시 또한 등록해줘야 합니다.</pre><p>앱을 출시할 때, 제가 직접 구글 앱 signing을 사용하도록 동의했던 것을 알게 되었습니다. 구글 앱 서명이란, 업로드 키를 사용하여 앱에 서명합니다. 그런 다음 Google에서 업로드 키 서명을 인증한 후 삭제합니다. 마지막으로 Google에서 내가 제공한 원래 앱 서명 키를 사용하여 앱에 다시 서명하고 사용자에게 앱을 제공합니다.</p><p>그렇기 때문에 로컬 릴리즈 키해시 값 말고도 구글 앱 서명 인증서로부터 keyhash를 추출해서 등록해야합니다. 추출 방법을 소개해드립니다.</p><pre><strong>google play console &gt; 해당 앱 선택 &gt; 메뉴에서 출시관리 &gt; 앱서명 </strong></pre><p>으로 들어가면 SHA-1 hash 값이 있습니다. 터미널로 해당 값으로 추출하는 방법 알려드리겠습니다. ( <a href="https://stackoverflow.com/questions/44355452/google-play-app-signing-key-hash/44448437#44448437">참고URL</a> )</p><p>SHA-1 이33:4E:48:84:19:50:3A:1F:63:A6:0F:F6:A1:C2:31:E5:01:38:55:2E 라고 예를 들면,</p><pre>echo 33:4E:48:84:19:50:3A:1F:63:A6:0F:F6:A1:C2:31:E5:01:38:55:2E | xxd -r -p | openssl base64</pre><p>output이 나오게 됩니다. 앱 출시할때, 구글 앱 서명을 사용한 것을 동의 하셨다면, 페이스북이나 카카오 등 외부 라이브러리 사용시에 위와같이 릴리즈 키해시값을 확인하셔서 등록하시면 되겠습니다. :)</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f010e65cea37" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[버전관리 git 으로 협업하기]]></title>
            <link>https://medium.com/@futureofdev/%EB%B2%84%EC%A0%84%EA%B4%80%EB%A6%AC-git-%EC%9C%BC%EB%A1%9C-%ED%98%91%EC%97%85%ED%95%98%EA%B8%B0-1cb49f88eb4?source=rss-e4427987f5b------2</link>
            <guid isPermaLink="false">https://medium.com/p/1cb49f88eb4</guid>
            <category><![CDATA[android]]></category>
            <category><![CDATA[git]]></category>
            <category><![CDATA[android-studio]]></category>
            <dc:creator><![CDATA[elice dev]]></dc:creator>
            <pubDate>Sun, 07 Jan 2018 05:14:40 GMT</pubDate>
            <atom:updated>2018-01-07T05:20:31.206Z</atom:updated>
            <content:encoded><![CDATA[<p>가끔 혼자서 프로젝트를 개발하다가 git설정을 하지 않은채로 작업중일 때가 있을 수 있습니다. 그러던 중, 버전관리가 필요해지거나 다른사람과 협업을 하기 위해서는 git이 필수입니다. 이번에 소개할 부분은 “<strong>이미 개발 중인”</strong> project가 git이 필요한 경우에 대해 유용한 방법을 소개하고자 합니다.</p><p>먼저, AndroidStudio 메뉴에VCS &gt;Enable Version Control Integration &gt;git으로 설정하면 기존 프로젝트에도 git이 설정된 것입니다. 그 후, class 들이 빨간색으로 변한 것을 볼 수 있습니다. 이는 unstaged file로 아직 git stage에 올라 오지 않은 파일들을 의미합니다.</p><p>이제 github, bitbucket과 같은 버전 관리할 저장소를 정해서 설정하면 됩니다.필자가 예로 소개할것은 bitbucket인데, 먼저 terminal 에서 해당 project path로 이동합니다.</p><p>cd /path/to/your/project 로 이동 후,</p><p>git remote add origin git@bitbucket.org:yourname/projectname.git</p><p>하면 해당 bitbucket으로 git이 설정되었습니다. 이후 unstaged file을 git add . 로 statge 에 올려주고 git commit -m ‘init proejct’ 를 통해 커밋합니다. 이제 git push -u origin master 를 통해 깃 저장소로 push를 완료하면 됩니다.</p><p>필자는 git 저장소를 먼저 만들고 프로젝트를 개발하는데, 간혹 혼자 개발하다가 git설정을 안하고 한적이 있어서 다시 프로젝트를 생성해야하나 했는데 역시 좋은 방법이 있었습니다. 그래서 저와 같은 분들에게 도움이 되었으면 합니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1cb49f88eb4" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[코틀린(Kotlin) CustomView]]></title>
            <link>https://medium.com/@futureofdev/%EC%BD%94%ED%8B%80%EB%A6%B0-kotlin-customview-774e236ca034?source=rss-e4427987f5b------2</link>
            <guid isPermaLink="false">https://medium.com/p/774e236ca034</guid>
            <category><![CDATA[custom-views]]></category>
            <category><![CDATA[android]]></category>
            <category><![CDATA[kotlin]]></category>
            <category><![CDATA[kotlin-beginners]]></category>
            <dc:creator><![CDATA[elice dev]]></dc:creator>
            <pubDate>Sat, 06 Jan 2018 14:06:04 GMT</pubDate>
            <atom:updated>2018-01-09T09:59:26.911Z</atom:updated>
            <content:encoded><![CDATA[<p>custom view를 개발 할 때, 안드로이드 framework에서는 view가 언제, 어떻게 생성되는지를 정의하기 위한 여러개의 constructor 를 필요로 한다. 그래서 View를 상속받는 class는 constructor 를 갖지 않으면 컴파일 에러가 난다. 그래서 아래와 같이 만들 수 있다.</p><pre>public class UserProfileView extends LinearLayout {<br>    public UserProfileView(Context context) {<br>        this(context, null);<br>    }<br><br>    public UserProfileView(Context context, @Nullable AttributeSet attrs) {<br>        this(context, attrs, 0);<br>    }<br><br>    public UserProfileView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {<br>        super(context, attrs, defStyleAttr);<br>    }<br>}</pre><p>위의 코드를 그대로 kotin으로 바꿔보자.</p><pre>class UserProfileView : View {</pre><pre>constructor(context: Context) : this(context, null)</pre><pre>constructor(context: Context, attrs: AttributeSet?) : this(context, attrs, 0)</pre><pre>constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) {</pre><pre>…</pre><pre>   }<br>}</pre><p>this 를 사용해서 같은 클래스 내에서 하나의 생성자만 호출하도록 했다. 하지만 java와 kotlin으로 작성한게 크게 차이는 없어보인다. 그렇지만 kotlin으로는 생성자를 더 간결하게 작성할 수 있는데, @JvmOverloads annotation을 통해서 이를 해결 할 수 있다.</p><pre>class UserProfileView @JvmOverloads <br>constructor(context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : View(context, attrs, defStyleAttr){<br>...<br>}</pre><p>annotation을 통해 3개의 생성자를 모두 작성하지 않아도 깔끔하게 작성할 수 있게 된다. @JvmOverloads 내부 코드를 보면 다음과 같이 설명되어있다.</p><p><em>Instructs the Kotlin compiler to generate overloads for this function that substitute default parameter values.</em></p><p><em>If a method has N parameters and M of which have default values, M overloads are generated: the first one takes N-1 parameters (all but the last one that takes a default value), the second takes N-2 parameters, and so on.</em></p><p>즉, 생성자의 parameter가 기본값으로 대체하도록 컴파일러에 지시한다는 의미이다.</p><p>하지만 TextView와 같은 경우를 커스텀뷰로 개발하게 되면, @JvmOverloads 로 인해서 기본값으로 대체되기 때문에 지정한 style이 적용되지 않는다. 따라서 TextView나 EditText를 customView로 개발하면 annotation을 사용하지 않으며, 아래와 같이 super를 사용하도록 한다.</p><pre>class MyEditText : TextView{</pre><pre>constructor(context: Context) : super(context)<br>constructor(context: Context, attrs: AttributeSet?) : super(context, attrs)<br>constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr)</pre><pre>}</pre><p>그 외에도 코틀린에서는 init{ …} 을 통해서 레이아웃을 inflate할 수 있고, 예를 들어 R.laoyut.item_profile 와 같은 레이아웃자체를 import 함으로써 아래와 같은 view binding을 아래와 같이 별도의 바인딩 없이 작성할 수 있다.</p><pre>//java코드로 작성된 뷰 바인딩<br>ImageView userProfileImage = findViewById(R.id.userProfileImage);<br>userProfileImage.setVisibility(View.GONE);</pre><pre>//코틀린에서는 별도의 바인딩 없이 작성할 수 있다.<br>userProfileImage.visibility = View.GONE</pre><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=774e236ca034" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[번역/Android Architecture Components 소개]]></title>
            <link>https://medium.com/@futureofdev/android-architecture-components%EB%A5%BC-%EC%86%8C%EA%B0%9C%ED%95%A9%EB%8B%88%EB%8B%A4-1-5a142eeb332f?source=rss-e4427987f5b------2</link>
            <guid isPermaLink="false">https://medium.com/p/5a142eeb332f</guid>
            <category><![CDATA[translation]]></category>
            <category><![CDATA[android]]></category>
            <category><![CDATA[architecture-components]]></category>
            <dc:creator><![CDATA[elice dev]]></dc:creator>
            <pubDate>Thu, 28 Dec 2017 09:33:28 GMT</pubDate>
            <atom:updated>2017-12-28T11:40:09.494Z</atom:updated>
            <content:encoded><![CDATA[<blockquote>해당글은 <a href="https://tutsplus.com/authors/tin-megali?_ga=2.22413816.258658837.1514444772-1298509972.1495626067"><strong>Tin Megali</strong></a><strong>이 작성한 글</strong><a href="https://code.tutsplus.com/tutorials/introduction-to-android-architecture--cms-28749"><strong> </strong>Introduction to Android Architecture Components</a><strong>를 일부 번역한 글로, 모든 저작권은 Tin Megali에 있습니다. 번역과 동시에 필자의 의견도 들어가있음을 알립니다.</strong></blockquote><blockquote><strong>*This article is a translated version of </strong><a href="https://tutsplus.com/authors/tin-megali?_ga=2.22413816.258658837.1514444772-1298509972.1495626067"><strong>Tin Megali</strong></a><strong>’s article: </strong><a href="https://code.tutsplus.com/tutorials/introduction-to-android-architecture--cms-28749">Introduction to Android Architecture Components</a><strong>. All rights are with him.</strong></blockquote><p>안드로이드는 2005년 세계적으로 소개되었다.12년 동안 놀라운 성공을 거두며 가장 많이 설치된 모바일 OS가 되었다. 이 기간동안 14가지 버전의 운영체제가 출시되었고, 점점 더 발전했다.</p><p>그러나 플랫폼의 가장 중요한 영역으로, 일반적인 개발자들이 플랫폼의 특성을 이해하고 채택할 수 있을 만큼 심플한 <strong>표준 아키텍처 패턴</strong>은 무시되어왔다.</p><p>그러던 중 지난 구글 I/O에서 안드로이드 팀은 이러한 문제를 해결하기로 결정하고, 전 세계적으로 개발자들에게 피드백을 줬다. Android Application Architecture를 <strong>공식 권장 사항을 발표</strong>하고, 이를 구현할 빌딩 블록으로 새로운 <strong>아키텍처 컴포넌트</strong>를 제공하기로 결정했다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/850/1*e7RIs3boDUibfJJtZsy9Ug.jpeg" /></figure><p>이 튜토리얼에서는 Google I / O에서 안드로이드 팀이 제안한 표준화 된 아키텍처를 살펴보고 Lifecycle, ViewModel, LifeData 및 Room과 같은 새로운 아키텍처 구성 요소의 주요 요소를 살펴보겠다.</p><h3><strong>오래된 실수(Old mistakes)</strong></h3><p>마지막 Google I/O가 있기 전까지는 안드로이드 시스템에서 특정 아키텍처를 권장하지 않았다. 즉, MVP, MVC, MVVM이나 심지어 패턴이 전혀 없는 모델 등 어떠한 것을 선택해도 될만큼 자유로웠다. 게다가 안드로이드 프레임워크는 시스템 자체, 특히 컴포넌트의 수명주기에 의해 생성 된 문제에 대한 <strong>고유 솔루션이 없었다.</strong></p><p>그래서 만약 당신이 MVP패턴을 도입하려하면, 본인만의 솔루션을 만들거나 공식적인 지원 없이 라이브러리를 채택해야 했다. 이러한 <strong>“표준&quot;의 부재</strong>는 유지보수나 테스트가 어려운 코드의 어플리케이션으로 이어졌다.</p><p>필자가 말해왔듯이, 이러한 상황은 수년동안 비난받아왔다. 사실, 나는 이문제에 대해 최근에 적었고 How to Adopt Model View Presenter 를 작성해서 해결책을 적었다. 그러나 가장 중요한 점은 12년 후에, 안드로이드 팀이 마침내 우리의 불만을 들어주고, 돕기로 결정했다는 점이다.</p><h3><strong>Android Architecture</strong></h3><p>새로운 안드로이드 아키텍처 가이드는 좋은 안드로이드 어플리케이션이 따라야할 몇 가지 핵심 원칙을 정의하고, 개발자가 훌륭한 앱을 만들도록 안전한 방법을 제안한다. 그러나 가이드가 제공하는 방법이 의무가 아니며 결정은 개인에게 있다. 즉, 어떠한 종류의 아키텍처를 도입하느냐는 것은 개발자가 결정해야 한다.</p><p>가이드에 따르면, 훌륭한 Android 앱은 <strong>관심사 분리</strong>를 해야하고, 모델로부터 UI를 벗어나도록 해야한다. UI나 운영체제의 상호작용을 핸들링하지 않는 어떠한 코드도 Activity나 Fragment에 있으면 안됩니다. 왜냐하면 Activity나 Fragment를 최대한 클린하게 유지하는 것이 많은 생명주기와 관련된 문제들로부터 벗어날 수 있도록 하기 때문이다. 결국 시스템은 언제든지 Activity나 Fragment를 destroy(생명주기) 할수 있어서 data는 UI로부터 분리된, 결과적으로 생명주기로부터 분리된 <strong>model에 의해서 처리되어야 한다</strong>.</p><h3><strong>새롭게 권장된 아키텍처</strong></h3><p>안드로이드가 권장하는 아키텍처는 우리가 아는 표준적인 패턴으로 쉽게 분류할 수 없다. MVC패턴처럼 보이지만 시스템 아키텍처와 밀접하게 연결되어 있으므로 알려진 convention을 사용하여 각 요소를 분류하기는 어렵다. 가장 중요한 점은, <strong>뛰어난 test가능성과 유지보수</strong>를 제공하는 관심사 분리가 가능한 새로운 아키텍처 컴포넌트가 필요하다는 점이다.</p><p>안드로이드 팀에서 제안한 것을 이해하기 위해서는 Architecture Component의 구성요소를 모두 알아야 한다. 왜냐하면 우리에게 쉬운부분이 아니기 때문이다. Room, ViewModel, LiveData, and Lifecycle 의 4가지 구성요소가 있다. 모든 요소들이 각 역할이 있고, 견고한 아키텍처를 만든다. 좀더 이해하기 쉽도록 다이어그램을 같이 보도록 하자.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/850/1*okKV5_-dxVTcYzqjaUtCtw.jpeg" /><figcaption>Android Architecture Component</figcaption></figure><ol><li>Activity 와Fragment 는 View 계층을 의미한다. 즉, 비즈니스 로직과 복잡한 operation 을 처리하지 않는다. 오직 유저 인터랙션을 다루고, 가장 중요한 점은 ViewModel로부터 LiveData를 관찰하고 표시한다.</li><li>ViewModel 은 안드로이드 생명주기 이벤트와 변경이 일어나는 동안 일관성을 유지하면서 view의 Lifecycle 상태를 자동으로 관찰한다. ViewModel 은 관찰가능한 LiveData 를 제공받는 Repository 로부터 data를 가져오는 것이 요구된다. ViewModel 은 결코 View 를 직접적으로 참조하지 않고, data업데이트는 LiveData 에 의한 것이라는 점을 이해하는 것이 중요하다.</li><li>Repository 는 특별한 Android component가 아니다. 특정적인 구현 없이 간단한 클래스로, database에서 웹 서비스까지 모든 가능한 소스에서 data를 가져오는 역할을 한다. 모든 data를 처리하여 일반적으로 관찰가능한LiveData 로 변환하여 ViewModel 에서 사용할 수 있도록 만든다.</li><li><strong>Room </strong>database는 SQLite 매핑 라이브러리로, database 프로세스 처리를 쉽게 한다. 자동으로 많은 상용구를 작성하고 컴파일 타임에 오류를 검사하며, 무엇보다 중요한 것은 관찰 가능한 <strong>LiveData</strong>가 있는 쿼리를 직접 return할 수 있다는 것이다.</li></ol><p>필자는 우리가 observables(관찰가능한) 에 대해 많이 이야기 한것을 당신이 느꼈을것이라 생각한다. Observer Pattern은 LiveData와 생명주기의 기반 중 하나이다. 이러한 패턴은 상태나 data가 변경될때마다 알려준다. 그래서 Activity가 LiveData를 관찰하면 data의 어떠한 변경이 일어날때마다 업데이트를 수신받게 된다.</p><p>— — — — — — — — — — — — — — — — — — — — — — — — — — — — —</p><blockquote>제가 AAC(Android Architecture Component)에 대해서 많은 글 중에 해당 글을 번역한 이유는 <strong>첫번째로</strong>, 아키텍처 컴포넌트의 탄생 배경에 대해 설명하고 있다는 점과 <strong>두번째로 </strong>AAC에 대해 큰 그림(구조)을 설명하고 있다는 점이 재밌었습니다.</blockquote><blockquote>저는 google github 예제를 따라하면서 느낀점이 “왜 이런 구조인가” 였습니다. 큰 그림을 알지못하면 여러 개념들때문에 코딩하면서도 헷갈릴 수 밖에 없었기 때문입니다.</blockquote><blockquote>그런점에서 가이드를 제시한 article이 도움이 많이 되었고, 저와 같은 시행착오를 겪으실 분들에게 도움이 되었으면 하는 마음에서 번역을 하였습니다. 도움이 되셨다면 <a href="https://tutsplus.com/authors/tin-megali?_ga=2.22413816.258658837.1514444772-1298509972.1495626067"><strong>Tin Megali</strong></a><strong> </strong>원글에 코멘트 + 저에게도 clap 부탁드립니다!</blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5a142eeb332f" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[안드로이드 DataBinding : RecyclerView]]></title>
            <link>https://medium.com/@futureofdev/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-what-is-databinding-recyclerview-e67abb855788?source=rss-e4427987f5b------2</link>
            <guid isPermaLink="false">https://medium.com/p/e67abb855788</guid>
            <category><![CDATA[data-binding]]></category>
            <category><![CDATA[android-data-binding]]></category>
            <category><![CDATA[android]]></category>
            <dc:creator><![CDATA[elice dev]]></dc:creator>
            <pubDate>Sun, 03 Dec 2017 10:54:58 GMT</pubDate>
            <atom:updated>2017-12-03T12:01:00.029Z</atom:updated>
            <content:encoded><![CDATA[<p>데이터바인딩은 애플리케이션 로직과 레이아웃을 바인딩하는 데 필요한 글루 코드를 최소화합니다. 글루코드는 아래 설명으로 대신합니다.</p><p><em>In </em><a href="https://en.wikipedia.org/wiki/Computer_programming"><em>computer programming</em></a><em>, glue code is </em><a href="https://en.wikipedia.org/wiki/Source_code"><em>source code</em></a><em> that serves solely to “adapt” different parts of code that would otherwise be incompatible.</em></p><p>그럼 데이터 바인딩을 시작해보겠습니다. 먼저, app모듈의 build.gradle에 아래 코드만 추가하면 데이터바인딩 빌드환경이 준비된것입니다. 간단하죠?</p><pre>android {<br>    ....<br>    dataBinding {<br>        enabled = true<br>    }<br>}</pre><p><a href="https://www.androidhive.info/2016/01/android-working-with-recycler-view/">https://www.androidhive.info/2016/01/android-working-with-recycler-view/</a> 해당 사이트의 recylcerView 예제를 데이터바인딩으로 바꿔보겠습니다. 가장 먼저, 레이아웃을 바꿀게요.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;<strong>layout</strong> xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;<br>    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;<br>    xmlns:bind=&quot;http://schemas.android.com/tools&quot;&gt;<br><br>    &lt;data&gt;<br><br>        &lt;import type=&quot;android.databinding.ObservableArrayList&quot; /&gt;<br>        &lt;import type=&quot;data.app.databindingtest.Movie&quot; /&gt;<br><br>        &lt;variable<br>            name=&quot;movieList&quot;<br>            type=&quot;ObservableArrayList&amp;lt;Movie&amp;gt;&quot; /&gt;<br>    &lt;/data&gt;<br><br>    &lt;LinearLayout<br>        android:layout_width=&quot;match_parent&quot;<br>        android:layout_height=&quot;match_parent&quot;&gt;<br><br>        &lt;android.support.v7.widget.RecyclerView<br>            android:id=&quot;@+id/recyclerView&quot;<br>            android:layout_width=&quot;match_parent&quot;<br>            android:layout_height=&quot;wrap_content&quot;<br>            app:layoutManager=&quot;LinearLayoutManager&quot;<br>            <strong>bind:item=&quot;@{movieList}&quot;</strong> /&gt;<br><br>    &lt;/LinearLayout&gt;<br><br>&lt;/<strong>layout</strong>&gt;</pre><p>기존의 레이아웃과 다르게 &lt;layout&gt;태그로 감싸고 있어야 뷰에서 바인딩클래스가 생성됩니다. 저는 데이터가 계속 변경될때마다 UI도 자동으로 업데이트 되기 위해서 ObservableArrayList로 선언했습니다. UI에 바인딩되어 있고ObservableArrayList를 통해서 데이터 객체의 속성이 변경되면 UI가 자동으로 업데이트되기 때문입니다. 즉, 데이터가 변경될때마다 데이터를 set할 필요가 없습니다.</p><p>그리고 xml이기 때문에 ObservableArrayList&lt;Movie&gt;에서의 generic형태의 &lt;&gt; 괄호가 &amp;lt;Movie&amp;gt; 로 나타내야 합니다.</p><p>위처럼 레이아웃 수정 후, 빌드하게 되면 아래와 같이 ActivityMainBinding클래스가 생성됩니다. 바인딩은 View 계층 구조에서 한 번 전달하여 ID가 있는 View를 추출하므로 recyclerView = findViewById(R.id.recyclerView); 라고 할필요 없이layout에서 ID 값을 지정한대로 binding.recyclerView로 사용할 수 있습니다.</p><pre><strong>private</strong> ObservableArrayList&lt;Movie&gt; movieList;<br><strong>private</strong> MoviesAdapter mAdapter;<br><br><strong>@Override<br>protected void onCreate</strong>(Bundle savedInstanceState) {<br>    super.onCreate(savedInstanceState);</pre><pre>    ActivityMainBinding binding = DataBindingUtil.<em>setContentView</em>(this, R.layout.<em>activity_main</em>);<br><br>    mAdapter = new MoviesAdapter();<br>    movieList = new ObservableArrayList&lt;&gt;();<br>    <strong>binding.recyclerView.setAdapter(mAdapter);</strong><br>    binding.setMovieList(movieList);<br><br>    prepareMovieData();<br>}</pre><p>레이아웃에서 <strong>bind:item=”@{movieList}” </strong>로 선언한 것에서 알 수 있듯이 어딘가에서 item을 넘겨준다는것을 추측할 수 있습니다. 맞습니다. 이럴때, <strong><em>@BindingAdapter</em></strong>를 사용합니다. 기존에 binding.setMovieList(movieList);를 했기 때문에, movieList 를 참조하고 있고, 리스트에 데이터가 더해지면 @BindingAdapter를 통해 어댑터로 데이터를 set해주는 역할을 합니다.</p><pre><strong>@BindingAdapter(&quot;bind:item&quot;)<br>public static void bindItem</strong>(RecyclerView recyclerView, ObservableArrayList&lt;Movie&gt; movie) {<br>    MoviesAdapter adapter =(MoviesAdapter)recyclerView.getAdapter();<br>    if (adapter != null) {<br>        adapter.setItem(movie);<br>    }<br>}</pre><p>위처럼 adapter로 넘겨진 데이터는 <strong>onCreateViewHolder</strong> 와 <strong>onBindViewHolder</strong> 를 통해 바인딩 됩니다. item_movie_list.xml을 네이밍으로 하였기 때문에 ItemMovieListBinding바인딩 객체가 생성되었습니다.</p><pre>@<strong>Override</strong><br><strong>public MyViewHolder onCreateViewHolder</strong>(ViewGroup parent, int viewType) {<br>    ItemMovieListBinding binding = ItemMovieListBinding.<br>  <em>inflate</em>(LayoutInflater.<em>from</em>(parent.getContext()), parent, false);<br>    return new MyViewHolder(binding);<br>}</pre><pre><strong>@Override<br>public void onBindViewHolder</strong>(MyViewHolder holder, int position) {<br>    Movie movie = moviesList.get(position);<br>    holder.bind(movie);<br>}</pre><pre><strong>void</strong> setItem(List&lt;Movie&gt; movie) {<br>    if (movie == null) {return;}<br>    this.moviesList = movie;<br>    notifyDataSetChanged();<br>}</pre><p>기존에 <strong>onBindViewHolder </strong>메서드에서<strong> </strong>holder.title.setText(“movie”);와 같은 형태였다면, 데이터바인딩에서는 아래와 같이 binding.setVariable(BR.<em>movie</em>, movie); 또는 binding.setMovie(movie); 으로 완성이 됩니다. 이유는 layout에서 android:text=@{movie.title}처럼 바인딩하고 있기 때문입니다. (레이아웃은 깃헙소스에 자세히 설명되어있습니다)</p><pre><strong>class MyViewHolder</strong> extends RecyclerView.ViewHolder {<br>    ItemMovieListBinding binding;<br><br>    MyViewHolder(ItemMovieListBinding binding) {<br>        super(binding.getRoot());<br>        this.binding = binding;<br>    }<br><br>    <strong>void</strong> bind(Movie movie) {<br>        binding.setVariable(BR.<em>movie</em>, movie);<br>    }<br>}</pre><p>DataBinding을 사용해보니, 이점으로는findViewById(R.id.recyclerView); 코드가 필요 없어지는 점과 xml에서 바인딩하기 때문에 RecyclerView Adapter에서 각 데이터를 일일이 set해주지 않아도 되서 java코드가 줄어든다는 점이 가장 컸습니다. 그리고 무엇보다 직접 코딩하면서 몸소 느꼈습니다.</p><p>하지만 단점을 굳이 꼽자면, 그에 비해 레이아웃의 코드가 많아진다는점, 바인딩에러나서 수정해도 클린하고 다시 빌드해야 해결될때가 있다는 점 등이 있었습니다.</p><p>지금까지 설명드렸던 예제들과 위의 응용 동작은 Github에서 샘플 프로젝트로 확인 해보실 수 있습니다.</p><blockquote><a href="https://github.com/Elice-kim/EliceDataBinding">https://github.com/Elice-kim/EliceDataBinding</a></blockquote><blockquote>[도움이 되셨다면 깃헙 오른쪽 위의 star버튼을 눌러주세요!]</blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e67abb855788" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Image Upload & Download with Firebase Storage — 안드로이드 게시판 구현]]></title>
            <link>https://medium.com/@futureofdev/image-upload-download-with-firebase-storage-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EA%B2%8C%EC%8B%9C%ED%8C%90-%EA%B5%AC%ED%98%84-58075a2fcdae?source=rss-e4427987f5b------2</link>
            <guid isPermaLink="false">https://medium.com/p/58075a2fcdae</guid>
            <category><![CDATA[firebase]]></category>
            <category><![CDATA[image-upload]]></category>
            <category><![CDATA[androi]]></category>
            <category><![CDATA[firebase-storage]]></category>
            <dc:creator><![CDATA[elice dev]]></dc:creator>
            <pubDate>Tue, 21 Nov 2017 13:09:28 GMT</pubDate>
            <atom:updated>2017-11-21T13:09:28.506Z</atom:updated>
            <content:encoded><![CDATA[<p>사진과 글을 올리는 게시판 기능을 구현하고 싶을 때, “이미지&quot; 업로드 및 다운로드는 별도 서버구축 없이 Firebase Storage로 구현이 간편하고 빠르게 가능하다. 아래 사이트로 기본적인 설정은 아래 사이트 통해서 미리 하길 바란다.</p><p><a href="https://firebase.google.com/docs/storage/android/start?hl=ko">Android에서 시작하기 | Firebase</a></p><pre>//가장 먼저, FirebaseStorage 인스턴스를 생성한다                          //getInstance() 파라미터에 들어가는 값은 firebase console에서 <br>//storage를 추가하면 상단에 gs:// 로 시작하는 스킴을 확인할 수 있다FirebaseStorage storage = FirebaseStorage.getInstance(&quot;gs://my-<br>custom-bucket&quot;);</pre><pre>//위에서 생성한 FirebaseStorage 를 참조하는 storage를 생성한다StorageReference storageRef = storage.getReference();</pre><pre>// 위의 저장소를 참조하는 images폴더안의 space.jpg 파일명으로 지정하여<br>// 하위 위치를 가리키는 참조를 만든다<br>StorageReference spaceRef = storageRef.child(&quot;images/space.jpg&quot;);</pre><p>storage를 참조하고 있는 StorageReference를 생성하고, images폴더안에 space.jpg 라는 파일명으로 저장하고 싶으면 child(“images/space.jpg”) 로 정의하면 된다. 그럼 실제 올리고 싶은 File 을 업로드 하겠다.</p><pre>Uri file = Uri.fromFile(new File(pathName);<br>uploadTask = riversRef.putFile(file);<br><br>// 파일 업로드의 성공/실패에 대한 콜백 받아 핸들링 하기 위해 아래와 같이 작성한다uploadTask.addOnFailureListener(new OnFailureListener() {<br>    @Override<br>    public void onFailure(@NonNull Exception exception) {<br>        // Handle unsuccessful uploads<br>    }<br>}).addOnSuccessListener(new OnSuccessListener&lt;UploadTask.TaskSnapshot&gt;() {<br>    @Override<br>    public void onSuccess(UploadTask.TaskSnapshot taskSnapshot) {<br>    }<br>});</pre><p>OnSuccessListener가 호출된다면 업로드 성공. Firebase Storage Console에서 업로드 된것을 실제로 확인할 수 있다. 이제 업로드된 space.jpg를 다운받아 보자.</p><pre>// 인스턴스 생성<br>StorageReference storageRef = storage.getReference();<br>StorageReference spaceRef = storageRef.child(&quot;images/space.jpg&quot;);</pre><pre>// 액티비티 내에 보여주고 싶은 이미지뷰 바인딩<br>ImageView imageView = (ImageView) findViewById(R.id.imageView);<br><br>// Glide Library 사용하여 화면에 바로 보여줄 수 있다<br>Glide.with(this /* context */)<br>        .using(new FirebaseImageLoader())<br>        .load(spaceRef)<br>        .into(imageView);</pre><p>다운로드하여 Glide 를 사용해서 바로 화면에 나타낼 수 있다. 위의 코드가 전부가 되겠다. 물론 Firebase storage 를 사용하지 않고, 서버와 연동해도 되지만, 위와 같은 작업이면 클라이언트 단에서 콘솔로 바로 이미지 확인도 가능하고 관리하기도 용이하다. 따라서 필자는 Firebase Storage를 추천하고 싶다</p><ul><li>서버와 연동해서 파일 업로드를 하고 싶다면, MultipartBody.Part 로 post 를 보낼 수 있다. 해당 내용을 알고싶다면 아래 주소를 참조하면 된다.</li></ul><p><a href="https://futurestud.io/tutorials/retrofit-2-how-to-upload-files-to-server">https://futurestud.io/tutorials/retrofit-2-how-to-upload-files-to-server</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=58075a2fcdae" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>