<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Hosuk Shin on Medium]]></title>
        <description><![CDATA[Stories by Hosuk Shin on Medium]]></description>
        <link>https://medium.com/@erish?source=rss-ab5cb4aa4a47------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/0*wYA8RyVzkEsGPuiO.jpg</url>
            <title>Stories by Hosuk Shin on Medium</title>
            <link>https://medium.com/@erish?source=rss-ab5cb4aa4a47------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 13 May 2019 12:12:44 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@erish" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[[Python] Django, Clean Architecture 연구하기]]></title>
            <link>https://medium.com/@erish/python-django-clean-architecture-%EC%97%B0%EA%B5%AC%ED%95%98%EA%B8%B0-591d7a555059?source=rss-ab5cb4aa4a47------2</link>
            <guid isPermaLink="false">https://medium.com/p/591d7a555059</guid>
            <category><![CDATA[clean-architecture]]></category>
            <category><![CDATA[django]]></category>
            <category><![CDATA[python]]></category>
            <category><![CDATA[architecture]]></category>
            <category><![CDATA[django-rest-framework]]></category>
            <dc:creator><![CDATA[Hosuk Shin]]></dc:creator>
            <pubDate>Sun, 14 Oct 2018 09:07:44 GMT</pubDate>
            <atom:updated>2018-10-14T09:07:44.073Z</atom:updated>
            <content:encoded><![CDATA[<p>이 포스트는 <a href="https://engineering.21buttons.com/clean-architecture-in-django-d326a4ab86a9">https://engineering.21buttons.com/clean-architecture-in-django-d326a4ab86a9</a> 를 기반으로 작성하였습니다.</p><h3><strong>집은 이쁘게 지어야 청소할 맛이 난다</strong></h3><p>홍대-합정 일대에서 자취(혹은 독립)를 했었다. 첫 자취였기에 많은 기대심도 있었지만, 큰 지출을 하기에는 꺼렸기 때문에 적당히 이불 깔면서 살려고 했었다. 그런데 사람 마음이 마음처럼 되던가. 침대를 들여오고, 가습기를 가져오기 시작하더니 화장실 타일을 락스로 주말마다 닦기도 하고 방향제를 뿌리며 열심히 관리하는 것이었다.</p><p>일련의 과정들을 겪으면서, 집은 나에 맞게 구성품들이 변화되었으며, 내 핵심 루틴에 맞게 조정되었다. 그리고 나는 집에 대한 애착 또한 크게 증가할 수 있었다.</p><p>요즘 회사마다 MSA(Micro Service Architecture)를 지향하면서 엄청나게 큰 대형 프로젝트에 수많은 사람들이 관련되어 있지 않고, 소규모의 사람들 혹은 혼자서 저마다의 프로젝트 하나씩을 담당하는 모습들을 볼 수 있다.</p><p>개인적으로 이 모습이 각자의 집을 지어나가고 관리하는 모습과 굉장히 유사하다고 생각한다. 본인들이 집을 짓기도 하고, 집을 유지보수하며 집에 대한 애착이 생기듯 서버에 대한 구조를 잡아 나가고, 서버에 대한 유지보수를 하며 서비스에 대한 이해도가 높아지고 애착이 생기게 된다.</p><h3><strong>Django, Clean Architecture 연구하기</strong></h3><figure><img alt="" src="https://cdn-images-1.medium.com/proxy/1*ZNT5apOxDzGrTKUJQAIcvg.png" /><figcaption>Clean Architecture Diagram</figcaption></figure><p><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture</a>는 그 중에서도 집을 알맞게 정리하고 꾸미기 위한 방법론중의 하나이다. 이 포스트는 Clean Architecture의 원론적인 이해를 안내하는 글이 아니기에 자세하게 설명할 수 없지만, <strong>서비스 로직 등 중요한 요소들</strong>은 Core 요소로서 원의 중심에 있어야 한다. <strong>실제 정보 노출이 되는 View 혹은 기기등 기타 요소</strong>일수록 원의 테두리에 있어야 한다. 그리고 Core 요소들은 원의 테두리에 있는 요소들을 인지하지 못한 상태에서도 작동될 수 있도록 구성해야 한다. (원의 테두리에 있는 요소들이 원의 중심에 있는 요소들에 의존적인 형태여야 한다).</p><p>그럼 이 방법을 Django에 적용해보면 어떻게 구성할 수 있을까. 예제 코드와 같이 확인해보면서 진행해보겠다.</p><h4>Entities Layer (Innermost Domain)</h4><pre>- entities.py</pre><pre>class Product(object):</pre><pre>    def __init__(self, reference, brand_id):<br>        self._reference = reference<br>        self._brand_id = brand_id</pre><pre>    @property<br>    def reference(self):<br>        return self._reference</pre><pre>    @property<br>    def brand_id(self):<br>        return self._brand_id</pre><p>이것은 Entity에 관한 최대로 간단한 예제이다. 실제 Entity는 위의 예제보다 더 많은 정보를 담고 있을 것이다. 이 Entity와 연관된 Business logic과 high-level rules는 여기와 분리하도록 한다. (eg: invariant validations).</p><h4>Use Cases Layer (Outermost Domain)</h4><p>우리는 이것들을 interactors.py라 부르고 각각의 사용 케이스에 대한 비지니스 로직이 포함되어 있다. 여기에 어플리케이션이 갖고 있는 로직들은 포함하도록 하자. 우리는 작업의 이행을 위해 command pattern을 사용한다. 왜냐하면 작업 큐잉(task enqueing), 장애가 발생했을때 롤백(rollback), 변수와 의존성과 분리할때 도움이 되기 때문이다. (가독성, 테스트, 의존성 주입에 매우 유용하다):</p><pre>- interactors.py</pre><pre>class GetProductInteractor(object):</pre><pre>    def __init__(self, product_repo):<br>        self.product_repo = product_repo</pre><pre>    def set_params(self, reference):<br>        self.reference = reference<br>        return self</pre><pre>    def execute(self):<br>        return self.product_repo \<br>                        .get_product(reference=self.reference)</pre><p>다시 한번, 이 예제는 너무 간단하다. 예를 들어, 사용자 등록을 할때 우리는 사용자 적합성을 구분해야 하며 username은 등록할만한 이름인지 확인해야 하며 새로운 user entity를 생성하거나 저장하고 확인을 위해 메일을 보내는 등의 처리를 해야하는 것을 생각해봐야 한다.</p><h4>Interface Adapters Layer</h4><p>프레임워크로부터 분리되었으나 환경으로부터는 연결되어 있는 부분들이 있다. (API Restful, 데이터베이스 저장소, 캐싱…)</p><p>이에 해당되는 것이views.py이다. 이것들은 Django의view 구조를 따르지만 철저하게 분리되어 있다. (다음 섹션에 어떻게 그러는지 보게 될 것이다):</p><pre>- views.py</pre><pre>from .factories import GetProductInteractorFactory<br>from .serializers import ProductSerializer<br></pre><pre>class ProductView(object):</pre><pre>    def __init__(self, get_product_interactor):<br>        self.get_product_interactor = get_product_interactor</pre><pre>    def get(self, reference):<br>        try:<br>            product = self.get_product_interactor \<br>                              .set_params(reference=reference) \ <br>                              .execute() <br>        except EntityDoesNotExist:<br>            body = {&#39;error&#39;: &#39;Product does not exist!&#39;}<br>            status = 404<br>        else:<br>            body = ProductSerializer.serialize(product)<br>            status = 200</pre><pre>        return body, status</pre><p>그리고 여기serializers.py 가 있다. (body로서 python dict를 응답하는 모습을 보여주고 있다):</p><pre>- serializers.py</pre><pre>class ProductSerializer(object):</pre><pre>    @staticmethod<br>    def serialize(product):<br>        return {<br>            &#39;reference&#39;: product.reference<br>            &#39;brand_id&#39;: product.brand_id<br>        }</pre><p>ProductView는 factory로부터 interactor를 가져오는 역할을 갖고 있으며 (Factory는 이후에 다시 나오게 될 것이다), 들어온 파라미터들을 파싱하고 (단어의 구조를 잡거나/형식 확인을 할 수도 있다) serializers와 함께 결과물의 형식을 잡을 수 있다 (also 조정하고 형식 예외를 처리할 수 있도 있다).</p><p>한켠으로는 이층에서 우리는 앞 부분의 repositories.py. 를 가질 수 있다. 이것들은 직접적으로 저장소에 접근할 수는 없으나 (이 파트들은 다음 층에서 설명하게 될 것이다) 소스 저장소, 캐싱, 인덱싱 등을 선택하는 것은 담당하고 있다:</p><pre>- repositories.py</pre><pre>class ProductRepo(object):</pre><pre>    def __init__(self, db_repo, cache_repo):<br>        self.db_repo = db_repo<br>        self.cache_repo = cache_repo</pre><pre>    def get_product(self, reference):<br>        product = self.cache_repo.get_product(reference)</pre><pre>        if product is None:<br>            product = self.db_repo.get_product(reference)<br>            self.cache_repo.save_product(product)</pre><pre>        return product</pre><h4>Framework &amp; Drivers Layer</h4><p>Django와 3rd 파티 라이브러리로 구성되어 있을때, 이 층은그것들의 이행을 하는 것과 관련된 코드들을 위치하는 곳이다. (glue code).</p><p>예시에서 우리는 두가지 종류로 나뉘게 된다: database 와 web.</p><p>첫번째 파트에서는 우리는 Django ORM과 엮여 있는 repository를 만들었다:</p><pre>- repositories.py</pre><pre>from common.exceptions import EntityDoesNotExist<br>from .models import ORMProduct<br>from .entities import Product</pre><pre>class ProductDatabaseRepo(object):</pre><pre>    def get_product(self, reference):<br>        try:<br>            orm_product = ORMProduct.objects \<br>                                       .get(reference=reference)<br>        except ORMProduct.DoesNotExist:<br>            raise EntityDoesNotExist()</pre><pre>        return self._decode_orm_product(orm_product)</pre><pre>    def _decode_orm_product(self, orm_product):<br>        return Product(reference=orm_product.reference,<br>                       brand_id=orm_product.brand_id)</pre><p>볼 수 있듯이, 우리가 정의한대로 리턴하는 양쪽 객체와 예외, 결과적으로 우리는 ORM 상세를 모두 감출 수 있다.</p><p>그리고 두번째로 프레임워크로부터 우리의 view를 띄어내고 세부 형식을 감출 수 있는 view wrapper를 만들었다:</p><pre>import json</pre><pre>from django.http import HttpResponse<br>from django.views import View<br></pre><pre>class ViewWrapper(View):</pre><pre>    view_factory = None</pre><pre>    def get(self, request, *args, **kwargs):<br>        body, status = self.view_factory.create().get(**kwargs)</pre><pre>        return HttpResponse(json.dumps(body), status=status,<br>                            content_type=&#39;application/json&#39;)</pre><p>이 wrapper는 2가지 목적을 가지고 있다: 모든 요청을 순수한 python 객체로 변환하고 결과 응답으로 변환할 수 있다. (그래서 view들은 순수한 python 객체로 리턴할 수 있다)</p><p>또한, self.view_factory.create() 는 이와 관련된 모든 dependencies와 함께view를 생성할 수 있다. (이 설명은 하단에 있다).</p><p>이런 층에서는 우리는 models.py<em>, </em>admin.py<em>, </em>urls.py, settings.py, migrations, 과 다른 Django와 관련된 코드들을 가질 수 있다 (우리는 특수성을 가지고 있지 않기 때문에 상세하게 명시할 수는 없다).</p><p>이런 층은 완전히 Django(혹은 다른 라이브러리)와 연결되어 있다. 비록 우리가 될 수 있는대로 가볍게 하려 해도 앱에서 강력하고 필수적인 부분일 것이다!</p><h4>Dependency Injection</h4><p>그런데 이 모든 부분들을 합치는가? 이 문제는 의존성 주입(Dependency injection)으로 해결할 수 있다!</p><p>우리가 이전에 봐왔던 것처럼, 우리는 의존성을 해결하는 것을 담당하는 factories.py를 통해 view를 생성할 수 있다.:</p><pre>- factories.py</pre><pre>from .repositories import ProductDatabaseRepo, ProductCacheRepo<br>from .unit_repositories import ProductRepo<br>from .interactors import GetProductInteractor</pre><pre>class ProductDatabaseRepoFactory(object):</pre><pre>    @staticmethod<br>    def get():<br>        return ProductDatabaseRepo() <br></pre><pre>class ProductCacheRepoFactory(object):</pre><pre>    @staticmethod<br>    def get():<br>	return ProductCacheRepo() <br></pre><pre>class ProductRepoFactory(object):</pre><pre>    @staticmethod<br>    def get():<br>	db_repo = ProductDatabaseRepoFactory.get()<br>	cache_repo = ProductCacheRepoFactory.get()<br>        return ProductRepo(db_repo, cache_repo)<br></pre><pre>class GetProductInteractorFactory(object):</pre><pre>    @staticmethod<br>    def get():<br>        product_repo = ProductRepoFactory.get()<br>        return GetProductInteractor(product_repo)<br></pre><pre>class ProductViewFactory(object):</pre><pre>    @staticmethod<br>    def create():<br>        get_product_interactor = GetProductInteractorFactory.get()<br>        return ProductView(get_product_interactor)</pre><p>Factories 는 각각의 factory resolver에 각 요소의 책임을 줌으로서 의존성을 재귀적으로 해결하고 생성하는 역할을 담당하고 있다.</p><p>결과적으로, 이 시작은 여기서 시작하게 된다: urls.py</p><pre>url(r&#39;^products/(?P&lt;reference&gt;\w+)$&#39;,<br>    ViewWrapper.as_view(view_factory=ProductViewFactory))</pre><p>이 포스트는 Django 구조 및 요소를 해체하거나 잘못 사용하는 것이 목적이 아니다. 단지 잘 사용할 수 있는 대체제로서 제시하는 것이다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=591d7a555059" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[개발 생각] 버그는 막을 수 있을까]]></title>
            <link>https://medium.com/@erish/%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EA%B8%B0-%EB%B2%84%EA%B7%B8%EB%8A%94-%EB%A7%89%EC%9D%84-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C-1392e6bba933?source=rss-ab5cb4aa4a47------2</link>
            <guid isPermaLink="false">https://medium.com/p/1392e6bba933</guid>
            <category><![CDATA[programming]]></category>
            <category><![CDATA[bugs]]></category>
            <category><![CDATA[computer-programming]]></category>
            <category><![CDATA[computer-science]]></category>
            <dc:creator><![CDATA[Hosuk Shin]]></dc:creator>
            <pubDate>Sun, 29 Jul 2018 09:00:17 GMT</pubDate>
            <atom:updated>2018-10-06T15:44:25.334Z</atom:updated>
            <content:encoded><![CDATA[<p>이 포스팅은 <a href="https://medium.com/qualityfaster/preventing-software-bugs-13f1cb2c7103">https://medium.com/qualityfaster/preventing-software-bugs-13f1cb2c7103</a> 를 기반으로 작성되었습니다.</p><h3>버그는 어떻게 나오게 될까</h3><h4>버그와의 전쟁은 지치고 무섭기도 하다. 하지만 버그의 본능을 안다면, 우리는 어떤 방지책이 효과적으로 고통으로부터 우리를 해방시킬 수 있는지 알 수 있을 것이다.</h4><p>버그를 경험했을때는 SOPT라는 동아리 활동을 할 때였다. 서울시 앱 공모전에 제출할 어플리케이션을 제작하기 위해 처음으로 안드로이드 어플리케이션을 제작하고 있던 시기였다. 그때 특정 기능을 추가한 앱을 만들었다고 생각했는데 휴대폰에 옮기니 죽는 것이었다.</p><p>그때의 감정은 당혹감이 제일 컸었다. 분명 내가 생각했을대, 이 기능은 특정 행동을 보이며 잘 작동되리라 생각했지만, 생각하지 못한 방향으로 작동이 되었다는 것이다. 결국 버그를 고치기 위해 수많은 노력과 검색을 해야만 했었다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*FxLQ6KiccA4GXui0nicnWQ.jpeg" /><figcaption>당시 나의 모습은 막막한 우주를 바라보는 우주인의 모습이었을까</figcaption></figure><p>시간이 흘러 카카오에 있는 지금도 그 감정은 유효하다. 생각한대로 프로그램이 작동하면 좋겠지만, 세상의 원리가 그러하듯, 프로그램은 매번 내가 머리속에서 그려온대로 작동하지 않는다.</p><p>하지만 이전처럼 당혹감은 존재하지만 처음 프로그래밍을 했을때와 달리 식은땀을 막 흘리면서 작업을 하지는 않는다. 왜 그럴까. 오늘 이 글은 버그의 유형에 대해 알아보고, 버그에 대한 이해도를 높이는 기회를 얻어보려 한다.</p><h4><em>버그를 이해한다면, 버그에 맞서 싸울 필요가 없어진다.</em></h4><p>버그는 3가지의 타입이 존재한다. 딱 3가지. 그리고 각각 “간편한 버튼&quot; 같은 트릭이 존재한다.</p><h3>버그 타입 1: Implementation Defect</h3><h4><strong><em>기획은 완벽했는데, 실행은 불완전했다.</em></strong></h4><p>흘깃 봤을때는, 이 유형의 버그가 제일 흔할 것 같지만 사실 아니다. <a href="http://cdn.intechopen.com/pdfs-wm/9291.pdf">다음 자료에 따르면,</a> 오직 15%의 결함이 이 단계에서 발생하고 있다. 그렇지만 이 연구가 Regressions 버그들을 고려하지는 않았기에 수치가 대등소이할 수 있다. 하지만 개인적 판단에 따르면 제일 작은 수치의 버그임에는 틀림없다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/640/1*eh2ZooqJFrwKmZJmsw7x2w.jpeg" /><figcaption>코드가 복잡하게 꼬여있으면 만든 사람도 보기 힘들다</figcaption></figure><h4>흔한 이유들</h4><p><strong><em>Regressions</em></strong><br>버그들은 거미줄처럼 크고 복잡하게 얽혀있는 코드들 사이에 숨어있다. 업계 평균은 <a href="http://www.mayerdan.com/ruby/2012/11/11/bugs-per-line-of-code-ratio/">1000라인당 15–50개의 버그</a>가 발생한다고 한다. 대단히 실력이 좋은 개발자라고 해도 당해낼 도리가 없다.</p><p><strong><em>Smelly Code</em><br>“</strong><a href="https://en.wikipedia.org/wiki/Code_smell">Smelly Code</a>” 는 버그로 이끌어가는 설계상의 약점을 고려해볼 수 있다. 이것이 발생하게 되는 요인에는 빨리 처리하기 위한 압박이나 나태함, 무시등이 있다.</p><p><strong><em>충분치 못한 테스팅</em></strong><em><br></em>타임라인은 빠듯하게 잡혀져 있고 팀은 빨리 기능을 출시해야한다고 생각해보자. 타임라인이 빠듯해지면 제일 유혹을 받는 부분은 자동 혹은 수동으로 테스트를 하는 시간을 줄이는 것이다. 이는 Production으로 넘어가기 전에 잡을 수 있는 버그들을 잡을 기회를 놓치면서 나오게 된다.</p><h4>해결 방식</h4><blockquote><strong><em>Test Driven Development</em></strong></blockquote><p><a href="http://www.jamesshore.com/Agile-Book/test_driven_development.html">Test Driven Development</a> (TDD)는 기능 명세에 맞춰 기능을 테스트할 수 있는 코드를 작성 및 테스트하는 것이다. 결과적으로 코드의 순기능에 집중해 테스트를 자동화 할 수 있다는 점을 장점으로 이야기하고 싶다.</p><p>이 작업을 함으로써 <a href="http://aspiringcraftsman.com/2008/01/03/art-of-separation-of-concerns/">separation of concerns</a>(관심사의 분리, 관리 요소의 분리), <a href="https://sourcemaking.com/design_patterns">design patterns</a> 및 <a href="https://sourcemaking.com/refactoring">refactoring</a>같은 원칙들을 사용하도록 유도한다. 그래서 더욱 깔끔한 코드, 적어도 Smelly Code를 적게 생산할 수 있다.</p><p>이것은 또한 시간의 압박을 받을때 속도를 유지할 수 있도록 해주는 <a href="https://docs.docker.com/docker-hub/builds/">자동화</a>와 <a href="https://www.thoughtworks.com/continuous-integration">continuous integration</a>와 같은 작업을 할 수 있도록 유도한다. 결과적으로 불충분한 테스트 프로그램을 줄이도록 한다.</p><p>위의 이점들은 <a href="http://research.microsoft.com/en-us/groups/ese/nagappan_tdd.pdf"><strong>40–90%</strong></a><a href="http://research.microsoft.com/en-us/groups/ese/nagappan_tdd.pdf">사이의 결점을 줄인다고 알려져 있다</a>. 상당히 큰 수치이다. 그리고 이런 점들이 Implementation bugs를 줄이기 위한 최대효과 해결 방식으로서 TDD라는 점을 나타내준다.</p><h3>Type 2: Incorrect Specification</h3><h4><strong><em>정의가 명확하지 못해, 결과적으로 기능 구현도 부정확하다.</em></strong></h4><p>캠브리지 대학교에서 연구한 것에 따르면 <a href="http://download.microsoft.com/documents/rus/visualstudio/03_CambridgeUniversity_study-time_and_cost_saved_using_RDBs-January_20....pdf">50%의 결점은 정의를 할때 발생한다고 한다</a>. 이 케이스의 제일 고통스러운 점은 설계를 처음부터 고쳐야 할 수도 있기 때문이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*EZk40FSSOPa6ddDVG-1dJg.jpeg" /><figcaption>소통은 빈틈이 있을수록 서로 상상할 여지를 주게 된다</figcaption></figure><h4>흔한 이유들</h4><p><strong><em>충분치 못한 커뮤니케이션<br></em></strong>충분하지 못한 커뮤니케이션은 서로 이해를 다르게 할 여지를 준다. 결국 기획자가 의도한 디테일한 부분들이 구체화에 반영되지 않는다면, 구체화는 잘못된 방향으로 진행되고 버그가 발생하게 된다.</p><p><strong><em>불일치<br></em></strong>가끔 몇몇 구체화된 사항들이 이전에 구체화되었던 사항들과 충돌이 날때도 있다. 만약 발생한다면 버그는 개발 단계(운이 좋다면) 혹은 Production 단계에서 발생할 수 있다.</p><h3>Bug Type 3: Missing Specifications</h3><h4><strong><em>정의에서 놓쳐, 결과적으로 구현에서 놓쳤다.</em></strong></h4><p>간단히 말해, 제품을 디자인할때 상상하지도 못한 시나리오들이다. 이것들은 “알려지지 않은&quot; 타입들을 일컫는다. 이들의 충격은 예상할 수 없으며 성가신 것부터 시작하여 파멸로 치닫는 것까지의 범위를 가진다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*KoilLRaq6YEtdd6UtSadoA.jpeg" /><figcaption>구현에서 독단적인 창작은 좋지 못하다</figcaption></figure><h4>흔한 이유들</h4><p><strong><em>충분하지 못한 연구</em></strong><br>제대로 된 연구 없이 막연하게 ‘이렇게 될 것이다&#39;라고 가정을 하기 시작하면, 결국 모든 것은 상상력으로 끝나게 된다. 가정을 하여 얻어낸 값은 큰 의미를 부여할 수 없으며 엉뚱하게도 복잡하고 난해한 문제가 따라올 가능성이 높다. 최종적으로 이것은 버그로 오게 된다.</p><p><strong><em>무시<br></em></strong>몇몇 사람들은 기대했던 행동이 정의되지 않았음에도 릴리즈를 할때 “기능이 잘못된 것 같다&quot;는 느낌을 받을 때가 있다. 이 버그들은 정의가 부족할때 나오게 된다.</p><h4>해결 방식</h4><blockquote><strong><em>Behaviour Driven Development</em></strong></blockquote><p><a href="http://inviqa.com/insights/bdd-guide#what-is-bdd">Behaviour Driven Development</a> (BDD)는 기획자와 개발자간의 이해를 공유하기 위해 만들어진 많이 알려진 개발 방법이다. 특히 TDD가 정착되고 나서, 개발현장은 TDD에 이은 다양한 xDD를 도입해왔다. 그 중에서도 BDD는 행동을 중심으로 한 테스트 방법이다.</p><p>BDD는 기획자와 개발자간에 어디서부터 테스트를 시작할 것이고 사용자의 행동 패턴에 맞춘 시나리오를 정의한다. 그리고 이것에 맞춰 ‘행동’에 대한 테스트를 진행한다. 최종적으로 BDD를 통해 시나리오에 대한 성공 유무를 확인할 수 있다.</p><p>이를 통해서 기획자는 시나리오의 완벽성을 확인할 수 있다. 개발자는 시나리오에 맞춘 개발 구현의 완성도를 확인할 수 있다. 또한 실패 원인에 따라 시나리오를 변경하거나 개발 구현 사항을 수정할 수 있게 된다.</p><h3>정리해보기</h3><p>우리는 버그를 없애기위해 필연적으로 테스트를 많이 해야한다. 처음에는 많이 당황할수도 있지만, 시간이 지날수록 요령은 생길 것이다. 제일 중요한 것은 버그를 맞서 싸우면서 기를 빼는 것보다 버그가 코드 내에 안착하기 전에 사전에 발견하여 없애는 것이 최고다.</p><p>그럼에도 버그는 필연적으로 발생할 것이며, 버그가 발견된다고 낙심하진 말자. 버그가 있다는 것은 서비스가 성장하기 위한 성장통이며, 이를 해결하는 나 자신 또한 성장하고 있다는 증거이다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1392e6bba933" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[Python] pipenv 란 무엇인가]]></title>
            <link>https://medium.com/@erish/python-pipenv-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-961b00d4f42f?source=rss-ab5cb4aa4a47------2</link>
            <guid isPermaLink="false">https://medium.com/p/961b00d4f42f</guid>
            <category><![CDATA[python]]></category>
            <category><![CDATA[pip]]></category>
            <category><![CDATA[pipenv]]></category>
            <category><![CDATA[virtualenv]]></category>
            <dc:creator><![CDATA[Hosuk Shin]]></dc:creator>
            <pubDate>Sat, 28 Apr 2018 08:12:14 GMT</pubDate>
            <atom:updated>2018-04-28T08:12:14.002Z</atom:updated>
            <content:encoded><![CDATA[<h4>pip, virtualenv, 귀찮지 않으세요?</h4><p>python을 사용하면서 당연하게도 사용하게 되는 두가지가 있다.</p><p>첫번째는 pip이다. python을 이용하며 사용하게 되는 패키지 관리 툴이다. 프로그램을 만들 때, 의도하지 않는 이상, 다양한 패키지를 사용하게 된다. 이때 pip를 활용하여 여러가지 패키지들을 설치할 수 있다.</p><p>두번째는 virtualenv이다. python으로 개발을 하게 되면 거의 항상 복수의 패키지를 설치하여 사용하게 된다. 하지만 각각의 프로젝트가 요구하는 패키지들의 상세 내용이 다를 수 있다.</p><p>가령 A라는 프로젝트는 특정 패키지의 1.0 버전을 사용하고 있었지만, B라는 프로젝트는 특정 패키지의 2.0버전을 사용하는 경우가 발생한다. 이때 각각의 프로젝트를 빌드하기 위해서 서로 번갈아가며 패키지를 설치했다 지웠다하는 생각은 버리도록 하자. pandas와 같은 패키지를 사용하면 알겠지만, 시간이 많이 소요된다.</p><p>그렇기 때문에 각각의 프로젝트 내 개발 환경을 구축하는 것이 제일 이상적이다. 이를 지원하는 것이 virtualenv이다. virtualenv는 프로젝트별로 고립된 개발환경을 구축하게 해주기 때문에 A 프로젝트와 B 프로젝트를 따로 의식하면서 패키지를 특정 환경에 맞게 설치했다 지웠다 하지 않으며 개발할 수 있게 된다.</p><p>하지만 여기서 문제가 발생한다. 첫번째는 pip는 패키지들을 설치하는데 있어서 여간 귀찮지 않을 수 없다. 먼저 pip를 하나씩 설치를 하자니 시간이 많이 들게 된다. 그래서 requirements.txt라는 파일을 통해 통으로 패키지들을 관리할 수 있도록 지원하고 있다. 하지만 문제점은 requirements.txt를 버전을 명시하지 않고 작성하였을때, 오늘과 내일의 설치가 똑같다는 보장이 없으며 정확히 버전을 일일이 기재를 하자니 또한 귀찮아진다. (참조 1)</p><p>이마저도 pip의 고비를 넘기기 전에 virtualenv를 설치해야 한다는 점도 까먹지 말자. 결론은 매번 환경 설정을 의식해야 하는것들이 많기 때문에 여러모로 귀찮다는 점이다.</p><h3>pipenv의 등장</h3><p>이런 이유들로 인해 등장한 것이 pipenv이다. 이름만으로도 느낌이 오지 않는가? pip와 virtualenv가 합쳐진 것이다.</p><p>pipenv는 <a href="https://packaging.python.org/tutorials/managing-dependencies/#managing-dependencies">Python.org</a>에서 공식적으로 권장하는 패키지 설치 툴이다. Pipenv는 파이썬으로 들어가는 세계 속 패키징 설치 경험을 최상으로 제공하고자 노력한다고 써있다. Pipenv는 또한 아래와 같이 문제들을 해결하려고 하였다.</p><ul><li>pip와 virtualenv를 따로 쓸 필요가 없다. 동시에 사용이 된다.</li><li>Pipenv는 Pipfile와 Pipfile.lock을 requirements.txt를 대신하여 사용한다.</li><li>해쉬가 자동생성된다. (보안)</li><li>의존성 그래프를 제공함으로서 insight를 제공한다 (e.g. $ pipenv graph).</li><li>.env 파일들을 사용한 스트림라인 개발 워크플로우</li></ul><p>기본 특징은 다음과 같다.</p><ul><li>필요한 것만 정의하면서, 결정론적인(deterministic, 파일에 정의된대로) 빌드가 가능하다.</li><li>락이 걸린 의존성에 대해 해쉬 파일을 생성하고 확인한다.</li><li>pyenv가 사용 가능하다면, 필요한 python도 자동으로 설치한다.</li><li>Pipfile을 찾으면서자동으로 프로젝트 홈을 찾아준다.</li><li>Pipfile이 없다면 자동으로 생성해준다.</li><li>자동으로 virtualenv 환경을 생성한다.</li><li>패키지를 설치/삭제하면, 자동으로 Pipfile에서 추가/삭제한다.</li><li>자동으로 .env 파일을 인식한다.</li></ul><h3>pipenv 사용법</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/654/1*pDmTt14s9yZnkNRSrzINuQ.gif" /><figcaption>참조 : <a href="https://github.com/pypa/pipenv">https://github.com/pypa/pipenv</a></figcaption></figure><p>가볍게 맥을 기준으로 사용법을 안내한다.</p><pre>$ brew install pipenv</pre><p>를 terminal에 입력하여 설치하도록 하자. 이후</p><pre>pipenv --python 3.6</pre><p>를 명령어를 치면 python 3.6버전을 기준으로 한 프로젝트가 생성된다. 이후는 pipenv를 사용하여 기존 패키지들을 pip처럼 설치하는 것 뿐이다.</p><pre>pipenv shell</pre><p>또한 pipenv 내 가상환경을 사용하는 것은 위와 같다. 이외 자세한 사용법은 아래와 같다.</p><pre>$ pipenv<br>Usage: pipenv [OPTIONS] COMMAND [ARGS]...<br><br>Options:<br>  --where          Output project home information.<br>  --venv           Output virtualenv information.<br>  --py             Output Python interpreter information.<br>  --envs           Output Environment Variable options.<br>  --rm             Remove the virtualenv.<br>  --bare           Minimal output.<br>  --completion     Output completion (to be eval&#39;d).<br>  --man            Display manpage.<br>  --three / --two  Use Python 3/2 when creating virtualenv.<br>  --python TEXT    Specify which version of Python virtualenv should use.<br>  --site-packages  Enable site-packages for the virtualenv.<br>  --version        Show the version and exit.<br>  -h, --help       Show this message and exit.<br><br><br>Usage Examples:<br>   Create a new project using Python 3.6, specifically:<br>   $ pipenv --python 3.6<br><br>   Install all dependencies for a project (including dev):<br>   $ pipenv install --dev<br><br>   Create a lockfile containing pre-releases:<br>   $ pipenv lock --pre<br><br>   Show a graph of your installed dependencies:<br>   $ pipenv graph<br><br>   Check your installed dependencies for security vulnerabilities:<br>   $ pipenv check<br><br>   Install a local setup.py into your virtual environment/Pipfile:<br>   $ pipenv install -e .<br><br>   Use a lower-level pip command:<br>   $ pipenv run pip freeze<br><br>Commands:<br>  check      Checks for security vulnerabilities and against PEP 508 markers<br>             provided in Pipfile.<br>  clean      Uninstalls all packages not specified in Pipfile.lock.<br>  graph      Displays currently–installed dependency graph information.<br>  install    Installs provided packages and adds them to Pipfile, or (if none<br>             is given), installs all packages.<br>  lock       Generates Pipfile.lock.<br>  open       View a given module in your editor.<br>  run        Spawns a command installed into the virtualenv.<br>  shell      Spawns a shell within the virtualenv.<br>  sync       Installs all packages specified in Pipfile.lock.<br>  uninstall  Un-installs a provided package and removes it from Pipfile.</pre><p>Pipenv를 활용하여 편리하고도 쉬운 개발환경 세팅하기를 바란다.</p><p>참조 1: <a href="https://www.kennethreitz.org/essays/a-better-pip-workflow">https://www.kennethreitz.org/essays/a-better-pip-workflow</a></p><p>참조 2: <a href="https://github.com/pypa/pipenv">https://github.com/pypa/pipenv</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=961b00d4f42f" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[회고] 개발자, 플레이윙즈, 2017년]]></title>
            <link>https://medium.com/@erish/%EC%9E%A1%EB%8B%B4-%EA%B0%9C%EB%B0%9C%EC%9E%90-%ED%94%8C%EB%A0%88%EC%9D%B4%EC%9C%99%EC%A6%88-2017%EB%85%84-ad7309793c96?source=rss-ab5cb4aa4a47------2</link>
            <guid isPermaLink="false">https://medium.com/p/ad7309793c96</guid>
            <category><![CDATA[2017]]></category>
            <category><![CDATA[2018]]></category>
            <category><![CDATA[playwings]]></category>
            <category><![CDATA[플레이윙즈]]></category>
            <category><![CDATA[회고록]]></category>
            <dc:creator><![CDATA[Hosuk Shin]]></dc:creator>
            <pubDate>Fri, 05 Jan 2018 00:01:05 GMT</pubDate>
            <atom:updated>2018-10-06T15:43:41.163Z</atom:updated>
            <content:encoded><![CDATA[<p>2017년. 이 글을 읽는 여러분들은 어떤 해였는지 우선 질문을 드려본다. 머리 속에서 제일 먼저 생각나는 순간들을 기억해보고 단어들로 정리를 하면 그것이 2017년 보냈던 의미들을 정리하는 것이 될 것이다.</p><p>나한테 있어서 2017년은 ‘도전, 커뮤니케이션, 정복’ 으로 정리되는 해였다고 생각한다. 이 단어들이 어떻게 나왔는지는 나날이 적으면서 2017년을 돌아보기로 하자.</p><h3><strong>도전</strong></h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*LWXwFGqzApL86prY1eJZdw.png" /><figcaption>2017년, 2,054 commit을 하였다. 1일 1commit은 아니었지만 횟수로는 채운만큼 달성은 한 것인가…? from github</figcaption></figure><p>엔지니어 커리어의 시작은 Android였다. 전자재료학과를 나온 나로써 Android를 개발을 할 수 있게 된 것만으로도 많은 흥분과 학습에 대한 욕구를 채울 수 있었다. 그리고 2016년 중반부터 안드로이드를 개발하기 위해 쓰이는 Java 언어를 활용하여 Spring Boot, Java8, JPA(Hibernate), Redis, MySQL(AuroraDB)를 활용하여 Production Server 및 신규 서버들의 개발 및 유지보수를 할 수 있게 되었다.</p><p>하지만 2017년은 여러 욕심이 커지는 해였다. 나와 개발팀이 개발하고 있는 Product들을 떳떳하게 공개해도 될 만큼 <strong>양질의 코드</strong>들과 <strong>안정적인 서비스</strong>가운영되기를 희망하였다.</p><p><strong>Android</strong>는 여러 신규 라이브러리 도입을 통한 안정적인 서비스 관리를 시작 할 수 있었다. 수많은 작업들이 있었지만, 기억에 남는 것 중에서는 우선 Realm을 도입을 하였다. Production Server와의 통신 중에서도 불필요한 서버 통신을 줄일 수 있도록 한번 받은 정보에 대해 Realm에 저장하여 활용할 수 있도록 하였다. 또한 RxJava와 연동하여 비동기적으로 insert 및 select, update와 관련된 처리를 할 수 있도록 하였다. Bitrize를 통해코드 테스트 및 플레이스토어까지 5% 릴리즈를 할 수 있도록 하였다.</p><p><strong>Server</strong>는 이전 개발자의 코드의 울타리에서 벗어나 명확성을 증가시킬 수 있도록 Clean Architecture를 할 수 있도록 노력하였다. 여기서 Clean Architecture의 정의는 1) 이해하기 쉽고 2) 유지보수하기 쉬운 구조를 뜻한다. 난잡하게 짜여져 있었던 코드들을 Controller단에서 Service단으로 모두 이동하였고, Service 내 동일한 코드들은 Util로 이동하고 Redis의 다양한 key값들을 깔끔하게 정리하는 등의 노력을 기울였다. 하지만 안타까운 점은 꾸준히 진행하였음에도 모자란 부분이 있어서 2018년에도 꾸준한 노력이 필요할 것이라 생각한다.</p><h3><strong>커뮤니케이션</strong></h3><p>사람간에 오가는 똑같은 단어는 어쩌면 그렇게 각자 마음속에 다르게 울릴지 모르겠다. 굵직굵직한 기획들이 많았던 해인만큼 다양한 팀들과 다양한 방식의 이야기들을 진행해야 했다.</p><p>원론적인 이야기겠지만 말하고 싶은 점은 <strong>기획을 위한 커뮤니케이션을 위한 스탭</strong>들이 존재한다는 점을 깨달았다. 처음에는 배경과 기획의 목표를 설정하는 것부터 시작한다. 배경과 목표가 정리 되었다면 스케쥴링과 세부 목표들 및 완료시 체크해야 할 것들을 정리해야 한다. 이후 스케쥴대로 개발에 대한 집행을 하며 체크일에 맞춰 목표들을 점검하는 방식을 채용하는 것이다.</p><p>물론 아직도 커뮤니케이션을 위한 길은 멀고도 험하기에 2018년에는 사람들을 ‘잘’ 설득시키고 하나의 방향으로 나아가길 희망한다.</p><h3><strong>정복</strong></h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/392/1*Hto0uLOaIbJP-6ExgVsBTw.jpeg" /><figcaption>취향을 골라 골라 from Playwings</figcaption></figure><p>데이터. <strong>많이 쌓으면 쌓을수록 좋기는 하지만 막상 쓰려면 어디서부터 열어서 활용해야 할지 모르는 데이터</strong>. 데이터 사이언티스트가 합류한 이후로 플레이윙즈는 사용자들에게 더 적합한 상품을 푸시로 보내거나 상품이 노출되기를 꿈꾸기 시작했다.</p><p>하지만 <strong>클러스터링을 구성하기 위한 작업은 험난하였다</strong>. 우선 사용자에게 필요한 정보들을 선별하는 작업부터 시작하였다. 가정은 각각의 유저마다 각각의 특징이 있다고 가정하였다. 이 가정이 중요한 것은, 특히 다른 서비스에서 이 기획을 진행할지 판단할때, 사용자들의 행동 패턴에 특별한 의미가 없거나 모두 동일한 행동을 하고 있다고 판단된다면 클러스터링을 할 의미가 없어지게 된다.</p><p>앞의 가정을 토대로 사용자들의 행동들은 익명으로 서버에 보고 되었으며 이 raw 정보들을 fluentd에 취합하여 s3에 저장하였다. 대용량의 정보들을 수집하는데 많은 고민들을 하여 반영하였고 이에 대한 자료들은 많은 편이었다.</p><p>그리고 기획을 통해서 정했던 유저의 행동에 대한 의미 부여 테이블이 존재하며, 이를 기반으로 기록 및 분석을 하였다. 최종적으로 분석된 정보를 통해 유저의 특징에 따라 클러스터링하였고 세부적으로 유저의 활동도에 따라 세부군을 다시 재분류하였다.</p><p>결과적으로 클러스터링 정보를 통해 컨텐츠 노출과 사용자 푸시에 활용되었다. 실제 이를 활용하여 컨버전률을 관리하고 있으며 기획 의도대로 작동하고 있다고 판단하고 있다.</p><p>만약 다른 서비스에서도 클러스터링을 기획한다면, 이야기하고 싶은 점은 생각보다 개발보다 <strong>기획적 측면에서 많은 시간이 소요될 것이다</strong>. 또한 <strong>클러스터링을 통해 얻고 싶은 점을 명확히 한다면 생각보다 쉽게 클러스터링을 할 수 있을 것이다</strong>.</p><h3><strong>2018년에는</strong></h3><p>무엇을 하고 싶은가. 나는 Coder로서 발전 욕심도 있고 Lead Developer로서 기획과 의견조율 및 비저닝을 하고 싶은 욕심 또한 있다. 그렇기 때문에 2018년에는 길을 다시 한번 체크하고 점검하고 방향을 다시 재정립하는 해가 되기를 기도한다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ad7309793c96" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[python] Python에도 스타일이 있다]]></title>
            <link>https://medium.com/@erish/python-codestyle-pep-8-%EC%A0%81%EC%9A%A9%EA%B8%B0-88b1dafd539e?source=rss-ab5cb4aa4a47------2</link>
            <guid isPermaLink="false">https://medium.com/p/88b1dafd539e</guid>
            <category><![CDATA[pycharm]]></category>
            <category><![CDATA[pylint]]></category>
            <category><![CDATA[python]]></category>
            <category><![CDATA[pep8]]></category>
            <category><![CDATA[pep]]></category>
            <dc:creator><![CDATA[Hosuk Shin]]></dc:creator>
            <pubDate>Wed, 17 May 2017 00:01:01 GMT</pubDate>
            <atom:updated>2017-05-17T00:40:36.955Z</atom:updated>
            <content:encoded><![CDATA[<p>회사가 홍대에 위치해 있어 창 밖에 다양한 사람들이 지나가는 것을 볼 수 있다. 유심히 들여다보면 각자 다양한 옷을 입으며 거리를 돌아다니고 있다. 그것은 그들의 개성을 나타내는 하나의 ‘스타일&#39;이다. 어떤 사람은 청바지를 좋아하기도 하며 어떤 사람은 모자를 쓰는 것을 좋아한다. 또 어떤 사람은 반대로 반지를 차는 것을 싫어할 수 있다.</p><p>코딩을 할때도 각자의 스타일이 있다. 어떤 사람은 한 라인에 여러 라이브러리들을 한꺼번에 불러 올 수 있으며 어떤 사람은 변수의 표기 방법을 자신의 스타일로서 구축할 수 있다.</p><p>하지만 코딩을 할 때 각자의 스타일을 내세우는 것보다 일정 규칙에 맞춘 하나의 스타일을 지키는 것이 좋다. 여기에는 다양한 이유가 있겠지만 한 줄로 요약하면 “읽고 쓰기 편하기 위해서&quot; 이다.</p><h3>PEP 8 / 코딩 스타일 가이드라인이란</h3><p>그래서 존재하는 것이 코딩 스타일 가이드라인이다. 이는 코드를 작성할 때 개발자들이 코딩을 할 때 특정 형식으로 작성하자고 약속하는 것이다. 그 중에서도 PEP(Python Enhance Proposal 8)가 있다. 이 제안서에는</p><ol><li>새로운 기능이나 구현을 제안하는 Standard Track</li><li>파이썬의 디자인 이슈나 일반적인 지침, 혹은 커뮤니티에의 정보를 제안하는 Informational</li><li>파이썬 개발 과정의 개선을 제안하는 Process</li></ol><p>3가지로 구분할 수 있다. 특히 PEP8는 파이썬 코딩 스타일 가이드라인을 의미하며 파이썬 커뮤니티에 정보를 제안하는 Process에 해당된다. 간단히 PEP8의 내용은 다음과 같다.</p><ol><li>들여쓰기는 공백 4개로 한다.</li><li>한 줄 최대 글자는 79자로 한다.</li><li>최상위(top-level) 함수와 클래스 정의는 2줄씩 띄어 씁니다.</li><li>파일은 UTF-8 또는 ASCII로 인코딩한다.</li><li>하나의 import에는 모듈 하나만 기재한다.</li><li>import는 표준 라이브러리, 서드파티, 로컬 라이브러리 순서로 묶는다.</li><li>소괄호, 중괄호, 대괄호 사이에 추가로 공백을 입력하지 않는다.</li><li>…..</li></ol><p>이외에도 수많은 규칙들이 PEP8에 적혀있다. 이를 더 자세히 확인하려면 <a href="https://www.python.org/dev/peps/pep-0008">https://www.python.org/dev/peps/pep-0008</a> 에서 확인할 수 있다.</p><h3>내 프로젝트는 PEP8을 잘 따르고 있는가</h3><p>이를 체크하기 위한 방법은 대표적으로 세가지가 존재한다.</p><h4>git config를 통해 체크하는 방법</h4><p>Python 프로그램을 git으로 관리한다는 전제 아래에 git config를 설정함으로서 문제를 해결할 수 있다. git에는 hook 이라는 것이 존재한다. hook은 git을 통해서 관리를 할때, 예를 들어, commit의 앞에 해야하는 일들 혹은 push 뒤에 해야하는 일들을 다양한 언어들을 통해서 작성하고 그 시점이 되었을때 작동되도록 하는 것이다.</p><pre>#!/usr/bin/env bash<br><br>git diff --cached | pep8 --diff</pre><p>단순하게 pre-commit 에 대한 스크립트를 짰다. 이를 project folder/.git/hooks/pre-commit 이라는 파일 이름으로 저장하도록 하면 커밋을 하기 전에 PEP8 형식에 맞는지 체크해줄 것이다.</p><h4>라이브러리를 통해 체크하는 방법</h4><p>Python의 문법을 체크하는 방법중 다양한 라이브러리들도 존재한다. 그 중에서도 Pylint(<a href="https://www.pylint.org/">https://www.pylint.org/</a>)라는 라이브러리를 이야기하려고 한다. Mac을 기준으로</p><pre>pip install pylint</pre><p>를 입력하면 설치는 완료된다. 또한 실행 방법은</p><pre>pylint [filename.py]</pre><p>라 입력하면 된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/653/1*mVKjJwRrSeuA1gaGh1r9EQ.png" /><figcaption>출처 : <a href="https://www.pylint.org/">https://www.pylint.org/</a></figcaption></figure><p>PEP8을 기준으로 코드를 분석하며 에러를 발생하는 부분에 대해서도 분석해준다. 결과 화면은 위의 이미지처럼 나오게 된다.</p><h4>PyCharm 에 한정되어 툴을 활용하는 방법</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Xrldb-TxneJu9QId2O3wxg.png" /><figcaption>PyCharm 내 Preference PEP8 관련 화면</figcaption></figure><p>PyCharm에서는 기본적으로 PEP8 형식을 맞출 수 있도록 지원하고 있다. (맥 기준) PyCharm — preferences 내 Editor — Inspections에 PEP8 코딩 스타일을 체크하는 부분이 존재한다. 또한 기본적으로 체크되어 있어 있다. 만약 체크되어 있지 않다면 이 항목들을 체크하기 바란다. 설정이 완료되면 가이드라인을 안 지켰을 시 이를 지키도록 툴이 안내해주고 있다.</p><h3>반드시 지킬 필요는 없다</h3><p>하지만 어느 규칙이나 예외는 존재한다. PEP8 또한 예외 사항을 갖고 있다. 먼저 가독성을 해치는 경우이다. 실제로 규칙을 따랐는데도 코드가 눈에 안 들어오는 경우들이 있다. PEP8은 실제 다른 사람들의 가독성과 나 자신의 가독성을 위해 쓰이는 이유가 존재하기 때문에 이런 상황에는 쓰지 않는 것이 맞다.</p><p>또 하나는 PEP8을 적용하는 와중일 때이다. 당연하게도 이전에 규칙이 적용이 안되어 있는 프로젝트에서 PEP8을 적용하기 시작하면 코드들이 혼재한 것은 당연하다. 이런 때도 인정되는 상황이다.</p><p>코드를 적용할때 PEP8이 당연하게 적용되야 하고 이전보다 적용한 이후가 반드시 좋다고 생각하면 안된다. 본인이 프로젝트에 PEP8을 적용할때 얼마만큼 효용성이 있는지 생각해보면서 적용해보기 바란다.</p><p>참조 :</p><ol><li><a href="http://www.hanul93.com/kicomav-pep8/">http://www.hanul93.com/kicomav-pep8/</a></li><li><a href="https://spoqa.github.io/2012/08/03/about-python-coding-convention.html">https://spoqa.github.io/2012/08/03/about-python-coding-convention.html</a></li></ol><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=88b1dafd539e" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[Android] Notification bar? Status bar?]]></title>
            <link>https://medium.com/@erish/android-notification-bar-status-bar-f39246a5d1cc?source=rss-ab5cb4aa4a47------2</link>
            <guid isPermaLink="false">https://medium.com/p/f39246a5d1cc</guid>
            <category><![CDATA[status-bar]]></category>
            <category><![CDATA[alarm]]></category>
            <category><![CDATA[notification-bar]]></category>
            <category><![CDATA[android]]></category>
            <category><![CDATA[ios]]></category>
            <dc:creator><![CDATA[Hosuk Shin]]></dc:creator>
            <pubDate>Mon, 03 Apr 2017 01:02:05 GMT</pubDate>
            <atom:updated>2017-04-03T01:02:05.947Z</atom:updated>
            <content:encoded><![CDATA[<p>몇개월만에 블로그에 글을 써 본다. 수많은 사건들이 있었기 때문에 글을 쓰지 못한 점, 먼저 죄송스럽다는 말씀부터 드린다. 나 자신과의 약속을 지키지 못하고 너무 오랜만에 글을 쓰게 된다. 그런 점에서 이번부터는 더욱 꾸준하게 글을 써보려 노력할 것이며 양은 적더라도 재밌고 알찬 내용들을 써보려 노력해보겠다.</p><p>사용자들이 스마트폰을 평소에 사용할 때 많이 보는 요소들이 있다. 홈 버튼부터 안드로이드의 은은하게 빛나는 LED, 알림 화면까지. 오늘은 그중에서도 알림바에 대해서 이야기해보려 한다.</p><h3>Notification bar, 너는 누구니</h3><h4>일단 뭐라 부르는지부터…</h4><p>안드로이드 개발자 혹은 아이폰 개발자가 많이 혼동하는 부분이다. 알림바에 대해서 부르려 하는데 이에 대한 정확한 용칭을 잘 알지 못하여 다양하게 부르게 된다. 한글로 알림바라고 부르기도 하고, status bar, notification bar까지 여러 용칭들이 혼재하고 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/624/1*vdDFvRa_ha-r7EBhfctFiw.png" /><figcaption>iOS에서는 status bar라고 불리운다 (이미지 : <a href="https://developer.apple.com/ios/human-interface-guidelines/ui-bars/status-bars/">https://developer.apple.com/ios/human-interface-guidelines/ui-bars/status-bars/</a>)</figcaption></figure><p>status bar는 iOS에서 불리는 용칭이다. (<a href="https://developer.apple.com/ios/human-interface-guidelines/ui-bars/status-bars/">1</a>) status bar 라고 불리는 이유는 휴대폰의 현재 상태를 알 수 있다는 의미를 부여하기 위해서 명칭된 것이다. 그렇기 때문에 인터넷 전파도부터 시간, 배터리의 용량이 보이는 것이다. 또한 한 발자국 더 들어가면, status bar이기 때문에 여러 다양한 알림들은 이 영역 안에서 보여주지 않고, status bar를 내리고 나서 알림 리스트 안에서 보여주는 이유도 위의 이유와 같다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/720/1*F28g0I4kF8sZOIBvVFKk6A.png" /><figcaption>android는 notification bar라고 불린다 (이미지 : <a href="https://material.io/guidelines/patterns/notifications.html#notifications-lock-screen">https://material.io/guidelines/patterns/notifications.html#notifications-lock-screen</a>)</figcaption></figure><p>안드로이드는 그럼 어떻게 불리울까? notification bar라고 불린다. (<a href="https://material.io/guidelines/patterns/notifications.html">2</a>) notification bar라고 불린다. 그렇기 때문에 iOS와 동일한 배터리 상태, 시간등은 오른쪽에 몰아 넣고 카카오톡부터 메세지나 여러가지 알림들이 이 notification bar 안에 나타나게 되어 있다.</p><h4>notification bar로 인하여 발생하는 문제들</h4><ul><li>사용자들이 통신사 로고를 지우려한다</li></ul><p>사용자 경험(User Experience)에 대한 문제이다. 사용자들은 notification bar에서 알림이 오면 지우고, 지워지지 않는 status로서의 정보들은 오른쪽에 있는 것에익숙하다. 하지만 유일하게 이 규칙에 안 맞는 것이 하나 있다. 그것은 바로 통신사 로고이다. 본인이 안드로이드 휴대폰을 사용중이라면 한번 유심히 확인해보기 바란다. 배터리 상태부터 시간이나 여러 지워지지 않는 정보들은 오른쪽에 몰려있는 것을 확인할 수 있다. 이와 동시에 통신사 로고만 동떨어져서 왼쪽에 박혀 있음을 알 수 있을 것이다. 그렇기 때문에 사용자들은 이를 버티지 못하고 ‘통신사 로고 없애기&#39;, ‘통신사 로고 지우기&#39;등을 찾는 이유는 앞서 말한 것 때문이다.</p><ul><li>언제 알람을 보내야 하는 것인가</li></ul><p>알람은 어플리케이션 운영자 입장에서는 참으로 유용한 도구이다. 알람을 보내면 사용자들이 일정 수준으로 모이기 때문이다. 하지만 구글은 알람을 ‘Notifications are intended to inform users about events in your app’이라 설명한다. 이 말인 즉슨, 자신의 어플리케이션을 사용할때 발생한 이벤트들을 사용자들에게 알려주기 위해 쓰이는 것이다. 만약 이 이외의 경우를 보낼때는 알람이 아닌, 스팸으로서의 의미로 작동되게 되는 것을 의미한다. 구글은 그 예시로,</p><ol><li>Cross-promotion / 타 어플리케이션에 대한 홍보</li><li>never opened / 한번도 사용하지 않은 사용자들에게 보내는 것</li><li>no direct value / 사용자들을 돌아오게 하는데 직접적 가치가 없는 것</li><li>rate an app / 평가해주세요 요청</li><li>Operations / 사용자들에게 굳이 안 알려줘도 되는 작동 기능들</li><li>Error states / 사용자와 사용작용이 없는데 알려지는 오류 메세지</li></ol><p>가 있다.</p><h4>결론은 Material Design Guidelines를 잘 참고하자</h4><p>그럼 어떻게 잘 쓰라는 것인가. Material Design Guidelines를 잘 보기를 권한다. 개발자임에도 어느정도 지식을 알고 있어야 이 기능이 건전한 작동인지, 만약 건전한 작동이 아니라면 이에 대한 위험을 사전에 말할 수 있어야 한다고 생각한다.</p><p>또한 한가지 팁은 개발할때 다른 서비스들은 알람을 통해서 어떤 형식으로 사용하고 있는지 관찰해보기 바란다. 서비스의 기획에 의해서 알람을 다른 형식으로 사용한다면 다행일 것이다. 하지만 다양한 고려 없이 다른 형식으로 사용하게 된다면, 가령 notification bar의 아이콘이 흰색이 아닌 일반 아이콘을 사용한다던지, 사용자 입장에서는 스팸 메세지로 인식되기 딱 좋은 모습이다.</p><ol><li><a href="https://developer.apple.com/ios/human-interface-guidelines/ui-bars/status-bars/">https://developer.apple.com/ios/human-interface-guidelines/ui-bars/status-bars/</a></li><li><a href="https://material.io/guidelines/patterns/notifications.html">https://material.io/guidelines/patterns/notifications.html</a></li></ol><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f39246a5d1cc" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[Android] 액티비티 스택에 관하여]]></title>
            <link>https://medium.com/@erish/andorid-%EC%95%A1%ED%8B%B0%EB%B9%84%ED%8B%B0-%EC%8A%A4%ED%83%9D%EC%97%90-%EA%B4%80%ED%95%98%EC%97%AC-66cc5b87d695?source=rss-ab5cb4aa4a47------2</link>
            <guid isPermaLink="false">https://medium.com/p/66cc5b87d695</guid>
            <category><![CDATA[material-design]]></category>
            <category><![CDATA[manifest-launch-mode]]></category>
            <category><![CDATA[android]]></category>
            <category><![CDATA[backstack]]></category>
            <category><![CDATA[tasks]]></category>
            <dc:creator><![CDATA[Hosuk Shin]]></dc:creator>
            <pubDate>Wed, 21 Sep 2016 05:05:03 GMT</pubDate>
            <atom:updated>2016-09-21T06:30:47.594Z</atom:updated>
            <content:encoded><![CDATA[<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FrrT6v5sOwJg%3Ffeature%3Doembed&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DrrT6v5sOwJg&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FrrT6v5sOwJg%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/5c80c3f6a66c81e1469df5665d6e1e9e/href">https://medium.com/media/5c80c3f6a66c81e1469df5665d6e1e9e/href</a></iframe><p>안드로이드는 종이접기와 같다. 안드로이드 매테리얼 디자인이 도입되며 사용자들에게 종이의 질감과 움직임을 주도록 가이드라인이 만들어졌다. 이로 인해 스마트폰 화면 속에 어플리케이션들이 실제 종이로 움직이듯이 행동하게 되었고, 이는 사용자의 경험이 높아지는 효과를 얻게 되었다.</p><p>그래서 나는 안드로이드의 새로운 화면을 노출시킬때, 화면을 쌓는다고 표현한다. 종이 위에 종이를 포개듯이 새로운 화면을 쌓는다. 하지만 안드로이드에서 화면을 관리하는 것은 생각 이상의 일이다.</p><h3>태스크와 백스택</h3><p>사용자의 인터페이스를 구성하는 기본 단위를 액티비티라 한다. 매테리얼 디자인에 빚대어 비유하면, 한 장의 도화지라 생각하면 용이하다. 한 장의 도화지 위에 글자들을 쓸 수도 있으며, 버튼들을 올릴수도 있다. 또한 액티비티들이 모여 하나의 어플리케이션으로 구성된다.</p><p>중요한 점은 하나의 어플리케이션에서 다른 어플리케이션의 액티비티를 사용할 수 있다는 것이다. 하나의 어플리케이션 내에서 다른 어플리케이션이 미리 만들어 놓은 종이(액티비티)를 빌려 쓸 수 있는 것이다. 예를 들어 내 어플리케이션에서 사진을 찍고 싶을 때 카메라 액티비티를 빌려 쓰는 것이 이에 해당한다.</p><p>여기서 태스크의 개념이 나오게 된다. 태스크란 특정 작업을 수행할 때 사용자와 상호작용하는 액티비티들의 모음이다. 그래서 하나의 태스크 안에 여러개의 어플리케이션 액티비티들이 쌓일 수 있다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/617/1*CcOHVVXoQ_7jF9CnsDWw7Q.png" /><figcaption>출처 : <a href="https://developer.android.com/guide/components/tasks-and-back-stack.html">https://developer.android.com/guide/components/tasks-and-back-stack.html</a></figcaption></figure><p>그리고 백스택은 액티비티가 열린 순서대로 스택에 정렬된다. 매테리얼 디자인에 비유하면, 새로 보여지는 종이(액티비티)에 맞춰 밑에 깔린 종이들(액티비티들)이라 이해하면 좋다.</p><h3>매니페스트 런치 모드</h3><p>그런데 액티비티들은 열리는 방식을 설정할 수 있다. 이것이 바로 매니페스트 런치 모드이다. 런치 모드에는 실제 4개가 존재하지만, 3개가 많이 쓰인다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/550/1*-cEgL5WDDZWk24GKr7Sn_A.png" /><figcaption>출처 : <a href="https://developer.android.com/guide/components/tasks-and-back-stack.html">https://developer.android.com/guide/components/tasks-and-back-stack.html</a></figcaption></figure><p>standard는 기본 설정이다. 액티비티는 여러 번 인스턴트화(생성)될 수 있고, 각 인스턴스는 서로 다른 태스크에 속할 수 있으며 한 작업에 여러 개의 인스턴스가 있을 수 있다.</p><p>singletop은 standard와 동일하나, 사용하고 있는 태스크 최상단에 이미 singletop이 적용된 액티비티가 있다면 이를 onNewIntent()를 사용하여 재사용한다. 매테리얼 디자인에 비유하면, 쓰고 있던 종이 뭉치(사용하고 있는 태스크) 맨 위에 사용하려는 종이가 있다면 다시 사용하고 없다면 새로운 종이를 사용한다고 이해하면 좋다.</p><p>singletask은 새 태스크의 루트에 액티비티를 생성한다. 만약 액티비티가 이미 존재하는 경우에는 이를 onNewIntent()를 사용하여 재사용한다. 매테리얼 디자인에 비유하면, 쌓여있는 종이 뭉치들(전체 태스크) 사이에 사용하려는 종이가 있다면 꺼내서 다시 사용하고 없다면 새로운 종이를 사용한다고 이해하면 좋다.</p><h3>인탠트 플래그</h3><p>그리고 각각의 종이(액티비티)마다 별개의 표시를 통해서 이전의 액티비티, 사용하고 있는 액티비티, 사용하게 될 액티비티에 대한 처리를 할 수 있다.</p><p>FLAG_ACTIVITY_SINGLE_TOP를 우선 설명해본다. A와 B 액티비티가 기존에 존재하고 새로운 B 액티비티를 실행시키려 한다. 플래그가 없이 실행을 시킨다면 B 액티비티 위에 다시 B 액티비티가 실행될 것이다. 하지만 FLAG_ACTIVITY_SINGLE_TOP 을 사용하게 된다면 기존에 실행시킨 B 액티비티를 재사용하게 될 것이다. 위에 설명드렸던 매니페스트 런치모드의 singleTop과 동일한 방식이다.</p><p>FLAG_ACTIVITY_NO_HISTORY는 다음과 같다. A와 B 액티비티를 기존에 실행시켰다고 가정해보자. 이전에 B 액티비티를 플래그 없이 실행을 시켰다면 새롭게 A 액티비티를 실행시키고 백버튼을 입력했을 경우, B 액티비티가 화면에 나오게 될 것이다. 하지만 FLAG_ACTIVITY_NO_HISTORY를 사용하게 되면, 새롭게 A 액티비티가 실행되었을 때 B 액티비티는 백스택에서 사라지게 된다. 최종적으로 백버튼을 입력하게 되면 화면에는 A 액티비티가 노출될 것이다.</p><p>태스크와 백스택 등에 대해 이해하기 어려운 면이 분명이 있다. 하지만 한번 이해를 하게 되면 이후 안드로이드 개발에 분명 도움이 될 것이다.</p><p>참조 :</p><ol><li><a href="https://developer.android.com/guide/components/tasks-and-back-stack.html">https://developer.android.com/guide/components/tasks-and-back-stack.html</a></li><li><a href="http://www.slideshare.net/luvgaram/activity-launch-mode">http://www.slideshare.net/luvgaram/activity-launch-mode</a></li><li><a href="http://m.blog.naver.com/mad_ai/130119521229">http://m.blog.naver.com/mad_ai/130119521229</a></li></ol><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=66cc5b87d695" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Python — 원숭이도 따라할 수 있는 크롤러 만들기]]></title>
            <link>https://medium.com/@erish/python-%EC%9B%90%EC%88%AD%EC%9D%B4%EB%8F%84-%EB%94%B0%EB%9D%BC%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%ED%81%AC%EB%A1%A4%EB%9F%AC-%EB%A7%8C%EB%93%A4%EA%B8%B0-6671bf445a4a?source=rss-ab5cb4aa4a47------2</link>
            <guid isPermaLink="false">https://medium.com/p/6671bf445a4a</guid>
            <category><![CDATA[web-crawler]]></category>
            <category><![CDATA[crawler]]></category>
            <category><![CDATA[python]]></category>
            <dc:creator><![CDATA[Hosuk Shin]]></dc:creator>
            <pubDate>Thu, 25 Aug 2016 07:21:42 GMT</pubDate>
            <atom:updated>2016-08-25T07:21:42.456Z</atom:updated>
            <content:encoded><![CDATA[<p>세상에는 엄청나게 방대한 정보들이 나뒹굴고 있다. 하지만 그것들을 일일이 확인하면서 나의 정보 리스트에 쌓는 것이란 거의 불가능에 가깝다. 예시로 AKB48의 멤버들의 산발적으로 발생하는 멤버들의 소식을 직접 수집하기는 힘들다. 하지만 나늘 대신해서 24시간 매일 확인을 해주는 녀석이 있다면 어떨까.</p><h3>크롤러란?</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*8J8yEexLEtXo7gI2GGEPoA.png" /><figcaption>구글 검색 크롤러는 엄청난 규모의 데이터를 확인하고 일련의 방식으로 정보를 가져오고 저장한다. 참조 : <a href="http://www.bloter.net/archives/166941">http://www.bloter.net/archives/166941</a></figcaption></figure><p>크롤링이란 단어는 ‘웹 페이지를 그대로 가져온 뒤, 가져온 내용을 기반으로 데이터를 추출해 내는 행위’라 한다. 이 방식을 이용해 구글이나 네이버는 전세계에 있는 여러 사이트들의 정보를 크롤러를 이용해서 가져온 뒤, 자신의 정보로 저장하여 검색을 할때 이전에 저장한 정보들을 확인하여 가져오는 것이다.</p><p>혹은 개인들이 대량의 웹사이트 정보를 가져올때, 특히 수작업으로 하기에는 너무나 작업량이 많을때, 크롤러를 이용하여 웹사이트에 있는 정보들을 가져와 저장하기도 한다.</p><p>그리하여 이 글은 간단하게 크롤러를 만든 것에 대해서 소개를 하고, 다른 이들도 이 글을 통해서 자신도 크롤러를 돌릴 수 있도록 하기 위하여 작성한다.</p><h4>lupin crawler 소개</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*VG8JLk6VPDzJXGqDm_axVQ.jpeg" /><figcaption>당신의 업무 시간을 웹툰을 이용하여 뺏을 크롤러, lupin crawler</figcaption></figure><p>회사에서는 웹툰의 알람을 받기란 참으로 어렵고 난감하다. 스마트폰을 이용하여 알람을 받을 수 있지만, 그러기 위해서는 휴대폰을 확인해야만 한다. 그렇다고 컴퓨터를 통해서 웹툰 알람을 받는 것은 서비스가 정식으로 되어 있는 것이 없기 때문에 힘들다.</p><p>이 와중에 회사(스타트업을 중심으로) 내에서 사용하는 메신저는 보통 Slack과 Jandi를 많이들 사용한다. 이 메신저들은 자신들의 API를 이용하여 직접 메세지를 전송할 수 있는 기능을 제공하고 있다.</p><p>이런 목표와 기술들을 이용하여 네이버 웹툰을 주기적으로 확인하여 변화가 생겼을 경우, 자신의 사내 메신저로 변화 사실을 보내 웹툰을 확인할 수 있는 lupin crawler를 만들어냈다.</p><h4>lupin crawler 구조 및 작동 방식</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*EVIiJCatZbR2HmXSXWmF9A.png" /><figcaption>lupin cralwer의 구조</figcaption></figure><p>lupin crawler의 구조는 단순하다.</p><p>BaseCrawler.py는 모든 크롤러들이 공통적으로 사용하는 기능들을 담아낸 클래스이다. 여기서 사이트에서 정보들을 가져오는 부분이 BaseCrawler.py 내에 존재한다.</p><p>HtmlCrawler.py는 사이트의 Html을 통해서 정보를 가져오는 기능을 담아낸 클래스이다. BaseCrawler.py를 통해서 정보들을 가져온 뒤, BeautifulSoup을 이용해서 Html의 태그, 클래스와 id등을 이용하여 찾고자 하는 부분을 추적할 수 있도록 하였다.</p><p>Crawlers.py는 BaseCrawler.py 혹은 HtmlCrawler.py 등을 이용하여 정보들을 수집하고자 하는 사이트의 목록들을 나열한 곳이다. 예를 들어 Crawlers.py 안에서 네이버 웹툰의 정보를 가져오는 클래스를 만든다. 이 클래스에는 어떠한 url을 통하여 정보를 가져올지, 어떠한 Crawler(BaseCrawler.py, HtmlCrawler.py등)을 이용하여 정보를 가져올지, 최종적으로 어떠한 부분을 확인하여 새로운 웹툰이 올라왔는지 결정을 하여 목록으로 변환하여 반환할지를 결정한다.</p><p>LupinCrawler.py 가 메인 클래스로서 크롤러의 작동, 메신저 전송, 상황 확인 기능을 담당하고 있다. 이전의 Crawlers.py에서 목록들을 모두 가져와서 초기화한뒤, 정보들을 가져오고 목록으로 저장한다. 매 시간마다 확인하여 이전 목록과 변화점이 있으면 사내 메신저(Slack, Jandi)로 메세지를 발송하는 것이다.</p><p>자신이 매일 확인하고자 하는 사이트를 이 기본적인 크롤러가 대신하여 체크할 수 있을 것이다. 혹은 가져온 정보를 데이터베이스에 저장하는 크롤러로도 변형을 시킬 수 있을 것이다. 실제 코드는 <a href="https://github.com/erishforG/lupin_crawler">https://github.com/erishforG/lupin_crawler</a>에 있다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6671bf445a4a" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Android — 안드로이드 빌드 환경 구성하기 feat.Jenkins]]></title>
            <link>https://medium.com/@erish/android-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%B9%8C%EB%93%9C-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0-feat-jenkins-84db5873d7d8?source=rss-ab5cb4aa4a47------2</link>
            <guid isPermaLink="false">https://medium.com/p/84db5873d7d8</guid>
            <category><![CDATA[jenkins-ci]]></category>
            <category><![CDATA[android]]></category>
            <category><![CDATA[jenkins]]></category>
            <dc:creator><![CDATA[Hosuk Shin]]></dc:creator>
            <pubDate>Wed, 20 Jul 2016 02:36:27 GMT</pubDate>
            <atom:updated>2016-07-20T02:36:27.374Z</atom:updated>
            <content:encoded><![CDATA[<p>안드로이드를 빌드하는 방법은 무수하게 많다. 자신의 노트북에서 안드로이드 스튜디오를 이용하여 단순하게 빌드하는 것부터 Gradle을 세팅하여 개발 버전과 릴리즈 버전을 빌드하는 방법, CI 툴들을 이용하여 빌드하는 방법까지 있다.</p><p>문제는 안드로이드를 개인적으로 만드는 것을 넘어서 회사 차원에서 여러가지 안드로이드 버전들을 관리하기 시작하는 순간, 자원적으로나 시간적으로 노트북으로 처리하는 것에서 한계가 생기게 된다. 그래서 CI 툴, 특히 Jenkins를 이용하여 배포하는 방법에 대하여 이야기 해보려 한다.</p><h3>Jenkins CI는 무엇인가</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/676/1*fiOou8ZYaZe-Ka8NUyovMw.png" /><figcaption>모든것을 다 해줄것만 같은 인자한 모습의 Jenkins</figcaption></figure><p>Jenkins란 오픈소스 CI 툴로써 팀원들이 작성한 코드 내용을 정기적으로 혹은 비정기적으로 통합하는 것을 의미한다. 애초에 ‘허드슨’ 이라는 이름으로 사용하고 있었지만, 2010년 오라클과의 상표권 문제로 인해 Jenkins로 이름이 바뀌게 되었다.</p><p>특히 Jenkins를 사용함으로써</p><ol><li>빌드가 정상적으로 되는지</li><li>유닛테스트를 이용하여 코드가 정상적으로 구현되고 있는지</li></ol><p>확인할 수 있다. 그리고 이 모든것을 자신의 노트북을 이용해서 빌드하면서 기다리는 것이 아닌, 서버를 통해서 빌드하여 업무를 병행 진행할 수 있다.</p><h3>Jenkins CI 도전해보자</h3><p>Jenkins CI을 조성한 환경을 먼저 안내하고자 한다.</p><blockquote>서버 : AWS EC2 T2 medium / Ubuntu Server 14.04 LTS</blockquote><blockquote>Jenkins : jenkins 2.13</blockquote><p>AWS EC2 T2 medium으로 선택한 이유는 안드로이드를 빌드할때 일정 수준 이상의 메모리를 사용하게 되는데, 최소 총용량 4GB 가 필요한것을 실제 테스트해보면서 알게 되었기 때문이다.</p><p>최소한의 설정을 통해, Jenkins를 이용하여, 안드로이드를 빌드하는 것을 목표로 한다. 모든 설명은 우분투를 기준으로 설명할 예정이다.</p><h4>Jenkins 설치하기</h4><p><a href="https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins+on+Ubuntu">https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins+on+Ubuntu</a>의 안내에 따라, 다음과 같이 명령어를 터미널에 입력한다.</p><blockquote>$ wget -q -O — http://pkg.jenkins-ci.org/debian/jenkins-ci.org.key | sudo apt-key add -</blockquote><blockquote>$ sudo sh -c ‘echo deb http://pkg.jenkins-ci.org/debian binary/ &gt; /etc/apt/sources.list.d/jenkins.list’</blockquote><blockquote>$ sudo apt-get update &amp;&amp; sudo apt-get install jenkins</blockquote><p>그럼 자신의 서버 IP:8080 주소를 통해서 Jenkins 웹페이지로 접속이 가능하다.</p><h4>Android SDK 설치하기</h4><p>Android SDK는 다른 사이트들의 설명을 보면, GUI를 이용해 설치하는 것이 보통이다. 하지만 AWS 혹은 Azure 과 같은 클라우드 플랫폼등을 이용해 서버를 이용하게 되면 GUI가 아닌 터미널을 이용해서 모든 것을 설정해야 한다. <a href="https://developer.android.com/studio/index.html">https://developer.android.com/studio/index.html</a>에서 안내한대로 최신 버전 24.4.1 버전을 다운받아 풀도록 한다.</p><blockquote>$ cd /var/lib/jenkins</blockquote><blockquote>$ sudo wget <a href="http://dl.google.com/android/android-sdk_r22.3-linux.tgz">http://dl.google.com/android/</a><a href="https://dl.google.com/android/android-sdk_r24.4.1-linux.tgz">android-sdk_r24.4.1-linux.tgz</a></blockquote><blockquote>$ sudo tar zxvf <a href="https://dl.google.com/android/android-sdk_r24.4.1-linux.tgz">android-sdk_r24.4.1-linux.tgz</a></blockquote><blockquote>$ rm <a href="https://dl.google.com/android/android-sdk_r24.4.1-linux.tgz">android-sdk_r24.4.1-linux.tgz</a></blockquote><p>이후에 안드로이드 SDK를 구성하도록 한다.</p><blockquote>$ cd /android-sdk-linux(안드로이드 SDK 폴더 이동)/tools</blockquote><blockquote>$ ./android list sdk — all</blockquote><p>위의 명령어를 이용하게 되면 Android SDk의 모든 목록들이 번호와 함게 나오게 된다. 자신의 Android 빌드 환경에 맞게 번호들을 적은 후</p><blockquote>$ sudo ./android update sdk -u -a -t &lt;패키지 번호 적기(ex) 1, 2, 3…&gt;</blockquote><p>를 터미널에 입력하면 SDK가 구성된다.</p><p>최종적으로 Jenkins가 Android SDK가 설치된 곳을 알기 위해 PATH 환경변수를 등록해야 한다.</p><blockquote>$ sudo vi /etc/profile.d/android.sh</blockquote><pre>export ANDROID_HOME=&quot;/var/lib/jenkins/android-sdk-linux&quot;</pre><pre>export PATH=&quot;$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$PATH&quot;</pre><blockquote>$ source /etc/profile</blockquote><h3>Jenkins 및 자신의 안드로이드 gradle 설정하기</h3><p>이제 Jenkins와 자신의 안드로이드 gradle을 설정하면 끝이다. 일반적으로 자신의 코드를 github에서 많이 관리하기 때문에, github에서 자신의 코드를 가져와 Jenkins를 통해 빌드하는 방법을 설명할 것이다.</p><h4>github에 있는 자신의 코드를 가져오기 위한 사용자 인증</h4><p>github에서 자신의 코드를 가져오려면, 특히 private repository 일 경우, 사용자를 github한테서 인증받아야 가져올 수 있다.</p><p>메인 페이지에서 Credentials-System-Global Credentials를 눌러, 후에 좌측에 있는 Add Credentials를 클릭하게 되면 다음과 같은 화면이 나오게 된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*frGdoU_eaKjeoee31e4JJg.png" /><figcaption>Credentials-System-Global Credentials-Add Credentials를 클릭한 화면</figcaption></figure><p>Username과 Id에 자신의 github 계정을, password에 자신의 github 비밀번호를 입력하고 저장하도록 한다.</p><p>이후에 터미널에서 다음과 같은 명령어를 입력하도록 한다.</p><blockquote>$ ssh-keygen -t rsa -N ‘’ -f ~/.ssh/id_rsa</blockquote><blockquote>$ cat ~/.ssh/id_rsa.pub</blockquote><p>그럼 github에 등록할 public key가 나오게 된다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1007/1*WsDp8SSQE-1oo2mvH5G0xQ.png" /><figcaption>github의 자신의 repository-Settings-Deploy keys를 클릭한 화면</figcaption></figure><p>자신이 가져오려는 github repository-settings-deploy keys 에 이전에 발급받은 public key를 그대로 복사하여 붙여넣기 하면 된다.</p><h4>Jenkins 설정하기</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/358/1*X3E9zCLB52Z7H-yN8cG0xQ.png" /><figcaption>상단에 있는 새로운 Item을 클릭하도록 하자</figcaption></figure><p>Jenkins 웹페이지에 들어오게 되면 새로운 Item을 클릭하도록 한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*VoAi0HzSr-XCmV8hatQOPA.png" /><figcaption>Freestyle project를 클릭하도록 하자</figcaption></figure><p>FreeStyle Project를 클릭하도록 한다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*YA9mQMnxM_B84tO3YxDLww.png" /><figcaption>Freestyle project를 생성하기 위한 설정 화면</figcaption></figure><ol><li>github project를 클릭하면 자신의 repository 주소를 적을 수 있다.</li><li>소스 코드 관리를 git으로 설정하고, 자신의 repository 주소를 입력하고, 위에서 설정했던 자신의 계정을 Credentials에 설정한다. 정상적으로 작동하면 어떠한 경고도 아래에 뜨지 않을 것이다.</li><li>빌드 유발 방법은 자신의 취향에 맞는 방법으로 설정한다</li><li>Build는 Invoke Gradle Script를 이용한다. 내부에 있는 Use Gradle Wrapper 을 클릭하며, Tasks에서 자신이 원하는 gradle 빌드 명령어를 입력하도록 한다.</li><li>빌드 후 조치 또한 자신의 취향에 맞는 방법으로 설정한다.</li></ol><p>이제 Jenkins에 관한 모든 설정은 끝났고, 서버에서 자신의 안드로이드 코드가 빌드만 된다면 Jenkins가 github에 있는 안드로이드 코드를 가져와 빌드될 것이다.</p><p>여기서부터는 gradle과 자신의 코드에 따라서 모든 것의 승패가 달려있다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=84db5873d7d8" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Android — 당신의 앱에 인앱결제를 쉽게 붙이는 방법]]></title>
            <link>https://medium.com/@erish/android-%EB%8B%B9%EC%8B%A0%EC%9D%98-%EC%95%B1%EC%97%90-%EC%B9%B4%EB%93%9C-%EA%B2%B0%EC%A0%9C%EB%A5%BC-%EC%89%BD%EA%B2%8C-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-b349fccd866c?source=rss-ab5cb4aa4a47------2</link>
            <guid isPermaLink="false">https://medium.com/p/b349fccd866c</guid>
            <category><![CDATA[android-app-development]]></category>
            <category><![CDATA[webview]]></category>
            <category><![CDATA[creditmodule]]></category>
            <category><![CDATA[credit-cards]]></category>
            <category><![CDATA[android]]></category>
            <dc:creator><![CDATA[Hosuk Shin]]></dc:creator>
            <pubDate>Sun, 19 Jun 2016 06:12:58 GMT</pubDate>
            <atom:updated>2016-07-20T02:47:31.884Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/500/1*jAXHAPdAO6uypH3zKjD6JA.png" /><figcaption>신용카드 결제, 안드로이드 어플리케이션에서는 너무나 어렵고 머나먼 이야기라고 생각했다</figcaption></figure><p>모든 서비스는 일정 수준을 넘게 되면 직접 판매를 하거나 혹은 마케팅을 통해 상품을 파는 것에 대해 고민하기 시작한다. 이 중에서 안드로이드 어플리케이션은 결제시키기 위한 방법이 크게 두가지가 있다. 하나는 직접 결제모듈을 붙여 이를 달성시키는 방법과 또 하나는 이를 우회하여 결제모듈을 직접 쓰지는 않았지만 결제가 되게 만드는 방법. 여기서 이야기하게 될 것은 직접 결제 모듈 회사들과 논의를 거치지 안고 우회해서 결제시키기 위한 방법을 연구하고 있는 사람들을 위해 써보려 한다.</p><h3>핵심은 WebView, Intent 그리고 노가다</h3><p>우선 사이트에 접속한다는 전제조건이 있는데, 이를 위해서는 WebView가 필요하게 된다.</p><h4>WebView란?</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*XRiNjKivOYIkzqK3BmLeBw.png" /><figcaption>안드로이드 5.0(Lollipop)부터 웹뷰는 하나의 어플리케이션이다</figcaption></figure><p><a href="http://www.androidcentral.com/android-webview-security">http://www.androidcentral.com/android-webview-security</a>에 따르면, 웹뷰는 안드로이드 OS에서 거의 모든 안드로이드 앱들 안에 웹 페이지를 렌더링할때 필요한 요소라고 소개하고 있다.</p><p>여러 앱들의 사용 사례를 인용하면, 공지사항에서 텍스트와 이미지를 같이 불러오면서도 HTML 태그들을 이용하여 작성하거나 실제 웹 페이지를 렌더링하기 위해서 사용하고 있다.</p><p>하지만 웹뷰는 다른 요소들보다도 불안정한 요소들이 많았고, 웹페이지를 렌더링한다는 것에 대한 자원을 많이 잡아먹는 부분들이 있었다. 구글도 이를 인지하여, <a href="https://developer.chrome.com/multidevice/webview/overview">https://developer.chrome.com/multidevice/webview/overview</a>에 안내된 내용에 따르면, 안드로이드 4.4(Kitkat)부터 Chromium 오픈 소스 프로젝트에 포함되어 업데이트된 V8 자바스크립트을 쓰기 시작했다. 안드로이드 5.0(Lollipop)에서는 아예 별도의 앱으로 분리되어 별도의 업데이트가 주기적으로 이루어지고 있다.</p><h4>WebViewClient</h4><p>WebViewClient란 HTML링크를 클릭할때 등의 렌더링이 필요할때 호출되는 클래스이다. Url Intercept 또한 여기서 가능하다. 내부에는 수많은 함수들을 이용할 수 있지만 대표적인 것들은 아래와 같다.</p><ul><li>public void onPageStarted(WebView view, String url, Bitmap favicon)</li></ul><p>페이지 로딩이 시작되는 것을 알리는 메소드.</p><ul><li>public void onLoadResource(WebView view, String url)</li></ul><p>WebView가 주어진 URL로 지정된 리소스를 로드할 것이라 알림을 받는 메소드. 여러번 나뉘어 호출되게 됩니다.</p><ul><li>public void onPageFinished(WebView view, String url)</li></ul><p>페이지 로딩이 완료된 것을 알림을 받는 메소드.</p><ul><li>public boolean shouldOverrideUrlLoading(WebView view, String url)</li></ul><p>이 중에서도 제일 중요하고 저희가 쓰게 될, 새로운 URL이 현재 WebView에 로드되려고 할 때 어플리케이션에게 컨트롤을 대신할 기회를 주는 메소드. 만약 어플리케이션이 직접 처리를 진행한다면 이에 대해서 true 값을 반환하며, 그렇지 않을 경우 false를 반환하게 된다.</p><h4>Intent</h4><p>shouldOverrideUrlLoading 함수에서는 WebView 자신과 Url을 파라미터로 넘김을 받게 됩니다. 이때, Url이 결제를 위한 창으로 넘어갈 때는 http:// 나 https://, javascript: 주소를 갖고 있지 않으며 각자 결제 모듈에 대한 스키마를 갖고 있다.</p><p>그렇기 때문에 이에 대해서 단순하게 처리할 경우에는</p><pre>Intent.<em>parseUri</em>(url, Intent.<em>URI_INTENT_SCHEME</em>);</pre><p>라는 형식을 통해서 Intent를 넘기면 간단하게 끝나게 된다. 조금 더 심화 처리를 하게 될 경우, ISP 결제를 예를 들때, ISP 결제는 최종 결제의 마무리 작업은 다시 자신의 앱이서 결제가 완료가 되었다는 확인을 해야 최종적으로 결제가 완료되었음을 사용자에게 인식시킬 수 있다. 그렇기 때문에 사용자에게 마지막 결제 마무리가 자신의 앱으로 돌아와야 한다는 것을 인식시키기 위해 창을 띄워야 한다.</p><pre>if(url.contains(&quot;ispmobile&quot;)) {<br>    Intent ispIntent = new Intent(context, paydialog.class);<br>    ispIntent.putExtra(&quot;url&quot;, url);<br>    context.startActivity(ispIntent);<br>    return true;<br>}</pre><p>그래서 ispmobile 스키마가 포함되었는지 확인하고, 자신이 만든 다이얼로그창에 url을 다시 한번 넘기면서 창을 띄우는 방법이 있다.</p><p>그 이외의 결제도 크게는 이 방식을 따르게 되며, 혹시 사용자가 이 스키마를 갖고 있지 않을 경우에는 구글 플레이스토어로 결제 모듈을 설치하라고 이동시킬 수 도 있다.</p><h3>이제 당신의 앱에도 결제 모듈을?!</h3><p>앱의 규모가 크거나 직접 결제 모듈사와 컨택을 통해서 붙일 수 있다면 베스트겠지만, 그렇지 못할 경우에는 이 방식이 많은 도움을 줄 것이라 생각하고 있다. 또한 저도 이와 같은 방식을 통해서 해결을 하고 있다.</p><p>이 부분을 해결한 것을 <a href="https://github.com/erishforG/wing-browser">https://github.com/erishforG/wing-browser</a> 를 통해서 git에도 오픈해 놓았다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b349fccd866c" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>