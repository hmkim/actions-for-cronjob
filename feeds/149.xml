<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="https://elky84.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://elky84.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2019-03-17T07:30:28+00:00</updated><id>https://elky84.github.io/feed.xml</id><title type="html">Elky Essay</title><subtitle>web &amp; socket programming. and...</subtitle><author><name>Elky Kim</name></author><entry><title type="html">C++ 게임 서버 개발자의 웹 프론트엔드 적응기</title><link href="https://elky84.github.io/2019/03/17/cpp_game_developer_to_web_frontend_developer/" rel="alternate" type="text/html" title="C++ 게임 서버 개발자의 웹 프론트엔드 적응기" /><published>2019-03-17T00:00:00+00:00</published><updated>2019-03-17T00:00:00+00:00</updated><id>https://elky84.github.io/2019/03/17/cpp_game_developer_to_web_frontend_developer</id><content type="html" xml:base="https://elky84.github.io/2019/03/17/cpp_game_developer_to_web_frontend_developer/">&lt;p&gt;다른 언어도 몇년간 실무에 썼음에도, 난 아직도 C++이 아직도 가장 익숙한 언어다.&lt;/p&gt;

&lt;p&gt;C++을 제외하고, 내가 가장 적응하기 쉬웠던 다른 언어는 C#과 루비다.&lt;/p&gt;

&lt;p&gt;사실 파이썬은 indent 강제에 대한 거부감이 크게 작용해서 기피했었는데, 막상 업무상 필요해서 써보니 indent 강제는 장점도 많았고, 루비와 비슷한 측면도 꽤 많아서 (다른 측면도 매우 많지만) 쉽게 적응할 수 있었다.&lt;/p&gt;

&lt;p&gt;사실 의외로 자바는 적응하기 힘들었는데, 이는 다른 글에서 몇 번 언급한 자바 개발자들의 문화와 규칙 때문이었다. 하지만, 이는 게임 서버도 나름의 규칙과 접근, 룰이 이해할 수 있는 부분이었다.&lt;/p&gt;

&lt;p&gt;또 다른 어려웠던 점은 자바의 발전 속도가 더뎌 다른 언어에서 이미 사용하던 기능 여럿을 쓸 수 없었고, 어노테이션 같은 확장 기능으로 커버해도 여타 언어만큼 편의성을 제공하지도 못한 자바를 (타의로) 사용하게 되고 나서 보니, 불편함 덩어리라서 굳이 이걸 각 잡고 배워야하는 가에 대한 회의감도 함께 했음을 고백한다.&lt;/p&gt;

&lt;p&gt;여하튼 그렇게 웹 개발, 플랫폼 개발에 발을 들였는데 처음 발을 들였을 때는 플랫폼과 백엔드 작업으로 한정짓다보니 자바에 비중이 높았고, 시간이 약이라고 나도 자바에 어느정도는 익숙해져가고 있었다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;그러던 와중 합류한 팀에서 1-tier 개발을 한다고 하더라. 그래서 자바 스크립트도 배워야 했는데, 나는 Jscript(https://ko.wikipedia.org/wiki/J%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8)라는 Java Script의 윈도우 스크립트 엔진으로 써본게 다였다보니, 조금 걱정이 됐다.&lt;/p&gt;

&lt;p&gt;다행히 Admin Tool 작업을 몇번 하다가, 본격적으로 frontend 작업을 하게 됐는데, 이 마저도 몇번의 작업은 국지적인 수정이라서 다행이었다.&lt;/p&gt;

&lt;p&gt;하지만 무언가 수정 사항이나 기능 개발, 이슈 확인을 위해선 자바 스크립트 코드를 읽어야 되는 상황을 맞이하게 됐고, 이 부담감을 지워내기 위해 본격적인 학습에 돌입했다.&lt;/p&gt;

&lt;p&gt;그렇게 만든 것이 Community Board (https://github.com/elky84/community_board) 였다.
Vue.js를 팀 내부적으로 사용하고 있었고, 나도 이에 맞춰 복습 및 경험치 획득을 위해 만들게 됐다.&lt;/p&gt;

&lt;p&gt;이렇게 데브 토이로 Vue.js를 썼음에도, 자바 스크립트 자체에 대한 낮은 숙련도는 계속 업무적 비효율로 이어지고 있었고, 스트레스의 원인 중 하나가 됐다.&lt;/p&gt;

&lt;p&gt;그러던 차에 업무적으로 진행된 서비스 하나가, backend/frontend 중에 선택 가능한 상황이 됐고, 나는 여기서 자바스크립트 숙련도 향상을 위해 frontend를 선택하게 됐다.&lt;/p&gt;

&lt;p&gt;그 결과 확실히 거부감이 많이 줄어들었고, 익숙해졌고, 그만큼 많은 감상이 들었다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;자바 스크립트 자체는 linter가 없인 너무 큰 자유도로 코드 가독성이 들쭉날쭉해지기 쉽상이라는 것.
    &lt;ul&gt;
      &lt;li&gt;이를 해소하기 위한 방법으로 linter와 framework를 사용함으로써 팀 규칙대로 코드를 작성하게 (반)강제하고, 다양한 스타일의 난립을 억제하려 하는 것 같다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자바 스크립트 자체는 아직도 불편하지만, lodash 같은 편의성 높은 패키지로 대체하고, module counts (http://www.modulecounts.com/) 의 최다 패키지 보유 플랫폼 답게, 수많은 기능을 가져다 사용해서 개발 공수를 낮출 수 있다는 것
    &lt;ul&gt;
      &lt;li&gt;download 카운트가 높다고해서, 딱히 완성도 있거나, 깔끔하게 동작하지만은 않았다.&lt;/li&gt;
      &lt;li&gt;초기에 만들어진 패키지라 다운로드 수가 많고, 이후에도 낚인 사람이 많아서 높은 download 수인 경우가 많으니 이 점에 주의하라.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;웹 프론트엔드에선 (변환기로써 구현되는 경우를 제외하면) 사실상 javascript가 필수나 다름없다보니 javascript 자체에 익숙해지려고 노력해온게 frontend 개발자 다수의 선택이고, 그렇다보니 javascript 자체의 점유율이 늘고 있다.
    &lt;ul&gt;
      &lt;li&gt;앞으로의 javascript 성장세는 미지수지만, frontend에서라도 확고한 위치는 확실하다는 것&lt;/li&gt;
      &lt;li&gt;개인적으로는 backend에서의 성장세는 꺾였고, 더 늘진 않을 것이라고 생각한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;JSON을 다루는 것이 너무나도 편하다는 것.
    &lt;ul&gt;
      &lt;li&gt;애초에 Java Script Object Notation의 약자가 말해주듯, 다루기 너무 쉽다. 다른 동적언어보다도 훨씬 쉽다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;역시 동적 언어는 까다롭다는 점.
    &lt;ul&gt;
      &lt;li&gt;여러 번 언급한 얘기지만, 동적 언어는 테스트 코드로 이를 커버해야 한다.&lt;/li&gt;
      &lt;li&gt;하지만 아래에 언급할 프론트엔드가 단위 테스트를 작성하기 상대적으로 까다롭고, 내가 익숙하지 못한 이유도 있다.&lt;/li&gt;
      &lt;li&gt;또한 단위 테스트로 커버를 한다고 해도, 정적 언어보다 실수할 여지, 놓치는 부분이 있을 여지는 압도적으로 많다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자동화 테스트에 대한 해결책은 아직 갖추지 못했다. 남들은 다 잘 하는 것 같은데, 내 프론트엔드 테스트 코드는 제로에 가깝다.
    &lt;ul&gt;
      &lt;li&gt;이는 자바 스크립트의 문제라기 보단, 프론트엔드 단위 테스트, 자동화 테스트가 로직 테스트보다 어려운 문제에 가깝다.&lt;/li&gt;
      &lt;li&gt;아직 이 문제에 대한 완벽한 해결책을 갖지 못한 것이 큰 아쉬움.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;결과적으로 아주 좋은 경험이었는데, 내가 가진 자바스크립트라는 언어 자체에 대한 편견을 조금 내려 놓는다면, 그만큼 많은 성장과 시야가 넓어지는 계기가 될 수 있을 거라는 생각이 들었다.
또한 아직은 몇가지 편견을 버리지 못했다. 언어적 한계로, backend에 어울리지 못하는 언어라는 생각. Node.js처럼 학습 코스트는 높을대로 높고, 언어적 한계는 명확히 가졌고, 자유도 마저 쥐어줘서 생기는 복잡도에 대한 리스크가 내가 가진 편견이다.
이 편견을 과연 깰 수 있을지는 잘 모르겠다. 나는 아직도 여전히, 프레임워크가 도와준다해도 동적 언어가 가질 수 있는 안정성은 한계가 있다고 생각하기 때문이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;반면 frontend로 한정 짓는다면 패키지를 조합해서 해결 할 수 있는 문제가 아주 많았다. 프레임워크도 훌륭하고, 관련한 레퍼런스나 질의 응답도 많아서, 해결책이 존재하는 편이었다. HTML 코드와 자바스크립트 코드간의 연동도 프레임워크가 적정선으로 끌어내려준 느낌을 확실히 받을 수 있었다.
과거의 노가다스러웠다던 frontend 개발을 모르지만, 적어도 지금의 frontend 개발 환경은 충분히 장점이 많았다. Webpack의 도움도 아주 아주 편하고 좋은 개발 환경에 보탬이 됐다고 할 수 있겠다.&lt;/p&gt;

&lt;p&gt;아직은 내가 frontend 개발자라는 말을 꺼내기엔 경험치도, 이해도도 부족하지만, 그럼에도 서비스 하나에 frontend를 온전히 구현하고 나서의 감상을 꼭 한번 정리하고 싶었다.&lt;/p&gt;

&lt;p&gt;내가 게임 클라이언트에서도 재미를 느꼈던 만큼, frontend도 꽤나 재밌었다.&lt;/p&gt;

&lt;p&gt;두번째, 세번째 경험도, 또 요구 사항이 조금 더 복잡한 경험도 해보고 싶을 만큼 재밌는 요소가 많았기에, 멀지 않은 시기에 다음 기회도 있었으면 하는 바램이다.&lt;/p&gt;</content><author><name>Elky Kim</name></author><category term="게임개발" /><category term="웹개발" /><summary type="html">다른 언어도 몇년간 실무에 썼음에도, 난 아직도 C++이 아직도 가장 익숙한 언어다. C++을 제외하고, 내가 가장 적응하기 쉬웠던 다른 언어는 C#과 루비다. 사실 파이썬은 indent 강제에 대한 거부감이 크게 작용해서 기피했었는데, 막상 업무상 필요해서 써보니 indent 강제는 장점도 많았고, 루비와 비슷한 측면도 꽤 많아서 (다른 측면도 매우 많지만) 쉽게 적응할 수 있었다. 사실 의외로 자바는 적응하기 힘들었는데, 이는 다른 글에서 몇 번 언급한 자바 개발자들의 문화와 규칙 때문이었다. 하지만, 이는 게임 서버도 나름의 규칙과 접근, 룰이 이해할 수 있는 부분이었다. 또 다른 어려웠던 점은 자바의 발전 속도가 더뎌 다른 언어에서 이미 사용하던 기능 여럿을 쓸 수 없었고, 어노테이션 같은 확장 기능으로 커버해도 여타 언어만큼 편의성을 제공하지도 못한 자바를 (타의로) 사용하게 되고 나서 보니, 불편함 덩어리라서 굳이 이걸 각 잡고 배워야하는 가에 대한 회의감도 함께 했음을 고백한다. 여하튼 그렇게 웹 개발, 플랫폼 개발에 발을 들였는데 처음 발을 들였을 때는 플랫폼과 백엔드 작업으로 한정짓다보니 자바에 비중이 높았고, 시간이 약이라고 나도 자바에 어느정도는 익숙해져가고 있었다. 그러던 와중 합류한 팀에서 1-tier 개발을 한다고 하더라. 그래서 자바 스크립트도 배워야 했는데, 나는 Jscript(https://ko.wikipedia.org/wiki/J%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8)라는 Java Script의 윈도우 스크립트 엔진으로 써본게 다였다보니, 조금 걱정이 됐다. 다행히 Admin Tool 작업을 몇번 하다가, 본격적으로 frontend 작업을 하게 됐는데, 이 마저도 몇번의 작업은 국지적인 수정이라서 다행이었다. 하지만 무언가 수정 사항이나 기능 개발, 이슈 확인을 위해선 자바 스크립트 코드를 읽어야 되는 상황을 맞이하게 됐고, 이 부담감을 지워내기 위해 본격적인 학습에 돌입했다. 그렇게 만든 것이 Community Board (https://github.com/elky84/community_board) 였다. Vue.js를 팀 내부적으로 사용하고 있었고, 나도 이에 맞춰 복습 및 경험치 획득을 위해 만들게 됐다. 이렇게 데브 토이로 Vue.js를 썼음에도, 자바 스크립트 자체에 대한 낮은 숙련도는 계속 업무적 비효율로 이어지고 있었고, 스트레스의 원인 중 하나가 됐다. 그러던 차에 업무적으로 진행된 서비스 하나가, backend/frontend 중에 선택 가능한 상황이 됐고, 나는 여기서 자바스크립트 숙련도 향상을 위해 frontend를 선택하게 됐다. 그 결과 확실히 거부감이 많이 줄어들었고, 익숙해졌고, 그만큼 많은 감상이 들었다. 자바 스크립트 자체는 linter가 없인 너무 큰 자유도로 코드 가독성이 들쭉날쭉해지기 쉽상이라는 것. 이를 해소하기 위한 방법으로 linter와 framework를 사용함으로써 팀 규칙대로 코드를 작성하게 (반)강제하고, 다양한 스타일의 난립을 억제하려 하는 것 같다. 자바 스크립트 자체는 아직도 불편하지만, lodash 같은 편의성 높은 패키지로 대체하고, module counts (http://www.modulecounts.com/) 의 최다 패키지 보유 플랫폼 답게, 수많은 기능을 가져다 사용해서 개발 공수를 낮출 수 있다는 것 download 카운트가 높다고해서, 딱히 완성도 있거나, 깔끔하게 동작하지만은 않았다. 초기에 만들어진 패키지라 다운로드 수가 많고, 이후에도 낚인 사람이 많아서 높은 download 수인 경우가 많으니 이 점에 주의하라. 웹 프론트엔드에선 (변환기로써 구현되는 경우를 제외하면) 사실상 javascript가 필수나 다름없다보니 javascript 자체에 익숙해지려고 노력해온게 frontend 개발자 다수의 선택이고, 그렇다보니 javascript 자체의 점유율이 늘고 있다. 앞으로의 javascript 성장세는 미지수지만, frontend에서라도 확고한 위치는 확실하다는 것 개인적으로는 backend에서의 성장세는 꺾였고, 더 늘진 않을 것이라고 생각한다. JSON을 다루는 것이 너무나도 편하다는 것. 애초에 Java Script Object Notation의 약자가 말해주듯, 다루기 너무 쉽다. 다른 동적언어보다도 훨씬 쉽다. 역시 동적 언어는 까다롭다는 점. 여러 번 언급한 얘기지만, 동적 언어는 테스트 코드로 이를 커버해야 한다. 하지만 아래에 언급할 프론트엔드가 단위 테스트를 작성하기 상대적으로 까다롭고, 내가 익숙하지 못한 이유도 있다. 또한 단위 테스트로 커버를 한다고 해도, 정적 언어보다 실수할 여지, 놓치는 부분이 있을 여지는 압도적으로 많다. 자동화 테스트에 대한 해결책은 아직 갖추지 못했다. 남들은 다 잘 하는 것 같은데, 내 프론트엔드 테스트 코드는 제로에 가깝다. 이는 자바 스크립트의 문제라기 보단, 프론트엔드 단위 테스트, 자동화 테스트가 로직 테스트보다 어려운 문제에 가깝다. 아직 이 문제에 대한 완벽한 해결책을 갖지 못한 것이 큰 아쉬움. 결과적으로 아주 좋은 경험이었는데, 내가 가진 자바스크립트라는 언어 자체에 대한 편견을 조금 내려 놓는다면, 그만큼 많은 성장과 시야가 넓어지는 계기가 될 수 있을 거라는 생각이 들었다. 또한 아직은 몇가지 편견을 버리지 못했다. 언어적 한계로, backend에 어울리지 못하는 언어라는 생각. Node.js처럼 학습 코스트는 높을대로 높고, 언어적 한계는 명확히 가졌고, 자유도 마저 쥐어줘서 생기는 복잡도에 대한 리스크가 내가 가진 편견이다. 이 편견을 과연 깰 수 있을지는 잘 모르겠다. 나는 아직도 여전히, 프레임워크가 도와준다해도 동적 언어가 가질 수 있는 안정성은 한계가 있다고 생각하기 때문이다. 반면 frontend로 한정 짓는다면 패키지를 조합해서 해결 할 수 있는 문제가 아주 많았다. 프레임워크도 훌륭하고, 관련한 레퍼런스나 질의 응답도 많아서, 해결책이 존재하는 편이었다. HTML 코드와 자바스크립트 코드간의 연동도 프레임워크가 적정선으로 끌어내려준 느낌을 확실히 받을 수 있었다. 과거의 노가다스러웠다던 frontend 개발을 모르지만, 적어도 지금의 frontend 개발 환경은 충분히 장점이 많았다. Webpack의 도움도 아주 아주 편하고 좋은 개발 환경에 보탬이 됐다고 할 수 있겠다. 아직은 내가 frontend 개발자라는 말을 꺼내기엔 경험치도, 이해도도 부족하지만, 그럼에도 서비스 하나에 frontend를 온전히 구현하고 나서의 감상을 꼭 한번 정리하고 싶었다. 내가 게임 클라이언트에서도 재미를 느꼈던 만큼, frontend도 꽤나 재밌었다. 두번째, 세번째 경험도, 또 요구 사항이 조금 더 복잡한 경험도 해보고 싶을 만큼 재밌는 요소가 많았기에, 멀지 않은 시기에 다음 기회도 있었으면 하는 바램이다.</summary></entry><entry><title type="html">게임 서버 개발과 웹 서버 개발의 차이</title><link href="https://elky84.github.io/2019/03/17/game_server_develop_difference_web_server_develop/" rel="alternate" type="text/html" title="게임 서버 개발과 웹 서버 개발의 차이" /><published>2019-03-17T00:00:00+00:00</published><updated>2019-03-17T00:00:00+00:00</updated><id>https://elky84.github.io/2019/03/17/game_server_develop_difference_web_server_develop</id><content type="html" xml:base="https://elky84.github.io/2019/03/17/game_server_develop_difference_web_server_develop/">&lt;p&gt;늘 궁금했다. 웹 개발이란 어떤 것인지.&lt;/p&gt;

&lt;p&gt;물론 이것저것 관심이 많다 보니, 임베디드, 보안, 인공지능 등 대부분 관심이 많지만, 좀 더 대중화 되고 컨텐츠 개발에서 주류에 있는 웹개발은 조금 더 궁금했다.&lt;/p&gt;

&lt;p&gt;사실상 책 따라하기 수준의 방명록, 게시판 정도론 웹 개발자들이 어떻게 생각하고, 무엇을 중요시 여기고, 어떤 것을 잘해야 하고, 어떻게 일하는지 알 수 없었다.&lt;/p&gt;

&lt;p&gt;그저 짐작을 할 뿐이나, 웹알못이 짐작하는 수준이라곤 게임 서버도 보이지 않는 backend 관점이니, 웹 백엔드와 큰 차이가 없을거라고 생각했다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;결론부터 말하자면, 비슷하면서도 아주 많은 간극을 보인다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;특히 문제를 해결하는 방법, 중요시 여기는 가치, 기본기라 여기는 기준들 너무 많은 것이 달랐다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;약간 과장해서, 다른 직업이라고 느껴질 정도로 달랐다. (과장이라고 표현했으나 나는 이렇게 생각하고 있다. 임베디드, 웹, 보안, 플랫폼, 게임 등…각 분야가 의외로 많은 차이를 보인다고 생각한다.)&lt;/p&gt;

&lt;p&gt;왜 이런 차이가 생기는 걸까?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;웹의 발전은 브라우저 기반위에서 이루어졌다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;브라우저라함은 HTML 파서이자 뷰어라 할 수 있는데, 브라우저가 소화 가능한 규격으로만 통신해야 함을 의미한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이를 주고 받기 위한 HTTP 프로토콜이 반론의 여지가 없는 표준이었다. 웹표준과 별개로 HTTP 프로토콜은 웹에선 빠르고, 당연하게 표준으로 자리 잡았다.&lt;/p&gt;

&lt;p&gt;초창기 성능이나 네트웍 속도에 제약으로, 정적 페이지를 적극 사용했는데, 이는 소수의 관리자가 컨텐츠를 편집했기에 가능한 접근이었다.&lt;/p&gt;

&lt;p&gt;반면 게임 서버는 커스텀한 클라이언트 프로그램인 게임을 위해 발전해왔다.
브라우저라는 제약이 없었고, 그러므로 반드시 HTTP 프로토콜을 사용할 필요는 없었다. 그렇다 보니, HTTP 프로토콜에서 소요되는 cost마저 아끼고 싶어했다. (소켓을 직접 통제하고, 헤더와 인증, 보안 처리 모두 커스텀하게 처리했음을 말한다.)&lt;/p&gt;

&lt;p&gt;또한 HTTP 프로토콜의 특징인 connectionless, stateless는 게임에 어울리지 않았다.&lt;/p&gt;

&lt;p&gt;이는 아래서 설명할 반응성이 웹보다 훨씬 중요하기 때문이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;당시에도 그랬고, 지금도 게임은 반응성이 웹보다 훨씬 더 중요한 분야다. connection을 맺고 끊는 비용, connection이 생성되고 필요한 작업을 위해 매번 db를 질의하는 비용 모두 줄여서라도 반응성을 유지하는 것이 더 중요했다.&lt;/p&gt;

&lt;p&gt;그렇다보니 표준이 아닌, 게임 마다 다른 TCP 프로토콜 위에 게임별 프로토콜이 각기 다른 모습으로 구현됐다.&lt;/p&gt;

&lt;p&gt;동적 컨텐츠인 게임은, 웹처럼 다수의 사용자에게 유사한 HTML 코드를 동일하게 전송할 수 없었고, 실시간으로 변동되는 데이터를 다뤄야했기에, 다른 방향으로 발전했다.&lt;/p&gt;

&lt;p&gt;요새의 게임 개발에선 아닌 경우가 더 많아 졌지만, 내가 처음 게임 개발에 입문했을 때만해도, 패킷 만들 때 최소한의 비트를 사용하고, 어셈코드로 렌더링하며, 메모리 정렬 단위를 계산하며, 복사 연산을 최소화 하기 위한 코딩을 했어야 했다.&lt;/p&gt;

&lt;p&gt;이는 제한된 서버 자원을 잘 활용해야만 동접이 높은 게임을 만들 수 있기 때문이다. 그 게임 내에서 수많은 동작이 실시간으로 이루어지는데, 이 로직들을 최대한 가볍게 짜고, 의도치 않은 큰 연산이 일어나지 않아야 렉이 생기지 않기 때문이다.&lt;/p&gt;

&lt;p&gt;실제로 온라인 게임의 렉(latency)은 대부분 네트워크 환경으로 인한 문제보다는 서버 내부의 로직이 도는 시간보다 더 많은 처리 요청이 발생해 처리가 밀리면서 발생한 현상이었다. 멀티스레드로 구현하면서, 블러킹 포인트를 만들어 생기는 경우도 없었다고 할순 없겠다.&lt;/p&gt;

&lt;p&gt;이는 패킷을 처리하고, 사용자에게 응답하기 까지의 시간을 유지하지 못하면 응답성이 떨어지며, 이 응답성이 게임 클라이언트가 허용한 범주보다 늦어지게 되면 사용자는 렉을 느끼게 된다. 이를 해결하는 방향성 중 하나는 모든 연산을 최저치로 낮출 수 있는 데로 낮추는 접근이었다고 말할 수 있겠다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;반응속도와 함께, 데이터 무결성을 보장해주어야 한다. 게임 사용자는 조금의 지연도 용납해주지 않는다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;내가 조금전 획득한 아이템이 10초후에 인벤토리에 들어온다고 치자. 사용자들은 바로 불편함과 우려를 표할 것이다. 아이템 시스템에 오류가 생긴것이 아닐까 불안해하며, 자신이 획득할 아이템에 대한 신뢰도마저 의심하곤 한다.&lt;/p&gt;

&lt;p&gt;마찬가지로, 내가 싸우는 몬스터의 HP 감소가 10초후에 이루어진다면? 내 체력도 10초후에 감소 된다면? 사용자들은 해당 게임이 정상적이지 않고, 문제가 있다고 인지하는 상황이 된다.&lt;/p&gt;

&lt;p&gt;그리고 만약 재접속 아이템 보상이 들어온다면? 현재 내 아이템 상황과, 내 눈에 보이는 상황이 달랐을 때 사용자들은 이 상황을 문제라고 인지하게 된다. 아마도 디아블로2의 복사 아이템 사건등을 겪은 사용자들이, 이런 현상이 아이템 복사 등으로 이어질지 모른다는 불안감도 한몫 해서 불안함을 갖기도 한다.&lt;/p&gt;

&lt;p&gt;지연적인 아이템, 상태 반영이 해당 게임의 시스템적으로 구성되어있다면, 불편함과 비직관성으로 큰 비판을 받게될 요소다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;반면 웹은 실제 디비에서 처리되고 있는 데이터보다 조금 예전 데이터를 주더라도 크게 문제 삼지 않는다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;그렇다보니 캐싱이 더 쉬워지고, 브라우저도 캐싱을 하며, 사용자도 이를 인정하고 새로운 데이터를 전달 받기 위해 새로고침을 직접 한다. (사용자들 마저 이 과정을 불쾌감으로, 오류로 받아들이지 않고 자연스럽게 받아들이는 것이 포인트다.)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이는 훨씬 더 많은 사용자에게 컨텐츠를 제공하는 방향으로 발전할 수 있는 원동력이 되기도 했다. 캐싱과 스케일아웃이 유연할 수 있는 근거는, 지금 언급한 조금의 지연이 있는 데이터, 혹은 소수의 사용자가 편집한 데이터를 전달하는 것도 용인 될 수 있는 웹 환경이 그 근거다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;애초에 데이터의 변화량/응답속도가 너무나도 중요한 가치인 게임과, 생산성/확장성이 더 중요한 웹은 궤를 달리 할 수 밖에 없었던 운명이었던 걸지도 모른다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이제와서 서로 간의 기술 융합과 응용이 이루어지고 있는 모습은 아주 긍정적이라고 생각한다. 이 흐름이 상대적으로 서버의 역할을 한정 지었던 모바일 게임에서의 웹 서버 기반의 서비스였긴 하지만, 그렇게 많은 게임 서버 개발자들이 웹 이해도가 늘었다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;다시금 모바일 게임도 MMORPG붐이 일면서, C++, C# TCP 게임 서버가 다시금 도입되고 있다. 최근 몇년간 게임 개발을 하고 있지 않아서 정확히 말하긴 어렵지만, 커스텀 게임 서버만으로 모든 컨텐츠를 만들어오던 과거와는 달리 이제는 적절한 지점에 웹서버도 이용하지 않을까 싶은 생각도 든다.&lt;/p&gt;

&lt;p&gt;트랜잭션 위주의 로직 서버로 웹 서버는 탁월한 선택이 될 수 있다. 또한 인게임 컨텐츠 중 일부(예를 들어 인게임 공략, 공지사항, 상점, 광고, 일부 이벤트 등)의 경우 웹 서버를 통해 구현하면 훨씬 더 수월하게 구현 가능하기도 하다.&lt;/p&gt;

&lt;p&gt;또한, 게임마다 다른 내부 구조를 이해하지 않고도, 사용되는 웹 프레임워크만 이해하는 사람도, 부분적인 분업도 가능해지므로 이 또한 협업과 분업의 메리트가 생길 수 있는 부분이다.&lt;/p&gt;

&lt;p&gt;또한 성능상의 이슈에서 상대적으로 자유로울 수 있는 컨텐츠 위주로 웹 서버를 이용한다면, 생산성 좋은 언어, 프레임워크를 선정할 수 있다는 장점도 있다.&lt;/p&gt;

&lt;p&gt;그렇게 유연한 선택을 통해, 안정성과 생산성을 얻을 수 있다면, 좀 더 고민이 많이 필요하고, 시간이 많이 필요한 작업에서 필요한 시간을 버는 데에 쓸 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;게임 서버는 특수성으로 인해 웹서버만으로 모든 시스템을 구축/운용 하는 것도 안되고, 커스텀 TCP 서버는 생산성이 너무 떨어진다. 이제는 게임 서버 개발에서도 폴리글랏 아키텍쳐가 필요할 때가 아닐까?&lt;/strong&gt;&lt;/p&gt;</content><author><name>Elky Kim</name></author><category term="게임개발" /><category term="웹개발" /><summary type="html">늘 궁금했다. 웹 개발이란 어떤 것인지. 물론 이것저것 관심이 많다 보니, 임베디드, 보안, 인공지능 등 대부분 관심이 많지만, 좀 더 대중화 되고 컨텐츠 개발에서 주류에 있는 웹개발은 조금 더 궁금했다. 사실상 책 따라하기 수준의 방명록, 게시판 정도론 웹 개발자들이 어떻게 생각하고, 무엇을 중요시 여기고, 어떤 것을 잘해야 하고, 어떻게 일하는지 알 수 없었다. 그저 짐작을 할 뿐이나, 웹알못이 짐작하는 수준이라곤 게임 서버도 보이지 않는 backend 관점이니, 웹 백엔드와 큰 차이가 없을거라고 생각했다. 결론부터 말하자면, 비슷하면서도 아주 많은 간극을 보인다. 특히 문제를 해결하는 방법, 중요시 여기는 가치, 기본기라 여기는 기준들 너무 많은 것이 달랐다. 약간 과장해서, 다른 직업이라고 느껴질 정도로 달랐다. (과장이라고 표현했으나 나는 이렇게 생각하고 있다. 임베디드, 웹, 보안, 플랫폼, 게임 등…각 분야가 의외로 많은 차이를 보인다고 생각한다.) 왜 이런 차이가 생기는 걸까? 웹의 발전은 브라우저 기반위에서 이루어졌다. 브라우저라함은 HTML 파서이자 뷰어라 할 수 있는데, 브라우저가 소화 가능한 규격으로만 통신해야 함을 의미한다. 이를 주고 받기 위한 HTTP 프로토콜이 반론의 여지가 없는 표준이었다. 웹표준과 별개로 HTTP 프로토콜은 웹에선 빠르고, 당연하게 표준으로 자리 잡았다. 초창기 성능이나 네트웍 속도에 제약으로, 정적 페이지를 적극 사용했는데, 이는 소수의 관리자가 컨텐츠를 편집했기에 가능한 접근이었다. 반면 게임 서버는 커스텀한 클라이언트 프로그램인 게임을 위해 발전해왔다. 브라우저라는 제약이 없었고, 그러므로 반드시 HTTP 프로토콜을 사용할 필요는 없었다. 그렇다 보니, HTTP 프로토콜에서 소요되는 cost마저 아끼고 싶어했다. (소켓을 직접 통제하고, 헤더와 인증, 보안 처리 모두 커스텀하게 처리했음을 말한다.) 또한 HTTP 프로토콜의 특징인 connectionless, stateless는 게임에 어울리지 않았다. 이는 아래서 설명할 반응성이 웹보다 훨씬 중요하기 때문이다. 당시에도 그랬고, 지금도 게임은 반응성이 웹보다 훨씬 더 중요한 분야다. connection을 맺고 끊는 비용, connection이 생성되고 필요한 작업을 위해 매번 db를 질의하는 비용 모두 줄여서라도 반응성을 유지하는 것이 더 중요했다. 그렇다보니 표준이 아닌, 게임 마다 다른 TCP 프로토콜 위에 게임별 프로토콜이 각기 다른 모습으로 구현됐다. 동적 컨텐츠인 게임은, 웹처럼 다수의 사용자에게 유사한 HTML 코드를 동일하게 전송할 수 없었고, 실시간으로 변동되는 데이터를 다뤄야했기에, 다른 방향으로 발전했다. 요새의 게임 개발에선 아닌 경우가 더 많아 졌지만, 내가 처음 게임 개발에 입문했을 때만해도, 패킷 만들 때 최소한의 비트를 사용하고, 어셈코드로 렌더링하며, 메모리 정렬 단위를 계산하며, 복사 연산을 최소화 하기 위한 코딩을 했어야 했다. 이는 제한된 서버 자원을 잘 활용해야만 동접이 높은 게임을 만들 수 있기 때문이다. 그 게임 내에서 수많은 동작이 실시간으로 이루어지는데, 이 로직들을 최대한 가볍게 짜고, 의도치 않은 큰 연산이 일어나지 않아야 렉이 생기지 않기 때문이다. 실제로 온라인 게임의 렉(latency)은 대부분 네트워크 환경으로 인한 문제보다는 서버 내부의 로직이 도는 시간보다 더 많은 처리 요청이 발생해 처리가 밀리면서 발생한 현상이었다. 멀티스레드로 구현하면서, 블러킹 포인트를 만들어 생기는 경우도 없었다고 할순 없겠다. 이는 패킷을 처리하고, 사용자에게 응답하기 까지의 시간을 유지하지 못하면 응답성이 떨어지며, 이 응답성이 게임 클라이언트가 허용한 범주보다 늦어지게 되면 사용자는 렉을 느끼게 된다. 이를 해결하는 방향성 중 하나는 모든 연산을 최저치로 낮출 수 있는 데로 낮추는 접근이었다고 말할 수 있겠다. 반응속도와 함께, 데이터 무결성을 보장해주어야 한다. 게임 사용자는 조금의 지연도 용납해주지 않는다. 내가 조금전 획득한 아이템이 10초후에 인벤토리에 들어온다고 치자. 사용자들은 바로 불편함과 우려를 표할 것이다. 아이템 시스템에 오류가 생긴것이 아닐까 불안해하며, 자신이 획득할 아이템에 대한 신뢰도마저 의심하곤 한다. 마찬가지로, 내가 싸우는 몬스터의 HP 감소가 10초후에 이루어진다면? 내 체력도 10초후에 감소 된다면? 사용자들은 해당 게임이 정상적이지 않고, 문제가 있다고 인지하는 상황이 된다. 그리고 만약 재접속 아이템 보상이 들어온다면? 현재 내 아이템 상황과, 내 눈에 보이는 상황이 달랐을 때 사용자들은 이 상황을 문제라고 인지하게 된다. 아마도 디아블로2의 복사 아이템 사건등을 겪은 사용자들이, 이런 현상이 아이템 복사 등으로 이어질지 모른다는 불안감도 한몫 해서 불안함을 갖기도 한다. 지연적인 아이템, 상태 반영이 해당 게임의 시스템적으로 구성되어있다면, 불편함과 비직관성으로 큰 비판을 받게될 요소다. 반면 웹은 실제 디비에서 처리되고 있는 데이터보다 조금 예전 데이터를 주더라도 크게 문제 삼지 않는다. 그렇다보니 캐싱이 더 쉬워지고, 브라우저도 캐싱을 하며, 사용자도 이를 인정하고 새로운 데이터를 전달 받기 위해 새로고침을 직접 한다. (사용자들 마저 이 과정을 불쾌감으로, 오류로 받아들이지 않고 자연스럽게 받아들이는 것이 포인트다.) 이는 훨씬 더 많은 사용자에게 컨텐츠를 제공하는 방향으로 발전할 수 있는 원동력이 되기도 했다. 캐싱과 스케일아웃이 유연할 수 있는 근거는, 지금 언급한 조금의 지연이 있는 데이터, 혹은 소수의 사용자가 편집한 데이터를 전달하는 것도 용인 될 수 있는 웹 환경이 그 근거다. 애초에 데이터의 변화량/응답속도가 너무나도 중요한 가치인 게임과, 생산성/확장성이 더 중요한 웹은 궤를 달리 할 수 밖에 없었던 운명이었던 걸지도 모른다. 이제와서 서로 간의 기술 융합과 응용이 이루어지고 있는 모습은 아주 긍정적이라고 생각한다. 이 흐름이 상대적으로 서버의 역할을 한정 지었던 모바일 게임에서의 웹 서버 기반의 서비스였긴 하지만, 그렇게 많은 게임 서버 개발자들이 웹 이해도가 늘었다. 다시금 모바일 게임도 MMORPG붐이 일면서, C++, C# TCP 게임 서버가 다시금 도입되고 있다. 최근 몇년간 게임 개발을 하고 있지 않아서 정확히 말하긴 어렵지만, 커스텀 게임 서버만으로 모든 컨텐츠를 만들어오던 과거와는 달리 이제는 적절한 지점에 웹서버도 이용하지 않을까 싶은 생각도 든다. 트랜잭션 위주의 로직 서버로 웹 서버는 탁월한 선택이 될 수 있다. 또한 인게임 컨텐츠 중 일부(예를 들어 인게임 공략, 공지사항, 상점, 광고, 일부 이벤트 등)의 경우 웹 서버를 통해 구현하면 훨씬 더 수월하게 구현 가능하기도 하다. 또한, 게임마다 다른 내부 구조를 이해하지 않고도, 사용되는 웹 프레임워크만 이해하는 사람도, 부분적인 분업도 가능해지므로 이 또한 협업과 분업의 메리트가 생길 수 있는 부분이다. 또한 성능상의 이슈에서 상대적으로 자유로울 수 있는 컨텐츠 위주로 웹 서버를 이용한다면, 생산성 좋은 언어, 프레임워크를 선정할 수 있다는 장점도 있다. 그렇게 유연한 선택을 통해, 안정성과 생산성을 얻을 수 있다면, 좀 더 고민이 많이 필요하고, 시간이 많이 필요한 작업에서 필요한 시간을 버는 데에 쓸 수 있을 것이다. 게임 서버는 특수성으로 인해 웹서버만으로 모든 시스템을 구축/운용 하는 것도 안되고, 커스텀 TCP 서버는 생산성이 너무 떨어진다. 이제는 게임 서버 개발에서도 폴리글랏 아키텍쳐가 필요할 때가 아닐까?</summary></entry><entry><title type="html">(내맘대로 선정한) 프로그래머를 위한 필독서 두번째</title><link href="https://elky84.github.io/2019/03/03/a_must_read_books_02/" rel="alternate" type="text/html" title="(내맘대로 선정한) 프로그래머를 위한 필독서 두번째" /><published>2019-03-03T00:00:00+00:00</published><updated>2019-03-03T00:00:00+00:00</updated><id>https://elky84.github.io/2019/03/03/a_must_read_books_02</id><content type="html" xml:base="https://elky84.github.io/2019/03/03/a_must_read_books_02/">&lt;p&gt;&lt;a href=&quot;/2018/07/05/a_must_read_books/&quot;&gt;지난 번 글&lt;/a&gt;에 이어, 2번째 필독서 추천을 해보고자 한다.&lt;/p&gt;

&lt;p&gt;지난번에 16선으로 추리면서, 포함되지 못한 서적과 최근 지인들에게 추천해준 책들 위주로 골라보았다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Joel On Software &amp;amp; More Joel On Software&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Trello와, 사업적 영역을 담당했지만 stack overflow로 더 유명한 조엘.&lt;/li&gt;
      &lt;li&gt;그의 통찰력 있는 개발에 대한 철학과 철칙을 배울 수 있는 멋진 서적이다.
        &lt;ul&gt;
          &lt;li&gt;처음 읽었던게 2005년인데, 주기적으로 읽을 때 마다 더 많은 걸 공감하고, 느껴지는게 많아지는 좋은 책이다.&lt;/li&gt;
          &lt;li&gt;애초에 그가 블로그에 쓴 글 중 일부러 옮겨온 만큼, 좋은 개발자는 어때야 하며, 좋은 개발팀은 어때야 하고, 좋은 회사는 좋은 개발자를 위해 무엇을 해야 하는지 뚜렷하게 제시했고, 합당했다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;소프트웨어 장인&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;큰 기대를 하지 않고 봤으나, 꽤나 괜찮은 내용이 많았다.&lt;/li&gt;
      &lt;li&gt;다만 현재 상황이 어떤가에 개의치 않고, 너는 잘해야되 라는 내용이 많아서, 꼰대같은 내용이라는 생각이 들 수도 있는 책이었다.&lt;/li&gt;
      &lt;li&gt;내 생각과 동일한 부분은 환경이 사람을 만든다는 말도 맞지만, 환경이 여의치 않더라도 내 자신을 발전 시켜놔야 더 좋은 환경을 내가 만들 수도, 그 환경을 쟁취할 수도 있다고는 생각한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Effective 시리즈&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;저자는 다르지만, C++의 scott meyers씨처럼 저명한 분들이 각 언어로 저술해주고 있는 언어의 철학, 깊이를 충족 시켜줄 수 있는 좋은 서적이다.&lt;/li&gt;
      &lt;li&gt;C++만해도, Effective C++, More Effective C++, Modern Effective C++ 3권이나 있고, Effective Java, Effective C# 등의 서적이 존재하는데, 해당 언어를 좀 더 이해하고 싶다면 꼭 읽어보는 것이 좋다고 생각한다.
        &lt;ul&gt;
          &lt;li&gt;저자가 다른데도 퀄리티가 준수한 것은, 애초에 언어의 문화, 철학에 대한 이해를 돕는 주제 자체가 좋은 거 같기도 하다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;C로 배우는 알고리즘 1 &amp;amp; 2&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;특정 언어에 편중된 책은 가급적 추천을 하고 싶지 않지만, 자료 구조와 알고리즘의 기초 언어로 가장 적합한 것이 C언어이다보니, 추천을 하게 됐다.
        &lt;ul&gt;
          &lt;li&gt;나 역시 대학 교재의 부족한 설명과 모호한 설명을, 이 책이 대신해줬다.
            &lt;ul&gt;
              &lt;li&gt;두고 두고 기억에 남는 자료 구조 및 알고리즘 기초 서적이라고 볼 수 있다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;린 소프트웨어 개발&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;애자일 개발서라지만, 실제론 효율론에 가깝다고 볼 수 있다.&lt;/li&gt;
      &lt;li&gt;수많은 애자일 방법론 서적이 있지만, 그 중에 가장 와닿고, 효율에 대해 다시 생각할 수 있는 거리들도 많아서 큰 도움이 된 서적이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;피플웨어&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;요즘 들어 많이 중요하다고 더 느껴지는 책이다.&lt;/li&gt;
      &lt;li&gt;목표 지향적, 결과 중시 적어도 한국의 게임 회사에서, IT 회사에선 너무 많이 봤다.&lt;/li&gt;
      &lt;li&gt;조직의 동기부여에는 실패해놓고, 왜 열정이 없느냐고, 자신이 만들고 있는 제품을 사랑하지 않느냐고?
        &lt;ul&gt;
          &lt;li&gt;애사심이라는 것이 어떻게 생기는 것이고, 그것이 어떤 결과를 가져다 주는지 고민해봐야 하는 사람들 (관리자, 경영진)이 읽어봤으면 좋겠는 책.
            &lt;ul&gt;
              &lt;li&gt;하지만 그 들은 이런 책 읽지 않겠지….&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;사랑하지 않으면 떠나라&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;절판 된 서적이라 구하기 쉽지 않겠지만, 나는 개발자 들이라면 꼭 한번은 읽었으면 좋겠다고 생각하는 책이다.&lt;/li&gt;
      &lt;li&gt;꽤나 많은 개발자들이 곰같다. 둔하고 무던하고, 변화를 두려워한다.&lt;/li&gt;
      &lt;li&gt;그래서 불편하고, 괴롭고, 동기부여가 부족함에도 자신의 문제로 치부하고 묵묵히 일한다.
        &lt;ul&gt;
          &lt;li&gt;그렇다고 최상의 결과나, 좀 더 나아진 결과를 내는 데에도 실패한다.
            &lt;ul&gt;
              &lt;li&gt;왜냐면 이미 일은 일이 되어버렸고, 열정은 사그라졌지만 별다른 대안을 찾기에 두려움도 존재해 현실에 안주하기 때문이다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;또한 회사의 선택과 회사에서의 자신의 포지션, 자신의 업무가 그 회사에서 어떤 가치를 가지는 업무인지 등에 대한 다양한 생각을 가질 수 있게 도와준다.&lt;/li&gt;
      &lt;li&gt;책 제목이 강하게 번역되서 그렇지, 실제론 이직 추천서, 이직 종용서는 아니고 회사 생활을 좀 더 가치있고, 즐겁게, 동기부여 되어 업무에서의 성취감을 찾을 수 있게 도와주는 자기 개발서라고 보는 것이 더 옳다.&lt;/li&gt;
      &lt;li&gt;제목에 대한 편견을 버릴 수 있다면, 어떠한 마음가짐으로 개발자로써의 회사 생활을 맞이해야 하는지 판단에 도움을 줄 책이라고 생각한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;해커와 화가&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;해커 (뛰어난 프로그래머. 프로그래밍 그 과정 자체를 즐기는 사람이라는 의미가 강하게 사용됨)를 화가에 비유하는 독특한 시점으로 쓰여진 책.&lt;/li&gt;
      &lt;li&gt;역자 서문에서 임백준씨도 밝히지만, 책 곳곳에서 느껴지는 오만하게 보일 수 있는 보수적인 관점이 불편할 수도 있다.&lt;/li&gt;
      &lt;li&gt;다만 프로그래밍을 온전히 즐기고자 했을 때, 어떠한 부분이 화가의 그것과 비슷한 지에 대한 그의 생각은 흥미로웠다.&lt;/li&gt;
      &lt;li&gt;프로그래머를 단순 공돌이로만 치부하기도 하는 현실도 무시하기 힘든 건 사실이지만, 프로그래밍에 대한 개념을 좀 더 독특한 관점에서 말해주기에, 그런 생각이 꽤 많은 프로그래머들에게 자극이었고, 발상의 전환에 도움이 될 좋은 이단스러운 책이라고 생각한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;전반적으로 측정 언어에 편중된 책은 배제하려다보니, 인문학 관점에 가까운 책들을 더 많이 추천한 것 같다.&lt;/p&gt;

&lt;p&gt;특정 언어에 편중된 책들 중에서 좋은 책을 추천하고 싶었는데, 아무래도 &lt;strong&gt;프로그래머&lt;/strong&gt; 필독서로는 애매한게 아닌가 싶더라.&lt;/p&gt;

&lt;p&gt;C++, C#, Java 등의 특정 언어에 편중된 서적은 따로 작성하는 것이 맞겠다는 싶더라. 다음 필독서 모음은 그렇게 작성해보겠다.&lt;/p&gt;</content><author><name>Elky Kim</name></author><category term="필독서" /><summary type="html">지난 번 글에 이어, 2번째 필독서 추천을 해보고자 한다. 지난번에 16선으로 추리면서, 포함되지 못한 서적과 최근 지인들에게 추천해준 책들 위주로 골라보았다. Joel On Software &amp;amp; More Joel On Software Trello와, 사업적 영역을 담당했지만 stack overflow로 더 유명한 조엘. 그의 통찰력 있는 개발에 대한 철학과 철칙을 배울 수 있는 멋진 서적이다. 처음 읽었던게 2005년인데, 주기적으로 읽을 때 마다 더 많은 걸 공감하고, 느껴지는게 많아지는 좋은 책이다. 애초에 그가 블로그에 쓴 글 중 일부러 옮겨온 만큼, 좋은 개발자는 어때야 하며, 좋은 개발팀은 어때야 하고, 좋은 회사는 좋은 개발자를 위해 무엇을 해야 하는지 뚜렷하게 제시했고, 합당했다. 소프트웨어 장인 큰 기대를 하지 않고 봤으나, 꽤나 괜찮은 내용이 많았다. 다만 현재 상황이 어떤가에 개의치 않고, 너는 잘해야되 라는 내용이 많아서, 꼰대같은 내용이라는 생각이 들 수도 있는 책이었다. 내 생각과 동일한 부분은 환경이 사람을 만든다는 말도 맞지만, 환경이 여의치 않더라도 내 자신을 발전 시켜놔야 더 좋은 환경을 내가 만들 수도, 그 환경을 쟁취할 수도 있다고는 생각한다. Effective 시리즈 저자는 다르지만, C++의 scott meyers씨처럼 저명한 분들이 각 언어로 저술해주고 있는 언어의 철학, 깊이를 충족 시켜줄 수 있는 좋은 서적이다. C++만해도, Effective C++, More Effective C++, Modern Effective C++ 3권이나 있고, Effective Java, Effective C# 등의 서적이 존재하는데, 해당 언어를 좀 더 이해하고 싶다면 꼭 읽어보는 것이 좋다고 생각한다. 저자가 다른데도 퀄리티가 준수한 것은, 애초에 언어의 문화, 철학에 대한 이해를 돕는 주제 자체가 좋은 거 같기도 하다. C로 배우는 알고리즘 1 &amp;amp; 2 특정 언어에 편중된 책은 가급적 추천을 하고 싶지 않지만, 자료 구조와 알고리즘의 기초 언어로 가장 적합한 것이 C언어이다보니, 추천을 하게 됐다. 나 역시 대학 교재의 부족한 설명과 모호한 설명을, 이 책이 대신해줬다. 두고 두고 기억에 남는 자료 구조 및 알고리즘 기초 서적이라고 볼 수 있다. 린 소프트웨어 개발 애자일 개발서라지만, 실제론 효율론에 가깝다고 볼 수 있다. 수많은 애자일 방법론 서적이 있지만, 그 중에 가장 와닿고, 효율에 대해 다시 생각할 수 있는 거리들도 많아서 큰 도움이 된 서적이다. 피플웨어 요즘 들어 많이 중요하다고 더 느껴지는 책이다. 목표 지향적, 결과 중시 적어도 한국의 게임 회사에서, IT 회사에선 너무 많이 봤다. 조직의 동기부여에는 실패해놓고, 왜 열정이 없느냐고, 자신이 만들고 있는 제품을 사랑하지 않느냐고? 애사심이라는 것이 어떻게 생기는 것이고, 그것이 어떤 결과를 가져다 주는지 고민해봐야 하는 사람들 (관리자, 경영진)이 읽어봤으면 좋겠는 책. 하지만 그 들은 이런 책 읽지 않겠지…. 사랑하지 않으면 떠나라 절판 된 서적이라 구하기 쉽지 않겠지만, 나는 개발자 들이라면 꼭 한번은 읽었으면 좋겠다고 생각하는 책이다. 꽤나 많은 개발자들이 곰같다. 둔하고 무던하고, 변화를 두려워한다. 그래서 불편하고, 괴롭고, 동기부여가 부족함에도 자신의 문제로 치부하고 묵묵히 일한다. 그렇다고 최상의 결과나, 좀 더 나아진 결과를 내는 데에도 실패한다. 왜냐면 이미 일은 일이 되어버렸고, 열정은 사그라졌지만 별다른 대안을 찾기에 두려움도 존재해 현실에 안주하기 때문이다. 또한 회사의 선택과 회사에서의 자신의 포지션, 자신의 업무가 그 회사에서 어떤 가치를 가지는 업무인지 등에 대한 다양한 생각을 가질 수 있게 도와준다. 책 제목이 강하게 번역되서 그렇지, 실제론 이직 추천서, 이직 종용서는 아니고 회사 생활을 좀 더 가치있고, 즐겁게, 동기부여 되어 업무에서의 성취감을 찾을 수 있게 도와주는 자기 개발서라고 보는 것이 더 옳다. 제목에 대한 편견을 버릴 수 있다면, 어떠한 마음가짐으로 개발자로써의 회사 생활을 맞이해야 하는지 판단에 도움을 줄 책이라고 생각한다. 해커와 화가 해커 (뛰어난 프로그래머. 프로그래밍 그 과정 자체를 즐기는 사람이라는 의미가 강하게 사용됨)를 화가에 비유하는 독특한 시점으로 쓰여진 책. 역자 서문에서 임백준씨도 밝히지만, 책 곳곳에서 느껴지는 오만하게 보일 수 있는 보수적인 관점이 불편할 수도 있다. 다만 프로그래밍을 온전히 즐기고자 했을 때, 어떠한 부분이 화가의 그것과 비슷한 지에 대한 그의 생각은 흥미로웠다. 프로그래머를 단순 공돌이로만 치부하기도 하는 현실도 무시하기 힘든 건 사실이지만, 프로그래밍에 대한 개념을 좀 더 독특한 관점에서 말해주기에, 그런 생각이 꽤 많은 프로그래머들에게 자극이었고, 발상의 전환에 도움이 될 좋은 이단스러운 책이라고 생각한다. 전반적으로 측정 언어에 편중된 책은 배제하려다보니, 인문학 관점에 가까운 책들을 더 많이 추천한 것 같다. 특정 언어에 편중된 책들 중에서 좋은 책을 추천하고 싶었는데, 아무래도 프로그래머 필독서로는 애매한게 아닌가 싶더라. C++, C#, Java 등의 특정 언어에 편중된 서적은 따로 작성하는 것이 맞겠다는 싶더라. 다음 필독서 모음은 그렇게 작성해보겠다.</summary></entry><entry><title type="html">C++ 게임 개발자의 웹 &amp;amp; 플랫폼 개발 적응기</title><link href="https://elky84.github.io/2019/03/02/cpp_game_developer_to_web_developer/" rel="alternate" type="text/html" title="C++ 게임 개발자의 웹 &amp; 플랫폼 개발 적응기" /><published>2019-03-02T00:00:00+00:00</published><updated>2019-03-02T00:00:00+00:00</updated><id>https://elky84.github.io/2019/03/02/cpp_game_developer_to_web_developer</id><content type="html" xml:base="https://elky84.github.io/2019/03/02/cpp_game_developer_to_web_developer/">&lt;p&gt;나는 게임 개발자였다.&lt;/p&gt;

&lt;p&gt;첫 시작은 게임 클라이언트였지만, 이후 꽤 긴 시간을 게임 서버 개발자로 보냈다.&lt;/p&gt;

&lt;p&gt;꽤 많은 시간을, 꽤 많은 게임을 만들었고, 유지보수도 했다. 하지만 아쉽게도 성공한 프로젝트는 없다.&lt;/p&gt;

&lt;p&gt;그 시간 동안 게임 개발과, 게임 플레이는 아주 많은 간극이 있다는 것도 알았고, 엔지니어는 거들 뿐 프로젝트의 성공을 위해선 훌륭한 프로듀서와 훌륭한 기획자가 최우선이란 것도 알았다. (때로는 홍보도)&lt;/p&gt;

&lt;p&gt;그렇게 조금씩 지쳐 갈 때 즈음, 웹 서버로 구현하던 많은 라이트한 게임들을 통해, 게임 서버 계에 웹 서버 붐 불었다.
 
나 역시 흐름에 따라 ruby on rails를 게임 웹 서버로 이용하며 발을 담그긴 했으나, 웹을 제대로 알지 못하고 썼으며, 사실상 DB 트랜잭션+로직 단위를 웹 콜 하나로 묶는 수준의 웹 서버를 구축했다고 봐야했다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;나는 여전히 게임을 많이 플레이 한다. 아니 어쩌면, 게임 개발자 일때보다 지금 더 많이 플레이하는 것 같다.
 
서버 개발자로 주로 지내오면서도, 내가 개발하는 게임이 해외 AAA 게임 보다 부족한 기술력, 기획력, 연출력, 아트 퀄리티, 완성도에 아쉽긴 했다. 그러나, 희망론자인 나는 앞으로 나아질거란 기대를 놓지 않았음은 물론이다.&lt;/p&gt;

&lt;p&gt;나는 스토리 기반의 싱글 플레이 게임을 선호하는데, 이는 아마 내 성장기에 즐겨왔던 게임이 주로 그랬던 것과, 엔딩이라는 종착지가 있음이 성취감을 주기 때문이기도 했던 것 같다.&lt;/p&gt;

&lt;p&gt;또한 MMORPG나, FPS, TPS등의 일부 장르에서 국내 기술력이 해외 메이저 게임보다 아쉬운 면도 있는건 사실이지만, 그렇다고해서 경쟁이 안될 정도로 벌어져 있는 상태가 아니었기에, 운이 조금 따른다면 충분히 좋은 프로젝트를 만나 재미와 흥행을 모두 잡는 게임을 만들 수 있을 거란 기대를 품고 게임 개발자로써의 성장을 위해 노력했다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;사람일은 어찌 흘러갈지 모르는 것처럼, 자의 반, 타의 반으로 서버 프로그래머로 전향하고 나서도 몇년간 클라이언트 개발을 다시 하고 싶어 했었으나 실무 기간를 게임 서버를 오래했던지라 경쟁력 문제로 게임 서버 개발을 계속 하게 됐었고, 그렇게 이어가던 게임 서버 개발자로써의 재미와 목표점을 찾게 된 다는, 게임 서버 개발자로서 많은 경험과 노력이 빛을 발할 날을 기다리고 있었다.&lt;/p&gt;

&lt;p&gt;모바일로 시장이 급변하고, 라이트한 게임이 시대의 흐름이 되었을 때, 서버 프로그래머인 나는 굉장히 혼란스러웠다.&lt;/p&gt;

&lt;p&gt;내가 중요하다고 여겨온 가치 몇가지가 와르르 무너지는 느낌이랄까?&lt;/p&gt;

&lt;p&gt;스마트폰 모바일 게임 시장의 초창기에는 서버는 저장소 이상의 가치로 쓰이지 않았다. 사실 그 정도로 쓰인다면 웹서버를 로직 &amp;amp; 데이터베이스 중계역할 정도로도 충분했다.&lt;/p&gt;

&lt;p&gt;그렇게 기술적 요구사항이 낮아지고, 온라인 게임에선 해킹, 검증 등의 이유로 절대 해선 안되던 일인, 로직이 클라이언트로 내려갔고, 이는 상시 네트웍 연결 상태가 아닐 수 있다는 이유로 내려가게 됐고, 조작 방식이 터치로만 이루여져야 한다는 한계는 일부 몇개의 게임을 제외하곤 게임의 방향성 마저 내가 좋아하는 장르나 지향점과 많이 멀어지고 있었다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;그렇게 내가 잘해오던, 내가 경쟁력을 가지던 것들이 무색해지면서 느낀 혼란은, 게임 개발의 재미를 급감 시켰다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 의문에, 나는 내가 클라이언트 개발을 하면 재미를 찾을 수 있는지 알기 위해, 유니티 클라이언트 개발로 게임을 출시하기도 했지만, 이젠 게임 서버 개발을 더 잘해내고 싶은 목표를 이미 갖고 있던 나에게 만족도를 가져다 주는 경험이 되진 못했다.&lt;/p&gt;

&lt;p&gt;이렇게 변한 환경은 기술적 요구사항이 낮아진 만큼 시간을 벌 수 있을테고, 컨텐츠에 조금 더 집중할 수 있지 않냐 라고 물어볼 수 도 있다.&lt;/p&gt;

&lt;p&gt;그랬다면 좋았을 텐데, 기술적 요구치가 낮아진 만큼 더 짧은 일정이 주어졌고, 그로 인해 게임 퀄리티는 더더욱 내가 생각하는 좋은 게임과 멀어지는 계기가 됐다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;아쉬웠던 게임 개발에 대한 이유와 별개로 웹&amp;amp;플랫폼 개발을 하고 싶었던 것은, 오픈 소스 환경에서의 생산성을 느끼면서 이다.&lt;/p&gt;

&lt;p&gt;애초에 최대한 많은 도구를 인하우스 개발을 해오던 게임 개발자가, 오픈 소스로 패키지들을 가져다가 조립해가며 높은 생산성을 맞이하게 됐을 때, 즐거웠다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;젊은 시절 과도한 야근과, 철야로 해친 건강을, 회복하지 못한 내 잘못도 크겠지만, 그로 인해 예전보다 집중력을 많이 잃으면서 적은 공수로 많은 비즈니스 로직을 구현할 수 있는 오픈 소스 문화권의 잘 가져다 써서, 잘 조립하는 환경에 대한 호기심이 생겨나게 됐다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;사실상 개인 C++ 라이브러리까지 꽤나 긴 유지 보수해가며, 최대한 많은 코드를 내 스타일로 커스텀하고 관리하고, 이를 바탕으로 개발하던 게 습관이던 내가, 다른 사람들이 만든 기능을 조합하는 일을 받아들이고, 재밌어 하는 일은 쉬운 결정은 아니었다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;바퀴를 재발명해서 더 나은 바퀴를 만들기 위해 고민하던 내가, 바퀴를 조합하는 일을 재밌게 할 수 있을지, 또 내 삶에 큰 의미를 가지는 게임 개발이 아닌, 다른 분야에 대한 개발에서 성취감과 재미를 찾을 수 있을지는 확신이 없었다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;좀 더 쓰기 좋은 바퀴를 만드는 일 보다, 좀 더 성능 좋은 바퀴를 만드는 데에 집착했던 나로서는 더더욱 그런 면이컸다.&lt;/p&gt;

&lt;p&gt;온라인 게임 개발할 땐 게임 서버 팀 내에서도, 주로 네트워크 라이브러리 작업, 커버리지 확보나 안정성 검증 작업을 더 많이 했던 나로서는 컨텐츠 개발을 적게 해서 그랬던 것 같기도 하다.&lt;/p&gt;

&lt;p&gt;모바일 게임으로 넘어오면서는 컨텐츠 작업의 비중이 더 커졌는데, 그 과정에서 바퀴를 가져다가 짧은 시간에 원하는 컨텐츠를 구현하는 것이 중요할 수 있다는 것에 공감하게 되면서, 조금씩 다른 것들이 보이기 시작했던 것 같다.&lt;/p&gt;

&lt;p&gt;그렇게 적은 공수로 컨텐츠를 만들게 되면서, 사이드잡 내지는 토이 프로젝트에서 C++보다는 다른 언어를 사용하게 됐고, 강력한 언어인 C++보다 효율적인 언어들을 찾아 사용하게 되기도 했다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;내가 웹 개발이 효율성이 좋다고 말한 이유는, 웹 개발을 이끌고 있는 리더들이, 다수의 개발자가 겪는 공통된 고민들을 오픈소스 환경 위에서 같이 고민하고, 같이 해결하며 발전해온 측면이 컸다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;게임 개발도 그런 노력이 없었던 것은 아니지만, 현시점 마저 공개된 기술의 사용이나 오픈 소스를 이용해서 풀 수 있는 문제가 한정되어 있다. 게임 마다 특화된 주제를 다룰 때도 있고, 표준화 되기 이전에 목표를 달성해 게임 출시에 사용해야 되기 때문이기도 하다.
 
그렇다 보니 기술의 재사용, 기술의 표준화에 있어서 웹 개발은 게임 개발보다 잘 이루어졌고, 공통 기술 스택이라 불릴 만큼 범용적 기술이나 경험이라 할 만한 것들마저 생겨났다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;결과론 적으로 웹 개발에선 팀바팀도 물론 요소가 많지만 표준들도 많았다 할 수 있고, 게임 개발은 팀바팀이 훨씬 더 크고 개인의 역량과 개인의 경험에 기대는 측면마저 크다고 볼 수 있다. (왜 그런지는 아래에서 좀 더 자세히 언급하겠다.)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이는 그렇게 기대는 개발자 개인의 이탈이 팀과 회사에 큰 리스크를 가져다 줌을 의미하고, 여전히 게임 개발은 그런 측면이 있다.&lt;/p&gt;

&lt;p&gt;물론 유니티같은 상대적으로 이전보다 쉬운 개발 환경을 만들어 주는 툴이 히트를 치고, 위에서 언급한 디비 저장용도로만 사용하는 웹서버 등으로 서버 개발의 공수도 줄었다지만, 다시금 코어한 게임 개발로 넘어간 지금은 이전 온라인 게임 개발과 다름없이, 특정 게임만을 위한 수많은 기술이 개발되고, 그에 의존한 게임 서비스를 구축해야 한다.&lt;/p&gt;

&lt;p&gt;이런 환경이, 모바일 게임 개발로 넘어오는 시기에 웹/플랫폼과 게임의 기술 대통합이 이뤄질 것처럼 보여졌던 환경에서, 과거로의 회귀같은 느낌마저 난다. (이는 밑에서 정리한 채용 공고만 봐도 느껴질 수 있는 부분이다.)&lt;/p&gt;

&lt;p&gt; 
&lt;strong&gt;이렇게 큰 차이가 나는 이유는, 문제를 푸는 방식, 문제를 해결하는 방식에서의 접근자체가 다르기 때문이다.&lt;/strong&gt;
 
게임 개발자들이 만든 기술을 오픈소스화 하는 데에도 인색한 것은, 아마도 남들도 오픈소스화 하지 않기 때문일 것이다. 또한 그렇게 개발한 기술이 타 게임 개발 업계 전반에 메리트가 있기보다는, 경쟁사의 경쟁 게임에 도움이 되는 기술 공개가 되기 때문인 측면도 분명히 있다고 본다.&lt;/p&gt;

&lt;p&gt;현시점마저 특정 팀내에서의 유틸리티, 엔진, 프레임워크 등 다수는 오픈소스가 아니다.&lt;/p&gt;

&lt;p&gt;과거에 비해 자체 엔진이 매우 줄어들고, 엔진/툴만이라도 과거에 비해 저렴해진 것이 그나마 위안일 정도랄까?&lt;/p&gt;

&lt;p&gt;그리고 게임 개발에서 이견이 없는 주류 언어로 오랜 기간 사용되어왔고, 다시금 선택 받고 있는 C++은 조각 코드 공유가 많지, 가져다 쓰기 쉬운 패키지 단위 배포가 잘 이뤄지지 않았다. (애초에 패키지 매니저 자체가 여타 언어에 비해 매우 늦었고, 아직도 정착 되지 못했다.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;또한 C++ 언어 특성상 라이브러리로 배포된다 한들 그 라이브러리가 세심한 검토 하에 사용되지 않으면 기존 환경 마저 깨뜨릴 수 있는 위험한 환경. 즉 네이티브 환경에서 개발하며, 맘편히 가져다 쓰지 못하고, 잘못 작성된 코드나, 라이브러리 연동과정에서 생긴 각종 트러블에 대한 네거티브한 경험에 의한 결론이 아닐까 싶기도 하다. 남이 만든 코드보다 내 코드, 내 경험, 내 판단, 내 검증만이 높은 퀄리티의 프로덕트의 원동력이라는 결론에 도달한 것 같다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;반면 웹은 브라우저나 웹 프로토콜 기반 하에서의 비슷한 이슈에 대한 고민이 많았고, (상대적으로)꽤나 많은 기능, 해결책들을 가져다 써서 해결 할 수 있었다. 심지어 가져다 써서 생긴 부작용마저 상대적으로 작았고, 웹 서버/웹 프론트엔드는 상대적으로 작은 오류에 대한 파급이 적은 환경이었다. 그런 긍정적인 경험들이 모여 가져다 써서 잘 만드는 데에 집중하는 접근, 환경에 대해 받아들이고 그 것이 옳다고 여길 수 있게 된 거라고 생각한다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;요샌 게임 개발도 효율, 기술의 재사용, 오픈소스로 문제를 많이 푼다는 이야기도 많이들 한다.&lt;/p&gt;

&lt;p&gt;하지만 여전히 채용권자 혹은 프로젝트 리더들과 대화 해본 나는 오픈 소스를 사용하되 그 것을 도입하는 방식, 이용하는 방식에서 여전히 큰 차이가 있다고 생각한다.&lt;/p&gt;

&lt;p&gt;이 주장을 위해 몇몇 회사의 채용 공고를 가져온다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;플랫폼-개발자&quot;&gt;플랫폼 개발자&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/kakao_platform.png&quot; alt=&quot;카카오 플랫폼&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/naver_platform.png&quot; alt=&quot;네이버 플랫폼&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/nhn_platform.png&quot; alt=&quot;NHN 플랫폼&quot; /&gt;&lt;/p&gt;

&lt;p&gt;대용량 처리 경험과, 관련 오픈 소스 사용 경험에 치중되어있다.&lt;/p&gt;

&lt;h2 id=&quot;웹-개발자&quot;&gt;웹 개발자&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/kakao_web.png&quot; alt=&quot;카카오 WEB&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/naver_web.png&quot; alt=&quot;네이버 WEB&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/nhn_web.png&quot; alt=&quot;NHN WEB&quot; /&gt;&lt;/p&gt;

&lt;p&gt;RESTful API, DB, Spring, Java 등의 키워드가 보인다.&lt;/p&gt;

&lt;h2 id=&quot;게임-클라이언트-개발자&quot;&gt;게임 클라이언트 개발자&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/netmarble_client.png&quot; alt=&quot;넷마블 넥서스 클라이언트&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/netgames_client.png&quot; alt=&quot;넷게임즈 클라이언트&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/pubg_client.png&quot; alt=&quot;PUBG 클라이언트&quot; /&gt;&lt;/p&gt;

&lt;p&gt;공학 기초, 엔진 (언리얼, 유니티), C++, C#, 프로젝트 경험 등이 키워드다.&lt;/p&gt;

&lt;h2 id=&quot;게임-서버-개발자&quot;&gt;게임 서버 개발자&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/netmarble_nexus_server.png&quot; alt=&quot;넷마블 넥서스 서버&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/netmarble_monster_server.png&quot; alt=&quot;넷마블 몬스터 서버&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/netmarble_blue_server.png&quot; alt=&quot;넷마블 블루 서버&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/netgames_server.png&quot; alt=&quot;넷게임즈 서버&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/nexon_server.png&quot; alt=&quot;넥슨 서버&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/nc_server.png&quot; alt=&quot;엔씨 서버&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C#, C++, DB, 네트웍, 로우 레벨 이해도 (TCP/IP 통신, 멀티 스레드, OS 구조 등), 트러블 슈트 등의 키워드가 나열됐다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;일부 공고에 불과하기에 일반화 하기엔 부족하지만, 게임 개발이 전반적으로 기초를 더 중요시 한다.&lt;/p&gt;

&lt;p&gt;실제로 공고보다 면접과정, 채용과정에서 로우레벨 이해도가 부족한 사람은 뽑아선 안된다는 기조가, 웹&amp;amp;플랫폼보다 훨씬 더 많이 언급됐고, 작용했다.&lt;/p&gt;

&lt;p&gt;이는 프레임워크나, 시스템 구조를 직접 작성해야 되기 때문에, 기초가 부족한 사람이 끼칠 부정적 영향에 대한 우려, 검증과 함께 개발해야 하는 게임 마다 특화된 구조를 지탱하고, 이해할 기초가 중요하다고 보는 경향이 상대적으로 높다고 볼 수 있겠다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;내가 게임 개발자로써 웹 개발자 혹은 플랫폼 개발자 분들과 대화해가며 문제에 대한 접근/해결책에 대해 너무나도 다른 시각과 해결책을 내놓고, 타협이 쉽게 이뤄지지 않는 것을 보고 왜 그런지 많은 고민을 했었다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;결국 다 프로그래머들인데 왜 이렇게 다르지?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 궁금증에 대한 해답을 얻고 싶었다.&lt;/p&gt;

&lt;p&gt;내가 일해오며 존경하는 몇명의 개발자가 있다. 이 개발자 분들은 흔히 말하는 머리 좋은 천재 프로그래머는 아니었다. 대부분 유연한 프로그래머였다. 생각이 경직되어 있지 않고, 자신의 의견보다 더 설득력 있는 주장, 혹은 다른 측면의 주장을 열린 마음으로 토론할 수 있고, 향상심과 함께 겸손함을 가진 분들을 결국엔 존경할 수 있었다.&lt;/p&gt;

&lt;p&gt;내가 고집스럽기도했고, C++은 모든걸 할 수 있는 언어인데 왜 다른 언어를 굳이 써야하지? 게임 개발은 어려운 일들이 많이 하니까 가치있어 같은 편협한 생각도 가졌던 나에게, 위에서 언급한 유연하고 겸손하고 훌륭한 분들이 내 생각을 많이 바꿔주셨다.&lt;/p&gt;

&lt;p&gt;그리고 나는 그 분들 처럼 되고 싶었다.&lt;/p&gt;

&lt;p&gt;그렇게 유연한 사람이 되기 위해, 새로운 분야를 경험해보고자 한 측면도 꽤 컸다.&lt;/p&gt;

&lt;p&gt;이렇게 웹&amp;amp;플랫폼 개발자로써 일해보고나니 알 수 있었던 또 다른 요소는, 그나마 웹&amp;amp;플랫폼 개발자는 비슷한 성향이나 근거, 판단이 유사한 측면이있다. 바로 효율, 재사용성에 집착한다는 측면이다.&lt;/p&gt;

&lt;p&gt;사실 웹&amp;amp;플랫폼 개발자들은 유연하고, 게임 개발자는 그렇지 않아라고 하기엔 그렇지도 않았다. 실제로 환경이 잘 가져다 쓰는 것이 중요하다고 주입된 것이지, 본인이 그 효율성에 통감하거나, 선택해서가 아닌 경우가 많았고, 그렇게 얻은 효율성을 잘 활용하는 사람이 딱히 많다고 보기 어려웠다.&lt;/p&gt;

&lt;p&gt;또한 게임 개발자 중에서도 최근엔 잘 조합해서 효율을 내고자 하는 노력이 여기저기서 이루어지고 있다.&lt;/p&gt;

&lt;p&gt;웹&amp;amp;플랫폼 개발자 분들 중에서도 편협하고, 유연하지 못한 분들이 많고, 게임 쪽도 마찬가지다. 어딜가나 고집스럽고, 자신의 경험이나 자신의 실력만 집착하는 사람들이 변화나 발전에 걸림돌이 된다.&lt;/p&gt;

&lt;p&gt;안정성이나 합리성을 뒷전으로 둔 채 변화만 쫓는 것도 문제지만, 무작정 자신의 경험, 지금껏 그래왔다는 부족한 근거로 변화를 거부 하는 것도 문제다.&lt;/p&gt;

&lt;p&gt;성장 할 수 있는 동력을 갖추기 위해선 겸손하고 유연한 사람이되어, 다른 분야의 장점을 받아들이려고 노력하는 게 필요하지 않을까 싶다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;양쪽 다 경험해본 내 입장에선, &lt;strong&gt;게임 개발은 재사용성을 좀 더 높이는 노력과 기술 내재화와 경험을 전파하는 노력이 이뤄진다면 많은 것이 더 좋아질 것이라고 생각한다. 아직은 개인의 역량이나 경험이 조금 더 중요한 경향이 있다. 미들웨어나 프레임워크를 덜 사용하기 때문에, 게임에 따라 특화된 구조가 나오고 이 구조는 안정성 전반에 영향을 주기 때문에, 개인의 역량이 크게 중요하다. 게임 마다 다르게 구성 되어 있는 구조를 이해하고, 그 안에서의 최적의 해를 구하는 것이 중요하기 때문이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;상대적으로 개인의 역량이 중요하므로, 리드 프로그래머, 메인 프로그래머 영역에 있는 사람은 프로젝트에 빠져선 안될 스폐셜 원이 되기 쉽다.&lt;/p&gt;

&lt;p&gt;반면 &lt;strong&gt;웹 개발은 국내는 대다수가 스프링이다. 자바와 스프링만 쓸 줄 알면 어떤 업무건 적응해야 될 요소가 상대적으로 크게 적다. 또한 웹 프론트 엔드도 자바 스크립트가 오랜 시간 유일한 선택이었고, 메이저한 프레임워크 (Angular, React, Vue), 플랫폼 개발도 메이저한 시스템 (하둡, 스파크, 엘라스틱 서치 등등)을 사용하기 때문에 그 경험이 통용되기 수월하다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;웹이나 플랫폼 개발에서도 메인이나 리드 프로그래머는 중요하다지만 팀 관점에서도 상대적으로 리스크가 적다. 또한 개발자가 이직시에도 적응 코스트가 낮아지는 장점이 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;지금껏 얘기한 비교는 지극히 내 경험에 한정되어있고, 기껏해야 지인들과의 대화에서 내린 결론에 불과하기에 정답도 아니고, 지향점도 될 수 없다.&lt;/p&gt;

&lt;p&gt;다만 어떤 분야의 개발자가 되고 싶은지 고민 중이거나, 전업을 고민하는 개발자들에게 도움이 될 글을 쓰고 싶었다.&lt;/p&gt;

&lt;p&gt;또한 내가 너무나도 궁금했던 웹&amp;amp;플랫폼 개발과 게임 개발이 무엇이 다른지 알고 싶은 개발자들에게 조금이나마 도움이 되지 않을까 싶어, 정리가 덜 된 글이라 요약하고 싶지만, 아쉽게도 두서없게 6개월만에 마무리한다.&lt;/p&gt;

&lt;p&gt;아마도 이 글에서 다룬 이야기는 더 잘 요약해서 다시금 쓰게 되지 않을까 싶은 예감이 든다.&lt;/p&gt;</content><author><name>Elky Kim</name></author><category term="게임개발" /><category term="웹개발" /><category term="플랫폼개발" /><summary type="html">나는 게임 개발자였다. 첫 시작은 게임 클라이언트였지만, 이후 꽤 긴 시간을 게임 서버 개발자로 보냈다. 꽤 많은 시간을, 꽤 많은 게임을 만들었고, 유지보수도 했다. 하지만 아쉽게도 성공한 프로젝트는 없다. 그 시간 동안 게임 개발과, 게임 플레이는 아주 많은 간극이 있다는 것도 알았고, 엔지니어는 거들 뿐 프로젝트의 성공을 위해선 훌륭한 프로듀서와 훌륭한 기획자가 최우선이란 것도 알았다. (때로는 홍보도) 그렇게 조금씩 지쳐 갈 때 즈음, 웹 서버로 구현하던 많은 라이트한 게임들을 통해, 게임 서버 계에 웹 서버 붐 불었다.   나 역시 흐름에 따라 ruby on rails를 게임 웹 서버로 이용하며 발을 담그긴 했으나, 웹을 제대로 알지 못하고 썼으며, 사실상 DB 트랜잭션+로직 단위를 웹 콜 하나로 묶는 수준의 웹 서버를 구축했다고 봐야했다. 나는 여전히 게임을 많이 플레이 한다. 아니 어쩌면, 게임 개발자 일때보다 지금 더 많이 플레이하는 것 같다.   서버 개발자로 주로 지내오면서도, 내가 개발하는 게임이 해외 AAA 게임 보다 부족한 기술력, 기획력, 연출력, 아트 퀄리티, 완성도에 아쉽긴 했다. 그러나, 희망론자인 나는 앞으로 나아질거란 기대를 놓지 않았음은 물론이다. 나는 스토리 기반의 싱글 플레이 게임을 선호하는데, 이는 아마 내 성장기에 즐겨왔던 게임이 주로 그랬던 것과, 엔딩이라는 종착지가 있음이 성취감을 주기 때문이기도 했던 것 같다. 또한 MMORPG나, FPS, TPS등의 일부 장르에서 국내 기술력이 해외 메이저 게임보다 아쉬운 면도 있는건 사실이지만, 그렇다고해서 경쟁이 안될 정도로 벌어져 있는 상태가 아니었기에, 운이 조금 따른다면 충분히 좋은 프로젝트를 만나 재미와 흥행을 모두 잡는 게임을 만들 수 있을 거란 기대를 품고 게임 개발자로써의 성장을 위해 노력했다. 사람일은 어찌 흘러갈지 모르는 것처럼, 자의 반, 타의 반으로 서버 프로그래머로 전향하고 나서도 몇년간 클라이언트 개발을 다시 하고 싶어 했었으나 실무 기간를 게임 서버를 오래했던지라 경쟁력 문제로 게임 서버 개발을 계속 하게 됐었고, 그렇게 이어가던 게임 서버 개발자로써의 재미와 목표점을 찾게 된 다는, 게임 서버 개발자로서 많은 경험과 노력이 빛을 발할 날을 기다리고 있었다. 모바일로 시장이 급변하고, 라이트한 게임이 시대의 흐름이 되었을 때, 서버 프로그래머인 나는 굉장히 혼란스러웠다. 내가 중요하다고 여겨온 가치 몇가지가 와르르 무너지는 느낌이랄까? 스마트폰 모바일 게임 시장의 초창기에는 서버는 저장소 이상의 가치로 쓰이지 않았다. 사실 그 정도로 쓰인다면 웹서버를 로직 &amp;amp; 데이터베이스 중계역할 정도로도 충분했다. 그렇게 기술적 요구사항이 낮아지고, 온라인 게임에선 해킹, 검증 등의 이유로 절대 해선 안되던 일인, 로직이 클라이언트로 내려갔고, 이는 상시 네트웍 연결 상태가 아닐 수 있다는 이유로 내려가게 됐고, 조작 방식이 터치로만 이루여져야 한다는 한계는 일부 몇개의 게임을 제외하곤 게임의 방향성 마저 내가 좋아하는 장르나 지향점과 많이 멀어지고 있었다. 그렇게 내가 잘해오던, 내가 경쟁력을 가지던 것들이 무색해지면서 느낀 혼란은, 게임 개발의 재미를 급감 시켰다. 이 의문에, 나는 내가 클라이언트 개발을 하면 재미를 찾을 수 있는지 알기 위해, 유니티 클라이언트 개발로 게임을 출시하기도 했지만, 이젠 게임 서버 개발을 더 잘해내고 싶은 목표를 이미 갖고 있던 나에게 만족도를 가져다 주는 경험이 되진 못했다. 이렇게 변한 환경은 기술적 요구사항이 낮아진 만큼 시간을 벌 수 있을테고, 컨텐츠에 조금 더 집중할 수 있지 않냐 라고 물어볼 수 도 있다. 그랬다면 좋았을 텐데, 기술적 요구치가 낮아진 만큼 더 짧은 일정이 주어졌고, 그로 인해 게임 퀄리티는 더더욱 내가 생각하는 좋은 게임과 멀어지는 계기가 됐다. 아쉬웠던 게임 개발에 대한 이유와 별개로 웹&amp;amp;플랫폼 개발을 하고 싶었던 것은, 오픈 소스 환경에서의 생산성을 느끼면서 이다. 애초에 최대한 많은 도구를 인하우스 개발을 해오던 게임 개발자가, 오픈 소스로 패키지들을 가져다가 조립해가며 높은 생산성을 맞이하게 됐을 때, 즐거웠다. 젊은 시절 과도한 야근과, 철야로 해친 건강을, 회복하지 못한 내 잘못도 크겠지만, 그로 인해 예전보다 집중력을 많이 잃으면서 적은 공수로 많은 비즈니스 로직을 구현할 수 있는 오픈 소스 문화권의 잘 가져다 써서, 잘 조립하는 환경에 대한 호기심이 생겨나게 됐다. 사실상 개인 C++ 라이브러리까지 꽤나 긴 유지 보수해가며, 최대한 많은 코드를 내 스타일로 커스텀하고 관리하고, 이를 바탕으로 개발하던 게 습관이던 내가, 다른 사람들이 만든 기능을 조합하는 일을 받아들이고, 재밌어 하는 일은 쉬운 결정은 아니었다. 바퀴를 재발명해서 더 나은 바퀴를 만들기 위해 고민하던 내가, 바퀴를 조합하는 일을 재밌게 할 수 있을지, 또 내 삶에 큰 의미를 가지는 게임 개발이 아닌, 다른 분야에 대한 개발에서 성취감과 재미를 찾을 수 있을지는 확신이 없었다 좀 더 쓰기 좋은 바퀴를 만드는 일 보다, 좀 더 성능 좋은 바퀴를 만드는 데에 집착했던 나로서는 더더욱 그런 면이컸다. 온라인 게임 개발할 땐 게임 서버 팀 내에서도, 주로 네트워크 라이브러리 작업, 커버리지 확보나 안정성 검증 작업을 더 많이 했던 나로서는 컨텐츠 개발을 적게 해서 그랬던 것 같기도 하다. 모바일 게임으로 넘어오면서는 컨텐츠 작업의 비중이 더 커졌는데, 그 과정에서 바퀴를 가져다가 짧은 시간에 원하는 컨텐츠를 구현하는 것이 중요할 수 있다는 것에 공감하게 되면서, 조금씩 다른 것들이 보이기 시작했던 것 같다. 그렇게 적은 공수로 컨텐츠를 만들게 되면서, 사이드잡 내지는 토이 프로젝트에서 C++보다는 다른 언어를 사용하게 됐고, 강력한 언어인 C++보다 효율적인 언어들을 찾아 사용하게 되기도 했다. 내가 웹 개발이 효율성이 좋다고 말한 이유는, 웹 개발을 이끌고 있는 리더들이, 다수의 개발자가 겪는 공통된 고민들을 오픈소스 환경 위에서 같이 고민하고, 같이 해결하며 발전해온 측면이 컸다. 게임 개발도 그런 노력이 없었던 것은 아니지만, 현시점 마저 공개된 기술의 사용이나 오픈 소스를 이용해서 풀 수 있는 문제가 한정되어 있다. 게임 마다 특화된 주제를 다룰 때도 있고, 표준화 되기 이전에 목표를 달성해 게임 출시에 사용해야 되기 때문이기도 하다.   그렇다 보니 기술의 재사용, 기술의 표준화에 있어서 웹 개발은 게임 개발보다 잘 이루어졌고, 공통 기술 스택이라 불릴 만큼 범용적 기술이나 경험이라 할 만한 것들마저 생겨났다. 결과론 적으로 웹 개발에선 팀바팀도 물론 요소가 많지만 표준들도 많았다 할 수 있고, 게임 개발은 팀바팀이 훨씬 더 크고 개인의 역량과 개인의 경험에 기대는 측면마저 크다고 볼 수 있다. (왜 그런지는 아래에서 좀 더 자세히 언급하겠다.) 이는 그렇게 기대는 개발자 개인의 이탈이 팀과 회사에 큰 리스크를 가져다 줌을 의미하고, 여전히 게임 개발은 그런 측면이 있다. 물론 유니티같은 상대적으로 이전보다 쉬운 개발 환경을 만들어 주는 툴이 히트를 치고, 위에서 언급한 디비 저장용도로만 사용하는 웹서버 등으로 서버 개발의 공수도 줄었다지만, 다시금 코어한 게임 개발로 넘어간 지금은 이전 온라인 게임 개발과 다름없이, 특정 게임만을 위한 수많은 기술이 개발되고, 그에 의존한 게임 서비스를 구축해야 한다. 이런 환경이, 모바일 게임 개발로 넘어오는 시기에 웹/플랫폼과 게임의 기술 대통합이 이뤄질 것처럼 보여졌던 환경에서, 과거로의 회귀같은 느낌마저 난다. (이는 밑에서 정리한 채용 공고만 봐도 느껴질 수 있는 부분이다.)   이렇게 큰 차이가 나는 이유는, 문제를 푸는 방식, 문제를 해결하는 방식에서의 접근자체가 다르기 때문이다.   게임 개발자들이 만든 기술을 오픈소스화 하는 데에도 인색한 것은, 아마도 남들도 오픈소스화 하지 않기 때문일 것이다. 또한 그렇게 개발한 기술이 타 게임 개발 업계 전반에 메리트가 있기보다는, 경쟁사의 경쟁 게임에 도움이 되는 기술 공개가 되기 때문인 측면도 분명히 있다고 본다. 현시점마저 특정 팀내에서의 유틸리티, 엔진, 프레임워크 등 다수는 오픈소스가 아니다. 과거에 비해 자체 엔진이 매우 줄어들고, 엔진/툴만이라도 과거에 비해 저렴해진 것이 그나마 위안일 정도랄까? 그리고 게임 개발에서 이견이 없는 주류 언어로 오랜 기간 사용되어왔고, 다시금 선택 받고 있는 C++은 조각 코드 공유가 많지, 가져다 쓰기 쉬운 패키지 단위 배포가 잘 이뤄지지 않았다. (애초에 패키지 매니저 자체가 여타 언어에 비해 매우 늦었고, 아직도 정착 되지 못했다.) 또한 C++ 언어 특성상 라이브러리로 배포된다 한들 그 라이브러리가 세심한 검토 하에 사용되지 않으면 기존 환경 마저 깨뜨릴 수 있는 위험한 환경. 즉 네이티브 환경에서 개발하며, 맘편히 가져다 쓰지 못하고, 잘못 작성된 코드나, 라이브러리 연동과정에서 생긴 각종 트러블에 대한 네거티브한 경험에 의한 결론이 아닐까 싶기도 하다. 남이 만든 코드보다 내 코드, 내 경험, 내 판단, 내 검증만이 높은 퀄리티의 프로덕트의 원동력이라는 결론에 도달한 것 같다. 반면 웹은 브라우저나 웹 프로토콜 기반 하에서의 비슷한 이슈에 대한 고민이 많았고, (상대적으로)꽤나 많은 기능, 해결책들을 가져다 써서 해결 할 수 있었다. 심지어 가져다 써서 생긴 부작용마저 상대적으로 작았고, 웹 서버/웹 프론트엔드는 상대적으로 작은 오류에 대한 파급이 적은 환경이었다. 그런 긍정적인 경험들이 모여 가져다 써서 잘 만드는 데에 집중하는 접근, 환경에 대해 받아들이고 그 것이 옳다고 여길 수 있게 된 거라고 생각한다. 요샌 게임 개발도 효율, 기술의 재사용, 오픈소스로 문제를 많이 푼다는 이야기도 많이들 한다. 하지만 여전히 채용권자 혹은 프로젝트 리더들과 대화 해본 나는 오픈 소스를 사용하되 그 것을 도입하는 방식, 이용하는 방식에서 여전히 큰 차이가 있다고 생각한다. 이 주장을 위해 몇몇 회사의 채용 공고를 가져온다. 플랫폼 개발자 대용량 처리 경험과, 관련 오픈 소스 사용 경험에 치중되어있다. 웹 개발자 RESTful API, DB, Spring, Java 등의 키워드가 보인다. 게임 클라이언트 개발자 공학 기초, 엔진 (언리얼, 유니티), C++, C#, 프로젝트 경험 등이 키워드다. 게임 서버 개발자 C#, C++, DB, 네트웍, 로우 레벨 이해도 (TCP/IP 통신, 멀티 스레드, OS 구조 등), 트러블 슈트 등의 키워드가 나열됐다. 일부 공고에 불과하기에 일반화 하기엔 부족하지만, 게임 개발이 전반적으로 기초를 더 중요시 한다. 실제로 공고보다 면접과정, 채용과정에서 로우레벨 이해도가 부족한 사람은 뽑아선 안된다는 기조가, 웹&amp;amp;플랫폼보다 훨씬 더 많이 언급됐고, 작용했다. 이는 프레임워크나, 시스템 구조를 직접 작성해야 되기 때문에, 기초가 부족한 사람이 끼칠 부정적 영향에 대한 우려, 검증과 함께 개발해야 하는 게임 마다 특화된 구조를 지탱하고, 이해할 기초가 중요하다고 보는 경향이 상대적으로 높다고 볼 수 있겠다. 내가 게임 개발자로써 웹 개발자 혹은 플랫폼 개발자 분들과 대화해가며 문제에 대한 접근/해결책에 대해 너무나도 다른 시각과 해결책을 내놓고, 타협이 쉽게 이뤄지지 않는 것을 보고 왜 그런지 많은 고민을 했었다. 결국 다 프로그래머들인데 왜 이렇게 다르지? 이 궁금증에 대한 해답을 얻고 싶었다. 내가 일해오며 존경하는 몇명의 개발자가 있다. 이 개발자 분들은 흔히 말하는 머리 좋은 천재 프로그래머는 아니었다. 대부분 유연한 프로그래머였다. 생각이 경직되어 있지 않고, 자신의 의견보다 더 설득력 있는 주장, 혹은 다른 측면의 주장을 열린 마음으로 토론할 수 있고, 향상심과 함께 겸손함을 가진 분들을 결국엔 존경할 수 있었다. 내가 고집스럽기도했고, C++은 모든걸 할 수 있는 언어인데 왜 다른 언어를 굳이 써야하지? 게임 개발은 어려운 일들이 많이 하니까 가치있어 같은 편협한 생각도 가졌던 나에게, 위에서 언급한 유연하고 겸손하고 훌륭한 분들이 내 생각을 많이 바꿔주셨다. 그리고 나는 그 분들 처럼 되고 싶었다. 그렇게 유연한 사람이 되기 위해, 새로운 분야를 경험해보고자 한 측면도 꽤 컸다. 이렇게 웹&amp;amp;플랫폼 개발자로써 일해보고나니 알 수 있었던 또 다른 요소는, 그나마 웹&amp;amp;플랫폼 개발자는 비슷한 성향이나 근거, 판단이 유사한 측면이있다. 바로 효율, 재사용성에 집착한다는 측면이다. 사실 웹&amp;amp;플랫폼 개발자들은 유연하고, 게임 개발자는 그렇지 않아라고 하기엔 그렇지도 않았다. 실제로 환경이 잘 가져다 쓰는 것이 중요하다고 주입된 것이지, 본인이 그 효율성에 통감하거나, 선택해서가 아닌 경우가 많았고, 그렇게 얻은 효율성을 잘 활용하는 사람이 딱히 많다고 보기 어려웠다. 또한 게임 개발자 중에서도 최근엔 잘 조합해서 효율을 내고자 하는 노력이 여기저기서 이루어지고 있다. 웹&amp;amp;플랫폼 개발자 분들 중에서도 편협하고, 유연하지 못한 분들이 많고, 게임 쪽도 마찬가지다. 어딜가나 고집스럽고, 자신의 경험이나 자신의 실력만 집착하는 사람들이 변화나 발전에 걸림돌이 된다. 안정성이나 합리성을 뒷전으로 둔 채 변화만 쫓는 것도 문제지만, 무작정 자신의 경험, 지금껏 그래왔다는 부족한 근거로 변화를 거부 하는 것도 문제다. 성장 할 수 있는 동력을 갖추기 위해선 겸손하고 유연한 사람이되어, 다른 분야의 장점을 받아들이려고 노력하는 게 필요하지 않을까 싶다. 양쪽 다 경험해본 내 입장에선, 게임 개발은 재사용성을 좀 더 높이는 노력과 기술 내재화와 경험을 전파하는 노력이 이뤄진다면 많은 것이 더 좋아질 것이라고 생각한다. 아직은 개인의 역량이나 경험이 조금 더 중요한 경향이 있다. 미들웨어나 프레임워크를 덜 사용하기 때문에, 게임에 따라 특화된 구조가 나오고 이 구조는 안정성 전반에 영향을 주기 때문에, 개인의 역량이 크게 중요하다. 게임 마다 다르게 구성 되어 있는 구조를 이해하고, 그 안에서의 최적의 해를 구하는 것이 중요하기 때문이다. 상대적으로 개인의 역량이 중요하므로, 리드 프로그래머, 메인 프로그래머 영역에 있는 사람은 프로젝트에 빠져선 안될 스폐셜 원이 되기 쉽다. 반면 웹 개발은 국내는 대다수가 스프링이다. 자바와 스프링만 쓸 줄 알면 어떤 업무건 적응해야 될 요소가 상대적으로 크게 적다. 또한 웹 프론트 엔드도 자바 스크립트가 오랜 시간 유일한 선택이었고, 메이저한 프레임워크 (Angular, React, Vue), 플랫폼 개발도 메이저한 시스템 (하둡, 스파크, 엘라스틱 서치 등등)을 사용하기 때문에 그 경험이 통용되기 수월하다. 웹이나 플랫폼 개발에서도 메인이나 리드 프로그래머는 중요하다지만 팀 관점에서도 상대적으로 리스크가 적다. 또한 개발자가 이직시에도 적응 코스트가 낮아지는 장점이 있다. 지금껏 얘기한 비교는 지극히 내 경험에 한정되어있고, 기껏해야 지인들과의 대화에서 내린 결론에 불과하기에 정답도 아니고, 지향점도 될 수 없다. 다만 어떤 분야의 개발자가 되고 싶은지 고민 중이거나, 전업을 고민하는 개발자들에게 도움이 될 글을 쓰고 싶었다. 또한 내가 너무나도 궁금했던 웹&amp;amp;플랫폼 개발과 게임 개발이 무엇이 다른지 알고 싶은 개발자들에게 조금이나마 도움이 되지 않을까 싶어, 정리가 덜 된 글이라 요약하고 싶지만, 아쉽게도 두서없게 6개월만에 마무리한다. 아마도 이 글에서 다룬 이야기는 더 잘 요약해서 다시금 쓰게 되지 않을까 싶은 예감이 든다.</summary></entry><entry><title type="html">특수화와 범용성</title><link href="https://elky84.github.io/2019/01/06/specialize_and_universality/" rel="alternate" type="text/html" title="특수화와 범용성" /><published>2019-01-06T00:00:00+00:00</published><updated>2019-01-06T00:00:00+00:00</updated><id>https://elky84.github.io/2019/01/06/specialize_and_universality</id><content type="html" xml:base="https://elky84.github.io/2019/01/06/specialize_and_universality/">&lt;p&gt;처음 프로그래밍을 시작한 시점부터 얼마나 많은 코드를 작성해왔는지, 그 코드들 중 얼마나 많은 코드가 아직도 실행되고 있는지를 알 순 없지만, 내가 짠 꽤나 많은 코드가 아직 현역일 것이다.&lt;/p&gt;

&lt;p&gt;그 과정에서 자주 고민하게 되는 이슈 중 하나는 바로, &lt;strong&gt;특수화와 범용성&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;혹자는 특수화 자체를 나쁘다고 규정 짓곤 하지만, 투입되는 코스트가 작아지고 예외가 적어질 수 있다는 점에서 특수화는 분명히 큰 장점이 있다.&lt;/p&gt;

&lt;p&gt;서두에 왜 내가 짠 코드가 아직도 현역일 것이란 얘기를 했냐하면, &lt;strong&gt;범용성이란 내가 작성한 코드가 현역인지 여부보다는 내가 작성한 코드가 얼마나 더 수정되거나, 재사용 될 것인가에 의미가 있기 때문이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;심지어는 수정이 되는 과정에서나, 수정이 되기 위해 검토되는 과정에서 마저 특수화가 더 중요한 가치일 때가 많다.&lt;/p&gt;

&lt;p&gt;범용성을 위해 모호한 네이밍, 모호한 사용법, 열려있는 기능이 코드 분석을 어렵게 할 수 있는 요인이 되기 때문이다.&lt;/p&gt;

&lt;p&gt;물론 범용성 자체가 나쁘단 얘긴 절대 아니다. 범용성 자체는 중요한 가치중 하나다. 작은 수정에도, 기존 코드에 큰 수정을 가해야해 리스크를 크게 가져가야 하는 상황은 분명히 잘못됐다. 하지만, 이미 오래 전에 open-close 원칙으로 확장에 유연하고, 기존 동작에 리스크 없게끔 범용성을 갖추는 방법이 고안되어있으며, 20-80 법칙등을 근거로 자주 사용될 때는 범용성을, 자주 호출되서 실행시간의 80%이상에 포함되는 코드는 특수화를 통한 성능 향상과 오류율 감소를 얻어내야 한다.&lt;/p&gt;

&lt;p&gt;작성하는 코드가 해야 할 역할에 따라서 다르다는 점은 매우 중요하다. 재사용되지 않을 기능, 특수한 상황만을 위한 어쩔 수 없는 비지니스 특화 코드 등에 범용성을 위한 코스트를 들이는 것은 낭비라고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;심지어는 어설픈 범용성으로 인해, 기능을 재사용하기 위해 많은 수정이 다시 필요한 경우도 존재한다는 점도 무시할 수 없다. 모든 시나리오를 위한 범용성을 갖췄을리 없기 때문에, 새로운 요구사항 혹은 새로운 사용법이 필요해졌을 때가 대비되어 있지 않을 가능성이 높기 때문이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;다시 고칠일이 없는 코드에 범용성을 위해 몇일을 소모하는, 휴먼 리소스 낭비마저 합리화 될 순 없다. 모두에게 시간은 평등하고, 가치 있기 때문에, 오버 엔지니어링 하지 않고 효율성도 고려하는 것이 좋은 엔지니어이기 때문이다.&lt;/p&gt;

&lt;p&gt;대부분의 경우에는, 나쁘지 않은 구현으로 기능을 개발 한 뒤, 자주 사용되거나, 요구 사항이 확정 되거나, 피드백을 반영해서 완성하는 것이 합리적일 때가 많다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;내 경험상으로는 범용성을 위해서 들이는 코스트도, 특수화를 위한 결단과 판단력도 모두 빠른 프로토타이핑 혹은 방향성을 확인하기 위한 예광탄으로 검증 된 뒤 고도화 하는 것이 합리적인 경우가 많았다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;대부분의 요구 사항은 결과물을 보기전까지 모호함과 결함을 내재하고 있기 때문이다. 이 것이 애자일에서 주로 언급하는 빠른 이터레이션이다. 그 과정을 좀 더 명확해진 설계로 이어지고, 곧 좀 더 특수화, 범용화 하기 쉬워진다.&lt;/p&gt;

&lt;p&gt;재작업을 비효율이라 여기는게 개발자들의 공통적인 생각인데, 범용화를 위해 쓰이는 시간이 낭비가 될 수 있다면, 이 역시 비효율로 여겨져야 한다고 생각한다.&lt;/p&gt;

&lt;p&gt;범용화를 위해 확장성도 있고, 안정성도 잡는 룰을 갖추고, 그 룰의 시행착오를 갖추고 적용하기 위해선 아주 아주 많은 코스트가 들지만, 그만큼 가치있다.&lt;/p&gt;

&lt;p&gt;그럼에도 거기에 들어가는 시간이 과다하다면, 엔지니어도, 엔지니어와 협업하는 다른 사람들도 납득시키기 어렵다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;난 코드 작성시의 범용성을 최우선 가치로 여기는 것은 옳지 않다고 생각한다. 범용성이 필요한 상황은 분명히 존재하나, 항상, 매번 중요한 가치로 여겨지기엔 들어가는 코스트가 너무 크고, 그 코스트가 효율성을 얻기 어려운 상황을 나는 매우 자주 접했기 때문이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;빠른 구현을 통해 방향성과 타당성을 검증하고, 그 이후에 범용성을 선택할지, 특수화를 선택할지 상황과 해야 될 일에 맡게 판단하는 것이 합리적인, 실용적인 프로그래머가 아닐까?&lt;/p&gt;</content><author><name>Elky Kim</name></author><category term="특수화" /><category term="범용성" /><summary type="html">처음 프로그래밍을 시작한 시점부터 얼마나 많은 코드를 작성해왔는지, 그 코드들 중 얼마나 많은 코드가 아직도 실행되고 있는지를 알 순 없지만, 내가 짠 꽤나 많은 코드가 아직 현역일 것이다. 그 과정에서 자주 고민하게 되는 이슈 중 하나는 바로, 특수화와 범용성이다. 혹자는 특수화 자체를 나쁘다고 규정 짓곤 하지만, 투입되는 코스트가 작아지고 예외가 적어질 수 있다는 점에서 특수화는 분명히 큰 장점이 있다. 서두에 왜 내가 짠 코드가 아직도 현역일 것이란 얘기를 했냐하면, 범용성이란 내가 작성한 코드가 현역인지 여부보다는 내가 작성한 코드가 얼마나 더 수정되거나, 재사용 될 것인가에 의미가 있기 때문이다. 심지어는 수정이 되는 과정에서나, 수정이 되기 위해 검토되는 과정에서 마저 특수화가 더 중요한 가치일 때가 많다. 범용성을 위해 모호한 네이밍, 모호한 사용법, 열려있는 기능이 코드 분석을 어렵게 할 수 있는 요인이 되기 때문이다. 물론 범용성 자체가 나쁘단 얘긴 절대 아니다. 범용성 자체는 중요한 가치중 하나다. 작은 수정에도, 기존 코드에 큰 수정을 가해야해 리스크를 크게 가져가야 하는 상황은 분명히 잘못됐다. 하지만, 이미 오래 전에 open-close 원칙으로 확장에 유연하고, 기존 동작에 리스크 없게끔 범용성을 갖추는 방법이 고안되어있으며, 20-80 법칙등을 근거로 자주 사용될 때는 범용성을, 자주 호출되서 실행시간의 80%이상에 포함되는 코드는 특수화를 통한 성능 향상과 오류율 감소를 얻어내야 한다. 작성하는 코드가 해야 할 역할에 따라서 다르다는 점은 매우 중요하다. 재사용되지 않을 기능, 특수한 상황만을 위한 어쩔 수 없는 비지니스 특화 코드 등에 범용성을 위한 코스트를 들이는 것은 낭비라고 볼 수 있다. 심지어는 어설픈 범용성으로 인해, 기능을 재사용하기 위해 많은 수정이 다시 필요한 경우도 존재한다는 점도 무시할 수 없다. 모든 시나리오를 위한 범용성을 갖췄을리 없기 때문에, 새로운 요구사항 혹은 새로운 사용법이 필요해졌을 때가 대비되어 있지 않을 가능성이 높기 때문이다. 다시 고칠일이 없는 코드에 범용성을 위해 몇일을 소모하는, 휴먼 리소스 낭비마저 합리화 될 순 없다. 모두에게 시간은 평등하고, 가치 있기 때문에, 오버 엔지니어링 하지 않고 효율성도 고려하는 것이 좋은 엔지니어이기 때문이다. 대부분의 경우에는, 나쁘지 않은 구현으로 기능을 개발 한 뒤, 자주 사용되거나, 요구 사항이 확정 되거나, 피드백을 반영해서 완성하는 것이 합리적일 때가 많다. 내 경험상으로는 범용성을 위해서 들이는 코스트도, 특수화를 위한 결단과 판단력도 모두 빠른 프로토타이핑 혹은 방향성을 확인하기 위한 예광탄으로 검증 된 뒤 고도화 하는 것이 합리적인 경우가 많았다. 대부분의 요구 사항은 결과물을 보기전까지 모호함과 결함을 내재하고 있기 때문이다. 이 것이 애자일에서 주로 언급하는 빠른 이터레이션이다. 그 과정을 좀 더 명확해진 설계로 이어지고, 곧 좀 더 특수화, 범용화 하기 쉬워진다. 재작업을 비효율이라 여기는게 개발자들의 공통적인 생각인데, 범용화를 위해 쓰이는 시간이 낭비가 될 수 있다면, 이 역시 비효율로 여겨져야 한다고 생각한다. 범용화를 위해 확장성도 있고, 안정성도 잡는 룰을 갖추고, 그 룰의 시행착오를 갖추고 적용하기 위해선 아주 아주 많은 코스트가 들지만, 그만큼 가치있다. 그럼에도 거기에 들어가는 시간이 과다하다면, 엔지니어도, 엔지니어와 협업하는 다른 사람들도 납득시키기 어렵다. 난 코드 작성시의 범용성을 최우선 가치로 여기는 것은 옳지 않다고 생각한다. 범용성이 필요한 상황은 분명히 존재하나, 항상, 매번 중요한 가치로 여겨지기엔 들어가는 코스트가 너무 크고, 그 코스트가 효율성을 얻기 어려운 상황을 나는 매우 자주 접했기 때문이다. 빠른 구현을 통해 방향성과 타당성을 검증하고, 그 이후에 범용성을 선택할지, 특수화를 선택할지 상황과 해야 될 일에 맡게 판단하는 것이 합리적인, 실용적인 프로그래머가 아닐까?</summary></entry><entry><title type="html">2018년 회고</title><link href="https://elky84.github.io/2018/12/31/retrospect/" rel="alternate" type="text/html" title="2018년 회고" /><published>2018-12-31T00:00:00+00:00</published><updated>2018-12-31T00:00:00+00:00</updated><id>https://elky84.github.io/2018/12/31/retrospect</id><content type="html" xml:base="https://elky84.github.io/2018/12/31/retrospect/">&lt;p&gt;다사 다난한 일이 꽤 자주 있는 편인지라, 평소와 같았다 볼 수 있는 한해가 또 저물어 간다.&lt;/p&gt;

&lt;p&gt;과연 나에겐 어떤 일들이 있었고, 어떠한 생각들을 가지고 살았으며, 내년엔 무엇을 하고 싶은지 간단히 정리해보고자한다.&lt;/p&gt;

&lt;h1 id=&quot;블로그&quot;&gt;블로그&lt;/h1&gt;

&lt;p&gt;한해 동안 꽤나 많은 글을 썼다.
10월 초 이후의 글을 못썼음에도 35개의 글을 썼다.&lt;/p&gt;

&lt;p&gt;사람에 대한 글, 기술에 대한 글 다양한 종류의 글을 썼다.&lt;/p&gt;

&lt;p&gt;생각나는 주제에 대해서 짧게 기록 해둔 뒤, 시간이 날 때 글을 마무리해서 올리곤했다.&lt;/p&gt;

&lt;p&gt;업무 연관한 생각들을 정리했고, 스터디를 진행하면서, 식사 중에 나누던 대화 주제, 최근에 읽은 기술 서적에 대한 이야기 등 많은 이야기를 쓰고자 의도했다.&lt;/p&gt;

&lt;p&gt;작년과 올해 실무 언어를 자바를 사용하면서 새로 접하는 환경이 많다보니, 할말도 많아졌던 것 같다.&lt;/p&gt;

&lt;p&gt;굳이 의도적으로 더 많은 글을 쓴다거나, 양질의 글을 쓰기 위해 한달에 한번 쓴다거나 이럴 생각은없고 지금처럼 쓰되, 스크린샷이나 샘플 소스 코드를 좀 더 늘리는 방향으로 계획하고 있다.&lt;/p&gt;

&lt;h1 id=&quot;기술적-관심사&quot;&gt;기술적 관심사&lt;/h1&gt;

&lt;p&gt;웹 개발을 좀 더 비중 있게, 실무로 일하고 있다.
작년에도 하반기에는 웹개발을 했으나, 올해는 프론트엔드도 진행하고 있으며, public 서비스이다보니 일의 갯수보다는, 일의 질에 관심을 가지고 있으며, 자바를 그냥 쓰다가, 조금 더 제대로 쓰기 위한 여러가지 계기도 마련됐고,익숙해지고 있다.&lt;/p&gt;

&lt;p&gt;또한 Vue.js를 통해 frontend 실무를 처음으로 진행하게 됐고, 좀 더 웹에 대한 이해도가 높아지고 있는 것을 느끼고 있다.&lt;/p&gt;

&lt;p&gt;개인적으론 최근 몇달간은 데이터 처리 관련 업무를 진행할 수 없었는데, 개인적인 시간을 할애해서라도 이어가고 싶다.&lt;/p&gt;

&lt;h1 id=&quot;웹--플랫폼-개발&quot;&gt;웹 &amp;amp; 플랫폼 개발&lt;/h1&gt;

&lt;p&gt;자바와 웹을 접하면서, 가장 많이 깨닳은 것중 하나다.&lt;/p&gt;

&lt;p&gt;게임 개발은 일정 양 이상의 컨텐츠를 만들어야 한다.
프레임워크에 의존한 개발을 하는 경우도 드물고, 그 프레임워크마저 그 게임이 추구하는 몇가지 가치에 의해 뜯어 고쳐서 적용하게 될 만큼, 그 프로젝트 만을 위한 코드가 많이 생산된다.&lt;/p&gt;

&lt;p&gt;웹 개발은 반복되는 문제들이 꽤 많고, 이 문제들에 대한 오픈 소스 솔루션들이 여럿 존재한다.
내가 직접 생산 하는 코드 양은 적지만, 잘 조합하고, 내가 만드는 코드가 솔루션이나 프레임워크가 제시하는 방향과 유사하게끔 구현하고 관리하는 것이 중요하게 받아들여 지더라.&lt;/p&gt;

&lt;h1 id=&quot;토이-프로젝트&quot;&gt;토이 프로젝트&lt;/h1&gt;

&lt;p&gt;rails를 통해 웹을 접하면서 느꼈던, 잘 가져다 써서 빠른 구현을 통해 컨텐츠에 집중할 수 있는 환경을, 자바 &amp;amp; 스프링을 익히면서, 이를 바탕으로 업무를 진행하면서 좀 더 익숙해졌다.&lt;/p&gt;

&lt;p&gt;다른 프로젝트를 forking하기도 하고, 업무나 개인적인 공부를 통해서 익힌 것들을 통해 간단한 프로젝트들을 진행했다.&lt;/p&gt;

&lt;p&gt;다양한 국내 커뮤니티를 크롤링해서 mongodb에 저장하고, 이를 보여주는 게시판, 데스크탑 notificator, slack notificator (line notify로 만들었다가 수정) 등을 만들어 사용 중이며, riot api를 이용해 등록한 친구의 게임 시작/승/패 정보를 전달해주는 loltracer를 만들어서 지인들의 플레이를 추적하는 데에 쓰고 있다.&lt;/p&gt;

&lt;p&gt;개인적인 관심사와, context switching에 쓰이던 코스트를 줄이는 것을 목표로 삼아 개발했고, 이를 통해 여러 게시판을 돌아다니는 데에 쓰는 human cost (polling)을 줄이는 데에 성공했다.&lt;/p&gt;

&lt;p&gt;내년에는 오래 전부터 계획중이던 다른 토이 프로젝트를 구현 하기 위해, 우선 순위와 관심사를 조정하고 있다.&lt;/p&gt;

&lt;h1 id=&quot;개인적인-이야기&quot;&gt;개인적인 이야기&lt;/h1&gt;

&lt;p&gt;재입사를 했다. 이런 케이스가 꽤나 있는편이라, 굳이 특별할 건 없지만, 내 경우는 처음이라 많은 감정이 느껴졌다.&lt;/p&gt;

&lt;p&gt;특히 같은 회사 내에서 게임 개발 부서에서, 웹 &amp;amp; 플랫폼 개발 부서로 재입사를 하는 과정과, 실무를 진행하는 과정에서 아주 많이 다른 것들을 느끼고 있다.&lt;/p&gt;

&lt;p&gt;게임 개발도, 웹 개발도 암묵적인 룰들이 많은데, 아직은 그런 것들 서로간의 차이와 장단점을 받아들이고 이해하고, 흡수하는 데에 주력하고 있다.&lt;/p&gt;

&lt;p&gt;DB를 바라보는 관점, 스케일 아웃에 대한 마인드, 중요한 메트릭의 종류, 일하는 방식, 중요한 업무적 가치 등 작을 줄 알았던 차이가 예상보다 많이 커서 놀랐다.&lt;/p&gt;

&lt;p&gt;그래도 사람은 적응의 동물인가보다. 4달여 지난 지금 많이 적응했지만, 아직 배워야 할 것도, 익숙해져야 할 것도, 짬짬이 공부해야 할 것들도 많다.&lt;/p&gt;

&lt;p&gt;그렇기 때문에 내년에도 할 것들이, 성장 할 수 있는 꺼리들이 많이 있다고 생각한다.&lt;/p&gt;

&lt;h1 id=&quot;2019년-목표&quot;&gt;2019년 목표&lt;/h1&gt;
&lt;p&gt;위에서 조금 언급한 것들도 있지만, 정리하자면 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;영어 공부&lt;/li&gt;
  &lt;li&gt;블로그 글에 코드 샘플과 이미지를 좀 더 많이 첨부하고, 읽기 쉽게끔 문장 가다듬기&lt;/li&gt;
  &lt;li&gt;토이 프로젝트 활성화
    &lt;ul&gt;
      &lt;li&gt;지금 처럼 컨텐츠를 만들어 사용하는 방향도 좋지만, 좀 더 많은 사용자가 이용할 수 있는 패키지 개발도 검토 중이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;강아지 산책 시간 늘리기
    &lt;ul&gt;
      &lt;li&gt;짧게 자주! 특히 주말에!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;독서 시간 늘리기
    &lt;ul&gt;
      &lt;li&gt;인문 서적 비율을 늘려야 할 때 인 것 같다.&lt;/li&gt;
      &lt;li&gt;소설도 조금 더 늘리고 싶지만, 시간이 될 까 모르겠다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터 처리/분석에 대한 좀 더 심도 있는 공부와 적용.
    &lt;ul&gt;
      &lt;li&gt;언젠간 업무적으로 이어갈 기회로 이어질 수 있도록 조금 더 노력해둬야 겠다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;얼마나 이뤄낼 수 있을지는 모르겠으나, 장황하고 모호하게 썼으나 내 목표치 자체가 딱 끝맺음이 있는 것들보다는 꾸준히 지킬 수 있는 범주에 두는 것이 좋다는 것은 살아오면서 느꼈기 때문에 그렇게 계획하고자 했다.&lt;/p&gt;

&lt;p&gt;내년 한해엔 가능한한 많은 것들을 지키고, 이뤄 낼 수 있는 한해가 되면 좋겠다.&lt;/p&gt;</content><author><name>Elky Kim</name></author><category term="회고" /><summary type="html">다사 다난한 일이 꽤 자주 있는 편인지라, 평소와 같았다 볼 수 있는 한해가 또 저물어 간다. 과연 나에겐 어떤 일들이 있었고, 어떠한 생각들을 가지고 살았으며, 내년엔 무엇을 하고 싶은지 간단히 정리해보고자한다. 블로그 한해 동안 꽤나 많은 글을 썼다. 10월 초 이후의 글을 못썼음에도 35개의 글을 썼다. 사람에 대한 글, 기술에 대한 글 다양한 종류의 글을 썼다. 생각나는 주제에 대해서 짧게 기록 해둔 뒤, 시간이 날 때 글을 마무리해서 올리곤했다. 업무 연관한 생각들을 정리했고, 스터디를 진행하면서, 식사 중에 나누던 대화 주제, 최근에 읽은 기술 서적에 대한 이야기 등 많은 이야기를 쓰고자 의도했다. 작년과 올해 실무 언어를 자바를 사용하면서 새로 접하는 환경이 많다보니, 할말도 많아졌던 것 같다. 굳이 의도적으로 더 많은 글을 쓴다거나, 양질의 글을 쓰기 위해 한달에 한번 쓴다거나 이럴 생각은없고 지금처럼 쓰되, 스크린샷이나 샘플 소스 코드를 좀 더 늘리는 방향으로 계획하고 있다. 기술적 관심사 웹 개발을 좀 더 비중 있게, 실무로 일하고 있다. 작년에도 하반기에는 웹개발을 했으나, 올해는 프론트엔드도 진행하고 있으며, public 서비스이다보니 일의 갯수보다는, 일의 질에 관심을 가지고 있으며, 자바를 그냥 쓰다가, 조금 더 제대로 쓰기 위한 여러가지 계기도 마련됐고,익숙해지고 있다. 또한 Vue.js를 통해 frontend 실무를 처음으로 진행하게 됐고, 좀 더 웹에 대한 이해도가 높아지고 있는 것을 느끼고 있다. 개인적으론 최근 몇달간은 데이터 처리 관련 업무를 진행할 수 없었는데, 개인적인 시간을 할애해서라도 이어가고 싶다. 웹 &amp;amp; 플랫폼 개발 자바와 웹을 접하면서, 가장 많이 깨닳은 것중 하나다. 게임 개발은 일정 양 이상의 컨텐츠를 만들어야 한다. 프레임워크에 의존한 개발을 하는 경우도 드물고, 그 프레임워크마저 그 게임이 추구하는 몇가지 가치에 의해 뜯어 고쳐서 적용하게 될 만큼, 그 프로젝트 만을 위한 코드가 많이 생산된다. 웹 개발은 반복되는 문제들이 꽤 많고, 이 문제들에 대한 오픈 소스 솔루션들이 여럿 존재한다. 내가 직접 생산 하는 코드 양은 적지만, 잘 조합하고, 내가 만드는 코드가 솔루션이나 프레임워크가 제시하는 방향과 유사하게끔 구현하고 관리하는 것이 중요하게 받아들여 지더라. 토이 프로젝트 rails를 통해 웹을 접하면서 느꼈던, 잘 가져다 써서 빠른 구현을 통해 컨텐츠에 집중할 수 있는 환경을, 자바 &amp;amp; 스프링을 익히면서, 이를 바탕으로 업무를 진행하면서 좀 더 익숙해졌다. 다른 프로젝트를 forking하기도 하고, 업무나 개인적인 공부를 통해서 익힌 것들을 통해 간단한 프로젝트들을 진행했다. 다양한 국내 커뮤니티를 크롤링해서 mongodb에 저장하고, 이를 보여주는 게시판, 데스크탑 notificator, slack notificator (line notify로 만들었다가 수정) 등을 만들어 사용 중이며, riot api를 이용해 등록한 친구의 게임 시작/승/패 정보를 전달해주는 loltracer를 만들어서 지인들의 플레이를 추적하는 데에 쓰고 있다. 개인적인 관심사와, context switching에 쓰이던 코스트를 줄이는 것을 목표로 삼아 개발했고, 이를 통해 여러 게시판을 돌아다니는 데에 쓰는 human cost (polling)을 줄이는 데에 성공했다. 내년에는 오래 전부터 계획중이던 다른 토이 프로젝트를 구현 하기 위해, 우선 순위와 관심사를 조정하고 있다. 개인적인 이야기 재입사를 했다. 이런 케이스가 꽤나 있는편이라, 굳이 특별할 건 없지만, 내 경우는 처음이라 많은 감정이 느껴졌다. 특히 같은 회사 내에서 게임 개발 부서에서, 웹 &amp;amp; 플랫폼 개발 부서로 재입사를 하는 과정과, 실무를 진행하는 과정에서 아주 많이 다른 것들을 느끼고 있다. 게임 개발도, 웹 개발도 암묵적인 룰들이 많은데, 아직은 그런 것들 서로간의 차이와 장단점을 받아들이고 이해하고, 흡수하는 데에 주력하고 있다. DB를 바라보는 관점, 스케일 아웃에 대한 마인드, 중요한 메트릭의 종류, 일하는 방식, 중요한 업무적 가치 등 작을 줄 알았던 차이가 예상보다 많이 커서 놀랐다. 그래도 사람은 적응의 동물인가보다. 4달여 지난 지금 많이 적응했지만, 아직 배워야 할 것도, 익숙해져야 할 것도, 짬짬이 공부해야 할 것들도 많다. 그렇기 때문에 내년에도 할 것들이, 성장 할 수 있는 꺼리들이 많이 있다고 생각한다. 2019년 목표 위에서 조금 언급한 것들도 있지만, 정리하자면 다음과 같다. 영어 공부 블로그 글에 코드 샘플과 이미지를 좀 더 많이 첨부하고, 읽기 쉽게끔 문장 가다듬기 토이 프로젝트 활성화 지금 처럼 컨텐츠를 만들어 사용하는 방향도 좋지만, 좀 더 많은 사용자가 이용할 수 있는 패키지 개발도 검토 중이다. 강아지 산책 시간 늘리기 짧게 자주! 특히 주말에! 독서 시간 늘리기 인문 서적 비율을 늘려야 할 때 인 것 같다. 소설도 조금 더 늘리고 싶지만, 시간이 될 까 모르겠다. 데이터 처리/분석에 대한 좀 더 심도 있는 공부와 적용. 언젠간 업무적으로 이어갈 기회로 이어질 수 있도록 조금 더 노력해둬야 겠다. 얼마나 이뤄낼 수 있을지는 모르겠으나, 장황하고 모호하게 썼으나 내 목표치 자체가 딱 끝맺음이 있는 것들보다는 꾸준히 지킬 수 있는 범주에 두는 것이 좋다는 것은 살아오면서 느꼈기 때문에 그렇게 계획하고자 했다. 내년 한해엔 가능한한 많은 것들을 지키고, 이뤄 낼 수 있는 한해가 되면 좋겠다.</summary></entry><entry><title type="html">MySQL LIMIT + Offset 쿼리 성능 문제</title><link href="https://elky84.github.io/2018/10/05/mysql/" rel="alternate" type="text/html" title="MySQL LIMIT + Offset 쿼리 성능 문제" /><published>2018-10-05T00:00:00+00:00</published><updated>2018-10-05T00:00:00+00:00</updated><id>https://elky84.github.io/2018/10/05/mysql</id><content type="html" xml:base="https://elky84.github.io/2018/10/05/mysql/">&lt;p&gt;페이징 처리시 자주 사용되는 Offset. 단순히 쿼리로 OFFSET을 수행하면 성능 저하가 일어난다.&lt;/p&gt;

&lt;h3 id=&quot;offset-사용시-성능-저하-이슈에-대해-검토와-관련-글들&quot;&gt;offset 사용시 성능 저하 이슈에 대해 검토와 관련 글들&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://devoluk.com/mysql-limit-offset-performance.html&quot;&gt;http://devoluk.com/mysql-limit-offset-performance.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://explainextended.com/2009/10/23/mysql-order-by-limit-performance-late-row-lookups/&quot;&gt;https://explainextended.com/2009/10/23/mysql-order-by-limit-performance-late-row-lookups/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.eversql.com/faster-pagination-in-mysql-why-order-by-with-limit-and-offset-is-slow/&quot;&gt;https://www.eversql.com/faster-pagination-in-mysql-why-order-by-with-limit-and-offset-is-slow/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이를 확인하기 위해 DB에서 직접 쿼리를 날려 보자 (속도 차가 나는 것은 실제 사용 쿼리보다 좀 더 단순한 쿼리로 비교했기 때문임)
30만건 이상의 데이터를 넣어둔 테이블에서의 결과임을 밝혀둔다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM 테이블
order by project_name asc
LIMIT 10 OFFSET 300000;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/default_limit_offset.png&quot; alt=&quot;default_limit_offset&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3.2초&lt;br /&gt;
Full Table Scan이 일어남 (전체 데이터 건수에 대한 접근)&lt;br /&gt;
그리고, 그 데이터들을 모두 정렬하는 과정의 코스트가 많이 발생함.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * 
FROM 테이블 as p
JOIN (SELECT 키값 
    FROM   테이블
    ORDER  BY 정렬컬럼 LIMIT 300000, 10) AS t ON t.키 = p.키; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/tuning_limit_offset.png&quot; alt=&quot;tuning_limit_offset&quot; /&gt;&lt;/p&gt;

&lt;p&gt;0.641초&lt;br /&gt;
Full Index Scan이 일어난 뒤, 인덱스를 정렬함. &lt;br /&gt;
정렬된 데이터를 기준으로 Unique Key Lookup 기반의 Nested Loop 처리로 인한 성능 향상&lt;/p&gt;

&lt;h3 id=&quot;인덱스-구조-관련-팁&quot;&gt;인덱스 구조 관련 팁&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;LIMIT OFFSET 에서 사용하는 Sorting 값이 있다면, 해당 값을 Clustering Index로 잡으면 성능 이득을 더 크게 볼 수 있다.&lt;/li&gt;
  &lt;li&gt;Sort 과정을 건너뛰어도 되는 만큼 처리할 데이터양이 많거나 클수록 차이가 나는 부분이니, 페이징할 데이터 양이 큰 경우 검토할 여지가 있다.
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://12bme.tistory.com/149&quot;&gt;클러스터링 인덱스&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Elky Kim</name></author><category term="MySQL" /><category term="Limit Offset" /><summary type="html">페이징 처리시 자주 사용되는 Offset. 단순히 쿼리로 OFFSET을 수행하면 성능 저하가 일어난다. offset 사용시 성능 저하 이슈에 대해 검토와 관련 글들 http://devoluk.com/mysql-limit-offset-performance.html https://explainextended.com/2009/10/23/mysql-order-by-limit-performance-late-row-lookups/ https://www.eversql.com/faster-pagination-in-mysql-why-order-by-with-limit-and-offset-is-slow/ 이를 확인하기 위해 DB에서 직접 쿼리를 날려 보자 (속도 차가 나는 것은 실제 사용 쿼리보다 좀 더 단순한 쿼리로 비교했기 때문임) 30만건 이상의 데이터를 넣어둔 테이블에서의 결과임을 밝혀둔다. SELECT * FROM 테이블 order by project_name asc LIMIT 10 OFFSET 300000; 3.2초 Full Table Scan이 일어남 (전체 데이터 건수에 대한 접근) 그리고, 그 데이터들을 모두 정렬하는 과정의 코스트가 많이 발생함. SELECT * FROM 테이블 as p JOIN (SELECT 키값 FROM 테이블 ORDER BY 정렬컬럼 LIMIT 300000, 10) AS t ON t.키 = p.키; 0.641초 Full Index Scan이 일어난 뒤, 인덱스를 정렬함. 정렬된 데이터를 기준으로 Unique Key Lookup 기반의 Nested Loop 처리로 인한 성능 향상 인덱스 구조 관련 팁 LIMIT OFFSET 에서 사용하는 Sorting 값이 있다면, 해당 값을 Clustering Index로 잡으면 성능 이득을 더 크게 볼 수 있다. Sort 과정을 건너뛰어도 되는 만큼 처리할 데이터양이 많거나 클수록 차이가 나는 부분이니, 페이징할 데이터 양이 큰 경우 검토할 여지가 있다. 클러스터링 인덱스</summary></entry><entry><title type="html">Ubuntu vs CentOS</title><link href="https://elky84.github.io/2018/10/01/ubuntu_vs_centos/" rel="alternate" type="text/html" title="Ubuntu vs CentOS" /><published>2018-10-01T00:00:00+00:00</published><updated>2018-10-01T00:00:00+00:00</updated><id>https://elky84.github.io/2018/10/01/ubuntu_vs_centos</id><content type="html" xml:base="https://elky84.github.io/2018/10/01/ubuntu_vs_centos/">&lt;p&gt;종종 언급했지만, 나는 자의적으로 서버 프로그래머가 된 케이스는 아니다.&lt;/p&gt;

&lt;p&gt;반 강제 서버 프로그래머로 전향한 2006년 당시만해도 대다수의 게임 개발은 윈도우 기반의 온라인 게임이었다보니, 당연히 게임 클라이언트 개발도 윈도우가 지배적이었다.&lt;/p&gt;

&lt;p&gt;더군다나 게임 서버 개발자 중 반절 이상은 클라이언트 개발을 하다가 인원 부족이나 전문 인력 부족으로 전향한 나와 같은 케이스가 많다 보니 클라이언트 개발시에 그리고 평상시 자주 사용해 익숙하던 윈도우 환경에서 서버를 구축하기 시작했다.&lt;/p&gt;

&lt;p&gt;아무래도 공통된 유틸리티성 코드 활용을 위함과 학습 코스트, 운용 코스트 등을 고려한 측면에서의 영향도 큰데, 서버와 클라이언트의 많은 코드를 공유하게 되면 커버리지도 공동 확보되는 경향도 있어서 일 것이다.&lt;/p&gt;

&lt;p&gt;나 역시 클라이언트에서 전향한 사례였다 보니 윈도우가 훨씬 익숙했고, 로 서버를 꽤나 긴 시간 개발해왔다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;그러던 중 리눅스를 실무에 사용하게 된 계기는 윈도우에서 production이 불가능에 가깝던 ruby on rails를 쓰게 되면서 였다.&lt;/p&gt;

&lt;p&gt;학습용으로 rails를 배워나가면서, 로그 처리 웹서버를 구성했었다. 간단한 기능이나 rails의 기본 기능들 까지는 동작하는데, 다수의 패키지가 윈도우에서 안도는 것들 투성이라서 선택지가 없었다.&lt;/p&gt;

&lt;p&gt;같은 이유로 이후에 스타트업에서 ruby on rails를 이용한 웹 서버로 게임 서비스를 해야 될 때도 어쩔 수 없이 리눅스를 써야 했다.&lt;/p&gt;

&lt;p&gt;윈도우 서버로는 production 레벨로 올릴 수 없기에, 여러가지 리눅스를 검토하기 시작했다.&lt;/p&gt;

&lt;p&gt;검토하다 보니 Ubuntu와 CentOS로 좁혀졌는데, 이는 다수의 클라우드 서버 및 물리 서버 호스팅을 위한 검토과정에서 공통적으로 지원하는 리눅스 계열 OS는 이 둘 뿐이었고, 왜 그런가를 살펴보았다.&lt;/p&gt;

&lt;h3 id=&quot;centos&quot;&gt;CentOS&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;RHEL을 지연 반영하는 안정성 높은 OS
    &lt;ul&gt;
      &lt;li&gt;반대로 버그 패치도 지연 반영되는 단점.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RPM(Redhat Package Manager)를 이용한 쉬운 설치/제거.
    &lt;ul&gt;
      &lt;li&gt;의존성 패키지 문제를 유발하는 원흉이 되기도 함.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;밸런스 있는 발전 속도와 혁신 (RHEL의 기조를 그대로 따라 감)&lt;/li&gt;
  &lt;li&gt;기술 지원이 쉽지 않음.
    &lt;ul&gt;
      &lt;li&gt;필요할 경우 RHEL을 쓰는게 낫다고 여겨짐.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;레드햇 계열 배포판 비교
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.lesstif.com/pages/viewpage.action?pageId=20775405&quot;&gt;https://www.lesstif.com/pages/viewpage.action?pageId=20775405&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ubuntu&quot;&gt;Ubuntu&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;LTS를 통한 장기 지원, 단기 유지되지만 새로운 시도를 하는 일반 버전 동시 지원.&lt;/li&gt;
  &lt;li&gt;다수의 사용자 커뮤니티 확보&lt;/li&gt;
  &lt;li&gt;데비안 기반의 신뢰도&lt;/li&gt;
  &lt;li&gt;데비안을 지연 반영하는 높은 안정성과 빠른 변화를 추구하는 우분투의 방향성의 밸런스
    &lt;ul&gt;
      &lt;li&gt;대신 빠른 버그 수정 및 대응이 강점.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;캐노니컬의 영업력으로 인한 높은 하드웨어 호환율&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우분투는 데비안의 안정성을 일부 취하면서, 빠른 변화와 새로운 패키지나 규칙 변화에 능동적인 편에 속한다. LTS 버전이라 할지라도 데비안이나 CentOS보단 불안정할 수 있지만, 그럼에도 최신 패키지나 새로운 라이브러리들을 가져다가 시험적인 혹은 프론티어 적인 시도를 하기 좋다고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;CentOS의 경우 안정 지향의 RHEL의 지연 반영이라는 점에서 큰 인기를 끄는 편이고, 왜 그런지 모르겠으나 같은 포지션의 데비안은 국내에선 상대적으로 덜 선택되는 편이었다.&lt;/p&gt;

&lt;p&gt;이 글을 정리하면서 궁금해서, 여러 글을 읽게 됐고 각 OS별 위키를 자세히 읽고 확인하게 됐는데, 해외에서의  점유율은 Ubuntu, Debian, CentOS가 3톱을 구성하고 있었고, 그 중 Ubuntu가 압도적인 수치 (37.5%)를 차지하고 있음을 알 수 있었다.&lt;/p&gt;

&lt;p&gt;2017년의 웹 기술: &lt;a href=&quot;https://w3techs.com/blog/entry/web_technologies_of_the_year_2017&quot;&gt;https://w3techs.com/blog/entry/web_technologies_of_the_year_2017&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/os_of_the_year_2017.png&quot; alt=&quot;os_of_the_year_2017&quot; /&gt;&lt;/p&gt;

&lt;p&gt;리눅스 배포판 별 점유율: &lt;a href=&quot;https://w3techs.com/technologies/details/os-linux/all/all&quot;&gt;https://w3techs.com/technologies/details/os-linux/all/all&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018_september_percentage_of_websites_using_linux.png&quot; alt=&quot;2018_september_percentage_of_websites_using_linux&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018_september_subcategories_of_linux.png&quot; alt=&quot;2018_september_subcategories_of_linux&quot; /&gt;&lt;/p&gt;

&lt;p&gt;글 제목에서도 알 수 있듯이, 나는 CentOS (+RHEL)과 Ubuntu (+Debian) 의 구도를 유지하고 있을 거라 생각했는데, 통계 사이트가 정확한 수치를 반영하기 어렵다는 것을 알지만, 그럼에도 꽤나 큰 차이는 충격적이었다.&lt;/p&gt;

&lt;p&gt;이런 큰 수치차이는 패키지 매니저의 특징과 관리 이슈, 안정성에 대한 시선에 따른 차이지 않을까 싶다.
우분투 데비안과 CentOS 사이의 균형을 잘 찾았다고 인지되고 있는 듯 하고, 그 정점에는 LTS를 통한 안정적 버전에 대한 신뢰도 있는게 아닐까 싶었다.&lt;/p&gt;

&lt;h3 id=&quot;배포판-별-위키&quot;&gt;배포판 별 위키&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%8D%B0%EB%B9%84%EC%95%88&quot;&gt;데비안&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9A%B0%EB%B6%84%ED%88%AC_(%EC%9A%B4%EC%98%81_%EC%B2%B4%EC%A0%9C)&quot;&gt;우분투&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/CentOS&quot;&gt;CentOS&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%A0%88%EB%93%9C%ED%96%87_%EC%97%94%ED%84%B0%ED%94%84%EB%9D%BC%EC%9D%B4%EC%A6%88_%EB%A6%AC%EB%88%85%EC%8A%A4&quot;&gt;RHEL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;리눅스를 능숙하게 쓴다고 감히 얘기할 수 있게 된 시기는, 각 OS별로 수많은 어플리케이션을 다뤄보고, 운용해보고, 이슈를 겪어보고 나서야 말 할 수 있었다.&lt;/p&gt;

&lt;p&gt;어플리케이션을 구동하기 위한 패키지 관리, 직접 컴파일해서 사용, 패키지간 충돌 해결 등의 다양한 문제와 함께 익숙해져감을 몸소 느낄 수 있었고 말이다.&lt;/p&gt;

&lt;p&gt;그리나서야 CentOS와 Ubuntu의 장단점에 대해서 얘기할 수 있을거란 생각이 들어 이 글을 쓰기 시작했고, 분명히 CentOS를 좀 더 지지하기 하려 했었으나, 통계와의 오차는 당황 스러우면서도 매우 흥미로웠다.&lt;/p&gt;

&lt;p&gt;또한 내 개인적 경험으로 인한 편견인지, 실제로 그걸 감안하고도 밸런스 좋은 OS인 Ubuntu가 인기 있는 것인지 알고 싶어졌다.&lt;/p&gt;

&lt;p&gt;한편으로는 동시에 서버 OS 배포판 별 통계나, 배포판 별 역사, 배포판 별 특징 등에 대해서 좀 더 잘 알 수 있게 된 계기가 됐다는 생각도 든다. 그리고 &lt;strong&gt;데비안을 써보고 싶어졌다.&lt;/strong&gt;&lt;/p&gt;</content><author><name>Elky Kim</name></author><category term="리눅스" /><category term="Ubuntu" /><category term="CentOS" /><summary type="html">종종 언급했지만, 나는 자의적으로 서버 프로그래머가 된 케이스는 아니다. 반 강제 서버 프로그래머로 전향한 2006년 당시만해도 대다수의 게임 개발은 윈도우 기반의 온라인 게임이었다보니, 당연히 게임 클라이언트 개발도 윈도우가 지배적이었다. 더군다나 게임 서버 개발자 중 반절 이상은 클라이언트 개발을 하다가 인원 부족이나 전문 인력 부족으로 전향한 나와 같은 케이스가 많다 보니 클라이언트 개발시에 그리고 평상시 자주 사용해 익숙하던 윈도우 환경에서 서버를 구축하기 시작했다. 아무래도 공통된 유틸리티성 코드 활용을 위함과 학습 코스트, 운용 코스트 등을 고려한 측면에서의 영향도 큰데, 서버와 클라이언트의 많은 코드를 공유하게 되면 커버리지도 공동 확보되는 경향도 있어서 일 것이다. 나 역시 클라이언트에서 전향한 사례였다 보니 윈도우가 훨씬 익숙했고, 로 서버를 꽤나 긴 시간 개발해왔다. 그러던 중 리눅스를 실무에 사용하게 된 계기는 윈도우에서 production이 불가능에 가깝던 ruby on rails를 쓰게 되면서 였다. 학습용으로 rails를 배워나가면서, 로그 처리 웹서버를 구성했었다. 간단한 기능이나 rails의 기본 기능들 까지는 동작하는데, 다수의 패키지가 윈도우에서 안도는 것들 투성이라서 선택지가 없었다. 같은 이유로 이후에 스타트업에서 ruby on rails를 이용한 웹 서버로 게임 서비스를 해야 될 때도 어쩔 수 없이 리눅스를 써야 했다. 윈도우 서버로는 production 레벨로 올릴 수 없기에, 여러가지 리눅스를 검토하기 시작했다. 검토하다 보니 Ubuntu와 CentOS로 좁혀졌는데, 이는 다수의 클라우드 서버 및 물리 서버 호스팅을 위한 검토과정에서 공통적으로 지원하는 리눅스 계열 OS는 이 둘 뿐이었고, 왜 그런가를 살펴보았다. CentOS RHEL을 지연 반영하는 안정성 높은 OS 반대로 버그 패치도 지연 반영되는 단점. RPM(Redhat Package Manager)를 이용한 쉬운 설치/제거. 의존성 패키지 문제를 유발하는 원흉이 되기도 함. 밸런스 있는 발전 속도와 혁신 (RHEL의 기조를 그대로 따라 감) 기술 지원이 쉽지 않음. 필요할 경우 RHEL을 쓰는게 낫다고 여겨짐. 레드햇 계열 배포판 비교 https://www.lesstif.com/pages/viewpage.action?pageId=20775405 Ubuntu LTS를 통한 장기 지원, 단기 유지되지만 새로운 시도를 하는 일반 버전 동시 지원. 다수의 사용자 커뮤니티 확보 데비안 기반의 신뢰도 데비안을 지연 반영하는 높은 안정성과 빠른 변화를 추구하는 우분투의 방향성의 밸런스 대신 빠른 버그 수정 및 대응이 강점. 캐노니컬의 영업력으로 인한 높은 하드웨어 호환율 우분투는 데비안의 안정성을 일부 취하면서, 빠른 변화와 새로운 패키지나 규칙 변화에 능동적인 편에 속한다. LTS 버전이라 할지라도 데비안이나 CentOS보단 불안정할 수 있지만, 그럼에도 최신 패키지나 새로운 라이브러리들을 가져다가 시험적인 혹은 프론티어 적인 시도를 하기 좋다고 볼 수 있다. CentOS의 경우 안정 지향의 RHEL의 지연 반영이라는 점에서 큰 인기를 끄는 편이고, 왜 그런지 모르겠으나 같은 포지션의 데비안은 국내에선 상대적으로 덜 선택되는 편이었다. 이 글을 정리하면서 궁금해서, 여러 글을 읽게 됐고 각 OS별 위키를 자세히 읽고 확인하게 됐는데, 해외에서의 점유율은 Ubuntu, Debian, CentOS가 3톱을 구성하고 있었고, 그 중 Ubuntu가 압도적인 수치 (37.5%)를 차지하고 있음을 알 수 있었다. 2017년의 웹 기술: https://w3techs.com/blog/entry/web_technologies_of_the_year_2017 리눅스 배포판 별 점유율: https://w3techs.com/technologies/details/os-linux/all/all 글 제목에서도 알 수 있듯이, 나는 CentOS (+RHEL)과 Ubuntu (+Debian) 의 구도를 유지하고 있을 거라 생각했는데, 통계 사이트가 정확한 수치를 반영하기 어렵다는 것을 알지만, 그럼에도 꽤나 큰 차이는 충격적이었다. 이런 큰 수치차이는 패키지 매니저의 특징과 관리 이슈, 안정성에 대한 시선에 따른 차이지 않을까 싶다. 우분투 데비안과 CentOS 사이의 균형을 잘 찾았다고 인지되고 있는 듯 하고, 그 정점에는 LTS를 통한 안정적 버전에 대한 신뢰도 있는게 아닐까 싶었다. 배포판 별 위키 데비안 우분투 CentOS RHEL 리눅스를 능숙하게 쓴다고 감히 얘기할 수 있게 된 시기는, 각 OS별로 수많은 어플리케이션을 다뤄보고, 운용해보고, 이슈를 겪어보고 나서야 말 할 수 있었다. 어플리케이션을 구동하기 위한 패키지 관리, 직접 컴파일해서 사용, 패키지간 충돌 해결 등의 다양한 문제와 함께 익숙해져감을 몸소 느낄 수 있었고 말이다. 그리나서야 CentOS와 Ubuntu의 장단점에 대해서 얘기할 수 있을거란 생각이 들어 이 글을 쓰기 시작했고, 분명히 CentOS를 좀 더 지지하기 하려 했었으나, 통계와의 오차는 당황 스러우면서도 매우 흥미로웠다. 또한 내 개인적 경험으로 인한 편견인지, 실제로 그걸 감안하고도 밸런스 좋은 OS인 Ubuntu가 인기 있는 것인지 알고 싶어졌다. 한편으로는 동시에 서버 OS 배포판 별 통계나, 배포판 별 역사, 배포판 별 특징 등에 대해서 좀 더 잘 알 수 있게 된 계기가 됐다는 생각도 든다. 그리고 데비안을 써보고 싶어졌다.</summary></entry><entry><title type="html">JavaScript 적응기 01 - Vue.js</title><link href="https://elky84.github.io/2018/09/29/js_vue_js_story/" rel="alternate" type="text/html" title="JavaScript 적응기 01 - Vue.js" /><published>2018-09-29T00:00:00+00:00</published><updated>2018-09-29T00:00:00+00:00</updated><id>https://elky84.github.io/2018/09/29/js_vue_js_story</id><content type="html" xml:base="https://elky84.github.io/2018/09/29/js_vue_js_story/">&lt;p&gt;최근 새 팀에 합류했다.&lt;/p&gt;

&lt;p&gt;합류한 팀에서 풀 스택 개발 추구하고 있었고, 그 과정에서 웹 프론트엔드 개발에 vue.js를 사용하고 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Vue.png&quot; alt=&quot;Vue.js&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자연스레 자바 스크립트를 사용해야 했는데, 2009~2012년경 윈도우 배치 스크립트 짜기 괴로워, Jscript (윈도우 내장 자바 스크립트 엔진을 이용한 스크립팅)을 했던 뒤로 오랜만에 실무에 사용하게 됐다.&lt;/p&gt;

&lt;p&gt;종종 Node.js를 이용한 REST API 서버를 가볍게 써오긴 했으나, 나의 경우엔 업무 외적인 습작에 써왔고, 백엔드 서버로써 사용한 거라 굉장히 다르다고 할 수 있다.&lt;/p&gt;

&lt;p&gt;주로 백엔드 내지는 서버 개발자 포지션에 있었으나, 클라이언트 개발에 관심도 많고 종종 해왔던지라 거부감이 없다는 점은 매우 다행이지 않나 싶다. 팀의 방향성과 나의 가치관에 충돌이 있을 땐 스트레스 요소가 될 수 있는데, 나는 아주 좋은 기회라고 생각이 들었고, 재미도 있었다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;대략 한달 간 가량 진행한 Vue.js의 감흥은 생각보다 쉽다 였다.
웹 프론트엔드 문외한이나 다름없었지만, 동료들이 작성한 코드를 보고 구조적인 이해나, &lt;a href=&quot;https://www.inflearn.com/course/vue-pwa-vue-js-%EA%B8%B0%EB%B3%B8/&quot;&gt;인프런 vue.js 강좌&lt;/a&gt;와 동일한 강사분이 써두신 &lt;a href=&quot;https://joshua1988.github.io/web-development/vuejs/vuejs-tutorial-for-beginner/&quot;&gt;입문서&lt;/a&gt;를 보고 금새 무언가를 만들 수 있을 만큼 직관적이고, 동작하는 무언가를 만드는 시간이 적게 소요됐다.&lt;/p&gt;

&lt;p&gt;즉 학습도, 실습도 빠른 시간내에 가능했다는 의미다.&lt;/p&gt;

&lt;p&gt;가장 도움이 된 것은 vue.js의 컴포넌트 라이프 사이클 이해하기 였는데, 유니티때와 마찬가지로 컴포넌트간 상호 작용이 크게 중요한 만큼, 이 그림은 계속 참고하면서 코딩하게 되는 유용한 자료 였다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/vue_lifecycle.png&quot; alt=&quot;Vue.js Lifecycle&quot; /&gt;&lt;/p&gt;

&lt;p&gt;참고: &lt;a href=&quot;https://medium.com/witinweb/vue-js-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-7780cdd97dd4&quot;&gt;https://medium.com/witinweb/vue-js-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-7780cdd97dd4&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;반면 힘들었던 점은 역시나 언어의 태생적인 단점이었다.
나는 강타입 언어를 선호하는데, java script 자체는 typeless 언어라서, 이에 대한 아쉬움이 있었다.&lt;/p&gt;

&lt;p&gt;Vue.js에서도 TypeScript를 지원 &lt;a href=&quot;https://kr.vuejs.org/v2/guide/typescript.html&quot;&gt;Vue.js TypeScript 지원&lt;/a&gt; 
하고 있으나, 현재 팀에선 사용하고 있지 않은 상태였고, 리액트에 비해 상대적으로 미약하다고 한다. 이 부분은 아무래도 좀 이해도가 높아진 후에야 명확히 말할 수 있을 것 같다.&lt;/p&gt;

&lt;p&gt;Vue.js 자체의 규칙은 간결하고 직관적이라 쉬운편이라고 할 수 있는 반면, 내가 HTML5, css, bootstrap등에 대한 이해도나 경험이 부족해서 이 부분에 대해서 막히는 부분이 많았다.&lt;/p&gt;

&lt;p&gt;html을 직접 작성해야 하고, vue와 결합도가 높게 동작하고 연관하여 분석, 작성 해야 하다 보니 부족한 이해도가 아쉬웠다.&lt;/p&gt;

&lt;p&gt;그런 부분을 감안했을 때에도 생각보다 허들이 낮은 편에 속했고, 프레임워크 자체에 대한 룰이나 제약이 단순하고, 해결 방법도 제시되어 있어 큰 어려움이 없이 작업 할 수 있었다.&lt;/p&gt;

&lt;p&gt;Vue.js에서 주장하는 쉽고 빠른 간결한 프레임워크라는 주장을 신뢰할 수 있는 경험이었다고 할 수 있겠다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;애초에 Web Frontend라 할 수 있는 작업도 처음이지만, SPA로 작업한 것도 처음이고, 컴포넌트 단위로 코딩한 것도 처음이지만, 게임 UI랑 비교 했을 때에 아주 색다른 개념들은 크진 않았다.&lt;/p&gt;

&lt;p&gt;컴포넌트간 통신 및 계층에 따른 의미나 제약을 집중해서 살펴보면서 작업을 진행했다.&lt;/p&gt;

&lt;p&gt;컴포넌트 간의 순환 참조, 생성 순서 문제, 상호 통신, 순환 참조 문제 등 다양한 이슈가 얽혀 있었다. 선행 조건들이 늘어 날 수록 컴포넌트 간의 관계도 복잡해지고, 결합도가 높아지는 걸 느낄 수 있었는데, 이에 대한 몇가지 우회 방법들이나 팁이 존재하더라.&lt;/p&gt;

&lt;p&gt;또 다른 측면의 걱정은 느리지 않을까?&lt;/p&gt;

&lt;p&gt;처음 맞닥뜨린 vue.js는 각 컴포넌트를 감시하게 동작 할 것 같다는 생각이 강하게 들었었다.&lt;/p&gt;

&lt;p&gt;앵귤러의 특징이면서도 단점으로 여겨지는 양방향 바인딩도 존재하고, v-bind나 v-if 등의 키워드로써 걸어놓은 트리거들이 동작하는 것들이 많고, 쉽게 사용할 수 있게 직관성을 강조하다보니 그만큼 느리지 않을까 하는 우려가 있었다. (물론 내부적으로 최대한 폴링보다는 이벤트 드리븐으로 잘 짰겠지만, 미지의 영역인 프론트 엔드 프레임워크에 대한 막연한 의구심 같은 거라고 할 수 있겠다.)&lt;/p&gt;

&lt;p&gt;아주 의외인 것은 &lt;a href=&quot;https://kr.vuejs.org/v2/guide/comparison.html&quot;&gt;리액트보다 빠르다는 점&lt;/a&gt;이었다. 측정한 곳이 vue.js 공식 페이지다보니 수치나 정말 복잡하게 사용하는 상황에서 마저 우위에 있을지를 100% 믿기엔 어렵겠지만 말이다.&lt;/p&gt;

&lt;p&gt;막연한 의구심을 해소하기 위해 이런 저런 글들과, 지인들에게 자문을 구했는데, 결론은 프론트엔드 프레임워크 대부분이 사용성과의 밸런스를 맞추기 위한 코스트를 감안하고 구현되어 있고, 돔을 직접 다루는 번거로움과 어지간히 잘 관리하지 못하면 돔을 찾고 수정하는 과정에 오버헤드가 걸리곤 하는데, 이를 프레임워크가 관리하면서 적정 수치 이상으로 유지해주기에 신경 쓸 거리가 적다고 봐야 한다는 것이었다.&lt;/p&gt;

&lt;p&gt;이런 고민들이나 의구심들 대다수가 게임 UI 에서도 공통되게 고민되는 것 들이고, 비슷하게 접근하고 나면 납득 할 수 있는 것들이 많았다.&lt;/p&gt;

&lt;p&gt;다만 현재까지의 생각과 감상이 든 과정 모두 내가 적응기로써 짧은 기간 학습+적응을 목표로 작업한 admin web에 한정된 이야기였고, 브라우저 호환성 및 메모리 이슈, 훨씬 더 복잡한 UI간 상호 작용을 요구하는 작업에선 훨씬 더 많은 감상이 있지 않을까 싶다.&lt;/p&gt;</content><author><name>Elky Kim</name></author><category term="JavaScript" /><category term="Vue.js" /><category term="Frontend" /><summary type="html">최근 새 팀에 합류했다. 합류한 팀에서 풀 스택 개발 추구하고 있었고, 그 과정에서 웹 프론트엔드 개발에 vue.js를 사용하고 있었다. 자연스레 자바 스크립트를 사용해야 했는데, 2009~2012년경 윈도우 배치 스크립트 짜기 괴로워, Jscript (윈도우 내장 자바 스크립트 엔진을 이용한 스크립팅)을 했던 뒤로 오랜만에 실무에 사용하게 됐다. 종종 Node.js를 이용한 REST API 서버를 가볍게 써오긴 했으나, 나의 경우엔 업무 외적인 습작에 써왔고, 백엔드 서버로써 사용한 거라 굉장히 다르다고 할 수 있다. 주로 백엔드 내지는 서버 개발자 포지션에 있었으나, 클라이언트 개발에 관심도 많고 종종 해왔던지라 거부감이 없다는 점은 매우 다행이지 않나 싶다. 팀의 방향성과 나의 가치관에 충돌이 있을 땐 스트레스 요소가 될 수 있는데, 나는 아주 좋은 기회라고 생각이 들었고, 재미도 있었다. 대략 한달 간 가량 진행한 Vue.js의 감흥은 생각보다 쉽다 였다. 웹 프론트엔드 문외한이나 다름없었지만, 동료들이 작성한 코드를 보고 구조적인 이해나, 인프런 vue.js 강좌와 동일한 강사분이 써두신 입문서를 보고 금새 무언가를 만들 수 있을 만큼 직관적이고, 동작하는 무언가를 만드는 시간이 적게 소요됐다. 즉 학습도, 실습도 빠른 시간내에 가능했다는 의미다. 가장 도움이 된 것은 vue.js의 컴포넌트 라이프 사이클 이해하기 였는데, 유니티때와 마찬가지로 컴포넌트간 상호 작용이 크게 중요한 만큼, 이 그림은 계속 참고하면서 코딩하게 되는 유용한 자료 였다. 참고: https://medium.com/witinweb/vue-js-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-7780cdd97dd4 반면 힘들었던 점은 역시나 언어의 태생적인 단점이었다. 나는 강타입 언어를 선호하는데, java script 자체는 typeless 언어라서, 이에 대한 아쉬움이 있었다. Vue.js에서도 TypeScript를 지원 Vue.js TypeScript 지원 하고 있으나, 현재 팀에선 사용하고 있지 않은 상태였고, 리액트에 비해 상대적으로 미약하다고 한다. 이 부분은 아무래도 좀 이해도가 높아진 후에야 명확히 말할 수 있을 것 같다. Vue.js 자체의 규칙은 간결하고 직관적이라 쉬운편이라고 할 수 있는 반면, 내가 HTML5, css, bootstrap등에 대한 이해도나 경험이 부족해서 이 부분에 대해서 막히는 부분이 많았다. html을 직접 작성해야 하고, vue와 결합도가 높게 동작하고 연관하여 분석, 작성 해야 하다 보니 부족한 이해도가 아쉬웠다. 그런 부분을 감안했을 때에도 생각보다 허들이 낮은 편에 속했고, 프레임워크 자체에 대한 룰이나 제약이 단순하고, 해결 방법도 제시되어 있어 큰 어려움이 없이 작업 할 수 있었다. Vue.js에서 주장하는 쉽고 빠른 간결한 프레임워크라는 주장을 신뢰할 수 있는 경험이었다고 할 수 있겠다. 애초에 Web Frontend라 할 수 있는 작업도 처음이지만, SPA로 작업한 것도 처음이고, 컴포넌트 단위로 코딩한 것도 처음이지만, 게임 UI랑 비교 했을 때에 아주 색다른 개념들은 크진 않았다. 컴포넌트간 통신 및 계층에 따른 의미나 제약을 집중해서 살펴보면서 작업을 진행했다. 컴포넌트 간의 순환 참조, 생성 순서 문제, 상호 통신, 순환 참조 문제 등 다양한 이슈가 얽혀 있었다. 선행 조건들이 늘어 날 수록 컴포넌트 간의 관계도 복잡해지고, 결합도가 높아지는 걸 느낄 수 있었는데, 이에 대한 몇가지 우회 방법들이나 팁이 존재하더라. 또 다른 측면의 걱정은 느리지 않을까? 처음 맞닥뜨린 vue.js는 각 컴포넌트를 감시하게 동작 할 것 같다는 생각이 강하게 들었었다. 앵귤러의 특징이면서도 단점으로 여겨지는 양방향 바인딩도 존재하고, v-bind나 v-if 등의 키워드로써 걸어놓은 트리거들이 동작하는 것들이 많고, 쉽게 사용할 수 있게 직관성을 강조하다보니 그만큼 느리지 않을까 하는 우려가 있었다. (물론 내부적으로 최대한 폴링보다는 이벤트 드리븐으로 잘 짰겠지만, 미지의 영역인 프론트 엔드 프레임워크에 대한 막연한 의구심 같은 거라고 할 수 있겠다.) 아주 의외인 것은 리액트보다 빠르다는 점이었다. 측정한 곳이 vue.js 공식 페이지다보니 수치나 정말 복잡하게 사용하는 상황에서 마저 우위에 있을지를 100% 믿기엔 어렵겠지만 말이다. 막연한 의구심을 해소하기 위해 이런 저런 글들과, 지인들에게 자문을 구했는데, 결론은 프론트엔드 프레임워크 대부분이 사용성과의 밸런스를 맞추기 위한 코스트를 감안하고 구현되어 있고, 돔을 직접 다루는 번거로움과 어지간히 잘 관리하지 못하면 돔을 찾고 수정하는 과정에 오버헤드가 걸리곤 하는데, 이를 프레임워크가 관리하면서 적정 수치 이상으로 유지해주기에 신경 쓸 거리가 적다고 봐야 한다는 것이었다. 이런 고민들이나 의구심들 대다수가 게임 UI 에서도 공통되게 고민되는 것 들이고, 비슷하게 접근하고 나면 납득 할 수 있는 것들이 많았다. 다만 현재까지의 생각과 감상이 든 과정 모두 내가 적응기로써 짧은 기간 학습+적응을 목표로 작업한 admin web에 한정된 이야기였고, 브라우저 호환성 및 메모리 이슈, 훨씬 더 복잡한 UI간 상호 작용을 요구하는 작업에선 훨씬 더 많은 감상이 있지 않을까 싶다.</summary></entry><entry><title type="html">Vue.js 참고 자료</title><link href="https://elky84.github.io/2018/09/29/vue_js_link/" rel="alternate" type="text/html" title="Vue.js 참고 자료" /><published>2018-09-29T00:00:00+00:00</published><updated>2018-09-29T00:00:00+00:00</updated><id>https://elky84.github.io/2018/09/29/vue_js_link</id><content type="html" xml:base="https://elky84.github.io/2018/09/29/vue_js_link/">&lt;h2 id=&quot;가이드&quot;&gt;가이드&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;공식
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://kr.vuejs.org/v2/guide/&quot;&gt;https://kr.vuejs.org/v2/guide/&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;입문서
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://joshua1988.github.io/web-development/vuejs/vuejs-tutorial-for-beginner/&quot;&gt;https://joshua1988.github.io/web-development/vuejs/vuejs-tutorial-for-beginner/&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;왜 43%의 프론트엔드 개발자들은 Vue.js를 배우고 싶어하나?
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://joshua1988.github.io/web-development/translation/why-43percent-devs-wanna-learn-vuejs/&quot;&gt;https://joshua1988.github.io/web-development/translation/why-43percent-devs-wanna-learn-vuejs/&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Vue.js 2.0 라이프 사이클 이해하기
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://medium.com/witinweb/vue-js-라이프사이클-이해하기-7780cdd97dd4&quot;&gt;https://medium.com/witinweb/vue-js-라이프사이클-이해하기-7780cdd97dd4&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Vue.js 2.0 소개 및 시작하기
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://velopert.com/3007&quot;&gt;https://velopert.com/3007&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;사례&quot;&gt;사례&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;[파일럿 프로젝트] Vue.js로 모바일 웹 구축하기
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://zuminternet.github.io/ZUM-Pilot-partjun/&quot;&gt;https://zuminternet.github.io/ZUM-Pilot-partjun/&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;디버깅&quot;&gt;디버깅&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;VS Code
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://medium.com/@changjoopark/visual-studio-code%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-vue-js-%EC%95%B1-%EB%94%94%EB%B2%84%EA%B9%85%ED%95%98%EA%B8%B0-6a402fefafe&quot;&gt;https://medium.com/@changjoopark/visual-studio-code%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-vue-js-%EC%95%B1-%EB%94%94%EB%B2%84%EA%B9%85%ED%95%98%EA%B8%B0-6a402fefafe&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;debugger 키워드를 타이핑 해두면, 브레이크 포인트가 잡힌다.&lt;/li&gt;
          &lt;li&gt;코드에서 잡은 breakpoint는 될 때가 있고, 안될 때가 있는데, 이유는 아직 모르겠다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;크롬
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://vuejs.kr/vue/2017/02/25/vue-chrome-debugging/&quot;&gt;http://vuejs.kr/vue/2017/02/25/vue-chrome-debugging/&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://vuejs.org/v2/cookbook/debugging-in-vscode.html&quot;&gt;https://vuejs.org/v2/cookbook/debugging-in-vscode.html&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;사용법&quot;&gt;사용법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;컴포넌트
    &lt;ul&gt;
      &lt;li&gt;자식 컴포넌트 메소드 호출
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://code.luasoftware.com/tutorials/vuejs/parent-call-child-component-method/&quot;&gt;https://code.luasoftware.com/tutorials/vuejs/parent-call-child-component-method/&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;동적 컴포넌트
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://kr.vuejs.org/v2/guide/components.html#%EB%8F%99%EC%A0%81-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8&quot;&gt;https://kr.vuejs.org/v2/guide/components.html#%EB%8F%99%EC%A0%81-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;http://b1ix.net/310&quot;&gt;http://b1ix.net/310&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;http://seulcode.tistory.com/262&quot;&gt;http://seulcode.tistory.com/262&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Vuex 상태
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://vuex.vuejs.org/kr/guide/state.html&quot;&gt;https://vuex.vuejs.org/kr/guide/state.html&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;마크다운
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/miaolz123/vue-markdown&quot;&gt;https://github.com/miaolz123/vue-markdown&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;watch
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://kr.vuejs.org/v2/guide/computed.html&quot;&gt;https://kr.vuejs.org/v2/guide/computed.html&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://blog.naver.com/PostView.nhn?blogId=psj9102&amp;amp;logNo=221011648288&quot;&gt;http://blog.naver.com/PostView.nhn?blogId=psj9102&amp;amp;logNo=221011648288&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Elky Kim</name></author><category term="JavaScript" /><category term="Vue.js" /><category term="Frontend" /><summary type="html">가이드 공식 https://kr.vuejs.org/v2/guide/ 입문서 https://joshua1988.github.io/web-development/vuejs/vuejs-tutorial-for-beginner/ 왜 43%의 프론트엔드 개발자들은 Vue.js를 배우고 싶어하나? https://joshua1988.github.io/web-development/translation/why-43percent-devs-wanna-learn-vuejs/ Vue.js 2.0 라이프 사이클 이해하기 https://medium.com/witinweb/vue-js-라이프사이클-이해하기-7780cdd97dd4 Vue.js 2.0 소개 및 시작하기 https://velopert.com/3007 사례 [파일럿 프로젝트] Vue.js로 모바일 웹 구축하기 https://zuminternet.github.io/ZUM-Pilot-partjun/ 디버깅 VS Code https://medium.com/@changjoopark/visual-studio-code%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-vue-js-%EC%95%B1-%EB%94%94%EB%B2%84%EA%B9%85%ED%95%98%EA%B8%B0-6a402fefafe debugger 키워드를 타이핑 해두면, 브레이크 포인트가 잡힌다. 코드에서 잡은 breakpoint는 될 때가 있고, 안될 때가 있는데, 이유는 아직 모르겠다. 크롬 http://vuejs.kr/vue/2017/02/25/vue-chrome-debugging/ https://vuejs.org/v2/cookbook/debugging-in-vscode.html 사용법 컴포넌트 자식 컴포넌트 메소드 호출 https://code.luasoftware.com/tutorials/vuejs/parent-call-child-component-method/ 동적 컴포넌트 https://kr.vuejs.org/v2/guide/components.html#%EB%8F%99%EC%A0%81-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8 http://b1ix.net/310 http://seulcode.tistory.com/262 Vuex 상태 https://vuex.vuejs.org/kr/guide/state.html 마크다운 https://github.com/miaolz123/vue-markdown watch https://kr.vuejs.org/v2/guide/computed.html http://blog.naver.com/PostView.nhn?blogId=psj9102&amp;amp;logNo=221011648288</summary></entry></feed>