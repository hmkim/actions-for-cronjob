<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by 김강천 on Medium]]></title>
        <description><![CDATA[Stories by 김강천 on Medium]]></description>
        <link>https://medium.com/@rlarkdcjs12?source=rss-e41ffd1fa53d------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*4KxorLSELhbvcjTE1tBEVw.jpeg</url>
            <title>Stories by 김강천 on Medium</title>
            <link>https://medium.com/@rlarkdcjs12?source=rss-e41ffd1fa53d------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Sun, 12 May 2019 20:41:47 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@rlarkdcjs12" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[[백준] C++ 알고리즘 풀이 — 11656번]]></title>
            <link>https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4-11656%EB%B2%88-73f6748b2840?source=rss-e41ffd1fa53d------2</link>
            <guid isPermaLink="false">https://medium.com/p/73f6748b2840</guid>
            <category><![CDATA[cpp]]></category>
            <category><![CDATA[c]]></category>
            <category><![CDATA[algorithms]]></category>
            <dc:creator><![CDATA[김강천]]></dc:creator>
            <pubDate>Thu, 02 Aug 2018 01:45:35 GMT</pubDate>
            <atom:updated>2018-08-02T02:33:39.005Z</atom:updated>
            <content:encoded><![CDATA[<h4>접미사 배열</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*JgG3a7xt8VmrlKCjczIpnA.jpeg" /><figcaption><a href="https://pixabay.com/ko/%EA%B8%80%EA%BC%B4-%EB%A6%AC%EB%93%9C-%EC%84%B8%ED%8A%B8-%ED%99%9C%ED%8C%90-%EC%9D%B8%EC%87%84%EC%88%A0-%EA%B5%AC%ED%85%90%EB%B2%A0%EB%A5%B4%ED%81%AC-%ED%8E%B8%EC%A7%80-%EA%B8%80%EA%BC%B4-%EC%84%A4%EC%A0%95-705667/">Pixabay</a></figcaption></figure><p><a href="https://www.acmicpc.net/problem/11656">11656번: 접미사 배열</a></p><h3>문제</h3><p>접미사 배열은 문자열 S의 모든 접미사를 사전순으로 정렬해 놓은 배열이다.</p><p>baekjoon의 접미사는 baekjoon, aekjoon, ekjoon, kjoon, joon, oon, on, n 으로 총 8가지가 있고, 이를 사전순으로 정렬하면, aekjoon, baekjoon, ekjoon, joon, kjoon, n, on, oon이 된다.</p><p>문자열 S가 주어졌을 때, 모든 접미사를 사전순으로 정렬한 다음 출력하는 프로그램을 작성하시오.</p><h3>입력</h3><p>첫째 줄에 문자열 S가 주어진다. S는 알파벳 소문자로만 이루어져 있고, 길이는 1,000보다 작거나 같다.</p><h3>출력</h3><p>첫째 줄부터 S의 접미사를 사전순으로 한 줄에 하나씩 출력한다.</p><h3>예제 입력</h3><pre>baekjoon</pre><h3>예제 출력</h3><pre>aekjoon<br>baekjoon<br>ekjoon<br>joon<br>kjoon<br>n<br>on<br>oon</pre><h3>코드</h3><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/02fe21e696b7fc05d1949ad4352af424/href">https://medium.com/media/02fe21e696b7fc05d1949ad4352af424/href</a></iframe><h3>풀이</h3><p>이 문제는 문자열의 접미사를 사전순으로 정리하는 문제이다.</p><p>일단, 문자열의 접미사를 다른 배열에 저장할 것인데<br>예를 들어 baekjoon의 접미사는 baekjoon, aekjoon, ekjoon, kjoon, joon, oon, on, n으로 8가지가 있다.</p><p>이 접미사들을 다른 배열로 복사해야하는 상황에서 <br>나는 substr()이라는 함수를 사용했다.</p><blockquote><em>temp[i] = str.substr(i, l);</em> str의 i~l까지를 <em>temp[i]</em>에 저장</blockquote><p>이제 temp[i]에 차례대로 baekjoon, aekjoon, ekjoon ···이 들어갔을 것이다.</p><p>마지막으로 temp[i]를 오름차순으로 정리해주면 끝이다. 오름차순은 sort()함수를 사용했다.</p><p>sort()함수는 algorithm 헤더에 정의되어 있기에 #include&lt;algorithm&gt;을 해줘야 한다.</p><h4>Another problem by `김강천`</h4><ul><li><a href="https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4-5618%EB%B2%88-b9860c33cf3d">[백준] C++ 알고리즘 풀이 — 5618번</a></li><li><a href="https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4-%E3%85%A1-1120%EB%B2%88-aae9bf1055e0">[백준] C++ 알고리즘 풀이 — 1120번</a></li><li><a href="https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4%E3%85%A11075%EB%B2%88-e698b4d6403">[백준] C 알고리즘 풀이ㅡ1075번</a></li><li><a href="https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4%E3%85%A11026%EB%B2%88-be3b21f589f2">[백준] C 알고리즘 풀이ㅡ1026번</a></li><li><a href="https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4-1057%EB%B2%88-152464074e39">[백준] C 알고리즘 풀이 — 1057번</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=73f6748b2840" width="1" height="1"><hr><p><a href="https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4-11656%EB%B2%88-73f6748b2840">[백준] C++ 알고리즘 풀이 — 11656번</a> was originally published in <a href="https://medium.com/wasd">WASD</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[백준] C++ 알고리즘 풀이 — 5618번]]></title>
            <link>https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4-5618%EB%B2%88-b9860c33cf3d?source=rss-e41ffd1fa53d------2</link>
            <guid isPermaLink="false">https://medium.com/p/b9860c33cf3d</guid>
            <category><![CDATA[cpp]]></category>
            <category><![CDATA[c]]></category>
            <category><![CDATA[algorithms]]></category>
            <category><![CDATA[baekjoon]]></category>
            <dc:creator><![CDATA[김강천]]></dc:creator>
            <pubDate>Sun, 01 Jul 2018 10:20:24 GMT</pubDate>
            <atom:updated>2018-07-01T10:51:35.557Z</atom:updated>
            <content:encoded><![CDATA[<h4>공약수</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*4WJzUwb5RuNUdK1sqRPdxw.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/photos/LVOaWx_Sphk?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Jon Tyson</a> on <a href="https://unsplash.com/search/photos/common-denominator?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p><a href="https://www.acmicpc.net/problem/5618">5618번: 공약수</a></p><h3>문제</h3><p>자연수 n개가 주어진다. 이 자연수의 공약수를 모두 구하는 프로그램을 작성하시오.</p><h3>입력</h3><p>첫째 줄에 n이 주어진다. n은 2 또는 3이다. 둘째 줄에는 공약수를 구해야 하는 정수 n개가 주어진다. 모든 정수는 10의 8제곱 이하이다.</p><h3>출력</h3><p>입력으로 주어진 n개 수의 공약수를 한 줄에 하나씩 증가하는 순서대로 출력한다.</p><h3>예제 입력</h3><pre>2<br>75 125</pre><h3>예제 출력</h3><pre>1<br>5<br>25</pre><h3>풀이</h3><p>두 개, 혹은 세 개의 정수들을 입력받아 공약수를 구하는 쉬운 문제이다.</p><p>먼저 조건문으로 정수 두 개를 입력 받을 경우와,<br>정수 세 개를 입력 받을 경우를 나누어 입력을 받아준다.</p><p>공약수를 골라내는 조건은, 각 숫자를 ‘n’이라는 숫자로 나누었을 때, <br>나머지가 0이여야만 공약수가 된다. 그러므로 반복문을 돌린다고 했을 때<br>a, b or a, b, c 를 반복문의 각 i 번째로 나누었을 때의 나머지가 모두 0일 때만 공약수가 된다.</p><p>조건식</p><p>if(a % i == 0 &amp;&amp; b % i == 0 &amp;&amp; c % i == 0)</p><p>이 조건 하나로 두 개의 정수를 입력받았을 때, 세 개의 정수를 입력받았을 때<br>모두 충족시킬 수 있다.</p><h3>코드</h3><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/bf1065af3b99940772d2795cde0c8a89/href">https://medium.com/media/bf1065af3b99940772d2795cde0c8a89/href</a></iframe><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b9860c33cf3d" width="1" height="1"><hr><p><a href="https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4-5618%EB%B2%88-b9860c33cf3d">[백준] C++ 알고리즘 풀이 — 5618번</a> was originally published in <a href="https://medium.com/wasd">WASD</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[백준] C++ 알고리즘 풀이 — 1120번]]></title>
            <link>https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4-%E3%85%A1-1120%EB%B2%88-aae9bf1055e0?source=rss-e41ffd1fa53d------2</link>
            <guid isPermaLink="false">https://medium.com/p/aae9bf1055e0</guid>
            <category><![CDATA[cpp]]></category>
            <category><![CDATA[c]]></category>
            <category><![CDATA[algorithms]]></category>
            <category><![CDATA[baekjoon]]></category>
            <dc:creator><![CDATA[김강천]]></dc:creator>
            <pubDate>Thu, 28 Jun 2018 14:44:05 GMT</pubDate>
            <atom:updated>2018-06-30T11:25:23.835Z</atom:updated>
            <content:encoded><![CDATA[<h4>문자열</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*x_N4uQT6YbRA64tT" /><figcaption>Photo by <a href="https://unsplash.com/@pedronogueiradesign?utm_source=medium&amp;utm_medium=referral">Pedro Nogueira</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral">Unsplash</a></figcaption></figure><p><a href="https://www.acmicpc.net/problem/1120">1120번: 문자열</a></p><h3>문제</h3><p>길이가 N으로 같은 문자열 X와 Y가 있을 때, 두 문자열 X와 Y의 차이는 X[i] ≠ Y[i]인 i의 개수이다. 예를 들어, X=”jimin”, Y=”minji”이면, 둘의 차이는 4이다.</p><p>두 문자열 A와 B가 주어진다. 이 때, A의 길이는 B의 길이보다 작거나 같다. 이제 A의 길이가 B의 길이와 같아질 때 까지 다음과 같은 연산을 할 수 있다.</p><ol><li>A의 앞에 아무 알파벳이나 추가한다.</li><li>A의 뒤에 아무 알파벳이나 추가한다.</li></ol><p>이 때, A와 B의 길이가 같으면서, A와 B의 차이를 최소로 하는 프로그램을 작성하시오.</p><h3>입력</h3><p>첫째 줄에 A와 B가 주어진다. A와 B의 길이는 최대 50이고, A의 길이는 B의 길이보다 작거나 같고, 알파벳 소문자로만 이루어져 있다.</p><h3>출력</h3><p>A와 B의 길이가 같으면서, A와 B의 차이를 최소가 되도록 했을 때, 그 차이를 출력하시오.</p><h3>예제 입력 1</h3><pre>adaabc aababbc</pre><h3>예제 출력 1</h3><pre>2</pre><h3>풀이</h3><p>이 문제는 A의 앞 그리고 뒤에 적절한 알파벳을 추가하여 B와의 차이를 <br>최소화하는 문제이다.</p><h4>예시</h4><blockquote>문자열 A: wasd <br>문자열 B: qwasde</blockquote><p>문자열 A의 앞에 q 그리고 끝에 e를 붙여 문자열 A인 wasd를 qwasde로만들어 B와의 차이를 없앨 수 있다.</p><p>하지만 문자열을 추가한다고 해도 B와 같은 위치에 같은 알파벳을 추가할 것 이기 때문에 쉽게 생각하자면</p><blockquote>A가 B에 가장 많이 중첩 됐을 때를 구한다.</blockquote><p>라고 생각하면 될 것 같다.</p><blockquote>이 문제도 역시 C 언어로 풀려고 했는데, C언어에는 length()함수가 없어 <br>문자열을 구할 수 없었다. 그래서 C++을 사용해봤는데 편해서 많이 사용할 것 같다 ^^;;</blockquote><h3>코드</h3><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/97d9ae77a604e8a308c5703d637e9747/href">https://medium.com/media/97d9ae77a604e8a308c5703d637e9747/href</a></iframe><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=aae9bf1055e0" width="1" height="1"><hr><p><a href="https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4-%E3%85%A1-1120%EB%B2%88-aae9bf1055e0">[백준] C++ 알고리즘 풀이 — 1120번</a> was originally published in <a href="https://medium.com/wasd">WASD</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[백준] C 알고리즘 풀이ㅡ1075번]]></title>
            <link>https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4%E3%85%A11075%EB%B2%88-e698b4d6403?source=rss-e41ffd1fa53d------2</link>
            <guid isPermaLink="false">https://medium.com/p/e698b4d6403</guid>
            <category><![CDATA[c]]></category>
            <category><![CDATA[baekjoon]]></category>
            <category><![CDATA[algorithms]]></category>
            <dc:creator><![CDATA[김강천]]></dc:creator>
            <pubDate>Sat, 09 Jun 2018 13:43:39 GMT</pubDate>
            <atom:updated>2018-07-01T13:51:16.259Z</atom:updated>
            <content:encoded><![CDATA[<h4>나누기</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*IMKx27c-PHYD0C7KSU8lxg.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/photos/Z3r7p3DqXeM?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Felipe Correia</a> on <a href="https://unsplash.com/search/photos/division?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p><a href="https://www.acmicpc.net/problem/1075">1075번: 나누기</a></p><h3>문제</h3><p>두 정수 N과 F가 주어진다. 지민이는 정수 N의 가장 뒤 두자리를 적절히 바꿔서 N을 F로 나누어 떨어지게 만드려고 한다. 만약 가능한 것이 여러가지이면, 뒤 두자리를 가능하면 작게 만드려고 한다.</p><p>예를 들어, N=275이고, F=5이면, 답은 00이다. 200이 5로 나누어 떨어지기 때문이다. N=1021이고, F=11이면, 정답은 01인데, 1001이 11로 나누어떨어지기 때문이다.</p><h3>입력</h3><p>첫째 줄에 N, 둘째 줄에 F가 주어진다. N은 100보다 크거나 같고, 2,000,000,000보다 작거나 같은 자연수이다. F는 100보다 작거나 같은 자연수이다.</p><h3>출력</h3><p>첫째 줄에 마지막 두 자리를 모두 출력한다. 한자리이면 앞에 0을 추가해서 두 자리로 만들어야 한다.</p><h3>예제 입력 1</h3><pre>1000<br>3</pre><h3>예제 출력 1</h3><pre>02</pre><h3><strong>접근 방식</strong></h3><p>N의 마지막 두 자리를 적절히 바꿔 F로 나누어 떨어지게 하는 문제이다.</p><p>일단, 마지막 두 자리를 00으로 바꿔야 하는데,</p><p><strong>n = (n/100) * 100;</strong></p><p>이라는 식을 사용했다.</p><p>그리고 반복문을 통해 N을 I와 더해 F로 나누어 떨어지는 최솟값을 구해주면 된다.</p><blockquote>한자리이면 앞에 0을 추가해서 두 자리로 만들어야 한다.</blockquote><p>라는 조건이 있기에, I가 10보다 작을 경우 0을 출력한 후 I 를 출력했다.</p><h3>코드</h3><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/af5492fa4169419cc037f3f9f47a2a55/href">https://medium.com/media/af5492fa4169419cc037f3f9f47a2a55/href</a></iframe><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e698b4d6403" width="1" height="1"><hr><p><a href="https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4%E3%85%A11075%EB%B2%88-e698b4d6403">[백준] C 알고리즘 풀이ㅡ1075번</a> was originally published in <a href="https://medium.com/wasd">WASD</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[백준] C 알고리즘 풀이ㅡ1026번]]></title>
            <link>https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4%E3%85%A11026%EB%B2%88-be3b21f589f2?source=rss-e41ffd1fa53d------2</link>
            <guid isPermaLink="false">https://medium.com/p/be3b21f589f2</guid>
            <category><![CDATA[algorithms]]></category>
            <category><![CDATA[c]]></category>
            <dc:creator><![CDATA[김강천]]></dc:creator>
            <pubDate>Wed, 06 Jun 2018 05:36:22 GMT</pubDate>
            <atom:updated>2018-06-30T12:13:42.686Z</atom:updated>
            <content:encoded><![CDATA[<h4>보물</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*5Au2FdefDQPZf0WICUkNtQ.jpeg" /></figure><p><a href="https://www.acmicpc.net/problem/1026">1026번: 보물</a></p><h3>문제</h3><p>옛날 옛적에 수학이 항상 큰 골칫거리였던 나라가 있었다. 이 나라의 국왕 김지민은 다음과 같은 문제를 내고 큰 상금을 걸었다.</p><p>길이가 N인 정수 배열 A와 B가 있다. 다음과 같이 함수 S를 정의하자.</p><p>S = A[0]*B[0] + … + A[N-1]*B[N-1]</p><p>S의 값을 가장 작게 만들기 위해 A의 수를 재배열하자. 단, B에 있는 수는 재배열하면 안된다.</p><p>S의 최솟값을 출력하는 프로그램을 작성하시오.</p><h3>입력</h3><p>첫째 줄에 N이 주어진다. 둘째 줄에는 A에 있는 N개의 수가 순서대로 주어지고, 셋째 줄에는 B에 있는 수가 순서대로 주어진다. N은 50보다 작거나 같은 자연수이고, A와 B의 각 원소는 100보다 작거나 같은 음이 아닌 정수이다.</p><h3>출력</h3><p>첫째 줄에 S의 최솟값을 출력한다.</p><h3>예제 입력 1</h3><pre>5<br>1 1 1 6 0<br>2 7 8 3 1</pre><h3>예제 출력 1</h3><pre>18</pre><h3><strong>접근 방식</strong></h3><p>S = A[0]*B[0] + … + A[N-1]*B[N-1]와 같은 식으로 A배열의 값을 재배열하여 S의 최솟값을 구하는 문제이다.</p><p>이 문제를 보고 <br>“A배열을 내림차순 하고 B배열을 오름차순하여 곱하면 되겠다!” 하고 문제를 풀고보니 <strong>B배열을 재배열하면 안된단다</strong>(…)</p><p><strong>나는 ‘B에 있는 수는 재배열하면 안된다.’ 라는 조건을 무시하고 풀어보겠다.</strong><br>문제가 이상해서 이 조건을 무시하고 제출해도 정답이 나온다.(?)</p><p>잡설은 각설하고,<br>A배열의 값과 B배열의 값을 버블 정렬로 각각 내림차순과 오름차순으로 재배열하여 값을 구했다!</p><p>버블 정렬은 어렵지 않으니 잘 모르시는 분들은 이번 문제를 통해 배우셨으면 좋겠다.</p><h3><strong>코드</strong></h3><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/acbbd5c5e9904eef3f6770ad3ef0356b/href">https://medium.com/media/acbbd5c5e9904eef3f6770ad3ef0356b/href</a></iframe><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=be3b21f589f2" width="1" height="1"><hr><p><a href="https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4%E3%85%A11026%EB%B2%88-be3b21f589f2">[백준] C 알고리즘 풀이ㅡ1026번</a> was originally published in <a href="https://medium.com/wasd">WASD</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[백준] C 알고리즘 풀이 — 1057번]]></title>
            <link>https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4-1057%EB%B2%88-152464074e39?source=rss-e41ffd1fa53d------2</link>
            <guid isPermaLink="false">https://medium.com/p/152464074e39</guid>
            <category><![CDATA[c]]></category>
            <category><![CDATA[algorithms]]></category>
            <category><![CDATA[baekjoon]]></category>
            <dc:creator><![CDATA[김강천]]></dc:creator>
            <pubDate>Thu, 24 May 2018 11:18:24 GMT</pubDate>
            <atom:updated>2018-06-30T12:18:52.135Z</atom:updated>
            <content:encoded><![CDATA[<h4>토너먼트</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*FxuAkr4OufWZJIGFz7JfMQ.jpeg" /><figcaption><a href="https://www.gameskinny.com/ap953/the-journal-of-an-ex-tournament-gamer">https://www.gameskinny.com/ap953/the-journal-of-an-ex-tournament-gamer</a></figcaption></figure><p><a href="https://www.acmicpc.net/problem/1057">1057번: 토너먼트</a></p><h3>문제</h3><p>김지민은 N명이 참가하는 스타 토너먼트에 진출했다. 토너먼트는 다음과 같이 진행된다. 일단 N명의 참가자는 번호가 1번부터 N번까지 배정받는다. 그러고 난 후에 서로 인접한 번호끼리 스타를 한다. 이긴 사람은 다음 라운드에 진출하고, 진 사람은 그 라운드에서 떨어진다. 만약 그 라운드의 참가자가 홀수명이라면, 마지막 번호를 가진 참가자는 다음 라운드로 자동 진출한다. 다음 라운드에선 다시 참가자의 번호를 1번부터 매긴다. 이 때, 번호를 매기는 순서는 처음 번호의 순서를 유지하면서 1번부터 매긴다. 이 말은 1번과 2번이 스타를 해서 1번이 진출하고, 3번과 4번이 스타를 해서 4번이 진출했다면, 4번은 다음 라운드에서 번호 2번을 배정받는다. 번호를 다시 배정받은 후에 한 명만 남을 때까지 라운드를 계속 한다.</p><p>마침 이 스타 대회에 임한수도 참가했다. 김지민은 갑자기 스타 대회에서 우승하는 욕심은 없어지고, 몇 라운드에서 임한수와 대결하는지 궁금해졌다. 일단 김지민과 임한수는 서로 대결하기 전까지 항상 이긴다고 가정한다. 1 라운드에서 김지민의 번호와 임한수의 번호가 주어질 때, 과연 김지민과 임한수가 몇 라운드에서 대결하는지 출력하는 프로그램을 작성하시오.</p><h3>입력</h3><p>첫째 줄에 참가자의 수 N과 1 라운드에서 김지민의 번호와 임한수의 번호가 순서대로 주어진다. N은 100,000보다 작거나 같은 자연수이고, 김지민의 번호와 임한수의 번호는 N보다 작거나 같은 자연수이고, 서로 다르다.</p><h3>출력</h3><p>첫째 줄에 김지민과 임한수가 대결하는 라운드 번호를 출력한다. 만약 서로 대결하지 않을 때는 -1을 출력한다.</p><h3>예제 입력 1</h3><pre>16 8 9</pre><h3>예제 출력 1</h3><pre>4</pre><h3><strong>접근 방식</strong></h3><p>예제의 흐름을 보면 <br><strong>김지민 8 -&gt; 4 -&gt; 2 -&gt; 1</strong><br><strong>임한수 9 -&gt; 5 -&gt; 3 -&gt; 2<br></strong>으로 4번에 걸쳐 토너먼트가 끝나는데,<br>이 흐름을 보고 쉽게 규칙을 찾을 수 있었다.</p><blockquote>while(입력값1 != 입력값2)</blockquote><blockquote>입력값1 -(입력값1/2)</blockquote><blockquote>입력값2-(입력값2/2)</blockquote><blockquote>카운트 증가</blockquote><h3><strong>코드</strong></h3><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/136f57a70991baeea3122ab1e3756ef7/href">https://medium.com/media/136f57a70991baeea3122ab1e3756ef7/href</a></iframe><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=152464074e39" width="1" height="1"><hr><p><a href="https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4-1057%EB%B2%88-152464074e39">[백준] C 알고리즘 풀이 — 1057번</a> was originally published in <a href="https://medium.com/wasd">WASD</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[백준] C 알고리즘 풀이 — 1946번]]></title>
            <link>https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4-1946%EB%B2%88-9e0d5612ac90?source=rss-e41ffd1fa53d------2</link>
            <guid isPermaLink="false">https://medium.com/p/9e0d5612ac90</guid>
            <category><![CDATA[algorithms]]></category>
            <category><![CDATA[c]]></category>
            <category><![CDATA[baekjoon]]></category>
            <dc:creator><![CDATA[김강천]]></dc:creator>
            <pubDate>Mon, 21 May 2018 09:57:36 GMT</pubDate>
            <atom:updated>2018-06-30T12:19:42.497Z</atom:updated>
            <content:encoded><![CDATA[<h4>신입 사원</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*TSxV-fgegnrutP7OyYdCeQ.jpeg" /></figure><p><a href="https://www.acmicpc.net/problem/1946">1946번: 신입 사원</a></p><h3>문제</h3><p>언제나 최고만을 지향하는 굴지의 대기업 진영 주식회사가 신규 사원 채용을 실시한다. 인재 선발 시험은 1차 서류심사와 2차 면접시험으로 이루어진다. 최고만을 지향한다는 기업의 이념에 따라 그들은 최고의 인재들만을 사원으로 선발하고 싶어 한다.</p><p>그래서 진영 주식회사는, 다른 모든 지원자와 비교했을 때 서류심사 성적과 면접시험 성적 중 적어도 하나가 다른 지원자보다 떨어지지 않는 자만 선발한다는 원칙을 세웠다. 즉, 어떤 지원자 A의 성적이 다른 어떤 지원자 B의 성적에 비해 서류 심사 결과와 면접 성적이 모두 떨어진다면 A는 결코 선발되지 않는다.</p><p>이러한 조건을 만족시키면서, 진영 주식회사가 이번 신규 사원 채용에서 선발할 수 있는 신입사원의 최대 인원수를 구하는 프로그램을 작성하시오.</p><h3>입력</h3><p>첫째 줄에는 테스트 케이스의 개수 T(1≤T≤20)가 주어진다. 각 테스트 케이스의 첫째 줄에 지원자의 숫자 N(1≤N≤100,000)이 주어진다. 둘째 줄부터 N개 줄에는 각각의 지원자의 서류심사 성적, 면접 성적의 순위가 공백을 사이에 두고 한 줄에 주어진다. 두 성적 순위는 모두 1위부터 N위까지 동석차 없이 결정된다고 가정한다.</p><h3>출력</h3><p>각 테스트 케이스에 대해서 진영 주식회사가가 선발할 수 있는 신입사원의 최대 인원수를 한 줄에 하나씩 출력한다.</p><h3>예제 입력 1</h3><pre>2<br>5<br>3 2<br>1 4<br>4 1<br>2 3<br>5 5<br>7<br>3 6<br>7 3<br>4 2<br>1 4<br>5 7<br>2 5<br>6 1</pre><h3>예제 출력 1</h3><pre>4<br>3</pre><h3><strong>접근 방식</strong></h3><p>필자의 경우에는 서류심사 순위를 <strong>오름차순</strong> 한 뒤, 현재 지원자와 다음 지원자의 면접시험 <strong>순위를 비교</strong>하여 합격자의 수를 셌다.</p><p>오름차순을 하는 법은 여러 가지가 있는데, 이번 문제에서는 서류심사의 순위와 배열의 순서가 같아서 쉽게 정렬할 수 있었다.</p><pre>scanf(&quot;%d %d, &amp;a, &amp;b);<br>rank[a-1][0] = a;<br>rank[a-1][1] = b;</pre><h3>코드</h3><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/7ff68884c0bafa1a63cdb6a5412fd91c/href">https://medium.com/media/7ff68884c0bafa1a63cdb6a5412fd91c/href</a></iframe><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9e0d5612ac90" width="1" height="1"><hr><p><a href="https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4-1946%EB%B2%88-9e0d5612ac90">[백준] C 알고리즘 풀이 — 1946번</a> was originally published in <a href="https://medium.com/wasd">WASD</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[백준] C 알고리즘 풀이 — 2839번]]></title>
            <link>https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4-2839%EB%B2%88-372de7d86de6?source=rss-e41ffd1fa53d------2</link>
            <guid isPermaLink="false">https://medium.com/p/372de7d86de6</guid>
            <category><![CDATA[c]]></category>
            <category><![CDATA[baekjoon]]></category>
            <category><![CDATA[algorithms]]></category>
            <dc:creator><![CDATA[김강천]]></dc:creator>
            <pubDate>Sat, 12 May 2018 13:01:28 GMT</pubDate>
            <atom:updated>2018-06-30T12:29:15.152Z</atom:updated>
            <content:encoded><![CDATA[<h4>설탕 배달</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*4JPxXOlb49Pj9RCAKMBRMw.jpeg" /></figure><p><a href="https://www.acmicpc.net/problem/2839">2839번: 설탕 배달</a></p><p>백준 2839번 설탕 배달의 풀이를 해보겠다.</p><h3>문제</h3><p>상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.</p><p>상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.</p><p>상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.</p><h3>입력</h3><p>첫째 줄에 N이 주어진다. (3 ≤ N ≤ 5000)</p><h3>출력</h3><p>상근이가 배달하는 봉지의 최소 개수를 출력한다. 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다.</p><h3>접근 방식</h3><p>이 문제의 <strong>핵심</strong>은 <strong><em>‘최대한 적은’</em></strong> 봉지를 배달해야 한다.<br>그러므로 3kg 보다 5kg를 먼저 빼야 한다고 생각하면 쉽게 풀 수 있을 것이다.</p><h3>코드</h3><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/d1593be2aec6ffd8649b7f4c71a1f1e9/href">https://medium.com/media/d1593be2aec6ffd8649b7f4c71a1f1e9/href</a></iframe><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=372de7d86de6" width="1" height="1"><hr><p><a href="https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4-2839%EB%B2%88-372de7d86de6">[백준] C 알고리즘 풀이 — 2839번</a> was originally published in <a href="https://medium.com/wasd">WASD</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[백준] C 알고리즘 풀이 — 10871번]]></title>
            <link>https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4-10871%EB%B2%88-5ed95b652e29?source=rss-e41ffd1fa53d------2</link>
            <guid isPermaLink="false">https://medium.com/p/5ed95b652e29</guid>
            <category><![CDATA[algorithms]]></category>
            <category><![CDATA[baekjoon]]></category>
            <category><![CDATA[c]]></category>
            <dc:creator><![CDATA[김강천]]></dc:creator>
            <pubDate>Sat, 12 May 2018 12:56:00 GMT</pubDate>
            <atom:updated>2018-07-01T13:48:56.023Z</atom:updated>
            <content:encoded><![CDATA[<h4><strong>X보다 작은 수</strong></h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ZkRK4GBSQxr2dGBRxmbv2g.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/photos/DwpmtAo01fY?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Céline Haeberly</a> on <a href="https://unsplash.com/search/photos/small?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p><a href="https://www.acmicpc.net/problem/10871">10871번: X보다 작은 수</a></p><p>백준 10871번의 풀이를 해보겠다.</p><h3>문제</h3><p>정수 N개로 이루어진 수열 A와 정수 X가 주어진다. 이 때, A에서 X보다 작은 수를 모두 출력하는 프로그램을 작성하시오.</p><h3>입력</h3><p>첫째 줄에 N과 X가 주어진다. (1 ≤ N, X ≤ 10,000)</p><p>둘째 줄에 수열 A를 이루는 정수 N개가 주어진다. 주어지는 정수는 모두 1보다 크거나 같고, 10,000보다 작거나 같은 정수이다.</p><h3>출력</h3><p>X보다 작은 수를 입력받은 순서대로 공백으로 구분해 출력한다. X보다 작은 수는 적어도 하나 존재한다.</p><h3>예제 입력 1</h3><pre>10 5<br>1 10 4 9 2 3 8 5 7 6</pre><h3>예제 출력 1</h3><pre>1 4 2 3</pre><h3>접근방식</h3><p>N번의 입력을 받아 X보다 작은 수를 출력하면 된다.<br>유의할 점이,</p><blockquote>입력을 받자마자 출력해야된다.</blockquote><blockquote>반복문으로 10번을 입력받고, 다른 반복문으로 10번을 출력하면 채점에 에러가 난다.</blockquote><p>이 점만 유의하면 쉽게 풀수 있을 것이다.</p><h3>코드</h3><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/33cf6e7523307253c8ecff711e0ecf7d/href">https://medium.com/media/33cf6e7523307253c8ecff711e0ecf7d/href</a></iframe><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5ed95b652e29" width="1" height="1"><hr><p><a href="https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4-10871%EB%B2%88-5ed95b652e29">[백준] C 알고리즘 풀이 — 10871번</a> was originally published in <a href="https://medium.com/wasd">WASD</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[백준] C 알고리즘 풀이 — 1009번]]></title>
            <link>https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4-1009%EB%B2%88-9e245be16fb0?source=rss-e41ffd1fa53d------2</link>
            <guid isPermaLink="false">https://medium.com/p/9e245be16fb0</guid>
            <category><![CDATA[c]]></category>
            <category><![CDATA[algorithms]]></category>
            <category><![CDATA[baekjoon]]></category>
            <dc:creator><![CDATA[김강천]]></dc:creator>
            <pubDate>Sun, 06 May 2018 06:40:40 GMT</pubDate>
            <atom:updated>2018-06-30T12:46:45.053Z</atom:updated>
            <content:encoded><![CDATA[<h4>분산처리</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*uDGeAnjuM8ExZZZSjg3-6g.jpeg" /><figcaption><a href="https://nos.twnsnd.co/image/83208814778">https://nos.twnsnd.co/image/83208814778</a></figcaption></figure><p><a href="https://www.acmicpc.net/problem/1009">1009번: 분산처리</a></p><p>백준 1009번 분산처리의 풀이를 해보겠다.</p><h3>문제</h3><p>재용이는 최신 컴퓨터 10대를 가지고 있다. 어느 날 재용이는 많은 데이터를 처리해야 될 일이 생겨서 각 컴퓨터에 1번부터 10번까지의 번호를 부여하고, 10대의 컴퓨터가 다음과 같은 방법으로 데이터들을 처리하기로 하였다.</p><p>1번 데이터는 1번 컴퓨터, 2번 데이터는 2번 컴퓨터, 3번 데이터는 3번 컴퓨터, … ,</p><p>10번 데이터는 10번 컴퓨터, 11번 데이터는 1번 컴퓨터, 12번 데이터는 2번 컴퓨터, …</p><p>총 데이터의 개수는 항상 ab개의 형태로 주어진다. 재용이는 문득 마지막 데이터가 처리될 컴퓨터의 번호가 궁금해졌다. 이를 수행해주는 프로그램을 작성하라.</p><h3>입력</h3><p>입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 정수 a와 b가 주어진다. (1 ≤ a &lt; 100, 1 ≤ b &lt; 1,000,000)</p><h3>출력</h3><p>각 테스트 케이스에 대해 마지막 데이터가 처리되는 컴퓨터의 번호를 출력한다.</p><h3>접근 방식</h3><p>이 문제의 경우에는 입력 받은 a를 b번 제곱 한 수의 마지막 자릿 수를 출력하는 문제이다.<br>무작정 제곱하면 자료형의 범위를 초과할 수 있으니 a의 크기를 줄이면서 마지막 자릿수를 출력 하는 데 중점을 두면 쉽게 풀 수 있다.</p><h3>코드</h3><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/7732320a4f5e512df011da18a32e3df1/href">https://medium.com/media/7732320a4f5e512df011da18a32e3df1/href</a></iframe><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9e245be16fb0" width="1" height="1"><hr><p><a href="https://medium.com/wasd/%EB%B0%B1%EC%A4%80-c-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%80%EC%9D%B4-1009%EB%B2%88-9e245be16fb0">[백준] C 알고리즘 풀이 — 1009번</a> was originally published in <a href="https://medium.com/wasd">WASD</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
    </channel>
</rss>