<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[오일석의 블로그]]></title><description><![CDATA[Microsoft Azure, I'm Maker]]></description><link>http://ilseokoh.com/</link><image><url>http://ilseokoh.com/favicon.png</url><title>오일석의 블로그</title><link>http://ilseokoh.com/</link></image><generator>Ghost 1.22</generator><lastBuildDate>Tue, 30 Apr 2019 06:44:08 GMT</lastBuildDate><atom:link href="http://ilseokoh.com/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[C# 7.0]]></title><description><![CDATA[<div class="kg-card-markdown"><h2 id="binaryliteralsanddigitseparators">Binary literals and digit separators</h2>
<pre><code class="language-c#">int myNumber = 0b11111111;
int myNumber2 = 0b1111_1111_0000_1111;

int onMillion = 1_000_000;
</code></pre>
<h2 id="localfunction">Local function</h2>
<pre><code class="language-c#">static void Main(string[] args)
{
    MyNumbers(); 
    
    void MyNumbers()
    {
        int mynum = 0b1111_1111;
        Console.WriteLine($&quot;my number: {mynum}&quot;);
    }
}
</code></pre>
<pre><code class="language-c#">int myValue = 1; 
int Calc(int n) =&gt; (n &lt;</code></pre></div>]]></description><link>http://ilseokoh.com/c-7-0/</link><guid isPermaLink="false">5b39dbbb86f74a0b4a3a8d5c</guid><category><![CDATA[c# 7.0]]></category><dc:creator><![CDATA[오일석]]></dc:creator><pubDate>Mon, 02 Jul 2018 09:53:58 GMT</pubDate><media:content url="http://ilseokoh.com/content/images/2018/07/C7.0.png" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><h2 id="binaryliteralsanddigitseparators">Binary literals and digit separators</h2>
<pre><code class="language-c#">int myNumber = 0b11111111;
int myNumber2 = 0b1111_1111_0000_1111;

int onMillion = 1_000_000;
</code></pre>
<h2 id="localfunction">Local function</h2>
<pre><code class="language-c#">static void Main(string[] args)
{
    MyNumbers(); 
    
    void MyNumbers()
    {
        int mynum = 0b1111_1111;
        Console.WriteLine($&quot;my number: {mynum}&quot;);
    }
}
</code></pre>
<pre><code class="language-c#">int myValue = 1; 
int Calc(int n) =&gt; (n &lt; 2) ? myValue : Calc(n-1) + Calc(n-2);
Console.WriteLine(Calc(8));
</code></pre>
<pre><code class="language-c#">public IEnumberable&lt;T&gt; Filter&lt;T&gt;(IEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; filter)
{
    if (source == null) throw new ArgumentNullException(nameof(source));
    if (filter == null) throw new ArgumentNullException(nameof(filter));
    
    return Iterator(); 
    
    IEnumerable&lt;T&gt; Iterator()
    {
        forech(var element in source)
        {
            if (filter(element)) { yield return element; }
        }
    }
}
</code></pre>
<h2 id="tuple">Tuple</h2>
<h3 id="oldtuplereferencetypeimmutablemustbe">Old Tuple: reference type, immutable(must be)</h3>
<pre><code class="language-c#">var person = new Tuple&lt;string, string, int&gt;(&quot;3 tuples&quot;, &quot;C#&quot;, 2016);

var reynald = Tuple.Create(&quot;5 Tuples&quot;, &quot;C#&quot;, &quot;ilseokoh&quot;, 2018, 7.0);

var nestedTuple = new Tuple&lt;int, int, int, int, int, int, int,
                      Tuple&lt;string, string, double&gt;&gt;(2,3,4,5,6,7,8,
                      Tuple.Create(&quot;Nested&quot;, &quot;C#&quot;, 7.0));
Console.WriteLine($&quot;{nestedTuple.Rest.Item1}&quot;);
</code></pre>
<pre><code class="language-c#">public static Tuple&lt;string, string, int&gt; GetTupleMethod() 
{
    var person = new Tuple&lt;string, string, int&gt;(&quot;tuple&quot;, &quot;c#&quot;, 7.0);
    return person; 
}
</code></pre>
<h3 id="newtuplevaluetypestructsmutable">New Tuple: value type(structs), mutable</h3>
<img src="http://ilseokoh.com/content/images/2018/07/C7.0.png" alt="C# 7.0"><p>Nuget에서 패키지를 받아와야 함.<br>
PM&gt; Install-Package &quot;System.ValueTuple&quot;</p>
<pre><code class="language-c#">using System.ValueTuple;

class TupleSamples
{
    public (string, string, long) GetNewCS7Tuple() { 
        string name = &quot;kevin oh&quot;;
        string title = &quot;ilseokoh.com&quot;;
        long year = 2018;
        
        return (name, title, year); 
    }
}

...

private static void Cs7Tuple()
{
    TupleSamples ts = new TupleSamples(); 
    var person = ts.GetNewCS7Tuple(); 
    Console.WriteLine($&quot;C# 7 Tuple - Author {person.Item1}, {person.Item2}, {person.Item3}&quot;);
}
</code></pre>
<pre><code class="language-c#">class TupleSamples
{
    public (string name, string title, long year) GetNewCS7Tuple() { 
        string name = &quot;kevin oh&quot;;
        string title = &quot;ilseokoh.com&quot;;
        long year = 2018;
        
        return (name, title, year); 
    }
}
</code></pre>
<h3 id="deconstructors">Deconstructors</h3>
<pre><code class="language-c#">(string authorName, string bookTitle, long pubYear) = GetNewCS7Tuple(); 

Console.WriteLine($&quot;Author: {authorName}, Title: {booktitle}, Year: {pubYear}&quot;);
</code></pre>
<pre><code class="language-c#">(var authorName, var bookTitle, var pubYear) = GetNewCS7Tuple(); 

var(authorName, bookTitle, pubYear) = GetNewCS7Tuple(); 
</code></pre>
<pre><code class="language-c#">class Program
{
    static void Main(string[] args)
    {
        Comedian comedian = new Comedian(&quot;Kevin&quot;, &quot;Oh&quot;);
        var (firstname, lastname) = comedian; 
        Console.WriteLine($&quot;{firstname} {lastname}&quot;);
    }
}

public class Comedian
{
    public stirng Firstname;
    public string Lastname; 
    
    public Comedian(string firstname, string lastname)
    {
        this.Firstname = firstname; 
        this.Lastname = lastname;
    }

    public void Deconstuct(out string firstname, out string lastName) { 
        firstName = FirstName; 
        lastName = LastName;
    }
}
</code></pre>
<h2 id="isexpressionswithpatterns">Is expressions with patterns</h2>
<pre><code class="language-c#">if (a is Performer p1)
    Console.WriteLine($&quot;This actor {p1.Name} is a performer.&quot;);
else ConsoleWriteLine($&quot;This actor is not a performer.&quot;);

if (a is Musisian) 
    Console.WriteLine($&quot;This actoris a musician.&quot;);
else ConsoleWriteLine($&quot;This actor is not a musician.&quot;);
</code></pre>
<h2 id="switchstatementwithpatterns">switch statement with patterns</h2>
<pre><code class="language-c#">switch(m)
{
    case Performer performer when (performer.Age == 33): 
        Console.WriteLine($&quot;The performer {performer.Name}&quot;);
    case Musician musician when (musician.Age == 25): 
        Console.WriteLine($&quot;The Performer {musician.Name}&quot;);
    case Musician musician:
        Console.WriteLine($&quot;The Musician is unknown&quot;);
    default: 
        Console.WriteLine(&quot;Not Found&quot;); 
    case null: 
        throw new ArgumentNullException(nameof(m));
}
</code></pre>
<h2 id="refreturns">Ref returns</h2>
<p>원래 ref 용도</p>
<pre><code class="language-c#">static void AddByRef(long a, long b, ref long total)
{
    total = a + b;
}

static void TestRef1()
{
    long total = 0;
    AddByRef(15, 10, ref total); 
    Console.WriteLine(total); // 25
}
</code></pre>
<pre><code class="language-c#">public ref string FindActor(int index, string[] names)
{
    if (names.Length &gt; 0) 
        return ref names[index];
        throw new IndexOutOfRangeException($&quot;{nameof(index)} not found&quot;);
}

static void TestRef2() 
{
    string[] actors = {&quot;Ben&quot;, &quot;Jennifer&quot;, &quot;Tom&quot;, &quot;Matt&quot;, &quot;Jackie&quot;}; 
    int positionInArray = 2; 
    
    ref string actor3 = ref new Program.FindActor(positionInArray, actors);
    
    Console.WriteLine($&quot;Origin: {actor3}&quot;); // Tom
    
    actor3 = &quot;Kevin&quot;; 
    
    Console.WriteLine($&quot;Changed: {actors[positionInArry]}&quot;); // kevin
}
</code></pre>
<h2 id="outvariables">Out variables</h2>
<pre><code class="language-c#">static void main(string[] args) 
{
    CreateName(out var firstname, out var lastName); 
    Consoel.WriteLine($&quot;{firstname}, {lastName}&quot;);
}

private static void CreateName(out string firstName, out string lastName) 
{
    firstName = &quot;Kevin&quot;;
    lastName = &quot;Oh&quot;;
}
</code></pre>
<h2 id="generalizedasyncreturntypes">Generalized async return types</h2>
<p>nuget<br>
PM&gt; Install-Package System.Threading.Tasks.Extensions</p>
<p>ValueTask는 sturct.</p>
<pre><code class="language-c#">private int GetCharacterCount()
{
    int count = 0;
    using (StreamReader reader = new StreamReader(&quot;Data.txt&quot;))
    {
        string content = reader.ReadToEnd();
        count = content.Length;
        Thread.Sleep(5000);
    }
    return count;
}

private async ValueTask&lt;int&gt; ProcessFile() {
    Task&lt;int&gt; task = new Task&lt;int&gt;(GetCharacterCount);
    task.Start();
    return await task;
}
</code></pre>
<h2 id="moreexpressionbodiedmembers">More expression bodied members</h2>
<p>Constructor</p>
<pre><code class="language-c#">//public Person(string name)
//{
//    Name = name;
//}

public Person(string name) =&gt; Name = name;
</code></pre>
<p>Full property</p>
<pre><code class="language-c#">private string _name;
public string Name
{
    get =&gt; _name;
    set =&gt; _name = value;
}
</code></pre>
<p>Destructor</p>
<pre><code class="language-c#">//~Person()
//{
//    Console.WriteLine(&quot;Destructor was called!&quot;);
//}

~Person() =&gt; Console.WriteLine(&quot;Destructor was called!&quot;);
</code></pre>
<h2 id="throwexpressions">Throw expressions</h2>
<pre><code class="language-c#">private string _name;
public string Name
{
    get =&gt; _name;
    set =&gt; _name = value ?? throw new ArgumentNullException(nameof(Name), message: &quot;New name must not be null&quot;);
}
</code></pre>
<p>Null Coalescing Expression</p>
<pre><code class="language-c#">public Person(string name) =&gt; Name = name ?? throw new ArumentException(name);
</code></pre>
<p>Conditional Expression</p>
<pre><code class="language-c#">public string GetFirstname() { 
    var parts = Name.Split(new string[] {&quot; &quot;}, StringSplitOptions.None);
    return (parts.Length &gt; 0) ? parts[0] : throw new InvalidOperationException(&quot;No name&quot;);
}
</code></pre>
<p>Lambda Expression</p>
<pre><code class="language-c#">public string GetLastname() =&gt; throw new NotImplementationException(); 
</code></pre>
</div>]]></content:encoded></item><item><title><![CDATA[C# 6.0]]></title><description><![CDATA[<div class="kg-card-markdown"><h2 id="nullconditionaloperators">Null-conditional operators</h2>
<pre><code class="language-c#">int? numberOfartists = artists?.Count(); 

Artist defaultArtist = artists?[0]; 

Console.WriteLine($&quot;name: {defaultArtist?.Name}&quot;); 

int thecount = artist?Count ?? 0; 

Console.WriteLine(&quot;$&quot;Default artist, {defaultArtist?.Name}, is age:{artists?[0]?.Age}&quot;);

//var handler = this.SomethingHappened;
//if (handler != null) handler(this, eventArgs);
this.SomethingHappened?.Invoke(this,</code></pre></div>]]></description><link>http://ilseokoh.com/c-6-0/</link><guid isPermaLink="false">5b39c55a86f74a0b4a3a8d58</guid><category><![CDATA[c# 6.0]]></category><dc:creator><![CDATA[오일석]]></dc:creator><pubDate>Mon, 02 Jul 2018 07:57:09 GMT</pubDate><media:content url="http://ilseokoh.com/content/images/2018/07/csharp-6.png" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><h2 id="nullconditionaloperators">Null-conditional operators</h2>
<pre><code class="language-c#">int? numberOfartists = artists?.Count(); 

Artist defaultArtist = artists?[0]; 

Console.WriteLine($&quot;name: {defaultArtist?.Name}&quot;); 

int thecount = artist?Count ?? 0; 

Console.WriteLine(&quot;$&quot;Default artist, {defaultArtist?.Name}, is age:{artists?[0]?.Age}&quot;);

//var handler = this.SomethingHappened;
//if (handler != null) handler(this, eventArgs);
this.SomethingHappened?.Invoke(this, eventArgs);
</code></pre>
<h2 id="stringinterpolation">String interpolation</h2>
<pre><code class="language-c#">var address = string.Format($&quot;334 S. Main St., {city}, {state}, {zip}\n&quot;);

var moneyOwed = $&quot;Today: {DateTime.Now.ToShortDateString()}, Dollar owed {money:C}&quot;;

public string GetAllGrades() =&gt;
    $@&quot;All Grades: {Grades.OrderByDescending(g =&gt; g)
    .Select(s =&gt; s.ToString(&quot;F2&quot;)).Aggregate((partial, element) =&gt; $&quot;{partial}, {element}&quot;)}&quot;;
</code></pre>
<h2 id="indexinitializers">Index initializers</h2>
<pre><code class="language-c#">var myNewDic = new Dictionary&lt;string, string&gt;
{
    [&quot;name&quot;] = &quot;Robert&quot;, 
    [&quot;artist&quot;] = &quot;mafia&quot;,
    [&quot;FamousQuote&quot;] = &quot;&quot;
};

var array = new[] {&quot;name&quot;, &quot;artist&quot;}; 
var thisArrayList = new List&lt;string&gt;(array)
{
    [0] = &quot;Robert&quot;, 
    [1] = &quot;Mafia&quot;
}
</code></pre>
<h2 id="nameofexpressions">nameof Expressions</h2>
<pre><code class="language-c#">if (IsNullOrWhiteSpace(lastName))
    throw new ArgumentException(message: &quot;Cannot be blank&quot;, paramName: nameof(lastName));
    
public string LastName
{
    get { return lastName; }
    set
    {
        if (value != lastName)
        {
            lastName = value;
            PropertyChanged?.Invoke(this, 
                new PropertyChangedEventArgs(nameof(LastName)));
        }
    }
}
private string lastName;
</code></pre>
<h2 id="extentionaddmethods">Extention add methods</h2>
<pre><code class="language-c#">public class Enrollment : IEnumerable&lt;Student&gt;
{
    private List&lt;Student&gt; allStudents = new List&lt;Student&gt;();

    public void Enroll(Student s)
    {
        allStudents.Add(s);
    }

    public IEnumerator&lt;Student&gt; GetEnumerator()
    {
        return ((IEnumerable&lt;Student&gt;)allStudents).GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return ((IEnumerable&lt;Student&gt;)allStudents).GetEnumerator();
    }
    
    // No Add method
}
</code></pre>
<pre><code class="language-c#">public static class StudentExtensions
{
    public static void Add(this Enrollment e, Student s) =&gt; e.Enroll(s);
}
</code></pre>
<pre><code class="language-c#">var classList = new Enrollment()
{
    new Student(&quot;Lessie&quot;, &quot;Crosby&quot;),
    new Student(&quot;Vicki&quot;, &quot;Petty&quot;)
}
</code></pre>
<h2 id="awaitincatchandfinallyblocks">await in catch and finally blocks</h2>
<pre><code class="language-c#">private static async Task LogDataAsync(string details, Exception ex) 
{ 
    using (var thisFile = File.Append.Text(&quot;issues.log&quot;))
    {
        await thisFile.WriteLineAsync($&quot;{details} {ex?.ToString()}&quot;);
    }
}

private static async void Test_AsnynInCatchFinally()
{
    try
    {
        throw new Exception(&quot;Something went wrong&quot;);
    }
    catch (Exception ex)
    {
        await LogDataAsync(&quot;Problem description --&gt;&quot;, ex); 
    }
    finally 
    {
        await LogDataAsync(&quot;Complete.&quot;, null); 
    }
}
</code></pre>
<h2 id="addingexceptionfilters">Adding exception filters</h2>
<pre><code class="language-c#">private static async void Test_ExceptionFilters()
{
    try
    {
        throw new Exception(&quot;Something went wrong&quot;);
    }
    catch (Exception ex) when (ex.Message.Substring(0,7) == &quot;Warning&quot;)
    {
        // Do nothing. Just warning
    }
    catch (Exception ex)
    {
        await LogDataAsync(&quot;Problem description --&gt;&quot;, ex); 
    }
    finally 
    {
        await LogDataAsync(&quot;Complete.&quot;, null); 
    }
}
</code></pre>
<h2 id="autopropertiesinitializers">Auto Properties Initializers</h2>
<pre><code class="language-c#">class Artist 
{
    public string Name { get; set;} = &quot;A-List actor&quot;;
}
</code></pre>
<h2 id="readonlyautoproperties">Read-only auto properties</h2>
<pre><code class="language-c#">class Artist 
{
    public int Age { get; } = 65;
}
</code></pre>
<h2 id="expressionbodiedfunctionmembers">Expression-bodied function members</h2>
<pre><code class="language-c#">static public stirng Name =&gt; &quot;Jerry Seinfeld&quot;;

static public string GetFullName(string firstname, string lastname) =&gt; $&quot;{firstname} {lastname}&quot;;

static public void PrintFullName(string firstname, string lastname) =&gt;  Console.WriteLine($&quot;{firstname} {lastname}&quot;); 

static public Comedian PrintComedianName(string firstname, string lastname) =&gt; new Comedian(firstName, lastname)
</code></pre>
<h2 id="usinstatic">usin static</h2>
<pre><code class="language-c#">using static System.Math; 
using static System.Console;

class Program
{
    private static void UsingSimplified() 
    {
        WriteLine($&quot;The comedy club was great. But it cost me {Round(59.8)});
    }
}
</code></pre>
<h2 id="orderofoperationwithstaticandinstancemethods">order of operation with static and instance methods</h2>
<img src="http://ilseokoh.com/content/images/2018/07/csharp-6.png" alt="C# 6.0"><p>Console.WriteLine 보다 인스턴스의 WriteLine이 우선함.</p>
<pre><code class="language-c#">using static System.Console;

class Program
{
    internal class writer
    {
        public void SartTest(string statement)
        {
            WriteLine(statement);
        }
        
        public void WriteLine(string statement)
        {
            Console.WriteLine($&quot;Instance method: {statement}&quot;);
        }
    }
    
    static private void Test_UsingInstance() 
    {
        Write w = new Writer(); 
        w.StartTest(&quot;Good morning&quot;); 
    }
}
</code></pre>
<h2 id="immediatewatchwindowsonvisualstudio">Immediate/watch windows on visual Studio</h2>
<p>Linq Expression을 Immediate/Watch 윈도우에서 사용가능.</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6#read-only-auto-properties">What's New in C# 6</a></p>
</div>]]></content:encoded></item><item><title><![CDATA[Packer로 Azure VM 이미지 만들기 #2 - Powershell로 실행하고 최신 이미지 Tag]]></title><description><![CDATA[<div class="kg-card-markdown"><p><a href="http://ilseokoh.com/packer-azure-vm-image/">Packer로 Azure 이미지 만들기 #1 - Packer 템플릿</a>에서는 Packer의 기본을 알아봤는데 이제 실제 사례를 살펴보자.</p>
<h2 id="">상황설명</h2>
<p>수십 또는 수백 대의 VM을 관리하는 상황에서 VMSS(Virtual Machin Scale Set)을 사용하거나 VM의 베이스 이미지를 만들어서 관리하는 상황을 생각해보자. VM의 설정이나 애플리케이션이 변경되면 Packer 템플릿을 수정하고 새로 이미지를 만들어 업데이트 하려고</p></div>]]></description><link>http://ilseokoh.com/packer-azure-powershell/</link><guid isPermaLink="false">5b16463c86f74a0b4a3a8d13</guid><category><![CDATA[azure]]></category><category><![CDATA[packer]]></category><category><![CDATA[vsts]]></category><dc:creator><![CDATA[오일석]]></dc:creator><pubDate>Wed, 20 Jun 2018 06:15:56 GMT</pubDate><media:content url="http://ilseokoh.com/content/images/2018/06/packer-azure-powershell.jpg" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><img src="http://ilseokoh.com/content/images/2018/06/packer-azure-powershell.jpg" alt="Packer로 Azure VM 이미지 만들기 #2 - Powershell로 실행하고 최신 이미지 Tag"><p><a href="http://ilseokoh.com/packer-azure-vm-image/">Packer로 Azure 이미지 만들기 #1 - Packer 템플릿</a>에서는 Packer의 기본을 알아봤는데 이제 실제 사례를 살펴보자.</p>
<h2 id="">상황설명</h2>
<p>수십 또는 수백 대의 VM을 관리하는 상황에서 VMSS(Virtual Machin Scale Set)을 사용하거나 VM의 베이스 이미지를 만들어서 관리하는 상황을 생각해보자. VM의 설정이나 애플리케이션이 변경되면 Packer 템플릿을 수정하고 새로 이미지를 만들어 업데이트 하려고 한다. 이미 VM 이미지가 있고 그 이미지 바탕으로 업데이트 해야한다. Packer가 실행되어 업데이트가 적용된 새로운 이미지를 만든다. 새로운 이미지에는 Tag를 version:latest로 달아서 Azure CLI, PowerShell 등의 코드에서 최신 이미지를 찾을 수 있도록 해준다.</p>
<h2 id="">소스코드</h2>
<p>전체 소스코드를 <a href="https://github.com/ilseokoh/packer-azure-vsts">Github</a>에 올려놨다. 주요 파일에 대한 설명은 아래와 같다.</p>
<ul>
<li>packer.exe 윈도우 버전 packer 실행 파일. <a href="https://www.packer.io/downloads.html">packer.io</a>에서 다운로드</li>
<li>build-baseimage.ps1 파워쉘로 작성한 실행 스크립트</li>
<li>baseimage.json Packer 템플릿</li>
<li>powershell/update-latest-imagename.ps1 Packer의 post-processor가 최신이미지 이름을 파라미터와 함께 호출해서 최신이미지의 Tag 적용</li>
<li>variable.json Azure의 Service Priciple과 베이스 이미지가 만들어질 리소스 그룹 이름</li>
</ul>
<p>여기서는 Windows VM을 대상으로 했다. 따라서 몇 가지 스크립트들이 PowerShell로 작성되었다.</p>
<h2 id="">소스코드</h2>
<p>VSTS의 Git Repository에서 소스를 다운 받는다. 이 소소코드는 <a href="https://github.com/ilseokoh/packer-azure-vsts">Github</a>에 있다.<br>
<img src="http://ilseokoh.com/content/images/2018/06/1-get-source.jpg" alt="Packer로 Azure VM 이미지 만들기 #2 - Powershell로 실행하고 최신 이미지 Tag"></p>
<h2 id="powershell">Powershell로 로컬에서 실행하기</h2>
<p>VSTS를 사용해서 자동화 하기 전에 build-baseimage.ps1 스크립트를 이용해서 실행해보자. AzureRM Powershell 모듈을 가져오고 Azure에 로그인 한다. 이때 로그인 창이 뜬다. Tag version:latest를 이용해서 최신 이미지를 찾는다. Packer를 실행시켜 새로운 이미지를 만든다.</p>
<pre><code class="language-powershell"># Azure RM import
Import-Module -Name AzureRM
# Get variable for service principle
$variables = Get-Content '.\variable.json' | Out-String | ConvertFrom-Json
$SecurePassword = $variables.client_secret | ConvertTo-SecureString -AsPlainText -Force
$cred = new-object -typename System.Management.Automation.PSCredential -argumentlist $variables.client_id, $SecurePassword
# login to Azure
Connect-AzureRmAccount -Credential $cred -Tenant $variables.tenant_id -ServicePrincipal

# Get Latest base image 
$latestimagename = (Get-AzureRmResource -ODataQuery &quot;`$filter=tagname eq 'version' and tagvalue eq 'latest'&quot;).Name

$cmdPath = &quot;$PSScriptRoot\packer.exe&quot;
$cmdArgList = @(
	&quot;build&quot;,
	# &quot;validate&quot;,
	# &quot;-debug&quot;,
	&quot;-var-file=.\variable.json&quot;,
	&quot;-var&quot;,&quot;custom_managed_image_name=$latestimagename&quot;
	&quot;.\bdm-baseimage.json&quot;
)

Write-Output &quot;image name: $latestimagename&quot;
Write-Output &quot;cmd: $cmdPath&quot;
Write-Output &quot;arg: $cmdArgList&quot;

&amp; $cmdPath $cmdArgList
</code></pre>
<p>Packer 템플릿은 아래와 같다. Provisioner에 추가되는 설정을 넣어주거나 chocolatey로 툴을 설치할 수 있다. 여기서는 chocolatey를 설치하는 스크립트를 실행하고 Sysprep 하는 스크립트가 실행된다.</p>
<pre><code class="language-json">{
    &quot;variables&quot;: {
        &quot;client_id&quot;: &quot;{{env `ARM_CLIENT_ID`}}&quot;,
        &quot;client_secret&quot;: &quot;{{env `ARM_CLIENT_SECRET`}}&quot;,
        &quot;tenant_id&quot;: &quot;{{env `ARM_TENANT_ID}}&quot;,
        &quot;subscription_id&quot;: &quot;{{env `ARM_SUBSCRIPTION_ID`}}&quot;,
        &quot;object_id&quot;: &quot;{{env `ARM_OJBECT_ID`}}&quot;,
        &quot;custom_managed_image_resource_group_name&quot;: &quot;{{env `ARM_CUSTOM_IMAGE_RG_NAME`}}&quot;,
        &quot;custom_managed_image_name&quot;: &quot;{{env `ARM_CUSTOM_IMAGE_NAME`}}&quot;,
        &quot;image_name&quot;: &quot;base-image-{{isotime \&quot;2006-01-02\&quot;}}_{{isotime \&quot;03-04-05\&quot;}}&quot;
    },
    &quot;builders&quot;: [
        {
            &quot;type&quot;: &quot;azure-arm&quot;,

            &quot;client_id&quot;: &quot;{{user `client_id`}}&quot;,
            &quot;client_secret&quot;: &quot;{{user `client_secret`}}&quot;,
            &quot;tenant_id&quot;: &quot;{{user `tenant_id`}}&quot;,
            &quot;subscription_id&quot;: &quot;{{user `subscription_id`}}&quot;,
            &quot;object_id&quot;: &quot;{{user `object_id`}}&quot;,

            &quot;managed_image_resource_group_name&quot;: &quot;{{user `custom_managed_image_resource_group_name`}}&quot;,
            &quot;managed_image_name&quot;: &quot;{{user `image_name`}}&quot;, 

            &quot;location&quot;: &quot;Korea Central&quot;,
            &quot;vm_size&quot;: &quot;Standard_D2s_v3&quot;,

            &quot;os_type&quot;: &quot;Windows&quot;,
            &quot;custom_managed_image_resource_group_name&quot;: &quot;{{user `custom_managed_image_resource_group_name`}}&quot;,
            &quot;custom_managed_image_name&quot;: &quot;{{user `custom_managed_image_name`}}&quot;,

            &quot;communicator&quot;: &quot;winrm&quot;,
            &quot;winrm_use_ssl&quot;: &quot;true&quot;,
            &quot;winrm_insecure&quot;: &quot;true&quot;,
            &quot;winrm_timeout&quot;: &quot;3m&quot;,
            &quot;winrm_username&quot;: &quot;ansibleuser&quot;
        }
    ],
    &quot;provisioners&quot;: [
        {
            &quot;type&quot;: &quot;powershell&quot;, 
            &quot;script&quot;: &quot;./powershell/install-chocolatey.ps1&quot;
        },
        {
            &quot;type&quot;: &quot;powershell&quot;,
            &quot;inline&quot;: [
                &quot;if( Test-Path $Env:SystemRoot\\windows\\system32\\Sysprep\\unattend.xml ){ rm $Env:SystemRoot\\windows\\system32\\Sysprep\\unattend.xml -Force}&quot;,
                &quot;&amp; $env:SystemRoot\\System32\\Sysprep\\Sysprep.exe /oobe /generalize /quiet /quit&quot;,
                &quot;while($true) { $imageState = Get-ItemProperty HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\State | Select ImageState; if($imageState.ImageState -ne 'IMAGE_STATE_GENERALIZE_RESEAL_TO_OOBE') { Write-Output $imageState.ImageState; Start-Sleep -s 10  } else { break } }&quot;
            ]
        }
    ],
    &quot;post-processors&quot;: [
        {
            &quot;type&quot;: &quot;shell-local&quot;,
            &quot;execute_command&quot;: [&quot;powershell.exe&quot;, &quot;{{.Script}} {{user `image_name`}}&quot;],
            &quot;script&quot;: &quot;.\\powershell\\update-latest-imagename.ps1&quot;
        }
    ]
}
</code></pre>
<p>post-processor에는 update-latest-imagename.ps1 라는 스크립트를 실행하게 되어 있는데 최신이미지에 Tag version:latest를 적용해서 다음번 빌드를 준비한다.</p>
<pre><code class="language-powershell">Param(
    [string]$newimagename
)

# Azure RM import
Import-Module -Name AzureRM
# Get variable for service principle
$variables = Get-Content '..\variable.json' | Out-String | ConvertFrom-Json
$SecurePassword = $variables.client_secret | ConvertTo-SecureString -AsPlainText -Force
$cred = new-object -typename System.Management.Automation.PSCredential -argumentlist $variables.client_id, $SecurePassword
# login to Azure
Connect-AzureRmAccount -Credential $cred -Tenant $variables.tenant_id -ServicePrincipal

#update latest-imagename.txt
Write-Output &quot;New Image name: $newimagename&quot;

#remove all tag in the resoruce group 
$current = (Get-AzureRmResource -ODataQuery &quot;`$filter=tagname eq 'version' and tagvalue eq 'latest'&quot;)
Set-AzureRmResource -Tag @{ } -ResourceId $current.ResourceId -Force

#set tag to the new image  
$r = Get-AzureRmResource | Where-Object ResourceName -eq $newimagename
Set-AzureRmResource -Tag @{ version=&quot;latest&quot;} -ResourceId $r.ResourceId -Force
</code></pre>
<p>실행결과</p>
<pre><code>&gt; .\build-baseimage.ps1

Account          : 220b9c3c-fac5-4df4-bf47-3f296123a447
SubscriptionName : Microsoft Azure Internal Consumption
SubscriptionId   : e47f0bbb-cd59-41dc-86b7-2e2432d53604
TenantId         : 72f988bf-86f1-41af-91ab-2dcd01531b47
Environment      : AzureCloud

image name: base-image-2018-06-07_05-03-53
cmd: C:\Users\iloh\source\packer-azure-vsts\packer.exe
arg: build -var-file=.\variable.json -var custom_managed_image_name=base-image-2018-06-07_05-03-53 .\baseimage.json

azure-arm output will be in this color.

==&gt; azure-arm: Running builder ...
    azure-arm: Creating Azure Resource Manager (ARM) client ...
    azure-arm: You have provided Object_ID which is no longer needed, azure packer builder determines this dynamically from the authentication token
==&gt; azure-arm: Creating resource group ...
==&gt; azure-arm:  -&gt; ResourceGroupName : 'packer-Resource-Group-rbggjbzqf5'
==&gt; azure-arm:  -&gt; Location          : 'Korea Central'
==&gt; azure-arm:  -&gt; Tags              :
==&gt; azure-arm: Validating deployment template ...
==&gt; azure-arm:  -&gt; ResourceGroupName : 'packer-Resource-Group-rbggjbzqf5'
==&gt; azure-arm:  -&gt; DeploymentName    : 'pkrdprbggjbzqf5'
==&gt; azure-arm: Deploying deployment template ...
==&gt; azure-arm:  -&gt; ResourceGroupName : 'packer-Resource-Group-rbggjbzqf5'
==&gt; azure-arm:  -&gt; DeploymentName    : 'kvpkrdprbggjbzqf5'
==&gt; azure-arm: Getting the certificate's URL ...
==&gt; azure-arm:  -&gt; Key Vault Name        : 'pkrkvrbggjbzqf5'
==&gt; azure-arm:  -&gt; Key Vault Secret Name : 'packerKeyVaultSecret'
==&gt; azure-arm:  -&gt; Certificate URL       : 'https://pkrkvrbggjbzqf5.vault.azure.net/secrets/packerKeyVaultSecret/5038000621384cc1ad6a15603abb32df'
==&gt; azure-arm: Setting the certificate's URL ...
==&gt; azure-arm: Validating deployment template ...
==&gt; azure-arm:  -&gt; ResourceGroupName : 'packer-Resource-Group-rbggjbzqf5'
==&gt; azure-arm:  -&gt; DeploymentName    : 'pkrdprbggjbzqf5'
==&gt; azure-arm: Deploying deployment template ...
==&gt; azure-arm:  -&gt; ResourceGroupName : 'packer-Resource-Group-rbggjbzqf5'
==&gt; azure-arm:  -&gt; DeploymentName    : 'pkrdprbggjbzqf5'
==&gt; azure-arm: Getting the VM's IP address ...
==&gt; azure-arm:  -&gt; ResourceGroupName   : 'packer-Resource-Group-rbggjbzqf5'
==&gt; azure-arm:  -&gt; PublicIPAddressName : 'pkriprbggjbzqf5'
==&gt; azure-arm:  -&gt; NicName             : 'pkrnirbggjbzqf5'
==&gt; azure-arm:  -&gt; Network Connection  : 'PublicEndpoint'
==&gt; azure-arm:  -&gt; IP Address          : '52.231.68.202'
==&gt; azure-arm: Waiting for WinRM to become available...
    azure-arm: #&lt; CLIXML
    azure-arm: WinRM connected.
    azure-arm: &lt;Objs Version=&quot;1.1.0.1&quot; xmlns=&quot;http://schemas.microsoft.com/powershell/2004/04&quot;&gt;&lt;Obj S=&quot;progress&quot; RefId=&quot;0&quot;&gt;&lt;TN RefId=&quot;0&quot;&gt;&lt;T&gt;System.Management.Automation.PSCustomObject&lt;/T&gt;&lt;T&gt;System.Object&lt;/T&gt;&lt;/TN&gt;&lt;MS&gt;&lt;I64 N=&quot;SourceId&quot;&gt;1&lt;/I64&gt;&lt;PR N=&quot;Record&quot;&gt;&lt;AV&gt;Preparing modules for first use.&lt;/AV&gt;&lt;AI&gt;0&lt;/AI&gt;&lt;Nil /&gt;&lt;PI&gt;-1&lt;/PI&gt;&lt;PC&gt;-1&lt;/PC&gt;&lt;T&gt;Completed&lt;/T&gt;&lt;SR&gt;-1&lt;/SR&gt;&lt;SD&gt; &lt;/SD&gt;&lt;/PR&gt;&lt;/MS&gt;&lt;/Obj&gt;&lt;Obj S=&quot;progress&quot; RefId=&quot;1&quot;&gt;&lt;TNRef RefId=&quot;0&quot; /&gt;&lt;MS&gt;&lt;I64 N=&quot;SourceId&quot;&gt;1&lt;/I64&gt;&lt;PR N=&quot;Record&quot;&gt;&lt;AV&gt;Preparing modules for first use.&lt;/AV&gt;&lt;AI&gt;0&lt;/AI&gt;&lt;Nil /&gt;&lt;PI&gt;-1&lt;/PI&gt;&lt;PC&gt;-1&lt;/PC&gt;&lt;T&gt;Completed&lt;/T&gt;&lt;SR&gt;-1&lt;/SR&gt;&lt;SD&gt; &lt;/SD&gt;&lt;/PR&gt;&lt;/MS&gt;&lt;/Obj&gt;&lt;/Objs&gt;
==&gt; azure-arm: Connected to WinRM!
==&gt; azure-arm: Provisioning with Powershell...
==&gt; azure-arm: Provisioning with powershell script: ./powershell/install-chocolatey.ps1
    azure-arm: Getting latest version of the Chocolatey package for download.
    azure-arm: Getting Chocolatey from https://chocolatey.org/api/v2/package/chocolatey/0.10.11.
    azure-arm: Downloading 7-Zip commandline tool prior to extraction.
    azure-arm: Extracting C:\Users\packer\AppData\Local\Temp\chocolatey\chocInstall\chocolatey.zip to C:\Users\packer\AppData\Local\Temp\chocolatey\chocInstall...
    azure-arm: Installing chocolatey on this machine
    azure-arm: Creating ChocolateyInstall as an environment variable (targeting 'Machine')
    azure-arm:   Setting ChocolateyInstall to 'C:\ProgramData\chocolatey'
    azure-arm: WARNING: It's very likely you will need to close and reopen your shell
    azure-arm:   before you can use choco.
    azure-arm: Restricting write permissions to Administrators
    azure-arm: We are setting up the Chocolatey package repository.
    azure-arm: The packages themselves go to 'C:\ProgramData\chocolatey\lib'
    azure-arm:   (i.e. C:\ProgramData\chocolatey\lib\yourPackageName).
    azure-arm: A shim file for the command line goes to 'C:\ProgramData\chocolatey\bin'
    azure-arm:   and points to an executable in 'C:\ProgramData\chocolatey\lib\yourPackageName'.
    azure-arm:
    azure-arm: Creating Chocolatey folders if they do not already exist.
    azure-arm:
    azure-arm: WARNING: You can safely ignore errors related to missing log files when
    azure-arm:   upgrading from a version of Chocolatey less than 0.9.9.
    azure-arm:   'Batch file could not be found' is also safe to ignore.
    azure-arm:   'The system cannot find the file specified' - also safe.
    azure-arm: WARNING: Not setting tab completion: Profile file does not exist at
    azure-arm: 'C:\Users\packer\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1'.
    azure-arm: Chocolatey (choco.exe) is now ready.
    azure-arm: You can call choco from anywhere, command line or powershell by typing choco.
    azure-arm: Run choco /? for a list of functions.
    azure-arm: You may need to shut down and restart powershell and/or consoles
    azure-arm:  first prior to using choco.
    azure-arm: Ensuring chocolatey commands are on the path
    azure-arm: Ensuring chocolatey.nupkg is in the lib folder
==&gt; azure-arm: Provisioning with Powershell...
==&gt; azure-arm: Provisioning with powershell script: C:\Users\iloh\AppData\Local\Temp\packer-powershell-provisioner392428847
    azure-arm: IMAGE_STATE_COMPLETE
    azure-arm: IMAGE_STATE_UNDEPLOYABLE
    azure-arm: IMAGE_STATE_UNDEPLOYABLE
    azure-arm: IMAGE_STATE_UNDEPLOYABLE
    azure-arm: IMAGE_STATE_UNDEPLOYABLE
    azure-arm: IMAGE_STATE_UNDEPLOYABLE
    azure-arm: IMAGE_STATE_UNDEPLOYABLE
    azure-arm: IMAGE_STATE_UNDEPLOYABLE
    azure-arm: IMAGE_STATE_UNDEPLOYABLE
==&gt; azure-arm: Querying the machine's properties ...
==&gt; azure-arm:  -&gt; ResourceGroupName : 'packer-Resource-Group-rbggjbzqf5'
==&gt; azure-arm:  -&gt; ComputeName       : 'pkrvmrbggjbzqf5'
==&gt; azure-arm:  -&gt; Managed OS Disk   : '/subscriptions/e47f0bbb-cd59-41dc-86b7-2e239d536c04/resourceGroups/packer-Resource-Group-rbggjbzqf5/providers/Microsoft.Compute/disks/pkrosrbggjbzqf5'
==&gt; azure-arm: Querying the machine's additional disks properties ...
==&gt; azure-arm:  -&gt; ResourceGroupName : 'packer-Resource-Group-rbggjbzqf5'
==&gt; azure-arm:  -&gt; ComputeName       : 'pkrvmrbggjbzqf5'
==&gt; azure-arm: Powering off machine ...
==&gt; azure-arm:  -&gt; ResourceGroupName : 'packer-Resource-Group-rbggjbzqf5'
==&gt; azure-arm:  -&gt; ComputeName       : 'pkrvmrbggjbzqf5'
==&gt; azure-arm: Capturing image ...
==&gt; azure-arm:  -&gt; Compute ResourceGroupName : 'packer-Resource-Group-rbggjbzqf5'
==&gt; azure-arm:  -&gt; Compute Name              : 'pkrvmrbggjbzqf5'
==&gt; azure-arm:  -&gt; Compute Location          : 'Korea Central'
==&gt; azure-arm:  -&gt; Image ResourceGroupName   : 'BaseImageGroup'
==&gt; azure-arm:  -&gt; Image Name                : 'base-image-2018-06-20_05-01-33'
==&gt; azure-arm:  -&gt; Image Location            : 'koreacentral'
==&gt; azure-arm: Deleting resource group ...
==&gt; azure-arm:  -&gt; ResourceGroupName : 'packer-Resource-Group-rbggjbzqf5'
==&gt; azure-arm:
==&gt; azure-arm: The resource group was created by Packer, deleting ...
==&gt; azure-arm: Deleting the temporary OS disk ...
==&gt; azure-arm:  -&gt; OS Disk : skipping, managed disk was used...
==&gt; azure-arm: Deleting the temporary Additional disk ...
==&gt; azure-arm:  -&gt; Additional Disk : skipping, managed disk was used...
==&gt; azure-arm: Running post-processor: shell-local
==&gt; azure-arm (shell-local): Running local shell script: .\powershell\update-latest-imagename.ps1
    azure-arm (shell-local):
    azure-arm (shell-local):
    azure-arm (shell-local): Account          : 220b9c3c-fac5-4df4-bf47-3f212ecea447
    azure-arm (shell-local): SubscriptionName : Microsoft Azure Internal Consumption
    azure-arm (shell-local): SubscriptionId   : e47f0bbb-cd59-41dc-86b7-2e223436c04
    azure-arm (shell-local): TenantId         : 72f988bf-86f1-41af-91ab-2d42121db47
    azure-arm (shell-local): Environment      : AzureCloud
    azure-arm (shell-local):
    azure-arm (shell-local): New Image name: base-image-2018-06-20_05-01-33
    azure-arm (shell-local):
    azure-arm (shell-local): Name              : base-image-2018-06-07_05-03-53
    azure-arm (shell-local): ResourceId        : /subscriptions/e4123bbb-cd59-41dc-86b7-2e239d536c04/resourceGroups/BaseImageGroup/providers/Microsoft.Compute/images/base-image-2018-06-07_05-03-53
    azure-arm (shell-local): ResourceName      : base-image-2018-06-07_05-03-53
    azure-arm (shell-local): ResourceType      : Microsoft.Compute/images
    azure-arm (shell-local): ResourceGroupName : BaseImageGroup
    azure-arm (shell-local): Location          : koreacentral
    azure-arm (shell-local): SubscriptionId    : e47f0bbb-cd59-41dc-86b7-2e239d536c04
    azure-arm (shell-local): Tags              : {}
    azure-arm (shell-local): Properties        : @{sourceVirtualMachine=; storageProfile=; provisioningState=Succeeded}
    azure-arm (shell-local):
    azure-arm (shell-local):
    azure-arm (shell-local): Name              : base-image-2018-06-20_05-01-33
    azure-arm (shell-local): ResourceId        : /subscriptions/e4123bbb-cd59-41dc-8627-2e239d536c04/resourceGroups/BaseImageGroup/providers/Microsoft.Compute/images/base-image-2018-06-20_05-01-33
    azure-arm (shell-local): ResourceName      : base-image-2018-06-20_05-01-33
    azure-arm (shell-local): ResourceType      : Microsoft.Compute/images
    azure-arm (shell-local): ResourceGroupName : BaseImageGroup
    azure-arm (shell-local): Location          : koreacentral
    azure-arm (shell-local): SubscriptionId    : e47f0bbb-cd59-41dc-86b7-2e239d536c04
    azure-arm (shell-local): Tags              : {version}
    azure-arm (shell-local): Properties        : @{sourceVirtualMachine=; storageProfile=; provisioningState=Succeeded}
    azure-arm (shell-local):
    azure-arm (shell-local):
    azure-arm (shell-local):
Build 'azure-arm' finished.

==&gt; Builds finished. The artifacts of successful builds are:
--&gt; azure-arm: Azure.ResourceManagement.VMImage:

ManagedImageResourceGroupName: BaseImageGroup
ManagedImageName: base-image-2018-06-20_05-01-33
ManagedImageLocation: koreacentral

--&gt; azure-arm:
</code></pre>
<p>Packer가 실행되어 새로운 이미지가 만들어진다. 새로 생성된 이미지에 Tag도 정확히 적용된 걸 확인했다. Packer가 실행되는 동안 Azure Portal을 열어보면 Packer가 만든 리소스가 만들어지고 삭제되는 모습을 볼 수 있다.<br>
<img src="http://ilseokoh.com/content/images/2018/06/packer-portal.jpg" alt="Packer로 Azure VM 이미지 만들기 #2 - Powershell로 실행하고 최신 이미지 Tag"></p>
<p>로컬 PowerShell에서 잘 작동하니 VSTS(Visual Studio Team Services)에 올려서 자동화 해보자. 다음편 <a href="http://ilseokoh.com/packer-vsts-azure">Packer로 Azure VM 이미지 만들기 #2 - VSTS로 자동화 하기</a></p>
</div>]]></content:encoded></item><item><title><![CDATA[Ansible로 Azure 관리하기 #2 - Provision]]></title><description><![CDATA[<div class="kg-card-markdown"><p>Ansible로 Azure 관리하기 <a href="http://ilseokoh.com/ansible-azure/">1편 Ansible 기초</a>에서 기본 개념을 살펴봤다. 2편에서는 Azure에 VM을 생성하는 방법에 대해서 애기해보자. 1편에서 살펴본 azure_rm_virtualnetwork 과 같은 모듈을 사용해서 Azure에 필요한 리소스를 만들 수 있다. 하지만 이 방법은 단점이 있는데 빠르게 발전하고 변화하는 Azure의 여러가지 기능을 빠르게 따라오지를 못한다. 새로나온 기능에 대한 상세한</p></div>]]></description><link>http://ilseokoh.com/ansible-azure-2-provision/</link><guid isPermaLink="false">5b02637286f74a0b4a3a8cfd</guid><category><![CDATA[azure]]></category><dc:creator><![CDATA[오일석]]></dc:creator><pubDate>Wed, 06 Jun 2018 06:26:07 GMT</pubDate><media:content url="http://ilseokoh.com/content/images/2018/05/ansible-azure-provision.jpg" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><img src="http://ilseokoh.com/content/images/2018/05/ansible-azure-provision.jpg" alt="Ansible로 Azure 관리하기 #2 - Provision"><p>Ansible로 Azure 관리하기 <a href="http://ilseokoh.com/ansible-azure/">1편 Ansible 기초</a>에서 기본 개념을 살펴봤다. 2편에서는 Azure에 VM을 생성하는 방법에 대해서 애기해보자. 1편에서 살펴본 azure_rm_virtualnetwork 과 같은 모듈을 사용해서 Azure에 필요한 리소스를 만들 수 있다. 하지만 이 방법은 단점이 있는데 빠르게 발전하고 변화하는 Azure의 여러가지 기능을 빠르게 따라오지를 못한다. 새로나온 기능에 대한 상세한 설정이 빠져 있는 경우도 있다. 이를 극복하기 위해서 ARM Template과 Ansible를 함께 사용하는 방법을 추천한다.</p>
<h2 id="arm">ARM 템플릿</h2>
<p>ARM 템플릿 (Azure Resource Manager Template)은 Azure의 리소스와 설정들을 Json 으로 표현해 놓고 Azure에 배포하면 템플릿에 설정한 그대로 리소스를 배포 할 수 있는 방법이다. <a href="https://docs.microsoft.com/ko-kr/azure/azure-resource-manager/resource-group-authoring-templates">템플릿의 구조와 구문</a>은 문서를 통해 확인 할 수 있다.</p>
<p><a href="https://github.com/Azure/azure-quickstart-templates">Gitbhu의 Azure Quick Start template 프로젝트</a>에 다양한 예제를 볼 수 있다.</p>
<p>또한 ARM 템플릿은 파라미터를 받을 수 있다. 파라미터로 VM이름 Admin ID 등을 받아서 Azure에 VM을 생성할 수 있다.</p>
<h2 id="azure_rm_deployment">azure_rm_deployment 모듈</h2>
<p><a href="http://docs.ansible.com/ansible/devel/modules/azure_rm_deployment_module.html?highlight=azure">azure_rm_deployment 모듈</a>은 ARM Template를 읽어와서 Azure에 배포해주는 모듈이다. 이 모듈에 ARM 템플릿의 위치를 알려주고 파라미터를 전달하면 Azure에 배포한다.</p>
<p><a href="https://github.com/ilseokoh/ansible-azure">Github</a>에 샘플코드를 올려놨다. 샘플 코드에 있는 ARM 템플릿은 Load Balancer, 두 개의 웹서버, 하나의 데이터 베이스 서버를 생성한다. <a href="https://github.com/ilseokoh/ansible-azure/blob/master/armtemplate/azuredeploy.json">azuredeploy.json</a>의 일부 코드를 살펴보자.</p>
<p>VM을 생성하는 부분에서 tags 도 붙여주는 것을 볼 수 있다. 이 tag를 이용해서 다이나믹 인벤토리 결과를 필터링 할 수 있다.</p>
<p>또한 Custom Script Extension을 이용하여 윈도우 머신에 WinRM을 설정하는 부분도 볼 수 있다. 이렇게 하면 VM이 생성되고 처음 부팅 될 때 <a href="https://github.com/ansible/ansible/blob/devel/examples/scripts/ConfigureRemotingForAnsible.ps1">ConfigureRemotingForAnsible.ps1</a> 파워쉘 스크립트가 실행되면서 WinRM을 설정해주기 때문에 Ansible로 관리할 수 있게 된다. 윈도우 머신의 경우 이렇게 설정해주면 되고 리눅스는 SSH로 연결하기 때문에 이 과정이 필요없다.</p>
<pre><code class="language-json">{
&quot;apiVersion&quot;: &quot;2016-04-30-preview&quot;,
&quot;type&quot;: &quot;Microsoft.Compute/virtualMachines&quot;,
&quot;name&quot;: &quot;[concat(parameters('vmNamePrefix'), copyindex())]&quot;,
&quot;copy&quot;: {
  &quot;name&quot;: &quot;virtualMachineLoop&quot;,
  &quot;count&quot;: &quot;[variables('numberOfInstances')]&quot;
},
&quot;tags&quot;: {
    &quot;service&quot;: &quot;web&quot;
},
&quot;location&quot;: &quot;[resourceGroup().location]&quot;,
&quot;dependsOn&quot;: [
  &quot;[concat('Microsoft.Storage/storageAccounts/', parameters('storageAccountName'))]&quot;,
  &quot;[concat('Microsoft.Network/networkInterfaces/', parameters('nicNamePrefix'), copyindex())]&quot;,
  &quot;[concat('Microsoft.Compute/availabilitySets/', variables('availabilitySetName'))]&quot;
],
&quot;resources&quot;: [
    {
        &quot;type&quot;: &quot;Microsoft.Compute/virtualMachines/extensions&quot;,
        &quot;name&quot;: &quot;[concat(concat(parameters('vmNamePrefix'), copyindex()), concat('/WinRMCustomScriptExtension', copyindex()))]&quot;,
        &quot;apiVersion&quot;: &quot;2016-04-30-preview&quot;,
        &quot;location&quot;: &quot;[resourceGroup().location]&quot;,
        &quot;dependsOn&quot;: [
          &quot;[concat('Microsoft.Compute/virtualMachines/', concat(parameters('vmNamePrefix'), copyindex()))]&quot;
        ],
        &quot;properties&quot;: {
          &quot;publisher&quot;: &quot;Microsoft.Compute&quot;,
          &quot;type&quot;: &quot;CustomScriptExtension&quot;,
          &quot;typeHandlerVersion&quot;: &quot;1.4&quot;,
          &quot;settings&quot;: {
            &quot;fileUris&quot;: [
              &quot;https://raw.githubusercontent.com/ansible/ansible/devel/examples/scripts/ConfigureRemotingForAnsible.ps1&quot;
            ],
            &quot;commandToExecute&quot;: &quot;powershell -ExecutionPolicy Unrestricted -file ConfigureRemotingForAnsible.ps1&quot;
          }
        }
    }
],
&quot;properties&quot;: {
  &quot;availabilitySet&quot;: {
    &quot;id&quot;: &quot;[resourceId('Microsoft.Compute/availabilitySets',variables('availabilitySetName'))]&quot;
  },
  &quot;hardwareProfile&quot;: {
    &quot;vmSize&quot;: &quot;[parameters('vmSize')]&quot;
  },
  &quot;osProfile&quot;: {
    &quot;computerName&quot;: &quot;[concat(parameters('vmNamePrefix'), copyIndex())]&quot;,
    &quot;adminUsername&quot;: &quot;[parameters('adminUsername')]&quot;,
    &quot;adminPassword&quot;: &quot;[parameters('adminPassword')]&quot;
  },
  &quot;storageProfile&quot;: {
    &quot;imageReference&quot;: {
      &quot;publisher&quot;: &quot;[parameters('imagePublisher')]&quot;,
      &quot;offer&quot;: &quot;[parameters('imageOffer')]&quot;,
      &quot;sku&quot;: &quot;[parameters('imageSKU')]&quot;,
      &quot;version&quot;: &quot;latest&quot;
    },
    &quot;osDisk&quot;: {
      &quot;createOption&quot;: &quot;FromImage&quot;
    }
  },
  &quot;networkProfile&quot;: {
    &quot;networkInterfaces&quot;: [
      {
        &quot;id&quot;: &quot;[resourceId('Microsoft.Network/networkInterfaces',concat(parameters('nicNamePrefix'),copyindex()))]&quot;
      }
    ]
  },
  &quot;diagnosticsProfile&quot;: {
    &quot;bootDiagnostics&quot;: {
      &quot;enabled&quot;: &quot;true&quot;,
      &quot;storageUri&quot;: &quot;[concat('http://',parameters('storageAccountName'),'.blob.core.windows.net')]&quot;
    }
  }
}
},
</code></pre>
<h2 id="arm">ARM 템플릿 배포</h2>
<p><a href="https://github.com/ilseokoh/ansible-azure/blob/master/ansible/roles/provision/tasks/main.yml">ARM 템플릿을 실행하는 Ansible 롤</a>을 살펴보자.</p>
<p>배포 지역과 리소스 그룹 이름을 지정하고 바로 파라미터가 나온다. ARM 템플릿에 정의되어 있는 파라미터를 이런식으로 전달 가능하다. ARM 템플릿은 azuredeploy.json 파일을 읽어서 json 포멧으로 붙인다. 그 표현식은 &quot;{{ lookup('file','../armtemplate/azuredeploy.json') | from_json }}&quot; 이다. 현재 플레이북의 상대적인 위치를 지정해서 가져올 수 있다.</p>
<p><a href="https://docs.ansible.com/ansible/2.5/plugins/lookup.html">lookup 과 같은 플러그인</a>을 이용하여 위치를 지정했다.</p>
<p>같은 플레이북에 Create와 Destroy가 같이 있으므로 tag 를 이용해서 구분해줬다.</p>
<pre><code class="language-yaml">---
# Create or update a template deployment based on uris using parameter and template links
- name: Create Azure Deploy
  azure_rm_deployment:
    state: present
    location: koreasouth
    resource_group_name: AnsibleVMGroup
    parameters:
      storageAccountName:
        value: &quot;avmstoragedig&quot;
      adminUsername: 
        value: &quot;ansibleuser&quot;
      adminPassword:
        value: &quot;Ansible!2345678&quot;
      dnsNameforLBIP:
        value: &quot;ansibleweb123&quot;
      vmNamePrefix: 
        value: &quot;WebVM&quot;
      lbName: 
        value: &quot;WebLB&quot;
      nicNamePrefix:
        value: &quot;webservernic&quot;
      publicIPAddressName: 
        value: &quot;WebPublicIP&quot;
      vnetName: 
        value: &quot;AnsibleVNet&quot;
      vmSize: 
        value: &quot;Standard_D2s_v3&quot;
    template: &quot;{{ lookup('file','../armtemplate/azuredeploy.json') | from_json }}&quot;
  tags:
    - create
  delegate_to: 127.0.0.1

# Destroy a template deployment
- name: Destroy Azure Deploy
  azure_rm_deployment:
    state: absent
    resource_group_name: AnsibleVMGroup
  tags:
    - destroy
  delegate_to: 127.0.0.1
</code></pre>
<p><a href="https://github.com/ilseokoh/ansible-azure">github</a>의 디렉토리 구조를 보면 위의 role 은 ansible/roles/tasks/main.yml 에 있고 실제 플레이북은 ansible/provision.yml 파일이다. 플레이북을 보면 hosts가 127.0.0.1로 표현되어 있는데 이는 Ansible 컨트롤 머신에서 실행되라는 얘기다. Azure에 VM을 만드는 과정은 특정 리모트 호스트와 관련이 없고 로컬에서 실행되면 되기 때문에 아래와 같이 hosts와 connection을 지정하면 된다.</p>
<pre><code class="language-yaml">---
- hosts: 127.0.0.1
  connection: local
  roles: 
    - role: provision
</code></pre>
<p>이 플레이북을 실행하면 아래와 같은 결과를 볼 수 있다.</p>
<p>ansible-playbook 명령을 실행할 때 생성 태스크만 실행되도록 --tags crate를 지정한다. 이 명령은 inventory가 필요없기 때문에 -i 옵션이 없다. 플레이북을 실행하면 실제 Azure에 3개의 VM과 Load Balancer 등이 만들어진다.</p>
<pre><code class="language-bash">$ cd ansible
$ ansible-playbook provision.yml --tags create
 [WARNING]: Unable to parse /etc/ansible/hosts as an inventory source

 [WARNING]: No inventory was parsed, only implicit localhost is available

 [WARNING]: Could not match supplied host pattern, ignoring: all

 [WARNING]: provided hosts list is empty, only localhost is available


PLAY [127.0.0.1] **************************************************

TASK [Gathering Facts] ********************************************************************
ok: [127.0.0.1]

TASK [provision : Create Azure Deploy] ******************************************************************
changed: [127.0.0.1 -&gt; 127.0.0.1]

PLAY RECAP *******************************************************
127.0.0.1                  : ok=2    changed=1    unreachable=0    failed=0
</code></pre>
<h2 id="static">Static 인벤토리로 실행</h2>
<p>provision.yml 에서 만든 윈도우 VM은 아무것도 설치되어 있지 않은 VM이다. 이제 VM에 웹서버, 데이터베이스 서버라는 역할을 할 수 있도록 설정해야 한다. <a href="https://github.com/ilseokoh/ansible-azure/blob/master/ansible/inventory.yml">inventory.yml</a> 에 생성된 VM의 IP를 넣어놓고 <a href="https://github.com/ilseokoh/ansible-azure/blob/master/ansible/webservers.yml">webserver.yml</a> 플레이북을 실행해보자.</p>
<p><a href="https://github.com/ilseokoh/ansible-azure/blob/master/ansible/group_vars/all.yml">ansible/group_vars/all.yml</a> 에 WinRM으로 접속을 위한 정보가 들어 있다.</p>
<p>webserver.yml 플레이북은 <a href="https://github.com/ilseokoh/ansible-azure/blob/master/ansible/roles/common/tasks/main.yml">common</a>, <a href="https://github.com/ilseokoh/ansible-azure/blob/master/ansible/roles/webserver/tasks/main.yml">webserver</a> 롤을 차례로 수행한다.</p>
<pre><code class="language-yaml">---
- hosts: web
  roles:
    - common
    - webserver 
</code></pre>
<p><a href="https://github.com/ilseokoh/ansible-azure/blob/master/ansible/roles/webserver/tasks/main.yml">ansible-azure/ansible/roles/webserver/tasks/main.yml</a></p>
<pre><code class="language-yaml">---
  - name: Ensure IIS webserver is installed
    win_feature:
      name: Web-Server
      state: present

  - name: Deploy default iisstart.htm file
    template:
      src: iisstart.j2
      dest: c:\inetpub\wwwroot\iisstart.htm

  - name: Ensure IIS service is running
    win_service: 
      name: W3SVC
      start_mode: auto
      state: started
</code></pre>
<p><a href="https://github.com/ilseokoh/ansible-azure/blob/master/ansible/roles/common/tasks/main.yml">ansible-azure/ansible/roles/common/tasks/main.yml</a></p>
<pre><code class="language-yaml">---
- name: Install Chocolatey
  win_shell: &quot;Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))&quot;
    
- name: Ensure .NET Framework 4.7.1 is installed using chocolatey
  win_chocolatey:
    name: dotnet4.7.1
    state: present
</code></pre>
<p>실행결과</p>
<pre><code>$ ansible-playbook -i inventory.yml webservers.yml

PLAY [web] *********************************************************************************************

TASK [Gathering Facts] *********************************************************************************
ok: [10.10.0.5]
ok: [10.10.0.4]

TASK [common : Install Chocolatey] *********************************************************************
changed: [10.10.0.5]
changed: [10.10.0.4]

TASK [common : Ensure .NET Framework 4.7.1 is installed using chocolatey] ******************************
ok: [10.10.0.4]
ok: [10.10.0.5]

TASK [webserver : Ensure IIS webserver is installed] ***************************************************
ok: [10.10.0.4]
ok: [10.10.0.5]

TASK [webserver : Deploy default iisstart.htm file] ****************************************************
ok: [10.10.0.4]
ok: [10.10.0.5]

TASK [webserver : Ensure IIS service is running] *******************************************************
ok: [10.10.0.4]
ok: [10.10.0.5]

PLAY RECAP *********************************************************************************************
10.10.0.4                  : ok=6    changed=1    unreachable=0    failed=0
10.10.0.5                  : ok=6    changed=1    unreachable=0    failed=0
</code></pre>
<h2 id="">다이나믹 인벤토리로 실행</h2>
<p>다이나믹 인벤토리로 Azure에 있는 VM들을 조회해서 플레이북을 실행할 수 있다. 다이나믹 인벤토리에 대해서는 <a href="http://ilseokoh.com/ansible-azure/">Ansible로 Azure 관리하기 #1 - Ansible 기초</a>에 나와있다.</p>
<p>실행 명령</p>
<pre><code>$ ansible-playbook -i azure_rm.py webserver_dynamic.yml

$ ansible-playbook -i azure_rm.py database_dynamic.yml
</code></pre>
<p>실행결과의 내용은 크게 다르지 않지만 Azure에 있는 VM들의 내용을 가져오기 위한 시간이 걸린다. 이 명령을 데이터베이스 서버가 설정 되었다.</p>
<p>여기까지 ARM 템플릿을 이용해서 Azure에 필요한 리소스들을 만들고 VM들을 만들었다. 고정된 서버를 운영한다면 Static 인벤토리를 이용하고 VM의 갯수가 늘었다 줄어다 하는 상황이면 다이나믹 인벤토리를 이용할 수 있다. Ansible을 실행해서 웹서버와 데이터베이스 서버를 설정 할 수 있었다.</p>
<h2 id="azure">Azure 다이나믹 인벤토리의 상세</h2>
<p>다이나믹 인벤토리의 실체는 파이썬으로 구현된 <a href="https://github.com/ansible/ansible/blob/devel/contrib/inventory/azure_rm.py">azure_rm.py</a>라는 파일이다. 이 파이썬 코드가 Azure 파이썬 SDK를 이용하여 Azure에 있는 VM들의 정보를 조회해서 인벤토리로 제공하는 것이다.</p>
<p>azure_rm.py를 사용할 대 수정한 부분이 있다. 다이나믹 인벤토리는 ansible_host라는 변수로 호스트 이름을 주는데 코드는 Publid IP를 주기로 되어 있다. 나는 Private IP로 받아서 내부 통신으로 수행하고 싶었기 때문에 아래처럼 코드를 수정했다. 수정한 부분은 줄번호 674이다.</p>
<pre><code class="language-python">host_vars['private_ip_alloc_method'] = ip_config.private_ip_allocation_method
host_vars['ansible_host'] = ip_config.private_ip_address
if ip_config.public_ip_address:
</code></pre>
<h3 id="azure_rmpy">azure_rm.py의 테스트</h3>
<p>azure_rm.py이 잘 작동하는지 테스트 할 수 있다.</p>
<pre><code>$ ./azure_rm.py --resource-groups=AnsibleVMGroup --pretty
{
  &quot;KoreaSouth&quot;: [
    &quot;DatabaseVM&quot;,
    &quot;WebVM0&quot;,
    &quot;WebVM1&quot;
  ],
  &quot;_meta&quot;: {
    &quot;hostvars&quot;: {
      &quot;DatabaseVM&quot;: {
        &quot;ansible_connection&quot;: &quot;winrm&quot;,
        &quot;ansible_host&quot;: &quot;10.10.1.4&quot;,
        &quot;computer_name&quot;: &quot;WebVMdatabase&quot;,
        &quot;fqdn&quot;: null,
        &quot;id&quot;: &quot;/subscriptions/e47f0bbb-cd59-41dc-86b7-2e239d536c04/resourceGroups/AnsibleVMGroup/providers/Microsoft.Compute/virtualMachines/DatabaseVM&quot;,
        &quot;image&quot;: {
          &quot;offer&quot;: &quot;WindowsServer&quot;,
...
</code></pre>
<p>테스트를 위한 상세 옵션은 azure_rm.py --help 명령으로 알 수 있다. 이 명령을 통해서 결과를 필터링 하는 방법을 테스트 해보면 좋다. 5가지 필터링을 제공한다. 리소스그룹 이름과 태그를 이용하는 것이 유용했다.</p>
<ul>
<li>전체</li>
<li>지역(Azure Region)</li>
<li>리소스그룹 이름</li>
<li>Security Group 이름(정확히 모르겠음)</li>
<li>태그 키 이름</li>
<li>태그 키_값</li>
<li>전원 상태</li>
</ul>
<h3 id="azure_rmini">azure_rm.ini</h3>
<p><a href="https://github.com/ilseokoh/ansible-azure/blob/master/ansible/azure_rm.ini">azure_rm.ini</a>는 다이나믹 인벤토리가 사용하는 파일인데 이 파일을 이용해서 다이나믹 인벤토리가 가져오는 VM리스트를 필터링 할 수 있다. 하지만 정적인 설정이기 때문에 불편할 수 있다. 동적으로 적용하기 위해서는 환경변수를 이용해야 하는데 Ansible 명령 앞에 환경변수를 설정하는 방법이 있다.</p>
<pre><code>$ AZURE_TAGS=service:database ansible-playbook -i azure_rm.py database_dynamic.yml
</code></pre>
<p>ansible-playbook을 실행하기전에 AZURE_TAGS를 설정하는 명령이다. 이렇게 사용할 수 있는 환경변수는 총 5가지다.</p>
<ul>
<li>AZURE_RESOURCE_GROUPS</li>
<li>AZURE_TAGS</li>
<li>AZURE_LOCATIONS</li>
<li>AZURE_TAGS</li>
<li>AZURE_INCLUDE_POWERSTATE</li>
</ul>
<p>정리하면 다이나믹 인벤토리를 실행할 때 전체 리스트가 아닌 선택된 VM 리스트를 가져오고 싶다면 azure_rm.ini에 5가지 필터링을 사용하거나 환경변수를 사용해서 필터링 할 수 있다.</p>
<h3 id="playbook">Playbook에서 필터링</h3>
<p>다이나믹 인벤토리가 가져온 리스트를 다시 Playbook에서 필터링 할 수 있다. hosts에 service_database라는 표현은 다이나믹 인벤토리가 가져온 리스트에서 태그가 service:database 인 호스트만 적용한다는 의미다.</p>
<pre><code class="language-yaml">---
# VMs that is tagged by service:database
- hosts: service_database
  roles:
    - common
    - database
</code></pre>
<p>hosts: azure 는 다이나믹 인벤토리가 가져오 호스트 전체를 의미한다.</p>
<h4 id="azuretag">Azure의 Tag를 잘 사용하면 쉽게 필터링을 할 수 있다.</h4>
<h2 id="">참고자료</h2>
<p><a href="https://github.com/erjosito/ansible-azure-lab">Azure+Ansible 따라하기</a><br>
<a href="https://docs.ansible.com/ansible/2.3/guide_azure.html">Ansible Azure 공식문서</a><br>
<a href="https://docs.microsoft.com/ko-kr/azure/ansible/ansible-overview">Azure의 Ansible 관련 문서</a><br>
<a href="https://channel9.msdn.com/Shows/Azure-Friday/Running-Ansible-on-Azure">채널 9 동영상</a></p>
</div>]]></content:encoded></item><item><title><![CDATA[Packer로 Azure VM 이미지 만들기 #1 - Packer 템플릿]]></title><description><![CDATA[<div class="kg-card-markdown"><h2 id="vm">VM 이미지 활용</h2>
<p>Azure의 VM은 이미지로 만들 수 있다. VM을 만들고 OS 설정과 내 애플리케이션을 배포한 다음 이미지로 만들 수 있다. 이 이미지로 부터 VM을 생성하면 똑같이 설정된 VM들을 계속 만들어 낼 수 있다. 또한 VMSS(Virtual Machine Scalce Set)을 사용할 때 VM 이미지가 필요하다. 하지만 VM 이미지를 생성하고</p></div>]]></description><link>http://ilseokoh.com/packer-azure-vm-image/</link><guid isPermaLink="false">5b1636bf86f74a0b4a3a8d10</guid><category><![CDATA[azure]]></category><dc:creator><![CDATA[오일석]]></dc:creator><pubDate>Tue, 05 Jun 2018 08:10:08 GMT</pubDate><media:content url="http://ilseokoh.com/content/images/2018/06/packer-azure-2.jpg" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><h2 id="vm">VM 이미지 활용</h2>
<img src="http://ilseokoh.com/content/images/2018/06/packer-azure-2.jpg" alt="Packer로 Azure VM 이미지 만들기 #1 - Packer 템플릿"><p>Azure의 VM은 이미지로 만들 수 있다. VM을 만들고 OS 설정과 내 애플리케이션을 배포한 다음 이미지로 만들 수 있다. 이 이미지로 부터 VM을 생성하면 똑같이 설정된 VM들을 계속 만들어 낼 수 있다. 또한 VMSS(Virtual Machine Scalce Set)을 사용할 때 VM 이미지가 필요하다. 하지만 VM 이미지를 생성하고 관리하는 작업은 어려운 점이 있다.</p>
<ol>
<li>이미지를 만드는 과정은 시간이 걸리고 반복적인 작업이다. 윈도우 서버의 경우 Sysprep 하고 Generalize 하고 Deallocation 하고 Capture 해야 한다. <a href="https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/capture-image-resource">Azure에서 일반화된 VM의 관리 이미지 만들기</a> 문서에 자세한 내용이 나와있다.</li>
<li><a href="https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/capture-image-resource">윈도우의 경우 Sysprep</a>, <a href="https://docs.microsoft.com/ko-kr/azure/virtual-machines/linux/capture-image">리눅스의 경우 sudo waagent -deprovision+user</a> 명령 때문에 전체를 자동화하기가 어렵다.</li>
<li>애플리케이션이 업데이트되거나 기본 이미지의 설정이 변경되면  이미지를 새로 만들어야 한다.</li>
<li>계속되는 이미지의 변경사항을 관리하기 어렵다.</li>
</ol>
<h2 id="packer">Packer로 이미지 만들기</h2>
<p>그런 어려운점을 해소하기 위한 방법으로  <a href="https://www.packer.io/">Packer</a>가 있다. Packer는 Json으로 작성하는 템플릿의 내용에 따라서 VM 이미지를 만든다. Azure 뿐만 아니라 AWS EC2, VMware, VirtualBox 등의 이미지를 만들 수 있고 자동화 할 수 있다.</p>
<p><a href="https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/build-image-with-packer">Azure에서 Packer를 사용하여 Windows 가상 머신 이미지를 만드는 방법</a> 문서에 자세한 내용이 나와있다. 이 문서를 그대로 따라하면 윈도우 서버 2016에 IIS 가 설치된 VM 이미지가 생성된다. 여기에 이미지의 설정이 변경되거나, 추가 툴을 설치하거나, 애플리케이션 배포가 필요하면 Provisioners 에 내용을 추가하면 된다. 이 Json 파일을 소스 관리하면서 변경을 관리하면 된다.</p>
<p>이 문서에서 고생하기 쉬운 부분이 하나 있는데 object_id 를 가져오는 부분이다. 여기서 말하는 object_id 는 Service Principle의 Object ID를 의미하지 않는다. 구독에 추가된 Service Priciple 권한의 Object ID를 의미한다. 아래 스크린샷을 보면 Azure 포탈에서 Object ID를 가져올 수 있다.</p>
<p>최신버전 Packer에서는 실행시 이런 설명을 출력한다. <em>&quot;You have provided Object_ID which is no longer needed, azure packer builder determines this dynamically from the authentication token&quot;</em> 따라서 Object ID는 없어도 될 것 같다.</p>
<p><img src="http://ilseokoh.com/content/images/2018/06/object-id.jpg" alt="Packer로 Azure VM 이미지 만들기 #1 - Packer 템플릿"></p>
<h2 id="packer">Packer로 기존에 만든 이미지에서 새로운 이미지 만들기</h2>
<p><a href="https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/build-image-with-packer">Azure에서 Packer를 사용하여 Windows 가상 머신 이미지를 만드는 방법</a> 문서의 템플릿은 Azure 마켓플레이스에 있는 Windows 2016 이미지로 부터 시작 한다. 이미 수동으로 만들어 놓은 이미지로 부터 새로운 이미지를 만들기 위해서는 조금만 수정하면 된다. &quot;image_publisher&quot;, &quot;image_offer&quot;, &quot;2016-Datacenter&quot; 대신에 &quot;custom_managed_image_resource_group_name&quot;, &quot;custom_managed_image_name&quot;를 쓰면 된다.<br>
custom_managed_image_resource_group_name는 기존 이미지가 들어 있는 리소스 그룹 이름, custom_managed_image_name은 만들어 놓은 이미지 이름을 넣어주면 된다.</p>
<pre><code class="language-json">{
    &quot;variables&quot;: {
        &quot;client_id&quot;: &quot;{{env `ARM_CLIENT_ID`}}&quot;,
        &quot;client_secret&quot;: &quot;{{env `ARM_CLIENT_SECRET`}}&quot;,
        &quot;tenant_id&quot;: &quot;{{env `ARM_TENANT_ID`}}&quot;,
        &quot;subscription_id&quot;: &quot;{{env `ARM_SUBSCRIPTION_ID`}}&quot;,
        &quot;object_id&quot;: &quot;{{env `ARM_OJBECT_ID`}}&quot;,
        &quot;custom_managed_image_resource_group_name&quot;: &quot;{{env `ARM_CUSTOM_IMAGE_RG_NAME`}}&quot;,
        &quot;custom_managed_image_name&quot;: &quot;{{env `ARM_CUSTOM_IMAGE_NAME`}}&quot;,
        &quot;image_name&quot;: &quot;base-image-{{isotime \&quot;2006-01-02\&quot;}}_{{isotime \&quot;03-04-05\&quot;}}&quot;
    },
    &quot;builders&quot;: [
        {
            &quot;type&quot;: &quot;azure-arm&quot;,

            &quot;client_id&quot;: &quot;{{user `client_id`}}&quot;,
            &quot;client_secret&quot;: &quot;{{user `client_secret`}}&quot;,
            &quot;tenant_id&quot;: &quot;{{user `tenant_id`}}&quot;,
            &quot;subscription_id&quot;: &quot;{{user `subscription_id`}}&quot;,
            &quot;object_id&quot;: &quot;{{user `object_id`}}&quot;,

            &quot;managed_image_resource_group_name&quot;: &quot;{{user `custom_managed_image_resource_group_name`}}&quot;,
            &quot;managed_image_name&quot;: &quot;{{user `image_name`}}&quot;, 

            &quot;azure_tags&quot;: {
                &quot;latest-image&quot;: &quot;true&quot;
            },

            &quot;location&quot;: &quot;Korea Central&quot;,
            &quot;vm_size&quot;: &quot;Standard_D2s_v3&quot;,

            &quot;os_type&quot;: &quot;Windows&quot;,
            &quot;custom_managed_image_resource_group_name&quot;: &quot;{{user `custom_managed_image_resource_group_name`}}&quot;,
            &quot;custom_managed_image_name&quot;: &quot;{{user `custom_managed_image_name`}}&quot;,

            &quot;communicator&quot;: &quot;winrm&quot;,
            &quot;winrm_use_ssl&quot;: &quot;true&quot;,
            &quot;winrm_insecure&quot;: &quot;true&quot;,
            &quot;winrm_timeout&quot;: &quot;3m&quot;,
            &quot;winrm_username&quot;: &quot;ansibleuser&quot;
        }
    ],
    &quot;provisioners&quot;: [ 
        {
            &quot;type&quot;: &quot;powershell&quot;, 
            &quot;script&quot;: &quot;./powershell/install-chocolatey.ps1&quot;
        },
        {
            &quot;type&quot;: &quot;powershell&quot;,
            &quot;inline&quot;: [
                &quot;if( Test-Path $Env:SystemRoot\\windows\\system32\\Sysprep\\unattend.xml ){ rm $Env:SystemRoot\\windows\\system32\\Sysprep\\unattend.xml -Force}&quot;,
                &quot;&amp; $env:SystemRoot\\System32\\Sysprep\\Sysprep.exe /oobe /generalize /quiet /quit&quot;,
                &quot;while($true) { $imageState = Get-ItemProperty HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\State | Select ImageState; if($imageState.ImageState -ne 'IMAGE_STATE_GENERALIZE_RESEAL_TO_OOBE') { Write-Output $imageState.ImageState; Start-Sleep -s 10  } else { break } }&quot;
            ]
        }
        ]
}
</code></pre>
<h2 id="chocolatey">윈도우 서버에서 Chocolatey 사용</h2>
<p>Windows 서버에 툴을 설치해야 하는 경우 <a href="https://chocolatey.org/">Chocolatey</a>를 사용하면 쉽게 스크립트로 설치 가능하다. Ubuntu에서 apt-get 처럼 choco install jre8 명령으로 JDK를 설치할 수 있다.</p>
<h2 id="">설정변수 파일</h2>
<p>설정변수는 커멘트의 파라미터로 넣어도 되고 variable.json 파일에 넣어도 된다.</p>
<pre><code class="language-language-json">{
    &quot;client_id&quot;: &quot;&lt;client_id&gt;&quot;,
    &quot;client_secret&quot;: &quot;&lt;client_secret&gt;&quot;,
    &quot;tenant_id&quot;: &quot;&lt;tenant_id&gt;&quot;,
    &quot;subscription_id&quot;: &quot;&lt;subscription_id&gt;&quot;,
    &quot;object_id&quot;: &quot;&lt;object_id&gt;&quot;,
    &quot;custom_managed_image_resource_group_name&quot;: &quot;&lt;resource group name&gt;&quot;
}
</code></pre>
<h2 id="">실행결과</h2>
<p>실행결과는 아래와 같다. 실행되는 중간에 Azure Portal을 보면 Packer가 만든 VM이 보이다가 완료되면 깨끗이 지운다. 새로만든 VM 이미지만 남는다. 실행전에 BaseImageVM-image-20180604165401 VM이미지가 이미 준비되어 있었다. Azure 마켓플레이스에 있는 기본 이미지를 사용하는 예제는 <a href="https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/build-image-with-packer">Azure에서 Packer를 사용하여 Windows 가상 머신 이미지를 만드는 방법</a> 에 있다.</p>
<pre><code>packer.exe build -var-file=.\variable.json -var custom_managed_image_name=BaseImageVM-image-20180604165401 .\bdm-baseimage.json
azure-arm output will be in this color.

==&gt; azure-arm: Running builder ...
    azure-arm: Creating Azure Resource Manager (ARM) client ...
    azure-arm: You have provided Object_ID which is no longer needed, azure packer builder determines this dynamically from the authentication token
==&gt; azure-arm: Creating resource group ...
==&gt; azure-arm:  -&gt; ResourceGroupName : 'packer-Resource-Group-73vfh7b6s2'
==&gt; azure-arm:  -&gt; Location          : 'Korea Central'
==&gt; azure-arm:  -&gt; Tags              :
==&gt; azure-arm:  -&gt;&gt; latest-image : true
==&gt; azure-arm: Validating deployment template ...
==&gt; azure-arm:  -&gt; ResourceGroupName : 'packer-Resource-Group-73vfh7b6s2'
==&gt; azure-arm:  -&gt; DeploymentName    : 'pkrdp73vfh7b6s2'
==&gt; azure-arm: Deploying deployment template ...
==&gt; azure-arm:  -&gt; ResourceGroupName : 'packer-Resource-Group-73vfh7b6s2'
==&gt; azure-arm:  -&gt; DeploymentName    : 'kvpkrdp73vfh7b6s2'
==&gt; azure-arm: Getting the certificate's URL ...
==&gt; azure-arm:  -&gt; Key Vault Name        : 'pkrkv73vfh7b6s2'
==&gt; azure-arm:  -&gt; Key Vault Secret Name : 'packerKeyVaultSecret'
==&gt; azure-arm:  -&gt; Certificate URL       : 'https://pkrkv73vfh7b6s2.vault.azure.net/secrets/packerKeyVaultSecret/31e1069f5e7849a2b444cdb49aca782c'
==&gt; azure-arm: Setting the certificate's URL ...
==&gt; azure-arm: Validating deployment template ...
==&gt; azure-arm:  -&gt; ResourceGroupName : 'packer-Resource-Group-73vfh7b6s2'
==&gt; azure-arm:  -&gt; DeploymentName    : 'pkrdp73vfh7b6s2'
==&gt; azure-arm: Deploying deployment template ...
==&gt; azure-arm:  -&gt; ResourceGroupName : 'packer-Resource-Group-73vfh7b6s2'
==&gt; azure-arm:  -&gt; DeploymentName    : 'pkrdp73vfh7b6s2'
==&gt; azure-arm: Getting the VM's IP address ...
==&gt; azure-arm:  -&gt; ResourceGroupName   : 'packer-Resource-Group-73vfh7b6s2'
==&gt; azure-arm:  -&gt; PublicIPAddressName : 'pkrip73vfh7b6s2'
==&gt; azure-arm:  -&gt; NicName             : 'pkrni73vfh7b6s2'
==&gt; azure-arm:  -&gt; Network Connection  : 'PublicEndpoint'
==&gt; azure-arm:  -&gt; IP Address          : '52.231.65.219'
==&gt; azure-arm: Waiting for WinRM to become available...
    azure-arm: #&lt; CLIXML
    azure-arm: WinRM connected.
    azure-arm: &lt;Objs Version=&quot;1.1.0.1&quot; xmlns=&quot;http://schemas.microsoft.com/powershell/2004/04&quot;&gt;&lt;Obj S=&quot;progress&quot; RefId=&quot;0&quot;&gt;&lt;TN RefId=&quot;0&quot;&gt;&lt;T&gt;System.Management.Automation.PSCustomObject&lt;/T&gt;&lt;T&gt;System.Object&lt;/T&gt;&lt;/TN&gt;&lt;MS&gt;&lt;I64 N=&quot;SourceId&quot;&gt;1&lt;/I64&gt;&lt;PR N=&quot;Record&quot;&gt;&lt;AV&gt;Preparing modules for first use.&lt;/AV&gt;&lt;AI&gt;0&lt;/AI&gt;&lt;Nil /&gt;&lt;PI&gt;-1&lt;/PI&gt;&lt;PC&gt;-1&lt;/PC&gt;&lt;T&gt;Completed&lt;/T&gt;&lt;SR&gt;-1&lt;/SR&gt;&lt;SD&gt; &lt;/SD&gt;&lt;/PR&gt;&lt;/MS&gt;&lt;/Obj&gt;&lt;Obj S=&quot;progress&quot; RefId=&quot;1&quot;&gt;&lt;TNRef RefId=&quot;0&quot; /&gt;&lt;MS&gt;&lt;I64 N=&quot;SourceId&quot;&gt;1&lt;/I64&gt;&lt;PR N=&quot;Record&quot;&gt;&lt;AV&gt;Preparing modules for first use.&lt;/AV&gt;&lt;AI&gt;0&lt;/AI&gt;&lt;Nil /&gt;&lt;PI&gt;-1&lt;/PI&gt;&lt;PC&gt;-1&lt;/PC&gt;&lt;T&gt;Completed&lt;/T&gt;&lt;SR&gt;-1&lt;/SR&gt;&lt;SD&gt; &lt;/SD&gt;&lt;/PR&gt;&lt;/MS&gt;&lt;/Obj&gt;&lt;/Objs&gt;
==&gt; azure-arm: Connected to WinRM!
==&gt; azure-arm: Provisioning with Powershell...
==&gt; azure-arm: Provisioning with powershell script: ./powershell/install-chocolatey.ps1
    azure-arm: Getting latest version of the Chocolatey package for download.
    azure-arm: Getting Chocolatey from https://chocolatey.org/api/v2/package/chocolatey/0.10.11.
    azure-arm: Downloading 7-Zip commandline tool prior to extraction.
    azure-arm: Extracting C:\Users\packer\AppData\Local\Temp\chocolatey\chocInstall\chocolatey.zip to C:\Users\packer\AppData\Local\Temp\chocolatey\chocInstall...
    azure-arm: Installing chocolatey on this machine
    azure-arm: Creating ChocolateyInstall as an environment variable (targeting 'Machine')
    azure-arm:   Setting ChocolateyInstall to 'C:\ProgramData\chocolatey'
    azure-arm: WARNING: It's very likely you will need to close and reopen your shell
    azure-arm:   before you can use choco.
    azure-arm: Restricting write permissions to Administrators
    azure-arm: We are setting up the Chocolatey package repository.
    azure-arm: The packages themselves go to 'C:\ProgramData\chocolatey\lib'
    azure-arm:   (i.e. C:\ProgramData\chocolatey\lib\yourPackageName).
    azure-arm: A shim file for the command line goes to 'C:\ProgramData\chocolatey\bin'
    azure-arm:   and points to an executable in 'C:\ProgramData\chocolatey\lib\yourPackageName'.
    azure-arm:
    azure-arm: Creating Chocolatey folders if they do not already exist.
    azure-arm:
    azure-arm: WARNING: You can safely ignore errors related to missing log files when
    azure-arm:   upgrading from a version of Chocolatey less than 0.9.9.
    azure-arm:   'Batch file could not be found' is also safe to ignore.
    azure-arm:   'The system cannot find the file specified' - also safe.
    azure-arm: chocolatey.nupkg file not installed in lib.
    azure-arm:  Attempting to locate it from bootstrapper.
    azure-arm: PATH environment variable does not have C:\ProgramData\chocolatey\bin in it. Adding...
    azure-arm: WARNING: Not setting tab completion: Profile file does not exist at
    azure-arm: 'C:\Users\packer\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1'.
    azure-arm: Chocolatey (choco.exe) is now ready.
    azure-arm: You can call choco from anywhere, command line or powershell by typing choco.
    azure-arm: Run choco /? for a list of functions.
    azure-arm: You may need to shut down and restart powershell and/or consoles
    azure-arm:  first prior to using choco.
    azure-arm: Ensuring chocolatey commands are on the path
    azure-arm: Ensuring chocolatey.nupkg is in the lib folder
==&gt; azure-arm: Provisioning with Powershell...
==&gt; azure-arm: Provisioning with powershell script: C:\Users\iloh\AppData\Local\Temp\packer-powershell-provisioner601613115
    azure-arm: IMAGE_STATE_COMPLETE
    azure-arm: IMAGE_STATE_UNDEPLOYABLE
    azure-arm: IMAGE_STATE_UNDEPLOYABLE
    azure-arm: IMAGE_STATE_UNDEPLOYABLE
    azure-arm: IMAGE_STATE_UNDEPLOYABLE
    azure-arm: IMAGE_STATE_UNDEPLOYABLE
    azure-arm: IMAGE_STATE_UNDEPLOYABLE
    azure-arm: IMAGE_STATE_UNDEPLOYABLE
    azure-arm: IMAGE_STATE_UNDEPLOYABLE
==&gt; azure-arm: Querying the machine's properties ...
==&gt; azure-arm:  -&gt; ResourceGroupName : 'packer-Resource-Group-73vfh7b6s2'
==&gt; azure-arm:  -&gt; ComputeName       : 'pkrvm73vfh7b6s2'
==&gt; azure-arm:  -&gt; Managed OS Disk   : '/subscriptions/e47f0bbb-cd59-41dc-86b7-2e239d536c04/resourceGroups/packer-Resource-Group-73vfh7b6s2/providers/Microsoft.Compute/disks/pkros73vfh7b6s2'
==&gt; azure-arm: Querying the machine's additional disks properties ...
==&gt; azure-arm:  -&gt; ResourceGroupName : 'packer-Resource-Group-73vfh7b6s2'
==&gt; azure-arm:  -&gt; ComputeName       : 'pkrvm73vfh7b6s2'
==&gt; azure-arm: Powering off machine ...
==&gt; azure-arm:  -&gt; ResourceGroupName : 'packer-Resource-Group-73vfh7b6s2'
==&gt; azure-arm:  -&gt; ComputeName       : 'pkrvm73vfh7b6s2'
==&gt; azure-arm: Capturing image ...
==&gt; azure-arm:  -&gt; Compute ResourceGroupName : 'packer-Resource-Group-73vfh7b6s2'
==&gt; azure-arm:  -&gt; Compute Name              : 'pkrvm73vfh7b6s2'
==&gt; azure-arm:  -&gt; Compute Location          : 'Korea Central'
==&gt; azure-arm:  -&gt; Image ResourceGroupName   : 'BaseImageGroup'
==&gt; azure-arm:  -&gt; Image Name                : 'base-image-2018-06-05_07-25-05'
==&gt; azure-arm:  -&gt; Image Location            : 'koreacentral'
==&gt; azure-arm: Deleting resource group ...
==&gt; azure-arm:  -&gt; ResourceGroupName : 'packer-Resource-Group-73vfh7b6s2'
==&gt; azure-arm:
==&gt; azure-arm: The resource group was created by Packer, deleting ...
==&gt; azure-arm: Deleting the temporary OS disk ...
==&gt; azure-arm:  -&gt; OS Disk : skipping, managed disk was used...
==&gt; azure-arm: Deleting the temporary Additional disk ...
==&gt; azure-arm:  -&gt; Additional Disk : skipping, managed disk was used...

==&gt; Builds finished. The artifacts of successful builds are:
--&gt; azure-arm: Azure.ResourceManagement.VMImage:

ManagedImageResourceGroupName: BaseImageGroup
ManagedImageName: base-image-2018-06-05_07-25-05
ManagedImageLocation: koreacentral
</code></pre>
<h2 id="">다른 관리툴과 연결</h2>
<p>Packer는 단일 바이너리 파일로 배포된다. Packer.exe 를 커멘트라인에서 실행한다. 위의 실행결과처럼 커멘드를 직접 실행해서 결과를 볼 수 있지만 앞뒤에 추가 작업이 필요한 경우 다른 배포툴, DevOps 툴과 함께 쓰면 좋다. <a href="http://ilseokoh.com/packer-vsts-azure">Packer로 Azure 이미지 만들기 #2 - VSTS와 Packer</a> 편에서 Visual Studio Team Service 에서 Packer를 사용한 사례를 알아보자.</p>
</div>]]></content:encoded></item><item><title><![CDATA[Ansible로 Azure 관리하기 #1 - Ansible 기초]]></title><description><![CDATA[<div class="kg-card-markdown"><p><a href="https://www.ansible.com/">Ansible</a>은 오픈소스 IT 자동화 툴이다. 커맨드 라인 기반으로 수십, 수백대의 서버를 관리할 수 있다. Ansible의 기본 구조와 개념을 알아보고 Azure의 VM들을 Ansible로 만들고 관리하는 방법에 대해서 살펴보자.</p>
<p><a href="http://ilseokoh.com/ansible-azure-2-provision/">Ansible로 Azure 관리하기 #2 - Provision</a></p>
<h2 id="azure">Azure에 시스템이 구축되면 ...</h2>
<p>Azure에 일단 시스템이 구축되어 돌아가기 시작하면 '모니터링'과 '시스템 운영 자동화' 두 가지가 생각난다.</p></div>]]></description><link>http://ilseokoh.com/ansible-azure/</link><guid isPermaLink="false">5b024eaa86f74a0b4a3a8cfa</guid><category><![CDATA[azure]]></category><dc:creator><![CDATA[오일석]]></dc:creator><pubDate>Mon, 21 May 2018 06:05:38 GMT</pubDate><media:content url="http://ilseokoh.com/content/images/2018/05/ansible-azure-logo.jpg" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><img src="http://ilseokoh.com/content/images/2018/05/ansible-azure-logo.jpg" alt="Ansible로 Azure 관리하기 #1 - Ansible 기초"><p><a href="https://www.ansible.com/">Ansible</a>은 오픈소스 IT 자동화 툴이다. 커맨드 라인 기반으로 수십, 수백대의 서버를 관리할 수 있다. Ansible의 기본 구조와 개념을 알아보고 Azure의 VM들을 Ansible로 만들고 관리하는 방법에 대해서 살펴보자.</p>
<p><a href="http://ilseokoh.com/ansible-azure-2-provision/">Ansible로 Azure 관리하기 #2 - Provision</a></p>
<h2 id="azure">Azure에 시스템이 구축되면 ...</h2>
<p>Azure에 일단 시스템이 구축되어 돌아가기 시작하면 '모니터링'과 '시스템 운영 자동화' 두 가지가 생각난다. 그 중에 운영 자동화를 Ansible을 이용해서 도움을 받을 수 있다. 물론 Azure 에서는 이미 Azure CLI, Azure PowerShell, ARM Template, Azure REST API와 SDK를 제공하고 있기 때문에 필요하면 bash, powershell, c#, node 등 여러가지 언어로 툴을 만들어 운영을 자동화 할 수 있다.</p>
<p>하지만 이렇게 시작하면 필요한 많은 툴을 직접 만들어야 하고 디버깅 해야하기 때문에 시간과 비용이 든다. 이미 누군가 필요한 것들을 만들어 놨다면 그걸 쓰는게 좋은 방법이다. Ansible, <a href="https://www.terraform.io/">Terraform</a>, <a href="https://www.chef.io/chef/">Chef</a>, <a href="https://saltstack.com/">SaltStack</a>등 이미 오픈소스 프로젝트가 진행되고 있다. 이 중에서 가장 적합한 툴을 선택해서 구축하면 된다. Ansible은 운영을 할 팀이 Linux, Bash, CLI 등에 익숙하다면 추천할 만 하다.</p>
<h2 id="ansible">Ansible의 특징</h2>
<blockquote>
<p>오픈소스 / 에이전트 설치 없음 / 데이터베이스 필요 없음 / 추가 SW 설치 없음</p>
</blockquote>
<h2 id="">시스템 요구사항</h2>
<p><img src="http://ilseokoh.com/content/images/2018/05/system-requirement.jpg" alt="Ansible로 Azure 관리하기 #1 - Ansible 기초"></p>
<p>Ansible 컨트롤 서버는 Linux 기반으로 Python이 설치되어 있어야 한다. 관리의 대상이 되는 리모트 서버는 Linux인 경우 SSH로 Windows의 경우 WinRM으로 컨트롤 하기 때문에 에이전트를 설치하지 않아도 되는 장점이 있다.</p>
<p>또한 Ansible 컨트롤 서버와 리모트 서버는 서로 통신이 가능한 네트워크에 있어야 한다. Azure의 경우 같은 가상네트워크에 있거나 다른 가상네트워크라면 VNet Peering 등의 방법으로 연결시켜줘야 한다.</p>
<h2 id="ansible">Ansible의 구조</h2>
<p><img src="http://ilseokoh.com/content/images/2018/05/ansible-arch.jpg" alt="Ansible로 Azure 관리하기 #1 - Ansible 기초"></p>
<p>Ansible의 구조는 그림과 같은데 3가지 용어를 알아야 한다.</p>
<h3 id="inventory">인벤토리(Inventory)</h3>
<p>인벤토리는 관리의 대상이 되는 시스템의 리스트를 말한다. 보통 텍스트 파일(ini 또는 yaml)파일에 시스템의 IP 또는 hostname을 쭉 적어놓는데 시스템들을 그룹핑해서 선택할 수 있도록 구조를 만들어준다.</p>
<pre><code>[webservers]
foo.example.com
bar.example.com

[dbservers]
one.example.com
two.example.com
three.example.com
</code></pre>
<pre><code class="language-yaml">all:
  hosts:
    mail.example.com:
  children:
    webservers:
      hosts:
        foo.example.com:
        bar.example.com:
    dbservers:
      hosts:
        one.example.com:
        two.example.com:
        three.example.com:
</code></pre>
<h3 id="module">모듈(Module)</h3>
<p>미리 구현되어 있는 모듈을 이용해서 필요한 작업을 만들 수 있다. 가장 간단한 <a href="http://docs.ansible.com/ansible/latest/modules/ping_module.html?highlight=ping">ping 모듈</a>은 리모트 서버에 접속해서 연결 결과를 알려주는 모듈이다.</p>
<h3 id="playbook">플레이북(Playbook)</h3>
<p>플레이북은 Ansible이 배포(deployment), 설정(configuration), 통합관리(orchestration)를 표현하는 언어다. YAML 파일로 표현하며 모듈을 사용해서 여러개의 태스크를 순서에 의해 수행할 수 있도록 작성한다.</p>
<pre><code class="language-yaml">--
- hosts: webservers
  vars:
    http_port: 80
    max_clients: 200
  remote_user: root
  tasks:
  - name: ensure apache is at the latest version
    yum:
      name: httpd
      state: latest
  - name: write the apache config file
    template:
      src: /srv/httpd.j2
      dest: /etc/httpd.conf
    notify:
    - restart apache
  - name: ensure apache is running (and enable it at boot)
    service:
      name: httpd
      state: started
      enabled: yes
</code></pre>
<p>예제에서 보면 hosts: webservers 는 inventory 파일에 기술되어 있는 webservers 호스트들에게 yum 이라는 모듈을 이용하여 httpd 를 설치하고 template 이라는 모듈로 httpd.conf를 만들어서 복사하고 Service라는 모듈로 apache를 시작한다.</p>
<p>모듈, 인벤토리, 플레이북에 기술된 내용이 Python으로 만들어진 Ansible을 통해 해석되어 Linux 는 SSH로, Windows는 WinRM으로 명령을 전송하여 리모트의 서버에 작업을 수행하게 되어 있다.</p>
<p>그 외에 Playbook 작성을 좀 더 구조적으로 할 수 있도록 Roles, Vars 라는 개념도 알고 있으면 좋은데 <a href="https://www.ansible.com/resources/get-started">Ansible 시작하기</a> 문서, 비디오 등을 활용해서 스터디 하면 된다.</p>
<h2 id="">설치</h2>
<p>Linux 배포판 마다 설치하는 방법이 <a href="http://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#basics-what-will-be-installed">설치 가이드 문서</a>에 기술되어 있다.</p>
<h2 id="azure">Azure를 위한 내용</h2>
<p>Azure를 위한 추가적인 내용은 <a href="http://docs.ansible.com/ansible/latest/scenario_guides/guide_azure.html">Microsoft Azure 가이드</a> 문서에 나와 있다.</p>
<p>Azure에 VM을 만들고 관리를 하기 위해서는 인증을 해야 하는데 Azure Service Priciple을 통해서 할 수 있다. <a href="https://docs.microsoft.com/ko-kr/azure/azure-resource-manager/resource-group-create-service-principal-portal">포털을 사용하여 리소스에 액세스할 수 있는 Azure Active Directory 응용 프로그램 및 서비스 주체 만들기</a> 문서를 따라하면 Azure 포탈에서 만들 수 있다.</p>
<p>Service Principle을 만들었다면 4가지 값을 복사하여 $HOME/.azure/credentials 파일을 만들어서 저장한다.</p>
<pre><code>[default]
subscription_id=xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
client_id=xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
secret=xxxxxxxxxxxxxxxxx
tenant=xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
</code></pre>
<p>이렇게 준비가 되면 <a href="http://docs.ansible.com/ansible/latest/modules/azure_rm_virtualnetwork_module.html">azure_rm_virtualnetwork</a>, azure_rm_storageaccount 등의 모듈을 이용하여 VM, 스토리지 등 Azure에 필요한 리소스를 만들 수 있다.</p>
<p>VM을 만드는 플레이북을 예로 들면 아래와 같다.</p>
<pre><code class="language-yaml">- name: Create virtual machine
  azure_rm_virtualmachine:
    resource_group: Testing
    name: testvm001
    vm_size: Standard_D1
    storage_account: testaccount001
    storage_container: testvm001
    storage_blob: testvm001.vhd
    admin_username: admin
    admin_password: Password!
    network_interfaces: testnic001
    image:
      offer: CentOS
      publisher: OpenLogic
      sku: '7.1'
      version: latest
</code></pre>
<p>이렇게 Azure에 Linux VM을 만들고 아파치를 설치하고 설정파일을 복사해서 웹서버 용 VM을 Ansible을 이용하여 만들 수 있다.</p>
<h2 id="dynamicinventory">다이나믹 인벤토리(Dynamic Inventory)</h2>
<p>Azure와 같은 Cloud 환경에서는 VM들이 쉽게 만들어지고 사라진다. 이런 환경에서는 인벤토리를 파일로 가지고 있으면 변경될 때마다 매번 파일을 수정해줘야 하는데 좋은 방법이 아니다. Ansible은 이런 상황을 위해서 <a href="http://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html#intro-dynamic-inventory">다이나믹 인벤토리라는 개념</a>을 가지고 있다. Azure도 다이나믹 인벤토리가 있는데 <a href="https://github.com/ansible/ansible/blob/devel/contrib/inventory/azure_rm.py">azure_rm.py</a> 라는 파이썬 코드가 Azure API를 통해서 호스트 정보를 조회해서 인벤토리로 활용하는 방법이다.</p>
<p>자세한 내용이 <a href="http://docs.ansible.com/ansible/latest/scenario_guides/guide_azure.html#dynamic-inventory-script">Azure 문서</a>에 기술되어 있다. 전체 VM을 가져오거나 특정 지역, 리소스 그룹, 태그를 이용해서 VM의 리스트를 조회할 수 있고 다시 플레이북에서 필터링 해서 원하는 VM 리스트에 태스크를 수행 할 수 있도록 구성할 수 있다.</p>
<p>다이나믹 인벤토리를 사용하는 부분이 문서화가 덜 되어 있고 Azure와 관련해서 많이 사용하기 때문에 <a href="http://ilseokoh.com/ansible-azure-2-provision/">2편 Provision</a>에서 좀 더 자세한 사용법을 알아보자.</p>
<h2 id="">자료</h2>
<p><a href="http://ansible.com/get-started">http://ansible.com/get-started</a></p>
<p>Pluralsight Lectures(유료): <a href="https://app.pluralsight.com/library/courses/ansible-windows-getting-started/table-of-contents">Hands-on Ansible Getting Started with Ansible on Windows</a></p>
<p>Ansible docs:<a href="http://docs.ansible.com/ansible/latest/scenario_guides/guide_azure.html">Microsoft Azure Guide</a></p>
<p>github sample code: <a href="https://github.com/ilseokoh/ansible-azure">https://github.com/ilseokoh/ansible-azure</a></p>
<p><a href="http://docs.ansible.com/ansible/devel/modules/azure_rm_deployment_module.html?highlight=azure">Ansible ‘azure_rm_deployment’ Module</a></p>
<p><a href="http://docs.ansible.com/ansible/latest/intro_dynamic_inventory.html">Azure Dynamic Inventory</a> <a href="https://github.com/ansible/ansible/blob/devel/contrib/inventory/azure_rm.py">azure_rm.py</a></p>
</div>]]></content:encoded></item><item><title><![CDATA[WordPress에서 Ghost로 블로그 마이그레이션]]></title><description><![CDATA[<div class="kg-card-markdown"><p>ilseokoh.com 블로그는 그동안 WordPress로 운영되었다. Azure Web App + MySQL in App을 조합해서 사용중이었고 안정적으로 잘 운영을 하고 있었다. 하지만 Node.js 기반의 Ghost 플랫폼이 눈에 들어와서 살펴보다가 깔끔함과 Markdown의 사용에 끌려 마이그레이션을 했다. 그 고생 담을 적어 보았다.</p>
<h2 id="azurewebapponlinux">Azure Web App on Linux 설치</h2>
<p>Ghost를 Azure Web App on</p></div>]]></description><link>http://ilseokoh.com/wordpress-to-ghost-blog-migration/</link><guid isPermaLink="false">5ad3f1fd9664d93d47b6bc5c</guid><category><![CDATA[azure]]></category><dc:creator><![CDATA[오일석]]></dc:creator><pubDate>Mon, 16 Apr 2018 02:06:52 GMT</pubDate><media:content url="http://ilseokoh.com/content/images/2018/04/wordpress-to-ghost-1.jpg" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><img src="http://ilseokoh.com/content/images/2018/04/wordpress-to-ghost-1.jpg" alt="WordPress에서 Ghost로 블로그 마이그레이션"><p>ilseokoh.com 블로그는 그동안 WordPress로 운영되었다. Azure Web App + MySQL in App을 조합해서 사용중이었고 안정적으로 잘 운영을 하고 있었다. 하지만 Node.js 기반의 Ghost 플랫폼이 눈에 들어와서 살펴보다가 깔끔함과 Markdown의 사용에 끌려 마이그레이션을 했다. 그 고생 담을 적어 보았다.</p>
<h2 id="azurewebapponlinux">Azure Web App on Linux 설치</h2>
<p>Ghost를 Azure Web App on Linux에 설치하려 했으나 Ghost CLI 사용이 어색하고 소스에서 배포 하자니 Ghost 내부 사정을 잘 알아야 해서 복잡했다. 대신 <a href="https://ourwayoflyf.com/ghost-v1-0-on-app-service-linux/">Azure Web App on Linux의 컨테이너 배포 방법이 잘 설명되어 있는 글</a>이 있어서 이걸 참조하면 컨테이너에 배포 할 수 있다. MySQL도 최근 정식 출시된 <a href="https://azure.microsoft.com/ko-kr/services/mysql/">Azure database for MySQL</a>을 사용할 수 있다. 이렇게 되니 비용이 많이 드는 단점이 있다. 제일 싼 VM을 단일 인스턴스로 운영하기로 결정했다.</p>
<h2 id="vmghost">VM에 Ghost 설치하기</h2>
<p>먼저 Azure에 Ubuntu linux 16.04 VM을 만들었다. 그리고 <a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-ghost-on-ubuntu-16-04">How To Install and Configure Ghost on Ubuntu 16.04</a> 문서의 내용을 따라서 설치 했다. ghost CLI로 설정까지 쉽게 진행이 되었다.</p>
<ol>
<li>Node.js 설치</li>
<li>Nginx 설치</li>
<li>MySQL 설치</li>
<li>Ghost CLI로 Ghost 설치</li>
</ol>
<p>설치와 설정이 완료되기 전에 현재 운영중인 도메인을 변경하지 못하기 때문에 <a href="http://mingu.kr/74">맥에서 hosts 파일을 변경</a>해서 접속 할 수 있다.</p>
<h2 id="wpghost">WP Ghost 플러그인 사용은 실패</h2>
<p>마이그레이션 관련 내용을 찾아보면 <a href="https://www.ghostforbeginners.com/migrating-your-wordpress-blog-to-ghost/">How to Migrate from WordPress to Ghost</a>라는 글이 찾아지는데 Wordpress Ghost 플러그인을 사용하는 방법인데 이유는 모르겠지만 Export한 결과 json파일에 포스트 본문이 짤려서 들어가는 문제가 있다. 본문 내용도 한글이 유니코드 표현형식인 /u 로 시작하는 코드로 만들어지는데 가져왔을 때 한글 표현을 정상이지만 내용 자체가 잘려 있어 사용할 수가 없었다.</p>
<h2 id="">이미지 복사</h2>
<p>Wordpress의 /wp-content/uploads 폴더의 내용을 Ghost의 /content/images로 복사하는 작업이 필요하다. <a href="https://docs.microsoft.com/ko-kr/azure/app-service/app-service-deploy-ftp">Azure Web App에 FTP로 접속</a>해서 다운로드 받고 <a href="https://zetawiki.com/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_scp_%EC%82%AC%EC%9A%A9%EB%B2%95">scp</a>로 Ghost VM에 업로드 했다.</p>
<h2 id="wp2ghost">wp2ghost 사용</h2>
<p>wp에서 <a href="http://mainia.tistory.com/3337">백업용 xml파일을 내보내기</a> 할 수 있다. 이 xml 파일을 Ghost용 json으로 변경해주는 소스가 여러가지가 있다. 그 중에 <a href="https://github.com/jonhoo/wp2ghost">Github wp2ghost</a>프로젝트를 이용해서 json으로 변경했다.</p>
<pre><code class="language-bash">$ node bin/wp2ghost.js wordpress.2018-04-15.xml &gt; ghost.json
</code></pre>
<p>변환은 잘 되었는데 여기에도 문제가 두가지가 있다. 먼저 본문이 markdown으로 변환되지 않아서 html이 그대로 들어있다. 이걸 그대로 사용하니까 스타일과 이미지의 width height가 적용되어서 본문이 깨진다.또한 애써 만든 WP의 대표이미지가 없다.</p>
<h2 id="html2markdown">html2markdown으로 본문 변환 및 대표이미지 살리기</h2>
<p>Node.js 코드를 작성해서 wp2ghost에서 변환한 json파일의 본문을 html2markdown을 사용해서 변환하고 동시에 WP Ghost 플러그인에서 내보내기 한 json파일에서 대표 이미지 링크를 가져와서 새로운 json파일을 만들었다. 전체 내용은 Github <a href="https://github.com/ilseokoh/wp2ghost">ilseokoh/wp2ghost</a> 참조.</p>
<pre><code class="language-javascript">var fs = require('fs');
var html2md = require('html-markdown');
var ghost = require('./wp2ghost.json');
var plugin = require('./wp2ghost_export_1523785447.json')

ghost.data.posts.forEach((post,index) =&gt; { 
    console.log(post.id);
    var idnum = post.id;

    // Covert html to markdown 
    post.markdown = html2md.html2mdFromString(post.markdown);
    
    // Get image from wp ghost export file
    var pickedobj = plugin.data.posts.find(o =&gt; o.id === idnum);
    post.image = pickedobj.image;
});

let data = JSON.stringify(ghost);  
fs.writeFileSync('ghost_migration.json', data);  
</code></pre>
<p>이렇게 내보내기와 변환을 거쳐 만든 json파일을 Ghost에 Import Content라는 Admin 메뉴를 통해서 밀어 넣어 완료했다.</p>
<h3 id="ghostcodeinjection">Ghost Code Injection</h3>
<p>기본 테마인 Casper를 사용하니 폰트가 맘에 들지 않았다. 폰트를 변경하고 Google Analytics를 붙이는 코드를 추가했다.</p>
<pre><code class="language-markup">&lt;link href='http://fonts.googleapis.com/earlyaccess/nanumgothic.css' rel='stylesheet' type='text/css'&gt;
&lt;style&gt;
body,  
h1, h2, h3, h4, h5, h6,  
.main-nav a,
.subscribe-button,
.page-title,
.post-meta,
.read-next-story .post:before,
.pagination,
.site-footer,
.post-full-content,
.post-card-excerpt,
[class^=&quot;icon-&quot;]:before, [class*=&quot; icon-&quot;]:before {
    font-family:&quot;Nanum Gothic&quot;, sans-serif;
}
&lt;/style&gt;
&lt;script async src=&quot;https://www.googletagmanager.com/gtag/js?id=UA-91123456-1&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-91123456-1');
&lt;/script&gt;
</code></pre>
<h2 id="a">도메인 A 레코드 변경</h2>
<p>Azure의 <a href="https://docs.microsoft.com/ko-kr/azure/virtual-network/virtual-network-deploy-static-pip-arm-portal">Public IP를 고정</a>으로 변경하고 DNS A레코드를 변경했다. 몇 시간 지난 후 정상적으로 도메인이 이전되어 마무리 되었다.</p>
<p>더 좋은 방법이 있을 텐데 코드까지 짜는 고생을 했다.</p>
</div>]]></content:encoded></item><item><title><![CDATA[Azure Linux VM 계정 추가]]></title><description><![CDATA[<div class="kg-card-markdown"><h4 id="azurelinuxvm">Azure Linux VM 계정 추가</h4>
<p>Azure Linux VM 생성할 때 계정하나를 만들면서 VM을 생성합니다. 이 계정으로 SSH 접속할 수 있고 sudo 로 루트가 필요한 명령을 수행할 수 있습니다.  마치 사용자를 추가할 수 없을 것 같은 생각이 들 수도 있지만 여기에 여러 사람이 동시 작업을 해야할 필요가 있을 때 계정를 추가할</p></div>]]></description><link>http://ilseokoh.com/azure-linux-vm-add-user/</link><guid isPermaLink="false">5ad354a2f590390ca1a067f5</guid><category><![CDATA[azure]]></category><dc:creator><![CDATA[오일석]]></dc:creator><pubDate>Thu, 21 Dec 2017 08:43:49 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><h4 id="azurelinuxvm">Azure Linux VM 계정 추가</h4>
<p>Azure Linux VM 생성할 때 계정하나를 만들면서 VM을 생성합니다. 이 계정으로 SSH 접속할 수 있고 sudo 로 루트가 필요한 명령을 수행할 수 있습니다.  마치 사용자를 추가할 수 없을 것 같은 생각이 들 수도 있지만 여기에 여러 사람이 동시 작업을 해야할 필요가 있을 때 계정를 추가할 수 있습니다. 특별한건 아니고 리눅스의 adduser 명령입니다.</p>
<pre><code class="language-bash"># 계정생성.
$ sudo adduser ilseokoh

# sudo 사용 가능하도록 sudo 그룹에 추가
$ sudo adduser ilseokoh sudo

# 비밀번호 생성 
$ sudo passwd ilseokoh
</code></pre>
<h4 id="root">root 계정은 어디있나?</h4>
<p>Azure 에서 생성되는 Linux VM에는 root 계정이 비활성화 되어 있습니다. sudo 를 사용하면 되는데 추천하지 않지만 굳이 root를 살려야 하면 이렇게 하면 됩니다. 그러면 su 가 됩니다.</p>
<pre><code class="language-bash">$ sudo passwd -u root
$ sudo passwd root 
$ su
</code></pre>
</div>]]></content:encoded></item><item><title><![CDATA[Azure CLI로 Azure 리소스를 태그로 검색해서 NSG 룰 추가]]></title><description><![CDATA[<div class="kg-card-markdown"><p>Azure 에서 사용하는 모든 리소스에 태그를 걸어 둘 수 있다. Key=value 쌍의 태그를 걸어놓고 사용할 수 있는데 Azure Portal에서는 태그 메뉴에서 추가할 수 있다.</p>
<p><a href="http://ilseokoh.com/content/images/2017/12/azure-portal-tag.jpg"><img src="http://ilseokoh.com/content/images/2017/12/azure-portal-tag.jpg" alt=""><br>
</a></p>
<p>이 태그를 잘 정의해 놓으면 스크립트에서 태그로 검색해서 관련된 리소스만 가져와서 특정 작업을 할 수 있다. 여기에 소개된스크립트에서는 ServerType=GameServer 태그가 들어 있는 Network Security</p></div>]]></description><link>http://ilseokoh.com/azure-cli-find-nsg-add-rule/</link><guid isPermaLink="false">5ad354a2f590390ca1a067f4</guid><category><![CDATA[azure]]></category><dc:creator><![CDATA[오일석]]></dc:creator><pubDate>Tue, 19 Dec 2017 04:24:26 GMT</pubDate><media:content url="http://ilseokoh.com/content/images/2017/12/azure-tag.jpg" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><img src="http://ilseokoh.com/content/images/2017/12/azure-tag.jpg" alt="Azure CLI로 Azure 리소스를 태그로 검색해서 NSG 룰 추가"><p>Azure 에서 사용하는 모든 리소스에 태그를 걸어 둘 수 있다. Key=value 쌍의 태그를 걸어놓고 사용할 수 있는데 Azure Portal에서는 태그 메뉴에서 추가할 수 있다.</p>
<p><a href="http://ilseokoh.com/content/images/2017/12/azure-portal-tag.jpg"><img src="http://ilseokoh.com/content/images/2017/12/azure-portal-tag.jpg" alt="Azure CLI로 Azure 리소스를 태그로 검색해서 NSG 룰 추가"><br>
</a></p>
<p>이 태그를 잘 정의해 놓으면 스크립트에서 태그로 검색해서 관련된 리소스만 가져와서 특정 작업을 할 수 있다. 여기에 소개된스크립트에서는 ServerType=GameServer 태그가 들어 있는 Network Security Group을 찾아서 방화벽 룰을 추가한다. Azure CLI 로 작성되었다.</p>
<pre><code class="language-bash">#!/bin/bash

# tag query 
tagQuery=ServerType=GameServer

# new rule
ruleName=http
description=http-inbound
access=Allow
protocol=Tcp
direction=Inbound
priority=102
sourceAddressPrefix=*
sourcePortRange=*
destinationAddressPrefix=*
destinationPortRange=443

az resource list --tag $tagQuery --query &quot;[].{Name: name,Group: resourceGroup}&quot; -o tsv | 
while read -r name resourceGroup; do
    printf &quot;Add new rule&quot;
    az network nsg rule create -g $resourceGroup --nsg-name $name \
    --name $ruleName \
    --description $description \
    --access $access \
    --protocol $protocol  \
    --direction $direction \
    --priority $priority \
    --source-address-prefix &quot;$sourceAddressPrefix&quot; \
    --source-port-range &quot;$sourcePortRange&quot; \
    --destination-port-range &quot;$destinationPortRange&quot; \
    --destination-address-prefix &quot;$destinationAddressPrefix&quot;
    

    printf &quot;NSG: $name, ResourceGroup: $resourceGroup&quot;
    az network nsg show -g $resourceGroup -n $name --query 'securityRules[].{Name:name,Desc:description,Access:access,Direction:direction,DestPortRange:destinationPortRange,DestAddrPrefix:destinationAddressPrefix,SrcPortRange:sourcePortRange,SrcAddrPrefix:sourceAddressPrefix}' -o table
done
</code></pre>
<p>실행결과</p>
<pre><code class="language-bash">$ ./add-nsg-rule.sh
{
  &quot;access&quot;: &quot;Allow&quot;,
  &quot;description&quot;: &quot;http-inbound&quot;,
  &quot;destinationAddressPrefix&quot;: &quot;*&quot;,
  &quot;destinationAddressPrefixes&quot;: [],
  &quot;destinationApplicationSecurityGroups&quot;: null,
  &quot;destinationPortRange&quot;: &quot;443&quot;,
  &quot;destinationPortRanges&quot;: [],
  &quot;direction&quot;: &quot;Inbound&quot;,
  &quot;etag&quot;: &quot;W/\&quot;123427a1-855a-441b-8a79-4950326c043c\&quot;&quot;,
  &quot;id&quot;: &quot;/subscriptions/12345bbb-cd59-41dc-86b7-2e239d536c04/resourceGroups/KaliGroup/providers/Microsoft.Network/networkSecurityGroups/KaliVM-nsg/securityRules/http&quot;,
  &quot;name&quot;: &quot;http&quot;,
  &quot;priority&quot;: 102,
  &quot;protocol&quot;: &quot;Tcp&quot;,
  &quot;provisioningState&quot;: &quot;Succeeded&quot;,
  &quot;resourceGroup&quot;: &quot;KaliGroup&quot;,
  &quot;sourceAddressPrefix&quot;: &quot;*&quot;,
  &quot;sourceAddressPrefixes&quot;: [],
  &quot;sourceApplicationSecurityGroups&quot;: null,
  &quot;sourcePortRange&quot;: &quot;*&quot;,
  &quot;sourcePortRanges&quot;: []
}
NSG: KaliVM-nsg, ResourceGroup: Kali
GroupName               Access    Direction      DestPortRange  DestAddrPrefix    SrcPortRange    SrcAddrPrefix    Desc
-----------------  --------  -----------  ---------------  ----------------  --------------  ---------------  ------------
default-allow-ssh  Allow     Inbound                   22  *                 *               *
Port_3389          Allow     Inbound                 3389  *                 *               *
http               Allow     Inbound                  443  *                 *               *                http-inbound
</code></pre>
</div>]]></content:encoded></item><item><title><![CDATA[Azure Planned Maintenance 리부팅 동반]]></title><description><![CDATA[<div class="kg-card-markdown"><p>Azure Planned Maintenance(계획된 유지 관리)가 계획되어 있습니다. VM을 사용해서 서비스하고 있는 팀은 살펴볼 필요가 있습니다. 아래 날짜들은 변경될 가능성이 있습니다.</p>
<h4 id="plannedmaintenance">Planned Maintenance(계획된 유지 관리)에 대하여</h4>
<p>Azure에서 사용하는 VM은 가상환경으로 Host 인프라 위에서 만들어지고 관리됩니다. Host 인프라의 안정성, 보안을 향상시키기 위해서 주기적으로 업데이트를 합니다. Host OS에 보안</p></div>]]></description><link>http://ilseokoh.com/azure-planned-maintenance/</link><guid isPermaLink="false">5ad354a2f590390ca1a067f3</guid><category><![CDATA[azure]]></category><dc:creator><![CDATA[오일석]]></dc:creator><pubDate>Fri, 15 Dec 2017 09:22:37 GMT</pubDate><media:content url="http://ilseokoh.com/content/images/2017/12/planned-maintenance.png" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><img src="http://ilseokoh.com/content/images/2017/12/planned-maintenance.png" alt="Azure Planned Maintenance 리부팅 동반"><p>Azure Planned Maintenance(계획된 유지 관리)가 계획되어 있습니다. VM을 사용해서 서비스하고 있는 팀은 살펴볼 필요가 있습니다. 아래 날짜들은 변경될 가능성이 있습니다.</p>
<h4 id="plannedmaintenance">Planned Maintenance(계획된 유지 관리)에 대하여</h4>
<p>Azure에서 사용하는 VM은 가상환경으로 Host 인프라 위에서 만들어지고 관리됩니다. Host 인프라의 안정성, 보안을 향상시키기 위해서 주기적으로 업데이트를 합니다. Host OS에 보안 업데이트나 기능 업그레이드, 펌웨어 업데이트 등의 업데이트가 있습니다. 이런 Planned Maintenance는 두가지 종류가 있습니다.</p>
<pre><code>- **리부팅 없는 Planned Maintenance:** VM을 리부팅 하지 않아도 되는 업데이트입니다. 업데이트가 실행되면 몇 초 동안 VM이 멈추고(Freezing) 호스트 업데이트가 끝나면 바로 작동합니다. 최대 시간은 30초라고 되어 있는데 보통 5-15초 정도의 임팩트가 있습니다. 따라서 정말 중요한 워크로드(Mission Critical Workload)가 아니면 신경쓰지 않아도 자연스럽게 지나갈 수 있습니다. 여기서 그냥 지나가려면 리트라이(Retry) 로직이 중요할 수 있습니다. 예를들어 15초 멈춘다 해도 설정에 따라 Database 커넥션이 끊어지거나 TCP 커넥션이 끊어질 수 있습니다. 이때 애플리케이션의 Retry 로직이 작동하여 문제없이 다시 커넥션할 수 있어야 합니다.
- **리부팅을 동반하는 Planned Maintenance**: VM 리부팅을 동반하는 업데이트 입니다. 신경써서 관리해야합니다. 이런 Planned Maintenance 는 공지도 나오고 알림도 받을 수 있습니다.
</code></pre>
<p>이번 Planned Maintenance 는 리부팅을 동반하는 업데이트 입니다. 지난 2016년 봄에 한번 있었고 이번에 또 계획되어 있습니다. Azure 팀은 일년에 한번 이하로 발생하도록 목표를 잡고 있습니다. 이번 Planned Maintenance 의 상세 내용에 설명 합니다.</p>
<h4 id="plannedmaintenance">이번 Planned Maintenance 는</h4>
<pre><code>- **리부팅 됩니다**. (정확히는 Redeploy )
- **몇 분** 걸릴 수도 있습니다.
- Host OS를 Windows Server 2016으로 업데이트 합니다. 여기서 Host OS와 내 VM의 OS가 헷갈리면 안됩니다. 내 VM의 OS는 그대로 유지 됩니다.
- 그 동안 쌓여 있던 펌웨어 업데이트를 이번에 한꺼번에 합니다.
- **VM의 Temp Disk 는 지워집니다.** (윈도우 서버의 경우 대걔 D: 드라이브, Linux의 경우 /dev/sdb1) OS 디스크나 Data Disk는 유지됩니다. 혹시 Temp Disk에 지워지면 안되는 내용을 쓰도록 설정되어 있다면 이번에 수정을 하는게 좋겠습니다.
- 모든 VM이 대상이 되는 건 아닙니다. 최근 4-5개월 전에 만든 VM은 이미 업데이트된 Host에 만들어졌을 가능성이 있습니다. (확인은 일정이 시작된 후 아래 방법으로 가능)
- 모든 지역이 한꺼번에 실행되는게 아니고 계획에 따라 몇 단계로 실행됩니다. 특히 데이터센터의 페어는 동시에 하지 않습니다. 예를들어 Korea Central 지역과 Korea South가 동시에 진행되지 않습니다.
</code></pre>
<h4 id="plannedmaintenance">이번 Planned Maintenance의 일정과 프로세스</h4>
<p>아래 날짜들은 변경될 가능성이 있습니다.</p>
<h5 id="step1201812"><strong>Step 1. 2018년 1월 2일에 시작 - 관리자에게 이메일이 발송될 예정</strong></h5>
<p>Azure 구독의 관리자(Admin)와 협력 관리자(Co-admin)에게 이메일이 발송됩니다. 현재 설정되어 있는 Admin 을 확인하거나 추가하려면 <a href="https://docs.microsoft.com/ko-kr/azure/billing/billing-add-change-azure-subscription-administrator#add-an-rbac-owner-admin-for-a-subscription-in-azure-portal">Azure Portal에서 구독에 대한 RBAC 소유자 관리자 추가 문서</a>를 참조하시고 이메일을 받을 수 있는 상태인지 미리 살펴보는게 좋겠습니다. 앞으로 계속 주요 알림이 구독 관리자 이메일 주소로 전송됩니다.</p>
<p>이메일 말고 Webhooks 나 SMS 도 지원하는데 한국 휴대폰 번호는 안됩니다. 혹시 Azure Logic App 을 사용하고 계신다면 <a href="https://docs.microsoft.com/ko-kr/azure/connectors/connectors-native-webhook">Webhook 커넥터</a>를 이용해서 <a href="https://docs.microsoft.com/ko-kr/azure/connectors/connectors-create-api-slack">슬랙 커넥터</a>로 연결시켜 슬랙에 꽂을 수도 있겠죠. Webhook 설정은 [Windows 가상컴퓨터에 대한 계획된 유지 관리 알림 처리 문서](<a href="http://Windows">http://Windows</a> 가상 컴퓨터에 대한 계획된 유지 관리 알림 처리)를 참조 바랍니다.</p>
<h5 id="3">포털에서 확인하는 3가지 방법</h5>
<p>**1. Azure 포탈의 &quot;도움말 + 지원 &gt; 계획된 유지 관리&quot; 메뉴에서 확인 할 수 있습니다. **</p>
<p><a href="http://ilseokoh.com/content/images/2017/12/azure-planned-maintenance-menu.jpg"><img src="http://ilseokoh.com/content/images/2017/12/azure-planned-maintenance-menu.jpg" alt="Azure Planned Maintenance 리부팅 동반"><br>
</a></p>
<p></p>
<p>지금은 기간이 아니라서 내용이 없고 저도 한번도 본적이 없어서 동영상에서 캡쳐 했습니다. 이런식으로 계획된 VM들의 리스트를 볼 수 있습니다.</p>
<p><a href="http://ilseokoh.com/content/images/2017/12/portal-planned-maintenace.jpg"><img src="http://ilseokoh.com/content/images/2017/12/portal-planned-maintenace.jpg" alt="Azure Planned Maintenance 리부팅 동반"><br>
</a></p>
<p>**2. 포탈의 가상 컴퓨터 메뉴에서 확인 가능합니다. **</p>
<p><a href="http://ilseokoh.com/content/images/2017/12/planned-maintenance-vm.png"><img src="http://ilseokoh.com/content/images/2017/12/planned-maintenance-vm.png" alt="Azure Planned Maintenance 리부팅 동반"><br>
</a></p>
<p>**3. Azure 포탈 가상컴퓨터에 들어가면 볼 수 있습니다. 특히 Step 2에서 설명할 직접 실행하기 버튼이 여기에 있습니다. **</p>
<p><a href="http://ilseokoh.com/content/images/2017/12/planned-maintenance-vm-start.png"><img src="http://ilseokoh.com/content/images/2017/12/planned-maintenance-vm-start.png" alt="Azure Planned Maintenance 리부팅 동반"><br>
</a></p>
<p>물론 <a href="https://docs.microsoft.com/ko-kr/azure/virtual-machines/linux/maintenance-notifications">Azure CLI</a>, <a href="https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/maintenance-notifications#check-maintenance-status-using-powershell">PowerShell</a> 을 사용해서 확인 할 수도 있습니다.</p>
<h5 id="step2proactivewindow20181219">**Step 2. 내가 직접 실행하는 기간(Proactive Window) 2018년 1월 2일부터 1월 9일까지 **</h5>
<p>내가 사용하는 VM들이 HA 구성이 잘 되어 있다면 직접 실행하지 않아도 Step 3에서 자연스럽게 되도록 그냥 둬도 됩니다. 사실 이렇게 되야죠. 가용성 집합(Availability Set)으로 묶여 있는 VM들의 경우 가능한 얘기 입니다. 하지만 여러가지 이유에서 HA 구성이 안되어 있거나 완벽하지 않을 수 있습니다. 예를들어 MySQL을 VM 1대(SSD 사용하면 SLA 99.5%)에 구성해서 사용하고 있는 경우가 그렇습니다.  여기에 그 외의 이유들이 몇 가지 있습니다.</p>
<pre><code>- 리부팅이 되면 서비스를 수동으로 올려줘야 하는 경우. 또는 서비스들의 실행 순서가 있어서 사람이 확인하면서 해야 하는 경우
- 서비스를 사용하는 고객에게 정확히  날짜와 시간을 공지하고 하고 싶은 경우
- 미뤄놨던 윈도우 업데이트나 미들웨어 등의 같이 업데이트 하고 싶은 경우
- 리부팅 후에 서비스가 올라와서 스스로 준비되는데 30분이 넘게 걸리는 경우 (아래 Step 3에서 자동으로 업데이트 될 때 가용성 집합이 Update Domain 하나가 끝나면 30분 기다려 주는 이유)
- 그냥 내가 통제하는 상황에서 리부팅 하고 싶은 경우
</code></pre>
<p>굳이 신경쓰지 않아도 되는 경우도 있습니다.</p>
<pre><code>- 개발용 QA 용이라서 리부팅되도 상관없는 경우
- 자주 리부팅 하는 경우
- 잠깐 쓰는 용도의 VM
</code></pre>
<p><strong>기간중에 직접 실행하려면 위의 스크린 샷에서 보이는 &quot;<span style="color: #800000;">Initiate Maintenance now</span>&quot; 버튼을 눌러서 실행합니다.</strong></p>
<p>Cloud Service와 <a href="http://ilseokoh.com/2017/12/11/azure-virtual-machine-scale-set-1-introduction/">VMSS(Virtual Machine Scale Set)</a>은 지원하지 않습니다.</p>
<h5 id="step3vmscheduledmaintenance">**Step 3. 직접 실행하지 않은 VM에 대한 실행 (Scheduled Maintenance) - 기간이 아직 정해지지 않음. **</h5>
<p>Step 2에서 직접 실행하지 않아서 남아있는 VM들은 이 기간 동안 자동으로 리부팅 되면서 업데이트 됩니다.  몇 분이 걸릴 수 있습니다. 역시 Temp Disk는 지워집니다. 가용성 집합을 사용한 경우 Update Domain 단위로 업데이트 됩니다. Update Domain 사이에는 30분의 시간을 기다려 줍니다.</p>
<p><a href="https://docs.microsoft.com/ko-kr/azure/best-practices-availability-paired-regions#what-are-paired-regions">Region Pair</a> 는 동시에 업데이트 되지 않습니다.</p>
<p><a href="https://docs.microsoft.com/ko-kr/azure/best-practices-availability-paired-regions">BCDR(Business continuity and disaster recovery)</a> 이 적용되어 있다면 더 안전하겠지만 몇 분안에 끝나는 업데이트에서 BCDR이 작동하는 것이 좋은지는 관리자의 판단이 필요할 것 같습니다.</p>
<p><strong>Scheduled Event(예정된 이벤트) 를 사용하여 대응하기 (현재 미리보기)</strong></p>
<p>Scheduled Event를 걸어놓으면 실제 리부팅 되기 15분 전에 알림을 받을 수 있습니다. Scheduled Event를 이용해서 리부팅 전에 해야하는 작업 예를들어 Load Balancer의 백엔트 풀에서 제거, 백업 포인트, 커넥션 정리, Failover 실행 등의 작업을 미리 실행해 놓고 리부팅을 할 수 있습니다. 좀 더 고급스러운 접근 같습니다. 저도 적용해 보지는 않았지만 가용성 집합 내의 VM 하나가 폴링을 해서 이벤트를 캐치해야 하고 그 후 정리할 걸 정리하는 등 코드를 좀 짜줘야 할 것 같습니다. 자세한 내용은 문서와 <a href="https://channel9.msdn.com/Shows/Azure-Friday/Using-Azure-Scheduled-Events-to-Prepare-for-VM-Maintenance">동영상</a> (데모 포함)참조 바랍니다.</p>
<h4 id="">질문들</h4>
<p>Step 3에서 리부팅 시간을 미리 몇 일 또는 몇 시간 전에 알 수 있나요? 아니요 Scheduled Event를 이용해서 15분전에 알 수 있습니다.</p>
<p>VM 말고 Azure Web App 같은 PaaS 서비스도 이번에 적용되나요? 아니요. PaaS 서비스는 별도 스케줄로 업데이트가 되고 대걔 임팩트가 없는 방향으로 진행됩니다. PaaS의 장점이라고 할 수 있습니다.</p>
<p></p>
<p>아 왜 업데이트가 있어서 귀찮게 ... 생각할 수 도 있지만 보안이나 가용성이 더 좋아질다고 하니 기꺼이 또는 강제로 업데이트를 해야하겠습니다. 더 상세한 내용을 알고 싶으시면 아래 링크 확인 바랍니다.</p>
<pre><code>- [Azure Friday 동영상](https://azure.microsoft.com/en-us/resources/videos/azure-friday-virtual-machine-planned-maintenance-rafalovich/)
- [공식 블로그 포스트(영문)](https://azure.microsoft.com/en-us/blog/a-new-planned-maintenance-experience-for-your-virtual-machines/?cdn=disable)
- [이그나이트 동영상 (영문)](https://myignite.microsoft.com/videos/57085)
- [문서](https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/maintenance-and-updates)</code></pre>
</div>]]></content:encoded></item><item><title><![CDATA[Azure Virtual Machine Scale Set #2 – Custom 이미지로 120대 만들기]]></title><description><![CDATA[<div class="kg-card-markdown"><p><a href="http://ilseokoh.com/2017/12/11/azure-virtual-machine-scale-set-1-introduction/">Virtual Machine Scale Set(이하 VMSS)의 개요</a>에 대해서는 지난 포스트에 설명이 되어 있다. 여기서는 Azure CLI를 이용해서 실제로 VMSS를 만드는 방법에 대한 내용이다. Custom VM 이미지를 이용해서 VMSS의 VM들을 생성하기 위해서 이미지용 VM을 만들고 스크립트를 통해서 이미지를 만든다.</p>
<p>전체 다이어그램은 아래 그림과 같다.</p>
<p><img src="http://ilseokoh.com/content/images/2017/12/vmss-architecture.jpg" alt=""></p>
<h4 id="1vm">1. VM 이미지 만들기</h4>
<h5 id="1azurecli20azure"><a href="https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest">1)</a></h5></div>]]></description><link>http://ilseokoh.com/azure-virtual-machine-scale-set-2-120-instances/</link><guid isPermaLink="false">5ad354a2f590390ca1a067f2</guid><category><![CDATA[azure]]></category><dc:creator><![CDATA[오일석]]></dc:creator><pubDate>Mon, 11 Dec 2017 07:01:34 GMT</pubDate><media:content url="http://ilseokoh.com/content/images/2017/12/azure-vmss-overprovisioning.jpg" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><img src="http://ilseokoh.com/content/images/2017/12/azure-vmss-overprovisioning.jpg" alt="Azure Virtual Machine Scale Set #2 – Custom 이미지로 120대 만들기"><p><a href="http://ilseokoh.com/2017/12/11/azure-virtual-machine-scale-set-1-introduction/">Virtual Machine Scale Set(이하 VMSS)의 개요</a>에 대해서는 지난 포스트에 설명이 되어 있다. 여기서는 Azure CLI를 이용해서 실제로 VMSS를 만드는 방법에 대한 내용이다. Custom VM 이미지를 이용해서 VMSS의 VM들을 생성하기 위해서 이미지용 VM을 만들고 스크립트를 통해서 이미지를 만든다.</p>
<p>전체 다이어그램은 아래 그림과 같다.</p>
<p><img src="http://ilseokoh.com/content/images/2017/12/vmss-architecture.jpg" alt="Azure Virtual Machine Scale Set #2 – Custom 이미지로 120대 만들기"></p>
<h4 id="1vm">1. VM 이미지 만들기</h4>
<h5 id="1azurecli20azure"><a href="https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest">1) Azure CLI 2.0 설치</a> 하고  <a href="https://docs.microsoft.com/ko-kr/cli/azure/authenticate-azure-cli?view=azure-cli-latest">Azure 로그인</a>을 먼저한다.</h5>
<pre><code>$ az login
To sign in, use a web browser to open the page https://aka.ms/devicelogin and enter the code G8R712ZTN6 to authenticate.
</code></pre>
<h5 id="22">2) 리소스 그룹을 2개 만든다.</h5>
<pre><code>$ az group create --name VMSSImageGroup --location koreacentral

$ az group create --name VMSSGroup --location koreacentral
</code></pre>
<h5 id="3portalvmapplication">3) Portal 에서 이미지 생성용 VM을 생성하고 필요한 미들웨어나 Application을 설치 후 잘 작동하는지 확인한다.</h5>
<h5 id="4windowsrdpsysprepsshwaagent">4) <a href="https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/classic/capture-image">Windows의 경우 RDP 접속해서 sysprep 한다</a>. <a href="https://docs.microsoft.com/ko-kr/azure/virtual-machines/linux/capture-image">리눅스의 경우 SSH로 접속해서 waagent 명령을 실행</a>한다.</h5>
<h5 id="5vmdeallocategeneralize">5) 이미지 생성용 VM을 Deallocate / Generalize 시키고 이미지를 생성한다.</h5>
<pre><code class="language-bash">$ az vm deallocate -g VMSSImageGroup -n VMSSImageVM1

$ az vm generalize -g VMSSImageGroup -n VMSSImageVM1

$ az image create --name VMSSImage01 --resource-group VMSSImageGroup --source VMSSImageVM1
</code></pre>
<h5 id="6vm">6) 이미지 생성용 VM을 지운다.</h5>
<pre><code class="language-bash">az vm delete -n VMSSImageVM1 -g VMSSImageGroup
</code></pre>
<p></p>
<h4 id="2vmss">2. VMSS 생성</h4>
<p>VM들이 들어갈 가상네트워크를 먼저 만들고 방금 만든 이미지로 120개의 VM을 VMSS로 생성한다. 100개 이상의 VM은 Load Balancer를 붙이지 못하고 single-placement-group을 false로 설정하여 생성한다. 가상네트워크의 서브넷 IP 범위를 120개 보다 크게 넉넉히 잡아줘야 한다.</p>
<pre><code class="language-bash">$ az network vnet create --name VMSSVNet --resource-group VMSSGroup --location koreacentral --address-prefix 10.1.0.0/16 --subnet-name VMSSSubnet --subnet-prefix 10.1.0.0/22

$ az vmss create --image /subscriptions/e4723bbb-cd59-41dc-86b7-2e239d536c04/resourceGroups/VMSSImageGroup/providers/Microsoft.Compute/images/VMSSImage0  \
                 --name TestVMSS --resource-group VMSSGroup --authentication-type password \
                 --admin-username kevinoh --admin-password '&lt;pasword&gt;' --single-placement-group false \
                 --load-balancer &quot;&quot; --vm-sku Standard_D1_v2 --instance-count 120 --vnet-name VMSSVNet \
                 --subnet VMSSSubnet --disable-overprovision
</code></pre>
<p>명령에서 사용한 파라미터를 몇 가지 살펴보자.</p>
<pre><code>- image: 1에서 생성한 이미지를 포탈에서 보면 Resource ID가 있다. 리소스그룹이 같으면 이미지 이름을 써도 되지만 리소스그룹이 다르기 때문에 ID를 사용한다. Managed Image는 리소스 아이디, Unmanaged image는 Storage Account URL를 사용한다.
- name: VMSS이름
- resource-group: VMSS가 생성될 리소스그룹
- authntication-type: password 로 지정하여 ID/pwd를 입력한다.
- admin-username: admin id
- admin-password: admin pwd
- single-placement-group: 100개 이상을 만들기 위해서 false로 설정한다. 상세 설명은 [개요](http://ilseokoh.com/2017/12/11/azure-virtual-machine-scale-set-1-introduction/) 참조
- load-balancer: single-placement-group false이고 100개 이상을 만드려면 Load Balancer를 만들지 않아야 한다. &quot;&quot;로 명시하지 않으면 오류 발생
- vm-sku: VM 사이즈. 사이즈 선택을 위한 문자열은 [가상 컴퓨터 크기 페이지](https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/sizes-general) 참조
- instance-count: 생성할 VM 수
- vnet-name: 가상네트워크 이름
- subnet-name: 서브넷 이름
- disable-overprovision: 현재 사용중인 구독의 core limit이 100개로 설정되어 있어서 껐다.
</code></pre>
<p>그 외 상세한 파라미터는<a href="https://docs.microsoft.com/en-us/cli/azure/vmss?view=azure-cli-latest#az_vmss_scale"> az vmss 커멘드 설명</a>을 참조</p>
<p>Azure Portal에서 인스턴스를 확인하면 120개의 인스턴스가 생성된 것을 확인 할 수 있다.</p>
<p><a href="http://ilseokoh.com/content/images/2017/12/azure-vmss-after-update2.jpg"><img src="http://ilseokoh.com/content/images/2017/12/azure-vmss-after-update2.jpg" alt="Azure Virtual Machine Scale Set #2 – Custom 이미지로 120대 만들기"><br>
</a></p>
<h4 id="3">3. 인스턴스 갯수 늘리기/줄이기</h4>
<pre><code class="language-bash"># 줄이기
az vmss scale --resource-group VMSSGroup --name TestVMSS --new-capacity 3
# 늘이기
az vmss scale --resource-group VMSSGroup --name TestVMSS --new-capacity 120
</code></pre>
<p>인스턴스 갯수를 늘리고 줄이는 명령이다.</p>
<h4 id="4vm">4. VM 업데이트</h4>
<p>운영을 하다보면 업데이트가 필요하다. VMSS 를 업데이트 하려면 먼저 VM이미지에서 다시 VM을 생성해서 업데이트를 하고 새로운 VM이미지를 만들어야 한다. VM 생성은 Portal에서 할 수 있고 아래 명령으로 VM을 다시 생성할 수 있다. 그리고 다시 1번을 수행해서 이미지를 생성한다.</p>
<pre><code class="language-bash">$ az vm create -n VMSSImageVM3 -g VMSSImageGroup --image VMSSImage01 --vnet-name VMSSI
mageGroup-vnet --subnet default --authentication-type password --admin-username kevinoh --admin-password 'Kevin!3245678' --size Standard_DS1_v2
</code></pre>
<p>새로 생성된 이미지 이름이 VMSSImage02라면 아래 명령으로 VMSS 의 이미지를 업데이트 할 수 있다. 그리고 전체 이미지를 즉시 업데이트 할 수 있다. instance-ids &quot;*&quot; 는 전체 업데이트고 인스턴스 아이디를 여러개씩 지정해서 업데이트 할 수도 있다. 100개 이상의 VM을 가지고 있고 Load Blancer가 없는 VMSS 구성은 Rolling Update가 지원되지 않는다. 반대의 경우라면 az vmss rolling-upgrade 명령을 살펴보기 바란다.</p>
<pre><code class="language-bash">$ az vmss update --resource-group VMSSTestGroup --name VMSSTest --set virtualMachineProfile.storageProfile.imageReference.id=/subscriptions/e47f23bb-cd59-41dc-86b7-2e239d536c04/resourceGroups/VMImageGroup/providers/Microsoft.Compute/images/VMSSImage02

$ az vmss update-instances --resource-group VMSSGroup --name TestVMSS --instance-ids &quot;*&quot;
</code></pre>
<p>이미지를 변경 후에 Azure Portal에서 인스턴스를 확인해보면 최신모델이 아니오로 표시된다. 업데이트에 성공하면 다시 예로 변경된다.<br>
<a href="http://ilseokoh.com/content/images/2017/12/azure-vmss-update.jpg"><br>
<img src="http://ilseokoh.com/content/images/2017/12/azure-vmss-update.jpg" alt="Azure Virtual Machine Scale Set #2 – Custom 이미지로 120대 만들기"><br>
</a></p>
<h4 id="5vmssdashboardtoolrollingupdate">5. VMSS Dashboard tool 을 사용하여 수동 Rolling Update</h4>
<p>python으로 만들어진 <a href="https://github.com/MurthyCloudConfigurations/vmssdashboard">VMSS Dashboard tool</a> 이 있다. Github에서 소스를 다운로드 받아서 python vmsseditor.py 를 실행하면 툴이 실행된다. 이 툴을 이용하면 Fault Domain 별로 VM 업데이트를 수동으로 실행 할 수 있다. 만약 VM 이미지를 변경하고 서비스의 중단없이 업데이트를 하려면 Fault Domain 별로 업데이트를 수행하면 된다.</p>
<p><a href="http://ilseokoh.com/content/images/2017/12/azure-vmss-after-update3.jpg"><img src="http://ilseokoh.com/content/images/2017/12/azure-vmss-after-update3.jpg" alt="Azure Virtual Machine Scale Set #2 – Custom 이미지로 120대 만들기"><br>
</a></p>
</div>]]></content:encoded></item><item><title><![CDATA[Azure Virtual Machine Scale Set #1 - 개요]]></title><description><![CDATA[<div class="kg-card-markdown"><p>같은 역할을 하는 VM이 수십, 수백대가 필요한 상황이 있을 수 있다. 규모가 큰 서비스 인프라를 운영하거나 또는 평소에는 2-3개의 VM으로 운영되다가 필요할 때 수십대의 VM으로 확장해서 사용해야하는 애플리케이션도 있다. 이렇게 VM의 개수가 많아지면 관리의 문제가 생긴다. 한꺼번에 만드는 건 Azure Poweshell이나 CLI를 통해서 한다고 하지만 VM 업데이트, 자동 확장(Auto</p></div>]]></description><link>http://ilseokoh.com/azure-virtual-machine-scale-set-1-introduction/</link><guid isPermaLink="false">5ad354a2f590390ca1a067f0</guid><category><![CDATA[azure]]></category><dc:creator><![CDATA[오일석]]></dc:creator><pubDate>Mon, 11 Dec 2017 03:02:27 GMT</pubDate><media:content url="http://ilseokoh.com/content/images/2017/12/vmss_vm_to_vmss.png" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><img src="http://ilseokoh.com/content/images/2017/12/vmss_vm_to_vmss.png" alt="Azure Virtual Machine Scale Set #1 - 개요"><p>같은 역할을 하는 VM이 수십, 수백대가 필요한 상황이 있을 수 있다. 규모가 큰 서비스 인프라를 운영하거나 또는 평소에는 2-3개의 VM으로 운영되다가 필요할 때 수십대의 VM으로 확장해서 사용해야하는 애플리케이션도 있다. 이렇게 VM의 개수가 많아지면 관리의 문제가 생긴다. 한꺼번에 만드는 건 Azure Poweshell이나 CLI를 통해서 한다고 하지만 VM 업데이트, 자동 확장(Auto Scale) 등 관리요소가 많아지고 스크립트도 많아진다. 이런 상황에 도움을 주기 위해 Azure Virtual Machine Scale Set(이하 VMSS)이 있다.</p>
<p>어떤 때에  Scale In/Out이 쉬운 수십대의 VM을 사용하게 될까? Azure 의 어떤 서비스는 VMSS를 사용해서 만들어진다. PaaS 서비스를 구축하는데 VMSS 가 사용되는 경우도 있다. 여기에 몇 가지 예가 있다.</p>
<pre><code>- Azure Service Fabric 은 VMSS로 VM을 생성하여 클러스터를 만든다.
- Azure Batch 는 계산노드(Compute Node)를 VMSS 로 만든다.
- [Azure의 Pivotal Cloud Foundary](https://docs.microsoft.com/ko-kr/azure/virtual-machines/linux/cloudfoundry-get-started)는 인프라를 생성할 때 VMSS를 사용한다.
- MRI 에서 나온 이미지를 VMSS를 사용하여 VM들을 Scale out 해서 처리하고 다시 자동으로 Scale In 하는 사례
- 대용량의 데이터 분석을 위해 분석 VM 노드를 VMSS로 Scale Out/In을 처리
- 게임서버를 테스트 하기 위한 클라이언트를 VMSS를 이용하여 VM 400대에서 수행
</code></pre>
<h4 id="vmss">VMSS의 특징</h4>
<pre><code>- 최대 1000개의 VM 생성
- Custom VM을 이용하여 생성 가능 (Custom VM이미지의 경우 300대가 최대)
- 서비스 중지 없이 업데이트 가능(Rolling Update)
- 동적으로 VM 인스턴스 갯수를 관리하여 비용 절감
- Auto Scale: 특정 조건에서 VM 개수를 자동으로 증가/감소
- Azure Load Balancer와 통합 (100대 이하)
- VMSS 전체 VM을 대상으로 Auto Scale, 업데이트가 가능하다. 개별 VM을 새로운 이미지로 업데이트하거나 자동 크기조정을 할 수는 없다.
- Managed Disk를 사용하는 것이 유리하다.
</code></pre>
<h4 id="azureportalvmss">Azure Portal에서 VMSS 생성</h4>
<p><a href="https://docs.microsoft.com/ko-kr/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-portal-create">Azure Portal에서 VMSS를 생성</a>할 수 있다. OS, 인스턴스 갯수(VM 갯수), 위치, ID/Pwd, 인스턴스 크기 등을 정해주면 만들 수 있다. 하지만 Portal UI에서는 Custom VM 이미지를 사용할 수 가 없고 세밀한 설정이 어렵다. <a href="https://docs.microsoft.com/ko-kr/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-create">Powershell 또는 CLI로 스크립트를 이용하거나</a> <a href="https://docs.microsoft.com/ko-kr/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-deploy-scaling-app-template">ARM Template</a>을 이용하는 것이 바람직하다.</p>
<p><a href="http://ilseokoh.com/content/images/2017/12/azure-vmss-portal.jpg"><img src="http://ilseokoh.com/content/images/2017/12/azure-vmss-portal.jpg" alt="Azure Virtual Machine Scale Set #1 - 개요"><br>
</a></p>
<h4 id="100">100개 인스턴스가 넘는 크기 조정 사용</h4>
<p><a href="https://docs.microsoft.com/ko-kr/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-placement-groups">대규모 Virtual Machine Scale Sets와 작동</a> 문서에 잘 설명이 되어 있다. 100개 이하와 이상의 VMSS는 차이가 있다.</p>
<p>100개 이하에서는 Load Balancer를 붙일 수 있고 Load Balancer를 설정하여 부하를 분산하고 Probe 설정을 통해 문제가 있는 VM에 로드를 주지 않을 수 있다. 100개 이하의 VM은 하나의 Placement Group 안에 배치되고 각각 5개의 Fault Domain / Update Domain 에 VM들이 배치된다.  LB는 표준크기를 사용할 수 있는데 표준 크기의 LB의 Back end pool 의 최대 크기가 100개라는 제약이 적용되기 때문이기도 하다.  Load Blancer가 붙어있고 Probe 설정이 되어 있어야 자동 Rolling Update가 가능하다.</p>
<p><img src="http://ilseokoh.com/content/images/2017/12/azure-vmss-placement-group.jpg" alt="Azure Virtual Machine Scale Set #1 - 개요"></p>
<p>하지만 100대가 넘어가면 Placement Group이 여러개가 되고 Load Balancer를 붙일 수 없다. 최대 1000대의 VM이 생성되지만 내가 만든 Custom 이미지를 사용하는 경우 최대 300대까지 배포가 가능하다. 위 그림은 97대의 VM을 Load Balancer 없이 100대 이상 사용 옵션으로 만든 후의 배포 모습이다. 초록색 점이 VM 한대 인데 3개의 Placement Group이 만들어지고 VM이 적절히 분산되어 있다.</p>
<p>100대 이상과 이하를 구분하여 생성할 때 스크립트에서 쓰는 스위치는 <em>singlePlacementGroup</em>  이다. True로 설정하면 100대 이하 False로 설정하면 100대 이상이고 False일 때 LB를 만들지 않아야 오류가 나지 않는다.</p>
<p>VM의 생성은 병렬로 만들어 지기 때문에 빠르게 수백대의 VM을 생성할 수 있다.</p>
<h4 id="overprovisioning">오버프로비전(OverProvisioning)</h4>
<p>VM을 만들어 내는 걸 Provisioning 한다고 한다. SSD 를 가진 하나의 VM은 99.5% 임을 알고 있을 것이다. 이걸 10대 생성한다면 (99.5%)^10 = 95%, 100대 생성한다면 (99.5%)^100 = 60% 로 SLA가 떨어진다. 계산이 그렇다는 것이다. VM 생성이 실패할 확률이 높아 진다는 얘기고 실제로 큰 문제가 발생하지는 않는다. 하지만 이를 보완할 필요가 있기 때문에 OverProvisioning을 한다. 만약 100대를 만든다면 경우에 따라 다르지만 120대를 생성요청하고 먼저 성공한 100대의 VM만 남기는 식이다. 이렇게 Provisioning의 실패율을 현저히 낮출 수 있다.  여기서 추가로 만들기 요청된 20 대에 대해서는 비용이 청구되지는 않는다. OverProvisioning은 기본값이 True로 되어 있고 끌 수도 있다. 아래 그림은 100대를 만들어야 하지만 OverProvisioning으로 110대가 만들어졌다.</p>
<p>OverProvisioning 를 Off 로 설정해서 사용하지 않아야 하는 때는 어떤 상황일까? 구독의 Core 제약이 걸려서 추가로 VM이 설정되지 않거나 가상네트워크의 서브넷 개수가 적어서 추가 VM을 넣을 수 없는 경우 등이 그렇다.</p>
<p><img src="http://ilseokoh.com/content/images/2017/12/azure-vmss-overprovisioning.jpg" alt="Azure Virtual Machine Scale Set #1 - 개요"></p>
<h4 id="manageddisk">Managed Disk 사용</h4>
<p>VMSS에서 Managed Disk를 사용하는 것이 유리하다. 100대 이상의 인스턴스를 만들 때는 반드시 Managed Disk를 사용해야 한다. Unmanaged Disk는 Storage Account를 만들어야하고 Storage Account는 자신의 네트워크 제약 때문에 최대 20대 이하의 VM 디스크를 넣어야 한다. Unmanaged Disk를 사용해도 VMSS가 알아서 Storage Account를 관리해주기는 하지만 굳이 Unmanaged Disk를 사용할 이유는 찾지 못하겠다.</p>
<h4 id="customvm">Custom VM의 생성</h4>
<p>여러대의 VM을 생성해서 내 인프라를 꾸미는데 아무것도 설치되지 않은 Windows Server 2016을 사용하고 100대를 하나씩 RDP로 들어가서 관리를 할 수 는 없다. 거의 불가능한 작업이고 실수를 할 위험이 있다. 따라서 자동으로 이 설정을 해줘야 한다. 두가지 방법이 있다. Custom Script Extension을 사용하는 방법이 있고 VM 이미지를 사용하는 방법이 있다.</p>
<h5 id="customscriptextension">Custom Script Extension</h5>
<p>VM의 확장(Extension)이고 VM이 Provision 되면 설정된 스크립트를 다운받아서 실행한다. <a href="https://docs.microsoft.com/ko-kr/azure/virtual-machines/windows/extensions-customscript">Windows VM이라면 PowerShell</a>, <a href="https://docs.microsoft.com/ko-kr/azure/virtual-machines/linux/extensions-customscript">Linux</a>라면 Bash 스크립트를 실행하는 식이고 이 스크립트에서 해당 VM에 필요한 모든 미들웨어와 데이터, 내 Application을 설치하고 설정까지 자동으로 실행하는 것이다. 스크립트를 만드는데 노력이 들어가는 일이지만 VMSS의 최대값이 1000대까지 VM을 만들 수 있고 코드이기 때문에 업데이트와 관리가 쉽다.</p>
<h5 id="vm">VM 이미지 사용</h5>
<p>VM을 하나 만들어서 필요한 모든 미들웨어와 Application을 설치한 후에 VM을 이미지로 만들고 VMSS 가 VM을 생성할 때 이 이미지를 사용하는 방법이다. 스크립트보다는 빠르게 적용할 수 있다. 다만 Applicsation의 업데이트가 있을 때 이미지를 다시 생성해야 한다. 이 부분을 어느정도 스크립트로 작성해 놓으면 좋다. 단점은 최대 300대까지만 생성이 가능하다.</p>
<h4 id="azure">Azure 가상 네트워크</h4>
<p>VMSS가 VM을 생성하지만 그 VM들은 Azure의 가상네트워크의 하나의 Subnet 안에 모두 만들어진다. 여기서 주의할 것은 Subnet의 IP 갯수다. 300대를 만들어야 하는데 Subnet의 설정이 10.0.0.0/24 (256개 영역. 실제로는 251개 사용 가능)로 되어 있다면 오류가 발생한다. 따라서 가상네트워크를 미리 만들면서 네트워크 주소 범위와 서브넷을 잘 설정해놓고 VMSS를 만들 때 그 서브넷을 지정해서 만드는 게 실수를 줄여준다. Subnet의 IP 개수는 필요한 것 보다 약 20% 정도 더 여유를 둬야 하는데 이는 OverProvisioning을 생각해야 하기 때문이다.</p>
<h4 id="subscriptioncore">구독(Subscription)의 Core 수 제약</h4>
<p>구독은 기본값으로 20개의 Core 수 제약이 있다. 이는 어떤 실수로 인해 비용이 과다 청구되는 것을 막기 위한 제약이다. 하지만 VMSS를 쓰기로 했다면 20개의 Core 보다 더 많이 사용할 가능성이 있다. 따라서 코어 제약을 원하는 개수로 늘려놔야 한다.  <a href="http://ilseokoh.com/2017/12/10/azure-core-limit/">Azure 구독의 코어수 제약 늘리기</a>를 참조해서 변경할 수 있다.</p>
</div>]]></content:encoded></item><item><title><![CDATA[Azure 구독의 Core 수 제약 늘리기]]></title><description><![CDATA[<div class="kg-card-markdown"><p>Azure 구독당 기본값으로 20개의 Core 수 제약이 있다. 이는 어떤 실수로 인해 과다한 사용량 청구를 막기위한 제약이다. 내 구독의 현재 상태를 보려면 구독 메뉴에서 사용량 및 할당량 메뉴에 들어가면 볼 수 있다.</p>
<p><img src="http://ilseokoh.com/content/images/2017/12/azure-quoat.jpg" alt=""></p>
<p></p>
<p>이 제약을 넘어서는 Core를 사용하려고 하면 이런 오류메시지를 만나게 된다.</p>
<blockquote>
<p>Operation results in exceeding quota limits of Core</p></blockquote></div>]]></description><link>http://ilseokoh.com/azure-core-limit/</link><guid isPermaLink="false">5ad354a2f590390ca1a067f1</guid><category><![CDATA[azure]]></category><dc:creator><![CDATA[오일석]]></dc:creator><pubDate>Sun, 10 Dec 2017 04:36:46 GMT</pubDate><media:content url="http://ilseokoh.com/content/images/2017/12/AzureVMCreateNormError.png" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><img src="http://ilseokoh.com/content/images/2017/12/AzureVMCreateNormError.png" alt="Azure 구독의 Core 수 제약 늘리기"><p>Azure 구독당 기본값으로 20개의 Core 수 제약이 있다. 이는 어떤 실수로 인해 과다한 사용량 청구를 막기위한 제약이다. 내 구독의 현재 상태를 보려면 구독 메뉴에서 사용량 및 할당량 메뉴에 들어가면 볼 수 있다.</p>
<p><img src="http://ilseokoh.com/content/images/2017/12/azure-quoat.jpg" alt="Azure 구독의 Core 수 제약 늘리기"></p>
<p></p>
<p>이 제약을 넘어서는 Core를 사용하려고 하면 이런 오류메시지를 만나게 된다.</p>
<blockquote>
<p>Operation results in exceeding quota limits of Core</p>
</blockquote>
<p>이 오류를 해결하기 위해서는 서비스 요청을 해서 제약을 풀어야 한다.</p>
<h5 id="1">1. 위 그림에서 &quot;증가요청&quot; 버튼을 누르거나 &quot;도움말 + 지원&quot; 메뉴에서 &quot;새 지원 요청&quot;을 누른다. 기본사항에 할당량 문제 유형, 구독, 코어, 지원 플랜을 선택한다.</h5>
<p><img src="http://ilseokoh.com/content/images/2017/12/azure-core-support.jpg" alt="Azure 구독의 Core 수 제약 늘리기"></p>
<h5 id="2vm">2. 리소스 관리자 배포모델, 위치, 필요한 VM 시리즈를 선택</h5>
<p><img src="http://ilseokoh.com/content/images/2017/12/azure-core-support2.jpg" alt="Azure 구독의 Core 수 제약 늘리기"></p>
<h5 id="3">3. 연락처 정보를 입력한다. 잠시후에 아래와 같은 이메일을 받을 수 있다.</h5>
<p><img src="http://ilseokoh.com/content/images/2017/12/azure-core-support-email.jpg" alt="Azure 구독의 Core 수 제약 늘리기"></p>
<p>이제 마이크로소프트 기술지원 부서에서 할당량 요청에 대한 처리를 해주거나 연락을 취할 것이다.</p>
</div>]]></content:encoded></item><item><title><![CDATA[Azure SQL Database 마이그레이션 툴 - Microsoft SQL Server Migration Assistant]]></title><description><![CDATA[<div class="kg-card-markdown"><p>요즘 On-prem 서버 또는 VM에 SQL Server를 설치해서 사용하시던 많은 분들이 Azure SQL Database로 이전하고 있다. 관리도 편하고 안정성과 속도도 좋기 때문에 클라우드로 이전할 때 가능하다면 Azure SQL Database를 검토한다. 이 때 <a href="https://www.microsoft.com/en-us/download/details.aspx?id=53595">Microsoft SQL Server Migration Assistant</a> 툴을 사용하면 마이그레이션이 가능한지 확인을 하거나 (Assessment) 실제 스키마와 데이터를 마이그레이션(Migration) 할</p></div>]]></description><link>http://ilseokoh.com/microsoft-sql-server-migration-assistant/</link><guid isPermaLink="false">5ad354a2f590390ca1a067ef</guid><category><![CDATA[azure]]></category><dc:creator><![CDATA[오일석]]></dc:creator><pubDate>Fri, 01 Dec 2017 07:45:51 GMT</pubDate><media:content url="http://ilseokoh.com/content/images/2017/12/SSMA.png" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><img src="http://ilseokoh.com/content/images/2017/12/SSMA.png" alt="Azure SQL Database 마이그레이션 툴 - Microsoft SQL Server Migration Assistant"><p>요즘 On-prem 서버 또는 VM에 SQL Server를 설치해서 사용하시던 많은 분들이 Azure SQL Database로 이전하고 있다. 관리도 편하고 안정성과 속도도 좋기 때문에 클라우드로 이전할 때 가능하다면 Azure SQL Database를 검토한다. 이 때 <a href="https://www.microsoft.com/en-us/download/details.aspx?id=53595">Microsoft SQL Server Migration Assistant</a> 툴을 사용하면 마이그레이션이 가능한지 확인을 하거나 (Assessment) 실제 스키마와 데이터를 마이그레이션(Migration) 할 수 있다.</p>
<p>SQL Server와 Azure SQL Database는 대부분 호환되지만 클라우드와 On-Prem의 특성으로 인한 차이점이 존재한다. 예를들어 Azure SQL Database는 Windows Authentication을 지원하지 않는다. 마이그레이션도 MDF, LDF 파일을 사용할 수 없다. 따라서 이런 툴이 서비스를 지원하는 것이다. 앞으로 <a href="https://azure.microsoft.com/en-us/blog/put-your-databases-on-autopilot-with-a-lift-and-shift-to-azure-sql-database/">Azure SQL Database Managed Instance</a>가 둘 사이의 차이점을 줄여줄 것이고,  <a href="https://azure.microsoft.com/ko-kr/services/database-migration/">Azure SQL Migration Service</a> (Preview) 가 더 편리한 마이그레이션 환경을 제공할 것이다.</p>
<p>툴은 총 6단계를 거치게 되는데 내부적으로는 아래 다이어그램처럼 작동한다.</p>
<p><a href="http://ilseokoh.com/content/images/2017/12/dma-process.jpg"><img src="http://ilseokoh.com/content/images/2017/12/dma-process.jpg" alt="Azure SQL Database 마이그레이션 툴 - Microsoft SQL Server Migration Assistant"><br>
</a></p>
<h4 id="1selectsource">1.소스 데이터베이스 (Select Source)</h4>
<p>로컬에 있는 소스 데이터베이스의 AAKorea3 라는 데이터베이스를 선택.</p>
<p><a href="http://ilseokoh.com/content/images/2017/12/sql-database-migration-source.jpg"><img src="http://ilseokoh.com/content/images/2017/12/sql-database-migration-source.jpg" alt="Azure SQL Database 마이그레이션 툴 - Microsoft SQL Server Migration Assistant"><br>
</a></p>
<h4 id="2selecttarget">2. 타겟 데이터베이스 (Select Target)</h4>
<p><a href="https://docs.microsoft.com/ko-kr/azure/sql-database/sql-database-get-started-portal">Azure 포탈을 통해서 미리 많들어 놓은 Azure SQL Database</a>를 선택. 여기서 SQL Database 의 방화벽에 작업하는 머신의 IP를 넣어야 접속 가능하다.</p>
<p><a href="http://ilseokoh.com/content/images/2017/12/sql-database-migration-target.jpg"><img src="http://ilseokoh.com/content/images/2017/12/sql-database-migration-target.jpg" alt="Azure SQL Database 마이그레이션 툴 - Microsoft SQL Server Migration Assistant"><br>
</a></p>
<h4 id="3selectobject">3. 오브젝트 선택 (Select Object)</h4>
<p>이 단계에서 마이그레이션 오류나 경고를 볼 수 있다. 지금 테스트로 마이그레이션 하는 데이터베이스는 스키마가 단순하기도 하고 SQL Database의 여러가지 기능을 사용하지 않아서 오류가 보이지 않고 일반적인 경고만 몇 개 보이지만 상황에 따라서 오류가 있을 수 있고 적절한 조치를 해줘야 한다.</p>
<p>여기서 발생한 경고는 &quot;중요! ntext, 텍스트, 및 이미지 데이터 형식은 나중 버전의 SQL Server에서 제거 됩니다. 향후 개발 작업에서는 이 데이터 형식을 사용하지 않도록 하고 현재 이 데이터 형식을 사용하는 응용 프로그램은 수정하세요. 대신 nvarchar(max), varchar(max)및 varbinary(max) 를 사용합니다.&quot; 이런 내용인데 이번에는 수정하지 않고 넘어가기로 한다.</p>
<p><a href="http://ilseokoh.com/content/images/2017/12/sql-database-migration-select-object.jpg"><img src="http://ilseokoh.com/content/images/2017/12/sql-database-migration-select-object.jpg" alt="Azure SQL Database 마이그레이션 툴 - Microsoft SQL Server Migration Assistant"><br>
</a></p>
<h4 id="4scriptdeployschema">4. 스크립트 생성 (Script &amp; Deploy schema)</h4>
<p>마이그레이션을 위한 스크립트 생성</p>
<p><a href="http://ilseokoh.com/content/images/2017/12/sql-database-migration-redeploy.jpg"><img src="http://ilseokoh.com/content/images/2017/12/sql-database-migration-redeploy.jpg" alt="Azure SQL Database 마이그레이션 툴 - Microsoft SQL Server Migration Assistant"><br>
</a></p>
<h4 id="5selecttable">5. 테이블 선택 (Select Table)</h4>
<p>마이그레이션 할 테이블 선택.</p>
<p><a href="http://ilseokoh.com/content/images/2017/12/sql-database-migration-select-tables.jpg"><img src="http://ilseokoh.com/content/images/2017/12/sql-database-migration-select-tables.jpg" alt="Azure SQL Database 마이그레이션 툴 - Microsoft SQL Server Migration Assistant"><br>
</a></p>
<ol start="6">
<li>데이터 마이그레이션 (Migrate Data)</li>
</ol>
<p>데이터 이전을 해서 최종 마이그레이션 완료.</p>
<p><a href="http://ilseokoh.com/content/images/2017/12/sql-database-migration-migrate-data.jpg"><img src="http://ilseokoh.com/content/images/2017/12/sql-database-migration-migrate-data.jpg" alt="Azure SQL Database 마이그레이션 툴 - Microsoft SQL Server Migration Assistant"><br>
</a></p>
<p>여기까지 SQL Database (2012버전)에서 Azure SQL로 마이그레이션을 <a href="https://www.microsoft.com/en-us/download/details.aspx?id=53595">Microsoft SQL Server Migration Assistant</a> 툴을 이용해서 해봤다. 스키마가 다르고 사용하는 기능이나 Query가 다르니 상황마다 오류나 가이드가 다를 것이고 실제 Application 을 붙여서 테스트 해야 될 것이다.</p>
<p>다른 종류의 DBMS에서도도 Azure SQL Database로 마이그레이션 할 경우가 있는데 Migration Assistant 는 여러가지 버전이 있다.</p>
<pre><code>- [SQL Server Migration Assistant for Access](https://www.microsoft.com/en-us/download/details.aspx?id=54255)
- [SQL Server Migration Assistant for DB2](https://www.microsoft.com/en-us/download/details.aspx?id=54254)
- [SQL Server Migration Assistant for MySQL](https://www.microsoft.com/en-us/download/details.aspx?id=54257)
- [SQL Server Migration Assistant for Oracle](https://www.microsoft.com/en-us/download/details.aspx?id=54258)
- [SQL Server Migration Assistant for SAP ASE](https://www.microsoft.com/en-us/download/details.aspx?id=54256)
</code></pre>
<p>다음 포스트에서는 이중에서 MySQL에 대해서 테스트 해보자.</p>
</div>]]></content:encoded></item><item><title><![CDATA[진에어 챗봇 서비스 - 제이드 출시]]></title><description><![CDATA[<div class="kg-card-markdown"><p>몇 달전에 진에어 팀과 함께 진행한 HackFest 가 있었다. 챗봇 개발을 위해 여러가지 적용해보는 내용이었고 3일 동안 할 수 있는 여러가지를 개발했었다. 관련된 내용은 <a href="https://microsoftapac.github.io/2017-05-26-jinair-kor.html">&quot;진에어 고객지원 챗봇 서비스 구축&quot;</a> 에서 상세한 내용을 살펴볼 수 있다.진에어 팀에서는 지속적으로 개발하고 개선해서 최근 진에어 챗봇 서비스 제이드를 출시했다. 항공사의 여러가지</p></div>]]></description><link>http://ilseokoh.com/jinair-chatbot-jaid/</link><guid isPermaLink="false">5ad354a2f590390ca1a067ee</guid><category><![CDATA[azure]]></category><dc:creator><![CDATA[오일석]]></dc:creator><pubDate>Tue, 28 Nov 2017 04:32:12 GMT</pubDate><media:content url="http://ilseokoh.com/content/images/2017/11/jaid.jpg" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><img src="http://ilseokoh.com/content/images/2017/11/jaid.jpg" alt="진에어 챗봇 서비스 - 제이드 출시"><p>몇 달전에 진에어 팀과 함께 진행한 HackFest 가 있었다. 챗봇 개발을 위해 여러가지 적용해보는 내용이었고 3일 동안 할 수 있는 여러가지를 개발했었다. 관련된 내용은 <a href="https://microsoftapac.github.io/2017-05-26-jinair-kor.html">&quot;진에어 고객지원 챗봇 서비스 구축&quot;</a> 에서 상세한 내용을 살펴볼 수 있다.진에어 팀에서는 지속적으로 개발하고 개선해서 최근 진에어 챗봇 서비스 제이드를 출시했다. 항공사의 여러가지 업무중 챗봇으로 서비스 할 수 있는 내용을 잘 구현해 놓았다. 앞으로 계속 발전해서 사람이 되길 ...</p>
<p>제이드가 해주는 기능은 크게 3가지</p>
<pre><code>- 스케줄 조회, 출도착 조회
- 예약 조회
- 서비스 문의, Delight Message
</code></pre>
<p>Facebook 메신저와 Skype 채널에 배포되어 있다.</p>
<p><a href="http://ilseokoh.com/content/images/2017/11/jinair-jade-delight-message.png"><img src="http://ilseokoh.com/content/images/2017/11/jinair-jade-delight-message.png" alt="진에어 챗봇 서비스 - 제이드 출시"><br>
</a> <a href="http://ilseokoh.com/content/images/2017/11/jinair-jade-faq.png"><img src="http://ilseokoh.com/content/images/2017/11/jinair-jade-faq.png" alt="진에어 챗봇 서비스 - 제이드 출시"><br>
</a> <a href="http://ilseokoh.com/content/images/2017/11/jinair-jade-filght-info.png"><img src="http://ilseokoh.com/content/images/2017/11/jinair-jade-filght-info.png" alt="진에어 챗봇 서비스 - 제이드 출시"><br>
</a></p>
<p><a href="http://ilseokoh.com/content/images/2017/11/jinair-jade-reservation.png"><img src="http://ilseokoh.com/content/images/2017/11/jinair-jade-reservation.png" alt="진에어 챗봇 서비스 - 제이드 출시"><br>
</a> <a href="http://ilseokoh.com/content/images/2017/11/jinair-jade-reservation-detail.png"><img src="http://ilseokoh.com/content/images/2017/11/jinair-jade-reservation-detail.png" alt="진에어 챗봇 서비스 - 제이드 출시"><br>
</a> <a href="http://ilseokoh.com/content/images/2017/11/jinair-jade-schedule.png"><img src="http://ilseokoh.com/content/images/2017/11/jinair-jade-schedule.png" alt="진에어 챗봇 서비스 - 제이드 출시"><br>
</a></p>
</div>]]></content:encoded></item></channel></rss>