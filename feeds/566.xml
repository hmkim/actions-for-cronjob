<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	
xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"
>

<channel>
	<title>Kwangshin&#039;s Positive Blog</title>
	<atom:link href="http://kwangshin.pe.kr/blog/feed/" rel="self" type="application/rss+xml" />
	<link>http://kwangshin.pe.kr/blog</link>
	<description>Life, Love, Christianity, Computing, Education, Agile ...</description>
	<lastBuildDate>Thu, 07 Feb 2019 16:04:07 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.0.4</generator>
<site xmlns="com-wordpress:feed-additions:1">69713028</site>	<item>
		<title>데이터의 표본 편향(Sample Bias), 그리고 생존 편향(Survivorship Bias)</title>
		<link>http://kwangshin.pe.kr/blog/2019/02/07/data-sample-bias-and-survivorship-bias/</link>
		<comments>http://kwangshin.pe.kr/blog/2019/02/07/data-sample-bias-and-survivorship-bias/#respond</comments>
		<pubDate>Thu, 07 Feb 2019 15:52:08 +0000</pubDate>
		<dc:creator><![CDATA[Kwangshin]]></dc:creator>
				<category><![CDATA[Software Development]]></category>
		<category><![CDATA[Technology]]></category>
		<category><![CDATA[Big Data]]></category>
		<category><![CDATA[Sample Bias]]></category>
		<category><![CDATA[Survivorship Bias]]></category>
		<category><![CDATA[빅 데이터]]></category>
		<category><![CDATA[생존 편향]]></category>
		<category><![CDATA[표본 편향]]></category>

		<guid isPermaLink="false">http://kwangshin.pe.kr/blog/?p=1133</guid>
		<description><![CDATA[데이터(Data)의 시대가 왔다! Image Source :&#160;https://www.theeleader.com/bigdata-2/ 인터넷과 모바일(Mobile) 기술의 발달로 엄청난 양의 데이터가 쌓이는 시대이다. 빅 데이터(Big Data)라는 단어가 그 흐름을 설명해 준다. 또한 채용 공고에서 데이터 과학자(Data Scientist)라는 직함을 보는 것이 결코 어색하지 않은 시대가 되었다. 데이터의 흐름을 보자면 개인적으로 (1) 인터넷 기술과 (2) 모바일 시대를 변화 포인트로 본다. 우선 인터넷 기술을 발전으로 시간적 [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>데이터(Data)의 시대가 왔다!</p>
<p><img class="aligncenter wp-image-1135" src="http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/BigData-1024x787.jpg" alt="" width="600" height="461" srcset="http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/BigData-1024x787.jpg 1024w, http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/BigData-300x231.jpg 300w, http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/BigData-768x590.jpg 768w, http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/BigData.jpg 1306w" sizes="(max-width: 600px) 100vw, 600px" /></p>
<p style="text-align: center;">Image Source :&nbsp;<a href="https://www.theeleader.com/bigdata-2/">https://www.theeleader.com/bigdata-2/</a></p>
<p>인터넷과 모바일(Mobile) 기술의 발달로 엄청난 양의 데이터가 쌓이는 시대이다. 빅 데이터(Big Data)라는 단어가 그 흐름을 설명해 준다. 또한 채용 공고에서 데이터 과학자(Data Scientist)라는 직함을 보는 것이 결코 어색하지 않은 시대가 되었다.</p>
<p>데이터의 흐름을 보자면 개인적으로 (1) 인터넷 기술과 (2) 모바일 시대를 변화 포인트로 본다. 우선 인터넷 기술을 발전으로 시간적 제약이 사라졌다. 즉, 인터넷만 연결되어 있으면 24시간 데이터를 생산할 수 있는 환경이 만들어졌다. 알고리즘의 복잡도를 나타내는 빅오 표기법(<a href="https://en.wikipedia.org/wiki/Big_O_notation">Big-O Notation</a>)으로 비교를 해 보자면, 기존의 데이터가 O(N) 이었다면, 인터넷 기술의 발달로 데이터가 O(N<sup>2</sup>) 가 되었다. 하지만 이 당시에는 공간의 제약이 있었다. 즉, 인터넷에 연결되어 있는 회사 컴퓨터나 집에 있는 컴퓨터를 사용해야만 했다. 하지만, 얼마 지나지 않아서 모바일을 시대가 왔다. 즉, 공간의 제약이 없어진 것이다. 이제 어디서나 24시간 데이터를 생산하는 활동을 할 수 있는 것이다. (당신이 24시간 움직이는 경로도 아주 중요한 데이터가 되었다.) 이제&nbsp;O(N<sup>2</sup>) 에서&nbsp;O(2<sup>N</sup>) 이 되었다. 알고리즘 복잡도에서 이 차이는 정말 엄청난 결과를 가져오듯이 오늘날의 데이터는 이전의 데이터와는 비교할 수 없을 정도로 양적으로 질적으로 큰 변화를 가져왔다. 그래서 빅 데이터라는 단어가 나왔을 것이다.</p>
<p><img class="aligncenter wp-image-1136" src="http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/BigOComplexityChart-1024x701.jpg" alt="" width="600" height="411" srcset="http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/BigOComplexityChart-1024x701.jpg 1024w, http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/BigOComplexityChart-300x205.jpg 300w, http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/BigOComplexityChart-768x526.jpg 768w, http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/BigOComplexityChart.jpg 1362w" sizes="(max-width: 600px) 100vw, 600px" /></p>
<p style="text-align: center;">Image Source :&nbsp;<a href="http://bigocheatsheet.com/">http://bigocheatsheet.com/</a></p>
<p>그렇다면 이렇게 쌓인 데이터를 살펴보고 분석해야 하는 일은 데이터 과학자라고 불리는 일부의 사람들에게만 주어진 일일까? 어떤 데이터가 필요한지, 이렇게 쌓인 데이터를 어떻게 분석하고 어떤 결과를 도출해야 하는지 이끌어 나가는 사람은 꼭 필요하다. 하지만, 소프트웨어/서비스와 관련된 모든 이해관계자(<a href="https://en.wikipedia.org/wiki/Project_stakeholder">Stakeholder</a>)들이 데이터를 꼭 살펴보아야 한다고 생각한다. 소프트웨어 엔지니어도 포함된다! 가끔씩 이런 데이터들에는 전혀 관심도 없고 자기 일이 아니라고 생각하는 소프트웨어 엔진니어를 만나기도 하는데, 내 생각에 데이터를 가장 효과적으로 분석할 수 있는 이해관계자 중 하나가 소프트웨어/서비스를 직접 개발한 소프트웨어 엔지니어일 것이다. 소프트웨어 엔지니어들도 두려움을 버리고, 데이터를 결정하고 분석하는 일에 적극적으로 뛰어들어보자.</p>
<p>하지만, 데이터가 많아지면 많아질수록 당연히 데이터를 분석하는 일도 기하급수적으로 어려워진다. 이 어려움을 극복하기 위해서 여러가지 방법을 사용하지만, 그 중에서 가장 많이 사용되는 방법이 아마도 샘플링(<a href="https://en.wikipedia.org/wiki/Sampling_(statistics)">Sampling</a>)이라고 불리는 표본을 구해서 데이터를 분석하는 방법일 것이다. 가끔씩 데이터를 분석한 결과를 너무 과대평가하고 100% 확신하는 경우를 보게된다. 최선을 다해 데이터를 분석해야 겠지만, 자신의 결과를 너무 과신하지는 말자.</p>
<p><img class="aligncenter wp-image-1137" src="http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/Sampling.jpg" alt="" width="500" height="248" srcset="http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/Sampling.jpg 862w, http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/Sampling-300x149.jpg 300w, http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/Sampling-768x381.jpg 768w" sizes="(max-width: 500px) 100vw, 500px" /></p>
<p style="text-align: center;">Image Source :&nbsp;<a href="https://my.wlc.edu/ICS/Academics/MAT/MAT__117/1213_SP-MAT__117-02/Chapter_08.jnz">https://my.wlc.edu/ICS/Academics/MAT/MAT__117/1213_SP-MAT__117-02/Chapter_08.jnz</a></p>
<p>"<a href="https://ridibooks.com/v2/Detail?id=510000561">구글의 아침은 자유가 시작된다</a>"라는 책을 보면, 표본 편향(Sample Bias)에 대한 이야기가 나온다. 자, 이야기 속으로 들어가서 과연 나는 어떤 결론을 내렸을지 생각해 보기를 바란다.</p>
<p>지금은 제2차 세계대전중이다. 당신은 미국 컬럼비아대학의 통계연구그룹에서 근무하고 있는 수학자이자 통계학자이다. 미국 정부로부터 통계 관련 과제가 주어졌다. 아군의 폭격기가 목표 지점에 가서 적의 진지를 폭격하는데, 적들의 포격도 만만치 않아서 아군 폭격기의 생존율이 점점 낮아지고 있다고 한다. 아군 폭격기의 생존율을 높일 수 있는 방법을 찾으라는 과제가 당신에게 주어졌다. 당연히 아군 폭격기의 생존율을 높이려면, 적의 포격을 맞고도 조금 더 버틸 수 있도록 폭격기에 장갑 장치를 강화하는 방법이 가장 효과적이라고 생각해서, 어느 부분에 장갑 장치를 강화해야 하는지 알아보려고 폭격 임무를 마치고 돌아온 비행기에 난 총알 자국의 위치를 조사해 보았다. 그 결과 다음과 같은 결과를 얻을 수 있었다.</p>
<p><img class="aligncenter wp-image-1138" src="http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/SurvivedData-1024x414.jpg" alt="" width="600" height="242" srcset="http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/SurvivedData-1024x414.jpg 1024w, http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/SurvivedData-300x121.jpg 300w, http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/SurvivedData-768x310.jpg 768w, http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/SurvivedData.jpg 1262w" sizes="(max-width: 600px) 100vw, 600px" /></p>
<p style="text-align: center;">Image Source :&nbsp;<a href="http://www.nww2m.com/2012/11/scitech-tuesday-abraham-wald-seeing-the-unseen/">http://www.nww2m.com/2012/11/scitech-tuesday-abraham-wald-seeing-the-unseen/</a></p>
<p>오른쪽 비행기의 검은 부분이 총알 자국이 가장 많이 나 있는 부분이다. 자, 데이터가 모든 것을 증명한다. 그렇다면 총알 자국이 많이 나 있는 검은 부분을 더 강화한다면 아군 폭격기의 생존율을 높일 수 있다고 말할 수 있지 않을까?</p>
<p>바로 여기에서 표본 편향(Sample Bias)의 문제가 발생한다. 모든 비행기를 하나도 빠짐없이 꼼꼼하게 조사했다고 가정해 보자. 얼핏보면 나의 데이터가, 나의 통계가 아무 문제 없을 것 같이 느껴진다. 하지만 당신이 생각하지 못한 데이터가 있다. 바로 실제로 적의 포격에 의해서 다시 돌아오지 못한 아군 폭격기이다.</p>
<p>이 이야기의 주인공은 헝가리 수학자 에이브러햄 왈드(Abraham Wald)이고, 실제로 있었던 이야기이다. 그리고 그가 직접 만든 위의 그림은 국립 제2차 세계대전 박물관에 있으며, 표본 편향의 교과서로 인정받고 있다. 그렇다면, 왈드는 어떤 결론을 내렸을까? 우리가 생각했던 의견과는 정반대로 총알 자국이 거의 없는 조종석과 꼬리 부분을 더 강화해야 한다고 결론을 내렸다. 왈드는 자기가 살펴본 표본, 즉 살아 돌아온 폭격기들은 편향된 표본임을 깨달았던 것이다. 실제로 조종석과 꼬리 부분에 총을 맞은 비행기는 한 대도 돌아오지 못했던 것이다.</p>
<p><img class="aligncenter wp-image-1134" src="http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/AbrahamWald-1024x641.jpg" alt="" width="600" height="376" srcset="http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/AbrahamWald-1024x641.jpg 1024w, http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/AbrahamWald-300x188.jpg 300w, http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/AbrahamWald-768x481.jpg 768w, http://kwangshin.pe.kr/blog/wp-content/uploads/2019/02/AbrahamWald.jpg 1156w" sizes="(max-width: 600px) 100vw, 600px" /></p>
<p style="text-align: center;">Image Source :&nbsp;<a href="https://riskwerk.com/2016/11/16/bn-extreme-economics-how-not-to-be-wrong/">https://riskwerk.com/2016/11/16/bn-extreme-economics-how-not-to-be-wrong/</a></p>
<p>이 경우는 또한 생존 편향(Survivorship Bias)의 사례가 될 수도 있다. 생존 편향은 전체 집단이 아니라 생존자만을 표본으로 삼아 분석 내용이 왜곡되는 경우이다.</p>
<p>아마도 "나는 이런 오류에 빠지지 않을 것 같은데..." 라고 생각하는 경우도 많을 것이다. 하지만 의외로 쉽게 이 문제에 빠지는 경우가 많다. 보통의 경우 새로운 소프트웨어/서비스를 만드는 경우에도 미리 많은 조사와 분석을 수행한다. 시간과 공을 들여서 비슷한 소프트웨어/서비스를 모두 조사하고 장단점을 비교해서, 새롭게 내 놓을 소프트웨어/서비스에 적용하면 웬지 완벽한 소프트웨어/서비스가 만들어 질 것 같다. 이런 노력이 필요하지 않다는 이야기는 아니다. 아니, 이런 노력은 꼭 필요하다. 하지만 너무 자만에 빠지지 말자는 이야기이다. 빠뜨린 부분이 있는 것 같지 않은가? 이미 개발되었지만 고객들의 외면을 받아서 사라져버린 소프트웨어/서비스도 조사와 분석에 포함될 수 있을까?</p>
<p>데이터를 다룰 때, 특히나 빅 데이터를 다룰 때는 좀 더 신중하게 내가 가진 데이터 또는 표본이 편향되어 있지는 않은지, 내가 빠뜨린 데이터는 없는지, 꼼꼼하게 살펴보고 접근하는 자세가 필요하다.</p>
<p>사실 비단 소프트웨어/서비스를 위한 데이터에만 종속되는 이야기는 아니다. 우리가 세상을 살아가면서 어떤 이야기나 뉴스를 접할 때에도 동일한 표본 편향의 문제가 발생할 여지가 크다. 편향된 데이터 또는 표본만 보고 내 주장을, 내 이야기를 100% 확신하는 오류에 빠지지 않기를 바란다.</p>
]]></content:encoded>
			<wfw:commentRss>http://kwangshin.pe.kr/blog/2019/02/07/data-sample-bias-and-survivorship-bias/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">1133</post-id>	</item>
		<item>
		<title>[번역] 함수형 프로그래밍 세번째 이야기: 그럼 지금까지 해오던 것들을 다 바꾸어야 할까?</title>
		<link>http://kwangshin.pe.kr/blog/2018/11/25/fp-e3-do-all-the-rules-change/</link>
		<comments>http://kwangshin.pe.kr/blog/2018/11/25/fp-e3-do-all-the-rules-change/#respond</comments>
		<pubDate>Sat, 24 Nov 2018 16:33:55 +0000</pubDate>
		<dc:creator><![CDATA[Kwangshin]]></dc:creator>
				<category><![CDATA[Functional Programming]]></category>
		<category><![CDATA[Java]]></category>
		<category><![CDATA[Software Development]]></category>
		<category><![CDATA[Technology]]></category>
		<category><![CDATA[번역]]></category>
		<category><![CDATA[Functional Programming Basics]]></category>
		<category><![CDATA[Functional Programming Language]]></category>
		<category><![CDATA[함수형 언어]]></category>
		<category><![CDATA[함수형 프로그래밍]]></category>
		<category><![CDATA[함수형 프로그래밍 기초]]></category>
		<category><![CDATA[함수형 프로그래밍 언어]]></category>

		<guid isPermaLink="false">http://kwangshin.pe.kr/blog/?p=1033</guid>
		<description><![CDATA[함수형 프로그래밍(Functional Programming) 세번째 이야기 그럼 지금까지 해오던 것들을 다 바꾸어야 할까? &#160; 3.&#160;함수형 프로그래밍 세번째 이야기: 그럼 지금까지 해오던 것들을 다 바꾸어야 할까? 2.&#160;함수형 프로그래밍 두번째 이야기: 왜 함수형이라고 부를까? 1.&#160;함수형 프로그래밍(Functional Programming) 기초 원문: FP Basics E3&#160;&#124; Blog &#124;&#160;8th Light, Inc. 저자: Robert C. Martin (Uncle Bob) (Blog: http://blog.8thlight.com/uncle-bob/archive.html) 번역: 오광신 (Email: kwangshin [&#8230;]]]></description>
				<content:encoded><![CDATA[<h4 style="text-align: center;">함수형 프로그래밍(Functional Programming) 세번째 이야기</h4>
<h2 style="text-align: center;">그럼 지금까지 해오던 것들을 다 바꾸어야 할까?</h2>
<p>&nbsp;</p>
<hr>
<p>3.&nbsp;함수형 프로그래밍 세번째 이야기: 그럼 지금까지 해오던 것들을 다 바꾸어야 할까?<br />
<a href="http://kwangshin.pe.kr/blog/2015/06/18/fp-e2-why-is-it-called-functional/" target="_blank" rel="noopener">2.&nbsp;함수형 프로그래밍 두번째 이야기: 왜 함수형이라고 부를까?</a><br />
<a title="함수형 프로그래밍(Functional Programming) 기초" href="http://kwangshin.pe.kr/blog/2013/01/21/%EB%B2%88%EC%97%AD-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8Dfunctional-programming-%EA%B8%B0%EC%B4%88/" target="_blank" rel="noopener">1.&nbsp;함수형 프로그래밍(Functional Programming) 기초</a></p>
<hr>
<p>원문: <a href="http://blog.8thlight.com/uncle-bob/2013/01/07/FPBE3-Do-the-rules-change.html" target="_blank" rel="noopener">FP Basics E3</a>&nbsp;| <a title="8th Light, Inc - Blog" href="http://blog.8thlight.com/" target="_blank" rel="noopener">Blog</a> |&nbsp;<a title="8th Light, Inc." href="http://www.8thlight.com/" target="_blank" rel="noopener">8th Light, Inc.<br />
</a><span style="line-height: 1.5;">저자: Robert C. Martin (Uncle Bob) (Blog: </span><a style="line-height: 1.5;" href="http://blog.8thlight.com/uncle-bob/archive.html" target="_blank" rel="noopener">http://blog.8thlight.com/uncle-bob/archive.html</a><span style="line-height: 1.5;">)<br />
</span><span style="line-height: 1.5;">번역: 오광신 (Email: kwangshin (at) gmail.com)</span></p>
<h2>그럼 지금까지 해오던 것들을 다 바꾸어야 할까?</h2>
<p>새로운 패러다임(paradigm: 한 시대의 사람들의 견해나 사고를 근본적으로 규정하고 있는 인식의 체계. 또는 다양한 사물에 대한 이론적인 틀이나 구조)으로 넘어가려고 할 때마다, 기존에 가지고 있던 규칙이나 습관들은 어떻게 해야 할까라는 문제에 마주치게 된다. 이런 경우 우리가 가지고 있는 규칙이나 습관들이 새로운 패러다임에서도 유효한지 아닌지를 먼저 각자 자신에게 질문을 던져보자. 예를 들어, 테스트 주도 개발(Test Driven Development)을 생각해보자. 테스트 주도 개발이 함수형 프로그래밍에서도 여전히 유효할까? 만약 여전히 유효하다면, 어떻게 함수형 프로그래밍에서 테스트 주도 개발을 실천할 수 있을까?</p>
<p>이러한 문제를 해결하는 가장 좋은 방법은 직접 해보는 것이다. 그럼 라인을 자동으로 넘겨주는 "줄 바꾸기(Word Wrap)"이라는 간단한 함수형 프로그램을 함께 만들어보자. 요구 사항은 아주 간단하다. 빈칸으로 구분되는 단어들로 이루어진 문자열과 한 라인의 최대 길이가 주어지면, 주어진 최대 길이보다 길이가 더 긴 라인이 없도록 문자열의 적절한 위치에 빈칸 대신 라인의 끝(line-end)을 의미하는 문자를 넣어주면 된다. 한 단어를 두 라인으로 나누는 것은 그 단어가 주어진 한 라인의 최대 길이보다 더 긴 경우에만 허용된다.</p>
<p>자, 이제 다음에 나오는 게티즈버그의 연설문(Gettysburg Address: 1863년 11월 19일 Lincoln 대통령이 Gettysburg에서 행한 연설; "government of the people, by the people, for the people"의 문구로 유명하다.)을 문자열로 사용해보도록 하자.</p>
<blockquote>
<p style="text-align: left;"><code>“Four score and seven years ago our fathers brought forth upon this continent a new nation conceived in liberty and dedicated to the proposition that all men are created equal”</code></p>
</blockquote>
<p>그리고 주어진 한 라인의 최대 길이가 10 이라면, 그 결과는 다음과 같다.</p>
<blockquote>
<p style="text-align: left;"><code>“Four score\nand seven\nyears ago\nour\nfathers\nbrought\nforth upon\nthis\ncontinent\na new\nnation\nconceived\nin liberty\nand\ndedicated\nto the\npropositio\nn that all\nmen are\ncreated\nequal”</code></p>
</blockquote>
<p>지금부터는 브라이언 매릭(Brian Marick)의 아주 훌륭한 테스트 프레임워크인 "Midje"(역자주: Midje는 Clojure에서 사용 가능한 테스트 프레임워크이고, <a href="https://github.com/marick/Midje" target="_blank" rel="noopener">https://github.com/marick/Midje</a> 에서 자세한 정보를 얻을 수 있다.)를 사용해서 테스트를 작성해보자. 다음과 같이 첫 번째 테스트를 작성하는 것으로 시작할 수 있다.</p>
<pre class="brush: scala; gutter: true">(facts
  (wrap &quot;&quot; 1) =&gt; &quot;&quot;)</pre>
<p>이 테스트는 <code>(wrap "" 1)</code> 라고 호출하면 <code>""</code>이 반환되어야 한다는 것을 의미한다. 이 테스트를 통과하려면 평소 테스트 주도 개발에서 사용하던 방식 그대로, <code>wrap</code> 함수를 정의하고, 원하는 결과가 나오도록 함수를 구현하면 된다.</p>
<pre class="brush: scala; gutter: true">(defn wrap [s n]
  &quot;&quot;)</pre>
<p>하지만 그 다음 테스트는 원하는 결과값을 그냥 그대로 구현하는 것만으로는 되지 않지만, 그렇다고 그리 어려운 함수는 아니다.</p>
<pre class="brush: groovy; gutter: true">(wrap &quot;x&quot; 1) =&gt; &quot;x&quot;</pre>
<pre class="brush: groovy; gutter: true">(defn wrap [s n] 
  s)</pre>
<p>다음 단계는 주어진 단어의 길이가 주어진 최대 길이보다 길다면 단어를 나누어야 하는 테스트이다.</p>
<pre class="brush: erlang; gutter: true">(wrap &quot;xx&quot; 1) =&gt; &quot;x\nx&quot;</pre>
<pre class="brush: groovy; gutter: true">(defn wrap [s n]
  (if (&lt;= (length s) n)
    s
    (str (subs s 0 n) &quot;\n&quot; (subs s n))))</pre>
<p>클로저(<a href="https://clojure.org/">Clojure</a>)에서 <code>if</code> 문은 <code>C</code>나 <code>java</code>에서의 <code>? :</code> 연산자와 동일하게 동작한다. <code>if</code> 문의 조건식이 참(true)이라면 첫번째 표현식(expression)을 반환하고, 그렇지 않으면 두번째 표현식을 반환한다. <code>subs</code> 함수는 굳이 설명하지 않아도 이해할 수 있으리라 생각되고, <code>Java</code>에서 <code>subString</code> 메서드(method)와 비슷하다. 마지막으로 <code>str</code> 함수는 인수(argument)로 주어지는 모든 문자열을 모두 연결해서 하나의 문자열로 반환한다.</p>
<p>다음 테스트는 동일한 작업을 반복해야 하는 경우이고, 재귀(recursion)를 적용해서 구현할 수 있다.</p>
<pre class="brush: groovy; gutter: true">(wrap &quot;xxx&quot; 1) =&gt; &quot;x\nx\nx&quot;</pre>
<pre class="brush: groovy; gutter: true">(defn wrap [s n]
  (if (&lt;= (count s) n)
    s
    (str (subs s 0 n) &quot;\n&quot; (wrap (subs s n) n))))</pre>
<p>다음 테스트는 새로운 라인 이후 바로 다음 문자가 공백인 경우를 확인한다. 새로운 라인이 공백으로 시작하는 경우를 방지하기 위해서, 새로운 라인이 공백으로 시작하는 경우에는 공백을 없애주도록 하자.&nbsp;</p>
<pre class="brush: groovy; gutter: true">(wrap &quot;x x&quot; 1) =&gt; &quot;x\nx&quot;</pre>
<pre class="brush: groovy; gutter: true">(defn wrap [s n]
  (if (&lt;= (count s) n)
    s
    (let [trailing-space (= \space (get s n))
          new-line-start (if trailing-space (inc n) n)
          head (subs s 0 n)
          tail (subs s new-line-start)]
      (str head &quot;\n&quot; (wrap tail n)))))</pre>
<p>클로저에서 <code>let</code>&nbsp;을 사용하면 이어져서 나오는 함수의 구현 부분에서 사용할 수 있는 값을 가지는 로컬 변수를 간단하게 만들 수 있다. 사실 이 값들은 켤코 변하지 않게 때문에, 변수라고 부르기 보다는 기호(symbol)나 이름이라고 부르는 것이 더 맞는 것 같다.</p>
<p>이름으로도 쉽게 알 수 있지만, <code>get</code>&nbsp;함수는 문자열에서 <code>n</code>&nbsp;번째 위치에 있는 문자를 반환해 준다. 그리고,&nbsp;<code>\space</code>&nbsp;는 클로저에서 사용되는 문자 상수로 공백을 나타낸다.</p>
<p>다음 테스트에서는 새로운 라인을 의미하는 문자열을 넣어주기 위해서 뒤에서부터 공백 문자를 찾아나가는 경우에 초점을 맞춰보도록 하자. 만약 이런 공백 문자를 찾을 수 없다면, 주어진 한 라인의 최대 길이 <code>n</code>&nbsp;보다 더 긴 단어가 존재한다는 의미이다. 만약 공백 문자를 찾았다면, 이 공백 문자 위치에서 새로운 라인을 시작하면 된다. 공백 문자를 뒤에서부터 찾기 위해서 <code>.lastIndexOf</code>&nbsp;함수를 사용할 수 있고, 이 함수는 <code>Java</code>&nbsp;의 문자열 라이브러리에 있는 메서드를 호출한다. 여기에서처럼 함수 이름의 맨 앞에 나오는&nbsp;<code>.</code>&nbsp;은 <code>java</code>&nbsp;에서 제공하는 메서드를 바로 호출하는 경우를 의미한다.</p>
<pre class="brush: groovy; gutter: true">(wrap &quot;x x&quot; 2) =&gt; &quot;x\nx&quot;</pre>
<pre class="brush: groovy; gutter: true">(defn wrap [s n]
  (if (&lt;= (count s) n)
    s
    (let [space-before-end (.lastIndexOf s &quot; &quot; n)
          this-line-end (if (neg? space-before-end) 
                            n 
                            space-before-end)
          trailing-space (= \space (get s this-line-end))
          new-line-start (if trailing-space 
                             (inc this-line-end) 
                             this-line-end)
          head (subs s 0 this-line-end)
          tail (subs s new-line-start)]
      (str head &quot;\n&quot; (wrap tail n)))))</pre>
<p>하나의 함수가 너무 길어지고 복잡해 져서 쉽게 이해할 수 없으니 리팩토링(refactoring)으로 조금 더 이해하기 쉬운 코드로 바꾸어 보자.</p>
<pre class="brush: groovy; gutter: true">(defn find-start-and-end [s n]
  (let [space-before-end (.lastIndexOf s &quot; &quot; n)
        line-end (if (neg? space-before-end) n space-before-end)
        trailing-space (= \space (get s line-end))
        line-start (if trailing-space (inc line-end) line-end)]
    [line-start line-end]))

(defn wrap [s n]
  (if (&lt;= (count s) n)
    s
    (let [[start end] (find-start-and-end s n)
          head (subs s 0 end)
          tail (subs s start)]
      (str head &quot;\n&quot; (wrap tail n)))))</pre>
<p>아마도 지금까지 만든 테스트로는 모든 경우의 수를 다 확인할 수 없고, 테스트가 더 있어야 될 것 같다고 느끼는 독자들이 많을 것이다. 만약 그렇게 느낀다면, 실패하는 테스트를 직접 찾아보기를 추천한다. 그러기 위해서는 먼저 위에서 소개한 간단해 보이는 6개의 테스트 케이스들을 더 세심하게 살펴보아야 한다. 위에서 설명한 것과 동일하게 테스트 케이스를 작성하는 것은&nbsp;대부분의 소프트웨어 엔지니어들에게 매우 어려운 일이다. 모든 케이스들을 고려하면서도, 이해하기 쉽고 적절한 순서를 가진, 가능한 한 적은 숫자의 테스트 케이스를 작성하는 것이 얼마나 어려우면서도 가치 있는 일인지 깨닫게 되기까지, 테스트 주도 개발에 매우 오랜 시간을 투자해야만 했다.</p>
<p>어쨋든 적어도 이 예제를 통해서, 다른 패러다임의 프로그래밍에서 적용되는 테스트 주도 개발의 원칙들이 함수형 프로그래밍에서도 동일하게 적용될 수 있음을 확인할 수 있다. 그러므로 새로운 패러다임의 함수형 프로그래밍을 시작한다고 우리가 가지고 있는 가치있고 소중한 것들을 버리는 우를 범하지 않기를 바란다. <em>테스트 주도 개발의 원칙들을 지켜나가자!</em></p>
<blockquote><p>역자 주 : 원문에 나오는 "Don’t throw out the baby with the bathwater."라는 문장은 직역하면 아기를 목욕시킨 후 목욕물을 버리려고 아기까지 버리지 말하는 의미이다. 즉, 상대적으로 덜 중요한 일을 하기 위해서 훨씬 더 중요한 것을 잃지 말라는 의미로 해석할 수 있다.</p></blockquote>
<p>아마도 몇몇 독자들은 이 구현 알고리즘은 함수형이라고 이야기할 수 없다고 불만을 가질 수도 있지만, 나는 함수형이라고 확신한다. 이 구현에서는 예기치 못한 부작용(side effect)을 찾을 수 없다. 또한 참조 투명성(representationally transparent) 원칙도 지키고 있다. 그리고 데이터 구조는 변하지 않는다. 따라서, 이 구현 알고리즘은 함수형임이 확실하다.</p>
<p>하지만, 함수형 프로그램에 경험이 있는 많은 독자들은 이 구현 알고리즘에 함수형의 한 가지 특징이 빠져 있다고 이야기할 것이다. 즉, 이 구현 알고리즘은 일련의 변환 과정으로 구성되어 있지 않다는 것이다.</p>
<p>정수들의 제곱을 구하는 프로그램을 다시 한번 살펴보자.</p>
<p><code>(take 25 (squares-of (integers))</code></p>
<p>이 코드가 함수형 패러다임을 완벽하게 따른다고 이야기 할 수 있는 있는 이유중에 하나는, 이 코드가 일련의 변환과정을 그대로 보여주고 있기 때문이다. 그 일련의 변환과정 중에서 첫번째는 바로&nbsp;<code>integers</code>&nbsp;함수이다. 인수로 아무것도 받고 있지 않지만, 1부터 시작하는 정수들이 조건을 만족해서 호출되는 경우에만 그 정수를 반환한다. 즉,&nbsp;아무것도 없는 상태를 정수로 변환한다고 이야기할 수 있다. 두번째 변환은 바로&nbsp;<code>squares-of</code>&nbsp;함수이다. 이 함수는 정수의 리스트를 정수의 제곱값을 가지는 리스트로 변환한다. 마지막 변환은 바로&nbsp;<code>take</code>&nbsp;함수이다. 이 함수는 아직 크기가 정해지지 않은, 즉 몇 개의 요소를 가질지 아직 알 수 없는 정수의 리스트를 정확하게 25개의 값을 가지는 리스트로 변환한다.</p>
<p>그렇다면, 이 "줄 바꾸기(Word Wrap)" 문제의 구현을 일련의 변환 과정이라는 함수형의 특징을 유지하도록 다시 작성할 수 있을까? 물론 그렇게 구현할 수 있다. 다음과 같은 함수를 함께 살펴보자.</p>
<pre class="brush: groovy; gutter: true">(defn wrap [s n]
  (join &quot;\n&quot; 
        (make-lines-up-to n 
                          (break-long-words n (split s #&quot; &quot;)))))</pre>
<p>정수들의 제곱을 구하는 프로그램을 분석했던 것과 동일한 방법으로 새롭게 구현한 "줄 바꾸기" 함수를 살펴보도록 하자. 즉, 가장 안쪽에 있는 함수에서 부터 시작해서 가장 바깥쪽에 있는 함수까지 따라가보자. 첫 번째 변환은 주어진 문자열을 단어의 배열로 나누는 것이다. 그 다음은 주어진 한 라인의 최대 길이 <code>n</code>&nbsp;보다 더 긴 단어를, 여러 단어로 쪼개서 한 라인의 최대 길이&nbsp;<code>n</code>&nbsp;보다 더 긴 단어가 없도록 만드는 것이다. 그 이후에는 앞에서부터 단어를 하나 하나 붙여서 한 라인을 만드는데, 한 라인의 길이가&nbsp;<code>n</code>&nbsp;보다 더 길어지는 경우에는 그 라인에 붙이지 않고 새로운 라인을 만들어서 단어를 계속 붙여 나간다. 마지막으로 모든 라인을 붙여서 하나의 라인으로 만드는데, 각 라인 사이에&nbsp;<code>‘\n’</code>&nbsp;을 붙여서 새로운 라인임을 나타내도록 하자. 어렵지 않죠?</p>
<p>이렇게 작성하고 나니 매우 간단하고 쉬워 보인다. 하지만, <code>wrap</code> 이라는 하나의 함수 뿐만 아니라 전체 프로그램의 구현을 보면 마음이 바뀔수도 있을 것 같다.&nbsp;</p>
<pre class="brush: groovy; gutter: true">(defn break-long-words [n words]
  (if (empty? words)
    []
    (let [word (first words)]
      (if (&gt;= n (count word))
        (cons word (break-long-words n (rest words)))
        (cons (subs word 0 n) 
              (break-long-words 
                 n 
                 (cons (subs word n) (rest words))))))))

(defn make-lines-up-to
  ([n words]
    (make-lines-up-to n words [] []))
  ([n words line lines]
    (if (empty? words)
      (conj lines (join &quot; &quot; line))
      (let [new-line (conj line (first words))]
        (if (&gt;= n (count (join &quot; &quot; new-line)))
          (make-lines-up-to n (rest words) new-line lines)
          (make-lines-up-to n 
                            words 
                            [] 
                            (conj lines (join &quot; &quot; line))))))))

(defn wrap [s n]
  (join &quot;\n&quot; (make-lines-up-to 
                n 
                (break-long-words n (split s #&quot; &quot;)))))</pre>
<p>많은 사람들이 나를 경험이 많고 기술이 뛰어난 함수형 프로그래머로 인정할 수 없으리라 생각한다. 아마도 그들의 생각이 맞을 것이다. 따라서 이 프로그램도 내 주장을 뒷받침하기에 턱없이 부족할 수도 있다. 하지만 나는 "줄 바꾸기" 문제에 대한 나의 첫번째 해결 방법이 바로 위에서 보여준 두번째 해결 방법보다 코드의 품질이 떨어진다고 생각하지 않는다. 함수형의 특징인 일련의 변환과정을 가지는 것이 나쁘다는 이야기는 절대 아니다. 그 반대로 함수형의 특징인 일련의 변환과정을 가지는 것은 매우 효과적이고 큰 도움이 된다고 생각한다. 이것에 대해서는 이후에 더 자세하고 깊게 공부해 보도록 하자. 내가 여기에서 강조하고 싶은 것은 모든 함수형 프로그램이 꼭 일련의 변환과정을 무조건적으로 가질 필요는 없다는 것이다. 오랜 시간 사용된 "더 간결하고 단순할수록, 더 낫다."라는 법칙은 여기에서도 적용된다. 여기에서 사용하는 "줄 바꾸기" 문제를 해결하는 알고리즘의 경우에는, 적어도 내가 보기에는 (또한 많은 사람들이 생각하는 것과 크게 다르지도 않고) 일련의 변환과정을 가지는 해결책이 최선의 선택은 아닌 것 같다.&nbsp;</p>
<p>그런데 위에서 소개한 변환과정을 가지는 해결 방법을 구현할 때에서는 테스트 주도 개발을 따르지 않았다. 테스트 주도 개발 원칙을 적용하면서 구현할 수도 있을 것 같았지만, 대신 많은 함수형 프로그래머들이 더 선호하는 방법을 사용했다. 알고리즘을 오랜 시간동안 고민하고 구현한 후에 전체적으로 동작 하는지 확인하기 위해서 콘솔에서 직접 테스트를 진행했다. (보통&nbsp;이런 방법은&nbsp;<code>REPL</code>&nbsp;이라고 불리고, "Read Evaluate Print Loop"의 약자이다.) 이 방법을 적용해서 개발을 진행했을 때, 테스트 주도 개발을 사용했을 때보다 3배 정도 더 많은 시간이 소요된 것 같다. 디버깅을 통해서 틀린 부분이 어디인지 알아내는 것이 쉽지 않았고, 그래서 어쩔 수 없이 수 많은 정보들을 화면에 출력해서 하나 하나 확인해야 했으며, 프로그램이 무한 재귀 루프에 빠져서 화면에는 아예 응답도 없는 경우들도 수 없이 만났다. 다시 말해서 개발하는 동안 여러 가지 어려움 속에 시달렸고, 결코 이 방법을 추천하고 싶지 않다.</p>
<p>지금까지의 이야기들을 요약하자면, 오랜 시간동안 수 없이 사용되었던 "더 간결하고 단순할수록, 더 낫다."라는 법칙은 아직도 유효하다. 함수형 프로그래밍은 패러다임의 변화이며 매우 중요한 변화임에는 틀림없다. 하지만 모든 것을 다 바꾸는 것은 결코 아니다. 프로그래밍은 여전히 프로그래밍이고, 원칙과 방법론도 여전히 원칙과 방법론이다. 테스트 주도 개발은 다른 스타일의 프로그래밍에서도 효과적으로 사용된 것처럼, 함수형 프로그래밍에서도 그대로 적용될 수 있고, 동일한 효과를 가져다 준다. 아마도 함수형 프로그래밍을 받아들이면서 버려야 하는 몇몇 규칙들이 타나날 수도 있지만, 아직까지는 그런 경우를 만난 적이 없다.</p>
]]></content:encoded>
			<wfw:commentRss>http://kwangshin.pe.kr/blog/2018/11/25/fp-e3-do-all-the-rules-change/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">1033</post-id>	</item>
		<item>
		<title>Google I/O &#8217;18 Keynote &#8211; 구글 살아있네!</title>
		<link>http://kwangshin.pe.kr/blog/2018/09/09/google-io-18-keynote-we-are-google/</link>
		<comments>http://kwangshin.pe.kr/blog/2018/09/09/google-io-18-keynote-we-are-google/#respond</comments>
		<pubDate>Sun, 09 Sep 2018 13:36:15 +0000</pubDate>
		<dc:creator><![CDATA[Kwangshin]]></dc:creator>
				<category><![CDATA[Software Development]]></category>
		<category><![CDATA[Technology]]></category>
		<category><![CDATA[2018 Google I/O Keynote]]></category>
		<category><![CDATA[dogfooding]]></category>
		<category><![CDATA[Google]]></category>
		<category><![CDATA[Google I/O]]></category>
		<category><![CDATA[구글]]></category>
		<category><![CDATA[구글 I/O]]></category>

		<guid isPermaLink="false">http://kwangshin.pe.kr/blog/?p=1124</guid>
		<description><![CDATA[매년 열리는 Google I/O는 소프트웨어 개발자라면 꼭 한번 가보고 싶어하는 개발자를 위한 행사이다. Google I/O에 대한 더 자세한 정보는 다음 링크에서 얻을 수 있다. https://events.google.com/io/ 2018년 Google I/O는 5월 8일부터 10일까지 개최되었는데, 정말 많은 소식들과 새로운 서비스/기술들이 소개되었다. 사실 이 글을 작성하기 시작한 것은 5월이었는데, 이제야 마무리를 짓게 되었다. 이미 모든 세션을 유튜브에서 볼 수 [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>매년 열리는 Google I/O는 소프트웨어 개발자라면 꼭 한번 가보고 싶어하는 개발자를 위한 행사이다. Google I/O에 대한 더 자세한 정보는 다음 링크에서 얻을 수 있다.</p>
<p style="text-align: center;"><a href="https://events.google.com/io/"><img class="aligncenter wp-image-1125" src="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/09/Google-IO-18-1024x268.png" alt="" width="700" height="183" srcset="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/09/Google-IO-18-1024x268.png 1024w, http://kwangshin.pe.kr/blog/wp-content/uploads/2018/09/Google-IO-18-300x79.png 300w, http://kwangshin.pe.kr/blog/wp-content/uploads/2018/09/Google-IO-18-768x201.png 768w" sizes="(max-width: 700px) 100vw, 700px" /></a><a href="https://events.google.com/io/">https://events.google.com/io/</a></p>
<p>2018년 Google I/O는 5월 8일부터 10일까지 개최되었는데, 정말 많은 소식들과 새로운 서비스/기술들이 소개되었다. 사실 이 글을 작성하기 시작한 것은 5월이었는데, 이제야 마무리를 짓게 되었다.</p>
<p>이미 모든 세션을 유튜브에서 볼 수 있고, 다음 링크의 유튜브 플레이리스트를 통해서 모든 세션을 한 곳에서 볼 수 있다.&nbsp;</p>
<p style="text-align: center;"><a href="https://www.youtube.com/playlist?list=PLOU2XLYxmsIInFRc3M44HUTQc3b_YJ4-Y"><strong>유튜브 - Google I/O 2018 - All Sessions Playlist</strong></a></p>
<p><iframe class='youtube-player' type='text/html' width='800' height='450' src='https://www.youtube.com/embed/videoseries?list=PLOU2XLYxmsIInFRc3M44HUTQc3b_YJ4-Y&#038;hl=en_US' allowfullscreen='true' style='border:0;'></iframe></p>
<p>&nbsp;</p>
<p>이 글에서는 2018 Google I/O Keynote를 보고, 다른 리뷰들에서는 관심을 받지 못했지만, 개인적으로 느낀 부분들을 중심으로 소개하고자 한다.</p>
<p>우선 1시간 46분의 Keynote를 보고 난 후, 총평은...</p>
<p style="text-align: center;"><strong>"구글 살아있네!"</strong></p>
<p>이다. 사실 "가지 많은 나무에 바람 잘 날 없다."라는 속담처럼, 기업이 커지면 커질수록 수 많은 이야기들과 논쟁거리들이 나오기 마련이다. 그럼에도 불구하고 다음의 세 가지 포인트만 봐도 구글은 앞으로도 꾸준히 잘 해 나갈 것이라 믿는다.</p>
<ol>
<li><strong>유머를 잃지 않으면서 자기 자랑하기!</strong></li>
<li><strong>구글은 항상 약자와 소수자를 잊지 않아요!</strong></li>
<li><strong>우리 아직도 <a href="https://en.wikipedia.org/wiki/Eating_your_own_dog_food">dogfooding</a> 하고 있어요!</strong></li>
</ol>
<p>&nbsp;하나씩 좀 더 자세히 살펴보도록 하자.</p>
<p><strong>1. 유머를 잃지 않으면서 자기 자랑하기!</strong></p>
<p>구글은 처음 시작할 때부터 즐겁게 일하는 것을 매우 강조했다. 어떻게 보면 즐겁게 일하는 것이, 생산성을 높일 수 있다는 믿음이 회사를 지탱하는 힘이 되었을지도 모른다. 요즘에 여러가지 이슈들이 문제화 되고 있기는 하지만, 다시 한번 유머를 잃지 않았음을 강조하면서, 거기에 "구글은 고객의 아주 사소한 소리에도 귀 기울이고 있어요!" 라는 메시지를 담은 이야기로 키노트 시작 43초, 즉 인사 후에 바로 강조하고 있다.</p>
<p><iframe class='youtube-player' type='text/html' width='800' height='450' src='https://www.youtube.com/embed/ogfYd705cRs?version=3&#038;rel=1&#038;fs=1&#038;autohide=2&#038;showsearch=0&#038;showinfo=1&#038;iv_load_policy=1&#038;start=43&#038;wmode=transparent' allowfullscreen='true' style='border:0;'></iframe></p>
<p>사실 키노트의 시작은 매우 중요하고 꼭 강조하고 싶은 이야기를 꺼내는 부분인데, 구글 CEO인 Sundar Pichai는 구글 서비스에 심각한 버그가 있다고 하면서, 다음과 같은 이모티콘으로 2018 Google I/O Keynote를 시작한다.</p>
<p><img class="aligncenter wp-image-1127" src="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/09/Burger-Emoticon-300x280.png" alt="" width="200" height="187" srcset="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/09/Burger-Emoticon-300x280.png 300w, http://kwangshin.pe.kr/blog/wp-content/uploads/2018/09/Burger-Emoticon.png 366w" sizes="(max-width: 200px) 100vw, 200px" /></p>
<p>무엇이 문제인지 눈치채신 분들이 있을까? 그렇다 바로 치즈 버그이다. 보통 햄버거를 만들 때, 저렇게 빵 위에 바로 치즈를 올리지 않는다. 어떻게 보면 아주 사소한 부분인데, 구글 서비스 사용자들의 의견을 받아들여서 다음과 같이 패티위에 치즈를 얻는 이모티콘으로 바꾸었다고 한다.</p>
<p><img class="aligncenter wp-image-1126" src="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/09/Burger-Before-After-Emoticon-300x152.png" alt="" width="400" height="203" srcset="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/09/Burger-Before-After-Emoticon-300x152.png 300w, http://kwangshin.pe.kr/blog/wp-content/uploads/2018/09/Burger-Before-After-Emoticon-768x390.png 768w, http://kwangshin.pe.kr/blog/wp-content/uploads/2018/09/Burger-Before-After-Emoticon.png 874w" sizes="(max-width: 400px) 100vw, 400px" /></p>
<p>그리고 이 버그를 수정하다가 다음의 맥주 이모티콘도 발견했다고 보여준다.</p>
<p><img class="aligncenter wp-image-1129" src="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/09/Beer-Emoticon-209x300.png" alt="" width="139" height="200" srcset="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/09/Beer-Emoticon-209x300.png 209w, http://kwangshin.pe.kr/blog/wp-content/uploads/2018/09/Beer-Emoticon.png 312w" sizes="(max-width: 139px) 100vw, 139px" /></p>
<p>그렇다, 맥주가 잔에 다 채워지지도 않았는데, 맥주 거품이 넘치고 있다. 이 맥주 이모티콘도 다음과 같이 수정했다고 한다.</p>
<p><img class="aligncenter wp-image-1128" src="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/09/Beer-Before-After-Emoticon-300x159.png" alt="" width="377" height="200" srcset="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/09/Beer-Before-After-Emoticon-300x159.png 300w, http://kwangshin.pe.kr/blog/wp-content/uploads/2018/09/Beer-Before-After-Emoticon-768x408.png 768w, http://kwangshin.pe.kr/blog/wp-content/uploads/2018/09/Beer-Before-After-Emoticon.png 848w" sizes="(max-width: 377px) 100vw, 377px" /></p>
<p>사실 별 거 아닐 수도 있고, 그냥 유머로 치부할 수도 있지만, 개인적으로는 아직 우리는 유머로 Keynote를 시작할 수 있고, 고객의 아주 사소한 목소리에도 귀를 기울이고 있다는 구글의 자신감이 느낄 수 있었다.</p>
<p><strong>2.구글은 항상 약자와 소수자를 잊지 않아요!</strong></p>
<p>2018은 머신 러닝(Machine Learning)으로 시작되는 인공 지능(Artificial Intelligence)이 모든 기술의 출발점에서 함께하는 해라고 해도 과장이 아닌 것 같다. 역시나 구글은 맨 앞에 서서 함께 나아갈 수 있는 길을 만들면서, 인공 지능 기술들을 이끌어 나가고 있다. 하지만, 그 이전에 다음과 같은 구글은 핵심 미션(core mission)을 다시 한번 강조한다.</p>
<blockquote><p>"That's the spirit with which we're approaching our core mission - to make information more useful, accessible and beneficial to society."</p>
<p>"이것이 바로 우리 사회가 정보를 더 유용하게 사용하고, 정보에 더 쉽게 다가갈 수 있고, 정보를 통해 더 많은 혜택을 받을 수 있도록 도와주는 우리의 핵심 미션을 담고 있는 정신이다."</p></blockquote>
<p>그렇다, 아직 구글은 <a href="https://www.google.com/about/">미션(mission)</a>을 잊어버리지 않았다. 어떤 분들은 미션을 만들어 놓기만 하면 무슨 소용이냐고 이야기할 수도 있다. 사실 나도 구글은 이 미션을 항상 기억하고 지키고 있는지 확신할 수 없다. 하지만, 이런 미션이 있는 기업과 없는 기업과는 시작하는 지점부터가 다르다. 이런 미션을 가지고 있는 구글을 응원한다.</p>
<p>그리고 난 후에, 인공 지능을 통해서 헬스케어를 어떻게 발전시켜 나가고 있는지 이야기한다. 이 부분에서도 인공 지능이 의사나 간호사를 대신하는 것이 아니라, 의사와 간호사에게 어떤 도움을 줄 수 있는지, 어떻게 협력할 수 있는지에 포커스를 맞추고 이야기를 이끌어 나가는 것도 매우 긍정적인 신호라고 본다.</p>
<p>또한 거기에서 더 나아가 모스 부호(<a href="https://en.wikipedia.org/wiki/Morse_code">Morse Code</a>)로 의소소통하는 Tania를 위해서 구글 키보드에 모스 부호로 입력이 가능하게 구현하는 프로젝트를 진행한 이야기를 해 주고, Tania의 가족을 직접 Google I/O 2018에 초대했다. 사실 이 프로젝트 자체도 중요하겠지만, 그 보다 더 중요한 것은 구글이 앞으로도 약자와 소수자들도 정보와 데이터를 동일하게 사용하고, 그 혜택도 동일하게 누릴 수 있도록 끊임없이 지원하겠다는 메시지가 더 중요한 것 같다.</p>
<p>구글이 미션을 잊지 않고 끊임없이 약자와 소수자들에게 정보를 들고 먼저 찾아가기를 기대해본다.</p>
<p><strong>3.우리 아직도 dogfooding 하고 있어요!</strong></p>
<p>다음은 아마도 가장 많은 사용자들을 보유하고 있는 구글 서비스가 아닐까 싶다. 바로 <a href="https://www.google.com/maps/">구글 지도(Google Maps)</a>이다. 사실 소프트웨어 개발자로서 이 부분에서 가장 놀랬던 것 같다. 아니, 내가 느끼는 부족한 부분을 자신들이 직접 사용해 보면서 더 발전시키다니! 소프트웨어 개발 분야에서는 <a href="https://en.wikipedia.org/wiki/Eating_your_own_dog_food">dogfooding</a>(도그 푸딩) 이라는 이야기를 한다. 자신들이 만드는 서비스나 제품을 직접 사용해 보는 것이다. 사실 이게 말은 쉬운데 잘 되지 않는다. 직접 사용해 보는 것은 가능할 때도 있는데, 자신이 사용하기에 불편했던 부분들을 향상시키는 것은, 서비스나 제품이 커지면 커질수록 더 어려워진다.</p>
<p>개인적으로 구글 지도의 가장 불편했던 점 하나가, 내가 어디에 있는지는 지도에 나오는데, 내가 향하고 있는 방향이 어디인지 확인하는 것이 참 어렵다. 예전에는 어떻게든 어디로 가야 하는지 지도의 모양을 보거나 건물을 보고 예측하는데 시간을 썼지만, 언젠가부터 먼저 어디로든 빨리 움직여 보고, 현재 내 위치가 어떻게 변하는지 확인하고 난 후에 내가 가야할 방향을 다시 찾는 방법을 사용했다.&nbsp;</p>
<p>그런데 놀랍게도 동일한 스토리를 2018 Google I/O Keynote 에서 듣게 되다니...</p>
<p><iframe class='youtube-player' type='text/html' width='800' height='450' src='https://www.youtube.com/embed/ogfYd705cRs?version=3&#038;rel=1&#038;fs=1&#038;autohide=2&#038;showsearch=0&#038;showinfo=1&#038;iv_load_policy=1&#038;start=5130&#038;wmode=transparent' allowfullscreen='true' style='border:0;'></iframe></p>
<p>이 부분에서 많은 참석자들이 함께 웃는 걸로 봐서 나 뿐만 아니라 수 많은 사람들이 동일한 불편함을 겪고 있었나 보다. 이러한 불편함을 카메라와 컴퓨터 비전을 활용해서 훌륭하게 해결했다. (사실 나도 아직 사용해보지는 못했다.) 이 부분에서 많은 박수와 함성이 쏟아져 나온다. 이렇게 훌륭하게 해결한 것도 놀랍지만, 자신들의 서비스나 제품의 불편한 상황을 알고 있었다는 것에 점수를 더 주고 싶다. 사용자의 피드백을 통해서일 수도 있지만, 웬지 구글 내부에서도 자신들의 서비스나 제품을 많이 사용하면서 향상시키려고 노력하고 있다는 느낌을 받았다. (사실 구글 지도의 경우 이제는 없어서는 안되는 서비스 중 하나이기는 하다.)</p>
<p>구글이 앞으로도 자신들의 미션을 수행하기 위해서 꾸준히 시나브로(모르는&nbsp;사이에&nbsp;조금씩&nbsp;조금씩) 발전하기를 기대해 본다.</p>
]]></content:encoded>
			<wfw:commentRss>http://kwangshin.pe.kr/blog/2018/09/09/google-io-18-keynote-we-are-google/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">1124</post-id>	</item>
		<item>
		<title>Reactive Architecture: Introduction to Reactive Systems 코스 소개</title>
		<link>http://kwangshin.pe.kr/blog/2018/08/18/reactive-architecture-introduction-to-reactive-systems-free-course/</link>
		<comments>http://kwangshin.pe.kr/blog/2018/08/18/reactive-architecture-introduction-to-reactive-systems-free-course/#respond</comments>
		<pubDate>Sat, 18 Aug 2018 02:54:47 +0000</pubDate>
		<dc:creator><![CDATA[Kwangshin]]></dc:creator>
				<category><![CDATA[Reactive Programming]]></category>
		<category><![CDATA[Reactive System]]></category>
		<category><![CDATA[Software Development]]></category>
		<category><![CDATA[Technology]]></category>
		<category><![CDATA[Actor Model]]></category>
		<category><![CDATA[Akka]]></category>
		<category><![CDATA[Reactive Architecture]]></category>
		<category><![CDATA[Reactive Manifesto]]></category>
		<category><![CDATA[리액티브 선언문]]></category>
		<category><![CDATA[리액티브 시스템]]></category>
		<category><![CDATA[리액티브 아키텍처]]></category>
		<category><![CDATA[리액티브 프로그래밍]]></category>
		<category><![CDATA[아카]]></category>
		<category><![CDATA[액터 모델]]></category>

		<guid isPermaLink="false">http://kwangshin.pe.kr/blog/?p=1120</guid>
		<description><![CDATA[2018년 8월 7일에 Lightbend로부터 다음과 같은 제목의 이메일을 받았다. New Free Course: “Reactive Architecture”, taken at your own pace 리액티브 아키텍처(Reactive Architecture)를 공부할 수 있는 온라인 강좌이고, 더 자세한 정보는 다음 블로그에서 확인할 수 있다. https://www.lightbend.com/blog/learn-reactive-architecture-for-free-at-your-own-pace 리액티브 아기텍처 / 시스템에 관심이 있는 분들에게 추천하고 싶다. 사실 코스 자체가 소개하는 코스이다 보니 실제 어떻게(How) 리액티브 시스템을 [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>2018년 8월 7일에 Lightbend로부터 다음과 같은 제목의 이메일을 받았다.</p>
<p><strong>New Free Course: “Reactive Architecture”, taken at your own pace</strong></p>
<p>리액티브 아키텍처(Reactive Architecture)를 공부할 수 있는 온라인 강좌이고, 더 자세한 정보는 다음 블로그에서 확인할 수 있다.</p>
<p><a href="https://www.lightbend.com/blog/learn-reactive-architecture-for-free-at-your-own-pace"><img class="aligncenter wp-image-1121 size-full" src="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/08/Reactive-Architecture-Onine-Course-e1534560692195.png" alt="" width="600" height="307"></a></p>
<p style="text-align: center;"><a href="https://www.lightbend.com/blog/learn-reactive-architecture-for-free-at-your-own-pace">https://www.lightbend.com/blog/learn-reactive-architecture-for-free-at-your-own-pace</a></p>
<p>리액티브 아기텍처 / 시스템에 관심이 있는 분들에게 추천하고 싶다. 사실 코스 자체가 소개하는 코스이다 보니 실제 어떻게(How) 리액티브 시스템을 구현해야 하는지에 대한 이야기는 없다. 다만 나침반과 같은 역할, 즉 리액티브 아키텍처 / 시스템이 무엇이고, 어디로 가야 하는지 간단하면서도 실제 예제(리액티브 BBQ 레스토랑)와 함께 설명해 준다.</p>
<p>리액티브 시스템을 소개하는데 역시나 <a href="https://www.reactivemanifesto.org/ko">리액티브 선언문</a>(<a href="https://www.reactivemanifesto.org/">Reactive Manifesto</a>)이 빠질 수 없다. 리엑트비 선언문을 읽고 더 자세하게 알고 싶으신 분들에게도 이 강좌를 추천하고 싶다.&nbsp;</p>
<p>개인적으로 다음과 같은 두 가지가 기억에 남는다.</p>
<p><strong>1. 확장성(Scalability)에서 유연성(Elastic)으로...</strong></p>
<p>초기버전의 리액티브 선언문에서는 "유연성"이 아니라 "확장성"이었다고 한다. 하지만, 확장성이라고 하면 보통 요청이 더 늘어났을 경우만을 생각하기 때문에, 요청이 줄어들었을 경우에도 유연하게 대응해야 한다는 의미에서 유연성으로 바뀌었다고 한다.</p>
<p>사실 요즘 클라우드 서비스들은 요청에 맞춰 리소스들을 유연하게 더 많이 할당하거나 줄이거나 하는 서비스들을 제공하는 것으로 알고 있다. 하지만 실제 서비스를 개발할 때, 이 유연성이 가장 어려운 부분이 아닐까 싶다. 구현하기 어려운 부분들도 있지만, 구현으로 인하여 얻는 이득이 들어가는 노력에 비하여 크지 않은 경우도 많다. 클라우드 서비스를 사용하지 않는 경우라면, 요청이 줄어들어서 남는 리소스들을 다른 서비스에 사용하는 것이 어렵거나 불가능 해서, 어차피 구현을 한다 해도 유연하게 대응해서 남는 리소스들을 아무도 사용하지 못하는 경우들이 많다.</p>
<p>서비스나 환경에 맞게 유연하게 잘 대응하는 것도 개발자나 개발팀의 유연성이 아닐까 싶다.</p>
<p><strong>2. 리액티브 시스템과 리액티브 프로그래밍</strong></p>
<p>흔히들 많이들 헷갈려하는 리액티브 시스템과 리액티브 프로그래밍에 대해서도 설명해 준다.</p>
<p>간단하게 말하면 리액티브 시스템을 구축하는 방법에는 여러 다른 방법들이 존재한다. 그 중에 하나가 리액티브 프로그래밍이다. 당연히 리액티브 프로그래밍을 사용하여 리액티브 시스템을 구축할 수 있지만, 리액티브 프로그래밍을 사용한다고 해서 무조건 리액티브 시스템이 되는 것은 아니다.</p>
<p>리액티브 시스템을 구축할 수 있는 방법 중에 하나인 액터 모델(<a href="https://en.wikipedia.org/wiki/Actor_model">Actor Model</a>)과 액터 모델을 구현한 아카(<a href="https://akka.io/">Akka</a>)에 대한 소개도 나옵니다.</p>
<p>강좌마다 퀴즈도 있어서 공부한 내용을 확인하는데 좋습니다. 모든 강의를 다 마치고 퀴즈와 마지막 시험까지 통과하면 다음과 같은 수료증도 받을 수 있습니다.</p>
<p><img class="aligncenter wp-image-1122 size-full" src="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/08/Reactive-Architecture-Certification-e1534560721780.png" alt="" width="600" height="385"></p>
<p style="text-align: center;"><a href="https://courses.cognitiveclass.ai/certificates/33a95fbab8e94666b872852694d0a14d">https://courses.cognitiveclass.ai/certificates/33a95fbab8e94666b872852694d0a14d</a></p>
<p>다음에는 액터 모델과 아카에 대한 강의가 나오기를 기대해 봅니다.</p>
<p><strong>관련글</strong></p>
<p><a href="http://kwangshin.pe.kr/blog/2017/10/14/what-is-reactvie-system/">리액티브(Reactive) 시스템이란?</a></p>
]]></content:encoded>
			<wfw:commentRss>http://kwangshin.pe.kr/blog/2018/08/18/reactive-architecture-introduction-to-reactive-systems-free-course/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">1120</post-id>	</item>
		<item>
		<title>[숭실대 컴타임즈] RAKUTEN 96학번 오광신 동문 인터뷰</title>
		<link>http://kwangshin.pe.kr/blog/2018/07/06/soongsil-comtimes-96-interview/</link>
		<comments>http://kwangshin.pe.kr/blog/2018/07/06/soongsil-comtimes-96-interview/#respond</comments>
		<pubDate>Thu, 05 Jul 2018 16:03:18 +0000</pubDate>
		<dc:creator><![CDATA[Kwangshin]]></dc:creator>
				<category><![CDATA[Software Development]]></category>
		<category><![CDATA[긍정적인 사고]]></category>
		<category><![CDATA[Comtimes]]></category>
		<category><![CDATA[Soongsil University]]></category>
		<category><![CDATA[숭실대학교]]></category>
		<category><![CDATA[컴타임즈]]></category>

		<guid isPermaLink="false">http://kwangshin.pe.kr/blog/?p=1112</guid>
		<description><![CDATA[지난 5월에 한국에 들어갔을 때, 우연히 친구로부터 연결된 숭실대학교 컴퓨터 학부 웹진, 컴타임즈와 인터뷰를 가졌습니다. 부족하지만 후배들에게 조금이라도 도움이 되었으면 하는 마음에서 한국 방문 시기에 인터뷰를 진행했습니다. 우선 인터뷰는 다음 링크에서 확인할 수 있습니다. (PS. 이미 컴타임즈 후배들에게도 이야기 했지만, 숭실대학교 컴퓨터 학부 웹진인데 아직도 모바일 대응이 안 되는 페이지라니...ㅠ.ㅠ 빨리 빨리 작업해서 모바일에서도 쉽게 [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>지난 5월에 한국에 들어갔을 때, 우연히 친구로부터 연결된 숭실대학교 컴퓨터 학부 웹진, 컴타임즈와 인터뷰를 가졌습니다. 부족하지만 후배들에게 조금이라도 도움이 되었으면 하는 마음에서 한국 방문 시기에 인터뷰를 진행했습니다.</p>
<p>우선 인터뷰는 다음 링크에서 확인할 수 있습니다.</p>
<p>(PS. 이미 컴타임즈 후배들에게도 이야기 했지만, 숭실대학교 컴퓨터 학부 웹진인데 아직도 모바일 대응이 안 되는 페이지라니...ㅠ.ㅠ 빨리 빨리 작업해서 모바일에서도 쉽게 읽을 수 있는 사이트가 되기를...)</p>
<p><a href="http://www.comtimes.kr/news/927"><img class=" aligncenter" src="http://www.comtimes.kr/paper/data/news/images/2018/05/323_L_1527065280.jpg" width="464" height="309"></a></p>
<p style="text-align: center;"><a href="http://www.comtimes.kr/news/927">http://www.comtimes.kr/news/927</a>&nbsp;</p>
<p>인터뷰 마지막에도 나오지만, 처음 개발을 시작하시는 분들과 그 시작을 준비하시는 분들에게는 다음과 같은 이야기를 해 드리고 싶다.</p>
<h3>1. 나만의 브랜드를 만들어서 알리자!</h3>
<p>먼저, 자신만의 브랜드를 만들어서 알리는 것이 중요합니다. 사실 조금은 오래된 연구 결과이기는 하지만, 1996년 소개된 Harvey J.Coleman의 <a href="https://www.mondofrank.com/pie/">PIE(Performance, Image and Exposure) Model</a>에 따르면, 직장에서의 성공은 자신의 능력 즉 퍼포먼스(Performance)도 중요하지만, 그보다 더 중요한 것은 자신의 이미지(Image)를 만들어 나가는 것, 그리고 자신의 성과를 여러 방법으로 더 많은 사람에게 노출(Exposure) 시키는 것이 직장에서의 성공에 더 큰 영향을 준다고 합니다. 그의 책에 따르면, 직장에서의 성공에 미치는 요인으로, 능력/퍼포먼스는 10%, 이미지는 30%, 그리고 노출은 60%의 영향력을 가지고 있다고 합니다. 아무리 능력/퍼포먼스가 좋아도, 자신의 팀원들만이 그 사실을 알고 있다면, 회사 내에서 좋은 평가를 받기에는 한계가 있겠죠. 그러니, 학부생 시절부터 자신만의 브랜드를 만들고, 이를 알릴 수 있으면 좋겠습니다. 소프트웨어 엔지니어로서 자신을 알리는 좋은 방법은 ‘<a href="https://github.com/">GitHub</a>’와 같은 공간에서, 오픈소스 커뮤니티를 활용하여 자신의 코드를 다른 사람들은 어떻게 생각하는지 의견도 들어보고, 다른 사람의 프로젝트에 리뷰도 달며 나를 드러내는 것은 아주 훌륭한 전략입니다.</p>
<h3>2. 끊임없이 상상하세요!</h3>
<p>그리고 루이스 캐럴(Lewis Caroll)은 자신의 책 ‘이상한 나라의 앨리스’에서 “상상은 현실과 맞설 수 있는 유일한 무기다”라는 이야기를 합니다. 모든 사람은 물리적 환경의 제약과 시간적 제약으로 무엇인가를 직접 경험하는 것에는 한계가 있지만, 상상에는 이러한 한계가 없습니다. 저 같은 경우에도 소프트웨어 엔지니어로 해외에 나가서 일하는 상상을 계속해서 해왔었고, 실제로 그런 기회가 주어졌을 때 그 상상들이 큰 도움이 되었던 것 같습니다. 또한, 지금도 전 세계에 있는 사람들에게 도움이 되는 더 가치 있는 제품이나 프로젝트에서 소프트웨어 엔지니어로 열심히 일을 하는 저를 상상해보고 있습니다. 상상은 시간과 장소에 제약이 없으니, 앞으로의 나의 모습을 생각해보는 것만으로도 많은 도움이 될 것이라 생각합니다. 더 큰 꿈을 가지고, 그 꿈을 이루어 나가는 자신을 상상해 보세요! 머지않아 그 꿈을 향한 첫걸음이 시작될 것입니다.</p>
<h3>3. 의사소통을 위한 도구로서의 영어!</h3>
<p>마지막으로, 영어에 두려움과 걱정을 가지고 있는 분들에게 영어는 의사소통을 위한 도구일 뿐이라는 것을 말해주고 싶습니다. 온라인 교육 플랫폼 유데미(<a href="https://www.udemy.com/" class="broken_link">Udemy</a>)의 강의 중 “<a href="https://www.udemy.com/esl-understand-business-english/" class="broken_link">Help! I’m A Native Speaker But No One Understands My English</a>”라는 강의를 2만 명 이상의 학생들이 수강하고 있을 정도로, 최근에는 영어가 모국어인 사람들을 대상으로 세계의 다양한 사람들과 의사소통하기 위한 영어를 가르치는 강의가 개설되고 많은 사람들이 수강하고 있습니다. 영어를 모국어로 사용하는 사람들조차 세계의 다양한 사람들과 의사소통이 안되어 공부를 한다는 의미입니다. 영어에 대한 두려움을 없애고, 영어를 원어민과 같은 발음과 표현으로 유창하게 하려고 너무 많은 시간을 투자하는 것보다는, 상대방과의 소통에 초점을 맞추고 의사소통의 도구로서 영어에 접근하는 것을 추천합니다.</p>
]]></content:encoded>
			<wfw:commentRss>http://kwangshin.pe.kr/blog/2018/07/06/soongsil-comtimes-96-interview/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">1112</post-id>	</item>
		<item>
		<title>소프트웨어 개발의 생산성, 그 어려움과 도전&#8230;</title>
		<link>http://kwangshin.pe.kr/blog/2018/06/26/software-development-productivity-difficulties-and-challanges/</link>
		<comments>http://kwangshin.pe.kr/blog/2018/06/26/software-development-productivity-difficulties-and-challanges/#comments</comments>
		<pubDate>Mon, 25 Jun 2018 16:04:06 +0000</pubDate>
		<dc:creator><![CDATA[Kwangshin]]></dc:creator>
				<category><![CDATA[Book]]></category>
		<category><![CDATA[Programming]]></category>
		<category><![CDATA[Software Development]]></category>
		<category><![CDATA[TDD]]></category>
		<category><![CDATA[Testing]]></category>
		<category><![CDATA[Code Quality]]></category>
		<category><![CDATA[Software Development Productivity]]></category>
		<category><![CDATA[Test-Driven Development]]></category>
		<category><![CDATA[The Mythical Man-Month]]></category>
		<category><![CDATA[단위 테스트]]></category>
		<category><![CDATA[맨먼스 미신]]></category>
		<category><![CDATA[소프트웨어 개발 생산성]]></category>
		<category><![CDATA[코드 품질]]></category>
		<category><![CDATA[테스트]]></category>
		<category><![CDATA[테스트 주도 개발]]></category>

		<guid isPermaLink="false">http://kwangshin.pe.kr/blog/?p=1105</guid>
		<description><![CDATA[요즘 개발하고 운영하는 서비스에 트러블이 너무 자주 발생해서 다시 꺼내서 읽고 있는 책이 바로 "맨먼스 미신 - 소프트웨어 공학에 관한 에세이" 이다. 맨먼스 미신 소프트웨어 개발과 관련 있으신 분이라면 누구나 알고 있는 그 용어, 맨-먼쓰 ( man-month), 이 용어가 가장 처음 사용되었다고 생각되고, "은 탄환은 없다. (No Silver Bullet.)"라는 이야기도 나오는 책이다. 1975년(내가 태어나기도 전에 [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>요즘 개발하고 운영하는 서비스에 트러블이 너무 자주 발생해서 다시 꺼내서 읽고 있는 책이 바로 "<a href="http://www.insightbook.co.kr/ppp/%EB%A7%A8%EB%A8%BC%EC%8A%A4-%EB%AF%B8%EC%8B%A0">맨먼스 미신 - 소프트웨어 공학에 관한 에세이</a>" 이다.</p>
<p><img class="aligncenter size-full wp-image-1106" src="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/06/man-month-myth-kor-cover.jpg" alt="" width="252" height="300"></p>
<blockquote class="wp-embedded-content" data-secret="HhoLqbtkVG"><p><a href="http://www.insightbook.co.kr/ppp/%eb%a7%a8%eb%a8%bc%ec%8a%a4-%eb%af%b8%ec%8b%a0">맨먼스 미신</a></p></blockquote>
<p><iframe class="wp-embedded-content" sandbox="allow-scripts" security="restricted" src="http://www.insightbook.co.kr/ppp/%eb%a7%a8%eb%a8%bc%ec%8a%a4-%eb%af%b8%ec%8b%a0/embed#?secret=HhoLqbtkVG" data-secret="HhoLqbtkVG" width="500" height="282" title="&#8220;맨먼스 미신&#8221; &#8212; 도서출판 인사이트" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe></p>
<p>소프트웨어 개발과 관련 있으신 분이라면 누구나 알고 있는 그 용어, 맨-먼쓰 ( man-month), 이 용어가 가장 처음 사용되었다고 생각되고, "은 탄환은 없다. (No Silver Bullet.)"라는 이야기도 나오는 책이다. 1975년(내가 태어나기도 전에 도 소프트웨어 개발은 어려었나보다.)에 처음 출판되었고, 20년 후인 1995년에 저자의 그 동안의 경험담(?)을 추가해서 20주년 기념판으로 재 출간 되었다. 위에 있는 것은 20주년 기념판의 번역서이고, 원서는 아마존에서 쉽게 찾을 수 있다.</p>
<p><iframe type="text/html" width="500" height="550" frameborder="0" allowfullscreen style="max-width:100%" src="https://read.amazon.com/kp/card?preview=inline&linkCode=kpd&ref_=k4w_oembed_V7fC3YkEZN8Ipx&asin=B00B8USS14&tag=kpembed-20"></iframe></p>
<p>사실 예전에 원서로도 읽었지만, 지난번에 한국에 들어갔을 때 번역서를 구매해서 가져왔다. 에세이 형식의 책이라서 짧게 시간 날 때 보고 싶은 곳을 보기도 하지만, 거의 책꽂이에서 쉬고 있다고 봐야...</p>
<p>오늘은 "17장&nbsp;⌈은 탄환은 없다⌋를 다시 쏘다"를 읽으면서 마음의 위안을 얻고, 거기에 더불어 앞으로 조금 더 집중하고 싶은 것들이 생각나서 글로 남긴다. 아마도 이 장은 1995년 20주년 기념판에 추가 된 이야기 같다. 1975년 책이 나온 이후로 많은 사람들이 이 책에 대해서, 더 나아가&nbsp;⌈은 탄환은 없다⌋에 대해서 비관적으로 보고 있다는 이야기를 한다. 하지만 비관적으로 보이는 것이 오히려 정상적인 반응이고, 투르스티(Turski) 같은 사람들은 저자와 동일하게 "허황된 몽상은 발전을 저해하며 우리 수고를 헛되게 할 뿐"이라고 이야기하고 있다. 그러면서 그 논문의 한 부분을 인용하고 있다.</p>
<blockquote><p>해결할 수 없는 문제가 존재한다는 사실을 받아들이는 데에는 많은 노력이 필요하다. 탈출구를 찾고자 하는 바람은, 심지어 그런 것에 존재하지 않음이 증명된 경우라 해도 아주 강렬하다. 우리 대부분은 그처럼 불가능한 것에 도전하는 용감한 사람들에게 큰 연민을 느낀다. 그리고 그런 일은 거듭된다. 원을 네모로 만들려는 것 같은 논문들이 저술된다. 탈모 치료용이라는 로션들이 인기리에 팔린다. 소프트웨어 생산성을 높이도록 고안되었다는 방법론들도 아주 잘 팔리고 있다.</p>
<p>우리에게는 너무 자주 스스로의 낙관성을 따르는 경향이 있다(또는 우리 후원자들의 낙관적인 희망을 이용하는 것일 수도 있다). 우리는 너무 자주 이성의 목소리를 묵살하고 만병통치약 장수의 유혹에 기꺼이 귀를 기울인다.</p>
<p>Turski, W. M., "And no philosophers' stone, either", in Information Processing 86, H. J. Kugler, ed. Amsterdam: Elsvier Science(North Holland), 1986, pp. 1077-1080</p></blockquote>
<p>아, 정말 마음은 아프지만 얼마나 마음에 와 닿는 비유인지.. 1986년에도 탈모 치료용 로션들이 많이 팔렸나 보다. "<span style="text-decoration: underline;"><strong>탈모 치료용이라는 로션들이 인기리에 팔린다. 소프트웨어 생산성을 높이도록 고안되었다는 방법론들도 아주 잘 팔리고 있다.</strong></span>" 소프트웨어 생산성을 높이는 것은 정말 어려운 일인가 보다. 현재 개발/운영중인 소프트웨어 서비스의 품질과 생산성 문제로 기분이 많이 다운 되어 있었는데, 좀 더 힘을 내야겠다.</p>
<p>좀 더 힘을 내는 의미로 개인적으로 다음과 같은 해결 방법들에 초점을 맞춰보려고 한다. 이건 주관적인 생각이고, 개발자 개인마다 개발팀마다 자기에게 맞는 방법을 찾아보는 것도 큰 도움이 될 것이다.</p>
<ol>
<li>단위 테스트 - 빠르게 실행되고 시나리오의 품질을 높여서!</li>
<li>테스트 주도 개발(TDD : Test Driven Development) - 자연스럽게 테스트 가능한 구조를 향하여!</li>
<li>코드 커버리지 - 참고는 하되, 적당한 선까지 알아서!</li>
<li>정적 코드 분석 - 이미 널리 알려진 실수들은 가능한 줄이자!</li>
</ol>
<p>우선 이 정도만 해도 어느 정도의 소스 코드 품질은 지켜지리라고 믿는다. (다이어트와 같은 거지, 누구나 다 알지만 실행은 정말 어려운...)</p>
<p>각각에 대해서 조금 더 이야기를 해 보자.</p>
<h3>1. 단위 테스트 - 빠르게 실행되고 시나리오의 품질을 높여서!</h3>
<p style="text-align: left;">내가 만든 소스코드에 버그가 없다는 것을 어떻게 증명하지? 소스 코드의 일부분을 수정했는데, 다른 부분에 영향을 미치지는 않을까? 이제는 소프트웨어 개발에서 빼 놓을 수 없는 단위 테스트! 자바 개발자라면 JUnit!</p>
<p style="text-align: center;"><a href="https://junit.org/junit5"><img class="aligncenter size-full wp-image-1108" src="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/06/junit5.png" alt="" width="442" height="150" srcset="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/06/junit5.png 442w, http://kwangshin.pe.kr/blog/wp-content/uploads/2018/06/junit5-300x102.png 300w" sizes="(max-width: 442px) 100vw, 442px" /></a><a href="https://junit.org/junit5"><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif;">https://junit.org/junit5</span></a></p>
<p>단위 테스트를 만들때는 꼭 필요한 시나리오에 테스트가 실패하는 것을 두 눈으로 확인하는 것이 좋다. 실패한 뒤에 성공해야, 내가 만든 단위 테스트가 제대로 동작하는 것을 확신할 수 있다. 그리고 단위테스트는 빠르게 실행되어야 한다. 빠르게라는 것이 얼마나 빨라야 할까? 개인적인 의견은 개발자의 개발 흐름에 영향을 미치지 않을 정도로만 빠르면 될 것 같다. 새로운 테스트 시나리오가 생각났는데, 단위 테스트가 실행되는 시간에 그 시나리오를 까먹지 않을 수 있도록...</p>
<h3>2. 테스트 주도 개발(TDD : Test Driven Development) - 자연스럽게 테스트 가능한 구조를 향하여!</h3>
<p>사실 이건 정말 끝이 없는 이야기를 끄집어 내는 주제일수도 있다, 테스트 주도 개발!</p>
<p>개인적인 의견은 테스트가 주도적으로 개발을 이끌어 나가면 (테스트가 먼저냐 나중이냐 이런 이야기는 하지 않겠다.), 아주 큰 장점 하나를 만날 수 있다. 바로, 쉽게 테스트 할 수 있는 소프트웨어 구조가 자연스럽게 만들어 진다는 것이다. 무슨 이야기인지 잘 감이 안 온다면, 기존에 테스트 코드가 전혀 없던 소스 코드에 테스트 코드를 추가하면서 무엇인가를 수정해본 기억을 떠 올리면 된다. 왜 기존에 테스트 코드가 전혀 없던 소스 코드에는 테스트 코드를 추가하기가 그렇게 어려웠을까? 소프트웨어 구조 자체가 테스트 하기 쉬운 구조가 아니었기 때문이다. 테스트가 주도적으로 개발을 이끌어 나가면 바로 이부분을 해결, 아니 완전하게 해결할 수는 없겠지만, 테스트를 전혀 신경쓰지 않은 코드보다는 훨씬 더 테스트 친화적인 소프트웨어 구조와 소스 코드를 얻을 수 있다.</p>
<p>테스트를 먼저 작성해야 하냐, 아니냐로 논쟁하며 시간을 낭비하지 말자. 그 시간에 하나라도 더 테스트를 만들자.</p>
<p>마지막으로 개인적으로 테스트 주도 개발과 관련해서는 다음 영상을 추천한다.</p>
<p><iframe class='youtube-player' type='text/html' width='800' height='450' src='https://www.youtube.com/embed/qkblc5WRn-U?version=3&#038;rel=1&#038;fs=1&#038;autohide=2&#038;showsearch=0&#038;showinfo=1&#038;iv_load_policy=1&#038;wmode=transparent' allowfullscreen='true' style='border:0;'></iframe></p>
<h3>3. 코드 커버리지 - 참고는 하되, 적당한 선까지 알아서!</h3>
<p>코드 커버리지는 내 소스 코드에서 어느 정도가 테스트 코드로 테스트 가능한지 이야기해 주는 수치이다. 당연히 100%가 좋을 수도 있지만, 100% 코드 커버리지를 달성하기 위해서 많은 시간을 할애하는 것은 추천하지 않는다. 수 많은 비지니스 로직들이 있기에 때로는 100%에 못 미칠수도 있다. 내가 생각하기에 100% 코드 커버리지 달성하는 것이 의미 없는 일이라면 과감하게 넘어가도록 하자. 예를 들어, 우리팀의 코드 커버리지 목표는 80%이다. 코드 커버리지 보다는 테스트 코드 퀄리티에 더 손을 들어주고 싶다.</p>
<p>그 유명한 Kent Beck도 다음과 같은 이야기를 했다. "테스트 커버리지가 100%라고 자랑하는 것은 신문에서 모든 글자를 하나 하나 다 읽었다고 자랑하는 것과 같다. 테스트 커버리지 100%보다 더 중요한 것들에 초점을 맞추자."</p>
<blockquote class="twitter-tweet" data-width="500" data-dnt="true">
<p lang="en" dir="ltr">Being proud of 100% test coverage is like being proud of reading every word in the newspaper. Some are more important than others.</p>
<p>&mdash; Kent Beck (@KentBeck) <a href="https://twitter.com/KentBeck/status/812703192437981184?ref_src=twsrc%5Etfw">December 24, 2016</a></p></blockquote>
<p><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>
<h3>4. 정적 코드 분석 - 이미 널리 알려진 실수들은 가능한 줄이자!</h3>
<p>소스 코드에도 어느 정도의 패턴이 존재한다. 소프트웨어 디자인에도 디자인 패턴이 존재하듯이 말이다. 그리고 어느 정도의 기본 패턴들은 이미 분석이 다 끝나서 추후에 버그를 발생시킬 확률이 높은 패턴들은 이미 널리 알려져 있다. 소스 코드를 정적으로 분석해서 이런 정보들을 알려주는 것이 바로 정적 코드 분석 도구들이다. 많이 사용되는 제품으로는 소나큐브(SonarQube)가 있다.</p>
<p><img class="aligncenter wp-image-1109 size-large" src="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/06/clean-code2x-1024x661.png" alt="" width="1024" height="661" srcset="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/06/clean-code2x-1024x661.png 1024w, http://kwangshin.pe.kr/blog/wp-content/uploads/2018/06/clean-code2x-300x194.png 300w, http://kwangshin.pe.kr/blog/wp-content/uploads/2018/06/clean-code2x-768x495.png 768w, http://kwangshin.pe.kr/blog/wp-content/uploads/2018/06/clean-code2x.png 1578w" sizes="(max-width: 1024px) 100vw, 1024px" /></p>
<p style="text-align: center;"><a href="https://www.sonarqube.org/">https://www.sonarqube.org/</a></p>
<p>이미 처음에 이야기를 시작했듯이, 완벽한 도구나 솔루션은 없다, No Silver Bullet! 하지만 유용한 도구들은 받아들여서 생산성과 품질을 가능한 높이도록 하자.</p>
<p>자, 이제 끝나지 않을 다이어트와 동일한 패턴의 작업들이 기다리고 있다. 하지만 기억하자, 다이어트에 실패할지라도 다이어트를 통해 현재 상태를 유지하는 사이드 이펙트를 얻을 수도 있다는 것을! 이 모든 것들을 매일 매일 하지 못해서 소스 코드 품질을 높이는 것에는 실패하더라도, 이러한 시도들을 통해서 소스 코드 품질이 떨어지는 것을 막을 수도 있다는 사실!</p>
]]></content:encoded>
			<wfw:commentRss>http://kwangshin.pe.kr/blog/2018/06/26/software-development-productivity-difficulties-and-challanges/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">1105</post-id>	</item>
		<item>
		<title>도커(Docker) 시작하기</title>
		<link>http://kwangshin.pe.kr/blog/2018/04/14/docker-intro/</link>
		<comments>http://kwangshin.pe.kr/blog/2018/04/14/docker-intro/#comments</comments>
		<pubDate>Sat, 14 Apr 2018 09:44:16 +0000</pubDate>
		<dc:creator><![CDATA[Kwangshin]]></dc:creator>
				<category><![CDATA[Java]]></category>
		<category><![CDATA[Linux]]></category>
		<category><![CDATA[Software Development]]></category>
		<category><![CDATA[Technology]]></category>
		<category><![CDATA[긍정적인 사고]]></category>
		<category><![CDATA[container]]></category>
		<category><![CDATA[docker]]></category>
		<category><![CDATA[linux]]></category>
		<category><![CDATA[software container]]></category>
		<category><![CDATA[tomcat]]></category>
		<category><![CDATA[도커]]></category>
		<category><![CDATA[리눅스]]></category>
		<category><![CDATA[소프트웨어 컨테이너]]></category>
		<category><![CDATA[자바]]></category>
		<category><![CDATA[컨테이너]]></category>
		<category><![CDATA[톰캣]]></category>

		<guid isPermaLink="false">http://kwangshin.pe.kr/blog/?p=1088</guid>
		<description><![CDATA[https://www.docker.com/ 이제 도커(Docker)는 더 이상 소프트웨어 엔지니어들만들의 주제는 아닌 것 같다. 시작은 이미 시장에 나와있었던 소프트웨어 컨테이너로 시작되었지만, 이제는 소프트웨어 컨테이터 플랫폼(software container platform)으로 발돋움, 아니 명실상부한 세계 최고의 소프트웨어 컨테이터 플랫폼이 되었다. "What is Docker?"라는 페이지를 보면 도커의 정의를 이렇게 하고 있다. Docker is the world's leading software containerization platform. 도커는 세계를 이끌어나가는 소프트웨어 [&#8230;]]]></description>
				<content:encoded><![CDATA[<p><a href="https://www.docker.com/"><img class="aligncenter wp-image-1090 size-medium" src="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/04/docker-logo-300x237.jpg" alt="" width="300" height="237" srcset="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/04/docker-logo-300x237.jpg 300w, http://kwangshin.pe.kr/blog/wp-content/uploads/2018/04/docker-logo-768x606.jpg 768w, http://kwangshin.pe.kr/blog/wp-content/uploads/2018/04/docker-logo.jpg 800w" sizes="(max-width: 300px) 100vw, 300px" /></a></p>
<p style="text-align: center;"><a href="https://www.docker.com/">https://www.docker.com/</a></p>
<p>이제 도커(<a href="https://www.docker.com/">Docker</a>)는 더 이상 소프트웨어 엔지니어들만들의 주제는 아닌 것 같다. 시작은 이미 시장에 나와있었던 소프트웨어 컨테이너로 시작되었지만, 이제는 소프트웨어 컨테이터 플랫폼(software container platform)으로 발돋움, 아니 명실상부한 세계 최고의 소프트웨어 컨테이터 플랫폼이 되었다. "<a href="https://www.docker.com/what-docker">What is Docker?</a>"라는 페이지를 보면 도커의 정의를 이렇게 하고 있다.</p>
<blockquote><p>Docker is the world's leading software containerization platform.</p>
<p>도커는 세계를 이끌어나가는 소프트웨어 컨테이너 플랫폼이다.</p></blockquote>
<p>이렇게 DockerCon이라는 컨퍼런스를 가질 정도면 세계 최고의 소프트웨어 컨테이너 플랫폼이 맞는 것 같다. 도커가 어떻게 발전해 나가고 있는지 느끼고 싶다면 이런 컨퍼런스에 가서 분위기를 느껴보는 것도 좋다.</p>
<p><a href="https://2018.dockercon.com/"><img class="aligncenter wp-image-1091 size-medium" src="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/04/dockercon-2018-SF-logo-300x199.png" alt="" width="300" height="199" srcset="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/04/dockercon-2018-SF-logo-300x199.png 300w, http://kwangshin.pe.kr/blog/wp-content/uploads/2018/04/dockercon-2018-SF-logo.png 565w" sizes="(max-width: 300px) 100vw, 300px" /></a></p>
<p style="text-align: center;"><a href="https://2018.dockercon.com/">DockerCon 2018 SF</a></p>
<p>개인적으로 도커는 소프트웨어 엔지니어 뿐만 아니라, IT와 관련있는 모든 사람들에게 정말 도움이 되는 도구이자 플랫폼이라고 믿는다. 이 글에서는 소프트웨어 엔지니어들이 사용하는 방법보다는, 직접 소프트웨어를 개발하지는 않지만 소프트웨어 개발과 관련이 있는 분들이 어떻게 도커를 활용할 수 있는 가장 기본적인 방법을 소개하려고 한다. 사실 너무나 간단하지만, 스트라이더(Strider)를 타기 위해서는 보호장구를 먼저 착용하는 것이 필수인 것 같이, 앞으로 더 나아가기 위해서는 도커를 직접 설치하고 컨테이너 이미지를 통해서 간단한 소프트웨어를 컨테이너 안에서 실행해 보는 것이 중요하다.</p>
<p><img class="aligncenter wp-image-1089 size-full" src="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/04/docker-with-Sunna-e1523687285377.jpg" alt="" width="400" height="667"></p>
<p style="text-align: center;">도커야 놀자!</p>
<p>도커는 이제 컨테이너를 넘어서서 컨테이너 플랫폼이 되었지만, 우선 컨테이너에 대해서 먼저 알아보자. 도커 공식 페이지에서는 "<a href="https://www.docker.com/what-container">What is a Container?</a>" 페이지를 통해서 다음과 같이 정의하고 있다.</p>
<blockquote><p>A container image is a lightweight, stand-alone, executable package of a piece of software that includes everything needed to run it: code, runtime, system tools, system libraries, settings.</p>
<p>컨테이너 이미지는 가볍고, 독립적이고, 실행이 가능한 패키지이고, 이 패키지 안에는 실행이 가능하도록 모든 것(코드, 실행 환경, 시스템 도구, 시스템 라이브러리, 설정등)을 이미 가지고 있는 소프트웨어들이 포함되어 있다.</p></blockquote>
<p>이렇게 정의하면 좀 어려운 감이 있는데, 실제 사용 시나리오로 살펴보면 더 쉽게 이해할 수 있을 것이다. 예를 들어, 리눅스 환경에서 웹 서버를 설치해서 사용해 보고 싶다고 가정해 보자. 현재 윈도우 컴퓨터나 맥 컴퓨터를 사용중이라면, 우선 리눅스 컴퓨터가 필요하다. 보통 일반적인 경우 여기에서부터 털썩! 하게 된다. 대체 어디가서 리눅스 컴퓨터를 구한단 말인가? 그렇다고 실제 컴퓨터를 구입하고 리눅스를 설치하기에는, "그냥 안 하고 말지" 라는 생각이 들 것이다. 그래 어떻게 어떻게 해서 리눅스 컴퓨터를 장만했다고 하자, 그러면 웹 서버를 설치해야 한다. 비교적 쉽게 설치 및 사용이 가능한 아파치 톰캣(<a href="http://tomcat.apache.org/">Apache Tomcat</a>)을 설치하기로 결정했다면, 우선 자바(<a href="https://www.java.com/en/">Java</a>)가 필요하다. 그렇다면 자바를 설치하고 톰캣을 설치하면 된다. 운영체제도 하나의 소프트웨어이므로, (1) 리눅스 운영체제 (2) 자바 (3) 톰캣 이렇게 3개의 소프트웨어가 패키지로 필요하다. 맞다, 이렇게 구성된 패키지가 바로 컨테이너 이미지가 되는 것이다.</p>
<p>이렇게 만들어진 컨테이너 이미지를 바로 구할 수도 있겠지만, 더 잘 이해하고 나만의 컨테이너를 만들기 위해서 지금부터 이 컨테이너 이미지를 만들어 보자. 컨테이너 이미지를 처음부터 한 땀, 한 땀 만들 필요는 없으니(<a href="https://en.wikipedia.org/wiki/Reinventing_the_wheel">Reinventing the wheel</a>), 우선 운영체제는 만들어진 컨테이너 이미지를 다운받아서 사용하고 나머지 소프트웨어를 그 위에 설치해 보자. 이렇게 하면 나만의 컨테이터 이미지가 만들어 질 것이다.</p>
<p>이제부터 할 일을 정리해 보자. (이 글은 맥을 사용하여 진행하지만, 윈도우에서도 크게 다른 부분은 없다.)</p>
<p style="padding-left: 30px;"><strong>1. 도커 다운로드 받고 설치하기.</strong><br />
<strong>2. 리눅스 운영체제로 CentOS 컨테이너 이미지 다운로드 받고 실행하기.</strong><br />
<strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif;">3. CentOS 리눅스 컨테이너에 자바 설치하기.<br />
</span>4. CentOS 리눅스 컨테이너에 톰캣 설치하고 실행하기.</strong><br />
<strong>5. 테스트 하기!&nbsp;</strong></p>
<h3>1. 도커 다운로드 받고 설치하기.</h3>
<p>우선 도커를 다운로드 받아서 설치하도록 하자. 도커 공식 홈 페이지에서 도커 커뮤니티 에디션(Docker Community Edition)를 다운로드 할 수 있다.</p>
<p><a href="https://www.docker.com/community-edition">https://www.docker.com/community-edition</a></p>
<p>설치를 마치고 나면 다음과 같은 명령어로 도커가 설치된 것을 확인할 수 있다.</p>
<p><strong><code>docker version</code></strong></p>
<p>다음과 같은 결과를 볼 수 있다.</p>
<pre class="brush: bash; gutter: true">docker # docker version
Client:
 Version:	18.03.0-ce
 API version:	1.37
 Go version:	go1.9.4
 Git commit:	0520e24
 Built:	Wed Mar 21 23:06:22 2018
 OS/Arch:	darwin/amd64
 Experimental:	false
 Orchestrator:	swarm

Server:
 Engine:
  Version:	18.03.0-ce
  API version:	1.37 (minimum version 1.12)
  Go version:	go1.9.4
  Git commit:	0520e24
  Built:	Wed Mar 21 23:14:32 2018
  OS/Arch:	linux/amd64
  Experimental:	true
docker #</pre>
<p>1단계 완료!</p>
<h3>2. 리눅스 운영체제로 CentOS 컨테이너 이미지 다운로드 받고 실행하기.</h3>
<p>도커는 소프트웨어 컨테이너 플랫폼으로 이미 많이 사용되는 리눅스 운영체제 컨테이너 이미지를 기본적으로 제공한다. 우선 컨테이너 이미지를 다운로드 하기 전에 현재 내가 가지고 있는 도커 컨테이너 이미지를 <strong><code>docker images</code></strong> 명령어로 확인해 보자.</p>
<pre class="brush: bash; gutter: true">docker # docker images
REPOSITORY TAG IMAGE ID CREATED SIZE
docker #</pre>
<p>도커를 처음 설치했다면 당연히 도커 컨테이너 이미지가 하나도 없을 것이다. 도커에서 제공하는 최신 버전의 CentOS 컨테이너를 가져오기 위해서는 다음과 같은 <strong><code>docker pull centos</code></strong> 명령어로 충분하다.</p>
<pre class="brush: bash; gutter: true">docker # docker pull centos
Using default tag: latest
latest: Pulling from library/centos
469cfcc7a4b3: Pull complete
Digest: sha256:989b936d56b1ace20ddf855a301741e52abca38286382cba7f44443210e96d16
Status: Downloaded newer image for centos:latest
docker #</pre>
<p>다운로드 중이라는 메시지를 볼 수 있고, 다운로드가 완료되면 위와 같은 결과를 확인할 수 있다. 이제 다시 도커 컨테이너 이미지를 <strong><code>docker images</code></strong>&nbsp;명령어로 확인해보자.</p>
<pre class="brush: bash; gutter: true">docker # docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
centos              latest              e934aafc2206        7 days ago          199MB
docker #</pre>
<p>이제 나만의 최신 버전의 CentOS 리눅스가 만들어졌다!</p>
<h3>3. CentOS 리눅스 컨테이너에 자바 설치하기.</h3>
<p>이제 나만의 리눅스에 자바를 설치할 차례이다. 이전 단계에서 리눅스 컨테이너 이미지를 다운로드 받았지만, 이미지는 컨테이너 이미지일 뿐 실행중인 것은 아니다. 컴퓨터에 리눅스가 설치되어 있어도 전원 버튼을 눌러서 리눅스 운영체제를 시작하듯이 컨테이너 이미지를 사용하여 컨테이너를 실행해야 한다.</p>
<p>컨테이너를 실행하기 전에 현재 실행중인 컨테이너를 다음과 같이 <strong><code>docker container ls</code></strong> 명령어로 간단하게 확인할 수 있다.</p>
<pre class="brush: bash; gutter: true">docker # docker container ls
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES
docker #</pre>
<p>실행중인 컨테이너 뿐만 아니라 모든 컨테이너를 보기 위해서는 <strong><code>-a</code></strong> 옵션을 추가해서 <strong><code>docker container ls -a</code></strong> 명령어를 사용하면 된다.</p>
<pre class="brush: bash; gutter: true">docker # docker container ls -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES
docker #</pre>
<p>현재는 컨테이너가 하나도 없기 때문에 동일한 결과를 볼 수 있다.</p>
<p>그렇다면 다음과 같은 명령어를 사용해서 컨테이너를 실행해 보도록 하자.</p>
<p><code><strong>docker run --name tomcat -p 8080:8080 -it centos bash</strong></code></p>
<p><strong><code>docker run</code></strong> 명령어를 사용하면 도커 이미지를 실행할 수 있다.</p>
<p>컨테이너에 이름을 주지 않아도 컨테이너 아이디로 접근 가능하지만, 이후에 쉽게 사용할 수 있도록 <strong><code>--name</code></strong> 옵션을 사용하여 <strong><code>tomcat</code></strong> 이라는 이름을 주었다.</p>
<p>컨테이너에 웹서버를 설치해서 실행할 계획인데 컨테이너 내부가 아닌, 도커를 실행중인&nbsp;컴퓨터에서 테스트 하기 위해서는 포트를 선언해 주어야 한다. 즉, localhost 서버에 8080 포트를 요청이 들어오면 도커가 내 tomcat 컨테이너로 요청을 연결해 준다는 의미이다. 참고로 톰캣을 실행하면 기본 포트가 8080 이므로, 8080 포트만 설정하도록 하겠다.</p>
<p>컨테이너를 실행한 후에 실행중인 리눅스에 명령어를 입력기 위해서는 컨테이너의 입력을 현재 사용중인 터미널에 연결하는 것이 필요하다. 이 연결을 가능하게 하는 것이 <strong><code>-it</code></strong> 옵션이다.</p>
<p>그 이후에는 이미지 이름을 주면 된다. 이미지 이름은 <strong><code>docker images</code></strong> 명령어 결과에서 나오는 REPOSITORY 값으로 알 수 있다. CentOS 컨테이너 이미지 이름은 centos 이다.</p>
<p>마지막으로 bash 는 bash shell로 리눅스와 연결하겠다는 의미이다.&nbsp;</p>
<p>명령어와 옵션에 대해서는 <a href="https://docs.docker.com/engine/reference/commandline/run/#examples">docker document -&gt; run -&gt; example</a> 에서 더 자세하게 확인할 수 있다.</p>
<p>명령어를 실행하면 결과는 너무나 간단하고 빨라서 놀랄 것이다.</p>
<pre class="brush: bash; gutter: true">docker # docker run --name tomcat -p 8080:8080 -it centos bash
[root@1f05c270d251 /]#</pre>
<p>자, 이제 나만의 리눅스에 root 권한으로 들어왔다. 제대로 들어왔는지 <strong><code>cat /etc/*-release</code></strong>&nbsp;명령어를 사용해서 리눅스 버전을 확인해보자.</p>
<pre class="brush: bash; gutter: true">[root@1f05c270d251 /]# cat /etc/*-release
CentOS Linux release 7.4.1708 (Core)
NAME=&quot;CentOS Linux&quot;
VERSION=&quot;7 (Core)&quot;
ID=&quot;centos&quot;
ID_LIKE=&quot;rhel fedora&quot;
VERSION_ID=&quot;7&quot;
PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;
ANSI_COLOR=&quot;0;31&quot;
CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;
HOME_URL=&quot;https://www.centos.org/&quot;
BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;

CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;
CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;
REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;
REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;

CentOS Linux release 7.4.1708 (Core)
CentOS Linux release 7.4.1708 (Core)
[root@1f05c270d251 /]#</pre>
<p>와, 나만의 CentOS 7 리눅스가 만들어 졌다. 그러면 이제 자바가 설치되어 있는지 <strong><code>java -version</code></strong> 명령어로 확인해 보자.</p>
<pre class="brush: bash; gutter: true">[root@1f05c270d251 /]# java -version
bash: java: command not found
[root@1f05c270d251 /]#</pre>
<p>우리가 다운로드 받은 리눅스 이미지에는 자바가 설치되어 있지 않다. 하지만 CentOS 리눅스는 소프트웨어를 쉽게 설치할 수 있도록 도와주는 <strong><code>yum</code></strong> 이라는 명령어를 기본으로 지원한다. 그래서 다음과 같은 명령어 하나로 자바를 쉽게 설치할 수 있다.</p>
<p><strong><code>yum install java</code></strong></p>
<p>패키지를 설치할 지 물어볼 때, y 만 눌러주면 설치가 완료된다!</p>
<pre class="brush: bash; gutter: true">[root@1f05c270d251 /]# yum install java
Loaded plugins: fastestmirror, ovl
base                                                                                                                | 3.6 kB  00:00:00
extras                                                                                                              | 3.4 kB  00:00:00
updates                                                                                                             | 3.4 kB  00:00:00
(1/4): base/7/x86_64/group_gz                                                                                       | 156 kB  00:00:00
(2/4): extras/7/x86_64/primary_db                                                                                   | 185 kB  00:00:00
(3/4): updates/7/x86_64/primary_db                                                                                  | 6.9 MB  00:00:06
(4/4): base/7/x86_64/primary_db                                                                                     | 5.7 MB  00:00:07
Determining fastest mirrors
..........
Installed:
  java-1.8.0-openjdk.x86_64 1:1.8.0.161-0.b14.el7_4

Dependency Installed:
  alsa-lib.x86_64 0:1.1.3-3.el7                              copy-jdk-configs.noarch 0:2.2-5.el7_4     fontconfig.x86_64 0:2.10.95-11.el7
  fontpackages-filesystem.noarch 0:1.44-8.el7                freetype.x86_64 0:2.4.11-15.el7           giflib.x86_64 0:4.1.6-9.el7
  java-1.8.0-openjdk-headless.x86_64 1:1.8.0.161-0.b14.el7_4 javapackages-tools.noarch 0:3.4.1-11.el7  libICE.x86_64 0:1.0.9-9.el7
  libSM.x86_64 0:1.2.2-2.el7                                 libX11.x86_64 0:1.6.5-1.el7               libX11-common.noarch 0:1.6.5-1.el7
  libXau.x86_64 0:1.0.8-2.1.el7                              libXcomposite.x86_64 0:0.4.4-4.1.el7      libXext.x86_64 0:1.3.3-3.el7
  libXfont.x86_64 0:1.5.2-1.el7                              libXi.x86_64 0:1.7.9-1.el7                libXrender.x86_64 0:0.9.10-1.el7
  libXtst.x86_64 0:1.2.3-1.el7                               libfontenc.x86_64 0:1.1.3-3.el7           libjpeg-turbo.x86_64 0:1.2.90-5.el7
  libpng.x86_64 2:1.5.13-7.el7_2                             libxcb.x86_64 0:1.12-1.el7                libxslt.x86_64 0:1.1.28-5.el7
  lksctp-tools.x86_64 0:1.0.17-2.el7                         python-javapackages.noarch 0:3.4.1-11.el7 python-lxml.x86_64 0:3.2.1-4.el7
  stix-fonts.noarch 0:1.1.0-5.el7                            ttmkfdir.x86_64 0:3.0.9-42.el7            tzdata-java.noarch 0:2018d-1.el7
  xorg-x11-font-utils.x86_64 1:7.5-20.el7                    xorg-x11-fonts-Type1.noarch 0:7.5-9.el7

Complete!
[root@1f05c270d251 /]#</pre>
<p>자, 이제 자바가 설치되었는지 <strong><code>java -version</code></strong> 명령어로 확인해 보자.</p>
<pre class="brush: bash; gutter: true">[root@1f05c270d251 /]# java -version
openjdk version &quot;1.8.0_161&quot;
OpenJDK Runtime Environment (build 1.8.0_161-b14)
OpenJDK 64-Bit Server VM (build 25.161-b14, mixed mode)
[root@1f05c270d251 /]#</pre>
<p>자바 설치도 완료!</p>
<h3>4. CentOS 리눅스 컨테이너에 톰캣 설치하고 실행하기.</h3>
<p>자, 이제 tomcat 9 을 설치하도록 하자. 자세한 정보는 다음 페이지에서 찾을 수 있다.</p>
<p><a href="https://tomcat.apache.org/download-90.cgi">https://tomcat.apache.org/download-90.cgi</a></p>
<p>위 홈페이지에서 제공되는 gz 파일을 다운로드 받아서 설치해 보자. 이 글을 쓰는 현재 최신 버전은 v9.0.7이고 위치는 다음과 같다.</p>
<p>http://ftp.yz.yamagata-u.ac.jp/pub/network/apache/tomcat/tomcat-9/v9.0.7/bin/apache-tomcat-9.0.7.tar.gz</p>
<p>자, 이제 새로운 <strong><code>tomcat9-download</code></strong> 라는 디렉토리를 만든 후에, 그 곳에 톰캣 파일을 다운로드 받도록 하자. 파일을 다운로드 받기 위해서는 <strong><code>curl</code></strong> 이라는 명령어에 <strong><code>-O</code></strong> 옵션을 사용하면 된다.</p>
<pre class="brush: bash; gutter: true">[root@1f05c270d251 /]# mkdir tomcat9-download
[root@1f05c270d251 /]# cd tomcat9-download/
[root@1f05c270d251 tomcat9-download]# curl -O http://ftp.yz.yamagata-u.ac.jp/pub/network/apache/tomcat/tomcat-9/v9.0.7/bin/apache-tomcat-9.0.7.tar.gz
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 9294k  100 9294k    0     0   933k      0  0:00:09  0:00:09 --:--:--  500k
[root@1f05c270d251 tomcat9-download]#</pre>
<p>이제 다운로드 받은 파일을 압축해제하고 적절한 <strong><code>/usr/local/tomcat9</code></strong> 디렉토리로 옮기도록 하자.</p>
<pre class="brush: bash; gutter: true">[root@1f05c270d251 tomcat9-download]# tar xzf apache-tomcat-9.0.7.tar.gz
[root@1f05c270d251 tomcat9-download]# mv apache-tomcat-9.0.7 /usr/local/tomcat9
[root@1f05c270d251 tomcat9-download]#</pre>
<p>최선 버전의 톰캣이 <strong><code>/usr/local/tomcat9</code></strong> 디렉토리에 설치되었다. 이제 톰캣을 실행하는 일만 남았다. 톰캣 디렉토리로 이동 후에 <strong><code>./bin/startup.sh</code></strong> 명령어를 사용하여 톰캣을 실행하도록 하자.</p>
<pre class="brush: bash; gutter: true">[root@1f05c270d251 tomcat9-download]# cd /usr/local/tomcat9/
[root@1f05c270d251 tomcat9]# ./bin/startup.sh
Using CATALINA_BASE:   /usr/local/tomcat9
Using CATALINA_HOME:   /usr/local/tomcat9
Using CATALINA_TMPDIR: /usr/local/tomcat9/temp
Using JRE_HOME:        /usr
Using CLASSPATH:       /usr/local/tomcat9/bin/bootstrap.jar:/usr/local/tomcat9/bin/tomcat-juli.jar
Tomcat started.
[root@1f05c270d251 tomcat9]#</pre>
<p>너무 쉽게 모든 것이 설치되었고 실행도 마무리 지었다. 이제 마지막 단계로 넘어가서 테스트를 진행해 보자.</p>
<h3>5. 테스트 하기!</h3>
<p>나의 도커 컨테이너에서 톰캣이 기본 값인 8080 포트를 가지고 실행중에 있다. 이제 브라우저를 열고 다음 주소를 입력해 보자.</p>
<p><strong><code>http://localhost:8080/</code></strong></p>
<p>다음과 같은 화면을 볼 수 있다면 성공이다!</p>
<p><img class="aligncenter size-full wp-image-1093" src="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/04/running-tomcat.png" alt="" width="600" height="400" srcset="http://kwangshin.pe.kr/blog/wp-content/uploads/2018/04/running-tomcat.png 600w, http://kwangshin.pe.kr/blog/wp-content/uploads/2018/04/running-tomcat-300x200.png 300w" sizes="(max-width: 600px) 100vw, 600px" /></p>
<p>이제 실행중인 컨테이너를 끝내보도록 하자. 간단하게 bash 을 <strong><code>exit</code></strong> 명령어로 종료하면 컨테이너도 함께 종료된다.</p>
<pre class="brush: bash; gutter: true">[root@1f05c270d251 tomcat9]# exit
exit
docker $</pre>
<p>이제 도커 컨테이너에서 나와서 다시 내 컴퓨터로 돌아왔다. <strong><code>docker container ls</code></strong> 명령어로 실행중인 컨테이너를 확인해 보자.</p>
<pre class="brush: bash; gutter: true">docker $ docker container ls
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES
docker $</pre>
<p>컨테이너가 종료되었기 때문에 현재 실행중인 컨테이너 목록에서는 확인할 수 없다. 모든 컨테이너를 확인하도록 <strong><code>-a</code></strong> 을 사용해서 <strong><code>docker container ls -a</code></strong> 명령어를 실행해 보자.</p>
<pre class="brush: bash; gutter: true">docker $ docker container ls -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                       PORTS                    NAMES
1f05c270d251        centos              &quot;bash&quot;              30 minutes ago      Exited (127) 3 minutes ago                            tomcat
docker $</pre>
<p>내가 만든 tomcat 이라는 컨테이너가 3분 전에 종료되었음을 확인할 수 있다.</p>
<p>컨테이너를 다시 시작하고 작업을 진행하고 싶다면 <strong><code>docker container start -i tomcat</code></strong> 명령어를 사용해서 컨테이너를 시작하고 다른 작업들을 진행할 수 있다.</p>
<pre class="brush: bash; gutter: true">docker $ docker container start -i tomcat
[root@1f05c270d251 /]#</pre>
<p>사실 이제 시작에 불과하다. 도커에 관한 더 많은 명령어들과 정보들은 다음 Docker Documentation 페이지에서 확인할 수 있다.</p>
<p><a href="https://docs.docker.com/">https://docs.docker.com/</a></p>
<p>시작이 반이다. 이제 발을 들여 놓았으니 끝없는 도커 속 세상으로 여행을 떠나보자.</p>
]]></content:encoded>
			<wfw:commentRss>http://kwangshin.pe.kr/blog/2018/04/14/docker-intro/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">1088</post-id>	</item>
	</channel>
</rss>
