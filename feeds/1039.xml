<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[devkoriel]]></title><description><![CDATA[Build software better, together.]]></description><link>https://blog.koriel.kr/</link><image><url>https://blog.koriel.kr/favicon.png</url><title>devkoriel</title><link>https://blog.koriel.kr/</link></image><generator>Ghost 2.13</generator><lastBuildDate>Sat, 11 May 2019 18:55:05 GMT</lastBuildDate><atom:link href="https://blog.koriel.kr/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Slack의 강력한 대안, Mattermost]]></title><description><![CDATA[<h2 id="mattermost-">Mattermost의 기능과 장점</h2><p>Mattermost는 Slack의 대항마로 등장했다. Slack은 현재 Standard 플랜이 사용자당 매월 $6.67이고 SaaS로만 제공되기 때문에 사내망에 직접 호스팅하여 서비스할 수 없다. 서버도 국내에 없기 때문에 직접 호스팅하는 것보다 느릴 수 밖에 없다. 그렇다면 Mattermost는? SaaS뿐만 아니라 직접 호스팅할 수 있으며 후자의 경우 무려 무료다. 소스 코드도 GitHub을</p>]]></description><link>https://blog.koriel.kr/slackyi-gangryeoghan-daean-mattermost/</link><guid isPermaLink="false">5ca6ea0799332842ecee46c0</guid><dc:creator><![CDATA[Jinsoo Heo]]></dc:creator><pubDate>Fri, 05 Apr 2019 07:37:53 GMT</pubDate><content:encoded><![CDATA[<h2 id="mattermost-">Mattermost의 기능과 장점</h2><p>Mattermost는 Slack의 대항마로 등장했다. Slack은 현재 Standard 플랜이 사용자당 매월 $6.67이고 SaaS로만 제공되기 때문에 사내망에 직접 호스팅하여 서비스할 수 없다. 서버도 국내에 없기 때문에 직접 호스팅하는 것보다 느릴 수 밖에 없다. 그렇다면 Mattermost는? SaaS뿐만 아니라 직접 호스팅할 수 있으며 후자의 경우 무려 무료다. 소스 코드도 GitHub을 통해 모두 공개되어있기 때문에 회사 사정에 맞게 모든 것을 바꾸어 사용할 수 있다. 사내망에 올릴 경우 속도도 극한까지 끌어올릴 수 있다. 대용량의 파일들을 채팅 서비스를 이용해 주고 받는 경우도 꽤 있기 때문에 전송 속도는 굉장히 중요하다. 심지어 Android와 iOS 모바일 앱의 코드도 모두 공개되어 있기 때문에 직접 빌드하여 배포까지 할 수 있다. 다양한 언어로 번역되어 있어 영어에 서툰 직원들도 쉽게 사용할 수 있는 장점까지 있다. Slack은 제공되는대로 사용해야하는 반면 Mattermost는 이렇게 입맛대로 바꾸어 사용할 수 있기 때문에 스타트업이나 소규모 팀이 자체적으로 운용하기엔 최적의 응용프로그램이다.</p><p>Team Edition은 현재 무료로 소스 코드까지 공개되어있다. Enterprise Edition도 소스 코드는 공개되어 있지만 라이센스가 없으면 LDAP 통합 등 일부 기능이 제한된다. LDAP 통합 기능을 이용하면 기존 사내 인증 시스템을 바로 통합할 수 있다. Slack과 비교하여 강력한 기능이다. Android와 iOS 모바일 앱을 직접 빌드하여 배포하면 직원들이 직접 URL을 입력하고 접속해야하는 수고로움없이 사내 채팅 서비스에 바로 접속할 수 있는 용이성까지 갖추었다.</p><p>Mattermost는 검색 기능이 매우 빠르고 강력하다. 아래 사진에 나와있는 규칙에 맞추어 검색하면 원하는 정보를 언제든 쉽게 찾을 수 있다. Slack 무료 버전은 일정 기간이 지나면 그 이전 기록이 모두 사라지는데에 반해 Mattermost는 호스트의 볼륨만 살아있다면 영구 보존된다.</p><p>Mattermost의 기능은 대체로 Slack과 동일하다. 다른 팀원들과 대화를 나눌 수 있고 특정 대화에 Thread를 열 수 있다. Mattermost에 처음 접속하면 Off-Topic 채널과 Town Square 채널이 생성된다. 이 채널들은 각각 Slack의 random 채널, general 채널에 대응된다. 채널의 유형은 Public과 Private으로 Slack과 동일하다. 채널을 생성한 후에는 Header에 마크다운 형식으로 간단한 설명이나 링크를 보여줄 수 있는 점이 돋보인다. 테마 설정을 통해 개발자들이 좋아하는 다크 모드도 설정할 수 있다. 코드 조작이 가능하므로 다크 모드 말고도 직접 색상들을 모두 바꿀 수 있다.</p><p>Hipchat, Slack, Mattermost 등의 채팅 서비스를 사용하면서 의사소통에 가장 걸림돌이 되는 부분은 바로 DM(Direct Message)이다. 필히 직접 이야기해야할 내용은 DM으로 소통하고 그렇지 않은 것은 반드시 공개된 채널에서 소통하는 것이 좋다. 그렇게 하지 않으면 여러번의 DM을 통해 정보를 전달하기 때문에 시간 낭비가 생긴다. 여기서 Slack의 문제가 발생한다. Slack은 현재 DM을 부분적으로 제한할 수 있는 방법이 없다. 하지만 Mattermost는 DM을 보내면 상대방에게 대화 내용을 자동으로 이메일로 보내도록 설정할 수 있어 자연스럽게 공유가 필요한 내용은 공개 채널을 사용하도록 유도할 수 있다.</p><p>Slack의 가장 강력한 기능은 바로 App일 것이다. Slack의 App Directory를 탐색해보면, 방대한 앱들이 있는 것을 알 수 있다. 이런 앱들을 활용해 JIRA, Confluence 등 협업 도구와 통합해 사용하면 개발 조직의 능률을 배로 끌어올릴 수 있다. Mattermost도 물론 가능하다. 그것도 모든 것을 공짜로. 무료인 점이 가장 강력한 기능이다.</p><p>Mattermost에선 Webhook이 지원된다. 따라서 공식적으로 통합되지 않는 앱들도 프로토콜만 맞춘다면 Webhook으로 알림 기능을 구성해 팀원들에게 정보를 실시간으로 전달할 수 있다.</p><p>마지막으로 Mattermost를 도커를 이용해 배포하고 관리한다면 도커 스웜으로 쉽게 오케스트레이션도 가능할 수 있다는 장점이 있다. 물론 Slack 등 SaaS들도 고가용성을 유지하기 위한 노력을 하고 오케스트레이션이 되어 있겠지만, 아무래도 전세계의 사용자들이 매초 접속하여 쓰기 때문에 어떤 일이 언제 일어날 지 모른다. 하지만 소규모의 팀이 Mattermost를 도커로 직접 서버에 올려 오케스트레이션하고 데이터 볼륨도 GlusterFS 등을 이용해 Replica를 만든다면 훨씬 더 좋은 고가용성을 확보할 수 있다. Slack은 고장나면 그들이 고칠 때까지 기다려야하지만 직접 설치하면 우리가 직접 고칠 수 있지 않은가.</p><h2 id="mattermost--1">Mattermost의 설치 방법</h2><p>Mattermost는 여러 가지 방법으로 설치할 수 있다. 그 방법들은 아래와 같다.</p><ul><li>Heroku에 배포하기</li><li>Bitnami를 통해 클라우드 플랫폼에 배포하기</li><li>서버에 직접 설치하기</li></ul><p>앞선 두가지 방법은 몇번의 클릭으로 간단하게 배포할 수 있는 방법이다. 이 글에서는 세번째 방법인, 서버에 직접 설치하는 방법을 알아보겠다.</p><p>Mattermost의 GitHub 저장소 주소와 설치 방법의 주소는 아래와 같다.</p><ul><li>GitHub 저장소: <a href="https://github.com/mattermost/mattermost-server">https://github.com/mattermost/mattermost-server</a></li><li>설치 방법: <a href="https://github.com/mattermost/mattermost-server#install-on-your-own-machine">https://github.com/mattermost/mattermost-server#install-on-your-own-machine</a></li></ul><p>서버에 직접 설치하는 방법도 여러가지이다. WAS를 직접 서버에 올리고 그 앞에 Nginx와 같은 리버스 프록시를 둘 수 있다. 하지만 사내 서버에서는 여러 앱들을 운영하는 경우가 많으므로 Docker를 통해 간단하게 설치하는 방법을 알아보겠다. Docker를 이용하지만 이 글에서는 Docker와 Nginx에 대한 자세한 설명은 생략한다.</p><p>설치 방법은 Ubuntu Server를 기준으로 설명한다.</p><h2 id="-">환경 설정</h2><h3 id="docker-ce-">Docker CE 설치</h3><p>먼저 Docker CE를 설치한다. Docker CE를 설치하기 위해선 아래 Ubuntu 배포판들 중 하나의 64bit 버전이 필요하다.</p><ul><li>Cosmic 18.10</li><li>Bionic 18.04 (LTS)</li><li>Xenial 16.04 (LTS)</li></ul><p>기존에 설치된 패키지들이 있다면 아래의 명령어를 통해 삭제한다.</p><pre><code>$ sudo apt remove docker docker-engine docker.io containerd runc</code></pre><p>패키지 인덱스를 업데이트하고 docker-ce를 본격적으로 설치할 차례다.</p><p>1. 패키지 인덱스 업데이트 및 패키지 업그레이드</p><pre><code>$ sudo apt update &amp;&amp; sudo apt upgrade -y</code></pre><p>2. Docker CE와 containerd의 최신 버전을 설치한다.</p><pre><code>$ sudo apt install docker-ce docker-ce-cli containerd.io</code></pre><p>Docker 설치는 이렇게 간단하게 끝났다. Docker 설치에 대한 자세한 설명은 Docker 공식 웹사이트에서 확인할 수 있다.</p><h3 id="nginx-">Nginx 설치</h3><p>이제 Nginx를 설치하고 방화벽의 정책을 설정해야한다.</p><pre><code>$ sudo apt install nginx
$ sudo ufw allow ‘Nginx Full'</code></pre><p>아래 명령어로 <code>ufw</code>의 정책을 확인할 수 있다.</p><pre><code>$ sudo ufw status</code></pre><h3 id="docker-">Docker 컨테이너 올리기</h3><p>Docker로 컨테이너를 생성하는 방법은 크게 3가지다.</p><ul><li><code>docker run</code> 명령어</li><li>docker-compose</li><li>Docker Swarm</li></ul><p>우리는 Docker Swarm을 이용할 것이다. Docker Swarm은 Docker의 클러스터링을 도와주는 이미지이다. 매니저 노드를 통해 여러 노드들에 퍼져있는 앱 컨테이너들을 관리하고 트래픽을 분산시킬 수 있다. 사내에서 관리하는 웹 서비스를 Docker Swarm을 통해 관리하면 고가용성을 유지할 수 있다.</p><p>하지만 이번 글에서는 클러스터링을 다루지 않고 하나의 노드에만 컨테이너를 올리도록 한다.</p><p><code>docker stack</code> 명령어를 통해 <code>docker-compose.yml</code> 파일을 로드하고 서비스를 실행할 수 있다. 해당 파일은 루트 계정 권한으로 생성하여 편집하는 것을 권장한다. 그렇지 않았다면 <code>chown</code> 명령어로 권한을 수정하기 바란다.</p><pre><code># This file allows you to run mattermost within your docker swarm mode cluster
# for more informations check: https://docs.docker.com/engine/swarm/
#
# Simply run:
#
# `docker stack up [STACK NAME] -c docker-stack.yml`
#
# In this case `mattermost` is going to be stack name, so the command will be:
#
# `docker stack up mattermost -c docker-stack.yml`
#
# From now on all the services that belong to this stack will be prefixed with `mattermost_`
# this file defines 3 services, these are going to be mattermost_db, mattermost_app and mattermost_web,
# each of these names is the service's hostname as well, they can communicate
# with each other easily by using the hostname instead of the ip or exposing ports to the host.
#
# As a side note, images tagged as latest are pulled by default,
# that means there's no need to use `image:latest`
#
# use latest compose v3.3 file format for optimal compatibility with latest docker release and swarm features.
# see https://docs.docker.com/compose/compose-file/compose-versioning/#version-3
# and https://docs.docker.com/compose/compose-file/compose-versioning/#version-33
# and https://docs.docker.com/compose/compose-file/compose-versioning/#upgrading

version: '3.3'
networks:
  # network for App &lt;-&gt; DB transactions
  mm-in:
    driver: overlay
    internal: true
  # this network faces the outside world
  mm-out:
    driver: overlay
    internal: false
volumes:
  mm-dbdata:
services:
  db:
    # use official mattermost prod-db image
    image: mattermost/mattermost-prod-db
    networks:
      - mm-in
    volumes:
      # use a named-volume for data persistency
      - mm-dbdata:/var/lib/postgresql/data
      - /etc/localtime:/etc/localtime:ro
    environment:
      - POSTGRES_USER=mattermost
      - POSTGRES_PASSWORD=&lt;POSTGRES_비밀번호&gt;
      - POSTGRES_DB=mattermostdb
      # uncomment the following to enable backup
      # - AWS_ACCESS_KEY_ID=XXXX
      # - AWS_SECRET_ACCESS_KEY=XXXX
      # - WALE_S3_PREFIX=s3://BUCKET_NAME/PATH
      # - AWS_REGION=us-east-1
    deploy:
      restart_policy:
        condition: on-failure
  app:
    # use official mattermost prod-app image
    image: mattermost/mattermost-prod-app
    networks:
      - mm-in
      - mm-out
    volumes:
      - /&lt;MATTERMOST_디렉토리&gt;/mattermost/config:/mattermost/config:rw
      - /&lt;MATTERMOST_디렉토리&gt;/mattermost/data:/mattermost/data:rw
      - /&lt;MATTERMOST_디렉토리&gt;/mattermost/logs:/mattermost/logs:rw
      - /&lt;MATTERMOST_디렉토리&gt;/mattermost/plugins:/mattermost/plugins:rw
      - /etc/localtime:/etc/localtime:ro
    environment:
      # use service's hostname
      - DB_HOST=db
      # talk to the port within the overlay network
      # without (over)exposing ports
      - DB_PORT_NUMBER=5432
      - MM_USERNAME=mattermost
      - MM_PASSWORD=&lt;POSTGRES_비밀번호&gt;
      - MM_DBNAME=mattermostdb
      # pass the edition to be used, default is enterprise
      # setting this env var will make the app use the team edition
      - edition=team
      # in case your config is not in default location
      # - MM_CONFIG=/mattermost/config/config.json
    deploy:
      restart_policy:
        condition: on-failure
  web:
    # use official mattermost prod-web image
    image: mattermost/mattermost-prod-web
    ports:
      - "&lt;HOST_포트&gt;:80"
    networks:
      - mm-out
    volumes:
      # This directory must have cert files
      - /&lt;MATTERMOST_디렉토리&gt;/cert:/cert:ro
      - /etc/localtime:/etc/localtime:ro
    environment:
      # use app service's hostname
      - APP_HOST=app
      # talk to the port within the overlay network
      # without (over)exposing ports
      - APP_PORT_NUMBER=8000
    deploy:
      restart_policy:
       condition: on-failure</code></pre><p>위 코드는 GitHub Gist로 공유되어있다. <a href="https://gist.github.com/devkoriel/9bf04f399b572e6ced4d78488aa0b73d%EC%97%90%EC%84%9C">https://gist.github.com/devkoriel/9bf04f399b572e6ced4d78488aa0b73d에서</a> 확인할 수 있다.</p><p>접속 후 코드의 오른쪽 위 “Raw”를 클릭하고 주소창의 URL을 복사한다. <code>curl -O</code> 명령어를 이용하여 바로 다운로드할 수 있다.</p><pre><code>$ curl -O https://gist.githubusercontent.com/devkoriel/9bf04f399b572e6ced4d78488aa0b73d/raw/12d197fd1c91e425205c048f29482b302686fb89/mattermost-docker-compose.yml</code></pre><p><code>mattermost-docker-compose.yml</code>에서 사용하는 파라미터는 총 3개이다.</p><p>&lt;POSTGRES_비밀번호&gt;: 생성되는 Postgres DB의 비밀번호이다. 최소 16자 이상으로 설정할 것을 권장한다. <a href="https://passwordsgenerator.xn--net-hw8m">https://passwordsgenerator.net를</a> 이용하면 간단하게 비밀번호를 자동 생성할 수 있다.<br>&lt;MATTERMOST_디렉토리&gt;: Docker 컨테이너가 사용할 Host의 볼륨 위치이다.<br>&lt;HOST_포트&gt;: Host에 노출할 포트이다.</p><p>아래 명령어로 &lt;MATTERMOST_디렉토리&gt;를 생성하고 소유자를 설정한다.</p><pre><code>$ sudo mkdir -p /home/apps/mattermost/{config,data,logs,plugins,cert}
$ sudo chown -R 2000:2000 /home/apps/mattermost</code></pre><p><code>mattermost-docker-compose.yml</code>에서 &lt;MATTERMOST_디렉토리&gt;를 모두 <code>/home/apps/mattermost</code>로 바꾼다.</p><p>아래 명령어로 <code>mattermost</code> 서비스와 컨테이너를 생성한다.</p><pre><code>$ docker stack deploy -c mattermost-docker-compose.yml mattermost</code></pre><p>아무 오류없이 아래와 같이 출력된다면 성공이다.</p><pre><code>$ Creating network mattermost_mm-in
$ Creating network mattermost_mm-out
$ Creating service mattermost_db
$ Creating service mattermost_app
$ Creating service mattermost_web</code></pre><h3 id="nginx--1">Nginx 리버스 프록시 설정</h3><p>[nginx.conf]</p><pre><code>server {
  listen 80;

  server_name chat.example.com;

  location ~ /api/v[0-9]+/(users/)?websocket$ {
      proxy_pass http://127.0.0.1:&lt;HOST_포트&gt;;
      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection "Upgrade";
      proxy_set_header Origin "";
  }

  location / {
      return 301 https://$host$request_uri;
  }
}

server {
    listen 443 ssl;
    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem; # managed by Certbot
    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem; # managed by Certbot
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    server_name chat.example.com; 

    client_max_body_size 10g;

    location ~ /api/v[0-9]+/(users/)?websocket$ {
        proxy_pass http://127.0.0.1:&lt;HOST_포트&gt;;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "Upgrade";
        proxy_set_header Origin "";
    }

    location / {
        proxy_set_header HOST $host;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_pass http://127.0.0.1:&lt;HOST_포트&gt;;
    }
}</code></pre><p>위 코드는 GitHub Gist로 공유되어있다. <a href="https://gist.github.com/devkoriel/8b789a65972733af7a4e7e799b49083c%EC%97%90%EC%84%9C">https://gist.github.com/devkoriel/8b789a65972733af7a4e7e799b49083c에서</a> 확인할 수 있다.</p><p>접속 후 코드의 오른쪽 위 “Raw”를 클릭하고 주소창의 URL을 복사한다. <code>curl -O</code> 명령어를 이용하여 바로 다운로드할 수 있다.</p><pre><code>$ curl -O https://gist.githubusercontent.com/devkoriel/8b789a65972733af7a4e7e799b49083c/raw/7d8e5bbb7ff282f95bcd3c52bf24ac13e46d7742/mattermost-nginx-conf</code></pre><p><code>mattermost-nginx-conf</code>에서 사용하는 파라미터는 총 2개이다.</p><p>example.com: 사용할 도메인<br>&lt;HOST_포트&gt;: mattermost-docker-compose.yml에서 사용한 &lt;HOST_포트&gt;</p><p><code>mattermost-nginx-conf</code>를 <code>nginx</code>의 설치 경로 밑 <code>sites-available</code>로 옮긴다.</p><pre><code>$ sudo mv mattermost-nginx-conf /etc/nginx/sites-available &amp;&amp; cd /etc/nginx/sites-available
$ sudo vim mattermost-nginx-conf</code></pre><p>위 2개의 파라미터를 알맞게 바꾼다.</p><pre><code>$ sudo ln -s /etc/nginx/sites-available/mattermost-nginx-conf /etc/nginx/sites-enabled/mattermost-nginx-conf
$ sudo service nginx restart</code></pre><p>오류가 없다면 리버스 프록시까지 정상적으로 설정된 것이다.</p><h3 id="mattermost--2">Mattermost 설정</h3><p>chat.example.com으로 접속하면 초기 화면을 볼 수 있다.</p><p>관리자 계정을 설정하는 부분이다. 관리자 그룹이나 관리자의 메일 계정, 이름, 비밀번호를 입력한다.</p><p>이후 표시된 화면에서 새로운 팀을 생성하거나 시스템 콘솔로 이동해 여러가지 설정을 할 수 있다. 팀을 생성할 수 있도록 되어있는 것은, 하나의 Mattermost 인스턴스에서 여러 팀이 분리되어 의사소통할 수 있도록하기 위함이다. 소규모 회사는 하나의 팀으로, 대규모 회사는 여러 팀으로 쪼개어 생성하면 좋다.</p><p>시스템 콘솔에선 General &gt; Configuration에서 “Site URL”을 반드시 설정한다. 다른 메뉴에선 기본 언어와 SMTP 서버, GitLab 통합, MFA 등을 자유자재로 설정할 수 있다.</p><p>설정을 마치면 본격적으로 Mattermost를 사용할 수 있다.</p><h2 id="mattermost--3">Mattermost 봇 만들어보기</h2><p>Slack과 같이 Mattermost도 봇을 만들어 통합할 수 있다. 깃헙의 attzonko/mmpy_bot을 이용해 챗봇을 만들어보겠다.</p><p>가장 최신 버전의 mmpy_bot을 이용해 개발하려면 Python3와 pip이 요구된다. 먼저 Python3와 pip을 가장 최신으로 업데이트하거나 설치하자.</p><p>이후 아래의 pip 명령어로 mmpy_bot 모듈을 설치할 수 있다.</p><pre><code>$ pip install mmpy_bot</code></pre><p>봇이 로그인할 수 있는 계정을 Mattermost에서 하나 만들어주자. 계정이 생성되면 그 정보를 저장할 <code>mattermost_bot_settings.py</code><br>파일을 프로젝트 루트 디렉토리에 만든다. 그 파일안에 아래와 같이 계정 정보를 명시하면 된다.</p><pre><code>SSL_VERIFY = True  # SSL 인증서 사용 여부
BOT_URL = 'http://&lt;mm.example.com&gt;/api/v3'  # 'http://'와 '/api/v3' 경로를 함께 쓴다. 마지막 ‘/’는 생략. 버전이 3.0보다 낮으면  '/api/v1'를 사용.
BOT_LOGIN = '&lt;bot-email-address&gt;'
BOT_PASSWORD = '&lt;bot-password&gt;'
BOT_TEAM = '&lt;your-team&gt;'
</code></pre><p>위 설정은 환경 변수로 설정해도 된다. Mattermost 봇을 도커로 이미징한 후 배포한다면, 환경 변수나 <code>docker secret</code>을 사용하는 것이 보안상 더 안전하다.</p><p>아래 명령어로 mmpy_bot cli을 호출해 간단하게 봇을 실행할 수 있다. 봇이 실행되면 사용자의 입력을 받을 수 있는 상태가 된다.</p><p><code>MATTERMOST_BOT_SETTINGS_MODULE=mattermost_bot_settings mmpy_bot</code></p><p>우리는 사용자 입력 이후의 행동을 정의해야한다. 같은 디렉토리에 <code>run.py</code>를 생성하고 아래와 같이 작성한다.</p><pre><code>from mmpy_bot.bot import Bot


if __name__ == "__main__":
    Bot().run()
</code></pre><p><code>MATTERMOST_BOT_SETTINGS_MODULE=mattermost_bot_settings python3 run.py</code> 명령어로 봇을 실행해볼 수 있다. 이제 mmpy_bot이 지원하는 여러가지 플러그인을 이용해 사용자의 입력에 응답하는 간단한 봇을 만들어보자.</p><p><code>respond_to</code> 플러그인과 <code>listen_to</code> 플러그인을 사용해보겠다.</p><p>이 플러그인들은 함수의 데코레이터로써 동작한다.</p><p><code>respond_to</code>로 데코레이션된 함수는 DM(Direct Message)이나 채널에서 ‘@봇이름’을 붙여 사용자가 입력한 메시지가 정규식 패턴과 일치할 때 호출된다.<br><code>listen_to</code>로 데코레이션된 함수는 채널에서 사용자가 입력한 메시지가 정규식 패턴과 일치할 때 호출된다.</p><p>둘 중 어떠한 플러그인을 사용할지는 만드는 봇의 명세에 따라 정하면 된다. 예를 들어 “오늘 날씨”와 같은 간단한 공개적 정보 전달이 목적이라면 <code>listen_to</code>를 사용하고 나머지 경우엔 <code>respond_to</code>을 사용하는 것이 바람직하다.</p><p>DM이나 ‘@봇이름’을 붙여 ‘안녕’이라고 채팅을 입력하면 ‘안녕하세요. 저는 봇입니다.’라고 답하고, 채널에서 ‘도와줘’라고 채팅을 입력하면 ‘무엇을 도와드릴까요?’라고 답하는 봇을 만들어보자.</p><pre><code>from mmpy_bot.bot import Bot

from mmpy_bot.bot import listen_to
from mmpy_bot.bot import respond_to


@respond_to('안녕')
def hi(message):
    message.reply('안녕하세요. 저는 봇입니다.')


@listen_to('도와줘')
def help_me(message):
    # 채널에 ‘@사용자’를 붙여 응답
    message.reply('무엇을 도와드릴까요?')

    # 채널에 응답
    # message.send('무엇을 도와드릴까요?')


if __name__ == "__main__":
    Bot().run()
</code></pre><p><code>MATTERMOST_BOT_SETTINGS_MODULE=mattermost_bot_settings python3 run.py</code> 명령어를 입력하여 우리가 만든 봇을 실행할 수 있다. 이후 ‘안녕’과 ‘도와줘’를 입력하여 봇이 정상적으로 응답하는지 확인한다.</p><h2 id="-mattermost">스타트업이라면 Mattermost</h2><p>스타트업이라면 Mattermost를 당장 도입할 것을 추천한다. Slack의 모든 기능을 무료로 사용할 수 있고 속도 또한 빠르며 관리자가 회사의 사정에 맞추어 자유자재로 바꾸어 사용할 수 있다. 스타트업이 겪는 어려움 중 가장 큰 것이 바로 자금난일 것이다. Slack을 사용한다면 매달 사용자당 비용을 지불해야하는데 자금이 넉넉치 않은 스타트업 입장에선 그 돈을 무시할 수 없다. 매달 채팅 서비스를 위해 지출되는 비용을 아껴 더 의미있는 곳에 쓴다면 좋을 것이다. Mattermost가 대놓고 Slack Alternative라고 자칭하는 것엔 이유가 있다.</p>]]></content:encoded></item><item><title><![CDATA[주한미군 CID(범죄수사사령부) 놀러 갔다 온 후기]]></title><description><![CDATA[<p>지난 1월 11일부터 12일까지 CID에 다녀왔습니다. CID는 미군내 중범죄를 다루는 기관으로 MP와는 조금 다릅니다. 특별한 업무가 있어서 다녀온 것은 아니고 근무하는 친구의 Escort를 받고 실컷 즐기다 왔습니다. 재밌는 것도 많이 보고요.</p><p>CID는 현재 동두천에 위치하고 있습니다. 강남에서도 꽤 멉니다... 쩝. 용산 한미연합사도 모두 평택으로 이전했는데 CID와 일부 부대는 아직 동두천에</p>]]></description><link>https://blog.koriel.kr/juhanmigun-cid-beomjoesusasaryeongbu-nolreogassdaon-hugi/</link><guid isPermaLink="false">5c334760ab07ac1d5f9e2d27</guid><category><![CDATA[travel]]></category><category><![CDATA[주한미군]]></category><category><![CDATA[동두천]]></category><category><![CDATA[보산역]]></category><category><![CDATA[CID]]></category><dc:creator><![CDATA[Jinsoo Heo]]></dc:creator><pubDate>Thu, 17 Jan 2019 17:17:42 GMT</pubDate><media:content url="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2019/01/fullsizeoutput_e91-1.jpeg" medium="image"/><content:encoded><![CDATA[<img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2019/01/fullsizeoutput_e91-1.jpeg" alt="주한미군 CID(범죄수사사령부) 놀러 갔다 온 후기"><p>지난 1월 11일부터 12일까지 CID에 다녀왔습니다. CID는 미군내 중범죄를 다루는 기관으로 MP와는 조금 다릅니다. 특별한 업무가 있어서 다녀온 것은 아니고 근무하는 친구의 Escort를 받고 실컷 즐기다 왔습니다. 재밌는 것도 많이 보고요.</p><p>CID는 현재 동두천에 위치하고 있습니다. 강남에서도 꽤 멉니다... 쩝. 용산 한미연합사도 모두 평택으로 이전했는데 CID와 일부 부대는 아직 동두천에 남아있습니다. 흔히 이야기하는 MP(Military Police)와 CID(Criminal Investigation Command)는 조금 다릅니다. CID는 미군내 중범죄를 수사합니다. 부대 이외의 지역에서도 미군과 관련된 사항이면 한국에서도 수사가 가능하다고 합니다.</p><p>동부이촌동 살 시절엔 바로뒤에 한미연합사와 미8군 부대가 있어서 독립기념일마다 불꽃놀이를 보며 즐겼는데 최근 다시 부대안을 들어가보니 느낌이 색다르더군요. 부대 안은 그냥 미국입니다. 실제 주소도 CA(California)로 되어있고 미국 영토로 간주되어 미국에서 물품을 구입할 시 관세도 붙지 않습니다.</p><p>부대 입구는 동두천 보산역에서 가장 가깝습니다. 역에서 내려 조금만 걸어가면 검문소가 나오고 Escort하는 분과 간단한 신분 확인 절차만 거치면 들어갈 수 있습니다. 검문소에서 일하시는 분들은 의외로 모두 한국분이시더군요. 하지만 영어를 유창하게 하십니다. 마치 미국 입국 심사대같은 느낌을 받았습니다.</p><figure class="kg-image-card"><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2019/01/wdzlLM3FQtWp1SSMb17aNg.jpg" class="kg-image" alt="주한미군 CID(범죄수사사령부) 놀러 갔다 온 후기"><figcaption>방문객 게이트</figcaption></figure><p>신분증을 제출하고 뒤에 앉아 기다리니 금방 끝났습니다. 위험 물품을 소지하고 있는지는 딱히 확인하지 않더군요. 물론 제가 그런 물건을 가지고 있던 건 아니었습니다 ㅎㅎ. 뒤로 들어가 마지막 보안 검사를 마치면 바로 광활한 부대가 펼쳐집니다.</p><figure class="kg-image-card"><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2019/01/fullsizeoutput_e91.jpeg" class="kg-image" alt="주한미군 CID(범죄수사사령부) 놀러 갔다 온 후기"><figcaption>반바지의 위엄</figcaption></figure><p>들어가니 왼쪽에 Barrack과 여러 건물들이 보입니다. 우리나라 길거리의 풍경과는 확연히 다릅니다. 아까도 이야기했다시피 그냥 미국입니다. 그나저나 앞에 뒷모습이 찍히신 분들은 이 날씨에 반바지라니 참 대단하시군요. 밤에 찍은 사진이라 크기가 잘 짐작이 안되지만 정말 넓습니다. 그리고 산골이라 공기가 맑을 줄 알았지만 그건 또 아니더군요. 쭉 걸어가서 CID office에 도착합니다.</p><figure class="kg-image-card"><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2019/01/r92krXl4Ti-nQVH2SJc5zg.jpg" class="kg-image" alt="주한미군 CID(범죄수사사령부) 놀러 갔다 온 후기"><figcaption>어색한 미소</figcaption></figure><p>MP와 CID 건물은 근무 요원의 Escort가 없으면 절대 출입할 수 없습니다. 모든 곳에 Warning이 덕지덕지 붙어있습니다. 보안상의 이유로 사무실 내부는 촬영하지 못했지만 상당히 자유로운 분위기에서 일하고 계셨고 대장님도 반팔 반바지 차림으로 밤 11시까지 일하고 계시더군요. 그리고 CID 근무자는 계급장을 붙이고 다니지 않습니다. 수사에 방해가 되기 때문이겠죠. 참 재밌는 것들이 많았습니다. 저 사진 왼쪽엔 역대 CID 헌병감들의 사진이 모두 걸려있는데 위압감이 상당합니다. 그리고 맨 왼쪽엔 Commander in Chief... 트럼프 대통령의 사진이 걸려있습니다. 지릴뻔 했습니다.</p><p>CID 내에도 계급이 존재하지만 의사소통은 매우 자유롭게 하는 편이더군요. 오히려 한국 기업들보다 더 자유롭습니다. 상병이 대장앞에서 다리를 꼬고 이야기를 하기도 하고 그냥 자유롭게 이야기합니다. 무엇보다 일만 잘하면 된다는 생각이 뿌리깊히 자리잡은 것 같습니다. 요원마다 private office가 하나씩 있습니다. 굉장히 넓습니다.</p><figure class="kg-image-card"><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2019/01/3B9E2718-F8B9-4CBD-9065-6C140226055C.jpg" class="kg-image" alt="주한미군 CID(범죄수사사령부) 놀러 갔다 온 후기"><figcaption>보안상 문제가 될 수 있는 부분은 블러 처리했습니다. 담당자의 승인이 있었습니다.</figcaption></figure><p>근무자의 사무실입니다. 가장 흥미로웠던 건 Microsoft에서 미육군용 Windows를 따로 만들어 납품한다는 사실이었습니다. 우리가 평소에 쓰는 Windows와 많이 다릅니다. 화면별로 Classified(기밀), Unclassified(기밀 해제)가 표시되고 접속 절차도 조금 다릅니다. 그리고 한국 인터넷망에 연결되지 않기 때문에 웹서핑은 자유롭게 못하더군요. 그건 한국군도 마찬가지지만요. 영화에서 흔히 보던 기관의 마크가 딱 찍힌 모니터의 모습입니다. 제 사무실보다 좋아서 기분이 갑자기 안좋아졌습니다. 농담입니다.</p><p>좀 돌아다녔으니 밥을 먹을 타이밍이 됐습니다. 식사할 수 있는 곳은 배식소, 클럽(우리가 아는 그 클럽이 아닙니다. 펍이라고 생각하시면 됩니다.), 스테이크 하우스가 있습니다. 고기가 짱이죠. 스테이크 하우스를 기쁜 마음 가득 안고 갔으나 8시가 넘어 닫았더군요. 그래서 그냥 새벽 1시까지 하는 클럽으로 들어가서 피자를 마음껏 먹었습니다.</p><figure class="kg-image-card"><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2019/01/saldyrLqQqqmlMWJyWlV0w.jpg" class="kg-image" alt="주한미군 CID(범죄수사사령부) 놀러 갔다 온 후기"><figcaption>완전 미국식 피자</figcaption></figure><p>클럽에선 여러 종류의 피자와 햄버거를 팝니다. 가격은 그냥 한국에서 먹는 것과 비슷한 수준입니다. 다만 결제를 달러화로 해야합니다. VISA 카드 없으면 결제가 안되니 혹시라도 가시게 된다면 꼭 준비하세요. 여기서 피자 먹겠다고 환전해가긴 좀 그렇잔아요. 종업원분들도 굉장히 친절했습니다. 한국어, 영어 모두 유창하게 하십니다. 항상 밝게 웃으시고 친구처럼 대해주시더군요. 전 그런 게 참 좋습니다.</p><p>좀 기다리다보니 피자가 금방 나왔습니다. 미국식 피자 그 자체입니다. 짭쪼름하고 대따 큰 그 피자. 아주 마음에 들었습니다. 전 피자광이거든요. 저 크기의 피자도 혼자 다 먹습니다. 어제도 하루 2끼를 피자로 먹었습니다. 피자는 신의 음식입니다. 아무튼 피자를 받고보니 영수증이 위에 있어서 조금 당황했지만, 신경쓰지 않습니다. 바로 치워버리고 입에 넣기 시작합니다. 아 맛있습니다. 셀프바에 가면 페퍼 가루와 여러 소스들이 있는데 그것을 같이 섞은 다음 피자를 거기에 찍어먹으면 참 맛있습니다. 둘이서 몇분만에 거뜬히 먹고 퇴장합니다. 이제 잠자러 가야죠.</p><p>식당에서부터 CID 숙소까지는 꽤 멉니다. 그래서 걸어갈 순 없고 차를 타고 가야합니다. 염치없는 마음으로 친구 차를 얻어타고 Barrack까지 이동했습니다.</p><figure class="kg-image-card"><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2019/01/JqKsDSCiR7aZNqo5dZKX9Q.jpg" class="kg-image" alt="주한미군 CID(범죄수사사령부) 놀러 갔다 온 후기"><figcaption>MP 차량, 디자인이 참 멋있습니다.</figcaption></figure><figure class="kg-image-card"><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2019/01/65A4C4CB-1D28-4815-B3BF-791415498CB4.jpg" class="kg-image" alt="주한미군 CID(범죄수사사령부) 놀러 갔다 온 후기"><figcaption>미육군 번호판이 따로 있습니다.</figcaption></figure><p>아래 소나타 차량을 타고 이동했는데, 번호판이 우리가 보던 것과 다릅니다. 부대안에서 운행하는 차량은 군용 번호판을 따로 달고 다닙니다. 이쯤에서 궁금한 게 생길 겁니다. 그럼 저 차를 끌고 부대 밖으로 나갈 수 있나? 네, 나갈 수 있습니다. 자세한 이야기는 위험해질 수 있으니 생략하도록 하죠.</p><p>그리고 부대안에 한국 택시가 굉장히 많습니다. 미군들이 시내에 나갈 때 택시를 많이 타기 때문인데, 승인 받은 택시들은 부대안에서 영업을 할 수 있다고 합니다.</p><p>Barrack에 들어가니 방은 굉장히 넓습니다. 침실과 거실이 따로 있고 여러 전자기기들도 갖춰져 있습니다.</p><figure class="kg-image-card"><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2019/01/BE55A527-E9CC-41B4-BFB8-5516963A3D1A.jpg" class="kg-image" alt="주한미군 CID(범죄수사사령부) 놀러 갔다 온 후기"><figcaption>거실</figcaption></figure><p>왼쪽에 보이는 소파가 상당히 편했습니다. 요즘 보는 책 이야기도 하면서 노닥거렸습니다. 소위 드래곤 스킨이라고 불리는 방탄복도 입어봤는데 상당히 무겁습니다. 10kg 가까이 되는 무게입니다. 드래곤 스킨은 입방정 질화 붕소로 만들어지는데 일반적인 납탄은 절대 뚫지 못합니다. 그래도 총 맞으면 겁나 아프겠죠. 전 안맞아봐서 모릅니다.</p><figure class="kg-image-card"><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2019/01/D565EE44-0EDF-4F3A-B092-D3F6CA514AAB.jpg" class="kg-image" alt="주한미군 CID(범죄수사사령부) 놀러 갔다 온 후기"><figcaption>슬리퍼가 포인트</figcaption></figure><p>담배도 피며 이런 저런 이야기를 하다보니 어느새 새벽 가까이 되었고 잠이 들 시간이 되었습니다. 미국엔 HVAC이라고 주택마다 공조 장치가 있는데, 여기도 마찬가지였습니다. 온도에 맞춰서 히터와 환풍 기구가 알아서 돌아갑니다. 따뜻하니 아주 좋더군요. 꿀잠 잤습니다.</p><figure class="kg-image-card"><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2019/01/Nym6Xry2QCeE-S8xyRsaMA-1.jpg" class="kg-image" alt="주한미군 CID(범죄수사사령부) 놀러 갔다 온 후기"><figcaption>Barrack 뒤 마당</figcaption></figure><p>Barrack 뒤에 큰 마당이 있는데 숨이 탁 트이고 좋았습니다. 앞쪽에 산이 크게 보여서 경관도 아름다웠습니다. 밤에 본 풍경과는 완전히 달랐습니다. 그냥 무지하게 넓다는 느낌. 가을이 되면 더 이쁘다는데 가을에 한번 더 와야겠습니다. 그땐 반드시 차를 가지고... 너무 멉니다. 아침에 피는 담배 한대는 참 좋습니다. 경치를 즐기며 한숨 돌리고 부대 밖으로 나갑니다.</p><p>보산역 뒤쪽에 굉장히 맛있는 부대찌개집이 있습니다. 백종원의 3대 천왕에도 나왔다는데 그럴만 하더군요. 둘이서 맛있게 먹고 집으로 귀가했습니다.</p><p>이틀동안 짧은 여행을 한 기분이었습니다. 참 좋더군요. 마주치는 사람들도 재밌었고 친절하고. 이만 마무리하겠습니다.</p>]]></content:encoded></item><item><title><![CDATA[50분 생각하고 10분 코드 작성하세요]]></title><description><![CDATA[<p>대개 개발을 한다고 하면 키보드부터 잡는 경우가 많습니다.</p><p>하지만, 좋지 않습니다. 소프트웨어 설계와 알고리듬 설계는 키보드로부터 시작하는 것이 아니거든요.</p><p>개발해야할 기능이 있다고 하면 처음엔 단순하게 시작하게 되지만 막상 코드를 작성하다보면 여러 예외 상황들이 생기고 그것들을 처리하기 위한 분기들이 여럿 생기게 됩니다.</p><p>이런 상황에서 코드부터 작성하면 기존의 코드 구조에 얽매여 그</p>]]></description><link>https://blog.koriel.kr/50bun-saenggaghago-10bun-kodeu-jagseonghaseyo/</link><guid isPermaLink="false">5c241a15ab07ac1d5f9e2d0d</guid><category><![CDATA[thinking]]></category><category><![CDATA[software architecture]]></category><category><![CDATA[development]]></category><category><![CDATA[note taking]]></category><category><![CDATA[생각]]></category><category><![CDATA[개발 방법]]></category><category><![CDATA[개발 습관]]></category><category><![CDATA[노트 정리]]></category><dc:creator><![CDATA[Jinsoo Heo]]></dc:creator><pubDate>Thu, 27 Dec 2018 00:25:17 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1527345931282-806d3b11967f?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1527345931282-806d3b11967f?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="50분 생각하고 10분 코드 작성하세요"><p>대개 개발을 한다고 하면 키보드부터 잡는 경우가 많습니다.</p><p>하지만, 좋지 않습니다. 소프트웨어 설계와 알고리듬 설계는 키보드로부터 시작하는 것이 아니거든요.</p><p>개발해야할 기능이 있다고 하면 처음엔 단순하게 시작하게 되지만 막상 코드를 작성하다보면 여러 예외 상황들이 생기고 그것들을 처리하기 위한 분기들이 여럿 생기게 됩니다.</p><p>이런 상황에서 코드부터 작성하면 기존의 코드 구조에 얽매여 그 이후의 코드가 지저분해지는 경우가 굉장히 많습니다.</p><p>기존 사고의 틀에서 벗어나지 못하여 마치 개미가 집짓듯 마구 덧붙이는 식이 되어버리는 거죠.</p><p>저는 코드를 작성하기 전에 가만히 앉아 10분 정도 생각하고 40분 정도는 앉아서 노트에 뭘 적기 시작합니다.</p><p>어떤 기능의 시작점부터 마지막점까지 노트에 볼펜으로 쭉 써내려가면서 예외 상황들을 정리하고 그것들을 고려한 코드 설계를 다듬어가는거죠.</p><p>먼저 작고 들고다닐 수 있는 노트를 준비하세요. 저는 <a href="http://item.gmarket.co.kr/Item?goodscode=1157704859" rel="nofollow">옥스포드의 리갈패드 미니 노랑</a>를 추천합니다.</p><p>항상 들고다니면서 어떤 기능에 대한 새로운 예외나 오류 처리에 대한 생각을 마구 적습니다. 그리고 차분하게 앉아 생각할 곳이 생기면 도표로 그리면서 코드를 설계합니다. 그렇게 다듬어가다보면 코드를 어떻게 작성해야겠다는 생각이 머릿속에 떠오르고 실제로 그것을 코드로 옮기는 데에는 5분에서 10분이 채 걸리지 않습니다. 노트에 적어놓은 구조만 그대로 번역하면 되니까요.</p><p>아래는 제가 회사에서 최근에 개발하는 2가지 기능에 대한 노트 필기 중 일부입니다. 기능 개발 구상 단계에서 가장 처음 작성한 것으로 알아보기 힘들 수 있습니다. 하지만 괜찮습니다. 이런 노트는 남에게 보여주기 위한 것이 아니라 혼자 생각을 정리하기 위한 용도거든요. 무엇이든지 적어놓지 않으면 시간이 흘러 잊기 마련입니다.</p><p>이렇게 Draft를 그린 후 생각을 다듬어 도표를 그리고 코드를 어떻게 작성해야겠다는 생각이 드는 순간 일은 사실 끝난 것이나 마찬가집니다. 코드를 작성하는 건 단지 타이핑일 뿐이거든요.</p><figure class="kg-image-card"><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2018/12/IMG_0267.jpeg" class="kg-image" alt="50분 생각하고 10분 코드 작성하세요"></figure><figure class="kg-image-card"><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2018/12/IMG_0268.jpeg" class="kg-image" alt="50분 생각하고 10분 코드 작성하세요"></figure><p>이 노트를 어딜가나 들고다닙니다. 버스나 지하철, 집앞에서 담배필 때까지. 개발자로서 일을 하다보면 업무 시간 이외에도 항상 본인이 작성하는 코드에 대해 생각을 할 수 밖에 없습니다. 길을 가다가도 문득 좋은 아이디어가 떠오르면 바로바로 적어두는 거죠. 그래야 나중에 시간날 때 다듬어야지.. 하면서 마음 편하게 다닐 수 있습니다.</p><p>개발 업무 이외에도 일정 관리나 새로운 기능에 대한 아이디어, 버그에 대한 해결 방법도 주로 이런 방법을 사용합니다.</p><p>한번 해보세요!</p>]]></content:encoded></item><item><title><![CDATA[Vim은 어디서 왔나]]></title><description><![CDATA[<blockquote>
<p>이 글은 <a href="https://twobithistory.org/2018/08/05/where-vim-came-from.html">Where Vim Came From</a>을 번역한 글입니다.</p>
</blockquote>
<p>나는 최근에 Intel HEX로 알려진 파일 포맷을 우연히 발견했다. 내가 아는 한, Intel HEX 파일(.hex 확장자를 사용하는)은 바이너리 이미지를 16진수들의 집합으로 인코딩해서 좀 더 잘 볼 수 있게 만든 것이다. 알아보니 마이크로 컨트롤러를 프로그램하거나 ROM에 데이터를 구워야 하는 사람들이</p>]]></description><link>https://blog.koriel.kr/where-vim-came-from/</link><guid isPermaLink="false">5b6a9570bed6e93b0b94190c</guid><category><![CDATA[vim]]></category><category><![CDATA[vi]]></category><category><![CDATA[ed]]></category><category><![CDATA[ex]]></category><category><![CDATA[em]]></category><category><![CDATA[text editor]]></category><category><![CDATA[line editor]]></category><category><![CDATA[history]]></category><dc:creator><![CDATA[Jinsoo Heo]]></dc:creator><pubDate>Thu, 09 Aug 2018 16:59:51 GMT</pubDate><media:content url="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2018/08/Ken_Thompson_-sitting-_and_Dennis_Ritchie_at_PDP-11_-2876612463--2.jpg" medium="image"/><content:encoded><![CDATA[<blockquote>
<img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2018/08/Ken_Thompson_-sitting-_and_Dennis_Ritchie_at_PDP-11_-2876612463--2.jpg" alt="Vim은 어디서 왔나"><p>이 글은 <a href="https://twobithistory.org/2018/08/05/where-vim-came-from.html">Where Vim Came From</a>을 번역한 글입니다.</p>
</blockquote>
<p>나는 최근에 Intel HEX로 알려진 파일 포맷을 우연히 발견했다. 내가 아는 한, Intel HEX 파일(.hex 확장자를 사용하는)은 바이너리 이미지를 16진수들의 집합으로 인코딩해서 좀 더 잘 볼 수 있게 만든 것이다. 알아보니 마이크로 컨트롤러를 프로그램하거나 ROM에 데이터를 구워야 하는 사람들이 쓴단다. 어쨌든, 내가 Vim에서 처음으로 HEX 파일을 열었을 때, 놀라운 걸 발견했다. 이 파일 포맷은 적어도 나한텐 매우 난해한 것이었지만 Vim은 이미 그것에 대해 모두 알고 있었다. HEX 파일의 각 행은 서로 다른 필드로 나눠진 레코드이다—Vim은 앞서서 각각의 필드를 다른 색으로 표시했다. 존경하는 눈빛으로 난 <code>set ft?</code>라고 물었고 Vim이 <code>filetype=hex</code>라 대답했다. 쩐다.</p>
<p>Vim은 어디에나 있다. 정말 많은 사람이 사용하기 때문에 HEX 파일 지원 같은 건 별로 놀라운 것도 아니다. Vim은 Mac OS에 같이 딸려오고 Linux 세계에선 큰 지지를 받고 있다. Vim을 싫어하는 사람에게조차 익숙한데, 그건 인기 있는 커맨드 라인 도구들이 기본적으로 Vim을 사용해서 사용자들이 특별한 지식 없이 Vim에 갇혀 버리는 게 일종의 밈(meme)이 되어버렸기 때문이다. 페이스북을 포함해서 <code>j</code> 키로 스크롤을 내리고 <code>k</code> 키로 올리는 주요 웹사이트들도 있다. 디지털 문화를 통해 퍼진 Vim의 끝판왕 격이다.</p>
<p>근데도 Vim은 여전히 미스터리다. 예를 들어, 페이스북이 개발하고 유지보수하는 걸 모두가 알고 있는 React랑 다르게, Vim은 정해진 스폰서가 없다. 어디에나 있고 그렇게 중요한데, Vim에 관한 결정을 내리는 위원회나 조직 같은 건 없다. Vim을 누가 만들었고 왜 만들었는지 잘 모르는 사람은 <a href="https://www.vim.org/">Vim 웹사이트</a>를 보는 데 시간이 좀 걸릴 것이다. 파일 인자를 넣지 않고 Vim을 실행하면, &quot;Bram Moolenaar et al&quot;에 의해 개발됐다는 Vim의 시작 메시지를 볼 수 있다. 하지만 그게 많은 걸 알려주진 않는다. Bram Moolenaar은 누구고 잘 알려지지 않은 그의 동료들은 어떤 사람들일까?</p>
<p>이런 질문을 하면서 좀 더 중요할 수도 있는 건, Vim을 빠져나가려면 왜 <code>:wq</code>을 쳐야 하는가이다. 물론 그건 &quot;쓰기(write)&quot; 동작 이후의 &quot;나가기(quit)&quot; 동작인데, 그다지 직관적인 규칙은 아니다. 도대체 누가 텍스트 복사를 &quot;홱 잡아당기기(yanking)&quot;으로 바꿔 부르기로 한 걸까? 왜 <code>:%s/foo/bar/gc</code>가 &quot;찾아서(find) 바꾸기(replace)&quot;가 되는 걸까? Vim의 이런 천방지축은 이해할 수 없을 정도로 제 멋대로이긴 하지만, 그것들은 어디서 온 걸까?</p>
<p>진부하긴 하지만 그 해답은 고대 컴퓨팅의 도가니, 벨 연구소(Bell Labs)에 있다. 어떻게 보면 Vim은 Unix 시대의 서막부터 지속해서 개발되고 개선된 &quot;wq 텍스트 편집기&quot;라고 하는 소프트웨어의 최신판일 뿐이다.</p>
<h1 id="kenthompson">Ken Thompson, 행 편집기를 만들다</h1>
<p>1996년에, 벨 연구소는 켄 톰슨(Ken Thompson)을 고용했다. 톰슨이 버클리의 캘리포니아 대학교(University of California)에서 막 전자공학과 컴퓨터과학 석사 학위를 딴 참이었다. 거기서 그는 QED라는 텍스트 편집기를 사용했는데 그건 1965년과 1966년 사이에 버클리 시분할 시스템 (Berkeley Timesharing System)<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>을 위해 작성된 것이었다. 톰슨이 벨 연구소에서 처음 한 일 중 하나가 MIT 호환 시분할 시스템을 위해 QED를 재작성하는 것이었다. 그는 나중에 Multics 프로젝트의 일환으로 QED의 또 다른 버전을 만들었다. 그 과정에서 그는 사용자가 파일의 행을 검색하고 정규식을 사용하여 문자열을 대체할 수 있도록 프로그램을 확장했다.<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
<p>버클리 시분할 시스템과 마찬가지로 상업적으로 사용 가능한 시분할 운영 체제를 개발하려는 Multics 프로젝트는 MIT와 General Electric, Bell Labs 간의 협력 사업이었다. 결과적으로 AT&amp;T가 성과가 없다고 판단하여 끝내버린 사업이다. 그러자 톰슨과 벨 연구소의 연구원인 데니스 리치 (Dennis Ritchie)는 시분할 시스템에 대한 접근권 없이 이러한 시스템이 제공하는 &quot;대화형 컴퓨팅의 느낌&quot;을 잃어버린 채 결국 Unix로 알려진 자신들만의 버전을 만들게 된다.<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> 1969년 8월, 톰슨의 아내와 어린 아들이 캘리포니아로 휴가를 떠났을 때, 그는 새 시스템의 기본 구성 요소를 모아 &quot;운영 체제와 쉘, 편집기, 어셈블러에 각각 일주일씩 할당&quot;했다.<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p>
<p>그때 만든 편집기는 <code>ed</code>라고 불렸다. QED에 기초를 두긴 했지만, 똑같이 재구현한 것은 아니었다. 톰슨은 QED의 기능에서 몇 가지를 빼기로 했다. 정규식 지원은 비교적 단순한 정규식만 이해할 수 있도록 바꿨다. QED는 다중 버퍼를 사용해서 사용자가 여러 파일을 동시에 편집할 수 있었지만 <code>ed</code>는 한 번에 한 버퍼만 작업할 수 있었다. 또 QED가 명령을 포함하는 버퍼를 실행할 수 있었던 반면, <code>ed</code>는 그럴 수 없었다. 이런 단순화는 꼭 필요한 것이었을 수도 있다. 데니스 리치는 QED의 고급 정규식을 없앤 것이 &quot;별로 큰 손실은 아니다&quot;라고 말했었다.<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></p>
<p><code>ed</code>는 이제 POSIX 스펙의 일부이다. 그래서 POSIX 호환 시스템을 가지고 있으면 컴퓨터에 설치된 걸 볼 수 있다. <code>ed</code>의 명령어 중 다수가 오늘날 Vim의 것이 되었기 때문에 한 번 가지고 놀아볼 가치는 있다. 예를 들어 디스크에 버퍼를 쓰기 위해선, <code>w</code> 명령어를 치면 된다. 편집기를 나가기 위해선, <code>q</code>를 치면 된다. 이 두 명령어는 <code>wq</code>처럼 같은 줄에 한 번에 쓸 수도 있다. <code>ed</code>는 Vim처럼 대화형 편집기이다. 명령 모드에서 입력 모드로 들어가기 위해선, 텍스트를 어떻게 바꿀지에 따라 입력 명령 (<code>i</code>)이나 추가 명령 (<code>a</code>), 변경 명령 (<code>c</code>)을 입력하면 된다. <code>ed</code>는 또한 텍스트를 찾고 바꾸거나 &quot;대체 (substitute)&quot;하기 위해 <code>s/foo/bar/g</code> 구문을 도입했다.</p>
<p>이런 비슷한 점을 고려하면, 평균적인 Vim 사용자가 <code>ed</code>도 문제없이 사용할 거로 생각할 수 있다. 하지만 <code>ed</code>은 또 다른 주요 특징에서 Vim과 완전히 다르다. <code>ed</code>는 진정한 행 편집기이다. 텔레프린터 (teletype printer) 시대에 작성되어 널리 사용되었던 것이다. 켄 톰슨과 데니스 리치가 Unix 일을 하고 있었을 때, 그 모습은 이랬다.</p>
<p><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2018/08/Ken_Thompson_-sitting-_and_Dennis_Ritchie_at_PDP-11_-2876612463-.jpg" alt="Vim은 어디서 왔나"></p>
<p><code>ed</code>는 변경 사항이 있을 때마다 전체 파일을 전부 다시 재출력해야 하므로 열려있는 버퍼에서 행들을 오가며 편집하거나 커서를 옮길 수 없다. 화면이라는 게 종이일 뿐이고 모든 것이 잉크로 출력되던 때였기 때문에 1969년 <code>ed</code>엔 화면의 내용을 &quot;지우는 (clear)&quot; 메커니즘이 없었다. 필요하면, 목록 명령 (l)을 이용해 특정 범위의 행을 <code>ed</code>가 출력하게 할 수 있지만 대부분 보이지 않는 텍스트에 대해 작업하게 될 뿐이다. 그래서 <code>ed</code>를 사용하는 것은 빛이 약한 손전등으로 어두운 집 주위에서 길을 찾으려고 애쓰는 것과 비슷하다. 한 번에 보이는 것만 볼 수 있기 때문에, 모든 것이 다 어디에 있는지 기억해야만 한다.</p>
<p>여기 <code>ed</code>를 사용하는 예제가 있다. 내가 각 행의 목적을 설명하는 주석 (<code>#</code> 문자 이후)을 달아놨다. 주석까지 그대로 입력하면 <code>ed</code>가 인식하지 못하고 오류를 뱉을 것이다.</p>
<pre><code class="language-shell">[sinclairtarget 09:49 ~]$ ed
i                           # Enter input mode
Hello world!

Isn't it a nice day?
.                           # Finish input
1,2l                        # List lines 1 to 2
Hello world!$
$
2d                          # Delete line 2
,l                          # List entire buffer
Hello world!$
Isn't it a nice day?$
s/nice/terrible/g           # Substitute globally
,l
Hello world!$
Isn't it a terrible day?$
w foo.txt                   # Write to foo.txt
38                          # (bytes written)
q                           # Quit
[sinclairtarget 10:50 ~]$ cat foo.txt
Hello world!
Isn't it a terrible day?
</code></pre>
<p>보이는 대로, <code>ed</code>가 특별히 말이 많은 프로그램은 아니다.</p>
<h1 id="billjoy">Bill Joy, 텍스트 편집기를 만들다</h1>
<p><code>ed</code>도 톰슨과 리치를 위해선 충분히 잘 작동한다. 하지만 다른 사람들은 사용하기가 어려웠고 Unix의 초보자에 대한 불친절함의 대명사라는 평판을 얻었다.<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup> 1975년에, 조지 클루리스 (George Coulouris)라는 사람이 런던의 퀸 메리 대학에 설치된 Unix 시스템에서 <code>ed</code>의 개량판을 개발했다. 클루리스는 퀸 메리에서 사용 가능한 비디오 디스플레이를 활용하기 위해 편집기를 만들었다. <code>ed</code>랑 다르게, 클루리스의 프로그램은 키를 눌러 줄을 옮겨가며 한 번에 한 줄씩 편집할 수 있었다. (Vim을 한 번에 한 줄씩 사용한다고 생각하면 된다). 클루리스는 그의 프로그램에 <code>em</code>이라는 이름을 붙였다. 또는 &quot;인간을 위한 편집기 (editor for mortals)&quot;라고도. 톰슨이 퀸 메리를 방문한 이후에 영감을 얻은 것으로 보였다. 그는 클루리스가 만든 프로그램을 보고 편집 도중 파일의 상태를 볼 필요는 없다면서 무시했었다.<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup></p>
<p>1976년, 클루리스는 UC 버클리로 가면서 <code>em</code>도 함께 가져갔다. 거기서 그는 컴퓨터과학부의 방문객으로서 여름을 보냈다. 켄 톰슨이 버클리를 떠나 벨 연구소에서 일한 후로 정확히 10년이 되는 때였다. 버클리에서, 클루리스는 Berkeley Software Distribution (BSD)에 참여하고 있는 대학원생, 빌 조이 (Bill Joy)를 만났다. 클루리스는 조이에게 <code>em</code>을 보여줬고 조이는 그의 코드를 보고 &quot;확장된 <code>ed</code>&quot;라는 뜻의 <code>ed</code>의 개량 버전, <code>ex</code>를 만들기 시작했다. <code>ex</code>의 1.1 버전은 1978년 BSD Unix의 첫 릴리즈와 함께 배포됐다. <code>ex</code>는 전체적으로 <code>ed</code>와 호환됐지만, <code>em</code>에서와 같이 한 줄 편집이 가능한 &quot;열린 (open)&quot; 모드와 우리가 요즘 쓰는 것처럼 전체 화면을 오가며 파일 전부를 실시간으로 편집할 수 있는 &quot;시각 (visual)&quot; 모드가 추가됐다.</p>
<p>1979년 BSD의 두 번째 릴리즈에선, 시각 모드로 연 <code>ex</code>보다 조금 더 많은 걸 할 수 있는, <code>vi</code>라는 실행 파일이 포함됐다.<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup></p>
<p><code>ex</code>/<code>vi</code> (이후 <code>vi</code>)는 <code>ed</code>엔 없었던, Vim과 관련된 대부분의 규칙을 세웠다. 조이가 사용하던 비디오 단말기 (video terminal)는 Lear Siegler ADM-3A였고 방향키가 없는 키보드가 달려있었다. 대신 화살표들이 <code>h</code>와 <code>j</code>, <code>k</code>, <code>l</code> 키 위에 인쇄되어 있었다. 바로 그게 조이가 이 키들을 <code>vi</code>에서 커서 이동키로 사용했던 이유다. ADM-3A 키보드의 ESC 키는 오늘날 탭키 자리에 있었다. 이건 그렇게 누르기 힘든 키가 어떻게 일반적으로 어떤 모드를 빠져나가는 동작에 할당됐는지를 설명해준다. 명령어 앞에 붙는 <code>:</code> 문자도 <code>vi</code>로부터 왔고 <code>:</code>는 일반 모드 (regular mode, <code>ex</code>를 실행하면 나오는 모드)에서 프롬프트 키로 사용된다. 이건 한번 실행하면 사용자가 아무것도 할 수 없는 <code>ed</code>에 대한 오랜 불만 사항을 해결한 것이다. 시각 모드에서 저장하고 종료하려면 이제는 당연한 <code>:wq</code>를 입력하는 작업이 필요하다. &quot;홱 잡아당기기 (Yanking)&quot;과 &quot;넣기 (Putting)&quot; 기호, 그리고 옵션을 설정하기 위한 <code>set</code> 명령어는 모두 원래 <code>vi</code>의 일부였다. Vim에서 기본적인 텍스트 편집을 할 때 우리가 사용하는 이 기능들은 대부분 <code>vi</code>의 기능들이다.</p>
<p><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2018/08/LSI-ADM3A-full-keyboard.jpg" alt="Vim은 어디서 왔나"></p>
<p><code>vi</code>는 <code>ed</code> 이외에 BSD Unix에 포함된 유일한 텍스트 편집기였다. 그 당시, Emacs는 수백 달러를 호가했었고 (GNU Emacs 이전이다), 그래서 <code>vi</code>의 인기가 대단했다. 하지만 <code>vi</code>는 <code>ed</code>의 직계 후손이었고 그 때문에 AT&amp;T의 소스 라이선스없이는 코드 수정이 불가능했다. 이 문제가 몇몇 사람들이 <code>vi</code>의 오픈 소스 버전을 만들게 된 동기가 됐다. 1987년엔 STEVIE (ST Editor for VI Enthusiasts)가 등장했고 1990년엔 Elvis, 1994년엔 <code>nvi</code>가 등장했다. 이 복제판 중 몇몇은 구문 강조 (syntax highlighting)와 화면 분할 같은 추가 기능들이 추가됐다. Elvis는 특히 Vim에 포함된 기능들을 많이 가지고 있었는데 그건 Elvis 사용자들이 넣어달라고 강력하게 요구했기 때문이다.<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup></p>
<h1 id="brammoolenaarvim">Bram Moolenaar, Vim을 만들다</h1>
<p>지금은 &quot;Vi Improved&quot;를 뜻하는 &quot;Vim&quot;이 원래는 &quot;Vi Imitation&quot;을 나타내는 말이었다. 다른 많은 <code>vi</code> 복제판들처럼, Vim도 사용할 수 없는 플랫폼으로 복제하려는 시도로 시작됐다. 벤로 (Venlo)의 복사기 회사에서 일하던 네덜란드 소프트웨어 엔지니어, 브람 무레나르 (Bram Moolenaar)는 그의 신상 Amiga 2000에서 사용할 <code>vi</code> 비슷한 것을 원했다. 무레나르는 그의 대학에서 Unix 시스템의 <code>vi</code>를 사용하는 데 익숙했었고 &quot;자유자재로 다루는&quot; 경지에 올랐었다.<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup> 그래서 1988년에 기존의 STEVIE <code>vi</code> 복제판을 시작으로, 무레나르는 Vim 개발에 돌입했다.</p>
<p>STEVIE는 이전에 Fred Fish의 디스크로 배포됐기 때문에 무레나르가 STEVIE에 접근할 수 있었다. Fred Fish란 미국 프로그래머로, 매월 Amiga 플랫폼에서 사용할 수 있는 최고의 오픈 소스 소프트웨어를 선정하여 플로피 디스크에 넣어 발송했었다. 누구든지 우편 비용만 내고 디스크를 신청할 수 있었다. STEVIE의 몇몇 버전은 Fred Fish의 디스크로 릴리즈됐다. 무레나르가 사용한 버전은 Fred Fish의 256번 디스크로 릴리즈된 것이었다.<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup> (실망스럽게도 Fred Fish의 디스크는 <a href="https://en.wikipedia.org/wiki/Freddi_Fish">Freddi Fish</a>와 전혀 관련이 없는 거로 보인다.)</p>
<p>무레나르는 STEVIE를 마음에 들어 했지만 <code>vi</code>의 명령어가 많이 빠져있다는 걸 금세 알게 됐다.<sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup> 그래서 무레나르는 Vim의 첫 릴리즈 때 <code>vi</code> 호환성을 최우선으로 생각했다. 어떤 사람이 <code>vi</code> 호환 매크로 편집기를 통해 임의로 생성된 미로를 풀 수 있는 일련의 <code>vi</code> 매크로를 작성하기도 했는데 무레나르는 이 매크로를 Vim에서 작동하게 만들 수 있었다. 1991년, Vim이 Fred Fish의 591번 디스크에 &quot;Vi Imitation&quot;이라는 이름으로 처음 릴리즈됐다.<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup> 무레나르는 여러번 되돌리기 (multi-level undo)와 컴파일 에러를 위한 &quot;빠른 고침 (quickfix)&quot; 모드를 포함하여 몇 가지 기능들을 추가했다. 이건 Vim이 <code>vi</code>를 능가했다는 것을 의미했다. 하지만 이후 FTP를 통해 1993년에 Vim 2.0이 나올 때까진 &quot;Vi Imitation&quot;으로 남아있었다.</p>
<p>무레나르는 여러 인터넷 공동 작업자로부터 종종 도움을 받아 Vim에 새로운 기능을 꾸준히 추가했다. Vim 2.0은 줄 바꿈 옵션과 긴 줄의 텍스트를 가로지르는 수평 스크롤을 지원했다. Vim 3.0에는 <code>vi</code> 복제판 <code>nvi</code>에서 영감을 받아 화면 분할과 버퍼를 추가했다. 지금의 Vim은 각 버퍼를 스왑 파일에 저장하여 편집된 텍스트가 충돌을 일으켜도 동작한다. Vimscript는 구문 강조 표시 기능과 함께 Vim 5.0에서 처음 등장했다. 그동안 Vim의 인기는 계속 커져 왔다. MS-DOS와 Windows, Mac, 심지어 Unix에도 이식되어 <code>vi</code>와 경쟁했다.</p>
<p>2006년, Vim은 <em>Linux Journal</em> 독자들 사이에서 가장 인기 있는 편집기로 뽑혔다.<sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup> 오늘날 Stack Overflow의 2018년도 개발자 설문조사에 따르면, Vim이 모든 소프트웨어 개발자의 25.8% (그리고 Sysadmin/DevOps의 40%)가 사용하는 가장 인기 있는 텍스트 모드 (터미널 에뮬레이터) 편집기이다.<sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup> 1980년대 후반과 1990년대 전반에 걸쳐 프로그래머들은 Emacs 사용자가 vi (나중에 Vim이 됐지만) 사용자들에게 맞서는 &quot;편집기 전쟁 (Editor Wars)&quot;을 겪었다. Emacs가 아직도 확실히 추종자를 가지고 있긴 하지만, 어떤 사람들은 편집기 전쟁이 끝났으며 Vim이 승리했다고 생각한다.<sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup> 2018년도 Stack Overflow 개발자 설문조사는 이것이 사실임을 확인해준다. 응답자의 4.1%만이 Emacs를 사용한다고 답했다.</p>
<p>어떻게 Vim이 이렇게 성공할 수 있었을까? 분명히 사람들은 Vim이 제공하는 기능들을 좋아하는 것일 테지만 난 Vim의 오랜 역사가 그 기능들 이상의 장점을 설명한다고 말하고 싶다. Vim의 코드베이스는 무레나르가 작업을 시작한 1988년으로 거슬러 올라간다. 반면 &quot;wq 텍스트 편집기&quot; (Unix스러운 텍스트 편집기가 어떻게 작동해야 하는지에 대한 더 넓은 비전을 제시한)는 반세기를 거슬러 올라간다. &quot;wq 텍스트 편집기&quot;에는 몇 가지 다른 이름들이 있었지만 빌 조이와 브람 무레나르가 이전 버전과의 호환성을 유지하는 데 특별히 신경을 쓰는 덕분에 시간이 지남에 따라 점점 좋은 생각들이 축적되어왔다. 이런 점에서 &quot;wq 텍스트 편집기&quot;는 컴퓨팅 세계에서 가장 위대한 사람들의 공헌을 받아 오랜 기간 실행되고 가장 성공한 오픈 소스 프로젝트 중 하나이다. &quot;스타트업-회사는-모든-선례를-집어던지고-끝내주는-새로운-소프트웨어를-만든다 (startup-company-throws-away all-precedents-and-creates-disruptive-new-software)&quot;는 접근법을 내가 꼭 안 좋게 생각하는 건 아니지만 Vim은 협력적이고 점증적인 접근 방식이 엄청난 걸 만들어낼 수 있음을 확실히 상기시켜 준다.</p>
<p><em>이 글을 재밌게 읽었다면 2주에 한 번씩 더 찾아주세요! Twitter에서 <a href="https://twitter.com/TwoBitHistory">@TwoBitHistory</a>를 팔로우하거나 <a href="https://twobithistory.org/feed.xml">RSS 피드</a>를 구독하여 새 게시물이 언제 나오는지 확인하세요.</em></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Butler Lampson, “Systems,” Butler Lampson, accessed August 5, 2018, <a href="http://bwlampson.site/Systems.htm">http://bwlampson.site/Systems.htm</a>. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Dennis Ritchie, “An Incomplete History of the QED Editor,” accessed August 5, 2018, <a href="https://www.bell-labs.com/usr/dmr/www/qed.html">https://www.bell-labs.com/usr/dmr/www/qed.html</a>. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Peter Salus, “The Daemon, the GNU, and the Penguin,” Groklaw, April 14, 2005, accessed August 5, 2018, <a href="http://www.groklaw.net/article.php?story=20050414215646742">http://www.groklaw.net/article.php?story=20050414215646742</a>. <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>ibid. <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>Dennis Ritchie, “An Incomplete History of the QED Editor,” accessed August 5, 2018, <a href="https://www.bell-labs.com/usr/dmr/www/qed.html">https://www.bell-labs.com/usr/dmr/www/qed.html</a>. <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>Donald Norman, “The Truth about Unix: The User Interface Is Horrid,” Datamation, accessed August 5, 2018, <a href="http://www.ceri.memphis.edu/people/smalley/ESCI7205_misc_files/The_truth_about_Unix_cleaned.pdf">http://www.ceri.memphis.edu/people/smalley/ESCI7205_misc_files/The_truth_about_Unix_cleaned.pdf</a>. <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>George Coulouris, “George Coulouris: A Bit of History,” George Coulouris’ Homepage, September 1998, accessed August 5, 2018, <a href="http://www.eecs.qmul.ac.uk/~gc/history/index.html">http://www.eecs.qmul.ac.uk/~gc/history/index.html</a>. <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>“Second Berkeley Software Distribution Manual,” Roguelife, accessed August 5, 2018, <a href="http://roguelife.org/~fujita/COOKIES/HISTORY/2BSD/vi.u.html">http://roguelife.org/~fujita/COOKIES/HISTORY/2BSD/vi.u.html</a>. <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>Sven Guckes, “VIM Wishlist,” Vmunix, May 15, 1995, accessed August 5, 2018, <a href="https://web.archive.org/web/20080520075925/http://www.vmunix.com/vim/wish.html">https://web.archive.org/web/20080520075925/http://www.vmunix.com/vim/wish.html</a>. <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>Bram Moolenaar, “Vim 25” (lecture, Zurich, November 2, 2016), December 13, 2016, accessed August 5, 2018, <a href="https://www.youtube.com/watch?v=ayc_qpB-93o&amp;t=4m58s">https://www.youtube.com/watch?v=ayc_qpB-93o&amp;t=4m58s</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>ibid. (?t=6m15s) <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>ibid. (?t=7m6s) <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>“Fish Disks 1 - 1120,” Amiga Stuff, accessed August 5, 2018, <a href="http://www.amiga-stuff.com/pd/fish.html">http://www.amiga-stuff.com/pd/fish.html</a>. <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>“2005 Linux Journal Reader’s Choice Awards,” Linux Journal, September 28, 2005, accessed August 5, 2018, <a href="https://www.linuxjournal.com/article/8520#N0x850cd80.0x87983bc">https://www.linuxjournal.com/article/8520#N0x850cd80.0x87983bc</a>. <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>“Stack Overflow Developer Survey 2018,” Stack Overflow, accessed August 5, 2018, <a href="https://insights.stackoverflow.com/survey/2018/#development-environments-and-tools">https://insights.stackoverflow.com/survey/2018/#development-environments-and-tools</a>. <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>Bruce Byfield, “The End of the Editor Wars,” Linux Magazine, May 11, 2015, accessed August 5, 2018, <a href="http://www.linux-magazine.com/Online/Blogs/Off-the-Beat-Bruce-Byfield-s-Blog/The-End-of-the-Editor-Wars">http://www.linux-magazine.com/Online/Blogs/Off-the-Beat-Bruce-Byfield-s-Blog/The-End-of-the-Editor-Wars</a>. <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded></item><item><title><![CDATA[수용력 있는 코드 리뷰 문화 만들기]]></title><description><![CDATA[<blockquote>
<p>이 글은 <a href="https://blog.plaid.com/building-an-inclusive-code-review-culture/">Building an Inclusive Code Review Culture</a>를 번역한 글입니다.</p>
</blockquote>
<p>모든 개발자는 코드 리뷰에 익숙합니다. 그리고 우리 이전의 많은 사람이 그것을 어떻게 할지에 대한 생각과 제안들을 쌓아왔습니다. 코드 리뷰는 모든 개발자가 매일 매일 수행하는 필수적인 요소기 때문에 팀 문화에 큰 영향을 미칩니다. Plaid에서, 우리는 수용력 있고 상호협력적인 문화에 자부심을</p>]]></description><link>https://blog.koriel.kr/building-an-inclusive-code-review-culture/</link><guid isPermaLink="false">5b5fef48bed6e93b0b9418e6</guid><category><![CDATA[code review]]></category><category><![CDATA[development]]></category><category><![CDATA[corporate culture]]></category><category><![CDATA[culture]]></category><category><![CDATA[engineering culture]]></category><dc:creator><![CDATA[Jinsoo Heo]]></dc:creator><pubDate>Wed, 08 Aug 2018 06:55:25 GMT</pubDate><media:content url="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2018/08/code-review-chat-1.jpg" medium="image"/><content:encoded><![CDATA[<blockquote>
<img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2018/08/code-review-chat-1.jpg" alt="수용력 있는 코드 리뷰 문화 만들기"><p>이 글은 <a href="https://blog.plaid.com/building-an-inclusive-code-review-culture/">Building an Inclusive Code Review Culture</a>를 번역한 글입니다.</p>
</blockquote>
<p>모든 개발자는 코드 리뷰에 익숙합니다. 그리고 우리 이전의 많은 사람이 그것을 어떻게 할지에 대한 생각과 제안들을 쌓아왔습니다. 코드 리뷰는 모든 개발자가 매일 매일 수행하는 필수적인 요소기 때문에 팀 문화에 큰 영향을 미칩니다. Plaid에서, 우리는 수용력 있고 상호협력적인 문화에 자부심을 가지고 있고, 그래서 우리는 우리만의 코드 리뷰 가이드라인을 만드는 것이 조직과 함께 우리도 성장하고 그런 문화를 성숙하게 만드는 것에 굉장히 중요하다고 느꼈습니다.</p>
<p>우리의 네 가지 개발 철학 중 하나는 <em>함께 성장하는 것</em>입니다. 이 글은 코드 리뷰 과정을 통해 우리가 그 가치를 실현하는 방법을 보여줍니다.</p>
<p>우리는 두 핵심 목표를 염두에 두고 코드 리뷰에 접근합니다. 모든 조직의 학습과 성장을 고려하고 좋은 코드를 실어 나르자. Plaid의 초기 개발자들은 이미 수용력 있는 코드 리뷰에 숙달했기 때문에 우리는 그것을 처음부터 발전시킬 수 있었습니다. 하지만 팀이 계속 성장하면서, 더 모든 개발자가 다른 개발자들과 서로 긴밀한 관계를 맺을 것이라고 확신할 수 없었습니다. 우리는 특정 스타일과 스타일 가이드를 강제하는 linter를 이용해 코드를 깔끔하게 작성하는 법은 이미 알고 있었지만, 어떻게 코드 리뷰의 방법을 다듬을지는 몰랐습니다. 우리는 Plaid의 코드 리뷰 문화를 기존의 팀과 새로운 직원들을 아우를 수 있는 무언가로 집약시켜야만 했습니다.</p>
<p>우리는 개발팀이라는 본질로 돌아가 현재 Plaid에 어떤 제일 나은 방법들이 있는지 써 내려가는 것부터 시작했습니다. 신입부터 시니어 개발자들까지 많은 개발자를 면담했습니다. 그러고 나서 모든 사람의 생각을 정리해서 몇 가지 권장 사항을 만들었습니다. 우리는 모든 직원이 기여하고 목소리를 낼 수 있도록 각 팀에 이 권장 사항들을 보냈습니다. 모두의 동의를 얻고 그 지지를 확실히 하기 위해 개발 과정에 우리는 다음과 같은 가이드라인을 제시했습니다.</p>
<h1 id="plaid">Plaid의 코드 리뷰 가이드라인</h1>
<h2 id="">코드 리뷰의 목적</h2>
<p>올바른 마음가짐으로 코드 리뷰를 시작하는 것은 건설적인 피드백을 주려는 쪽에게나, 받으려는 쪽에게나 굉장히 중요합니다. 대부분 코드 리뷰에서의 우리의 목표는 좋은 코드 기반을 유지하고 무결성을 보장, 작성자와 검토자 양쪽 모두를 학습시키고 성장하게 하기 위함입니다.</p>
<h2 id="">작성자를 위해</h2>
<p>코드 작성자에게 가장 중요한 규칙은 검토자의 시간을 존중하는 것입니다. 다른 모든 규칙도 이것으로부터 파생됩니다. 이것이 의미하는 바는, 리뷰를 요청할 때 우리는 우리의 코드가 다른 사람이 볼 준비가 되어있다는 확신을 가지고 있어야 한다는 것입니다. 필수적인 테스트를 돌리고 쓸데없는 디버깅 구문들을 삭제, 리뷰 설명에 적당한 문맥적 의미를 적어야 한다는 말입니다. 누가 코드를 보든 간에, 그게 검토자인지 미래의 개발자인지 상관없이 코드의 목적이 무엇이고 그것을 어떻게 달성했는지 이해할 수 있도록 하는 것은 중요합니다.</p>
<p>PR의 범위를 구체적으로 지정하는 것은 효과적인 코드 리뷰 과정을 갖추는 데 도움이 됩니다. 만약 당신이 리뷰를 위해 수백 줄이 넘는 코드를 제출하는 자기 자신을 본다면, PR의 범위를 지정함으로써 조금 더 꼼꼼해질 수 있습니다. 수백 줄의 코드를 두고 검토자가 모든 변경 사항을 이해하고 효과적으로 검토한다는 것은 굉장히 힘든 일입니다. 변경 사항을 제한함으로써 코드 리뷰 과정을 더욱 빠르게 만들고 당신의 코드를 더 신속하게 반영할 수 있습니다.</p>
<p>마지막으로, 검토자가 당신이 작성한 변경 사항을 적용할 수 있도록 돕기 위해 쏟는 시간을 존중하세요. 그들은 당신에게 피드백을 주기 위해 본인의 주요 프로젝트 업무에서 시간을 떼어온 것입니다. 만약에 그들이 코멘트를 남기면 그것이 무엇이든 응답해주는 것이 중요합니다. 그 응답이 그들 말대로 수정했다고 하는 간단한 것이라고 해도요. 고맙게도, 우리는 그걸 위한 이모지⚡를 가지고 있습니다. 이건 변경 사항을 추적하기 위한 아주 좋은 도구입니다.</p>
<p><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2018/07/code-review-github@2x@2x.jpg" alt="수용력 있는 코드 리뷰 문화 만들기"></p>
<blockquote>
<p>jlamb: 다른 케이스들은 철자순으로 되어있는 것 같네요 - 이 케이스는 밑으로 내리는 게 어때요?<br>
jsiegel: ⚡</p>
</blockquote>
<h2 id="">검토자를 위해</h2>
<p>Plaid에서 우리의 코드 리뷰 목표 중 하나는 우리의 코드 기반을 건강하게 유지하는 것입니다. 그렇게 하는 것은 본질적으로 어렵습니다. 많은 경우에, 코드를 보다 읽기 쉽게 작성하고 스타일 가이드라인에 더 잘 맞출 수 있는 방법을 제안하는 것은 의견의 문제로 이어집니다. 따라서 검토자로서는, 무엇이 의견이고 무엇이 사실인 지 명확히 하는 것이 중요합니다. 코드의 버그는 객관적이고, 그래야만 합니다. 변수를 분리하거나 이름을 바꾸는 것에 대한 다른 접근법은 코드를 읽을 수 있게 하는 데 있어 큰 변화를 가져올 수 있지만, 그것은 검토자의 의견이므로 의견으로써 전달되어야 합니다.</p>
<p>Plaid에서는, 우리가 사용하는 언어들을 위한 각각의 스타일 가이드를 가지고 있습니다. 당신이 검토자로서 보고 싶은 코드가 있으면, 예를 들어, 타입스크립트 저장소에서 import 문들을 철자 순으로 배열하는 것이 스타일 가이드에 포함되어야 합니다. 전역적인 변경 사항을 코드에 통합하고 싶으면, 개발자는 그 스타일 가이드를 준수하여 PR을 생성해야 합니다. 그 언어로 작성된 모든 저장소에서 모든 PR을 뒤지고 다닐 게 아니라요. 만약 누군가가 스타일 가이드에 대해 많은 위반을 저질렀다면, 검토자는 특정 위반 사항을 언급하며 스타일 가이드를 가리켜 작성자가 보도록 해야 합니다. 그리고 검토자가 한줄 한줄 읽어 각 위반 사항에 대해 코멘트할 것이 아니라 작성자 스스로 직접 고치도록 해야 합니다.</p>
<p>바꿔 말해, 검토자는 자질구레한 것들에 집중하는 걸 피해야 합니다. 코드 리뷰는 한줄 한줄 읽고 각 줄의 실수를 잡아내는 것이 아닙니다. 코드 리뷰는 코드를 전체적으로 보고 더 큰 체계에 들어맞는지 보는 것입니다. 사소한 코멘트들을 절대 고려하면 안 된다는 것이 아니지만 그것이 코드 리뷰의 초점이 되어서는 안 됩니다.</p>
<p>검토자로서, 당신은 항상 정확함을 염두에 두어야 합니다. 하지만 인간은 컴퓨터만큼 버그를 잡아내는 것에 효과적이지 못할 겁니다. 검토자가 버그를 확인하는 것이 중요한 만큼, 작성자가 새로운 코드에 대해 적절한 테스트를 작성했는지 확인하는 것은 더 중요합니다.</p>
<h2 id="">모두를 위해</h2>
<p>Plaid에서, 우리는 &quot;ship it (실어 날라)&quot; 문화를 가지고 있습니다. 지속적인 배포가 일어나고 전 세계에 직원이 있는 환경에서, 실어 나르는 일은 절대 멈추지 않습니다. 10,000개가 넘는 금융 기관을 통합하는 우리 일의 본질은 우리가 인프라의 변화에 끊임없이 반응하고 있다는 것을 의미합니다. 따라서, 코드 리뷰에 촉박함을 느낄 때가 자주 있습니다. 하지만, 모든 PR이 똑같은 긴급성을 가지진 않기 때문에 리뷰를 요청할 때 일정에 대해 미리 잘 알고 있는 것이 중요합니다.</p>
<p>코드 리뷰 과정을 통해 지속적인 성장과 학습을 할 수 있지만, 이건 코드 리뷰의 이러한 측면을 받아들일 때만 가능합니다. 작성자와 검토자 모두 토론에 열려있어야 하고 어떤 것이 왜 그런 방식으로 처리되었는지 물을 의지가 있어야 합니다. 그러나 토론이 언제 삼천포로 빠지는지 알아차리는 것도 물론 중요합니다.</p>
<p>코드 리뷰에서 검토자가 놀랄 만한 일은 없어야 합니다. 중요한 디자인 의사결정에 대해서는 코드가 작성되기 전에 의논하세요. 코드 리뷰는 구현의 세부 사항을 다듬는 시간이지 주요 디자인과 아키텍처 결정을 논하는 시간이 아닙니다. 때때로 코드 리뷰 중에 논쟁 포인트가 될 거라 예상은 못 했지만 중요한 토론이 필요한 문제가 발생하는 경우가 있습니다. 한두 번 정도 훑어본 다음, 오프라인으로 토론을 하고 바로바로 해치워야 합니다. 이는 적절하게 구체화하지 않거나 범위가 지정되지 않은 PR에서 나타날 수 있지만, PR 토론이 왜 꼬였는지에 관계없이 그것이 있음을 인지하고 슬기롭게 해결하는 것이 중요합니다.</p>
<h2 id="">가이드라인 만들기</h2>
<p>새로운 직원들을 빠르게 적응시키고 우리의 코드 리뷰 권장 사항을 체득시키기 위해서, 우리는 우리가 만든 가이드라인을 훑어보고 GitHub에 들어가 최근 PR들을 살펴보는 코드 리뷰 온보딩<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 세션을 만들었습니다. 새로운 직원들을 확실하게 Plaid의 코드 리뷰 문화에 노출함으로써, 그들을 처음부터 그 문화에 기여할 수 있게 만든다고 믿고 있습니다.</p>
<p><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2018/08/code-review-chat.jpg" alt="수용력 있는 코드 리뷰 문화 만들기"></p>
<p>어떤 새로운 직원이든, 새로운 조직의 모든 문화 규범을 시도해보고 빠르게 따라오라는 건 겁을 먹을 만한 일입니다. 문화 규범을 익히는 것이 코드 리뷰처럼 비판적인 피드백을 받는 일과 같다면 특히 겁먹을 수 있습니다. 그렇기 때문에, 코드 리뷰 문화에 새로운 직원을 받아들일 땐 가능한 환영하는 것이 중요합니다.</p>
<p>코드 리뷰 온보딩 세션이 끝날 때 LGTM<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> 이모지를 고르게 되고 이것은 코드 리뷰를 수락하는 데 사용할 개인적인 승인 도장입니다. 내부 개발 README 문서에 이 이모지를 추가하는 건 또 하나의 재미이고 Plaid에서 코드 리뷰어로서 여정을 시작했음을 알리는 상징적인 방법입니다. 우리는 아주 처음부터 새로운 개발자들을 코드 리뷰어로서 환영하는 것이 우리의 코드 리뷰 문화를 강화하는 데 핵심적인 역할을 한다고 믿습니다.</p>
<p>이 가이드라인들은 우리의 개발 조직이 발달하면서 분명히 계속 같이 발달할 것입니다. 팀원들이 가이드라인에 기여하여 그들이 우리의 문화의 대표자가 될 수 있도록 장려하고 있습니다. 이 가이드라인들의 세부 사항이 바뀔 순 있어도, 그 목적은 항상 똑같을 겁니다. 수용력 있고 상호협력적인 개발 문화를 가꿔나가자.</p>
<p>이 글이 재밌었다면, <a href="https://plaid.com/careers/">우리 팀에 합류하는 것을 고려해보세요!</a></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>조직내 새로 합류한 사람이 빠르게 조직의 문화를 익히고 적응하도록 돕는 과정 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>&quot;Looks Good To Me&quot;라는 뜻으로 검토자가 승인의 의미로 사용하는 줄임말 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded></item><item><title><![CDATA[AWS Lightsail로 Ghost 블로그 운영하기 - 3]]></title><description><![CDATA[<h3 id="1ghoststorageadapters3">1. ghost-storage-adapter-s3 설치</h3>
<p>Ghost 블로그는 기본적으로 이미지나 첨부 파일을 업로드 하면 인스턴스의 볼륨에 그것들을 저장한다. 우리가 생성한 Lightsail 인스턴스의 볼륨은 20G로 아주 작은 건 아니지만 첨부 파일의 용량에 따라서는 금방 차버릴 수도 있다. 따라서 네이티브 볼륨을 이용하는 것 보다는 AWS s3에 이미지와 첨부 파일을 업로드해서 관리하는 것이 훨씬 효율적이다. 이후에</p>]]></description><link>https://blog.koriel.kr/aws-lighstsailro-ghost-beulrogeu-unyeonghagi-3/</link><guid isPermaLink="false">5b22a5ce85316a27ea491f32</guid><dc:creator><![CDATA[Jinsoo Heo]]></dc:creator><pubDate>Thu, 14 Jun 2018 18:48:35 GMT</pubDate><content:encoded><![CDATA[<h3 id="1ghoststorageadapters3">1. ghost-storage-adapter-s3 설치</h3>
<p>Ghost 블로그는 기본적으로 이미지나 첨부 파일을 업로드 하면 인스턴스의 볼륨에 그것들을 저장한다. 우리가 생성한 Lightsail 인스턴스의 볼륨은 20G로 아주 작은 건 아니지만 첨부 파일의 용량에 따라서는 금방 차버릴 수도 있다. 따라서 네이티브 볼륨을 이용하는 것 보다는 AWS s3에 이미지와 첨부 파일을 업로드해서 관리하는 것이 훨씬 효율적이다. 이후에 블로그를 다른 서버로 옮기더라도 이 설정 방법을 이용해 같은 s3 버킷에 붙이기만 하면 별도의 백업과 복원 과정없이 이미지와 첨부 파일들을 옮길 수 있다.</p>
<p>우선 npm으로 ghost-storage-adapter-s3를 설치하자.</p>
<pre><code class="language-bash">$ sudo npm i -g ghost-storage-adapter-s3
$ sudo mkdir -p /var/www/ghost/content/adapters/storage

# 전역 설치된 패키지를 ghost 디렉토리로 복사
$ sudo cp -r /usr/lib/node_modules/ghost-storage-adapter-s3 /var/www/ghost/content/adapters/storage/s3
$ sudo chown -R ghost:ghost /var/www/ghost/content/adapters
</code></pre>
<p>설치가 끝나면 <code>config.production.json</code>를 수정해서 ghost가 이미지와 첨부 파일을 s3 버킷에 올리도록 설정하자.</p>
<pre><code class="language-bash">$ sudo vim /var/www/ghost/config.production.json
</code></pre>
<pre><code class="language-bash">{
  &quot;url&quot;: &quot;https://blog.koriel.kr&quot;,
  &quot;server&quot;: {
    &quot;port&quot;: 2368,
    &quot;host&quot;: &quot;127.0.0.1&quot;
  },
  &quot;database&quot;: {
    &quot;client&quot;: &quot;mysql&quot;,
    &quot;connection&quot;: {
      &quot;host&quot;: &quot;localhost&quot;,
      &quot;user&quot;: &quot;ghost-178&quot;,
      &quot;password&quot;: &quot;********&quot;,
      &quot;database&quot;: &quot;ghost_prod&quot;
    }
  },
  &quot;mail&quot;: {
    &quot;transport&quot;: &quot;Direct&quot;
  },
  &quot;logging&quot;: {
    &quot;transports&quot;: [
      &quot;file&quot;,
      &quot;stdout&quot;
    ]
  },
  &quot;process&quot;: &quot;systemd&quot;,
  &quot;paths&quot;: {
    &quot;contentPath&quot;: &quot;/var/www/ghost/content&quot;
  },
  # 이 밑부분을 추가
  &quot;storage&quot;: {
    &quot;active&quot;: &quot;s3&quot;,
    &quot;s3&quot;: {
      &quot;bucket&quot;: &quot;blog.koriel.kr-*******&quot;,
      &quot;region&quot;: &quot;ap-northeast-2&quot;,
      &quot;accessKeyId&quot;: &quot;A*******************&quot;,
      &quot;secretAccessKey&quot;: &quot;J***************************************&quot;,
      &quot;endpoint&quot;: &quot;https://s3.ap-northeast-2.amazonaws.com/&quot;
    }
  }
}
</code></pre>
<p>s3 버킷 생성은 <a href="https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/user-guide/create-bucket.html">https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/user-guide/create-bucket.html</a> 을 참조.</p>
<p>Access key id와 secret access key 발급은 <a href="https://docs.aws.amazon.com/ko_kr/IAM/latest/UserGuide/id_credentials_access-keys.html">https://docs.aws.amazon.com/ko_kr/IAM/latest/UserGuide/id_credentials_access-keys.html</a> 을 참조.</p>
<p>Ghost를 재시작하여 설정을 적용하자.</p>
<pre><code class="language-bash">$ cd /var/www/ghost
$ ghost restart
</code></pre>
<h3 id="2">2. 테마 설정</h3>
<p>Casper라는 기본 테마도 굉장히 잘 만들어진 테마이다. 많은 개발자들이 기본 테마를 그냥 사용하고 있지만  그것이 싫다면 <a href="https://marketplace.ghost.org">https://marketplace.ghost.org</a> 에서 마음에 드는 것을 골라 사용할 수도 있다. 유료도 있으니 주의.</p>
<p>내가 사용하고 있는 테마는 Ghostium인데 GitHub에서 찾을 수 있다. 마지막 커밋 날짜가 꽤 되어서 ghost 1.24.x 버전과 호환성 문제가 생겼다. 호환성 문제를 해결하고 가독성을 개선해서 개인 repo에 올려두었다. <a href="https://github.com/devkoriel/ghostium">https://github.com/devkoriel/ghostium</a>.</p>
<p>오른쪽 위 <strong>Clone or downlad &gt; Download ZIP</strong>를 눌러 다운로드 받거나 <a href="https://github.com/devkoriel/ghostium/archive/master.zip">https://github.com/devkoriel/ghostium/archive/master.zip</a> 이 링크를 눌러 직접 다운로드 받을 수 있다. 다운로드 받은 .zip 압축 파일을 <strong>관리자 페이지 &gt; Design &gt; Upload a theme</strong>으로 업로드하면 바로 적용할 수 있다.</p>
<p><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2018/06/Screen-Shot-2018-06-15-at-3.47.16-AM.png" alt="Screen-Shot-2018-06-15-at-3.47.16-AM"></p>
<p>소셜 계정과 메타 태그, 왼쪽 네비게이션 바를 커스터마이징하려면 아래 4개의 파일들을 본인의 정보에 맞게 수정해야 한다.</p>
<ul>
<li><code>partials/custom/config.hbs</code></li>
<li><code>partials/custom/featured.hbs</code></li>
<li><code>partials/custom/meta.hbs</code></li>
<li><code>partials/custom/navigation.hbs</code></li>
</ul>
<p>수정한 후 다시 최상위 폴더를 압축하여 업로드하면 적용할 수 있다.</p>
<p><a href="https://blog.koriel.kr/aws-lighstsailro-ghost-beulrogeu-unyeonghagi-1/">AWS Lightsail로 Ghost 블로그 운영하기 - 1</a><br>
<a href="https://blog.koriel.kr/aws-lighstsailro-ghost-beulrogeu-unyeonghagi-2/">AWS Lightsail로 Ghost 블로그 운영하기 - 2</a><br>
AWS Lightsail로 Ghost 블로그 운영하기 - 3</p>
]]></content:encoded></item><item><title><![CDATA[AWS Lightsail로 Ghost 블로그 운영하기 - 2]]></title><description><![CDATA[<h3 id="1ubuntu">1. Ubuntu 패키지 업데이트</h3>
<pre><code class="language-bash">$ sudo apt update &amp;&amp; sudo apt upgrade -y
</code></pre>
<p>중간에 묻는 것이 있다면 그냥 다 엔터</p>
<h3 id="2en_usutf8issue">2. en_US.UTF-8 issue 해결</h3>
<p>AWS EC2나 Lightsail에서 Ubuntu 인스턴스를 생성하고 접속해서 작업하다 보면 다음과 같은 경고를 마주친다.</p>
<pre><code class="language-bash">perl: warning: Setting locale failed.
perl: warning: Please check that your</code></pre>]]></description><link>https://blog.koriel.kr/aws-lighstsailro-ghost-beulrogeu-unyeonghagi-2/</link><guid isPermaLink="false">5b22386a85316a27ea491f2e</guid><dc:creator><![CDATA[Jinsoo Heo]]></dc:creator><pubDate>Thu, 14 Jun 2018 17:25:55 GMT</pubDate><content:encoded><![CDATA[<h3 id="1ubuntu">1. Ubuntu 패키지 업데이트</h3>
<pre><code class="language-bash">$ sudo apt update &amp;&amp; sudo apt upgrade -y
</code></pre>
<p>중간에 묻는 것이 있다면 그냥 다 엔터</p>
<h3 id="2en_usutf8issue">2. en_US.UTF-8 issue 해결</h3>
<p>AWS EC2나 Lightsail에서 Ubuntu 인스턴스를 생성하고 접속해서 작업하다 보면 다음과 같은 경고를 마주친다.</p>
<pre><code class="language-bash">perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
	LANGUAGE = (unset),
	LC_ALL = (unset),
	LC_CTYPE = &quot;UTF-8&quot;,
	LANG = &quot;en_US.UTF-8&quot;
    are supported and installed on your system.
perl: warning: Falling back to a fallback locale (&quot;en_US.UTF-8&quot;).
locale: Cannot set LC_CTYPE to default locale: No such file or directory
locale: Cannot set LC_ALL to default locale: No such file or directory
</code></pre>
<p>왜 기본 설정으로 넣어두지 않았는 지 모르겠다. 에러가 아니라 사용하는 데에 문제가 생기진 않지만 상당히 거슬린다. <code>/etc/environment</code>에 아래 라인들을 추가하면 다음 로그인부터 해당 경고들이 사라진다.</p>
<pre><code class="language-bash">LANG=en_US.utf-8
LC_ALL=en_US.utf-8
</code></pre>
<h3 id="3swapmemory">3. Swap memory 설정</h3>
<p>Ghost는 권장 사양으로 1G의 램을 요구한다. 우리가 생성한 인스턴스는 512MB이므로 나머지를 메꿀 수 있는 swap을 설정해야 한다. 넉넉하게 2G 정도 잡아주자.</p>
<pre><code class="language-bash">$ sudo fallocate -l 2G /swapfile # 2G 크기의 파일 생성
$ sudo chmod 600 /swapfile # root만 읽을 수 있도록 권한 수정
$ sudo mkswap /swapfile # swap 파일로 만들기
$ sudo swapon /swapfile # swap 파일 활성화
</code></pre>
<p>2G의 swap memory가 잡혔고 아래 명령어로 확인이 가능하다.</p>
<pre><code class="language-bash">$ sudo free -m
              total        used        free      shared  buff/cache   available
Mem:            486         275          36           1         175         178
Swap:          2047          73        1974
</code></pre>
<h3 id="4ghost">4. Ghost 설치</h3>
<h4 id="">사용자 추가</h4>
<p>Ghost를 설치하고 관리하기 위한 UNIX 사용자를 따로 추가하는 것이 좋다. <strong>사용자 이름을 절대 ghost로 설정하면 안된다.</strong> Ghost 설치 과정에서 ghost 사용자를 생성해서 사용하기 때문에 충돌한다.</p>
<pre><code class="language-bash">$ sudo adduser &lt;user&gt; # user 추가. 이름을 ghost로 설정하지 말 것!!!
$ sudo usermod -aG sudo &lt;user&gt; # superuser 그룹에 추가
$ su - &lt;user&gt; # user로 로그인
</code></pre>
<h4 id="nginx">Nginx 설치</h4>
<pre><code class="language-bash">$ sudo apt install nginx
$ sudo ufw allow 'Nginx Full'
</code></pre>
<h4 id="mysql">MySQL 설치</h4>
<pre><code class="language-bash">$ sudo apt install mysql-server
</code></pre>
<p>설치 도중 root 계정의 비밀번호를 설정하는 창이 뜨는데 이때 <strong>반드시 비밀번호를 설정</strong>해야 한다. 빈칸으로 놔두고 넘어가면 나중에 Ghost를 설치할 때 문제가 된다.</p>
<h4 id="nodejs">Node.js 설치</h4>
<pre><code class="language-bash">$ curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash
$ sudo apt install -y nodejs
</code></pre>
<p>Ghost가 지원하는 Node.js의 버전은 <a href="https://docs.ghost.org/docs/supported-node-versions">https://docs.ghost.org/docs/supported-node-versions</a> 에 나와있다. v6(Boron)이나 v8(Carbon) LTS 버전을 설치할 것을 권장한다. 이 글에서는 Ghost가 추천하는 v6 버전으로 설치한다.</p>
<h4 id="ghostcli">Ghost-CLI 설치</h4>
<pre><code class="language-bash">$ sudo npm i -g ghost-cli
</code></pre>
<h4 id="ghost">Ghost 설치</h4>
<pre><code class="language-bash">$ sudo mkdir -p /var/www/ghost
$ sudo chown [user]:[user] /var/www/ghost
$ sudo chmod 775 /var/www/ghost
</code></pre>
<p>[user]는 처음에 만든 사용자 이름이다.</p>
<pre><code class="language-bash">$ cd /var/www/ghost
$ ghost install
✔ Checking system Node.js version
✔ Checking logged in user
✔ Checking current folder permissions
✔ Checking operating system compatibility
✔ Checking for a MySQL installation
✔ Checking memory availability
✔ Checking for latest Ghost version
✔ Setting up install directory
✔ Downloading and installing Ghost v1.24.4
✔ Finishing install process
</code></pre>
<p>설치가 끝나면 설정할 정보들을 물어본다.</p>
<pre><code class="language-bash">? Enter your blog URL: https://blog.koriel.kr # 1편에서 설정한 도메인 입력
? Enter your MySQL hostname: localhost
? Enter your MySQL username: root
? Enter your MySQL password: [hidden] # 위에서 설정한 MySQL root 계정 비밀번호
? Enter your Ghost database name: ghost2_prod # 그냥 엔터 또는 사용할 database 이름 입력
</code></pre>
<p>여기까지 끝나면 Yes or No로 답하는 질문들을 쭉 하는데, SSL만 No로 대답하고 나머진 모두 Yes로 답하면 된다.</p>
<pre><code class="language-bash">? Do you wish to set up &quot;ghost&quot; mysql user? Yes
? Do you wish to set up Nginx? Yes
? Do you wish to set up SSL? No
? Enter your email (used for Let's Encrypt notifications) dev@koriel.kr # SSL 인증서 관련 이메일을 받을 주소 입력
? Do you wish to set up Systemd? Yes
? Do you want to start Ghost? Yes
</code></pre>
<p>MySQL 계정 설정, Nginx 설정, Systemd 설정, Ghost 실행까지 한번에 알아서 다 해준다. 이후 진행 상황이 쭉 보이고 Ghost가 실행된 다음 접속 가능한 URL을 표시한다.</p>
<pre><code class="language-bash">Running sudo command: systemctl is-active ghost_temp-koriel-kr
✔ Ensuring user is not logged in as ghost user
✔ Checking if logged in user is directory owner
✔ Checking current folder permissions
Running sudo command: systemctl is-active ghost_temp-koriel-kr
✔ Validating config
✔ Checking folder permissions
✔ Checking file permissions
✔ Checking content folder ownership
✔ Checking memory availability
Running sudo command: systemctl start ghost_temp-koriel-kr
✔ Starting Ghost
Running sudo command: systemctl is-enabled ghost_temp-koriel-kr
Running sudo command: systemctl enable ghost_temp-koriel-kr --quiet
✔ Starting Ghost
You can access your publication at https://blog.koriel.kr
Next, go to to your admin interface at https://blog.koriel.kr/ghost/ to complete the setup of your publication

Ghost uses direct mail by default
To set up an alternative email method read our docs at https://docs.ghost.org/docs/mail-config
</code></pre>
<h4 id="ssl">SSL 인증서 발급</h4>
<p>certbot을 이용하면 엔터 몇번으로 SSL 발급, Nginx 설정, 리다이렉트 설정까지 알아서 다 해준다. 먼저 certbot을 설치하자.</p>
<pre><code class="language-bash">$ sudo add-apt-repository ppa:certbot/certbot
$ sudo apt update
$ sudo apt install python-certbot-nginx
</code></pre>
<p>설치가 끝나면 이제 우리가 설정한 도메인에 대해 SSL 인증서를 발급받고 설정을 완료하자.</p>
<pre><code class="language-bash">$ sudo certbot --nginx -d blog.koriel.kr
Saving debug log to /var/log/letsencrypt/letsencrypt.log
Plugins selected: Authenticator nginx, Installer nginx
Enter email address (used for urgent renewal and security notices) (Enter 'c' to
cancel): dev@koriel.kr
Starting new HTTPS connection (1): acme-v01.api.letsencrypt.org
</code></pre>
<p>이후 서비스 이용 약관과 이메일 주소 공유 동의 여부를 물어보는데 각각 a와 y로 답하고 나면 쭉쭉 진행되고 이미 Ghost에 의해 생성된 Nginx conf 파일이 자동으로 수정된다.</p>
<pre><code class="language-bash">-------------------------------------------------------------------------------
Please read the Terms of Service at
https://letsencrypt.org/documents/LE-SA-v1.2-November-15-2017.pdf. You must
agree in order to register with the ACME server at
https://acme-v01.api.letsencrypt.org/directory
-------------------------------------------------------------------------------
(A)gree/(C)ancel: a

-------------------------------------------------------------------------------
Would you be willing to share your email address with the Electronic Frontier
Foundation, a founding partner of the Let's Encrypt project and the non-profit
organization that develops Certbot? We'd like to send you email about EFF and
our work to encrypt the web, protect its users and defend digital rights.
-------------------------------------------------------------------------------
(Y)es/(N)o: y
Starting new HTTPS connection (1): supporters.eff.org
Obtaining a new certificate
Performing the following challenges:
http-01 challenge for blog.koriel.kr
Waiting for verification...
Cleaning up challenges
Deploying Certificate to VirtualHost /etc/nginx/sites-enabled/blog.koriel.kr.conf
</code></pre>
<p>마지막으로 HTTP 트래픽을 HTTPS로 리다이렉트할 것인 지 물어보는데 2로 답하여 리다이렉트하도록 설정하자.</p>
<pre><code class="language-bash">Please choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access.
-------------------------------------------------------------------------------
1: No redirect - Make no further changes to the webserver configuration.
2: Redirect - Make all requests redirect to secure HTTPS access. Choose this for
new sites, or if you're confident your site works on HTTPS. You can undo this
change by editing your web server's configuration.
-------------------------------------------------------------------------------
Select the appropriate number [1-2] then [enter] (press 'c' to cancel): 2
Redirecting all traffic on port 80 to ssl in /etc/nginx/sites-enabled/blog.koriel.kr.conf
</code></pre>
<p>여기까지 하면 SSL 인증서까지 설정이 모두 끝난다.</p>
<h4 id="ssl">SSL 인증서 자동 갱신 설정</h4>
<p>매달 1일에 인증서를 자동 갱신하도록 crontab을 설정하자.</p>
<pre><code class="language-bash">$ sudo crontab -e
</code></pre>
<p>편집기를 선택한 후 아래 라인을 추가하자.</p>
<pre><code class="language-bash">0 0 1 * * certbot renew
</code></pre>
<h3 id="5">5. 관리자 페이지 접속</h3>
<p>https://[URL]/ghost 로 관리자 페이지에 접속할 수 있다. 아래 화면이 보이면 모두 정상적으로 설치, 설정된 것이다.</p>
<p><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2018/06/Screen-Shot-2018-06-15-at-2.24.46-AM.png" alt="Screen-Shot-2018-06-15-at-2.24.46-AM"></p>
<p><strong>Create your account</strong>를 눌러 계정 정보들을 설정하면 거의 끝.</p>
<p><a href="https://blog.koriel.kr/aws-lighstsailro-ghost-beulrogeu-unyeonghagi-1/">AWS Lightsail로 Ghost 블로그 운영하기 - 1</a><br>
AWS Lightsail로 Ghost 블로그 운영하기 - 2<br>
<a href="https://blog.koriel.kr/aws-lighstsailro-ghost-beulrogeu-unyeonghagi-3/">AWS Lightsail로 Ghost 블로그 운영하기 - 3</a></p>
]]></content:encoded></item><item><title><![CDATA[AWS Lightsail로 Ghost 블로그 운영하기 - 1]]></title><description><![CDATA[<p>홈페이지와 블로그를 AWS EC2 + RDS로 운영을 했었는데 매달 나오는 비용을 보고 이게 얼마나 어리석은 짓이었는 지 알게 됐다. 정확히 얼마가 청구됐는 지는 창피해서 공개하지 못하고... 쨋든 개인 웹 사이트 운영비치고는 굉장히 많이 나왔다. 시험 기간을 맞이해서 홈페이지는 GitHub Pages로 옮기고 블로그는 조금 더 저렴한 서비스로 옮기기로 했다. 시험 기간엔 시험</p>]]></description><link>https://blog.koriel.kr/aws-lighstsailro-ghost-beulrogeu-unyeonghagi-1/</link><guid isPermaLink="false">5b222c71fd23941a67e10eb5</guid><dc:creator><![CDATA[Jinsoo Heo]]></dc:creator><pubDate>Wed, 13 Jun 2018 07:09:00 GMT</pubDate><content:encoded><![CDATA[<p>홈페이지와 블로그를 AWS EC2 + RDS로 운영을 했었는데 매달 나오는 비용을 보고 이게 얼마나 어리석은 짓이었는 지 알게 됐다. 정확히 얼마가 청구됐는 지는 창피해서 공개하지 못하고... 쨋든 개인 웹 사이트 운영비치고는 굉장히 많이 나왔다. 시험 기간을 맞이해서 홈페이지는 GitHub Pages로 옮기고 블로그는 조금 더 저렴한 서비스로 옮기기로 했다. 시험 기간엔 시험 공부 아니면 다 재밌다. 진작 할 걸...</p>
<p>홈페이지는 전부 정적인 페이지라 그대로 GitHub repo에 올리면 되어서 문제가 없는데 블로그는 Ghost로 운영하고 있어서 GitHub Pages로 옮기기엔 어려움이 있다. 물론 안되는 건 아니다. Buster라는 걸 이용해서 Ghost 리소스들을 전부 static file로 바꾸어서 GitHub repo에 올리면 되긴 하는데, 이 과정에서 UI가 어그러지는 곳도 있고... 말끔하진 않다. 그래도 완전 공짜로 가능하니 메리트가 있긴 한데 한번 해보고 싶다면 이 링크를 타고 가서 해보시길. <a href="https://github.com/paladini/ghost-on-github-pages">https://github.com/paladini/ghost-on-github-pages</a>. 그런 이유로 어쨋든 서버를 쓰긴 써야 하는데 EC2는 관리도 귀찮고 비용도 커지고 RDS도 따로 붙여야 하기 때문에 조금 더 쓰고 쉽고 깔끔한 걸 찾고 있었는데, 열심히 구글링 하던 도중 AWS Lightsail이 눈에 들어왔다. 로고도 마음에 들고 ㅎㅎ. AWS Elastic Beanstalk도 있긴 한데 이건 정해진 탬플릿 안에서 앱을 배포하는 거기 때문에 Ghost를 올리기 전에 또 귀찮은 몇번의 과정을 해줘야 하기 때문에 스킵.</p>
<p>AWS Lightsail은 클릭 몇번으로 자신만의 서버를 바로 운영할 수 있는 서비스이다. 거기다 월별 요금으로 구분되어 있어 EC2나 RDS를 묶어서 사용할 때 처럼 비용 걱정을 하지 않아도 되고, Network metrics도 그냥 간단하게 확인 가능. 진짜 클릭 몇번만 하면 자질구레한 설정 필요없이 바로 완성된 구성과 함께 서버를 사용할 수 있다. EC2랑은 조금 다른게, EC2는 인스턴스를 생성하고 난 다음에 Security Group, ACL, Elastic IP, Key pair 등등 이런 걸 다 직접 설정해줘야 한다. 안해도 되는데 안하면 안하는 대로 문제가 또 생긴다. 근데 Lightsail은 그런 것들을 전부 Wrap해서 Wrapper로써 서비스되는 것이다. 제일 매력적이었던 것은 가격. 월별 요금을 선택해서 이용하면 딱 그 정도만 청구된다. 제일 저렴한 게 $5/month 였는데 이 정도면 개인 블로그 운영하면서 충분히 지불할만 하다.</p>
<h3 id="1awslightsail">1. AWS Lightsail 인스턴스 생성</h3>
<p><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2018/06/Screen-Shot-2018-06-14-at-6.20.10-PM.png" alt="Screen-Shot-2018-06-14-at-6.20.10-PM"></p>
<p>AWS Lightsail에 들어가면 위와 같은 화면이 보이는데 처음 들어가면 아무것도 안보이고 인스턴스 생성 버튼만 있다. 나는 이미 이 글을 쓰는 인스턴스를 하나 생성했기 때문에 목록에 하나가 보인다. 쨋든 <strong>인스턴스 생성</strong>(<strong>Create instance</strong>)을 누르자.</p>
<p><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2018/06/Create-an-instance---Lightsail-3.png" alt="Create-an-instance---Lightsail-3"></p>
<p><strong>Location: Seoul</strong><br>
<strong>Platform: Linux/Unix</strong><br>
<strong>Blueprint: OS Only + Ubuntu</strong><br>
<strong>Plan: $5/month</strong></p>
<p>으로 설정하고 생성(Create)를 누르면 인스턴스 생성이 끝난다.</p>
<h3 id="2staticip">2. Static IP 붙이기</h3>
<p>인스턴스 생성이 끝나면 목록에 생성한 인스턴스가 보이는데 그것을 클릭해서 들어가면 관리할 수 있는 페이지가 나타난다. 거기서 <strong>Networking 탭</strong>을 눌러서 이동하자.</p>
<p><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2018/06/networking.png" alt="networking"></p>
<p><strong>IP addresses &gt; Public IP</strong> 부분에 보면 밑에 <code>Create static IP</code>라는 버튼이 보인다. 지금 보이는 IP는 바로 접근이 가능한 Public IP인데 인스턴스를 중지했다가 다시 시작하면 바뀐다. 따라서 static IP를 하나 생성해서 인스턴스에 붙여야한다. static IP는 인스턴스를 내렸다 올려도 바뀌지 않는다. EC2 쓸 때 많이 봤던 Elastic IP. <code>Create static IP</code> 버튼을 누르고 잇따라 나오는 페이지에서도 그냥 또 <code>Create</code>를 누르면 바로 static IP가 생성되고 생성한 인스턴스에 붙는다.</p>
<p><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2018/06/Screen-Shot-2018-06-13-at-3.47.58-PM.png" alt="Screen-Shot-2018-06-13-at-3.47.58-PM"></p>
<p>인스턴스에 붙어있는 동안엔 공짜다. 야호.</p>
<h3 id="3httpsport">3. HTTPS port 허용</h3>
<p>Nginx를 설치하고 SSL을 설정하려면 443 포트가 열려있어야 한다.</p>
<p><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2018/06/Screen-Shot-2018-06-14-at-6.28.08-PM.png" alt="Screen-Shot-2018-06-14-at-6.28.08-PM"></p>
<p><strong>Firewall &gt; Add another</strong>을 누르면 새롭게 허용할 포트를 추가할 수 있다. 거기서 드롭 다운 메뉴를 눌러 <strong>HTTPS</strong>를 선택한 다음 <strong>Save</strong>를 누르면 바로 저장이 되고 해당 포트가 허용된다.</p>
<h3 id="4ssh">4. SSH 접근</h3>
<p>상단바의 <strong>Account &gt; Account</strong>를 눌러서 계정 관리 페이지로 넘어가자.</p>
<p><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2018/06/Screen-Shot-2018-06-14-at-6.22.49-PM.png" alt="Screen-Shot-2018-06-14-at-6.22.49-PM"></p>
<p><img src="https://s3-ap-northeast-2.amazonaws.com/blog.koriel.kr-storage/2018/06/Screen-Shot-2018-06-14-at-6.31.05-PM.png" alt="Screen-Shot-2018-06-14-at-6.31.05-PM"></p>
<p>넘어가서 SSH keys을 누르면 SSH 접근에 필요한 private key를 다운로드 받을 수 있다. 인스턴스를 서울 리전에서 생성했으므로 서울에 해당하는 key pair를 다운로드 받자. 가능하면 <code>~/.ssh</code> 경로에 다운로드.</p>
<p>다운로드를 다 받으면 터미널을 켜서 아래 명령어로 권한을 수정하고 SSH로 생성한 인스턴스 서버에 접속해보자.</p>
<pre><code class="language-bash">$ chmod 600 [pem file]
$ ssh -i [pem file] ubuntu@[static ip]
</code></pre>
<p>아래와 같이 뜨면 성공적으로 서버에 접속한 것이다.</p>
<pre><code class="language-bash">Welcome to Ubuntu 16.04.4 LTS (GNU/Linux 4.4.0-1052-aws x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  Get cloud support with Ubuntu Advantage Cloud Guest:
    http://www.ubuntu.com/business/services/cloud

0 packages can be updated.
0 updates are security updates.


*** System restart required ***
Last login: Thu Jun 14 08:40:21 2018 from 175.209.190.60
ubuntu@ip-172-26-0-18:~$
</code></pre>
<h3 id="5dns">5. DNS 설정</h3>
<p>블로그에 사용할 도메인이 없다면 하나 사자. <a href="https://kr.godaddy.com">https://kr.godaddy.com</a>. static IP로도 접속할 수 있긴 하지만 SSL 인증서를 발급받지 못할 뿐더러 그 주소 직접 치고 접속할 사람 아무도 없다.</p>
<p>도메인을 구입하면 GoDaddy에서 바로 A 레코드 설정이 가능하다. A 레코드에 위에서 설정한 static IP를 넣으면 된다. 설정법은 여길 보자. <a href="https://kr.godaddy.com/help/point-your-domain-name-to-a-server-19116">https://kr.godaddy.com/help/point-your-domain-name-to-a-server-19116</a>.</p>
<p>GoDaddy에서 도메인을 구입하고 시간이 조금 지나면 소유권 자체를 다른 곳으로 이전할 수 있는데 나는 AWS Route 53으로 다 옮겨놨다. 한 군데에서 다 관리하는 것이 편하기 때문에... 만약 이미 Route 53으로 관리하고 있다면 <a href="https://docs.aws.amazon.com/ko_kr/Route53/latest/DeveloperGuide/resource-record-sets-creating.html">https://docs.aws.amazon.com/ko_kr/Route53/latest/DeveloperGuide/resource-record-sets-creating.html</a> 를 따라서 A 레코드를 생성할 수 있다.</p>
<p>DNS 설정이 끝나면 해당 도메인으로도 SSH 접근이 가능하다.</p>
<pre><code class="language-bash">$ ssh -i [pem file] ubuntu@blog.example.kr
</code></pre>
<p>레코드를 생성한 직후엔 아직 전파가 되지 않아 접속이 안될 수도 있으니 좀 기다리자.</p>
<p>AWS Lightsail로 Ghost 블로그 운영하기 - 1<br>
<a href="https://blog.koriel.kr/aws-lighstsailro-ghost-beulrogeu-unyeonghagi-2/">AWS Lightsail로 Ghost 블로그 운영하기 - 2</a><br>
<a href="https://blog.koriel.kr/aws-lighstsailro-ghost-beulrogeu-unyeonghagi-3/">AWS Lightsail로 Ghost 블로그 운영하기 - 3</a></p>
]]></content:encoded></item><item><title><![CDATA[C++11 스마트 포인터]]></title><description><![CDATA[<p>지금은 더 이상 사용하지 않는 스마트 포인터 <code>std::auto_ptr</code>가 C++11 이전에도 있었다. 하지만 몇가지 문제점이 있었는데, 배열의 포인터를 해제할 때 배열 객체가 모두 제대로 해제되지 않는다는 것과 복사 대입 연산시 실제로는 복사가 되지 않는 다는 것이었다. 후자는 상식적으로 잘 이해가 되지 않을 수도 있는데 C++98 표준에서는</p>]]></description><link>https://blog.koriel.kr/cpp11-smart-pointer/</link><guid isPermaLink="false">5b222c71fd23941a67e10eb2</guid><category><![CDATA[C++]]></category><category><![CDATA[C++11]]></category><dc:creator><![CDATA[Jinsoo Heo]]></dc:creator><pubDate>Sat, 28 Oct 2017 17:37:01 GMT</pubDate><media:content url="https://blog.koriel.kr/content/images/2017/10/ISO_C--_Logo-3.svg" medium="image"/><content:encoded><![CDATA[<img src="https://blog.koriel.kr/content/images/2017/10/ISO_C--_Logo-3.svg" alt="C++11 스마트 포인터"><p>지금은 더 이상 사용하지 않는 스마트 포인터 <code>std::auto_ptr</code>가 C++11 이전에도 있었다. 하지만 몇가지 문제점이 있었는데, 배열의 포인터를 해제할 때 배열 객체가 모두 제대로 해제되지 않는다는 것과 복사 대입 연산시 실제로는 복사가 되지 않는 다는 것이었다. 후자는 상식적으로 잘 이해가 되지 않을 수도 있는데 C++98 표준에서는 복사로 이동을 대신했었다. 유식한 말로 복사 시맨틱이라고 하는데 이것이 개발자들을 상당히 곤란하게 만들었었다. 아래 코드를 좀 보자.</p>
<pre><code class="language-cpp">#include &lt;memory&gt;

int main() {
    std::auto_ptr&lt;int&gt; foo(new int(3));
    
    std::auto_ptr&lt;int&gt; bar = foo; // 이때 foo는 null_ptr가 되어버린다.
    
    return 0;
}
</code></pre>
<p><code>std::auto_ptr</code>의 복사 대입 연산자 함수 구현를 보았다면 이렇게 될 걸 예견할 수 있지만, 그렇지 않다면 그걸 미리 알기는 쉽지 않다.</p>
<p>이러한 문제점들을 보완하기 위해 C++11 표준에서는 새로운 스마트 포인터들이 포함됐다. 그리고 이동 시맨틱이 추가되었다. 이동 시맨틱은 객체를 복사하지 않고 이동시킨다. 이동 후에 객체의 소유권은 당연히 대입된 쪽이 가진다. 복사 시맨틱일 경우, STL 컨테이너 중 리스트나 벡터는 동적 배열이기 때문에 상황에 따라 그 메모리 크기가 두배까지 늘어난다. 그러고 나선 정작 원본은 해제시켜버린다. 이런 일련의 동작들이 메모리를 낭비하고 성능을 저하시키기 때문에 이동 시맨틱은 꼭 필요한 것이었다.</p>
<br>
<h3 id="1unique_ptr">1. unique_ptr</h3>
<p>C++11에선 <code>std::unique_ptr</code>라는 새로운 고유 포인터 타입을 도입했다. <code>std::auto_ptr</code>의 하위 호환이다. <code>std::unique_ptr</code>는 복사 생성자와 복사 대입 연산자가 아예 구현되어 있지 않다. 그렇기 때문에 복사가 애초에 불가능하고 이동만 가능하다. 이동은 <code>std::move()</code> 함수로만 가능하다. 포인터는 <code>get()</code> 멤버 함수로 얻을 수 있고 메모리 해제는 <code>reset()</code> 멤버 함수로 한다.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() {
    std::unique_ptr&lt;int&gt; foo(new int(3));
    
    // auto baz = foo; // 복사할 수 없다.
    auto bar = std::move(foo); // bar로 이동
    
    std::cout &lt;&lt; foo.get() &lt;&lt; std::endl; // null_ptr기 때문에 0 출력
    std::cout &lt;&lt; bar.get() &lt;&lt; std::endl;
    
    foo.reset(); // 이미 이동되었기 때문에 아무 동작도 수행되지 않는다.
    bar.reset(); // 메모리 해제
    
    return 0;
}
</code></pre>
<p>포인터를 복사할 수 없는거지 포인터가 가리키는 객체를 복사할 수 없는 것은 아니다. 또 복사 대입 연산시 좌항을 참조자로 선언하고 정의하는 것도 포인터의 포인터를 통해 참조하는 것이기 때문에 가능하다.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() {
    std::unique_ptr&lt;int&gt; foo(new int(3));
    
    auto bar = *foo;
    auto&amp; baz = foo;
    
    // 포인터 출력
    std::cout &lt;&lt; foo.get() &lt;&lt; std::endl;
    std::cout &lt;&lt; &amp;bar &lt;&lt; std::endl; // 컴파일러가 bar의 데이터 타입을 int로 추정
    std::cout &lt;&lt; baz.get() &lt;&lt; std::endl; // 참조자로 선언하고 정의했기 때문에 별 문제없이 출력된다.
    
    // 객체 출력
    std::cout &lt;&lt; *foo &lt;&lt; std::endl; // 3
    std::cout &lt;&lt; bar &lt;&lt; std::endl; // 3
    std::cout &lt;&lt; *baz &lt;&lt; std::endl; // 3
    
    return 0;
}
</code></pre>
<p>마지막으로 한가지 유의할 점이 있다. <code>const std::unique</code>로 선언된 포인터는 <code>std::move()</code>로도 이동시킬 수 없다. 비트 수준의 상수성을 가지고 있기 때문에 데이터를 다른 곳으로 이동을 시킬 수 없어서 그렇다.</p>
<pre><code class="language-cpp">#include &lt;memory&gt;

int main() {
    const std::unique_ptr&lt;int&gt; foo(new int(3));
    
    auto bar = std::move(foo); // error: use of deleted function 'std::unique_ptr&lt;_Tp, _Dp&gt;::unique_ptr(const std::unique_ptr&lt;_Tp, _Dp&gt;&amp;) [with _Tp = int; _Dp = std::default_delete&lt;int&gt;]'
    
    return 0;
}
</code></pre>
<br>
<h3 id="2shared_ptr">2. shared_ptr</h3>
<p><code>std::shared_ptr</code>는 이름처럼 가리키는 객체의 소유권을 다른 포인터들과 공유할 수 있는 포인터다. <code>std::unique_ptr</code>과는 다르게 복사도 마음껏 할 수 있다. 같은 객체를 가리키는 <code>std::shared_ptr</code>은 레퍼런스 카운팅으로 추적된다. 참조된 횟수를 세는 것이므로 포인터가 복사될 때 마다 1씩 증가한다. 그리고 해제될 때 마다 1씩 감소한다. 포인터가 가리키는 객체의 메모리가 해제되는 시점은 레퍼런스 카운트가 0이 될 때이다. 레퍼런스 카운트는 <code>use_count()</code> 멤버 함수로 가져올 수 있다.</p>
<p>신기하게도 <code>std::shared_ptr</code> 객체가 복사되어도 메모리 공간은 늘어나지 않는다. 객체의 메모리 공간은 그대로 두고 앞서 이야기한대로 레퍼런스 카운트만 건드리기 때문에 그렇다.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() {
    std::shared_ptr&lt;int&gt; foo(new int(3)); // reference count = 1
    auto bar = foo; // reference count = 2
    
    std::cout &lt;&lt; &quot;reference count: &quot; &lt;&lt; bar.use_count() &lt;&lt; std::endl;
    
    foo.reset(); // reference count = 1
    
    std::cout &lt;&lt; &quot;reference count: &quot; &lt;&lt; bar.use_count() &lt;&lt; std::endl;
    
    bar.reset(); // reference count = 0, 이떄 객체가 완전히 해제된다.
    
    return 0;
}
</code></pre>
<p>레퍼런스 카운트가 0이 되어 참조하는 객체를 해제할 때 <code>std::shared_ptr</code>는 <code>delete</code> 연산자를 사용한다. 여기에 문제가 있다. 뭐가 문제냐고? <code>delete[]</code>는 사용하지 않는 것이 문제다.</p>
<pre><code class="language-cpp">#include &lt;memory&gt;
#include &lt;vector&gt;

int main() {
    std::shared_ptr&lt;int&gt; foo(new int[1024]); // 이렇게 배열의 포인터를 선언하지 말고
    
    foo.reset();
    
    std::vector&lt;std::shared_ptr&lt;int&gt;&gt; bars; // 포인터 벡터를 만들면 해결된다.
    bars.push_back(std::shared_ptr&lt;int&gt;(new int(3)));
    
    for(auto&amp; bar : bars) {
        bar.reset();
    }
}
</code></pre>
<p>이렇게 해결할 수도 있지만 전혀 섹시하지 않다. <code>std::shared_ptr</code>의 기본 생성자를 이용해서 해결하면 조금 더 섹시해질 수 있다. <code>std::shared_ptr</code>의 기본 생성자는 아래와 같이 정의되어 있다.</p>
<pre><code class="language-cpp">constexpr shared_ptr() noexcept; // (1)

constexpr shared_ptr( std::nullptr_t ) noexcept; // (2)

template&lt; class Y &gt;
explicit shared_ptr( Y* ptr ); // (3)

template&lt; class Y, class Deleter &gt;
shared_ptr( Y* ptr, Deleter d ); // (4)

template&lt; class Deleter &gt;
shared_ptr( std::nullptr_t ptr, Deleter d ); // (5)

template&lt; class Y, class Deleter, class Alloc &gt;
shared_ptr( Y* ptr, Deleter d, Alloc alloc ); // (6)
</code></pre>
<p>4번째 기본 생성자를 보면 두번째 인자로 Deleter 함수 객체를 받고 있다. 여기에 우리가 원하는  Deleter 함수 객체를 넣어주면 <code>std::shared_ptr</code>가 그것으로 객체를 해제할 것이다.</p>
<pre><code class="language-cpp">#include &lt;memory&gt;

template&lt;typename T&gt;
struct ArrayDeleter {
    void operator() (T* ptr) {
        delete[] ptr;
    }
};

int main() {
    std::shared_ptr&lt;int&gt; foo(new int[1024], ArrayDeleter&lt;int&gt;());
    
    foo.reset(); // 이제 배열도 제대로 해제될 것이다.
    
    return 0;
}
</code></pre>
<p>Deleter로 함수 객체가 아닌 lambda를 넘겨주어도 된다.</p>
<pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;memory&gt;

template&lt;typename T&gt;
std::function&lt;void (T*)&gt; array_deleter() {
    return [](T* ptr) { delete[] ptr; };
}

int main()
{
    std::shared_ptr&lt;int&gt; foo(new int[1024], array_deleter&lt;int&gt;());
    
    foo.reset();
    
    return 0;
}
</code></pre>
<p>C++11 lambda는 template을 지원하지 않기 때문에 lambda를 반환하는 템플릿 함수를 정의하는 트릭을 썼다.</p>
<br>
<h5 id="">참조 객체의 형변환</h5>
<p><code>static_pointer_cast&lt;&gt;()</code> 함수로 <code>std::shared_ptr</code>가 가리키는 객체의 형을 변환할 수 있다.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

class Car {
};

class Sedan : public Car {
public:
    Sedan(int price) : price(price) {};
    void set_price(int price) { this-&gt;price = price; };
    int get_price() { return this-&gt;price; };

private:
    int price;
};

int main() {
    std::shared_ptr&lt;Sedan&gt; camry(new Sedan(3000));
    std::static_pointer_cast&lt;Car&gt;(camry);

    std::cout &lt;&lt; camry.use_count() &lt;&lt; std::endl; // 1

    auto _camry = std::static_pointer_cast&lt;Sedan&gt;(camry);

    std::cout &lt;&lt; camry.use_count() &lt;&lt; std::endl; // 2
}
</code></pre>
<br>
<h5 id="shared_ptr">shared_ptr의 문제점</h5>
<ul>
<li>순환 참조</li>
</ul>
<p>순환 참조는 보통 그룹 객체와 소속 객체 사이에 발생한다. 서로가 서로를 참조하고 있는 상황이기 때문에 메모리 해제가 제대로 안되는 상황이 발생한다.</p>
<ul>
<li>멀티쓰레드 안정성</li>
</ul>
<p>다수의 쓰레드에서 같은 각체를 참조하는 경우가 있을 수 있다. 이때 읽기는 안전하지만 쓰기는 안전하지 않다.</p>
<br>
<h3 id="3weak_ptr">3. weak_ptr</h3>
<p><code>std::shared_ptr</code>가 참조하는 객체는 레퍼런스 카운트가 0이 되는 시점에 같이 해제된다고 했었다. 이러한 특징때문에 발생하는 심각한 문제가 있다. 두 클래스가 서로의 클래스 인스턴스 즉, 서로의 객체를 <code>std::shared_ptr</code>로 참조하고 있으면 두 객체 모두 영원히 <code>reset()</code> 멤버 함수로 해제될 수 없다. 이런 문제는 그룹 객체와 소속 객체 사이에서 자주 나타난다. 이럴 때 어느 한쪽에서 <code>std::shared_ptr</code>가 아닌 <code>std::weak_ptr</code>로 다른 객체를 참조하면 문제를 해결할 수 있다. <code>std::weak_ptr</code>은 객체의 레퍼런스 카운트에 포함되지 않기 때문에 가능한 일이다. 사실 객체의 참조는 강한 참조와 약한 참조로 나뉘는데 객체의 생명 주기에 관여하는 참조가 강한 참조이다. <code>std::weak_ptr</code>는 이름에서 알 수 있듯이 약한 참조이다. 따라서 <code>std::weak_ptr</code>을 통해서 멤버 변수나 함수에 접근할 수 없고 포인터에도 직접 접근할 수 없다.</p>
<p><code>std::weak_ptr</code>의 기본 생성자, 복사 생성자, 복사 대입 연산자는 아래와 같다.</p>
<pre><code class="language-cpp">// constructor
constexpr weak_ptr() noexcept;

weak_ptr( const weak_ptr&amp; r ) noexcept;

template&lt; class Y &gt;
weak_ptr( const weak_ptr&lt;Y&gt;&amp; r ) noexcept;

template&lt; class Y &gt;
weak_ptr( const std::shared_ptr&lt;Y&gt;&amp; r ) noexcept;

weak_ptr( weak_ptr&amp;&amp; r ) noexcept;

template&lt; class Y &gt;
weak_ptr( weak_ptr&lt;Y&gt;&amp;&amp; r ) noexcept;

// operator=
weak_ptr&amp; operator=( const weak_ptr&amp; r ) noexcept;

template&lt; class Y &gt;
weak_ptr&amp; operator=( const weak_ptr&lt;Y&gt;&amp; r ) noexcept;

template&lt; class Y &gt;
weak_ptr&amp; operator=( const shared_ptr&lt;Y&gt;&amp; r ) noexcept;

weak_ptr&amp; operator=( weak_ptr&amp;&amp; r ) noexcept;

template&lt; class Y &gt;
weak_ptr&amp; operator=( weak_ptr&lt;Y&gt;&amp;&amp; r ) noexcept;
</code></pre>
<p>한번 쭉 보면 알 수 있듯이 같은 형 또는 <code>std::shared_ptr</code>의 객체만 그 인자로 받고 있다. 형 변환도 <code>std::shared_ptr</code>로만 가능하다. 그리고 <code>std::weak_ptr</code>은 포인터에 직접 접근을 할 수 없기 때문에 <code>lock()</code> 멤버 함수로 <code>std::shared_ptr</code> 객체를 생성한 다음 그 객체를 통해서 포인터에 접근해야 한다.</p>
<pre><code class="language-cpp">#include &lt;memory&gt;

int main() {
    std::shared_ptr&lt;int&gt; foo(new int(3)); // reference count = 1
    std::weak_ptr&lt;int&gt; bar = foo; // reference count = 1
    
    {
        auto baz = bar.lock(); // reference count = 2
    } // 이 closure를 벗어나면서 baz는 해제된다. reference count = 1
    
    foo.reset(); // reference count = 0
    
    return 0;
}
</code></pre>
<p>아래는 <code>std::weak_ptr</code>를 이용해서 그룹 객체와 소속 객체의 순환 참조 문제를 해결한 예시이다.</p>
<pre><code class="language-cpp">#include &lt;memory&gt;

class Tenant;

class Room {
public:
    Room() {}
    ~Room() { release_tenant(); }

    void set_tenant(const std::shared_ptr&lt;Tenant&gt;&amp; tenant) {
        this-&gt;tenant = tenant;
    }

    void release_tenant() {
        this-&gt;tenant.reset();
    }

private:
    std::shared_ptr&lt;Tenant&gt; tenant;
};

class Tenant {
public:
    void set_room(const std::shared_ptr&lt;Room&gt;&amp; room) {
        this-&gt;room = room;
    }

    void leave_room() {
        if(!this-&gt;room.expired()) {
            std::shared_ptr&lt;Room&gt; room = this-&gt;room.lock();

            if(room) {
                room-&gt;release_tenant();
            }
        }
    }
private:
    std::weak_ptr&lt;Room&gt; room;
};

int main() {
    /*
     * 아래 표시된 숫자들은 해당 객체의 레퍼런스 카운트
     */

    std::shared_ptr&lt;Room&gt; room(new Room()); // room: 1

    {
        std::shared_ptr&lt;Tenant&gt; tenant(new Tenant()); // room:1, tenant: 1

        room-&gt;set_tenant(tenant); // room: 1, tenant: 2
        tenant-&gt;set_room(room); // room: 1, tenant: 2
    } // room: 1, tenant: 1

    room.reset(); // room: 0, tenant: 0
}
</code></pre>
]]></content:encoded></item><item><title><![CDATA[Modern C++ lambda의 특징과 사용법]]></title><description><![CDATA[<p>lambda는 람다 표현식 또는 람다 함수, <strong>익명 함수</strong>(anonymous function)로 불립니다. 그 성질은 함수 객체(functor)와 동일합니다. 그 이름처럼 몸통은 있지만 이름이 없는 함수입니다. 요즘 대부분의 프로그래밍 언어들은 이 lambda를 지원하고 있습니다.</p>
<p>lambda는 함수 객체 클래스를 암시적으로 정의하고 함수 객체를 생성합니다. lambda로 생성된 함수 객체는 타입을 가지고 있긴</p>]]></description><link>https://blog.koriel.kr/modern-cpp-lambdayi-teugjinggwa-sayongbeob/</link><guid isPermaLink="false">5b222c71fd23941a67e10eb1</guid><category><![CDATA[C++]]></category><category><![CDATA[C++11]]></category><category><![CDATA[Modern C++]]></category><dc:creator><![CDATA[Jinsoo Heo]]></dc:creator><pubDate>Mon, 23 Oct 2017 15:18:59 GMT</pubDate><media:content url="https://blog.koriel.kr/content/images/2017/10/ISO_C--_Logo-2.svg" medium="image"/><content:encoded><![CDATA[<img src="https://blog.koriel.kr/content/images/2017/10/ISO_C--_Logo-2.svg" alt="Modern C++ lambda의 특징과 사용법"><p>lambda는 람다 표현식 또는 람다 함수, <strong>익명 함수</strong>(anonymous function)로 불립니다. 그 성질은 함수 객체(functor)와 동일합니다. 그 이름처럼 몸통은 있지만 이름이 없는 함수입니다. 요즘 대부분의 프로그래밍 언어들은 이 lambda를 지원하고 있습니다.</p>
<p>lambda는 함수 객체 클래스를 암시적으로 정의하고 함수 객체를 생성합니다. lambda로 생성된 함수 객체는 타입을 가지고 있긴 하지만 <code>decltype</code>이나 <code>sizeof</code>를 사용할 순 없습니다.</p>
<br>
<h3 id="1vslambda">1. 함수 객체 vs lambda</h3>
<p>C++ 프로그래밍을 하다 보면 함수 포인터나 함수 객체가 필요한 시점이 있습니다. 함수 포인터는 Callback 함수를 상황에 따라 다르게 하거나 Strategy 패턴을 구현할 때 주로 씁니다. 하지만 함수 포인터는 상태를 가질 수 없기 때문에 상태를 가져야하는 함수가 필요할 땐 함수 객체를 씁니다. 둘 다 장단점이 있습니다. 함수 객체의 가장 큰 단점은 번거로움이죠. 함수 객체를 정의할 땐 클래스나 구조체를 정의해야 합니다. 코드도 길어지고 보기도 좋지 않습니다.</p>
<p>lambda는 함수 포인터와 함수 객체의 장점만 골라 가졌다고 볼 수 있습니다. 정의하기 위해서 클래스나 구조체를 정의할 필요가 없고가 상태도 가질 수 있습니다.</p>
<p>예시로 같은 기능의 함수를 함수 객체와 lambda로 모두 구현해보고 lambda가 함수 객체에 비해 얼마나 편리한 지 알아보겠습니다.</p>
<pre><code class="language-cpp">#include &lt;array&gt;
#include &lt;algorithm&gt;

// 함수 객체로 구현
struct SumFunctor : public std::unary_function&lt;int, void&gt; {
    SumFunctor(int&amp; number) : sum(number) {}
    
    void operator() (int&amp; number) {
        sum += number;
    }
    
private:
    int&amp; sum;
};

int main() {
    std::array&lt;int, 5&gt; numbers = { 1, 2, 3, 4, 5 };
    int sum = 0;
    
    std::for_each(numbers.begin(), numbers.end(), SumFunctor(sum));
    
    sum = 0;
    
    // lambda로 구현
    std::for_each(numbers.begin(), numbers.end(), [&amp;sum](int&amp; number) { 
        sum += number; 
    });
    
    return 0;
}
</code></pre>
<p>합계를 저장할 변수를 참조자로 전달받아 거기에 값을 누적시키는 함수를 구현했습니다. 함수 객체로 구현할 경우 번거롭게 구조체를 먼저 정의한 후 사용해야 합니다. 하지만 lambda는 그렇지 않죠. 단 몇줄만으로 끝났습니다. 굉장히 섹시합니다. 이제 왜 써야하는지는 알았으니 어떻게 쓰는지를 알아봅시다.</p>
<br>
<h3 id="2lambda">2. lambda의 사용법</h3>
<h5 id="21lambda">2-1. lambda의 문법</h5>
<p>lambda의 문법은 크게 캡처(capture), 인자(parameter), 반환형(return type), 몸통(body)로 이루어져 있습니다.</p>
<pre><code class="language-cpp">[captures](parameters) -&gt; return type { body }

/*
* captures: comma(,)로 구분된 캡처들이 들어갑니다.
* parameters: 함수의 인자들이 들어갑니다.
* return type: 함수의 반환형입니다.
* body: 함수의 몸통입니다.
*/
</code></pre>
<p>캡처를 제외한 나머지 것들은 대부분 아시리라 봅니다. 그냥 함수와 동일합니다. 캡처는 lambda에서 사용할 변수나 상수들을 미리 지정하여 찍어오는 것입니다. 참조하여 찍어올 수도 있고 복사하여 찍어올 수도 있는데 그건 천천히 예시를 보면서 알아보겠습니다.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    // no parameter, no argument.
    []() { std::cout &lt;&lt; &quot;Hello lambda!&quot; &lt;&lt; std::endl; }();
    
    return 0;
}
</code></pre>
<br>
<h5 id="22lambdaparameter">2-2. lambda의 parameter</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    [](std::string name) {
        std::cout &lt;&lt; &quot;My name is &quot; &lt;&lt; name &lt;&lt; std::endl;
    }(&quot;Jinsoo Heo&quot;);
    
    return 0;
}
</code></pre>
<br>
<h5 id="23lambdastdfunction">2-3. lambda를 std::function에 대입</h5>
<p>lambda는 <code>std::function</code>에 대입이 가능합니다. <code>auto</code> 키워드로 타입 추정도 물론 가능합니다.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;functional&gt;

int main() {
    // std::function&lt;void (std::string)&gt;
    auto introduce = [](std::string name) {
        std::cout &lt;&lt; &quot;My name is &quot; &lt;&lt; name &lt;&lt; std::endl;
    };
    
    introduce(&quot;Jinsoo Heo&quot;);
    
    return 0;
}
</code></pre>
<br>
<h5 id="24lambda">2-4. lambda를 함수의 파라미터로 사용</h5>
<p>lambda를 <code>std::function</code>에 대입할 수 있다는 것은 그것을 함수의 파라미터로 전달할 수도 있다는 이야기입니다. 하지만 전달되는 함수의 반환형과 그 파라미터의 타입이 항상 같지 않을 수 있으므로 주로 템플릿 함수의 파라미터로 전달됩니다.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;functional&gt;

template&lt;typename T&gt;
void templateFunc(T func) {
    func();
}

int main() {
    // std::function&lt;void (void)&gt;
    auto foo = []() { std::cout &lt;&lt; &quot;Hello lambda!&quot; &lt;&lt; std::endl; };
    
    templateFunc(foo);
    
    return 0;
}
</code></pre>
<br>
<h5 id="25lambda">2-5. lambda를 반환하는 함수</h5>
<p>함수가 lambda를 반환하는 것도 가능합니다.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;functional&gt;

std::function&lt;void (void)&gt; getLambda() {
    return []() { std::cout &lt;&lt; &quot;Hello lambda!&quot; &lt;&lt; std::endl; };
}

int main() {
    auto foo = getLambda();
    
    foo();
    
    return 0;
}
</code></pre>
<br>
<h5 id="26lambdastlcontainer">2-6. lambda를 STL container에 저장</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;std::function&lt;void (void)&gt;&gt; funcs;
    
    funcs.push_back([]() { std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl; });
    funcs.push_back([]() { std::cout &lt;&lt; &quot;lambda!&quot; &lt;&lt; std::endl; });
    
    for(auto&amp; func : funcs) {
        func();
    }
}
</code></pre>
<br>
<h5 id="27lambda">2-7. lambda의 반환형 명시</h5>
<p>lambda는 값을 반환할 수 있고 그 반환형을 명시할 수 있습니다. C++0x부터 등장한 후행 반환형(trailing return type)을 사용합니다. 또한 함수 포인터나 함수 객체와 다르게 반환형의 추론도 가능합니다.</p>
<pre><code class="language-cpp">int main() {
    // implicit return type
    auto foo = [] { return 3.14;};
    
    // explicit return type
    auto bar = []() -&gt; float { return 3.14f; };
    
    // warning. double에서 float으로 암시적 형변환.
    float x = foo();
    
    // OK
    float y = bar();
    
    return 0;
}
</code></pre>
<br>
<h3 id="3lambda">3. lambda의 캡처</h3>
<p>lambda 외부에 정의되어 있는 변수나 상수를 lambda 내부에서 사용하기 위해서 캡처를 사용합니다. 참조(reference)와 복사(copy) 두 방식을 사용할 수 있고, 참조는 <code>&amp;var</code>로 복사는 <code>var</code>로 합니다. 그리고 캡처는 처음에 보았듯이 문법 요소 중 가장 처음에 나오는 <code>[]</code>에 기술합니다.</p>
<h5 id="31">3-1. 참조로 캡처</h5>
<pre><code class="language-cpp">#include &lt;array&gt;
#include &lt;algorithm&gt;

int main() {
    std::array&lt;int, 5&gt; numbers = { 1, 2, 3, 4, 5 };
    int sum = 0;
    
    // sum을 참조로 캡처
    std::for_each(numbers.begin(), numbers.end(), [&amp;sum](int&amp; number) { 
        sum += number; 
    });
    
    return 0;
}
</code></pre>
<br>
<h5 id="32">3-2. 복사로 캡처</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    std::string name = &quot;Jinsoo Heo&quot;;
    
    [name]() {
        std::cout &lt;&lt; &quot;My name is &quot; &lt;&lt; name &lt;&lt; std::endl;
    }();
    
    return 0;
}
</code></pre>
<p>복사에선 주의해야할 점이 하나있습니다. 복사로 캡처된 변수는 몸통(body)에서 변경을 할 수 없다는 것이 바로 그것입니다.</p>
<pre><code class="language-cpp">#include &lt;array&gt;
#include &lt;algorithm&gt;

int main() {
    std::array&lt;int, 5&gt; numbers = { 1, 2, 3, 4, 5 };
    int sum = 0;
    
    // sum을 복사로 캡처
    std::for_each(numbers.begin(), numbers.end(), [sum](int&amp; number) { 
        // 'sum': 변경 불가능한 람다에서 복사 방식 캡처를 수정할 수 없습니다.
        sum += number;
    });
    
    return 0;
}
</code></pre>
<p>lambda의 문법 요소 중 지정자(specifier)라는 것이 있는데 이건 선택 사항입니다. 이 지정자를 이용해서 캡처된 변수를 몸통안에서 어떻게 쓸 것인지 지정할 수 있습니다. 대표적으로 <code>mutable</code>과 <code>constexpr</code>이 있는데, <code>mutable</code>은 복사로 캡처된 변수를 몸통안에서 수정될 수 있도록 허용하는 지정자이고 <code>constexpr</code>은 함수 호출 연산자(function call operator)가 상수 식인 것을 명시하는 지정자입니다. 지정자에 아무 것도 기술하지 않으면 <code>constexpr</code>이 기본값으로 들어갑니다.</p>
<pre><code class="language-cpp">#include &lt;array&gt;
#include &lt;algorithm&gt;

int main() {
    std::array&lt;int, 5&gt; numbers = { 1, 2, 3, 4, 5 };
    int sum = 0;
    
    // sum을 복사로 캡처. mutable 지정자
    std::for_each(numbers.begin(), numbers.end(), [sum](int&amp; number) mutable { 
        // OK
        sum += number;
    });
    
    return 0;
}
</code></pre>
<br>
<h5 id="33">3-3. 여러개의 변수나 상수 캡처</h5>
<p>여러개의 변수나 상수를 한번에 캡처할 수 있습니다. <code>[]</code>안에 여러 캡처들을 comma(,)로 구분하여 기술하면 됩니다.</p>
<pre><code class="language-cpp">#include &lt;string&gt;

int main() {
    int x = 0;
    char y = 'J';
    double z = 3.14;
    std::string w = &quot;Jinsoo Heo&quot;;
    
    // x, y는 참조로, z, w는 복사로 캡처.
    auto foo = [&amp;x, &amp;y, z, w]() {};
}
</code></pre>
<ul>
<li><code>[a,&amp;b]</code> a를 복사로 캡처, b를 참조로 캡처.</li>
<li><code>[this]</code> 현재 객체를 참조로 캡처.</li>
<li><code>[&amp;]</code> 몸통에서 쓰이는 모든 변수나 상수를 참조로 캡처하고 현재 객체를 참조로 캡처.</li>
<li><code>[=]</code> 몸통에서 쓰이는 모든 변수나 상수를 복사로 캡처하고 현재 객체를 참조로 캡처.</li>
<li><code>[]</code> 아무것도 캡처하지 않음.</li>
</ul>
<p><code>[&amp;]</code>나 <code>[=]</code>는 lambda가 정의되어있는 함수를 넘어서서 전역(global) 범위까지가 그 캡처 범위입니다. <code>[&amp;, a]</code> 이렇게 하면 모든 변수나 상수를 캡처하고 <code>a</code>만 예외적으로 복사로 캡처하는 것입니다. <code>[=, &amp;b]</code>도 마찬가지로 모든 변수나 상수를 캡처하고 <code>b</code>만 예외적으로 참조로 캡처하는 것이구요. 그런데 <code>[&amp;, &amp;a]</code> 이렇게 쓰는 건 안됩니다. <code>a</code>를 같은 방식으로 2번 캡처하는 것이기 때문이죠.</p>
<pre><code class="language-cpp">int main() {
    int a, b, c;
    
    // OK
    [&amp;, a, b]() {}();
    // OK
    [=, &amp;c]() {}();
    
    // 기본 캡처 모드가 참조 방식인 경우 '&amp;a'을(를) 사용할 수 없습니다.
    [&amp;, &amp;a]() {}();
    // 기본 캡처 모드가 값 방식인 경우 '&amp;b'이(가) 필요합니다.
    [=, b]() {}();
}
</code></pre>
<br>
<h5 id="34">3-4. 전역 변수 캡처</h5>
<p>전역 변수를 아래와 같이 캡처하면 오류가 발생합니다.</p>
<pre><code class="language-cpp">#include &lt;array&gt;
#include &lt;algorithm&gt;

int sum = 0;

int main() {
    std::array&lt;int, 5&gt; numbers = { 1, 2, 3, 4, 5 };
    
    // 전역 변수 sum을 참조로 캡처
    std::for_each(numbers.begin(), numbers.end(), [&amp;sum](int&amp; number) { 
        // 'sum': 람다 캡처 변수는 바깥쪽 함수 범위에 속해야 합니다
        sum += number;
    });
    
    return 0;
}
</code></pre>
<p>전역 변수를 캡처하기 위해서는 기본 캡처 모드(capture-default)를 사용해야 합니다.</p>
<pre><code class="language-cpp">#include &lt;array&gt;
#include &lt;algorithm&gt;

int sum = 0;

int main() {
    std::array&lt;int, 5&gt; numbers = { 1, 2, 3, 4, 5 };
    
    // 참조 방식의 기본 캡처 모드
    std::for_each(numbers.begin(), numbers.end(), [&amp;](int&amp; number) { 
        // OK
        sum += number;
    });
    
    return 0;
}
</code></pre>
<br>
<h5 id="35lambda">3-5. 클래스 멤버 함수 속 lambda</h5>
<p>클래스 멤버 함수안에서 lambda를 정의하면 <code>[this]</code>로 현재 객체를 참조로 캡처할 수 있습니다. 이때 lambda는 friend 함수이므로 현재 객체의 private 멤버에도 접근할 수 있습니다.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

class Person {
public:
    Person(std::string name) : name(name) {}
    void introduce() {
        [this]() { std::cout &lt;&lt; &quot;My name is &quot; &lt;&lt; name &lt;&lt; std::endl; }();
    }
private:
    std::string name;
};

int main() {
    Person* devkoriel = new Person(&quot;Jinsoo Heo&quot;);
    devkoriel-&gt;introduce(); // My name is Jinsoo Heo
    
    return 0;
}
</code></pre>
<p>클래스 멤버 함수안에서 정의되는 것뿐만 아니라 lambda 자체가 멤버로 선언될 수도 있습니다. 이럴 경우 기존 멤버 다루듯 하면 됩니다. <code>[this]</code>로 현재 객체를 참조로 캡처할 수 있는 것도 마찬가지입니다.</p>
<br>
<h5 id="36lambda">3-6. lambda 재귀</h5>
<p>lambda는 기본적으로 함수이기 때문에 재귀도 당연히 가능합니다. 대입된 <code>std::function</code> 함수를 참조로 캡처한 후 몸통에서 호출하면 됩니다.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;functional&gt;

int main() {
    std::function&lt;int (int)&gt; factorial = [&amp;factorial](int x) -&gt; int {
        return x &lt;= 1 ? 1 : x * factorial(x - 1);
    };
    
    std::cout &lt;&lt; &quot;factorial(5): &quot; &lt;&lt; factorial(5) &lt;&lt; std::endl;
}
</code></pre>
<p>팩토리얼 함수를 lambda와 재귀를 통해 구현해보았습니다. 간단한 코드이지만 주의해야할 점이 있습니다. lambda를 대입시킬 함수의 타입을 <code>auto</code> 키워드로 추론하면 안됩니다. 어찌보면 당연한 것이, <code>auto</code> 키워드를 쓰면 컴파일러가 타입을 추론하게 되는데, 타입이 제대로 추론되기도 전에 lambda 몸통에서 그 함수를 재귀적으로 호출하고 있기 때문입니다. lambda 재귀를 할땐 반드시 대입시킬 함수의 타입을 명시하여야 합니다.</p>
<br>
<h3 id="4">4. 정리</h3>
<ul>
<li>lambda는 익명 함수(anonymous function)이고 함수 객체를 생성한다.</li>
<li>lambda는 함수 포인터와 함수 객체의 장점을 모두 가지고 있다.</li>
<li>기본 캡처 모드(capture-default), 복사, 참조를 통해 변수나 상수를 캡처할 수 있다.</li>
<li>함수에서 반환할 수도 있고 함수의 파라미터로 전달할 수도 있다.</li>
<li>클래스 멤버 함수안에서 정의되는 lambda는 <code>[this]</code>로 현재 객체를 참조로 캡처할 수 있다.</li>
<li>재귀 호출이 가능하다.</li>
</ul>
]]></content:encoded></item><item><title><![CDATA[#define 보다는 const, enum, inline을 쓰자]]></title><description><![CDATA[<p>C++ 프로그래밍을 할 때 우리는 종종 선행 처리기(Pre-processor)를 사용합니다. 보통 프로그램 전체에 걸쳐 사용되는 상수가 필요할 경우, 아래의 형식으로 사용되죠.</p>
<pre><code class="language-cpp">#define PI 3.14159265359
</code></pre>
<p>위의 전처리문으로 프로그램의 코드가 컴파일러에게 넘어가기 전에 선행 처리기가 코드에 등장하는 모든 <code>PI</code>를 <code>3.14159265359</code>로 바꾸어 버립니다. 그 결과로 컴파일러가 사용하는 기호</p>]]></description><link>https://blog.koriel.kr/define-bodaneun-const-enum-inlineeul-sseuja/</link><guid isPermaLink="false">5b222c71fd23941a67e10eb0</guid><category><![CDATA[C++]]></category><dc:creator><![CDATA[Jinsoo Heo]]></dc:creator><pubDate>Sun, 22 Oct 2017 16:09:02 GMT</pubDate><media:content url="https://blog.koriel.kr/content/images/2017/10/ISO_C--_Logo-1.svg" medium="image"/><content:encoded><![CDATA[<img src="https://blog.koriel.kr/content/images/2017/10/ISO_C--_Logo-1.svg" alt="#define 보다는 const, enum, inline을 쓰자"><p>C++ 프로그래밍을 할 때 우리는 종종 선행 처리기(Pre-processor)를 사용합니다. 보통 프로그램 전체에 걸쳐 사용되는 상수가 필요할 경우, 아래의 형식으로 사용되죠.</p>
<pre><code class="language-cpp">#define PI 3.14159265359
</code></pre>
<p>위의 전처리문으로 프로그램의 코드가 컴파일러에게 넘어가기 전에 선행 처리기가 코드에 등장하는 모든 <code>PI</code>를 <code>3.14159265359</code>로 바꾸어 버립니다. 그 결과로 컴파일러가 사용하는 기호 테이블에는 <code>PI</code>가 포함되지 않습니다. 이건 프로그래머에게 상당히 곤란한 상황을 만들어 낼 수 있습니다. <code>PI</code>가 사용된 코드에서 컴파일 에러가 난 상황이 바로 그 상황입니다. 분명 코드엔 <code>PI</code>가 있었는데, 컴파일 에러에선 <code>PI</code>가 보이지 않고 <code>3.14159265359</code>만이 보일 뿐입니다. 행여 <code>PI</code>가 정의된 파일이 자신이 작성한 것이 아니라면 이 문제는 더욱 심각해집니다. 이 경우엔 대체 <code>3.14159265359</code>이 어디서 왔는지 찾아내느라 시간을 낭비해야만 합니다.</p>
<p>이런 문제는 매크로 대신 상수를 사용해서 해결할 수 있습니다.</p>
<pre><code class="language-cpp">const double pi = 3.14159265359;
</code></pre>
<p><code>pi</code>는 C++에서 지원하는 상수 타입의 데이터이기 때문에 컴파일러에게도 보이고 기호 테이블에도 포함됩니다. <code>pi</code>처럼 부동소수점 실수형 데이터인 경우엔 컴파일러가 뱉어낸 코드의 길이도 매크로를 썼을 때보다 짧습니다. 매크로를 썼을 땐 선행 처리기가 <code>PI</code>를 <code>3.14159265359</code>로 모조리 바꾸면서 그 데이터의 사본이 사용한 만큼 생깁니다. 하지만 <code>const</code>를 썼을 땐 아무리 많이 사용해도 사본이 생기지 않기 때문이죠. 우리가 <code>const</code>를 쓸 수 있을 땐 반드시 사용해야 하는 이유 중 하나입니다.</p>
<p>우리가 <code>#define</code>을 <code>const</code>로 교체할 때는 딱 두 가지만 조심하면 됩니다. 첫째는 상수 포인터를 쓰는 경우입니다. 상수 정의는 보통 헤더 파일에 하고 이때 포인터는 꼭 <code>const</code>로 선언합니다. 포인터의 여러 사본이 같은 대상을 가리키도록 하기 위해서 입니다. 또한 그 포인터가 가리키는 대상도 <code>const</code>로 선언합니다. 코드가 아래와 같이 되겠죠.</p>
<pre><code class="language-cpp">const double* const pi = 3.14159265359;
</code></pre>
<p>두번째 경우는 상수가 클래스 안에 정의되는 경우입니다. 어떤 상수가 클래스 안에서만 유효하도록 하고 싶을 때 이렇게 하는데, 이럴 땐 상수를 정적 멤버로 만들어야 합니다. 나중에 클래스의 인스턴스가 여러번 생겨날 때 굳이 상수의 사본이 여러개가 될 필요가 없기 때문이죠. 아래를 봅시다.</p>
<pre><code class="language-cpp">class Team {
private:
    static const int numOfMembers = 4;
    std::string names[numOfMembers];
}
</code></pre>
<p><code>numOfMembers</code>가 <code>static</code>으로 선언되어 있습니다. 정의(Definition)이 아니라 선언(Declaration)입니다. 이 둘은 분명 다릅니다. C++에선 보통 선언 이후 정의가 필요합니다. 하지만 정적 정수 타입의 상수는 예외입니다. 하지만 여러분이 정의를 필요로 하는 컴파일러를 사용하고 있다면 이야기가 달라집니다. 아래와 같이 구현 파일에서 정의를 해주어야 합니다.</p>
<pre><code class="language-cpp">const double Team::numOfMembers;
</code></pre>
<p>여기에 초기값 <code>4</code>를 적으면 안됩니다. 초기화는 이미 선언과 동시에 이루어 지고 있습니다.</p>
<p>C++에서 선언은 주로 헤더 파일에 하고 정의는 구현 파일에 합니다. 다른 파일에서 그 헤더 파일을 쉽게 가져다 쓰도록 하기 위함이죠. 근데 구현 파일에선 선언과 정의를 둘 다 할 수 있지만 헤더 파일에선 선언만 할 수 있습니다.</p>
<p>여기서 잠깐, 클래스 상수를 <code>#define</code>으로 하려는 건 아니겠죠? 사실 그 순간 클래스 상수라는 건 말이 안됩니다. 매크로는 유효범위라는 것이 따로 없습니다. 컴파일이 끝날 때까지 유효합니다. 따라서 클래스 상수를 선언할 때 <code>#define</code>를 사용할 순 없습니다. 그렇게 하면 캡슐화도 할 수가 없습니다. <code>private</code> 같은 걸 사용할 수 없단 얘기죠. 그치만 상수 멤버는 그게 가능합니다.</p>
<p>여기서 끝난 게 아닙니다. 간혹 위의 문법을 허용하지 않는 컴파일러가 있습니다. 선언 시점에 초기화를 진행하는 것 말이죠. 표준에 어긋나는 것이지만 옛날 컴파일러는 그럴 수 있습니다. 또 여건에 따라 그런 걸 사용해야하는 상황일 수도 있고요. 그럴 땐 어쩔 수 없이 정의할 때 초기값을 제공해야 합니다.</p>
<pre><code class="language-cpp">// team.hpp
class Team {
private:
    static const int numOfMembers;
    std::string names[numOfMembers];
}

// team.cpp
const int Team::numOfMembers = 4;
</code></pre>
<p>이렇게 하면 앞서 말한 문제는 해결할 수 있습니다. 근데, 다른 컴파일 에러가 우릴 기다리고 있습니다. <code>names</code>를 선언할 때 초기화되지 않은 <code>numOfMembers</code>를 쓰고 있기 때문이죠. 답이 없습니다. 어떻게 해야할까요? <code>enum</code>으로 장난을 조금 치면 됩니다.</p>
<pre><code class="language-cpp">class Team {
private:
    enum { numOfMembers = 5 };
    std::string names[numOfMembers];
}
</code></pre>
<p>간지나게 'enum hack'이라고 부르는 방법입니다. 간단하지만 C++의 특징을 살리고 우리의 목적도 달성할 수 있는 섹시한 방법입니다. <code>const</code>로 선언된 상수는 나중에 포인터를 얻을 수 있지만 <code>enum</code>은 그것도 안됩니다. 그래서 나중에 다른 사용자나 개발자가 포인터를 얻지 못하게 하거나 참조자를 쓰지 못하게 할 때에도 좋은 열쇠가 될 수 있습니다. 하나 더 남았습니다. <code>enum</code>은 쓸데없이 메모리 낭비도 하지 않습니다.</p>
<p>이제 마지막 <code>#define</code>의 오용 사례를 보겠습니다. 아래는 두개의 인자 중 큰 것을 골라 함수를 호출하는 매크로 함수입니다.</p>
<pre><code class="language-cpp">#define CALL_WITH_MAX(a, b) foo((a) &gt; (b) ? (a) : (b))
</code></pre>
<p>문제없는 코드처럼 보이죠? 과연 그럴까요? 아래 코드를 봅시다.</p>
<pre><code class="language-cpp">int a = 5;
int b = 0;

CALL_WITH_MAX(++a, b); // a가 2 증가
CALL_WITH_MAX(++a, b + 10); // a가 1 증가
</code></pre>
<p>이제 문제가 있는 게 확실해졌습니다. 끔찍합니다. 코드 작성시에 모르고 이렇게 썼다가 런타임시에 뭔가 문제가 있다는 것을 알아챈다면 더 끔찍해집니다. 매크로 함수가 함수 호출을 막아준다는 장점은 분명 가지고 있습니다. 하지만 이런 경우엔 그게 다가 아니죠. 그렇다면 어떻게 하면 이런 상황을 섹시하게 해결할 수 있을까요? 바로 템플릿과 인라인 함수를 쓰면 됩니다.</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
inline void callWithMax(const T&amp; a, const T&amp; b) {
    foo(a &gt; b ? a : b);
}
</code></pre>
<p>매크로 함수의 효율성도 유지하고 정규 함수의 동작 방식과 타입 안정성까지 취할 수 있는 방법입니다. 매크로 함수를 썼을 때 나타내는 문제가 발생할 여지도 없습니다. 더군다나 <code>callWithMax</code>는 진짜 함수기 때문에 유효 범위와 접근 규칙도 그대로 따라갑니다. 클래스안에서만 쓸 수 있는 인라인 함수도 있을 수 있다는 거죠. 매크로 함수는 그런 개념 자체가 없습니다.</p>
<p><code>const</code>, <code>enum</code>, <code>inline</code>을 적절히 활용하면 얻을 수 있는 장점들이 이렇게나 많습니다. 무턱대고 <code>#define</code>를 쓰기 전에 한번 생각해보세요.</p>
]]></content:encoded></item><item><title><![CDATA[pthread.h를 include 했는데도 undefined reference 에러가 날때]]></title><description><![CDATA[<h1 id="problem">Problem</h1>
<hr>
<p><strong>Pthread API</strong>를 이용하여 프로그래밍을 할 때, <code>pthread.h</code>를 include 했는데도 다음과 같은 오류가 나타나며 컴파일이 안되는 경우가 있다. <s>빡침…</s> <code>pthread.h</code>를 찾지 못해서 생기는 오류이다.</p>
<pre><code class="language-shell">/tmp/cctcT7AX.o: In function `main':
pthread.c:(.text+0x4e): undefined reference to `pthread_create'
pthread.c:(.text+0x5f): undefined reference</code></pre>]]></description><link>https://blog.koriel.kr/pthread-hreul-include-haessneundedo-undefined-reference-ereoga-nalddae/</link><guid isPermaLink="false">5b222c71fd23941a67e10eae</guid><category><![CDATA[Linux]]></category><category><![CDATA[GCC]]></category><category><![CDATA[C]]></category><dc:creator><![CDATA[Jinsoo Heo]]></dc:creator><pubDate>Sun, 16 Oct 2016 21:36:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1456406644174-8ddd4cd52a06?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;s=cbbeb38815936507752d594d9f856b7d" medium="image"/><content:encoded><![CDATA[<h1 id="problem">Problem</h1>
<hr>
<img src="https://images.unsplash.com/photo-1456406644174-8ddd4cd52a06?ixlib=rb-0.3.5&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&s=cbbeb38815936507752d594d9f856b7d" alt="pthread.h를 include 했는데도 undefined reference 에러가 날때"><p><strong>Pthread API</strong>를 이용하여 프로그래밍을 할 때, <code>pthread.h</code>를 include 했는데도 다음과 같은 오류가 나타나며 컴파일이 안되는 경우가 있다. <s>빡침…</s> <code>pthread.h</code>를 찾지 못해서 생기는 오류이다.</p>
<pre><code class="language-shell">/tmp/cctcT7AX.o: In function `main':
pthread.c:(.text+0x4e): undefined reference to `pthread_create'
pthread.c:(.text+0x5f): undefined reference to `pthread_join'
collect2: error: ld returned 1 exit status
</code></pre>
<br>
<h1 id="solution">Solution</h1>
<hr>
<pre><code class="language-shell">$ gcc source.c -o source -lpthread
</code></pre>
<p><code>gcc</code> 컴파일 옵션에 <code>-lpthread</code>를 추가하면 말끔히 해결된다.</p>
<blockquote>
<p>gcc의 컴파일 옵션을 잘 활용하자</p>
<p>-l 옵션은 헤더 파일을 탐색할 디렉토리를 지정해주는 옵션이다.</p>
</blockquote>
]]></content:encoded></item><item><title><![CDATA[fork() 함수를 이용하여 피보나치 수열을 출력해보자]]></title><description><![CDATA[<h1 id="introduction">Introduction</h1>
<hr>
<p>언어를 공부할 때 항상 보는 예제들이 있는데, 그 중 하나가 <strong>피보나치 수열 출력</strong> 예제이다. 로직이 간단하고 반복문을 활용하는 법을 익힐 수 있기 때문에 매번 등장하는 것 같다. 이번 포스트에선 <code>fork()</code> 함수와 <code>wait()</code> 함수에 대해 알아보고 그것들을 활용하여 간단하게 피보나치 수열 출력 예제를 풀어보겠다.</p>
<p>일단 피보나치 수열은 다음의 점화식으로 정의되는</p>]]></description><link>https://blog.koriel.kr/fork-hamsureul-iyonghayeo-pibonaci-suyeoleul-culryeoghaeboja/</link><guid isPermaLink="false">5b222c71fd23941a67e10ead</guid><category><![CDATA[C]]></category><dc:creator><![CDATA[Jinsoo Heo]]></dc:creator><pubDate>Sun, 16 Oct 2016 21:26:00 GMT</pubDate><media:content url="https://blog.koriel.kr/content/images/2017/10/FibonacciSpiral.svg" medium="image"/><content:encoded><![CDATA[<h1 id="introduction">Introduction</h1>
<hr>
<img src="https://blog.koriel.kr/content/images/2017/10/FibonacciSpiral.svg" alt="fork() 함수를 이용하여 피보나치 수열을 출력해보자"><p>언어를 공부할 때 항상 보는 예제들이 있는데, 그 중 하나가 <strong>피보나치 수열 출력</strong> 예제이다. 로직이 간단하고 반복문을 활용하는 법을 익힐 수 있기 때문에 매번 등장하는 것 같다. 이번 포스트에선 <code>fork()</code> 함수와 <code>wait()</code> 함수에 대해 알아보고 그것들을 활용하여 간단하게 피보나치 수열 출력 예제를 풀어보겠다.</p>
<p>일단 피보나치 수열은 다음의 점화식으로 정의되는 수열이다.</p>
<script type="math/tex; mode=display">{ F }_{ 0 }=0,{ F }_{ 1 }=1,{ F }_{ n+2 }={ F }_{ n+1 }+{ F }_{ n }</script>
<p>이 피보나치 수열을 출력하는 로직은 아래에 있는 코드처럼 매우 간단하다. 하지만 이번 포스트에서의 중점은 피보나치 수열에 있는 것이 아니고 <code>fork()</code> 함수에 있다. <code>fork()</code> 함수를 이용하여 <strong>자식 프로세스</strong>를 분기로 따내고 그 프로세스에서 일련의 작업을 마친 후 다시 <strong>부모 프로세스</strong>로 넘어와 새로운 작업을 시작하는 방법을 알아 볼 것이다. 먼저 <code>fork()</code> 함수에 대해 알아보자.</p>
<pre><code class="language-c">for(register int i = 1; i &lt; arg - 1; i++) {
    fib_n = fib_0 + fib_1;
    fib_0 = fib_1;
    fib_1 = fib_n;
    printf(&quot;, %lld&quot;, fib_n);
}
</code></pre>
<br>
<h1 id="fork">fork()</h1>
<hr>
<p><code>fork()</code>는 현재 실행되는 프로세스의 복사본을 생성하는 함수이다. 참고로 프로세스는 Disk Storage(i.e., HDD, SSD.)에 저장되어 있던 프로그램이 메모리에 올려지고 OS의 스케쥴에 따라 실행되는 하나의 실행 단위이다.</p>
<table>
<thead>
<tr>
<th style="text-align: center">Header</th>
<th style="text-align: left">unistd.h</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">Format</td>
<td style="text-align: left">pid_t fork(void);</td>
</tr>
<tr>
<td style="text-align: center">Return</td>
<td style="text-align: left">프로세스 생성에 실패하면 -1을,  
성공 시 부모 프로세스엔 자식 프로세스 ID, 자식 프로세스엔 0을 반환</td>
</tr>
</tbody>
</table>
<br>
<p><code>fork()</code> 함수에 대한 설명은 <a href="https://en.wikipedia.org/" title="Wikipedia">Wikipedia</a>에도 잘 나와있다. Wikipedia에 올라와있는 <code>Hello World</code> 예제를 한번 살펴보자.</p>
<pre><code class="language-c">int main(void)
{
   pid_t pid = fork();

   if (pid == -1) {
      perror(&quot;fork failed&quot;);
      exit(EXIT_FAILURE);
   } else if (pid == 0) {
      printf(&quot;Hello from the child process!\n&quot;);
      _exit(EXIT_SUCCESS);
   } else {
      int status;
      (void)waitpid(pid, &amp;status, 0);
   }
   
   return EXIT_SUCCESS;
}
</code></pre>
<br>
<p>예제를 분석해보자.</p>
<pre><code class="language-c"> pid_t pid = fork();
</code></pre>
<p><code>main()</code> 함수의 첫 구문은 <strong>fork system call</strong>을 호출하여 프로세스의 실행을 두 갈래로 나누고 있다. <code>fork()</code> 함수의 반환형은 <strong>POSIX</strong> type의 <code>pid_t</code> 구조체로 변수 <code>pid</code>에 그 값이 들어간다.</p>
<pre><code class="language-c">if (pid == -1) {
    perror(&quot;fork failed&quot;);
    exit(EXIT_FAILURE);
}
</code></pre>
<p><code>pid</code>의 값이 -1이라는 것은 프로세스 생성에 실패했다는 뜻이다. 따라서 “fork failed”라는 오류 메시지를 출력하고 <code>exit()</code> 함수로 프로세스를 중단시키고 있다.</p>
<p>fork가 제대로 이루어져 프로세스가 성공적으로 생성되면, 프로세스가 두 갈래로 나누어짐과 동시에 <code>pid</code>값을 반환받은 지점부터 <code>main()</code> 함수가 다시 실행된다. 각각의 프로세스가 서로 다른 작업을 하길 원한다면, <code>fork()</code>의 반환값으로 프로그램에 분기점들을 만들어 주면 된다. 위쪽의 표에도 나와 있듯이, 프로세스 생성에 성공하면 <code>fork()</code>는 부모 프로세스엔 자식 프로세스 ID를, 자식 프로세스엔 0을 반환하기 때문이다. 지금 설명한 내용이 보통 아래와 같이 구현된다.</p>
<pre><code class="language-c">// child process
else if (pid == 0) {
    printf(&quot;Hello from the child process!\n&quot;);
    _exit(EXIT_SUCCESS);
}

// parent process
else {
    int status;
    (void)waitpid(pid, &amp;status, 0);
}
</code></pre>
<p><code>fork()</code>가 성공적으로 호출되면 실행되고 있는 프로세스가 그대로 복사된 후, 두 개의 프로세스에서 <code>fork()</code>가 호출된 시점부터 다시 실행이 시작되기 때문에, 간단한 분기로도 부모 프로세스와 자식 프로세스의 작업을 나눌 수 있는 것이다.</p>
<p>부모 프로세스의 <code>waitpid()</code> 함수는 자식 프로세스가 종료될 때까지 기다리는 함수이다. 첫번째 인자 <code>pid</code>는 기다릴 자식 프로세스의 ID이고 두번째 인자 <code>status</code>는 기다린 자식 프로세스의 종료 상태를 받을 정수형 포인터이다. 호출이 끝나면 종료된 자식 프로세스의 ID를 반환한다.</p>
<blockquote>
<p>자식 프로세스는 주의해서 종료하자</p>
<p>자식 프로세스는 표준 C 라이브러리의 exit() 함수가 아니라 반드시 POSIX의 _exit() 함수로 종료해야 한다.</p>
</blockquote>

<br>
<h1 id="wait">wait()</h1>
<hr>
<p>Wikipedia의 예제에서 본 <code>waitpid()</code> 함수와는 다른 함수지만, 물론 그 쓰임새는 동일하다. 피보나치 수열 예제에서는 <code>wait()</code> 함수를 이용할 것이기 때문에 잠시 알아보자.</p>
<p><code>wait()</code> 함수는 부모 프로세스 안에서 쓰이며, 실행되고 있는 자식 프로세스가 종료할 때까지 기다리는 역할을 한다. 반환형은 <code>pid_t</code> 구조체로 종료된 자식 프로세스의 ID이고 <code>waitpid()</code> 함수와는 다르게 <code>pid</code> 인자가 없다. <code>waitpid()</code>에서는 기다릴 자식 프로세스의 ID를 명시적으로 알려주었지만 <code>wait()</code>에서는 암시적으로 자식 프로세스의 ID를 파악한다.</p>
<table>
<thead>
<tr>
<th style="text-align: center">Header</th>
<th style="text-align: left">wait.h</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">Format</td>
<td style="text-align: left">pid_t wait(int *status);</td>
</tr>
<tr>
<td style="text-align: center">Parameters</td>
<td style="text-align: left">int status: 종료된 자식 프로세스의 상태</td>
</tr>
<tr>
<td style="text-align: center">Return</td>
<td style="text-align: left">pid_t: 종료된 자식 프로세스의 ID</td>
</tr>
</tbody>
</table>
<br>
<h1 id="">피보나치 출력 예제</h1>
<hr>
<p>다음은 시스템 인자로부터 출력하고 싶은 피보나치 수의 개수를 입력받아 그 만큼의 피보나치 수열을 출력하는 예제이다. 설명은 코드의 주석을 참고.</p>
<h3 id="1">1. 컴파일</h3>
<hr>
<pre><code class="language-bash">$ gcc fibonacci.c -o fibonacci
</code></pre>
<br>
<h3 id="2">2. 실행</h3>
<hr>
<pre><code class="language-bash">$ ./fibonacci 5 # 최초 5개의 피보나치 수 출력
</code></pre>
<br>
<h3 id="3">3. 실행 결과</h3>
<hr>
<pre><code class="language-bash"># 실행 결과
Parent is waiting for the child to complete.
Child forked.
0, 1, 1, 2, 3
Child ended.
Ended child process id is 16393
Child process ended successfully. Status: 0
</code></pre>
]]></content:encoded></item><item><title><![CDATA[UDP, TCP 통신 예제]]></title><description><![CDATA[<h1 id="introduction">Introduction</h1>
<hr>
<p>우리는 지금도 인터넷을 사용하고 있고 그 인터넷이라는 건 끊임없는 <strong>Client</strong>와 <strong>Server</strong> 사이의 통신으로 이루어진다. 프로토콜이라는 말을 들어본 적이 있을 것이다. 대충 통신 규약이라는 말로 통하는데 쉽게 풀어 설명하면, 통신을 할 때 서로 말을 알아 들을 수 있도록 미리 정해놓은 약속이라고 할 수 있다. 예를 들어, 멀리 떨어져 있는</p>]]></description><link>https://blog.koriel.kr/udp-tcp-tongsin-yeje/</link><guid isPermaLink="false">5b222c71fd23941a67e10eac</guid><category><![CDATA[Linux]]></category><category><![CDATA[TCP]]></category><category><![CDATA[UDP]]></category><dc:creator><![CDATA[Jinsoo Heo]]></dc:creator><pubDate>Sat, 15 Oct 2016 21:03:00 GMT</pubDate><media:content url="https://blog.koriel.kr/content/images/2017/10/Tcp-udp.jpg" medium="image"/><content:encoded><![CDATA[<h1 id="introduction">Introduction</h1>
<hr>
<img src="https://blog.koriel.kr/content/images/2017/10/Tcp-udp.jpg" alt="UDP, TCP 통신 예제"><p>우리는 지금도 인터넷을 사용하고 있고 그 인터넷이라는 건 끊임없는 <strong>Client</strong>와 <strong>Server</strong> 사이의 통신으로 이루어진다. 프로토콜이라는 말을 들어본 적이 있을 것이다. 대충 통신 규약이라는 말로 통하는데 쉽게 풀어 설명하면, 통신을 할 때 서로 말을 알아 들을 수 있도록 미리 정해놓은 약속이라고 할 수 있다. 예를 들어, 멀리 떨어져 있는 두 사람이 신속한 대화를 위해서 일종의 은어나 수신호를 만든다면, 그것이 바로 <strong>프로토콜</strong>이다. 실제 네트워크에서 쓰는 프로토콜은 훨씬 복잡하고 종류도 많지만 말이다.</p>
<p>실제로 우리가 인터넷을 사용할 땐, 굉장히 여러가지의 프로토콜을 통해 서버와 통신하게 된다. 이때 우리가 보내고 받는 정보(<em>컴퓨터 네트워크에서는 패킷이라고 부른다.</em>)는 한번에 목적지로 가는 것이 아니고 여러 계층을 통과해 목적지에 도달하게 된다. 이 계층을 보통 인터넷 5계층(Five-layer Internet protocol stack)이나 OSI 7계층(Seven-layer ISO OSI reference model)이라 한다.</p>
<p><img src="https://blog.koriel.kr/content/images/2017/10/osi-seven-layer.png" alt="UDP, TCP 통신 예제"></p>
<p>이렇게 어떤 정보가 프로토콜과 계층을 통해 목적지까지 도달하는 일련의 과정을 <strong>공항 수속 과정</strong>에 비유하면 이해하기가 쉽다. 사람이 비행기를 타고 미국에 가기 위해선 다음의 과정을 꼭 거쳐야 한다.</p>
<table>
<thead>
<tr>
<th style="text-align: center">출발</th>
<th style="text-align: center">방향</th>
<th style="text-align: center">방향</th>
<th style="text-align: center">도착</th>
<th style="text-align: center">단계</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">티켓 (구입)</td>
<td style="text-align: center">↓</td>
<td style="text-align: center">↑</td>
<td style="text-align: center">티켓 (확인)</td>
<td style="text-align: center">티켓</td>
</tr>
<tr>
<td style="text-align: center">수하물 (체크인)</td>
<td style="text-align: center">↓</td>
<td style="text-align: center">↑</td>
<td style="text-align: center">수하물 (찾기)</td>
<td style="text-align: center">수하물</td>
</tr>
<tr>
<td style="text-align: center">게이트 (짐 싣기)</td>
<td style="text-align: center">↓</td>
<td style="text-align: center">↑</td>
<td style="text-align: center">게이트 (짐 내리기)</td>
<td style="text-align: center">게이트</td>
</tr>
<tr>
<td style="text-align: center">이륙</td>
<td style="text-align: center">↘</td>
<td style="text-align: center">↗</td>
<td style="text-align: center">착륙</td>
<td style="text-align: center">이착륙</td>
</tr>
<tr>
<td style="text-align: center">비행</td>
<td style="text-align: center">비행</td>
<td style="text-align: center">비행</td>
<td style="text-align: center">비행</td>
<td style="text-align: center">비행</td>
</tr>
</tbody>
</table>
<p>사람은 정보(패킷)에, 각 단계는 계층에 비유할 수 있다. 그리고 이때 각 단계의 직원들이 서로 소통하는 방식을 프로토콜이라 할 수 있다. 여기서 중요한 것은, 수하물을 담당하는 직원이 게이트에서 짐을 싣고 내리는 직원이나 비행기를 조종하는 파일럿과는 서로 소통하지 않는다는 것이다. 수하물 담당 직원은 문제가 생기면 상대 공항의 수하물 담당 직원과 이야기를 한다. 다른 단계의 직원들도 마찬가지이다. 이렇게 단계를 분리해놓고 각 단계의 역할을 명확히 함으로써 일의 진행을 원활하게 하고 승객을 안전하게 목적지까지 운송할 수 있는 것이다. 실제 컴퓨터 네트워크에서도 이런 과정을 통해 패킷을 주고 받게 된다. 그 중 우리가 살펴볼 예제의 <strong>UDP</strong>, <strong>TCP</strong>는 <strong>Transport Layer</strong>의 프로토콜이다.</p>
<p>이번 포스트에서는 UDP, TCP에 대한 자세한 설명은 생략하고 C로 Server와 Client를 직접 구현하여 귀여운 강아지 사진을 실제로 전송해보는 작업을 할 것이다.</p>
<br>
<h1 id="source">Source</h1>
<hr>
<p>예제는 <a href="https://github.com/devkoriel/socket.udp-tcp.test">Github</a>에 공유해두고 있다. 아래 명령어로 다운로드 받을 수 있다.</p>
<pre><code class="language-shell">$ git clone https://github.com/DanielHeo94/socket.udp-tcp.test.git
$ cd socket.udp-tcp.test/
</code></pre>
<blockquote>
<p>git이 설치되어 있지 않다면?</p>
<p>git이 설치되어 있지 않다면, $ sudo apt-get install git 명령어로 설치하자.</p>
</blockquote>
<br>
<h1 id="udp">UDP</h1>
<hr>
<h3 id="1serverc">1. server.c</h3>
<script src="https://gist.github.com/devkoriel/d19dc4b9c4b723ca3138bf34f9636886.js"></script>
<br>
<h3 id="2clientc">2. client.c</h3>
<script src="https://gist.github.com/devkoriel/ec865dffaecbef45ddd027758bdf3f3f.js"></script>
<blockquote>
<p>전체 소스를 다운로드 받으세요</p>
<p>전체 소스는 server.c와 client.c, <strong>그 이외</strong>의 파일로 이루어져 있습니다. 다운로드 받은 소스의 경우 따로 코딩할 부분은 없습니다.</p>
</blockquote>
<br>
<h3 id="3application">3. Application</h3>
<p>Server와 Client를 각각 다른 터미널에서 실행하여야 하기 때문에, 두 개의 터미널을 열어야 합니다.</p>
<pre><code class="language-shell"># 1번 터미널 (Server)

$ cd socket.udp-tcp.test/UDP
$ make
$ ./s 9999 # 포트 넘버
</code></pre>
<p><img src="https://blog.koriel.kr/content/images/2017/10/------2016-10-09-19-09-19.png" alt="UDP, TCP 통신 예제"></p>
<pre><code class="language-shell"># 2번 터미널 (Client)

$ ./c 127.0.0.1 9999 # localhost ip, 포트 넘버
</code></pre>
<p><img src="https://blog.koriel.kr/content/images/2017/10/------2016-10-09-19-08-31.png" alt="UDP, TCP 통신 예제"></p>
<p>디렉토리에 있던 귀여운 강아지 사진 <code>src.jpg</code>가 전송되어 <code>dst.jpg</code>가 생성된 것을 볼 수 있다.</p>
<br>
<h1 id="tcp">TCP</h1>
<hr>
<h3 id="1serverc">1. server.c</h3>
<script src="https://gist.github.com/devkoriel/5ddb92fe5aa4c362a2f1f7e5de0fc947.js"></script>
<br>
<h3 id="2clientc">2. client.c</h3>
<script src="https://gist.github.com/devkoriel/ec865dffaecbef45ddd027758bdf3f3f.js"></script>
<blockquote>
<p>전체 소스를 다운로드 받으세요</p>
<p>전체 소스는 server.c와 client.c, <strong>그 이외</strong>의 파일로 이루어져 있습니다. 다운로드 받은 소스의 경우 따로 코딩할 부분은 없습니다.</p>
</blockquote>
<br>
<h3 id="3application">3. Application</h3>
<p>Server와 Client를 각각 다른 터미널에서 실행하여야 하기 때문에, 두 개의 터미널을 열어야 합니다.</p>
<pre><code class="language-shell"># 1번 터미널 (Server)

$ cd socket.udp-tcp.test/TCP
$ make
$ ./s 9999 # 포트 넘버
</code></pre>
<p><img src="https://blog.koriel.kr/content/images/2017/10/------2016-10-09-19-11-05.png" alt="UDP, TCP 통신 예제"></p>
<pre><code class="language-shell"># 2번 터미널 (Client)

$ ./c 127.0.0.1 9999 # localhost ip, 포트 넘버
</code></pre>
<p><img src="https://blog.koriel.kr/content/images/2017/10/------2016-10-09-19-11-08.png" alt="UDP, TCP 통신 예제"></p>
<p>디렉토리에 있던 귀여운 강아지 사진 <code>src.jpg</code>가 전송되어 <code>dst.jpg</code>가 생성된 것을 볼 수 있다.</p>
<br>
<h1 id="">함수 설명</h1>
<hr>
<h3 id="asocket">a. socket()</h3>
<table>
<thead>
<tr>
<th style="text-align: center">Header</th>
<th style="text-align: left">#include &lt;sys/types.h&gt;
<br>#include &lt;sys/socket.h&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">Format</td>
<td style="text-align: left">int socket(int domain, int type, int protocol);</td>
</tr>
<tr>
<td style="text-align: center">Parameters</td>
<td style="text-align: left">int domain: 인터넷을 통해 통신할 지, 같은 시스템 내에서 프로세스 끼리 통신할 지의 여부를 설정합니다.  
int type: 데이터의 전송 형태를 지정하며 아래와 같은 값을 사용할 수 있습니다.  
int protocol: 통신에 있어 특정 프로토콜을 사용을 지정하기 위한 변수이며, 보통 0 값을 사용합니다.</td>
</tr>
<tr>
<td style="text-align: center">Return</td>
<td style="text-align: left">-1 이외: Socket Descriptor  
-1: Fail</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Socket을 생성하여 반환합니다.</p>
</blockquote>
<h3 id="bmemset">b. memset()</h3>
<table>
<thead>
<tr>
<th style="text-align: center">Header</th>
<th style="text-align: left">#include &lt;string.h&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">Format</td>
<td style="text-align: left">void *memset(void *s, int c, size_t n);</td>
</tr>
<tr>
<td style="text-align: center">Parameters</td>
<td style="text-align: left">void *ptr: 메모리의 크기를 변경할 포인터  
int c: 초기화 값  
size_t size: 초기화 길이</td>
</tr>
<tr>
<td style="text-align: center">Return</td>
<td style="text-align: left">void *: s에 대한 포인터를 반환하며 실패하면 NULL을 반환한다.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>malloc() 이나 calloc() 에서 할당 받은 메모리를 특정 값으로 초기화합니다. 보통 어떤 작업을 하기 전에 NULL로 초기화할 때 많이 사용합니다. 데이터를 읽어 들이거나 어떤 함수를 호출 후 메모리에 입력된 값을 처리하는 경우 미리 메모리를 초기화를 하는 것이 디버깅에 유리합니다.</p>
</blockquote>
<h3 id="cbind">c. bind()</h3>
<table>
<thead>
<tr>
<th style="text-align: center">Header</th>
<th style="text-align: left">#include &lt;sys/types.h&gt; 
<br>#include &lt;sys/socket.h&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">Format</td>
<td style="text-align: left">int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);</td>
</tr>
<tr>
<td style="text-align: center">Parameters</td>
<td style="text-align: left">int sockfd: 소켓 디스크립터  
struct sockaddr *myaddr: 주소 정보로 인터넷을 이용하는 AF_INET인지 시스템 내에서 통신하는 AF_UNIX에 따라서 달라집니다. 인터넷을 통해 통신하는 AF_INET인 경우에는 struct sockaddr_in을 사용합니다.  
socklen_t addrlen: myadd 구조체의 크기</td>
</tr>
<tr>
<td style="text-align: center">Return</td>
<td style="text-align: left">0: Success.  
-1: Fail.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Socket에 IP주소와 포트번호를 지정해 줍니다. 이로서 소켓을 통신에 사용할 수 있도록 준비가 됩니다.</p>
</blockquote>
<h3 id="dclose">d. close()</h3>
<table>
<thead>
<tr>
<th style="text-align: center">Header</th>
<th style="text-align: left">#include &lt;unistd.h&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">Format</td>
<td style="text-align: left">int close(int s);</td>
</tr>
<tr>
<td style="text-align: center">Parameters</td>
<td style="text-align: left">int s: Socket Descriptor</td>
</tr>
<tr>
<td style="text-align: center">Return</td>
<td style="text-align: left">0: Success.  
-1: Fail.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Socket을 닫습니다.</p>
</blockquote>
<h3 id="erecvfrom">e. recvfrom()</h3>
<table>
<thead>
<tr>
<th style="text-align: center">Header</th>
<th style="text-align: left">#include &lt;sys/types.h&gt;
<br>#include &lt;sys/socket.h&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">Format</td>
<td style="text-align: left">int recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlen);</td>
</tr>
<tr>
<td style="text-align: center">Parameters</td>
<td style="text-align: left">int s: Socket Descriptor  
void *buf: 자료 수신을 위한 버퍼 포인터  
size_t len: 버퍼의 바이트 단위 길이  
int flags: 수신을 위한 옵션  
sockaddr *to: 전송한 곳의 주소 정보  
socklen_t tolen: 전송한 곳의 주소 정보의 크기</td>
</tr>
<tr>
<td style="text-align: center">Return</td>
<td style="text-align: left">-1 이외: 실제로 수신한 바이트 수.  
-1: Fail.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>UDP/IP 통신에서 소켓으로부터 데이터를 수신합니다.</p>
</blockquote>
<h3 id="fsendto">f. sendto()</h3>
<table>
<thead>
<tr>
<th style="text-align: center">Header</th>
<th style="text-align: left">#include &lt;sys/types.h&gt;
<br>#include &lt;sys/socket.h&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">Format</td>
<td style="text-align: left">int sendto(int s, const void *msg, size_t len, int flags, const struct sockaddr *to, socklen_t tolen);</td>
</tr>
<tr>
<td style="text-align: center">Parameters</td>
<td style="text-align: left">int s: Socket Descriptor  
void *msg: 전송할 메시지  
size_t len: 버퍼의 바이트 단위 길이  
int flags: 전송을 위한 옵션  
sockaddr *to: 목적지 주소 정보  
socklen_t tolen: 목적지 주소 정보의 크기</td>
</tr>
<tr>
<td style="text-align: center">Return</td>
<td style="text-align: left">-1 이외: 실제로 전송한 바이트 수.  
-1: Fail.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>UDP/IP 통신에서 소켓으로 데이터를 전송합니다.</p>
</blockquote>
<h3 id="glisten">g. listen()</h3>
<table>
<thead>
<tr>
<th style="text-align: center">Header</th>
<th style="text-align: left">#include &lt;sys/socket.h&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">Format</td>
<td style="text-align: left">int listen(int s, int backlog);</td>
</tr>
<tr>
<td style="text-align: center">Parameters</td>
<td style="text-align: left">int s: Socket Descriptor  
int backlog: 대기 메시지 큐의 개수</td>
</tr>
<tr>
<td style="text-align: center">Return</td>
<td style="text-align: left">0: Success.  
-1: Fail.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>소켓을 통해 클라이언트의 접속 요청을 기다리도록 설정합니다.</p>
</blockquote>
<h3 id="haccept">h. accept()</h3>
<table>
<thead>
<tr>
<th style="text-align: center">Header</th>
<th style="text-align: left">#include &lt;sys/types.h&gt;
<br>#include &lt;sys/socket.h&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">Format</td>
<td style="text-align: left">int accept(int s, struct sockaddr *addr, socklen_t *addrlen);</td>
</tr>
<tr>
<td style="text-align: center">Parameters</td>
<td style="text-align: left">int s: Socket Descriptor  
struct sockaddr *addr: 클라이언트 주소 정보를 가지고 있는 포인터  
socklen_t addrlen: struct sockaddr *addr 포인터가 가르키는 구조체의 크기</td>
</tr>
<tr>
<td style="text-align: center">Return</td>
<td style="text-align: left">-1 이외: 새로운 Socket Descriptor.  
-1: Fail.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>클라이언트의 접속 요청을 받아드리고 클라이언트와 통신하는 전용 소켓을 생성합니다.</p>
</blockquote>
<h3 id="iread">i. read()</h3>
<table>
<thead>
<tr>
<th style="text-align: center">Header</th>
<th style="text-align: left">#include &lt;unistd.h&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">Format</td>
<td style="text-align: left">ssize_t read (int s, void *buf, size_t nbytes);</td>
</tr>
<tr>
<td style="text-align: center">Parameters</td>
<td style="text-align: left">int s: Socket Descriptor  
void *buf: 소켓에서 데이터를 읽어들일 버퍼  
size_t nbytes: 버퍼의 크기</td>
</tr>
<tr>
<td style="text-align: center">Return</td>
<td style="text-align: left">-1 이외: 읽어들인 바이트 수.  
-1: Fail.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>소켓의 데이터를 읽어들입니다.</p>
</blockquote>
<h3 id="jconnect">j. connect()</h3>
<table>
<thead>
<tr>
<th style="text-align: center">Header</th>
<th style="text-align: left">#include &lt;sys/types.h&gt;
<br>#include &lt;sys/socket.h&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">Format</td>
<td style="text-align: left">int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen);</td>
</tr>
<tr>
<td style="text-align: center">Parameters</td>
<td style="text-align: left">int sockfd: Socket Descriptor  
struct sockaddr *serv_addr: 서버 주소 정보에 대한 포인터  
socklen_t addrlen: struct sockaddr *serv_addr 포인터가 가르키는 구조체의 크기</td>
</tr>
<tr>
<td style="text-align: center">Return</td>
<td style="text-align: left">0: Success.  
-1: Fail.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>생성한 소켓을 통해 서버로 접속을 요청합니다.</p>
</blockquote>
<h3 id="kwrite">k. write()</h3>
<table>
<thead>
<tr>
<th style="text-align: center">Header</th>
<th style="text-align: left">#include &lt;unistd.h&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">Format</td>
<td style="text-align: left">ssize_t write (int s, const void *buf, size_t n)</td>
</tr>
<tr>
<td style="text-align: center">Parameters</td>
<td style="text-align: left">int s: Socket Descriptor  
void *buf: 소켓에 쓸 데이터를 담을 버퍼  
size_t n: 버퍼의 크기</td>
</tr>
<tr>
<td style="text-align: center">Return</td>
<td style="text-align: left">-1 이외: 쓴 데이터의 바이트 수.  
-1: Fail.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>소켓에 데이터를 씁니다.</p>
</blockquote>
]]></content:encoded></item><item><title><![CDATA[연세대학교 YSCEC 공지사항 Fetch Tool]]></title><description><![CDATA[<h1 id="introduction">Introduction</h1>
<hr>
<p>우리 학교엔 <strong>YSCEC</strong>이라는 것이 있다. 정식 명칭은 <strong>연세 지식 창조 커뮤니티</strong>인데, 그냥 온라인으로 공지사항이나 과제를 확인할 수 있는 곳이다. 나름 사용률이 높아서 대부분의 교수님들이 애용하고 계신다. 여러 유용한 정보들도 많이 올라오기 때문에 하루에 한번씩은 들어가서 확인을 해줘야 한다. <s>이게 바로 불편함의 발단…</s> 까먹고 못보고 있다가 과제 하나라도</p>]]></description><link>https://blog.koriel.kr/yeonsedaehaggyo-yscec-gongjisahang-fetch-tool/</link><guid isPermaLink="false">5b222c71fd23941a67e10eab</guid><category><![CDATA[Ubuntu]]></category><category><![CDATA[Python]]></category><dc:creator><![CDATA[Jinsoo Heo]]></dc:creator><pubDate>Thu, 13 Oct 2016 20:50:00 GMT</pubDate><media:content url="https://blog.koriel.kr/content/images/2017/10/2017-10-08.png" medium="image"/><content:encoded><![CDATA[<h1 id="introduction">Introduction</h1>
<hr>
<img src="https://blog.koriel.kr/content/images/2017/10/2017-10-08.png" alt="연세대학교 YSCEC 공지사항 Fetch Tool"><p>우리 학교엔 <strong>YSCEC</strong>이라는 것이 있다. 정식 명칭은 <strong>연세 지식 창조 커뮤니티</strong>인데, 그냥 온라인으로 공지사항이나 과제를 확인할 수 있는 곳이다. 나름 사용률이 높아서 대부분의 교수님들이 애용하고 계신다. 여러 유용한 정보들도 많이 올라오기 때문에 하루에 한번씩은 들어가서 확인을 해줘야 한다. <s>이게 바로 불편함의 발단…</s> 까먹고 못보고 있다가 과제 하나라도 놓치는 날엔, 학기 끝날 때까지 그 억울함을 지울 수 없을거야 아마…</p>
<p><strong>YSCEC</strong>이 다 좋은데 학교에서 별도로 서비스하고 있는 모바일 앱이 없다. 대부분의 학생들이 스마트폰은 항상 지니고 있기 때문에 앱이 있다면 그걸 더 많이 사용할 것 같지만, 안타깝게도 없다. 예전에 몇몇 학생이 모여 만든 _연앱_이라는 것이 있긴 있었다. 새로운 공지사항이 뜨면 서버에서 일정한 주기로 페이지를 크롤링해서 푸시 알림을 주는 기능도 있었다. 사실 이 기능 덕분에 대다수의 학생들이 이 앱을 사용했었다. 근데 서버 관리 비용을 부담할 수 없었는 지, 어느 순간부터 서비스가 제대로 되지 않았다. 때마침 얼마 가지 않아 학교에선 <strong>YSCEC</strong>을 전면 개편했다.</p>
<p>지금 듣고 있는 수업 중에 _응용 프로그래밍_이라는 수업이 있는데, Java, Android, Python, Html… 등등의 언어를 배우는 수업이다. 무려 한 학기 동안. <s>많기도 하지…</s> 이 수업이 중간고사를 보지 않고 프로젝트로 그걸 대체하는데, 배운 걸 활용해서 Android 앱을 만든다는… 뭐 대충 그런 프로젝트이다. 뭘 만들까 생각하다보니 그냥 예전에 없어진 연앱이 떠올랐다. 사실 웹 페이지를 크롤링해서 필요한 정보들만 앱에 딱딱 띄어주는 것이 그렇게 어려운 것도 아닌데다가, 그것에 비해 유용함은 극에 달하기 때문에 성적과 쓸모 있음 두 가지를 모두 얻을 수 있는 것이라 할 수 있겠다.</p>
<p>근데 지금이 시험 기간이라 나 혼자 프로젝트를 시작할 순 없고, 같이 듣는 형이랑 같이 해야 하는데, 또 코딩은 하고 싶고, 그래서 일단 내가 쓰는 리눅스에서 사용할 Tool을 <strong>Python</strong>으로 간단하게 만들었다. 아직 기능은 공지사항을 YSCEC에서 싹 긁어와서 뿌려주고 각각에 할당된 인덱스를 입력하면 그 내용과 첨부파일을 보여주는 정도이다. 기능들은 자잘하게 조금씩 업데이트할 예정.</p>
<blockquote>
<p>도움의 손길을 구합니다</p>
<p>Python wget 모듈을 사용해서 첨부파일을 한번에 다운로드 받을 수 있는 기능을 구현했는데, 이게 잘 안됩니다. 받아오는 과정에서 데이터가 깨지는 지, 파일이 열리지 않습니다. 이것에 대해서 팁을 가지고 있는 분이 계시면 댓글로 좀 달아주세요... 꼭 wget 모듈이 아니어도 됩니다.</p>
</blockquote>
<br>
<h1 id="install">Install</h1>
<hr>
<p><a href="https://www.dropbox.com/s/6vvoyajdzwp2jb9/yscec.deb?dl=0">YSCEC-Notice-Fetch-Tool</a></p>
<p>위의 파일을 다운로드 받아 해당 경로로 가서 아래 명령어로 그냥 설치하면 된다.</p>
<pre><code class="language-shell">$ sudo dpkg -i yscec.deb
$ source ~/.bashrc
</code></pre>
<br>
<p>아니면 그냥 <code>Files</code>에서 더블 클릭해서 설치해도 된다. 그렇게 설치해도 아래</p>
<pre><code class="language-shell">$ source ~/.bashrc
</code></pre>
<p>는 한번 해주자. 변경된 <code>.bashrc</code>을 시스템에 적용하는 명령어인데, 사실 이건 <code>Debian Package</code>안에 <code>postinst</code>에 포함할 수 있다. 그런데 뭐가 문젠지 패키징 과정에서 오류가 발생해서 일단은 빼놨다.</p>
<br>
<h1 id="use">Use</h1>
<hr>
<p>터미널에서</p>
<pre><code class="language-shell">$ yscec
</code></pre>
<p>만 입력하면 된다.</p>
<br>
<h1 id="video">Video</h1>
<hr>
<div style="text-align:center"><iframe width="640" height="360" src="https://www.youtube.com/embed/Ab1tMzj43Vg" frameborder="0" align="middle" allowfullscreen></iframe></div>]]></content:encoded></item></channel></rss>