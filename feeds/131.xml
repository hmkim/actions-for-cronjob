<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Sanghee Kim on Medium]]></title>
        <description><![CDATA[Stories by Sanghee Kim on Medium]]></description>
        <link>https://medium.com/@sanghee?source=rss-afbf8d48e5b5------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*nksNJdYWF0dJbAg9zfWZTA.jpeg</url>
            <title>Stories by Sanghee Kim on Medium</title>
            <link>https://medium.com/@sanghee?source=rss-afbf8d48e5b5------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Sun, 12 May 2019 20:17:05 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@sanghee" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[발사믹 비프, Balsamic beef]]></title>
            <link>https://medium.com/@sanghee/%EB%B0%9C%EC%82%AC%EB%AF%B9-%EB%B9%84%ED%94%84-balsamic-beef-cfd263044a2b?source=rss-afbf8d48e5b5------2</link>
            <guid isPermaLink="false">https://medium.com/p/cfd263044a2b</guid>
            <category><![CDATA[발사믹]]></category>
            <dc:creator><![CDATA[Sanghee Kim]]></dc:creator>
            <pubDate>Mon, 11 Dec 2017 01:12:25 GMT</pubDate>
            <atom:updated>2017-12-11T01:12:25.202Z</atom:updated>
            <content:encoded><![CDATA[<p>우리나라에 소고기 장조림이나 갈비찜, 특히 맛있는 소고기 갈비찜이 생각나는데 미국에서 딱히 그걸 먹을데가 없다는 생각이 들면 아쉬운데로 홀푸즈 Whole foods 에 가면된다. 거기에 가면 고기를 요리해서 파는데가 있는데 거기에서 발사믹 비프를 달라고 하면 된다. 그러면 17달러 정도 내고 발사믹 비프랑 채소요리 약간이랑 해서 먹으면 그럭저럭 맛있는 소고기 갈비찜을 먹을 수 있다.</p><p>사실 양념의 조합이 다를 뿐이지 들어가는 재료는 대부분 비슷하다. 기름기가 좀 있는 두꺼운 소고기에 감칠맛 있는 양념을 넣고 비교적 오랜 시간 조려내는 것이다. 그 오랜 시간이라는게 갈비찜을 좋아하는 사람이라면 “오늘 만들었다가 내일이나 모레까지 여러번 데워 먹어서 쫄아든 그 맛” 에 약간 흐물텅 해지는 감자와 당근에 바닥에 깔린 짭짤한 양념에… 거기에 흰 밥 비벼서 먹으면 다른 반찬… 이 있으면 참 좋겠다만, 없어도 뭐 꽤 맛있게 먹지 않던가? 고기에서 우러난 국물에 양념 조합이 맛이 없… 기도 하지만, 대개 맛있지 않은가…</p><p>물론 미국에서 한인마트나 이런데 가서 갈비 끊어다가 간장 양념에 갈비찜 해먹어도 되지만, 그렇게 안하고 비슷하게 먹을려면, 적당히 큰 소고기 부위, 특히 Chuck 부위, 우리로 치면 목심부터 약간의 등심까지 이어지는 그 곳을 사다가 굽다가 진한 양념 해서 오래 익혀서 먹으면 된다.</p><p>그런데 내가 위에서 말한 것들중에 몇 가지 좀 더 설명해야 하는 부분이 나오는데 가령 이러한 것들이 되겠다.</p><p>a. 적당히 큰 소고기 부위: 이건 chuck 으로 시작하는 주먹 두 세 개 합쳐진 큰 부위를 통째로 파는걸 사면 된다. 가격은 그렇게 비싸지 않게 구입할 수 있다. 어차피 양념이 강하고 오래 익히니까 살짝 냄새가 나거나 질긴 부위도 괜찮다. 오래 익힘 앞에 질긴 부위 없다. 냄새도 강한 양념 앞에 무릂을 꿇는 정도가 아니라 오히려 “은근한 고기 냄새”로 변할 수 있다.</p><p>b. 굽다가: 고기라는게 일단 겉을 지지듯 굽게 되면 마이야르니 뭐니 이런 말을 가져다 설명하지 않아도 “노릇노릇” 한 그 맛이 좋지 않던가? 다 알아서 설명할 필요 없을 정도인 그 상태인 노릇노릇보다 더 강하게 구워 갈색 빛이 날 정도까지 터프하게 두꺼운 팬 위에 지져서 구우면 된다. 이때 기름을 달걀 후라이 할 정도보다 조금 더 넣고 구워주면 안탄다. 태우려고 노력해도 안 탈 정도로 안탄다. 그러니 당황하지 말고 적당히 1분에서 2분 정도 해서 각 면들을 지져주면 된다.</p><p>c. 진한 양념: 발사믹 식초라고 해서 마냥 신 맛이 아닌 포도를 잘 어떻게 해서 만든 단 맛이 꽤 도는 너무 시지는 않은 식초가 있다. 이 식초를 살 때 하나 팁이 있는데 Balsamic vinegar 라고 써있다고 다 같은건 아니고, 그 위에 뭐가 들었나… 를 잘 보고 caramel 이 추가되어 있는 것은 딱히 살 필요가 없다. 대개 이 카라멜이라는게 그런것이다. 원래 발사믹이라는게 포도로 만들어서 자연적인 단맛이 꽤 올라오는데 이게 잘 숙성되면서 꽤 감칠맛 있는게 나오는기라… 발사믹의 그 진한 색이 그렇게 나오는거다. 그런데 이걸 이렇게 만들지 않고 적당히 숙성된 포도 식초에다가 족발 삶을때 거무튀튀한 색과 윤기와 단맛을 덮어버리는 카라멜을 꽤 많이 넣어서 발사믹 식초처럼 만드는거다. 뭐 자기 취향이라서 뭘 사든 관계는 없는데, 그래도 한 번 먹어본다면 Balsamic vinegar of Modena 라고 써있는 것을 사면 좋은데, 이게 일종의 인증과 같아서 카라멜 함량이 2% 미만이고(뒷면을 보고 카라멜이 없는 것을 사면 좋겠다만) 나머지는 와인 식초와 포도의 혼합. 여튼 이런걸 사서 넣으면 된다.</p><p>저 진한 양념에 당연히 들어가야 하는 것은, 고기 구운 곳에서 고기를 구해내고 나면 눌어붙은 그 맛… 그거 있지 않은가… 보통 고기 다 구워 먹으면 “저기요, 밥좀 볶아주세요~” 할 때 그 상태. 거기에다가 양파를 볶음밥 할 때 처럼 잘라서 넣어서 노랗게 볶아주면 된다. 그러면 “노릇노릇” 맛에다가 양파의 단 맛이 들어가서 거기에 솔직히 바로 밥 넣고 볶아주면 참 맛있는데…</p><p>여튼 이렇게 고기 기름과 양파 기반에 발사믹 1/3컵 정도 넣고, 머스타드 사서 두어스푼 넣어주고 해서 잘 비벼주다가 거기에 육수 파는거 한 팩 사서 넣어주면 된다. 두 컵… 이라고 하니까 두 컵 정도.</p><p>이렇게 하면 집 안에 정말 신 냄새가 미친듯이 진동하는데 요리라는게 그렇게 호락호락 하지 않으니 정신 차리고 환풍기 켜고 창문 다 열어놓는 것은 스테이크 굽는 것과 같다. 역시 소고기라는게 이렇게 요리하기 어렵다. 그래서 고기는 고깃집에 가서 먹는거다.</p><p>여튼 이렇게 해놓고 양념 맛을 보면 이게 나쁘지 않다. 신 맛이 나지만 어차피 이거야 나중에 다 날라갈거고, 단 맛도 나고, 포도 맛도 나고, 양파 맛도 나고… 여기에 타임이나 뭐 비슷한 허브 서너 개 정도 넣어주면 된다.</p><p>“나는 그런거 없어요.”</p><p>라고 생각하면 우리의 친구 후추가 있으니 후추나 아쉬운데로 너무 많이 뿌리지는 말고 몇 번 털어넣어준다. 물론 바로 갈아서 먹는 후추가 있으면 그것도 좋고.</p><p>“나는 후추도 없어요.”</p><p>라는 사람이 있다면, 뭐 다음번에 마트 갈 때 후추 하나 사거나 아마존 후추 하나 사면 된다. 이번에는 그냥 이대로 가도 큰 문제 없다. 고기 구울때 후추 꼭 넣어야 하는거 아니니까.</p><p>물론 타임 말린거 넣어도 된다. 안될게 없다. 다만, 아무래도 느낌이라는게 있으니까.</p><p>이렇게 해서 여기에 아까 고기 잘 구운거 넣어주고 오븐 350도(화씨) 맞춰준 곳에 넣어서 두 시간에서 세 시간 정도 기다려 주면 된다. 잘 생각해보면 두 세 시간 350도에서 견뎌줄 고기라면 아래와 같은 조건이 성립되어야 먹을 수 있다는 것을 알게 된다.</p><p>1. 담는 그릇에 뚜껑이 있고, 그릇 자체가 두꺼울수록 좋구나. 그래서 보통 주물로 된 더치 오븐 같은것, 혹은 겉에 에나멜로 코팅이 된 것을 사람들이 쓴다. 이거 꼭 “아내의 친구가 샀다는” 르쿠르제 같은거 사서 괜히 마음에 20만원짜리 혹은 그 이상의 부담을 만들지 말고, 싼거 사면 된다. 미제 롯지 괜찮다. 아니면 아이키아 ikea 가서 4만원짜리 하나 사면 된다. 뭐 르쿠르제 살 수 있으면 사면 된다. 나는 분명히 파나쏘닉이면 된다고 했는데 라이카 사오면 뭐든 잘 찍으면 되니까. 어차피 우리는 셀카 찍을껀데 뭐…</p><p>2. 국물이 꽤 있어야 한다. 그래서 저 위에 보면 육수를 두 컵 정도 넣는 것이다. 딱 생각해봐도 식초 넣은 육수에다가 고기를 천천히 익혀내는 것인데 국물이 꽤 있어야 하지 않겠는가? 고기를 오래 맛있는 국물에서 익혀내서 흐트러지기 바로 전 까지 익혀내고, 밑에 기름기와 함께 양념이 자작할 정도보다 조금 더 있는 정도로 뽑아낼 것이다. 그래서 기름은 아내 주고 보들보들한 양념은 내가 먹을 것이다.</p><p>3. 제발 오후 다섯 시 전에 요리를 시작해야 한다. 그래야 여덟 시 정도에 먹는건데, 꼭 늦게 시작하는 “내” 가 있다. 실제 몇 번 이런 요리를 늦게 시작해서 요리 하다가 라면 먹고 요리 끝내고 자정에 샤워 하고 자고 다음날 바빠서 아침은 거르고 회사 갔다가 저녁에 친구 만나서 밥 먹고 그러다보니 어느새 곰팡이 비슷하게 꼈더라.</p><p>이렇게 해서 양념이 자작 해지면 거기에 고기만 먹고 변비 걸릴 수 있으니 당근이랑 감자를 넣어주면 된다. 통째로 넣으면 왠지 모르게 나 기분이 좋아져서 감자는 알감자 같은걸 사다가 적당히 씻어서 넣어주면 되고, 당근은 벅스 버니가 먹을 법 한 줄기까지 있는걸 한 단 사다가 줄기만 잘라서 버리고 최대한 길게 넣어서 30분 정도 오븐에 더 넣어두면 된다.</p><p>그렇게 해서 적당히 당근과 감자가 익었을 때, 좋은 사람과 함께 먹으면 된다.</p><p>자! 자세한 내용은 남이 이미 만들어 놓은 요리법을 참고하도록 하자.</p><p><a href="https://www.thewickednoodle.com/chuck-roast/">https://www.thewickednoodle.com/chuck-roast/</a></p><p>덧, 술은 맥주는 에일 ale 을 권한다. 와인은 모른다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=cfd263044a2b" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[query geoPositions: [GeoPosition]!]]></title>
            <link>https://medium.com/@sanghee/graphql-query-geopositions-geoposition-4053d698cbfd?source=rss-afbf8d48e5b5------2</link>
            <guid isPermaLink="false">https://medium.com/p/4053d698cbfd</guid>
            <category><![CDATA[apollostack]]></category>
            <category><![CDATA[graphql]]></category>
            <category><![CDATA[expressjs]]></category>
            <category><![CDATA[nodejs]]></category>
            <category><![CDATA[apollo]]></category>
            <dc:creator><![CDATA[Sanghee Kim]]></dc:creator>
            <pubDate>Sun, 10 Dec 2017 17:17:39 GMT</pubDate>
            <atom:updated>2017-12-10T17:38:16.131Z</atom:updated>
            <content:encoded><![CDATA[<p>This article is originally a commit message for my friend who wants to know how to have graphql server. Please see the commit if you want.</p><p><a href="https://goo.gl/RuyiZu">schema: query geoPositions: [GeoPosition]! · sangheestyle/awacs@b281129</a></p><p>This series of commits will cover the following:</p><ul><li>GraphQL query, mutation, subscription</li><li>Simple web server based on express.js</li></ul><p>I already implemented GraphQL server at work based on Apollo, Knex, Join-monster, so my explanation can be a bit biased. ;)</p><p>—</p><p>Assume we have only two geo positions and want to get them via graphQL. What we need to have?</p><p>Stack:<br>a. graphql: graphql<br>b. apollo: apollo-server-express, graphql-tools</p><p>You can implement graphQL server with Apollo. It is quite cool ecosystem for graphQL. Of course, you can implement the server without Apollo, but it makes life easy and you get quite well organized development documents. Also, it is really well maintained project.</p><p>Please check the following:</p><p><a href="https://github.com/apollographql/apollo-server#express">https://github.com/apollographql/apollo-server#express</a><br><a href="https://dev-blog.apollodata.com">https://dev-blog.apollodata.com</a><br><a href="https://www.apollographql.com/docs/apollo-server">https://www.apollographql.com/docs/apollo-server</a></p><p>GraphQL requires schema and resolver so you might need to implement<br>them at first.</p><p>For understanding schema, please check the following:</p><p><a href="http://graphql.org/learn/schema">http://graphql.org/learn/schema</a></p><p>For example, we want to have geo position. What is that? I don’t know exactly. So, we assume latitude and longitude are required for it. How do I know?</p><p><a href="https://goo.gl/maps/Dgssc5KBvK62">https://goo.gl/maps/Dgssc5KBvK62</a></p><p>Google maps show me latitude and longitude for excellent beer shop near my house. You can see `<a href="http://twitter.com/40">@40</a>.7847102,-73.977418` in URL. That is latitude and longitude pair for geo position.</p><p>So, we can define one type for representing this pair.</p><pre>type GeoPosition {<br>  latitude: Float!<br>  longitude: Float!<br>}</pre><p>graphQL uses type system so you can define this kind of type on your schema. Our type has two fields, latitude and longitude and their type is Float. For each scalr type on graphql, please see the following document:</p><p><a href="http://graphql.org/learn/schema/#scalar-types">http://graphql.org/learn/schema/#scalar-types</a></p><p>Also, you can find ! mart after Float. What’s that? I don’t know because my brain is not enough to remember this. If you are same with me, no worries. We have a great cheat sheet for it.</p><p><a href="https://github.com/sogko/graphql-schema-language-cheat-sheet">https://github.com/sogko/graphql-schema-language-cheat-sheet</a></p><p>Thanks to the sheet, now you know that it is type modifier and now you know the difference between Float and Float! GeoPosition requires latitude and longitude so Float! should be required instead of Float. Otherwise, you will get <em>{ latitude: 40.7847102, longitude: null }</em> then you will go to coffee shop instead of beer shop. If you want to be sober, do it.</p><p>OK, we have one type now.</p><p>At the same time, we want to get all the geo positions. Assume<br>we have two geo positions in our mind and want to get em all.<br>What do we need for this in grapqhl? We need Query type.</p><pre>type Query {<br>  geoPositions: [GeoPosition]!<br>}</pre><p>Query is one of root type in graphql. What’s root type? You know<br>alreay have cheat sheet and my labtop is running out of battery<br>so please check that by yourself. Please. :)</p><p>Query root type is type for query. It means that it is quite<br>similar with HTTP GET method. You can get something with Query.<br>So, just add field for getting positions.</p><pre>geoPositions: [GeoPosition]!</pre><p>It means that with geoPositions query, you will get array of<br>GeoPosition. I didn’t tell you that those graphql types can be<br>easily mapped to JSON. So, if our server stores two geo positions,<br>we need the following graphql document:</p><pre># graphql document 1<br>query {<br>  geoPositions {<br>    latitude<br>    longitude<br>  }<br>}</pre><p>and we will get the following payload from the server as a JSON:</p><pre>{<br>  “data”: {<br>    “geoPositions”: [<br>      {<br>        “latitude”: 40.7848139,<br>        “longitude”: -73.9771623<br>      },<br>      {<br>        “latitude”: 40.7847102,<br>        “longitude”: 73.977418<br>      }<br>    ]<br>  }<br>}</pre><p>Awesome right? But, how it works? With schema and data, and … something miracle happens? Nope. You need resolvers. What’s that?</p><p>Look at the following code from this commit:</p><pre><br>const geoPositions = [<br>  { latitude: 40.7848139, longitude: -73.9771623 },<br>  { latitude: 40.7847102, longitude: 73.977418 }<br>]</pre><pre>const resolvers = {<br>  Query: {<br>    geoPositions: () =&gt; {<br>      return geoPositions;<br>    },<br>  },<br>  GeoPosition: {<br>    latitude: (pos) =&gt; pos.latitude,<br>    longitude: (pos) =&gt; pos.longitude,<br>  },<br>};<br></pre><p>You can think resolvers are functions to resolve data based on each graphql types and their fields. For example, if you use the first graphl document for retrieving array of GeoPositions:</p><p>a. schema checks graphql grammer (if failed, return error)<br>b. Query.geoPositions in resolvers tries to resolve data. You can see it returns geoPositions array which has two GeoPositions. It means that, two steps are resolved now. What? OK, here is what you need to see.</p><pre><br>query { ← 1. resolved by resolvers.Query<br>  geoPositions { ← 2. resolved by resolvers.Query.geoPositions<br>    latitude ← 3. not resolved yet<br>    longitude ← 4. not resolved yet<br>  }<br>}</pre><p>OK, we need to resolve 3 and 4 for this document. How to resolve this? For that, you need to know which type has those two fields 3, 4. In root Query schema, you see this:</p><pre>geoPositions: [GeoPosition]!</pre><p>Yes, GeoPosition. So, resolver has to know how to resolve this type and you can see the part in above resolve code.</p><p>With 1, 2, GeoPosition will have array of GeoPositions. And it will map each GeoPosition and resolve it. For example, `pos` should be GeoPosition so for latitude, you need only pos.latitude. Yes, I told you resolvers are quite similar with functions. After this, 3, 4 will be resolved.</p><pre>query { ← 1. resolved by resolvers.Query<br>  geoPositions { ← 2. resolved by resolvers.Query.geoPositions<br>    latitude ← 3. resolved by resolvers.GeoPosition.latitude<br>    longitude ← 4. resolved by resolvers.GeoPosition.longitude<br>  }<br>}</pre><p>Done! Nothing to resolve. So, now you can get what you want.</p><p>I know you need something more to understand for this, but, please visit websites which I mentioned above, then you will understand what I told you. Again, my labtop is running out of battery and I have to go home now for my wife’s cousin’s wedding.</p><p>Before go home, want to tell you how you can use graphql. Just do the following:</p><pre>$ git clone <a href="mailto:git@github.com">git@github.com</a>:sangheestyle/awacs.git<br>$ cd awacs<br>$ npm i<br>$ npm start</pre><p>Then, please go to</p><p><a href="http://localhost:3000/graphiql">http://localhost:3000/graphiql</a></p><p>Then, copy the following and paste it to left panel of graphiql:</p><pre>query {<br>  geoPositions {<br>    latitude<br>    longitude<br>  }<br>}</pre><p>Then, you will see</p><pre>{<br>  “data”: {<br>    “geoPositions”: [<br>      {<br>        “latitude”: 40.7848139,<br>        “longitude”: -73.9771623<br>      },<br>      {<br>        “latitude”: 40.7847102,<br>        “longitude”: 73.977418<br>      }<br>    ]<br>  }<br>}</pre><p>Good.</p><p>I want to give you some homeworks. It is really simple, so just do it<br>right now.</p><p>a. in graphiql, please do the follwing docs:</p><pre><br>query {<br>  geoPositions {<br>    latitude<br>  }<br>}</pre><p>How those values are resolved? Also, how about this?</p><pre><br>query {<br>  geoPositions<br>}</pre><p>What is the meaning of `must have a selection of subfields`.</p><p>See you!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4053d698cbfd" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[I am new to Hapi and your article was very helpful to me. Thanks for such a great article.]]></title>
            <link>https://medium.com/@sanghee/i-am-new-to-hapi-and-it-is-really-helpful-to-me-thanks-397ca4468a4f?source=rss-afbf8d48e5b5------2</link>
            <guid isPermaLink="false">https://medium.com/p/397ca4468a4f</guid>
            <dc:creator><![CDATA[Sanghee Kim]]></dc:creator>
            <pubDate>Sat, 02 Dec 2017 21:17:56 GMT</pubDate>
            <atom:updated>2017-12-02T21:20:21.816Z</atom:updated>
            <content:encoded><![CDATA[<p>I am new to Hapi and your article was very helpful to me. Thanks for such a great article.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=397ca4468a4f" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Congrats! We are currently trying to use Apollo for server and UI.]]></title>
            <link>https://medium.com/@sanghee/congrats-we-are-currently-trying-to-use-apollo-for-server-and-ui-e84d0a2f9210?source=rss-afbf8d48e5b5------2</link>
            <guid isPermaLink="false">https://medium.com/p/e84d0a2f9210</guid>
            <dc:creator><![CDATA[Sanghee Kim]]></dc:creator>
            <pubDate>Tue, 18 Jul 2017 21:21:20 GMT</pubDate>
            <atom:updated>2017-07-18T21:21:20.446Z</atom:updated>
            <content:encoded><![CDATA[<p>Congrats! We are currently trying to use Apollo for server and UI. I love you guys well managed documentation and this blog. Every single blog post is quite awesome. Really appreciate you guys huge contribution.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e84d0a2f9210" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Hey, I think you might need to check out to t1-start branch otherwise we will have wrong `App.css`]]></title>
            <link>https://medium.com/@sanghee/hey-i-think-you-might-need-to-check-out-to-t1-start-branch-otherwise-we-will-have-wrong-app-css-7896b383e94c?source=rss-afbf8d48e5b5------2</link>
            <guid isPermaLink="false">https://medium.com/p/7896b383e94c</guid>
            <dc:creator><![CDATA[Sanghee Kim]]></dc:creator>
            <pubDate>Fri, 02 Jun 2017 15:20:50 GMT</pubDate>
            <atom:updated>2017-06-02T15:20:50.581Z</atom:updated>
            <content:encoded><![CDATA[<p>Hey, I think you might need to check out to t1-start branch otherwise we will have wrong `App.css` file.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7896b383e94c" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[이팩티브 파이썬 아이템 22번을 다시 보다가]]></title>
            <link>https://medium.com/@sanghee/%EC%9D%B4%ED%8C%A9%ED%8B%B0%EB%B8%8C-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%95%84%EC%9D%B4%ED%85%9C-22%EB%B2%88%EC%9D%84-%EB%8B%A4%EC%8B%9C-%EB%B3%B4%EB%8B%A4%EA%B0%80-4a302cede305?source=rss-afbf8d48e5b5------2</link>
            <guid isPermaLink="false">https://medium.com/p/4a302cede305</guid>
            <category><![CDATA[python]]></category>
            <category><![CDATA[파이썬]]></category>
            <dc:creator><![CDATA[Sanghee Kim]]></dc:creator>
            <pubDate>Mon, 30 Jan 2017 05:33:27 GMT</pubDate>
            <atom:updated>2017-01-30T05:34:33.984Z</atom:updated>
            <content:encoded><![CDATA[<p>이팩티브 파이썬에 나오는 코드들은 정말 좋은 예제들이 많다. 왜 그 예제들이 좋다고 생각하냐면 아래와 같은 것들이 충족되기 때문이다.</p><ul><li>주제를 잘 나타내는 짧은 예제</li><li>현실과 너무 동떨어지지 않은 예제</li><li>쉽게 확장 가능한 시점을 제공하는 예제</li></ul><p>파이썬을 사용하다보면 딕셔너리와 튜플 혹은 리스트로 왠만한 것들을 다 할 수 있을것처럼 보인다. 거기에 모든 데이터들을 다 담아버리면 될 것 같은 그러한 자신감.</p><p>그런데 그러다보면 복잡도가 매우 높아진다. 파이썬이 ‘간결함’이 복잡도를 높일 수 있는 빌미가 된다는 생각 또한 해야한다.</p><p>브렛 슬랫킨의 아이템 22번에 나오는 예제는 정말 정말 마음에 든다. 이 예제가 마음에 드는 이유를 설명하기 전에 코드를 한 번 보면 좋을 것 같다. 아래는 내가 책에 있는 예제를 그대로 옮긴 것이다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/c573b5120cddef4e514fb6f26c92f22a/href">https://medium.com/media/c573b5120cddef4e514fb6f26c92f22a/href</a></iframe><p>일단 코드 줄 수 보다 전체적인 모양을 보면 읽기 편하다. 분명히 읽기 편하고, 딱히 어려운 것도 없다. 아이템 22에 이 코드가 나온 이유를 보다보면 처음에는 딕셔너리와 튜플, 그리고 두어개의 클래스만으로 작업하는데 점점 복잡해진다.</p><p>특히 튜플 언패킹을 사용하거나 튜플 인덱스를 사용해서 작업하는 것을 보면 처음에는 ‘나도 저렇게 하니까…’ 하다가 ‘나 역시 복잡함을 느꼈다.’ 라는 생각이 들면서 기분이 영 그래진다.</p><p>그러다가 네임드 튜플을 사용하는 순간 ‘아차!’ 하는 느낌이 든다. 사실 적지 않은 사람들이 네임드 튜플을 쓰는데, 잘 쓰는 경우는 본 적이 별로 없다. 그런데 이 예제는 잘 쓴다. 그리고 명저 플루언트 파이썬 Fluent Python 에 나오는 네임드 튜플 예보다도 나는 깔끔하게 들어온다. (물론 플루언트 파이썬에서 처음 당위성을 느꼈다만…)</p><p>더불어 나는 이 책을 관통해서 브랫 에킨스가 사용하는 아래와 같은 부분이 점점 마음에 든다.</p><pre>total, count = 0, 0</pre><p>브랫은 책 전체를 통해서 (그리고 동영상을 통해서, 사파리 북스에 동영상이 있다) 비주얼 노이즈, 그러니까 코드를 읽는데 괜히 걸리적 거려서 생각을 느리게 하는 것들을 줄이는데 최선을 다한다. 나는 저 부분도 그 중의 하나라고 생각한다.</p><p>보통 저러한 것은 아래와 같이 쓴다.</p><pre>total = 0<br>count = 0</pre><p>그런데 사실 total 과 count 와 같은 것을 셋업 하는 것은 흔한 일이고, 딱히 그걸 두 줄에 걸쳐서 쓸 일도 아니다. 이렇게 한 줄에 하는 것이 비주얼 노이즈를 매우 줄여주기도 한다. (같은 문맥이라면 같은 줄에 하는데 나을때가 있다)</p><p>여튼, 나는 이 코드들이 참 마음에 든다. 딱딱 끊어지고 커플링이 적은 코드들이라서 나눠서 써먹기도 편하고 하니까…</p><p>그나저나 요새 드는 생각이 ‘재사용의 용이성’ 보다 ‘재작업의 용이성’을 생각하면서 작업하는게 낫겠다… 하는 그런거. 사실 재사용 많이 안하는 것 같다. 그보다 일단 짜고 부분적으로 바꾸고… 하는 재작업의 용이성 같은거…</p><p>남한테 일정 부분을 추후에 맡기기도 용이하고…</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4a302cede305" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[파이썬에서 튜플과 리스트에 대한 이런저런 이야기]]></title>
            <link>https://medium.com/@sanghee/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%97%90%EC%84%9C-%ED%8A%9C%ED%94%8C%EA%B3%BC-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%EB%9F%B0%EC%A0%80%EB%9F%B0-%EC%9D%B4%EC%95%BC%EA%B8%B0-8d3b0a59a14f?source=rss-afbf8d48e5b5------2</link>
            <guid isPermaLink="false">https://medium.com/p/8d3b0a59a14f</guid>
            <dc:creator><![CDATA[Sanghee Kim]]></dc:creator>
            <pubDate>Mon, 30 Jan 2017 03:33:25 GMT</pubDate>
            <atom:updated>2017-01-30T03:33:25.573Z</atom:updated>
            <content:encoded><![CDATA[<p>파이썬에서 튜플과 리스트는 언뜻 보면 매우 흡사해서 그냥 튜플을 안쓰고 다 리스트로 써버려도 사실 큰 차이가 없다. 그렇지만 튜플과 리스트는 큰 속성의 차이가 있는데 간단하게 말하면 뮤터블이냐 임뮤터블이냐의 mutable vs immutable 차이로 볼 수 있다.</p><p><a href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences">https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences</a></p><p>뮤터블과 임뮤터블은 말 그대로 한 번 만들어 내면 그걸 수정할 수 있느냐 없느냐의 차이로 볼 수 있다. 여기서부터 생각하면 그에 따르는 펑션들도 다르겠구나… 라는 생각을 해볼 수 있다.</p><p>가령 튜플은 임뮤터블이므로 어떤 아이템이 어디에 있느냐… 를 알려주는 index 그리고 어떤 아이템이 몇 개 있냐를 알려주는 count 가 있다. 이게 모두다. 그런데 리스트는 이것들에 더해서 아이템을 추가하는 append(마지막에 추가하는), extend(다른 리스트를 연장하는), insert(원하는 위치에 넣는) 함수들과 더불어 제거하는 pop(위치를 콕 찝어 제거하는), remove(해당 값을 제거하는), clear(모두 제거하는) 같은 함수들이 있다.</p><p>리스트는 비슷한 성질의 값들을 저장하고 튜플은 각 아이템들의 값들의 속성들이 다르다. 가령 3D 위치를 알려주기 위해서 x, y, z 를 저장한다면 튜플이 나을 것이다. 왜냐하면 x, y, z 각각의 값들의 속성은 다르다. 하지만 학생의 국어 점수만 다 모은다고 치면 당연히 리스트가 나을 것이다. 가령 [100, 90, 70, 100, 80] 이렇게 하면 되니까.</p><p>예를 들어서 액셀의 한 행을 나타내는데는 무엇이 나을까? 가령 주소록… 이라면 이름, 주소, 전화번호 이렇게 열이 있고, 각 행은 김상희, 뉴욕, 123 이 될 것이다. 이러한 것이라면 튜플이 나을 것이다.</p><p>하도 이러한 일이 많다보니 시퀀스 타입인 튜플을 쓸 때 name = row[0] 이렇게 하는 것 보다 name = row.name 하는게 낫지 않겠는가… 그래서 기본적으로 파이썬에서 제공하는 컬렉션이 네임드튜플 namedtuple 이다.</p><p><a href="https://docs.python.org/3/library/collections.html#collections.namedtuple">https://docs.python.org/3/library/collections.html#collections.namedtuple</a></p><p>이렇게까지 보고 나면 대략 튜플과 리스트의 차이를 알 수 있을 것이다. 그렇다면 한 발 더 나아가서 이런 생각도 해볼 수 있다. 튜플이라는게 일단 임뮤터블이니까 메모리상에 ‘고정’ 되어 있지 않을까…. 그러면 빠르지 않을까.</p><p><a href="http://stackoverflow.com/a/3340881/568901">http://stackoverflow.com/a/3340881/568901</a></p><p>실제로 뉴플이 리스트보다 만들어질 때는 빠르다. 정말 빠르다. 그런데 그 속도가 마이크로세컨드의 차이다. 그래서 딱히 “빠르다”는 이유로 리스트보다 튜플을 선택할 이유는 없다. 전혀 없다.</p><p>정리하자면, 튜플을 사용해야 하는 이유는</p><p>1) 임뮤터블</p><p>2) 다른 한 레코드 안에서 종류의 데이터를 저장할 때</p><p>정도로 생각하고 그 외의 것들은 모두 리스트로 써도 된다. 참고로 임뮤터블이 주는 이점은 생각보다 훨씬 강하다! 물론 그런게 없다고 생각한다면 그냥 안쓰면 된다. 너무 그런걸로 부담 갖을 필요는 없다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8d3b0a59a14f" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GET request 에 body 를 넣게되면 어떻게 될까… 를 생각해보다가…]]></title>
            <link>https://medium.com/@sanghee/get-request-%EC%97%90-body-%EB%A5%BC-%EB%84%A3%EA%B2%8C%EB%90%98%EB%A9%B4-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%90%A0%EA%B9%8C-%EB%A5%BC-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EB%8B%A4%EA%B0%80-b529edca6c8b?source=rss-afbf8d48e5b5------2</link>
            <guid isPermaLink="false">https://medium.com/p/b529edca6c8b</guid>
            <dc:creator><![CDATA[Sanghee Kim]]></dc:creator>
            <pubDate>Wed, 11 Jan 2017 21:37:17 GMT</pubDate>
            <atom:updated>2017-01-11T21:37:17.127Z</atom:updated>
            <content:encoded><![CDATA[<p>웹 API 작업을 하다보면 GET request 에 body 를 받을 수 있게 하면 좋겠다… 하는 생각이 드는데 이에 대해서 말이 참 많은것 같다.</p><p><a href="http://stackoverflow.com/questions/978061/http-get-with-request-body">http://stackoverflow.com/questions/978061/http-get-with-request-body</a></p><p>HTTP 스펙을 만든 사람중에 하나인 로이 Roy Fielding 의 코멘트를 예로 든 의견(쓸 수 있지만 뭔 의미가 있냐)에 동의하는 사람이 상당히 많지만, 저 아래 보면 ES(일라스틱서치) 의 search API는 GET에 body 를 지원하는데… 라는 의견에도 약간의 동의하는 사람들이 있다. (나?) 가령 아이디 sgronblo 의 의견을 보자면…</p><p><a href="https://github.com/postmanlabs/postman-app-support/issues/131#issuecomment-21089380">https://github.com/postmanlabs/postman-app-support/issues/131#issuecomment-21089380</a></p><p>그래서 ‘ES의 방식에 나도 동감’ 하면서 해볼라고 하니까 Postman 에서 글쎄 GET에 body 를 지원하지 않는거라… 그래서 구글링 해보니까 뭐 분위기가 아래와 같다.</p><p><a href="https://github.com/postmanlabs/postman-app-support/issues/131">https://github.com/postmanlabs/postman-app-support/issues/131</a></p><p>아마 아이디 a85 는 postman 을 만든사람중에 하나가 아닐가 생각되는데 이 사람이 결론적으로는 ‘오케이, 그렇게 지원하게 할게… 그런데 node.js 네트워킹 스택이 그걸 허용하지 않네…’ (postman 은 node.js 기반) 라고 한다.</p><p>그런데 의견들을 잘 보면 특히 ES 사용자들이 ‘야야 좀 해줘라.’ 하고 +1 을 계속해서 넣어서 압박을 주고 있는 것…</p><p>음… 그래서 결론적으로 나는 어떻게 할꺼냐…</p><p>POST 로 할거다. ㅋ 왜냐하면 postman 이 지원안해서…</p><p>덧, 더불어 ES에서도 GET과 POST 모두 지원한다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b529edca6c8b" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[테스트 더블, 그리고 목]]></title>
            <link>https://medium.com/@sanghee/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8D%94%EB%B8%94-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%AA%A9-478715d900af?source=rss-afbf8d48e5b5------2</link>
            <guid isPermaLink="false">https://medium.com/p/478715d900af</guid>
            <dc:creator><![CDATA[Sanghee Kim]]></dc:creator>
            <pubDate>Sat, 31 Dec 2016 17:19:09 GMT</pubDate>
            <atom:updated>2016-12-31T17:19:09.960Z</atom:updated>
            <content:encoded><![CDATA[<p>주말에 일을 좀 하고 있는데(일이나 놀이나 뭐나 다 같으니까) 예전에 짜놓은 API에서 이제 마지막 두 개 중에 하나를 오늘 옮겨볼려고 하고 있다.</p><p>이렇게 어떠한 기능을 옮기는데 있어서 테스트를 만들어 놓고 옮기면 마음이 상당히 놓이는데(테스트를 정의하고 만들면서 정리도 되지만, 심리적인 기능이 상당히 크다) 좀 의도적으로 파이썬 목 mock 을 사용해보려고 하고 있다.</p><p><a href="https://docs.python.org/3/library/unittest.mock.html">https://docs.python.org/3/library/unittest.mock.html</a></p><p>파이썬 목은 원래 써드 파티 라이브러리였는데 3.3부터는 파이썬에 들어가 있다. 그래서 비록 나는 파이썬 2.7을 쓰고 있지만(AWS… 쫌!) 3.x 문서 기반으로 보고 있다.</p><p>테스트 관련해서 많은 용어들이 자바 영역에서 온 것은 자명한 사실 같다. 그래서 저 목 문서를 보다보면 테스트 더블 test double 이라는 말이 나오는데 이 말의 의미가 궁금해서 한 번 찾아보니 마틴 파울러의 문서로 연결된다.</p><p><a href="http://martinfowler.com/bliki/TestDouble.html">http://martinfowler.com/bliki/TestDouble.html</a></p><p>테스트 더블은 스턴트 더블 stunt double 이라고 생각하라고 마틴 파울러는 말하는데, 그 의미를 찾아보니 한국말로는 ‘대역’이 되겠다. 흔히 말하는 스턴트 맨 말이다.</p><p>그러니까 테스트를 위해서 실제와 다르게 사용하는 ‘대역’이 테스트 더블인데 마틴 파울러는 이에 대해서 이렇게 말하고 있다.</p><p>‘Test Double is a generic term for any case where you replace a production object for testing purposes.’</p><p>‘테스트 더블이라 함은 프로덕션 오브젝트를 테스트 용도로 바꾸는 모든 경우에 대한 일반적인 용어다.’ — 번역 김상희</p><p>우리가 흔히 부르는 더미 dummy, 스텁 stubs, 목 mocks 모두 이 테스트 더블의 일종인데, 목에서는 예외를 던지는 경우까지도 고려하게 된다는 것이다.</p><p>파이썬은 ‘일단 저지르고 용서받는’ 스타일의 언어다. 이를 EAFP 라고 하는데 Easier to ask for forgiveness than permission 의 약자다.</p><p><a href="https://docs.python.org/3/glossary.html#term-eafp">https://docs.python.org/3/glossary.html#term-eafp</a></p><p>이 경우 try except 를 통한 예외 처리를 장려하게 되는데 이러한 예외 처리 역시 테스트를 해줘야 한다. 이를 위해서는 목 mocks 을 사용해서 테스트 하면 상당히 편하게 할 수 있고, 실제 목 문서에도 이러한 것들이 잘 나와있다.</p><p>여튼 그렇다고…</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=478715d900af" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AWS 현재 상태 파악하기]]></title>
            <link>https://medium.com/@sanghee/aws-%ED%98%84%EC%9E%AC-%EC%83%81%ED%83%9C-%ED%8C%8C%EC%95%85%ED%95%98%EA%B8%B0-7e82e8a1a27f?source=rss-afbf8d48e5b5------2</link>
            <guid isPermaLink="false">https://medium.com/p/7e82e8a1a27f</guid>
            <category><![CDATA[aws-cloudwatch]]></category>
            <category><![CDATA[lambda]]></category>
            <category><![CDATA[cloudwatch]]></category>
            <category><![CDATA[aws-lambda]]></category>
            <category><![CDATA[aws]]></category>
            <dc:creator><![CDATA[Sanghee Kim]]></dc:creator>
            <pubDate>Wed, 28 Dec 2016 20:06:50 GMT</pubDate>
            <atom:updated>2016-12-28T22:14:19.691Z</atom:updated>
            <content:encoded><![CDATA[<p>AWS 람다로 웹 API들을 만들어서 잘 쓰고 있다. 원래 장고 기반으로 했었던 것들을 거의 다 람다의 파이썬 기반으로 바꿨다. 지금까지는 만족스럽다.</p><p>다만 한 가지 AWS 람다의 콜드 스타트 cold-start 문제가 남아있었는데, AWS 람다 펑션을 하나 만들고 그 펑션 안에서 각 API들을 9분마다 호출하게 해서 계속 warm 상태로 유지하게 했다.</p><p>그런데 이걸 만들면서 이런 생각이 들었다.</p><p>‘대체 계속 warm 상태로 유지되는지 어떻게 알지?’</p><p>그래서 각 API를 호출하는 펑션에서 각 endpoint 의 응답시간을 로깅하게 해서, 클라우드워치 CloudWatch 에서 해당 로그를 살펴보고, 메트릭을 만들어서 대쉬보드에 띄워주게 했다. 그게 아래 결과물이다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/801/1*qIb1MTRQymx1a-Z7uvC9lg.png" /></figure><p>상당히 간단하지만 내가 원하는 것(현 상태 파악하기)을 충분히 할 수 있다. search API 는 원래 오래 걸리고 (정상이다… 더 줄이려면 구현을 아예 바꿔야 하고 딱히 그럴 필요도 없다) 나머지는 1초 미만으로 걸리니 문제가 없다. (시간을 줄이면 비용도 같이 올라간다)</p><p>이렇게 해두고 특이점이 발견되면 분석해서 람다 펑션의 메모리를 늘리던가 하면 된다.</p><p>다들 이런거 하는데 나만 뒤늦게 이런거 알아서 하고 있는건지 모르겠다…</p><p>덧, 예전에 매트가 AWS 를 배우는데 시간이 좀 걸리고 어떠한 것들을 까다로운데 돌아오는 혜택 reward 가 크다고 했다. 실제 그런것 같다. cold start 문제가 해결되고 나니까 마음도 상당히 편해지고 기분도 좋다. 참고로 9분에 한 번 정도 저렇게 돌려서 warm 상태를 유지하면 한 달에 5000번 정도 수행한다. 실제 수행시간을 각 1초로 잡고 256 MB 기준으로 한 달에 200만 번 (2,000,000) 정도 수행하면 한 달에 내야하는 돈이 1.87 달러다. 2천원쯤 하는 셈이다. 람다에다가 다이나모 DB를 쓰면 스벅 커피 가장 작은 것 하나 사는 돈도 안나온다. 게다가 클라우드 워치니 뭐니 이런거는 다 무료다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7e82e8a1a27f" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>