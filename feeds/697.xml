<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Sean Soowan Lee on Medium]]></title>
        <description><![CDATA[Stories by Sean Soowan Lee on Medium]]></description>
        <link>https://medium.com/@blaswan?source=rss-e47347637ee------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*4c_GnWSzpwHG1YNGzRwc-w.jpeg</url>
            <title>Stories by Sean Soowan Lee on Medium</title>
            <link>https://medium.com/@blaswan?source=rss-e47347637ee------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 13 May 2019 23:31:09 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@blaswan" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[[채용] 세일즈부스트 개발팀 두번째 공개 채용]]></title>
            <link>https://medium.com/salesboost-people/salesboost-second-recruit-abd4d5629aa1?source=rss-e47347637ee------2</link>
            <guid isPermaLink="false">https://medium.com/p/abd4d5629aa1</guid>
            <category><![CDATA[boost-sales]]></category>
            <category><![CDATA[people]]></category>
            <dc:creator><![CDATA[Sean Soowan Lee]]></dc:creator>
            <pubDate>Mon, 11 Jun 2018 08:09:21 GMT</pubDate>
            <atom:updated>2018-07-02T08:59:24.050Z</atom:updated>
            <content:encoded><![CDATA[<p><strong>고객의 매출을 높이는 기술을 만들어가는 세일즈부스트</strong>에서 개발팀을 충원합니다. 우리가 스스로 만드는 압도적으로 좋은 환경에서 즐겁게 일할 최고의 엔지니어들을 찾습니다!</p><ul><li>회사 소개 (첫번째 공개 채용 글): <a href="https://bit.ly/2xZNLhd">https://bit.ly/2xZNLhd</a></li><li>리모트 문화 관련: <a href="https://bit.ly/2kZpOgu">https://bit.ly/2kZpOgu</a></li></ul><h3>포지션별 JD</h3><h4>리드급 프론트엔드 엔지니어</h4><p>현재 개발 중인 세일즈부스트 <strong>마케팅 솔루션의 랜딩 페이지와 대시보드 개발을 리드</strong>합니다. 그저 동작하는 결과물을 만드는 것에 만족하지 않고 올바른 설계와 깔끔한 구조에 관심이 있는 분이어야합니다. React.js Redux, Next.js, Styled component 등의 기술을 사용하고 있으며 언어는 TypeScript를 사용합니다. 스타트업 등에서 직접 프론트엔드 프로젝트를 개발하고 운영해본 경험이 있으시면 우대합니다.</p><h4>웹 최적화 엔지니어</h4><p>모바일 환경에서의 느린 <strong>웹 로딩 속도를 획기적으로 개선할 기술</strong>을 만드는 프로젝트를 진행합니다. CTO와 함께 HTML의 서브셋 명세를 설계하고, 각종 성능 최적화를 구현한 자바스크립트 라이브러리를 개발합니다. HTML5, HTTP2 등의 웹 표준 및 자바스크립트와 브라우저에 대한 깊은 이해가 있거나 탐구욕이 있는 분을 원합니다. 핵심 기술과 표준은 오픈 소스로 공개할 예정입니다.</p><h4>데이터 백엔드 엔지니어</h4><p>수많은 정형 또는 비정형 데이터로부터 유의미한 상관관계와 트렌드를 발견하는 <strong>분석 능력과 더불어 서비스 제공을 위한 서버 개발</strong>까지 가능한 분이면 좋겠습니다. 아직 정해진 것이 많이 없는 초기 프로젝트에 배치되는만큼 애자일한 개발 경험과 추진력, 실행력이 있는 분을 찾고 있습니다.</p><h3>지원 방법 및 절차</h3><p>채용 절차는 아래와 같습니다.</p><ul><li><strong>서류 검토</strong>: wewantyou@salesboost.ai 로 이력서 또는 본인을 소개하는 자료를 보내주시면 최대 1주일 내로 답변을 드립니다.</li><li><strong>1차 인터뷰</strong>: CTO와 1~2시간 정도의 대면 인터뷰를 진행합니다.</li><li><strong>2주 테스트</strong>: 역량 검증을 위해 2주간 파트 타임으로 팀에 조인해 실제 개발을 진행합니다. 면접비를 지급하고 주당 근무 시간은 협의 사항입니다.</li><li><strong>3개월 랜딩</strong>: 팀과의 핏을 알아보기 위해 최대 3개월 간 랜딩 기간을 가집니다. 3개월 이내 언제든 정직원 전환 또는 랜딩 중지가 가능합니다. 이 기간 동안의 연봉은 협의한대로 정상적으로 지급합니다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*QSuzoupRDNwxpHhB_qEg1g.jpeg" /></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=abd4d5629aa1" width="1" height="1"><hr><p><a href="https://medium.com/salesboost-people/salesboost-second-recruit-abd4d5629aa1">[채용] 세일즈부스트 개발팀 두번째 공개 채용</a> was originally published in <a href="https://medium.com/salesboost-people">Salesboost People</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[번역] Terraform을 활용한 AWS 람다 배포]]></title>
            <link>https://medium.com/salesboost-people/aws-lambda-deployment-using-terraform-31c334fb2da6?source=rss-e47347637ee------2</link>
            <guid isPermaLink="false">https://medium.com/p/31c334fb2da6</guid>
            <category><![CDATA[devops]]></category>
            <category><![CDATA[engineering]]></category>
            <category><![CDATA[terraform]]></category>
            <category><![CDATA[aws]]></category>
            <category><![CDATA[lambda]]></category>
            <dc:creator><![CDATA[Sean Soowan Lee]]></dc:creator>
            <pubDate>Sat, 17 Mar 2018 03:22:04 GMT</pubDate>
            <atom:updated>2018-07-02T09:11:54.468Z</atom:updated>
            <content:encoded><![CDATA[<blockquote>새로운 시스템을 설계하면서 메인 인프라스트럭쳐로 AWS Lambda를 사용하고 Terraform을 이용해 provision하고 있습니다. 이에 관해 블로그를 작성하려다가 좋은 글을 발견해서 번역을 해보았습니다.</blockquote><blockquote>원문: <a href="https://medium.com/build-acl/aws-lambda-deployment-with-terraform-24d36cc86533">https://medium.com/build-acl/aws-lambda-deployment-with-terraform-24d36cc86533</a></blockquote><p>최근에 Hacker News에서 나온 흥미로운 질문이 있었습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/864/1*LZHVs_rh5A0Uc7x34MI05w.png" /></figure><p>저는 다른 사람들의 경험은 어땠는지 알고 싶었습니다. ACL에는 우리가 많이 의존하는 다수의 Lambda 함수가 있으며, 우리는 이를 Terraform을 사용하여 배포합니다. 우리에겐 이러한 배포에 문제가 없었고, 그래서 저는 다른 사람들이 Lambda에 어떻게 접근했는지 궁금했습니다. 그런데 다른 사람들은 어려움을 겪고 있는 것처럼 보였습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/1*53QxdK_ZFM2LKXZnAUG5ag.png" /></figure><p>그러나 Terraform 모듈은 그것을 추상화할 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/581/1*4brx3Ju9WO4d8eZeaajFXA.png" /></figure><p>그러나 Terraform은 필요한 변경 사항만 업데이트합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/569/1*py0N8DkmLSAYSJ07qvZNnQ.png" /></figure><p>그러나 Terraform을 사용한다면 다른 인프라스트럭쳐를 개발하는 것과 같을 것입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/614/1*75TWHMe9bh3v0RJAo79NcQ.png" /></figure><p>그러나 이미 Terraform을 활용하여 여러 가지 환경을 지원할 수 있습니다.</p><p>간략하게 말하자면, 저는 왜 사람들이 그저 Terraform을 사용하지 않는지 궁금합니다. 이것이 이 글을 쓰는 이유입니다. 저는 Terraform의 능력을 최대한 활용하여 Hacker News에서 제기된 모든 우려를 극복할 수 있는 방법을 공유하고 싶습니다.</p><p>자, 시작합시다.</p><h3><strong>속지 마세요</strong></h3><p>Terraform을 사용하여 Lambda를 배포하는 데 필요한 모든 것이 아래와 같다고 생각할 수 있습니다.</p><ol><li>JavaScript 파일을 생성합니다.</li><li>해당 JavaScript 파일을 참조하는 Terraform 구성 파일을 만듭니다.</li><li>Terraform을 적용합니다.</li><li>성공했습니다!</li></ol><p>틀렸습니다.</p><p>이 네 단계는 <strong>기술적으로</strong> 람다를 배포합니다. 그러나 이러한 표준에 따라 서버에 SSH로 접속하고 여기에 소스 코드를 복사하여 붙여넣으면 “배포를 지속”할 수도 있습니다.</p><p>AWS Lambda 자원을 생성하는 것만으로는 충분하지 않습니다. 여기 더 많은 것들이 있습니다.</p><h3><strong>AWS Lambda에 관한 오해</strong></h3><p>당신이 이전에 AWS Lambda 관련 발표를 본 적이 있다면, “단순히 함수”이기 때문에 발표자가 Lambda 중심에서 필요한 세부 작업을 빠르게 얼버무렸다는 점을 알게 되었을 것입니다. 그것은 불행히도 람다와 그 근본을 이루는 아키텍처를 총체적으로 간략화합니다.<em> 단순히 코드 베이스가 작기 때문에 그 코드 베이스가 다른 코드 베이스와 같은 노력을 해야 하지 않는다는 것을 의미하지는 않습니다.</em></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*0lP6aSIQFjmSh_R0xYPHHA.png" /><figcaption>작은 폭탄 → 그러나 큰 폭발력</figcaption></figure><h3><strong>AWS Lambda 함수의 필수 구성 요소</strong></h3><p>저는 Lambda 함수를 사용하더라도 여전히 다음과 같은 것들을 필요로 한다고 주장합니다.</p><ol><li><strong>테스트 </strong>— 논리를 검증하고 회귀를 방지하려면 단위 테스트 및 통합 테스트가 필요합니다.</li><li><strong>3rd-party 패키지</strong> — 아주 기본적인 것을 구축하는 것이 아닌 한, 도움이 되는 3rd-party 라이브러리가 필요할 수 있습니다. 예를 들어 내부적으로 CIDR 블록을 파싱하는 Lambda 함수가 있습니다. CIDR 블록을 파싱하는 로직을 직접 작성해야 합니까? 아니면 <a href="http://adilapapaya.com/docs/ipaddr.js/">ipaddress.js</a>를 사용해야 합니까?</li><li><strong>모듈 번들러</strong> — 이제 테스트 및 런타임을 위한 3rd-party 패키지가 있으므로 프로덕션을 위해 코드베이스를 패키지화하기 위한 도움이 필요합니다. Node.js에서는 Gulp 또는 Webpack과 같은 모듈 번들러가 필요합니다.</li><li><strong>AWS 리소스 지원</strong> — Lambda 함수가 독립적으로 작동하는 일은 드뭅니다. 최소한 IAM 역할 및 IAM 정책이 필요합니다. 종종 KMS, CloudWatch Logs 등과 같은 지원 리소스가 필요할 것입니다.</li><li><strong>다중 환경</strong> — 프로덕션에 배포하기 전에 통합 및 스테이징에서 코드를 검증할 수 있습니다. 또한, 신속한 개발 및 테스트를 수행할 수 있는 충분한 로컬 개발 환경이 필요합니다.</li><li><strong>모니터링</strong> — Lambda 함수가 실패하거나 실행 시간을 초과하였는지 상태를 모니터링할 수 있습니다.</li></ol><p>Lambda를 프로덕션에 적용하기 전에 이러한 모든 문제에 대한 메커니즘을 가지고 있어야 합니다. 다행히도 이 부분에서 Terraform이 강점이 있습니다.</p><p>이제 각 지점을 분해하고 Terraform을 사용하여 어떻게 그들을 다룰 수 있는지 보겠습니다.</p><h3><strong>개발 및 테스트</strong></h3><p><em>당신의 람다 함수가 테스트와 개발이 쉬운지 확인하십시오.</em></p><p>개발 환경과 테스트 환경을 갖추는 것이 Terraform과 엄격하게 관련되어 있지는 않지만 어쨌든 이점을 언급할 필요가 있습니다. 왜일까요? 이들 두 환경이 개발자들이 배포하기 전에 그들의 코드를 신뢰하는 중심이기 때문입니다. 코드가 제대로 작동하는지 확신할 수 없다면 코드를 아직 배포하지 말아야 합니다! 신속하고 익숙한 개발 경험을 위해서는 이 두 가지 환경이 필요합니다.</p><p>내부적으로 우리는 이벤트와 관련된 보안을 위해 CloudTrail을 모니터링하는 Node.js 람다 함수를 사용합니다. 작은 코드 베이스에도 불구하고, 이 람다 함수는 39개의 테스트가 있고 JS linter를 통해 신속하고 고품질의 개발을 보장합니다. 이 람다 함수는 테스트 (Gulp, Mocha, Chai, Sinon) 및 런타임 (Lodash, ipaddrs.js) 에 널리 사용되는 3rd-party Node.js 패키지를 사용합니다. 이것이 람다의 친숙하지 않은 프로덕션 환경에도 불구하고 이미 친숙한 Node.js 개발 및 테스트의 경험을 유지할 방법입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/434/1*BZ62OsAu8--u_dwvCLQfTg.png" /><figcaption>폴더 구조는 (주로) 전통적인 Node.js 응용 프로그램과 유사합니다.</figcaption></figure><p>이러한 결정들의 기반이 되는 핵심 철학은 우리의 애플리케이션 아키텍처를 AWS Lambda로 제한하지 않는 것입니다.</p><blockquote><em>AWS Lambda는 당신의 애플리케이션에 유일한 시작점으로 보여야 합니다. 애플리케이션 로직은 AWS Lambda와는 구별되어야 하고 별도로 유지되어야 합니다.</em></blockquote><p>이러한 원칙은 필요할 경우에 AWS Lambda를 떠날 수도 있는 유연성을 제공합니다. 또한, 우리가 개발한 어떤 다른 응용 프로그램과 마찬가지로 Lambda 함수를 고려할 수 있게 합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/840/1*qBAyLdZkfPb_UfOYPwEvog.png" /><figcaption>람다는 우리 애플리케이션의 시작점일 뿐입니다.</figcaption></figure><p>위의 예시에서, 우리는 Lambda를 우리가 만든 객체를 즉시 호출하게 하고 우리 도메인을 대표하게 하는 것만으로 애플리케이션에서 추출하였습니다. 이 추출을 통해, 우리는 이제 다른 Node.js 응용 프로그램과 마찬가지로 Monitor 클래스에서 시작하여 응용 프로그램을 테스트할 수 있습니다.</p><p>이것이 우리가 개발 경험을 쾌적하게 유지하는 방법과 AWS Lambda에 고착되지 않도록 하는 방법입니다. 필요하다면 Express.js를 로직 앞에 두고 AWS의 EC2 Container Service (ECS) 와 같은 것을 사용하여 Docker container에서 실행할 수 있습니다.</p><h3><strong>AWS 리소스</strong></h3><p><em>람다 함수가 필요로 하는 모든 것을 쉽게 생성할 수 있는지 확인하십시오.</em></p><p>람다 함수를 배포하기 위해 장려되는 AWS의 메커니즘은 CloudFormation과 함께 그들의 SAM (Serverless Application Model) 사양을 사용하기 위한 것입니다. AWS SAM의 핵심은 다음과 같은 사양입니다.</p><blockquote><em>… 서버리스 응용 프로그램에 대한 함수, API, 매핑 및 DynamoDB 테이블을 표현하는 방법을 단순화하는 AWS 자원 유형을 지원합니다.</em></blockquote><p>그런데, 서버리스 애플리케이션은 종종 그러한 AWS 리소스 유형보다 훨씬 더 많은 것을 요구하므로, API 게이트웨이, DynamoDB 테이블 또는 람다 함수 자체만이 아닌 람다 함수가 필요로 하는 모든 것을 관리하고 배포하는 방법을 고려하는 것이 중요합니다.</p><h4><strong>SAM에서 지원</strong></h4><p><em>AWS Lambda, DynamoDB, API Gateway</em></p><h4><strong>SAM에서 비지원</strong></h4><p><em>IAM Role, IAM Policy, ACM Certificate for HTTPS API Gateway, Cloudwatch Events Scheduler, KMS, Route 53 records for CNAME 등.</em></p><p>실제로, 우리의 CloudTrail 보안 서비스 람다 함수에는 CloudTrail 트레일, CloudTrail 암호화 용 KMS 키, CloudTrail 용 S3 버킷, CloudWatch 로그 그룹 및 CloudWatch 로그와의 Lambda 통합이 필요합니다.</p><p>이러한 시나리오에서는 람다 함수 자체보다는 인프라스트럭처 전체를 관리하는 방법을 고려하는 것이 더 중요합니다. 다행히 Terraform은 이 부분에서 뛰어나고 필요한 모든 것을 즉시 제공합니다. 당신이 CloudFormation을 이미 사용하고 있다면 SAM이 잘 맞는 조합일 수 있습니다. 그러나 이미 Terraform을 사용 중이거나 Terraform쪽에 기울었다면 SAM에 흔들리지 않을 것입니다. 사용 초기부터 Terraform을 간단히 사용할 수 있으며 그것이 모든 Lambda의 요구사항을 충족시킬 만큼 유연하다는 것을 알 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/942/1*zJ-7H7Cgio4IgcLKEfOSpw.png" /><figcaption>Terraform 자체에서 내가 직접 람다 함수에 필요한 IAM 역할을 쉽게 참조하는 방법을 보여주는 샘플 Terraform 코드.</figcaption></figure><h3><strong>다중 환경</strong></h3><p><em>여전히 당신의 람다 함수에 대해 분리된 환경이 필요합니다.</em></p><p>하나의 계정 내에서, 여러 환경에 대해 람다 함수를 분리하라는 AWS의 권장 사항은 ACL의 권장 사항이 아님을 알려드립니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/780/1*XFGKrLRwm2MJDNi40SzFHA.png" /><figcaption>왜 아마존의 나쁜 사례를 추천하려고 합니까?</figcaption></figure><p>실제로, AWS 계정으로 “논리적인 계정 분리”을 하는 것이 가장 좋은 방법입니다. 달리 말하자면, 당신의 환경에 맞는 별도의 AWS 계정이 있어야 합니다. 자세한 내용은 <a href="https://www.thoughtworks.com/insights/blog/using-aws-security-first-class-citizen">이곳</a>을 참조하십시오. 따라서 그것은 람다 함수를 단일 계정이 아닌 그러한 해당 계정들에 배포해야 함을 의미합니다. 여기 다시 Terraform이 해결사로 나섭니다.</p><p>Terraform은 “<a href="https://www.terraform.io/docs/state/workspaces.html">workspaces</a>” (이전에는 “<a href="https://www.terraform.io/docs/state/environments.html">environments</a>”라고 했음) 의 개념을 지원합니다. 이를 통해 당신의 Terraform이 작동할 AWS 계정을 쉽게 변경할 수 있도록 합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*73qDFOpWzlgKPbJrdTS2vQ.png" /></figure><p>이 기능을 사용하면, 프로덕션에 적용하기 전에 람다 함수(필요한 모든 AWS 리소스 포함)을 통합 및 스테이징 계정에 쉽게 배포할 수 있습니다. 이로써 당신의 코드를 배포하는 데 훨씬 안전한 방법을 제공합니다. 또한, 인프라스트럭처가 가져야 할 작업 흐름에 훨씬 가깝습니다.</p><h3><strong>암호화</strong></h3><p><em>간단한 슬랙봇조차도 보안을 유지해야 하는 민감한 토큰을 가집니다.</em></p><p>Lambda는 암호화된 환경 변수를 지원합니다. 하지만 … 그것은 별로 의미가 없습니다. 다시 말해 보겠습니다. Lambda는 암호화 휴식 상태의 환경 변수를 즉시 사용할 수 있도록 지원합니다. 그것은 런타임에 환경 변수를 복호화하지 않습니다. 스스로 해야 합니다. 우리의 람다 함수에 암호가 있다면 무엇을 할 수 있을까요? 음, 여기 두 가지 옵션이 있습니다.</p><ol><li><strong>KMS 암호화/복호화</strong> — KMS를 사용하여 CipherBlobs로 암호화하고 이를 환경 변수로 전달하거나 코드 베이스에 파일로 저장할 수 있습니다. 그리고 런타임에 AWS SDK를 사용하여 이들을 복호화할 수 있습니다.</li><li><strong>매개 변수 저장소</strong> — EC2 SSM의 매개 변수 저장소에 암호를 저장하고 AWS SDK를 사용하여 런타임에 이들을 불러올 수 있습니다.</li></ol><p>요즘에 저는, 이 둘 중에 더 단순한 옵션인 매개 변수 저장소를 살펴보는 것을 추천하게 됩니다. AWS의 콘솔 UI를 사용하여 쉽게 암호를 추가할 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*o7_0sLz4eoBft4rfmQ_bRQ.png" /></figure><p>그런 다음 AWS SDK를 사용하여 쉽게 암호를 불러올 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/816/1*S-HBt0tcc_w4HLwequJGaw.png" /></figure><p>여기서, Terraform은 필수적인 KMS 구성이 요구될 경우 도움을 줄 수 있습니다. 예를 들어 사용자 정의 키를 만들려면 Terraform 안에서 정의할 수 있습니다. 만약에 매개 변수를 미리 가져와서 환경 변수를 통해 전달하려고 하면, 이 역시 쉽습니다. Terraform은 당신에게 유연성을 제공합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/359/1*WCzITwJ1GBjPahHF9AVV0g.png" /><figcaption>Terraform은 매개 변수 저장소의 구성을 쉽게 가져올 수 있습니다.</figcaption></figure><p>안타깝게도, 암호들은 람다에 대한 자체적인 문제들을 가져옵니다. 복호화 호출에는 150–200ms의 오버헤드가 있습니다. (적어도 저의 벤치마크에서는 그렇습니다)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/858/1*ceUV9AQEqVwXd64M4Ca2rA.png" /></figure><p>그렇다면 각각의 호출에 암호가 필요한 경우, 어떻게 우리의 람다 함수를 빠르게 유지할 수 있을까요? 이를 위해서는 AWS Lambda의 이면을 들여다봐야 합니다.</p><h3><strong>AWS Lambda의 이면</strong></h3><p><em>놀랍게도, 그것은 컨테이너의 풀입니다!</em></p><p>당신이 Lambda의 사용을 고려했다면, AWS Lambda 이 어떻게 작동하는지 알고 싶었을 것입니다. Lambda는 컨테이너 내에서 함수를 실행함으로써 작동합니다. 이것이 람다가 빠르게 돌고 보다 넓게 확장할 수 있는 비결입니다.</p><p>첫 번째 호출에서 Lambda는 애플리케이션 코드가 포함된 컨테이너를 돌리고 핸들러 함수(일명 <em>콜드</em> 호출)를 호출합니다. 그러나 두 번째 호출 (짧은 시간 내에 발생하는 경우)에서는 같은 컨테이너가 다시 사용됩니다. (예 : <em>웜</em> 호출) 그것이 재사용될 때, 코드 베이스와 전역 변수 또한 재사용됩니다. 이러한 재사용성은 설정 로직을 단지 한 번만 수행하여 코드 실행을 최적화할 수 있는 옵션을 제공합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/174/1*bfx4GmD-NVxxEXMz44qTtA.png" /><figcaption>우리 Lambda 함수의 첫 번째 호출은 ~1800ms, 두 번째 호출은 ~9ms, 세 번째 및 그 이후의 호출은 1ms도 안 걸립니다.</figcaption></figure><p>호출간에 전역 변수를 재사용 할 수 있다는 것을 알면, 우리는 우리의 암호를 한번 해독할 수 있고 이후의 호출에서 재사용 할 수 있도록 전역 변수에 저장할 수 있음을 의미합니다. 이를 통해 최대 150ms의 복호화 시간을 절약할 수 있습니다. 또한 패키지를 로드하는 데 필요한 “부팅 시간”과 런타임을 극복하는 데 도움이 됩니다.</p><p>이제, 예시의 맥락에서 중요한 세부 사항을 설명해 보겠습니다. AWS Lambda를 사용하여 Slack 명령을 작성한 경우 3초 이내에 응답해야 함을 알게 됩니다. 그렇지 않으면 Slack이 이를 시간 초과 이벤트로 취급합니다. 우리의 경우, 드물게 회사 전반에 걸친 Slack 명령을 사용하여 처음으로 호출하는 데 2–3초가 걸리면 많은 직원이 시간 초과 이벤트를 받을 위험이 있습니다. 그렇다면첫번째 호출을 빠르게 하기 위해서는 무엇을 할 수 있을까요?</p><p>다시 한번, Terraform이 구조대로 다가옵니다.</p><h3><strong>람다 “워머”</strong></h3><p>람다를 따뜻한 상태로 유지하려면 지속적으로 호출해야 합니다. AWS에서 사용할 수 있는 간단한 트릭은 CloudWatch 의 이벤트 스케줄러를 사용하여 매분마다 람다 함수를 호출하여 따뜻한 상태로 유지하는 것입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*gB6u_5jaZn0YVtk3P2aeYA.png" /><figcaption>이 스니펫은 Terraform이 우리의 람다 함수를 타겟으로 (`aws_cloudwatch_event_target`) CloudWatch 이벤트 스케줄러에 의해 람다 함수가 호출되도록 허용하는 (`aws_lambda_permission`) CloudWatch 이벤트 스케줄러 (`aws_cloudwatch_event_rule`) 를 생성하는 것을 보여줍니다.</figcaption></figure><p>Terraform (또는 CloudFormation)이 없이는 이러한 옵션을 가질 수 없습니다.</p><h3>모니터링</h3><p><em>잘 동작합니까?</em></p><p>마지막으로, 어떤 방법으로 람다 함수의 상태를 모니터링하고 유지할 수 있을까요? 람다만의 고유한 옵션은 없지만 몇 가지 옵션을 사용할 수 있습니다. 다행히도 이러한 옵션 중 일부는 Terraform을 사용하여 구현하기 쉽습니다.</p><h4><strong>CloudWatch 메트릭스</strong></h4><p>Terraform을 사용하면, 람다 실패 호출 또는 시간 초과를 모니터링하고 모니터링 할 SNS 이벤트를 트리거하도록 하는 CloudWatch 메트릭스를 만들 수 있습니다. 이 전략은 람다 배포와 함께 단순히 더 많은 Terraform 코드를 생성하는 이점이 있습니다.</p><h4><strong>로깅</strong></h4><p>좀 더 인간 친화적인 방법으로 람다 로그를 읽으려면, <a href="https://github.com/jorgebastida/awslogs">awslogs</a>라는 툴을 사용할 수 있습니다. 이것으로 CloudWatch Logs를 사용하는 UX를 확연하게 개선하고, 커맨드 라인에서 직접 사용하게 하는 부가적인 이점도 있습니다.</p><p>그러나 <em>awslogs</em> 에는 한계가 있습니다. 당신이 더욱 사용자 친화적인 툴을 원한다면, AWS ElasticSearch 클러스터를 만들고 CloudWatch Logs를 연결하여 처리할 수 ​​있습니다. 그런 다음 Kibana 인터페이스를 사용하여 로그를 빠르게 확인하고 기본적인 로그 분석을 수행할 수도 있습니다.</p><h4><strong>에러 처리</strong></h4><p>당신은 예외 관리를 위해 New Relic, Airbrake, Rollbar 등과 같은 써드 파티 툴을 계속 사용할 수 있습니다. 이 경우 다른 응용 프로그램과 마찬가지로 각 타사 패키지를 포함하고 이를 사용하도록 람다 함수를 구성하면 됩니다. 대안으로, 단순히 로그와 메트릭스 모니터링을 활용할 수도 있습니다.</p><h4><strong>성능 모니터링</strong></h4><p>Datadog 또는 New Relic 사용자인 경우 람다 함수의 성능을 모니터링하는 것이 아주 다르지는 않을 것입니다. 단지 한 번만 설정하면 됩니다. 그리고는? Terraform 자체를 통해 <a href="https://www.terraform.io/docs/providers/datadog/index.html">Datadog</a> 및 <a href="https://www.terraform.io/docs/providers/newrelic/index.html">New Relic</a> 모니터링을 설정할 수도 있습니다.</p><h3><strong>결론</strong></h3><p>당신은 이제 Terraform을 사용하는 다른 모든 코드 베이스에 적용할 때와 같이, 람다 함수를 프로덕션에 배포하는 데 필요한 전체적인 그림을 가지고 있습니다.</p><p>제가 Terraform이 이미 람다 함수를 배포하는 데 필요한 모든 것을 갖추고 있으며, 다른 AWS 리소스와 고도로 통합된 기능을 구현할 수 있는 훌륭한 선택임을 보여 드렸기를 바랍니다. Terraform을 이미 사용하고있는 경우, 람다 기능을 배포하기 위해 별도의 프레임워크를 찾을 필요가 없습니다. 우리는 ACL에서 전체 인프라스트럭쳐를 Terraform에서 표준화 했습니다. 그래서 이것은 우리에게 자연스러운 단계였습니다.</p><p>이 자세한 포스팅을 통해 Lambda의 효과적인 배포를 위한 완벽하고 실용적인 접근법을 보여드렸기를 바랍니다. 개인적으로 AWS Lambda의 전체 개발 경험에서 사고방식의 리더십을 찾기가 쉽지 않음을 알았습니다. 사람들은 많은 세부 사항을 개별적으로 알아내고 있습니다. 바라건대 이 포스팅이 당신이 그 하위 작업의 일부를 스스로 하는 것을 방지하고, 그로 인해 생산성에 도움이 되었으면 합니다.</p><p>당신 자신의 경험이나 대안적인 기술도 저와 공유해 주시기 바랍니다. 진정 그것들을 알고 싶습니다!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=31c334fb2da6" width="1" height="1"><hr><p><a href="https://medium.com/salesboost-people/aws-lambda-deployment-using-terraform-31c334fb2da6">[번역] Terraform을 활용한 AWS 람다 배포</a> was originally published in <a href="https://medium.com/salesboost-people">Salesboost People</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Terraform의 Workspace를 이용해 배포 환경 분리하기]]></title>
            <link>https://medium.com/salesboost-people/terraform-workspaces-for-deployment-environments-2deff99356f6?source=rss-e47347637ee------2</link>
            <guid isPermaLink="false">https://medium.com/p/2deff99356f6</guid>
            <category><![CDATA[terraform-workspace]]></category>
            <category><![CDATA[engineering]]></category>
            <category><![CDATA[terraform]]></category>
            <category><![CDATA[테라폼]]></category>
            <dc:creator><![CDATA[Sean Soowan Lee]]></dc:creator>
            <pubDate>Sun, 11 Feb 2018 06:39:53 GMT</pubDate>
            <atom:updated>2018-07-02T09:11:38.008Z</atom:updated>
            <content:encoded><![CDATA[<p>최근 새로운 시스템을 구축하면서 Terraform을 도입해서 <a href="https://en.wikipedia.org/wiki/Infrastructure_as_Code">인프라스트럭처를 코드로 관리</a>하고 있다. 이 글에서는 Terraform의 Workspace를 사용해서 서로 다른 배포 환경(dev, test, staging, prod 등)의 인프라를 관리하는 방법을 설명하겠다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/350/1*-RjeiRI2wAxXzwUUrkHqaQ.png" /></figure><h3>프로젝트를 분리</h3><p>Terraform으로 서로 다른 배포 환경의 인프라스트럭처를 관리하는 가장 단순한 방법은 코드베이스를 환경별로 분리하는 것이다.</p><pre>terraforming-dev/<br>└── aws<br>    ├── api-gateway.tf<br>    ├── lambda.tf<br>    └── ...</pre><pre>terraforming-prod/<br>└── aws<br>    ├── api-gateway.tf<br>    ├── lambda.tf<br>    └── ...</pre><p>서로 다른 프로젝트이기 때문에 credentials, backend 등의 config 를 포함해 모든 리소스를 완벽하게 격리할 수 있지만, (누구나 예상하듯이) 거의 동일한 코드를 복사-붙여넣기 해야해서 코딩하기 귀찮고 중복 코드가 늘어나 유지보수가 어렵기 때문에 좋은 방법은 아니다.</p><h3>같은 프로젝트에서 디렉토리로 분리</h3><p>하나의 프로젝트 안에서 (기본적인 config들은 공유하고) 환경별로 디렉토리를 구분하는 방법도 생각해볼 수 있다.</p><pre>terraforming/<br>└── aws<br>    ├── env<br>    │   ├── dev<br>    │   ├── prod<br>    │   │   ├── instance.tf<br>    │   │   └── security_group.tf<br>    │   ├── staging<br>    │   └── testing<br>    └── modules<br>        └── module_name<br>            ├── main.tf<br>            ├── output.tf<br>            └── variables.tf</pre><pre>ref) <a href="https://medium.com/@jyotirbhandari/overview-of-terraform-in-10-mins-9780d55bf6a3">https://medium.com/@jyotirbhandari/overview-of-terraform-in-10-mins-9780d55bf6a3</a></pre><p>하나의 프로젝트이기 때문에 config 설정을 공유한다(물론, 원한다면 분리하는 것도 가능함). 또 공통 코드가 있다면 별도 디렉토리(위에서는 modules)에 모듈로 만들어서 유지보수를 좀 더 쉽게 할 수도 있다.</p><p>그러나 여전히 코드를 어느 정도 복사-붙여넣기 해야하는 건 마찬가지이다. 환경별 인프라 구성 차이가 크다면 괜찮은 방법이지만, 보통은 환경별 인프라가 거의 유사하기 때문에 중복 코드가 많이 생긴다.</p><h3>Terraform Workspace를 사용하여 분리</h3><p>Terraform에서는 이런 요구 사항을 반영해 <a href="https://github.com/hashicorp/terraform/blob/master/CHANGELOG.md#090-march-15-2017">0.9.0 버전에 Environment 라는 기능을 출시</a>했고, <a href="https://github.com/hashicorp/terraform/blob/master/CHANGELOG.md#0100-august-2-2017">0.10.0 버전부터는 Workspace로 이름을 변경</a>했다.</p><p>Workspace는 Terraform state를 담는 그릇이라고 생각할 수 있다(<a href="https://www.terraform.io/docs/state/workspaces.html">자세한 설명은 링크 참고</a>). 위 경우처럼 (작은 차이점만 있는) 거의 동일한 코드를 관리할 때 유용하다.</p><p>우리는 이제 코드베이스를 하나만 관리하면 된다.</p><pre>terraforming/<br>└── aws<br>    ├── api-gateway.tf<br>    ├── lambda.tf<br>    └── ...</pre><p>개발 환경에 따라 Workspace를 만들고, 선택해 배포한다.</p><pre># Create a new workspace<br>$ terraform workspace new prod</pre><pre># Select a workspace (already created)<br>$ terraform workspace select prod</pre><pre># Plan or Apply<br>$ terraform plan<br>$ terraform apply</pre><p>개발 환경 사이에 설정이 달라지는 부분은 Interpolation을 이용한다.</p><pre>resource &quot;aws_route53_zone&quot; &quot;primary&quot; {<br>  name = &quot;${terraform.workspace == &quot;prod&quot; ? &quot;salesbooster.io&quot; : &quot;dev.salesbooster.io&quot;}&quot;<br>}</pre><p>Map 타입의 Variable을 이용하면 더 깔끔하게 변수들을 관리할 수 있다.</p><pre>variable &quot;root_domain_name&quot; {<br>  type = &quot;map&quot;<br>  default = {<br>    &quot;prod&quot; = &quot;salesbooster.io&quot;<br>    &quot;dev&quot; = &quot;dev.salesbooster.io&quot;<br>  }<br>}</pre><pre>resource &quot;aws_route53_zone&quot; &quot;primary&quot; {<br>  name = &quot;${var.root_domain_name[terraform.workspace]}&quot;<br>}</pre><p>만약 특정 개발 환경에서 리소스를 아예 배포하고 싶지 않으면 count 변수에 0을 넘긴다.</p><pre>resource &quot;aws_route53_record&quot; &quot;example&quot; {<br>  count = &quot;${terraform.workspace == &quot;prod&quot; ? 1 : 0}&quot;<br>}</pre><p>이 방법은 유지 보수가 쉽고 더 편리하기 때문에 거의 유사한 인프라를 서로 다른 환경으로 배포할 때 유용하게 사용할 수 있다.</p><h3>Troubleshooting</h3><p>만약 우리의 경우처럼 환경마다 서로 다른 AWS 계정을 사용하고 있다면 아래의 두 가지 문제를 겪을 것이다.</p><h4>Workspace별로 다른 Backend 사용하기</h4><p>Terraform의 구현상 여러 Workspace는 하나의 Backend 안에서 구성된다. 만약 Workspace 별로 Backend 설정도 분리하고 싶다면 지금 현재로는 설정이 쉽지 않다. (<a href="https://github.com/hashicorp/terraform/issues/16627">관련 이슈 참고</a>)</p><p>우리의 경우, Workspace별로 서로 다른 AWS 계정에 있는 S3를 Backend로 사용해보려 했으나 몇 가지 편법 외에는 방법이 없었다. 그래서 dev용 AWS 계정에 있는 S3를 모든 Workspace가 공유하는 형태로 구성했다.</p><h4>Workspace에 따라 Role 을 변경하여 배포하기</h4><p>Workspace 별로 서로 다른 AWS 계정을 사용할 경우, 아래와 같이 설정하면 하나의 AWS Profile에 role만 변경하여 여러 환경을 배포할 수 있다. (아니, 그럴 것 같았다)</p><pre>provider &quot;aws&quot; {<br>  version = &quot;~&gt; 1.1&quot;<br>  region  = &quot;ap-northeast-2&quot;<br>  assume_role {<br>    role_arn = &quot;arn:aws:iam::${var.account_id[terraform.workspace]}:role/${var.aws_role}&quot;<br>  }<br>}</pre><p>하지만 현재 버전의 Terraform에서 assume_role이 동작하지 않는 버그가 있다. (<a href="https://github.com/terraform-providers/terraform-provider-aws/issues/1184">관련 이슈 참고</a>) 따라서 아쉽게도 현재는, 아래와 같이 Workspace를 변경할 때마다 (그 Workspace에 대응되는) AWS 계정의 IAM 유저 프로필로 변경을 해야한다.</p><pre>$ terraform workspace select prod<br>$ export AWS_PROFILE=terraform-prod<br>$ terraform plan</pre><h3>References</h3><ul><li><a href="https://www.terraform.io/docs/state/workspaces.html">https://www.terraform.io/docs/state/workspaces.html</a></li><li><a href="https://medium.com/@diogok/terraform-workspaces-and-locals-for-environment-separation-a5b88dd516f5">https://medium.com/@diogok/terraform-workspaces-and-locals-for-environment-separation-a5b88dd516f5</a></li><li><a href="https://medium.com/@jyotirbhandari/overview-of-terraform-in-10-mins-9780d55bf6a3">https://medium.com/@jyotirbhandari/overview-of-terraform-in-10-mins-9780d55bf6a3</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2deff99356f6" width="1" height="1"><hr><p><a href="https://medium.com/salesboost-people/terraform-workspaces-for-deployment-environments-2deff99356f6">Terraform의 Workspace를 이용해 배포 환경 분리하기</a> was originally published in <a href="https://medium.com/salesboost-people">Salesboost People</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[[채용] 세일즈부스트 팀 빌딩을 시작합니다.]]></title>
            <link>https://medium.com/salesboost-people/salesboost-recruit-2c1248aa394a?source=rss-e47347637ee------2</link>
            <guid isPermaLink="false">https://medium.com/p/2c1248aa394a</guid>
            <category><![CDATA[people]]></category>
            <category><![CDATA[세일즈부스트]]></category>
            <category><![CDATA[boost-sales]]></category>
            <category><![CDATA[채용]]></category>
            <dc:creator><![CDATA[Sean Soowan Lee]]></dc:creator>
            <pubDate>Mon, 22 Jan 2018 07:30:46 GMT</pubDate>
            <atom:updated>2019-04-23T12:22:50.919Z</atom:updated>
            <content:encoded><![CDATA[<blockquote>세일즈부스트에서 소수 정예의 프로팀을 만들고자 합니다. 백엔드 엔지니어 1명, 프론트엔드 엔지니어 2명, UX/UI 디자이너 1명을 찾습니다!</blockquote><p>안녕하세요, 세일즈부스트 CTO 이수완입니다.</p><p>세일즈부스트는 <strong>“고객의 매출을 높이는 기술을 만든다”</strong>는 미션 아래, <strong>누구나 쓰기 쉬운 마케팅 솔루션</strong>을 만들고 있습니다. 저희는 거대하고 복잡한 온라인 마케팅 시장에서 중소 규모의 회사들이 공통으로 겪는 문제들을 발견했고, 기술로 이를 해결할 수 있으며, 의미 있는 스케일을 만들어낼 수 있다고 확신합니다.</p><p>가설 증명을 위해 프로토타입 버전을 개발했고, <strong>UI도 없는 이 제품에 20개의 고객사가 돈을 내고 사용</strong>하고 있습니다. 빠른 시간 내에 상용 수준의 제품으로 만들어 더 많은 고객에게 서비스를 제공하려고 합니다.</p><p>올해 상반기에는 <strong>쇼핑몰을 위한 솔루션</strong>을 런칭하고, 하반기에는 <strong>모바일 게임을 위한 솔루션</strong> 런칭을 계획하고 있으며 내년에는 <strong>글로벌 진출</strong>을 목표로 하고 있습니다.</p><p><strong>현재 함께 하고 있는 창업팀은 이전에 동고동락하며 일한 경험이 있습니다.</strong> 세일즈부스트를 이끌고 있는 <a href="https://www.facebook.com/shawn.kimn"><strong>김상현 대표</strong></a>는 커머스 스타트업에서 CMO/CTO로 일한 경험이 있고 프라이머가 투자한 스타트업뿐만 아니라 여러 커머스 업체들의 성장 전략 및 디지털 마케팅에 관해 컨설팅을 해왔던 <strong>디지털 마케팅 전문가</strong>입니다. <a href="https://www.facebook.com/sybae12">SY</a>는 IoT 스타트업의 마케팅 헤드로 일하며 해외에서의 제품 시장성을 성공적으로 입증시킨 경험이 있습니다.</p><p>최근 법인 설립을 했고, 설립과 동시에 캡스톤과 프라이머 그리고 권도균 대표님과 네이버 전 김상헌 대표님으로부터 <strong>약 7억의 시드 투자</strong>를 받았습니다.</p><p>우리가 지향하는 회사의 모습은, 기업 문화로는 탁월한 인재들이 모여 자율과 책임 아래 높은 퍼포먼스를 내고 동종 업계 최고의 대우를 제공하는 <a href="https://www.slideshare.net/reed2001/culture-1798664"><strong>넷플릭스</strong></a> + 업무 방식은 전 직원 원격 근무를 하는 <a href="http://www.bloter.net/archives/256818"><strong>오토매틱</strong></a>(워드프레스 개발사)으로 설명할 수 있습니다. 이런 회사를 만들고 싶다고 하면 다들 ‘한국에서는 불가능한 이상적인 꿈’이라고 합니다. 하지만 <strong>책임감, 능력, 신뢰 이 세 가지를 모두 갖춘 사람들이 모여 놀라운 성과를 만들어낸다면 꿈이 현실이 되지 않을까요?</strong></p><p>근무는 리모트 형식을 기본으로 하고, <strong>일주일에 두 번 강남역 드림플러스에 모여</strong>서 밥 먹고 회의하며 싱크를 맞춥니다. 주간/월간 단위로 팀별/개인별 목표를 설정하고 그 목표를 달성하기 위해 원하는 시간에, 원하는 장소에서 자율적이고 주도적으로 업무를 진행합니다. 답답한 사무실도, 마이크로매니징도, 눈치 보는 휴가도 필요 없습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/960/1*L48Q51NcXRKWvTYP9vOF2w.jpeg" /><figcaption>강남역 드림플러스</figcaption></figure><h3>To. 엔지니어</h3><p><strong>뛰어난 사람들이 모여 훌륭한 기술을 만들고, 훌륭한 기술이 위대한 제품을 만든다</strong>는 믿음으로 개발팀을 꾸려가려고 합니다. 제품 초기부터 아키텍처 설계에 공을 들이고 있으며 개발 프로세스와 문화도 최고 수준으로 함께 만들어나가고 싶습니다.</p><p>메인 언어로는 Python과 TypeScript 를, 서브 언어로 Golang을 사용하고 있습니다. 마이크로서비스 아키텍처를 적극적으로 적용하고 있고, 서버 운영에 신경을 쓰고 싶지 않아서 AWS Lambda 를 비롯한 여러 서버리스 기술을 사용하고 있습니다. Devops 문화를 초기부터 만들기 위해 CI/CD, 통합 모니터링, 통합 로깅, Infrastructure as Code 등을 비롯해 각종 자동화를 다져놓았습니다. 프론트엔드는 Vue.js 또는 React.js 로 개발을 할 예정입니다. <strong>단순히 트렌드인 기술을 적용하는 것 자체에 그치지 않고 Best Practice로 올바르게 사용하려고 합니다.</strong></p><blockquote>혹시 온라인 광고/마케팅 분야의 AI 기술에 관심이 많거나 경험이 있으신 엔지니어가 있다면 꼭 연락 부탁드립니다. 이번 채용의 대상은 아니지만 더 큰 일을 도모하기 위해 관계를 이어나가고 싶습니다.</blockquote><h3>To. 디자이너</h3><p><strong>디자이너는 업계 최고의 실력자로 욕심내어 모시고자 합니다. </strong>저희가 가장 필요로 하는 탤런트인 만큼 합당한 대우를 해드리겠습니다.</p><p>디자이너는 모든 분야에 날개를 달아줄 수 있는 유일한 포지션이라고 생각합니다. <strong>개발, 마케팅, 사업에 걸쳐 가장 협업 폭이 큰 포지션이기도 하여 팀에서 가장 핵심적인 역할을 맡게 될 겁니다.</strong></p><p>구체적으로 아래와 같은 일을 하게 됩니다.</p><ul><li>로고, 명함, 홈페이지를 포함한 전반적인 회사 브랜딩을 빈 캔버스에서부터 시작하실 수 있습니다.</li><li>고객이 직관적이고 쉽게 우리의 마케팅 솔루션을 경험하는 것을 목표로, 제품 랜딩페이지와 웹 대시보드의 UX 전략 수립과 UI 디자인을 총괄합니다.</li><li>광고 크리에이티브 제작을 통해 고객의 경험과 공감을 구체화합니다.</li></ul><p>우리의 여정에 동참하고 싶으신 백엔드 엔지니어, 프론트엔드 엔지니어, 디자이너가 계신다면, 일단 강남역에서 포카리 한 잔 하는거 어때요?</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ero6p9UOmJbZBtRwmZ8rlA.png" /><figcaption>포카리 한 잔 해요!</figcaption></figure><p>wewantyou@salesbooster.io 로 이력서 또는 본인을 소개하는 자료를 보내주세요. 정성껏 읽어보고 다음 단계를 안내해 드리겠습니다. 궁금하신 부분이 있다면 <a href="http://facebook.com/blaswan">제 페이스북</a>으로 메시지 주시거나 아래 댓글로 남겨주세요.</p><p>조금 오래 걸리고, 당장 코딩할 시간이 줄더라도 가능한 많은 분을 직접 만나보고 싶습니다. 실력도 중요하지만, 초기 멤버인만큼 다른 많은 부분도 고려하여 가장 적합한 분을 찾으려고 합니다.</p><p>본인이 아닌 지인이 더 적합하다고 생각하신다면 링크를 공유해주시거나 소개를 해주셔도 좋습니다. <strong>성사가 되면 애플워치</strong>로 답례하겠습니다.</p><p>긴 글 읽어주셔서 감사합니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2c1248aa394a" width="1" height="1"><hr><p><a href="https://medium.com/salesboost-people/salesboost-recruit-2c1248aa394a">[채용] 세일즈부스트 팀 빌딩을 시작합니다.</a> was originally published in <a href="https://medium.com/salesboost-people">Salesboost People</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[네 감사합니다 자주 들러주세요 :)]]></title>
            <link>https://medium.com/@blaswan/%EB%84%A4-%EA%B0%90%EC%82%AC%ED%95%A9%EB%8B%88%EB%8B%A4-%EC%9E%90%EC%A3%BC-%EB%93%A4%EB%9F%AC%EC%A3%BC%EC%84%B8%EC%9A%94-ac479ff3c1ad?source=rss-e47347637ee------2</link>
            <guid isPermaLink="false">https://medium.com/p/ac479ff3c1ad</guid>
            <dc:creator><![CDATA[Sean Soowan Lee]]></dc:creator>
            <pubDate>Sun, 26 Feb 2017 09:00:42 GMT</pubDate>
            <atom:updated>2017-02-26T09:00:42.212Z</atom:updated>
            <content:encoded><![CDATA[<p>네 감사합니다 자주 들러주세요 :)</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ac479ff3c1ad" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[채널 데스크 프론트엔드 기술 스택]]></title>
            <link>https://medium.com/@blaswan/channel-desk-frontend-stack-893b75adf2e1?source=rss-e47347637ee------2</link>
            <guid isPermaLink="false">https://medium.com/p/893b75adf2e1</guid>
            <category><![CDATA[technology]]></category>
            <category><![CDATA[channel]]></category>
            <category><![CDATA[zoyi]]></category>
            <dc:creator><![CDATA[Sean Soowan Lee]]></dc:creator>
            <pubDate>Thu, 01 Dec 2016 06:43:51 GMT</pubDate>
            <atom:updated>2016-12-01T09:43:22.018Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*_oD7kivHNPfwPXPYBEqTHw.png" /></figure><p><a href="http://walkinsights.com/">오프라인 고객 분석 솔루션 워크인사이트</a>를 개발해 온 <a href="http://zoyi.co/">조이</a>는 최근 <a href="https://channel.io">온라인 접객 서비스 채널</a>을 런칭했습니다. 이 글은 채널과 관련된 기술 블로그의 첫번째 글로 채널 데스크 프론트엔드(웹, 윈도우, OSX)의 기술 스택 및 개발 환경을 소개하도록 하겠습니다.</p><h3>React</h3><p>채널 개발을 처음 시작할 당시 (지금으로부터 1년 전) 에 워크인사이트 대시보드 및 기타 사내 툴에서는 AngularJS 1을 사용하고 있었습니다. 비교적 적은 코드로 복잡한 애플리케이션을 빠르게 만들 수 있는 점에는 만족했지만 퍼포먼스면에서는 아쉬운 부분이 많았습니다. 따라서 새로운 프레임워크 및 라이브러리를 리서치 했고 매우 가볍고 렌더링 퍼포먼스 면에서 AngularJS 1 대비 우위에 있던 React 를 사용하기로 결정했습니다.</p><p>컴포넌트의 설계 패턴은 <a href="https://medium.com/@dan_abramov">Redux를 만든 Dan</a>이 제안한 <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.5j7mszaqi">Container 와 Presentational 컴포넌트를 구분하는 방식</a>으로 설계하고 있습니다. 따라서 Container 가 data fetch 및 update 등의 액션을 실행하고 Presentational 컴포넌트들을 조합하여 렌더링을 하게 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/440/1*imX6iAiQxl3AF344gKR_BQ.png" /></figure><p>React를 실제 1년째 사용해 본 결과 저를 비롯한 팀원들은 매우 만족하고 있습니다. 구조, 스타일, 동작을 한 컴포넌트로 묶어 재사용성이 매우 높아졌으며 React의 휴리스틱한 Dom diff algorithm 덕분에 렌더링 퍼포먼스에서도 많은 이득을 얻을 수 있었습니다.</p><h3>Facebook Flux Utils</h3><p>아키텍쳐는 페이스북이 제안한 flux 철학에 따라 설계되었습니다. flux를 구현하기 위한 기본적인 유틸리티 기능을 제공하는 <a href="https://github.com/facebook/flux">Flux Utils</a>을 사용합니다. Flux의 많은 구현체 중에 요즘 가장 인기인 <a href="https://github.com/reactjs/redux">Redux</a>도 고려했었습니다. 저희가 프로젝트를 시작할 당시에 Redux는 5~6개월밖에 되지 않은 프로젝트였고 거의 Dan의 1인 프로젝트였기 때문에 향후 메인터넌스를 장담할 수 없다고 판단했습니다. 그보다는 페이스북이 만든 Flux Utils가 그런 면에서는 더 안전할 거라고 생각했던 것이죠.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ymv0cviV6fZGiIbN-1HWEQ.png" /></figure><p>약 1년 정도 Flux Utils로 개발해오며 몇 가지 문제를 겪게 되었습니다. 애플리케이션이 커지면서 관리해야할 State가 많아지고 그들 사이의 의존성 관리 때문에 Store의 복잡도가 빠르게 증가했습니다. 그에 따라 테스트가 어려워지고 올바른 유닛테스트를 위해서는 테스트 코드 역시 매우 복잡해지는 문제가 있었습니다.</p><p>그래서 Redux를 다시 리서치하게 되었고, 결론적으로 “단일 Store, 다수Reducer” 라는 Redux의 철학을 통해 State 관리 로직(Reducer)을 단순하고 테스트도 쉽게 유지할 수 있겠다는 생각을 하게 되었습니다. 뿐만 아니라 그 동안 설계와 관련되어 고민하고 필요한 경우 저희 스스로 개발해서 사용하던 많은 부분이 Redux의 서브 프로젝트 형태로 (<a href="https://github.com/acdlite/redux-actions">redux-actions,</a> <a href="https://github.com/gaearon/redux-thunk">redux-thunk</a>, <a href="https://github.com/reactjs/reselect">reselect</a> 등) 개발되어 사용되고 있는 것을 발견해서 Redux로의 마이그레이션을 결정했고 현재 진행 중에 있습니다.</p><h3>Electron</h3><p>이 글의 도입부에서 이야기한 것처럼 채널 데스크는 윈도우용, OSX용 애플리케이션으로도 제공됩니다. 채널 개발 초기 당시 윈도우, OSX 각각 네이티브로 만들 리소스가 부족했기 때문에 웹 기술 기반으로 네이티브 앱을 만들 수 있는 다양한 솔루션들을 리서치했고 그 중 <a href="http://electron.atom.io/">Electron</a>을 선택하게 되었습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/951/1*1VSELY8h6yjocNeiowupbw.png" /></figure><p>Electron은 제가 정말 좋아하는 제품인 Slack, Simplenote에서 사용하고 알려져 있고 국내에서는 Remember 등에서 사용하고 있습니다. 초기 개발 당시에는 안정성에 의문을 제기하는 개발자들도 많았고 저희도 여러 문제와 삽질(인증, 패키징, 이슈 레포팅의 어려움, 메모리릭 등등)을 많이 겪긴 했습니다만 개인적으로는 충분히 프로덕션에 쓸 수 있을 정도 수준이라고 생각합니다. 무엇보다 프론트엔드 개발자가 매우 적은 노력으로도 네이티브 데스크탑 앱을 만들 수 있는 장점이 다른 모든 문제점을 상쇄하고도 남습니다.</p><h3>언어</h3><p>개발 언어로는 자바스크립트 ES6를 사용합니다. 언어를 선택할 당시에도 여러 옵션이 있었는데 가능하면 실험적이지 않고 표준을 사용하는 것이 미래 유지보수에 안전하다고 판단했습니다. 또한 다른 자바스크립트 대안 언어를 사용하지 않더라도 ES6 (일부 ES7 포함) 스펙도 충분히 효율적인 개발이 가능하다고 생각했습니다.</p><p>코딩 스타일은 기본적으로 <a href="https://github.com/zoyi/javascript">Airbnb의 코딩 스타일 가이드라인을 따르며 조이의 상황과 맞지 않는 부분은 엔지니어들과 상의 후 수정해서 사용</a>하고 있습니다. 스타일 체크는 <a href="http://eslint.org/">ESLint</a>로 자동화한 뒤 <a href="https://circleci.com/">Circle CI</a>와 붙여서 모든 풀리퀘스트에 대해 점검하고 있습니다.</p><h3>테스트</h3><p>초기 개발할 때는 테스트 코드를 별도로 붙이지 않았습니다. 고객의 요구와 기타 상황에 따라 기획과 설계가 크게 변경되기도 했고 그 때마다 기민하게 반응하기 위해서, 어느 정도 확립된 제품이 되기 이전에는 테스트 코드는 작성하지 않는 것이 좋다고 판단했습니다. 이제는 많은 부분이 확정되었고 안정성이 중요해지기 시작했으며 애플리케이션이 커지면서 자동화된 테스트는 필수가 되기 시작했기에 최근에 도입을 하고 있습니다.</p><p>테스트를 위한 도구는 <a href="https://facebook.github.io/jest/">Jest</a>, <a href="https://github.com/airbnb/enzyme">Enzyme</a> 등을 사용합니다. Presentational 컴포넌트에 대한 테스트는 props에 따라 원하는 형태로 렌더링이 이루어지는지, 이벤트에 따라 콜백이 잘 실행되는지 등의 Spec 을 작성합니다. Container 컴포넌트에 대한 테스트는 각종 이벤트 및 동작을 시뮬레이션하고 그에 따라 Action이 잘 발생하는지 또는 내부 state가 잘 변경되는지를 테스트합니다. 또한 Store (또는 Reducer), Action Creator, Model, Util 등 모든 구성 요소에 대한 테스트를 붙이려고 노력하고 있습니다. 유닛 테스트가 아닌 e2e 테스트 혹은 css 스타일 테스트 등은 하지 않고 있습니다.</p><h3>빌드 및 배포</h3><p>현재 채널 데스크는 Client-side rendering을 합니다. 초기 로딩 속도가 느리다는 단점이 있어서 Server-side rendering으로의 전환도 고려하고 있습니다. 이미 Node.js 를 사용하고 있어서 Isomorphic Javascript의 형태로 어렵지 않게 전환이 가능합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/380/1*VIHA3H8AC_5j9UZhVT6mPg.png" /></figure><p>작성된 자바스크립트는 Babel로 컴파일되고 Webpack으로 번들화됩니다. css를 포함한 각종 리소스들 역시 Webpack을 통해 처리됩니다. 웬만한 작업은 npm과 Webpack으로만 자동화하려고 했으며, Electron과 관련된 작업(패키징, 인증 등)들만 gulp를 이용해 자동화됩니다. 모든 리소스들은 Node.js + express 서버로 Serving 되고, Node.js 앱은 Docker로 빌드되어 AWS EC2로 배포됩니다.</p><h3>마무리</h3><p>이상으로 채널 데스크 프론트엔드의 기술 스택을 소개해드렸습니다. 앞으로 각 부분 별로 저희 팀이 고민해 온 문제들과 해결 방법을 공유하고자 합니다. 뛰어난 개발자 분들의 많은 관심과 피드백 부탁드립니다!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=893b75adf2e1" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[워크인사이트 프론트엔드 개발환경]]></title>
            <link>https://medium.com/@blaswan/walkinsights-frontend-stack-544a913acb03?source=rss-e47347637ee------2</link>
            <guid isPermaLink="false">https://medium.com/p/544a913acb03</guid>
            <category><![CDATA[dashboard]]></category>
            <category><![CDATA[frontend]]></category>
            <category><![CDATA[walkinsights]]></category>
            <category><![CDATA[web-development]]></category>
            <category><![CDATA[technology]]></category>
            <dc:creator><![CDATA[Sean Soowan Lee]]></dc:creator>
            <pubDate>Fri, 09 Sep 2016 08:32:37 GMT</pubDate>
            <atom:updated>2016-10-07T06:30:11.305Z</atom:updated>
            <content:encoded><![CDATA[<p>이 글은 2015년 4월 10일에 작성된 글입니다.</p><p><a href="http://zoyi.co/">조이코퍼레이션</a>은 오프라인 고객 분석 서비스인 <a href="http://walkinsights.com/">워크인사이트</a>를 만들고 있습니다. 워크인사이트는 스마트폰 신호를 통해 매장 방문객의 출입 및 체류 패턴을 측정하고 분석합니다. 분석된 데이터는 웹 대시보드를 통해 한 눈에 파악하기 쉬운 형태로 매장에 제공됩니다. 매장들은 이 대시보드를 보고 중요한 판단과 의사 결정을 내리기 때문에 대시보드는 보기 쉬워야 하고 쓰기 편해야 하며 무엇보다 아름다워야 합니다. 조이의 빅데이터 기술을 통해 분석된 데이터를 매장에 효과적으로 전달하기 위해 <strong>프론트엔드 기술에 많은 노력을 기울이고 있습니다.</strong> 이 글에서는 조이의 대시보드를 만들기 위해 사용하고 있는 기술과 개발 환경 그리고 기술적인 관점에서 고민하고 있는 부분들을 간략하게 공유하고자 합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*zKalW-uVGgegD0e8YiagOw.png" /><figcaption>그림1. 대시보드 화면</figcaption></figure><h3>사용하는 기술</h3><ul><li><strong>AngularJS</strong>: AngularJS를 기본 프레임워크로 사용하고 있습니다. AngularJS는 SPA (Single Page Application) 형태의 웹 애플리케이션을 빠르게 개발할 수 있도록 도와주는 MVC 프레임워크입니다. 조이에서는 현재 프로덕션 버전인 1.3.x를 사용하고 있습니다. 대시보드는 사용자의 이벤트에 따라 동적으로 데이터를 변경해야하는 애플리케이션적 요소가 많기 때문에 AngularJS의 양방향 데이터 바인딩의 유용함을 느끼고 있습니다.</li><li><strong>D3.js</strong>: 다양한 그래프를 아름답게 보여주기 위해서 D3.js를 사용합니다. D3.js는 데이터 시각화를 위한 자바스크립트 라이브러리로, HTML/CSS/SVG 등의 웹 기술을 이용해 그래프를 그릴 수 있습니다. 자유도가 매우 높아서 생각할 수 있는 많은 형태의 그래프를 그릴 수 있으며 부드러운 전환이나 애니메이션도 추가할 수 있습니다. 다만 초기 학습 비용이 높고 신경쓰지 않으면 너저분한 코드가 양산될 수 있다는 단점도 있습니다.</li><li><strong>CoffeeScript</strong>: 자바스크립트를 더 깔끔하고 효율적으로 사용할 수 있도록 Compile to JS 언어를 사용하는데, 여러 선택 사항 중 CoffeeScript를 사용하고 있습니다. CoffeeScript는 문법적 간결함 덕분에 타이핑을 줄이고 빠르게 코드를 작성할 수 있습니다. 특히 클래스와 클래스 상속 등을 문법적으로 지원하기 때문에 OOP적인 설계를 할 때 도움을 받았습니다. 하지만 자바스크립트와는 다른 새로운 문법을 익혀야하고 그마저도 일관성이 떨어지는 문제가 있습니다. 또 특별한 신경을 쓰지 않으면 가독성이 안 좋은 코드를 작성하기 쉽습니다. 조이에서는 Lint 툴과 코드 리뷰를 통해 코딩스타일을 엄격히 제한하고 있습니다.</li></ul><h3>개발 환경</h3><ul><li><strong>빌드 및 배포</strong>: Bower와 npm(Node Package Manager)을 이용해서 패키지를 관리합니다. 빌드 시에는 JS Minify &amp; Uglify, HTML/CSS 최적화, CoffeeScript Lint를 통한 코드 품질 검증, Karma를 이용한 테스트 수행 등의 과정을 거치며 이 모든 빌드 과정은 Grunt를 사용하여 자동화하고 있습니다. 빌드가 끝난 파일들은 AWS (Amazon Web Service)의 S3 저장소로 배포하고 있습니다. 배포 과정 역시 Grunt의 task로 자동화되어 있습니다.</li><li><strong>코드 관리</strong>: 모든 코드는 Jenkins로 통합되어 자동화된 테스트를 통과해야 합니다. 모든 커밋은Gerrit을 통해 다른 엔지니어의 리뷰를 거쳐야만 머지를 할 수 있습니다. 따라서 모든 코드는 적어도 둘 이상의 엔지니어가 이해하고 있습니다. 같은 코드에 대해 더 좋은 설계가 있는지 논의하면서 함께 코드를 발전시켜 나갑니다. 더 좋은 설계가 발견될 때마다 수시로 리팩토링을 진행합니다.</li><li><strong>프로젝트 관리</strong>: 디자이너와 엔지니어 그리고 기획에 참여하는 데이터 분석가 등은 Trello를 이용해 태스크와 이슈를 관리합니다. 일주일을 한 번의 스프린트로 보고 매주 월요일에 일을 분배하고 금요일에 회고를 합니다. 이 과정에서 엔지니어도 기획에 능동적으로 참여할 수 있으며, 어떤 데이터를 어떤 형태의 그래프로 보여주어야 효과적인지를 함께 고민할 수도 있습니다.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*521cKl4pWoYF_hnCSqXkrA.png" /><figcaption>그림2. 트렐로를 이용한 프로젝트 관리</figcaption></figure><h3>지속적으로 고민하는 부분</h3><ul><li><strong>성능 이슈</strong>: 대시보드에는 많은 수치 데이터를 다룹니다. API 서버로부터 하나의 큰 JSON 데이터를 받아서 시간별/일별/요일별/날씨별/최고기온별/평일휴일별 방문객 정보, 방문전환율/체류전환율/구매전환율 등의 지표를 그리기 위한 데이터로 가공합니다. 여기에는 계산량이 적지 않기 때문에 성능에 대한 고민을 많이 하게 됩니다. 연산 로직을 더 간단히 하거나 더 적게 Draw/Redraw 하는 방법을 고민하고 응답성을 향상시키기 위해 Async하게 연산하는 등의 고민을 합니다.</li><li><strong>설계</strong>: 대시보드는 빠르게 업그레이드됩니다. 기능이 추가되고 변경됨에 따라 그에 맞는 좋은 설계도 계속해서 변합니다. 수시로 진행하는 리팩토링이 좋은 설계를 만든다고 생각합니다. 따라서 리팩토링에 쓰는 시간을 아까워하지 않습니다.</li><li><strong>테스트</strong>: 테스트는 매우 중요합니다. 특히 버그로 인해 잘못된 데이터가 보여지는 것은 용납될 수 없습니다. 그래서 데이터를 가공하는 로직에 대한 테스트는 엄격하게 수행됩니다. 설계 단에서도 테스트하기 쉬운 코드를 작성하려고 노력합니다.</li><li><strong>최신 기술</strong>: 조이의 프론트엔드 팀은 최신 기술에 민감합니다. Gulp, Angular 2.0, EcmaScript6, TypeScript, React와 같은 자바스크립트 최신 기술들에 관심을 갖고 그들의 기본 철학이나 장단점들을 파악하려고 노력합니다. 때때로 우리에게 더 잘 맞는 기술이 등장하면 과감하게 적용하기도 합니다.</li></ul><h3>맺음말</h3><p>조이는 임베디드 기술과 빅데이터 기술을 보유한 기술 회사입니다. 그러나 프론트엔드 기술 역시 그 못지 않게 중요하게 생각하고 있습니다. 말뿐이 아니라 며칠 전에는 OKKY 자바스크립트 컨퍼런스에 후원을 하고 좋은 자바스크립트 개발자들을 만나기 위해서 부스를 차리기도 했습니다. 앞으로도 프론트엔드 기술 관련 컨퍼런스에 후원도 하고 기여도 계속 할 계획입니다.</p><p>저도 조이에서 엔지니어로 일하면서 훌륭한 동료 엔지니어들과 함께 많은 성장을 했습니다. 무엇보다 기술적인 욕심과 의욕이 넘치는 분위기 속에서 일하는 것 자체가 즐겁고요. 혹시 이 글을 읽고 위와 같은 고민을 공유하고 폭풍 성장을 함께 할 멋진 자바스크립트 개발자가 있다면 <a href="http://zoyi.co/job/2015/03/27/front-end-engineer/">이 글</a>을 읽어보시길 바래요 :)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/816/1*3lkjYsATxx-HAESS7nxvBA.jpeg" /><figcaption>그림3. OKKY 자바스크립트 컨퍼런스 부스</figcaption></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=544a913acb03" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>