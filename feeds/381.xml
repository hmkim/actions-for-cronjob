<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Park Juhyung on Medium]]></title>
        <description><![CDATA[Stories by Park Juhyung on Medium]]></description>
        <link>https://medium.com/@majecty?source=rss-b7860e5e0b63------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/1*-TeA1P3Pe-Nd1wu3GRltAQ.jpeg</url>
            <title>Stories by Park Juhyung on Medium</title>
            <link>https://medium.com/@majecty?source=rss-b7860e5e0b63------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 13 May 2019 04:27:36 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@majecty" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[Schnorr Signature and Tendermint]]></title>
            <link>https://medium.com/codechain/schnorr-signature-and-tendermint-a863678998be?source=rss-b7860e5e0b63------2</link>
            <guid isPermaLink="false">https://medium.com/p/a863678998be</guid>
            <category><![CDATA[blockchain]]></category>
            <category><![CDATA[chaincode]]></category>
            <category><![CDATA[tendermint]]></category>
            <category><![CDATA[schnorr-signature]]></category>
            <dc:creator><![CDATA[Park Juhyung]]></dc:creator>
            <pubDate>Fri, 10 May 2019 09:38:05 GMT</pubDate>
            <atom:updated>2019-05-10T09:46:51.505Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/proxy/1*Oq2wDsZEOGYZON1x4vgfrQ.jpeg" /><figcaption><a href="https://en.wikipedia.org/wiki/Claus_P._Schnorr">Claus Schnorr</a> (Image from Konrad Jacobs — <a href="https://opc.mfo.de/detail?photoID=3722">https://opc.mfo.de/detail?photoID=3722</a>)</figcaption></figure><h4>Digital Signature Algorithms of Blockchains</h4><p>The asymmetric key signature algorithm, which consists of a public key and a private key, is the underlying technology of the blockchain. The address of the wallet is created from the public key, and the ownership of the goods in the wallet is verified using the private key. In blockchain networks, user-created transactions always contain signatures and these signatures should be used to validate transactions.</p><p>Many blockchain projects use the ECDSA signature algorithm. This is because ECDSA can achieve similar safety with fewer bits compared to RSA. If RSA needs 1024 bits to offer a certain level of safety, ECDSA offers equal results with just 192 bits. Similarly, <a href="https://koclab.cs.ucsb.edu/teaching/ecc/project/2015Projects/Cenar+Sebastian.pdf">2048 bits in RSA can be achieved with 256 bits in ECDSA</a>. Since most of the block is composed of public keys and signatures, small signatures and keys ultimately result in low network and storage costs.</p><p>The Schnorr signature scheme is the emerging signature scheme for ECDSA in the blockchain industry. Its signing method is simpler, has a smaller signature size, and offers the ability to combine multiple signatures as well. For more information, please check <a href="https://medium.com/codechain/schnorr-signatures-in-codechain-5d1ae31f4f8f">this post</a> written by Jeong Hyunsik, a software engineer of KodeBox.</p><h4><strong>CodeChain and Tendermint Consensus Algorithms</strong></h4><p>CodeChain’s mainnet uses the Tendermint consensus algorithm. Tendermint is a BFT consensus algorithm where appointed nodes (called committees) send and receive messages amongst each other and agree on blocks. In this process, the types of messages that are sent and received are known as Propose, Prevote, and Precommit. These messages include the signature of the node that created the message. A block determined as a result of consensus contains a Precommit signature of the nodes that agreed on the block.</p><p>The larger the size of a committee, the more resilient it is against abnormally behaving nodes, so the size of the committee is important for BFT consensus algorithms. However, as the size of the committee grows, the amount of messages sent and received, the messages to be stored, and the messages to be verified all increase, which slows down the processing of blocks and increases the load on the network and disk.</p><p>Currently, CodeChain’s mainnet is composed of 30 nodes, which work together to create a block. Each block contains 29–30 Precommits, and 30 signatures add up to approximately 2 KB. Whether the number of transactions is large or small, a load of 2KB is always added to the block, and since it the network is still in the beginning stages, Precommit messages occupy most of the data currently being exchanged.</p><h4><strong>Plans to Adopt the Schnorr Signature and the Expected Effects</strong></h4><p>As mentioned above, Schnorr signatures allow you to combine multiple signatures into a single signature. The CodeChain team plans to combine the Precommits stored in the blocks into a single signature. With this feature enabled, disk usage can be reduced by up to a factor of 10, and network usage can be significantly reduced. You can also increase the size of the committee at a lower cost since the sum of three signatures, the sum of 30 signatures, and the sum of 300 signatures are all the same.</p><h4><strong>The Difficulty of Adopting a New Signature Algorithm</strong></h4><p>Even a small bug in the cryptographic library can be a fatal security issue, so make sure you carefully check that the library is heavily used and that the implementation is stable enough. Since the Schnorr signature is a method that is not yet widely used, there is a big risk to adopt it before other projects. However, as long as the benefits of its adoption is attractive enough, it is worth looking into and utilizing it in your own project.</p><h4><strong>Conclusion</strong></h4><p>Signature algorithms are one of the underlying techniques of blockchains. Since all actions involve signatures, the processing speed of the network as a whole is proportional to the processing speed of signatures, and the network and disk load is proportional to the size of the keys and signatures. The CodeChain team is hard at work to come up with ways to save money and improve network safety, and one of them is testing the function that collects Schnorr signatures.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a863678998be" width="1" height="1"><hr><p><a href="https://medium.com/codechain/schnorr-signature-and-tendermint-a863678998be">Schnorr Signature and Tendermint</a> was originally published in <a href="https://medium.com/codechain">CodeChain</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Schnorr 서명과 텐더민트]]></title>
            <link>https://medium.com/codechain-kr/schnorr-%EC%84%9C%EB%AA%85%EA%B3%BC-%ED%85%90%EB%8D%94%EB%AF%BC%ED%8A%B8-4aad44578c87?source=rss-b7860e5e0b63------2</link>
            <guid isPermaLink="false">https://medium.com/p/4aad44578c87</guid>
            <category><![CDATA[chaincode]]></category>
            <category><![CDATA[tendermint]]></category>
            <category><![CDATA[schnorr-signature]]></category>
            <dc:creator><![CDATA[Park Juhyung]]></dc:creator>
            <pubDate>Thu, 09 May 2019 11:05:51 GMT</pubDate>
            <atom:updated>2019-05-09T11:10:08.322Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/400/1*Oq2wDsZEOGYZON1x4vgfrQ.jpeg" /><figcaption><a href="https://en.wikipedia.org/wiki/Claus_P._Schnorr">Claus Schnorr</a> (Image from Konrad Jacobs — <a href="https://opc.mfo.de/detail?photoID=3722">https://opc.mfo.de/detail?photoID=3722</a>)</figcaption></figure><h4>블록체인에서의 서명 알고리즘</h4><p>공개키와 비밀키로 이루어진 비대칭키 서명 알고리즘은 블록체인의 기반이 되는 기술입니다. 지갑의 주소는 공개키로부터 만들어지고, 지갑에 들어있는 재화의 소유권은 비밀키를 사용하여 증명합니다. 블록체인 네트워크에서 유저가 만드는 트랜잭션에는 항상 서명이 포함되어 있으며, 트랜잭션을 검증하기 위하여 사용됩니다.</p><p>많은 블록체인 프로젝트가 서명 알고리즘으로 ECDSA를 사용합니다. 그 이유는 RSA에 알고리즘에 비하여, 비슷한 안전성을 더 적은 bit으로 달성할 수 있기 때문입니다. RSA에서 1024bit을 사용했을때의 안전성을 ECDSA에서는 192bit만 사용하면 충분하고, RSA에서 2048bit을 사용할 때의 안전성은 ECDSA에서는 256bit으로 달성할 수 있습니다[<a href="https://koclab.cs.ucsb.edu/teaching/ecc/project/2015Projects/Cenar+Sebastian.pdf">link</a>]. 블록의 대부분의 내용은 공개키와 서명으로 이루어져있기 때문에, 작은 크기의 서명과 키는 적은 네트워크 비용과 디스크 비용을 의미합니다.</p><p>Schnorr 서명 방식은 블록체인 업계에서 ECDSA에 대한 대안으로 떠오르고 있는 서명 방식입니다. 서명 방식이 더 간단하며, 서명의 용량이 작고, 여러 서명을 하나로 합칠 수 있는 기능을 제공해줍니다. 자세한 설명은 코드박스 정현식님이 작성하신 <a href="https://medium.com/codechain-kr/%EC%BD%94%EB%93%9C%EC%B2%B4%EC%9D%B8%EC%97%90%EC%84%9C%EC%9D%98-schnorr-signatures-e32754dccad6">이 글</a>을 확인해주세요.</p><h4><strong>코드체인과 텐더민트 컨센서스 알고리즘</strong></h4><p>코드체인의 메인넷은 텐더민트 합의 알고리즘을 사용합니다. 텐더민트는 BFT계열의 합의 알고리즘으로, 정해져있는 노드들이(위원회라고 부릅니다) 서로 메시지를 주고 받으며, 블록을 합의해나가는 컨센서스 알고리즘입니다. 이 과정에서 Propose, Prevote, Precommit 종류의 메시지들을 주고 받으며, 이 메시지들에는 메시지를 만든 노드의 서명이 포함됩니다. 합의의 결과로 확정된 블록은 해당 블록에 동의한 노드들의 Precommit 서명을 포함합니다.</p><p>위원회의 크기가 클수록 비정상적으로 행동하는 노드가 많아도 안전하기 때문에, BFT계열의 합의 알고리즘은 위원회의 크기가 중요합니다. 하지만 위원회의 크기가 클수록 주고 받는 메시지의 양과, 저장해야하는 메시지, 검증해야하는 메시지가 늘어나기 때문에 블록을 처리하는 속도도 느려지고 네트워크 및 디스크의 부하도 커집니다.</p><p>현재 코드체인 메인넷은 30개의 노드들로 위원회가 구성되어 블록을 생성합니다. 블록마다 29~30개의 Precommit들이 포함되고 있으며, 30개의 서명을 합치면 약 2KB가 됩니다. 블록에 들어있는 트랜잭션 갯수가 많든 적든 항상 2KB의 부하가 추가되고 있으며, 네트워크의 초기인 현재 주고받는 데이터의 대부분을 Precommit 메시지가 차지하고 있습니다.</p><h4><strong>Schnorr 서명의 도입 계획과 예상 효과</strong></h4><p>Schnorr 서명에서는 앞서 언급했던 바와 같이, 여러 서명을 모아서 하나의 서명으로 합칠 수 있습니다. 코드체인 팀은 블록에 저장되는 Precommit들을 하나의 서명으로 합쳐서 저장할 계획을 가지고 있습니다. 이 기능이 구현되면 디스크의 사용량은 최대 수십배 줄어들 수 있으며, 네트워크의 사용량 역시 상당 부분을 줄일 수 있습니다. 또한 3개의 서명을 합친 것과, 30개의 서명을 합친 것, 300개의 서명을 합친 것의 크기가 동일하기 때문에, 더 적은 비용으로 위원회의 크기를 키울 수 있습니다.</p><h4><strong>새로운 서명 알고리즘 도입의 어려운 점</strong></h4><p>암호화 라이브러리의 작은 버그가 치명적인 보안적 이슈가 될 수 있으므로, 해당 라이브러리가 많이 사용되고 있어서 충분히 구현이 안정되었는지를 주의 깊게 확인해야합니다. Schnorr 서명 방식은 아직 널리 쓰이고 있지 않은 서명 방식이기 때문에, 다른 프로젝트들보다 먼저 이를 사용하는 건 큰 부담이 됩니다. 하지만 적용했을 때의 효과가 충분히 매력적인 만큼, 직접 라이브러리의 코드를 검토해보고 도입해볼 만한 가치가 충분합니다.</p><h4><strong>결론</strong></h4><p>서명 알고리즘은 블록체인의 기반 기술 중 하나이며, 모든 행동에 서명이 포함되기 때문에 네트워크 전체의 처리 속도와 서명의 처리 속도에, 네트워크 및 디스크의 부하는 키와 서명의 크기에 비례합니다. 코드체인 팀은 비용의 절감과 네트워크 안전성을 위하여 여러 고민들을 하고 있으며, 그 중 한 방안으로 Schnorr 서명을 모으는 기능을 테스트하고 있습니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4aad44578c87" width="1" height="1"><hr><p><a href="https://medium.com/codechain-kr/schnorr-%EC%84%9C%EB%AA%85%EA%B3%BC-%ED%85%90%EB%8D%94%EB%AF%BC%ED%8A%B8-4aad44578c87">Schnorr 서명과 텐더민트</a> was originally published in <a href="https://medium.com/codechain-kr">코드체인</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[CodeChain and Regular Key]]></title>
            <link>https://medium.com/codechain/codechain-and-regular-key-2e358658405d?source=rss-b7860e5e0b63------2</link>
            <guid isPermaLink="false">https://medium.com/p/2e358658405d</guid>
            <category><![CDATA[chaincode]]></category>
            <category><![CDATA[key-management]]></category>
            <category><![CDATA[blockchain]]></category>
            <dc:creator><![CDATA[Park Juhyung]]></dc:creator>
            <pubDate>Mon, 29 Apr 2019 09:12:48 GMT</pubDate>
            <atom:updated>2019-04-30T07:41:50.584Z</atom:updated>
            <content:encoded><![CDATA[<p>Let’s find out what regular keys are, and how to use them.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/0*fwXJBPLwqOANceQ2" /><figcaption>Photo by <a href="https://unsplash.com/photos/FqaybX9ZiOU?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">James Sutton</a> on <a href="https://unsplash.com/search/photos/safety?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><h3>Secret Key and Blockchain</h3><p>In a blockchain, the hash value of the public key, or the public key itself, which is a pair with the secret key, is used as an address to give and receive money. In other words, a secret key represents one’s identity on a blockchain.</p><h3>Problems that Arise Without Regular Keys</h3><p>While secret keys are being used, there may be situations where a user has to change that secret key due to reasons such as secret key theft. In this situation, the user will be unable to use the address used with the stolen secret key. In the perspective of a service provider, this can be a critical issue. For instance, users may send tokens to an address that has been changed or no longer accessible. Tokens sent to such addresses will be lost forever.</p><h3>A Solution Via Regular Keys</h3><p>The problem mentioned above arises due to the secret key having multiple functions. One function is for proving one’s identity and the other is one’s public address. Is it absolutely necessary to create an address out of the secret key, which is used for signatures?</p><p>A solution is to use regular keys. The address is created by using the master key. Then the master key will be stored in a cold storage where there is no network connectivity. When users need to sign something, they would use the regular key. Under this type of model, even if something were to happen to the regular key, a new regular key can be created, making the old regular key invalid, while keeping the same address.</p><h3>Using a Regular Key</h3><p>Let’s learn how to use the SDK to take full advantage of the regular key. If this is your first time using CodeChain’s SDK, then read <a href="https://medium.com/codechain/managing-game-assets-with-codechain-97a49494a5e7">this article by JinGyeong</a>.</p><p>We will be taking a look at the following examples:</p><ol><li><strong>Randomly create a regular key pair (secret/public).</strong></li><li><strong>Register the newly created regular key to an existing master key.</strong></li><li><strong>Send a transaction that has been signed by a regular key.</strong></li><li><strong>Check whether the regular key has been stored properly by verifying the processing fee that has been charged in the master account.</strong></li></ol><p>To facilitate your understanding, here is the relationship between the master and regular key:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/569/1*1uF3ZFcjB9uDXk3ph1qpew.png" /></figure><p>Here is an example of code that creates a regular by using the SDK:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/1a9ea0caf9432ad8d347860f26e77c0a/href">https://medium.com/media/1a9ea0caf9432ad8d347860f26e77c0a/href</a></iframe><p>Let’s register the newly created regular key in an existing master account.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f88649b87f27854b4d566ea00b5caf37/href">https://medium.com/media/f88649b87f27854b4d566ea00b5caf37/href</a></iframe><p>From this point, you can use the regular key instead of the master key to sign transactions.</p><p>The code below is an example of sending CCC to another person by using the regular key instead of the master secret key:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/b2d6840dd0a95e65dc721f3099c8e701/href">https://medium.com/media/b2d6840dd0a95e65dc721f3099c8e701/href</a></iframe><p>If you look at code closely, the difference in using a regular key instead of the master key occurs when signing a transaction. By applying such small changes, it was possible to differentiate keys for different purposes.</p><h3>Points of Caution</h3><p>It is only possible to sign with a regular key after the block that contains the SetRegularKey transaction has been mined. Thus, if you send the SetRegularKey transaction and a transaction that has been signed with that regular key at the same time, it is possible that the transaction that has been signed with the regular key may not be processed. This is because CodeChain prevents transactions that cannot be processed at that point in time from being sent to the P2P network at all. Thus, it is crucial to check whether the regular key has been properly registered before using that regular key to sign off transactions.</p><h3>Conclusion</h3><p>CodeChain supports regular keys for service providers, such as game companies, that cannot randomly stop their services to cope with emergency situations where their address must change. I hope this article helps you understand what regular keys are and how to register and use regular keys using the CodeChain SDK.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2e358658405d" width="1" height="1"><hr><p><a href="https://medium.com/codechain/codechain-and-regular-key-2e358658405d">CodeChain and Regular Key</a> was originally published in <a href="https://medium.com/codechain">CodeChain</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Facilitate Secret Key Management with KeyStore CLI]]></title>
            <link>https://medium.com/codechain/facilitate-secret-key-management-with-keystore-cli-17a77cc03909?source=rss-b7860e5e0b63------2</link>
            <guid isPermaLink="false">https://medium.com/p/17a77cc03909</guid>
            <category><![CDATA[chaincode]]></category>
            <category><![CDATA[keystore]]></category>
            <category><![CDATA[nodejs]]></category>
            <dc:creator><![CDATA[Park Juhyung]]></dc:creator>
            <pubDate>Fri, 26 Apr 2019 11:38:57 GMT</pubDate>
            <atom:updated>2019-04-28T09:27:32.793Z</atom:updated>
            <content:encoded><![CDATA[<p>If you build an app based on blockchains, the first thing you would do is create a secret key. You can transfer coins with the secret key you’ve created. If you lose your secret key, not only will you lose your coins, but will also render already revealed public keys useless. Therefore, keeping your secret key safe is critical.</p><p>However, managing the secret key is not a seamless task. It doesn’t feel safe to simply convert the key into a string format and store it into a hard drive, but it doesn’t mean that you’d want to go out of your way to create an encryption format. What you want is a tool that can safely store your private key and allow you to take it out in a simple way when you need it.</p><figure><img alt="" src="https://cdn-images-1.medium.com/proxy/1*rBkWrK2XOJPGZp0pGW6jTw.jpeg" /><figcaption>Photo by Luka Siemionov from Pexels</figcaption></figure><h4>CodeChain KeyStore CLI’s task</h4><p>CodeChain’s KeyStore CLI allows you to easily create and manage secret keys using the command line interface. Basic encryption is provided by allowing the user to lock the secret key with a passphrase. You can load the file created in the CLI through the CodeChain SDK and use the secret key easily when you need it.</p><p>Let’s practice the following:</p><ol><li>Create a platform account and an asset account using the KeyStore CLI.</li><li>Within the SDK, by using an account created through the KeyStore CLI, you can create your own assets in CodeChain.</li></ol><h3>Install KeyStore CLI</h3><p>You can install the CodeChain KeyStore by either using the JavaScript package manager or downloading the pre-built binary file. You can use the installation method of your choice.</p><p><strong>Install with npm</strong></p><pre>npm install -g codechain-keystore-cli</pre><p><strong>Install with yarn</strong></p><pre>yarn global add codechain-keystore-cli</pre><h4>Download binary file</h4><p>You can install the binary file from this <a href="https://github.com/CodeChain-io/codechain-keystore-cli/releases">link</a>.</p><h4>Test the executable file</h4><p>If the installation was successful, you can use the KeyStore CLI by using the <em>cckey</em> command. The command below is the simplest command that you can type on the terminal. It verifies the version of the KeyStore CLI currently installed.</p><pre>cckey --version</pre><h3>Create a project</h3><p>The KeyStore CLI stores the key file in the current directory. Since we plan to use the CodeChain SDK, we set up the nodejs development environment in advance and then create an account.</p><p>In the terminal, enter the following command to create the directory and create the nodejs project:</p><pre>mkdir keystore-example<br>cd keystore-example<br>npm init<br>npm install --save codechain-sdk@&quot;^1.2.0&quot;</pre><h3>Create an account</h3><p>Here is how to create a platform account and an asset account.</p><h4>Platform accounts and asset accounts</h4><p>CodeChain has two types of accounts depending on the purpose. One type of account is called a platform account that pays for the processing fees in order to process the parcels. The other type of account is called an asset account, which enables you to own or trade assets that were originally published on CodeChain. The upcoming examples create and use both types of accounts.</p><h4>Create a platform account</h4><p>Create a platform account by using the following command. The newly created account is created in the working directory when the command was executed. If this command succeeds, a <em>keystore.db</em> file is created in the directory.</p><pre>cckey create -t platform --network-id cc</pre><p>The -t platform option specifies the creation of a platform account.</p><p>The --network-id option specifies the network that the account will be created in.</p><p>CodeChain manages different networks depending on the purpose or goal, and the type of accounts used in each network will vary as well. In this example, we will use “cc” since we will create an account for the main network.</p><p>After creating an account, you can use the following command to see all of the accounts managed by the KeyStore CLI:</p><pre>cckey list -t platform --network-id cc</pre><h4>Receive CCC in your platform account</h4><p>We need more than 100,100 CCC as the processing fee in order to send assets with the platform account created above. You can buy CCC using BTC or ETH, and the instructions are <a href="https://medium.com/codechain/charging-ccc-in-codechain-wallet-c6443b8b9b18">here</a>. If you purchased CCC, then send CCC to the address you created by using the CodeChain KeyStore CLI.</p><h4>Create an asset account</h4><p>You need an asset account to own and transfer assets in CodeChain.</p><p>Use the following command to create an asset account:</p><pre>cckey create -t asset --network-id cc</pre><p>You can check the created accounts with the following command:</p><pre>cckey list -t asset --network-id cc</pre><h3>Using a file generated from KeyStore CLI in CodeChain SDK</h3><p>The account you created earlier is easy to use in the CodeChain SDK.</p><h4>Read</h4><p>Create the read_example.js file with the contents below and execute it with `node read_keystore.js`.</p><p>This is the code that makes the createLocalKeyStore function read the file that was generated by the KeyStore CLI. Enter the path of the file generated by the KeyStore CLI as the argument of the createLocalKeyStore function. In this example, we use the value “<em>keystore.db</em>” since we used the default file name.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/5166776e2d6f08df26c61cbceb5acc34/href">https://medium.com/media/5166776e2d6f08df26c61cbceb5acc34/href</a></iframe><h4>Signing</h4><p>Any value can be signed using the keys created by the KeyStore CLI.</p><p>Run sign_example.js as shown in the example below. For the passphrase variable, assign it with the passphrase that you used earlier when creating the platform key.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/53dde43e1d799ea075fa9dd20b8bbcd0/href">https://medium.com/media/53dde43e1d799ea075fa9dd20b8bbcd0/href</a></iframe><h4>Publishing assets</h4><p>The following example shows how to create a new asset with the key of the platform account created earlier in the KeyStore CLI and the key of the asset account.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/7812a71b62f96ea87bbf63fabbbf48fa/href">https://medium.com/media/7812a71b62f96ea87bbf63fabbbf48fa/href</a></iframe><h3>Conclusion</h3><p>If you wish to create an application using CodeChain, the simplest way to manage keys is to use to KeyStore CLI. It allows you to generate and manage keys in a simple manner, and easily read from the SDK. If you are interested in CodeChain, you should definitely give the KeyStore CLI a shot.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=17a77cc03909" width="1" height="1"><hr><p><a href="https://medium.com/codechain/facilitate-secret-key-management-with-keystore-cli-17a77cc03909">Facilitate Secret Key Management with KeyStore CLI</a> was originally published in <a href="https://medium.com/codechain">CodeChain</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Block Sync Design for Supporting both PoW and Tendermint]]></title>
            <link>https://medium.com/codechain/block-sync-design-for-supporting-both-pow-and-tendermint-bec4a848017c?source=rss-b7860e5e0b63------2</link>
            <guid isPermaLink="false">https://medium.com/p/bec4a848017c</guid>
            <category><![CDATA[blockchain]]></category>
            <category><![CDATA[chaincode]]></category>
            <category><![CDATA[blocksync]]></category>
            <dc:creator><![CDATA[Park Juhyung]]></dc:creator>
            <pubDate>Fri, 26 Apr 2019 08:18:31 GMT</pubDate>
            <atom:updated>2019-04-26T08:33:02.496Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*BBFhg-LkqfpbgUJH" /><figcaption>Photo by<a href="https://unsplash.com/photos/CHAFV-0U7b8?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText"> Charlie Marusiak</a> on<a href="https://unsplash.com/search/photos/delivery?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText"> Unsplash</a></figcaption></figure><p>PoW (Proof of Work) is a consensus algorithm used by Bitcoin and Ethereum. All nodes will continue to run random computations until a certain score is reached. If the calculation is successful, it propagates successful results and blocks to the network through block synchronization. When other nodes receive a successful block, they build a new block over that block and repeat the random calculation again.</p><p><a href="https://allquantor.at/blockchainbib/pdf/buchman2016tendermint.pdf">Tendermint Consensus</a> is a BFT style consensus algorithm, in which a predetermined number of validation nodes negotiate blocks through the steps of <em>Propose</em>, <em>Pre-vote</em>, and <em>Pre-commit</em>. Each validator node becomes a proposer according to a predetermined order and generates a proposal block and propagates it to other nodes. The non-proposer validator nodes process a <em>Pre-vote</em> vote, a <em>Pre-commit</em> vote to determine the block. Finally, a proposal block that receives 2/3 or more <em>Pre-commit</em> votes of all nodes is committed and included in the chain.</p><p>The CodeChain mainnet uses the Tendermint consensus, but CodeChain itself is a blockchain engine that supports both Tendermint and PoW. Block synchronization, transaction propagation, block and transaction verification, and block generation code share the same implementation in both consensuses.</p><p>This article summarizes the problems and solutions we have encountered while designing and implementing block-synchronization code that works well with both Tendermint and PoW consensus.</p><h4>Storing Precommits in the Chain.</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/733/0*8_OfoH8twkVHhCH0" /><figcaption>(Figure 1 The Pre-commit for the current proposal is included in the current block. The contents of the pre-commits’ fields of the proposal block and the confirmed block are different.)</figcaption></figure><p>The blocks in Tendermint must contain more than ⅔ of pre-commits about that block in order to be confirmed, and thus, the chain must store the blocks’ pre-commits. The most intuitive way is to store the pre-commit in the header of the block. Each node collects 2/3 or more pre-commits, completes the block, and propagates the completed block through block synchronization. With this method, it is easy to synchronize blocks because you can verify the validity of the block with the information in the block just like PoW.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/899/0*tlVrOOEaRbjj2KfQ" /><figcaption>(Figure 2 Blocks with three or more pre-commits each, when the total number of validation nodes is four. They are all valid blocks, but each hash value is different.)</figcaption></figure><p>However, this method has problems when calculating the hash of the block. If you calculate the hash of a block, including all the pre-commits in the block, there would be several valid blocks at a height, each containing slightly different pre-commits. This would be a violation since a fixed block of a certain height must have a single hash.</p><p>Another way to calculate a block hash is to use the hash of the block excluding the pre-commit in the block, as a hash of the block. At this point, a block with 2/3 or more pre-commit separate from the block hash becomes a valid block. With this approach, the pre-commit in the blocks for each node in the network changes slightly. However, because the pre-commit content in the block is used to penalize nodes that have not participated in the consensus later, all nodes must have the same content. Therefore, there is no way to calculate the hash of a block without pre-commits.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/742/0*6zQiPbjRNJYNyGij" /><figcaption>(Figure 3: The pre-commits for the previous block are contained in the next block. The contents of the proposal block and the confirmed block are the same.)</figcaption></figure><p>To solve this problem, we included the pre-commit of the previous block in the header of the next block. Using this method, a proposer that has seen more than 2/3 of the pre-commits of the previous block will create the block with those pre-commits stored in the next block. With this method, the hash of the proposal and the committed block is the same, and all nodes share the same pre-commit. Instead, there always has to be a block ahead in order to confirm the previous block.</p><h4>Is It Possible to Propagate a Block that Does Not Have a Pre-commit</h4><p>Block synchronization is the process by which each node shares the block with the highest score (best block) that it knows. Each node shares its score with connected nodes whenever it changes the block with the highest score that it knows, and requests for a block if the score of the other node is higher than its score.</p><p>The block score refers to the difficulty of mining in the PoW consensus and the height of the block in the Tendermint consensus. (If there are multiple proposals at the same block height in Tendermint consensus, there will be some arbitrary score amongst the proposals. I will skip this topic because it is not important for this article). When a block is well synchronized, the blocks with the highest score of the connected nodes become equal.</p><p>However, since blocks can only be verified if there exists a next block, even if the node has propagated the highest-scoring block known to it, it is impossible for the node receiving that block to verify it. Therefore, the latest updated block is different for each connected node.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/355/0*60rUg3c96qzKCzOo" /><figcaption>(Figure 4 If you do not have a Best Proposal Block, you can not deliver the most recent block’s pre-commit, making it impossible to adjust the height between nodes.)</figcaption></figure><p>For example, let’s say that node A has a height of 3 and node B has a height of 5 as shown in Figure 4. Even if node A receives blocks of height 4 and 5 from B, since it cannot retrieve the pre-commits of height 5, and thus, the height of A becomes 4. Node A can never be at the same height as Node B, since the pre-commit of the chain’s latest block can never exist.</p><h4>Best Block and Best Proposal Block</h4><p>The CodeChain team introduced a best proposal block, which is different from the best block, to solve this problem. Best proposal block is defined as the block that has the highest score among the blocks that are not yet confirmed but are likely to be confirmed. In the PoW consensus, the best proposal block is always the best block, and in the Tendermint consensus, the proposal block becomes the best proposal block.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/357/0*4RVcFQ2izDrl1rGo" /><figcaption>(Figure 5 If you receive the Best Proposal Block, it is possible to adjust the height between nodes.)</figcaption></figure><p>Existing block synchronization technology only delivers to the best block, and the best block of the receiving node is one level below the best block of the delivering node. After introducing the best proposal block, each node delivers it to the best proposal block, and the node receiving the best proposal block reads the pre-commit of the best block from the best proposal block and verifies the best block. Now the blocks are safely synchronized all the way up to the best block.</p><p>For example, in Figure 5, Node A receives block 4, block 5, and proposal block 6. Block 4 is verified with the pre-commit in block 5 and block 5 is verified with the pre-commit of proposal block 6. Node A has a height of 5, and is the same height as Node B that delivered the block.</p><h4>Conclusion</h4><p>Consensus can be thought of as only a part of the process of making blocks come to an agreement in a blockchain, but it has major impacts on other components of the blockchain as well. The CodeChain team has also introduced a new concept called the best proposal block to implement block synchronization that works in both PoW and Tendermint.</p><p>CodeChain is currently running on the main network and the test network using the Tendermint consensus. You can see the block explorer at <a href="https://explorer.codechain.io">explorer.codechain.io</a> and <a href="https://corgi.codechain.io/explorer">corgi.codechain.io/explorer</a> for each respective network.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=bec4a848017c" width="1" height="1"><hr><p><a href="https://medium.com/codechain/block-sync-design-for-supporting-both-pow-and-tendermint-bec4a848017c">Block Sync Design for Supporting both PoW and Tendermint</a> was originally published in <a href="https://medium.com/codechain">CodeChain</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[How to access CodeChain Corgi testnet]]></title>
            <link>https://medium.com/codechain/how-to-access-codechain-corgi-testnet-810819740b82?source=rss-b7860e5e0b63------2</link>
            <guid isPermaLink="false">https://medium.com/p/810819740b82</guid>
            <category><![CDATA[blockchain]]></category>
            <category><![CDATA[chaincode]]></category>
            <dc:creator><![CDATA[Park Juhyung]]></dc:creator>
            <pubDate>Thu, 18 Apr 2019 09:40:35 GMT</pubDate>
            <atom:updated>2019-04-19T05:34:46.816Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*DhckBCm7BF6H1LQzJja7cQ.png" /></figure><p>Corgi is a test network of CodeChain. You can participate in the network by following the instructions below.</p><h4>Download CodeChain</h4><p>You can download the latest CodeChain binary from <a href="https://github.com/CodeChain-io/codechain/releases">this link</a>.</p><h4>Run CodeChain</h4><p>Please run CodeChain with the following command:</p><pre>ENABLE_ORDER=true ENABLE_DELEGATIONS=true ./codechain --chain corgi\<br>  --no-miner \<br>  --bootstrap-addresses &quot;52.68.160.158:3485&quot; &quot;52.87.80.242:3485&quot; &quot;13.52.125.202:3485&quot; &quot;18.184.72.190:3485&quot; &quot;13.124.7.55:3485&quot;</pre><ul><li><strong>chain</strong>: option to select which chain to use. The testnet uses Corgi chain</li><li><strong>bootstrap-address</strong>: default node address for finding a peer when a node is first launched</li><li><strong>no-miner</strong>: option to disable to create a block. This option is needed because we are running a non-validating node.</li></ul><h4>Check the CodeChain node</h4><p>You can check the node status by using JSON RPC. <em>chain_getBestBlock</em> RPC is the RPC that returns the biggest block number. By calling this RPC, you can check whether your node is in sync with the network or whether it is participating in the network without errors. The RPC can be called by using the following curl command:</p><pre>curl -XPOST localhost:8080 \<br>  -H ‘Content-type: application/json’ \<br>  --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:1,&quot;method&quot;:&quot;chain_getBestBlockNumber&quot;,&quot;params&quot;:[]}&#39;</pre><p>If you have successfully called the RPC, the following result will be returned:</p><pre>{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;: 137,&quot;id&quot;:1}</pre><p>The above output represents the latest block number. The output will increase each time you call the RPC until the value matches with the latest block number in the testnet. You can check the latest block number in the testnet block explorer (<a href="https://corgi.codechain.io/explorer/">https://corgi.codechain.io/explorer/</a>).</p><h4>Caution</h4><p>Your computer must have a public IP to participate in the testnet. If a node does not have a public IP, other nodes cannot access the network. Also, make sure that port 3485, which is used for P2P communication in CodeChain, is not blocked by a firewall.</p><h4>Conclusion</h4><p>It’s effortless to run CodeChain in your machine. Try to download and run it. You can use your CodeChain node by using <a href="https://github.com/CodeChain-io/codechain/blob/master/spec/JSON-RPC.md">RPC calls</a> or <a href="https://github.com/CodeChain-io/codechain-sdk-js">CodeChain SDK</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=810819740b82" width="1" height="1"><hr><p><a href="https://medium.com/codechain/how-to-access-codechain-corgi-testnet-810819740b82">How to access CodeChain Corgi testnet</a> was originally published in <a href="https://medium.com/codechain">CodeChain</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Rust Associated Type]]></title>
            <link>https://medium.com/codechain/rust-associated-type-b0193c22eacd?source=rss-b7860e5e0b63------2</link>
            <guid isPermaLink="false">https://medium.com/p/b0193c22eacd</guid>
            <category><![CDATA[associatedtype]]></category>
            <category><![CDATA[rust]]></category>
            <category><![CDATA[planets]]></category>
            <dc:creator><![CDATA[Park Juhyung]]></dc:creator>
            <pubDate>Tue, 16 Apr 2019 10:08:09 GMT</pubDate>
            <atom:updated>2019-04-16T11:02:03.355Z</atom:updated>
            <content:encoded><![CDATA[<h3>Associated Types in Rust</h3><p>Associated Types in Rust are similar to Generic Types; however, Associated Types limit the types of things a user can do, which consequently facilitates code management. Among the Generic Types of traits, types that depend on the type of trait implementation can be expressed by using the Associated Type syntax.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/716/1*SPKVQbBQTMpg2hNJz0hB6g.png" /><figcaption>Photo by Miguel Á. Padriñán from Pexels</figcaption></figure><p>By comparing the Associated and Generic Types, you can get a better understanding of Associated Types.</p><p>The Generic Type always has a <strong>&lt;&gt;</strong> attached, and moves together with it. However, the Associated Type does not specify anything after the type. For instance, if the type returned by the Iterator is Generic, the result would be <strong>Iterator&lt;Item&gt;</strong>. However, if you were to use the Associated Type, it would simply be <strong>Iterator</strong>.</p><p>Code using the Associated Type can be replaced with code using the Generic Type, but not the other way around. For example, if you want an easy way to convert <strong>i32</strong> type variables and <strong>i64</strong> type variables to <strong>BigInt</strong> types, the <strong>BigInt</strong> type would implement <strong>From&lt;i32&gt;</strong> and <strong>From&lt;i64&gt;</strong>. At this point, the FromType of <strong>From&lt;FromType&gt;</strong> can not be created as an Associated Type since one <strong>BigInt</strong> type can implement multiple <strong>From&lt;FromType&gt;</strong>.</p><p>By using Associated Types instead of Generic, you can reduce unnecessary code modifications. While writing code with Rust, you may run into a situation where you need to declare a new Generic Type in the middle of everything. In this case, you will need to fix a substantial amount of unrelated code as well. To be more specific, you will need to add Generic Type arguments to all functions from the point of creation of the values that the Generic Type uses, all the way until that value itself is deleted. However, if the type I want to add can be represented as an Associated Type, I can reduce unnecessary code modifications.</p><p>For example, let’s say that you’ve created the <strong>FromStr</strong> trait yourself, which creates an arbitrary type from a <strong>String</strong> value. An example is shown below, where the <strong>from_str</strong> function returns <strong>Self</strong> upon success and <strong>String</strong> upon failure.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/905753041e18eaf4c4bfa343fcc3bc59/href">https://medium.com/media/905753041e18eaf4c4bfa343fcc3bc59/href</a></iframe><p>The example above was decent; however, I wanted to express an <strong>Error</strong> type, which would hold more variety of information than <strong>String</strong>.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/766823f393361e01c004e47398946742/href">https://medium.com/media/766823f393361e01c004e47398946742/href</a></iframe><p>In order to solve this problem, I’ve tried the method as shown above. However, this requires me to fix the entire code. I need to add the <strong>Err</strong> type in every single instance where <strong>FromStr</strong> type is used.</p><p>The following code does not care about the <strong>Err</strong> type; however, even this code needs to be fixed!</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/e869b1c5476c0571050ee7b0bd3c7246/href">https://medium.com/media/e869b1c5476c0571050ee7b0bd3c7246/href</a></iframe><p>However, if you use AssociatedTypes, you do not need to modify the code of a function that have no relation to <strong>Err </strong>such as <strong>do_great_work</strong>.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/35b1efef67e0064183f1cdbc3efc4ae8/href">https://medium.com/media/35b1efef67e0064183f1cdbc3efc4ae8/href</a></iframe><p>CodeChain takes advantage of Associated Types in necessary situations. For example, <strong>CacheableItem</strong> trait is a trait that must be implemented by the type that will be used in the cache. This trait requires the <strong>Address</strong> type in order to find the correct value in the cache. You can declare this type as Generic, but it would be more natural to use the Associated Type. The reason is that there will never be an instance where one would use two different Addresses for a type that needs to be cached. You can check out the code discussed just now in the link below.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/6310127245446ce1a1c5b47f9d351104/href">https://medium.com/media/6310127245446ce1a1c5b47f9d351104/href</a></iframe><p><a href="https://github.com/CodeChain-io/codechain/blob/19e33691457bd65563f271091c4f78fcda7cbf4b/state/src/item/local_cache.rs#L28">CodeChain-io/codechain</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b0193c22eacd" width="1" height="1"><hr><p><a href="https://medium.com/codechain/rust-associated-type-b0193c22eacd">Rust Associated Type</a> was originally published in <a href="https://medium.com/codechain">CodeChain</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Javascript Crypto Library and  WebCrypto]]></title>
            <link>https://medium.com/codechain/javascript-crypto-library-and-webcrypto-5bb640b8fcc?source=rss-b7860e5e0b63------2</link>
            <guid isPermaLink="false">https://medium.com/p/5bb640b8fcc</guid>
            <category><![CDATA[webcrypto]]></category>
            <category><![CDATA[planets]]></category>
            <category><![CDATA[security]]></category>
            <category><![CDATA[engineering]]></category>
            <dc:creator><![CDATA[Park Juhyung]]></dc:creator>
            <pubDate>Thu, 17 Jan 2019 08:20:37 GMT</pubDate>
            <atom:updated>2019-01-17T08:26:10.205Z</atom:updated>
            <content:encoded><![CDATA[<h3>JavaScript Crypto Library and WebCrypto</h3><p>While creating the CodeChain Wallet, there was a situation where the UI would stall. While searching for the cause, we discovered that the secret key encryption process of the codechain-keystore, used to securely store the key, was slow, and we were able to improve this with a simple method.</p><figure><img alt="" src="https://cdn-images-1.medium.com/proxy/1*08KnqQi4CMsA_d2FQqoHnQ.jpeg" /><figcaption>Source: <a href="https://pixabay.com/en/castle-padlock-metal-capping-1461009/">pixabay.com</a></figcaption></figure><p>First, let me tell you about the situation when we discovered the problem. The <a href="https://github.com/CodeChain-io/codechain-keystore-js">codechain-keystore</a> is a library that manages the secret keys used by CodeChain. It takes the passphrase from the user and encrypts the secret ket and stores it in storage (hard disk, memory, brower’s storage). Since the key was encrypted using the passphrase given by the user, it is impossible to restore the secret key when a stored file is leaked without knowing the passphrase.</p><p>The problem occurred in the <a href="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a> function that the codechain-keystore used to encrypt the secret key. PBKDF2 uses a technique called <a href="https://en.wikipedia.org/wiki/Key_stretching">key stretching</a> to prevent <a href="https://en.wikipedia.org/wiki/Brute-force_attack">brute-force attack</a>. Key stretching is a technique that repeats hashing to make it difficult for a hacker to guess a password with a simple brute-force attack, even when passphrases are short. PBKDF2 is time-consuming because it computes the hash repeatedly, and can cause the UI to stop running at the web browser. Because the web browser runs JavaScript as a single thread, JavaScript will stop the UI if you perform a lot of operations without returning to the event loop. In the early implementations of the codechain-keystore, the wallet’s UI was paused because of the hash calculation of PBKDF2.</p><p>We used the Web Crypto API provided by web browsers in order to solve this problem. The Web Crypto API is a standard defined by the W3C and is supported by most browsers you are using now.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*RKdzTtnqZBvpri3R" /><figcaption><a href="https://caniuse.com/#feat=cryptography">https://caniuse.com/#feat=cryptography</a></figcaption></figure><p>As you can see in the figure above, you can use the Web Crypto API in browsers used by 91% of the world’s users. However, since it can only be used in SecureContext(<a href="https://github.com/w3c/webcrypto/issues/28">link</a>), it can only be used on sites on localhost or sites connected via https. Therefore, when you connect to the development server via http, WebCrypto cannot be used and can be slowed, so be careful when you check performance.</p><p>However, simply using the WebCrypto API in all situations does not solve all the problems. A small number may not support the WebCrypto API at all, and the algorithms supported by each browser may vary slightly. Therefore, you should have a library that will be used as a fallback if necessary, and you should also consider situations that will work in a nodejs environment.</p><p>Since the codechain-keystore is a library used not only in web browsers but also in nodejs of server environment, it was necessary to use a different crypto library depending on the environment. We should use the Web Crypto API in a Web browser environment and the native library in a nodejs environment. We used <a href="https://github.com/crypto-browserify/crypto-browserify">crypto-browserify</a> for this purpose. Crypto-browserify is a wrapper for the <a href="https://nodejs.org/api/crypto.html">Crypto API</a> provided by the node, which changes the crypto library provided by the node into code that can be executed from a web browser. The PBKDF2 functions provided by crypto are pbkdf2Sync and pbkdf2. Among them, pbkdf2Sync calls the JavaScript implementation provided by crypto-browserify, and pbkdf2 calls the Web Crypto API. Therefore, there is no difference in speed between crypto.pbkdf2 and crypto.pbkdf2Sync in a nodejs environment, but the speed difference is very large in the latest version of the browser. Therefore, we recommend that you verify that your crypto library supports the Web Crypto API for your browser.</p><figure><img alt="" src="https://cdn-images-1.medium.com/proxy/0*t9xEFHq1diza0jZ8" /></figure><p>Since the blockchain field is distributed, each client needs to be concerned about security. Inevitably, you will have to use the crypto libraries, but since there is no crypto library that works seamlessly on all web browsers, you should use a mix of library to suit your situation. We hope that our experience will help other blockchain developers out there.</p><p>This blog is translated by <a href="https://medium.com/u/9f88b5a6c010">Seung Woo Kim</a>. Thanks!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5bb640b8fcc" width="1" height="1"><hr><p><a href="https://medium.com/codechain/javascript-crypto-library-and-webcrypto-5bb640b8fcc">Javascript Crypto Library and  WebCrypto</a> was originally published in <a href="https://medium.com/codechain">CodeChain</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Javascript Crypto라이브러리와 WebCrypto]]></title>
            <link>https://medium.com/codechain-kr/javascript-crypto%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%99%80-webcrypto-cc24eb972978?source=rss-b7860e5e0b63------2</link>
            <guid isPermaLink="false">https://medium.com/p/cc24eb972978</guid>
            <category><![CDATA[webcrypto]]></category>
            <category><![CDATA[engineering]]></category>
            <category><![CDATA[chaincode]]></category>
            <dc:creator><![CDATA[Park Juhyung]]></dc:creator>
            <pubDate>Thu, 10 Jan 2019 07:48:12 GMT</pubDate>
            <atom:updated>2019-01-10T09:47:11.561Z</atom:updated>
            <content:encoded><![CDATA[<h3>JavaScript Crypto라이브러리와 WebCrypto</h3><p>코드체인 지갑을 만드는 도중, UI가 멈추는 상황이 발생했습니다. 원인을 찾아보던 중 안전하게 키를 저장하기 위해 사용한 codechain-keystore의 비밀키 암호화 과정이 느리다는 걸 발견하고, 이를 간단한 방법으로 개선했습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*08KnqQi4CMsA_d2FQqoHnQ.jpeg" /><figcaption>Source: <a href="https://pixabay.com/en/castle-padlock-metal-capping-1461009/">pixabay.com</a></figcaption></figure><p>먼저, 저희가 발견했던 문제 상황을 설명해드리겠습니다. <a href="https://github.com/CodeChain-io/codechain-keystore-js">codechain-keystore</a>는 코드체인에서 사용하는 비밀키를 관리해주는 라이브러리입니다. 사용자로부터 passphrase를 받아 비밀키를 암호화하여 스토리지(하드 디스크, 메모리, 브라우저의 스토리지)에 저장합니다. 유저로부터 passphrase를 받아 암호화를 했기 때문에, 저장된 파일이 유출 되더라도 passphrase를 알지 못하면 비밀키를 복원할 수 없습니다.</p><p>문제는 codechain-keystore가 비밀키를 암호화하는 데 사용했던 <a href="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a> 함수에서 발생했습니다. PBKDF2는 <a href="https://en.wikipedia.org/wiki/Brute-force_attack">brute-force attack</a>을 방지하기 위해 <a href="https://en.wikipedia.org/wiki/Key_stretching">key stretching</a> 이라는 기법을 사용합니다. Key stretching이란 해싱을 반복해 사용자가 간단한 암호를 사용해도 brute-force attack으로 암호를 유추하기 어렵게 만드는 기법을 말합니다. PBKDF2는 해시를 반복적으로 계산하기 때문에 시간이 많이 소요되며, 웹브라우저에서 실행 시 UI를 멈추게 할 수 있습니다. 웹브라우저는 자바스크립트를 싱글 쓰레드로 동작시키기 때문에, 자바스크립트에서 이벤트 루프로 리턴하지 않고 많은 연산을 하면 UI가 멈추게 됩니다. codechain-keystore의 초기 구현에서도 PBKDF2의 해시계산 때문에 지갑의 UI가 잠시 멈추는 문제가 있었습니다.</p><p>저희는 이 문제를 해결하기 위해 웹브라우저에서 제공하는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API">Web Crypto API</a>를 사용하였습니다. Web Crypto API는 W3C에서 정의된 표준으로 지금 사용 중인 브라우저 대부분이 이를 지원합니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*RKdzTtnqZBvpri3R" /><figcaption><a href="https://caniuse.com/#feat=cryptography">https://caniuse.com/#feat=cryptography</a></figcaption></figure><p>위 그림에서 알 수 있듯이, 전 세계의 91%의 유저들이 사용하는 브라우저에서 Web Crypto API를 사용할 수 있습니다. 단, SecureContext에서만 사용할 수 있기 때문에(<a href="https://github.com/w3c/webcrypto/issues/28">link</a>) localhost나 https로 접속한 사이트에서만 사용 가능합니다. 즉, http로 연결된 사이트에서는 Web Crypto API를 사용할 수 없습니다. 따라서 개발용 서버에 http로 접속하는 경우 WebCrypto를 사용하지 못해 느려질 수 있으니 성능을 점검할 때 주의해야 합니다.</p><p>하지만 단순히 모든 상황에서 WebCrypto API를 사용하는 것으로 모든 문제가 해결되지 않습니다. 소수지만 WebCrypto API를 전혀 지원하지 않는 상황일 수도 있고, 브라우저마다 지원하는 알고리즘들이 조금씩 다를 수 있습니다. 따라서 필요한 경우 fallback으로 쓰일 라이브러리가 있어야 하며, 상황에 따라 nodejs 환경에서 동작하는 상황도 고려해야 합니다.</p><p>codechain-keystore는 웹 브라우저뿐만 아니라 서버 환경의 nodejs에서도 사용되는 라이브러리이기 때문에 환경에 따라서 다른 crypto 라이브러리를 사용해야 했습니다. 웹브라우저 환경에서는 Web Crypto API를, nodejs 환경에서는 빠른 속도를 낼 수 있는 native라이브러리를 사용해야 합니다. 저희는 이를 위해 <a href="https://github.com/crypto-browserify/crypto-browserify">crypto-browserify</a>를 사용했습니다. crypto-browserify는 node에서 제공하는 <a href="https://nodejs.org/api/crypto.html">Crypto API</a>의 wrapper로, node가 제공하는 crypto 라이브러리를 웹 브라우저에서 실행할 수 있는 코드로 변경해줍니다. crypto가 제공하는 PBKDF2 함수는 pbkdf2Sync와 pbkdf2 두 가지 있습니다. 이 중 pbkdf2Sync를 사용하면 crypto-browserify가 제공하는 자바스크립트 구현체를 호출하고, pbkdf2를 사용하면 Web Crypto API를 호출합니다. 때문에 nodejs 환경에서는 crypto.pbkdf2와 crypto.pbkdf2Sync의 속도 차이가 없지만, 최신 버전의 브라우저에서는 속도의 차이가 매우 큽니다. 따라서 사용하는 crypto 라이브러리가 브라우저를 위한 Web Crypto API 지원을 하는지 확인하고 사용하는 것이 좋습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*t9xEFHq1diza0jZ8" /></figure><p>블록체인 분야는 분산되어있기 때문에 각 클라이언트가 보안을 신경 써야 합니다. 필연적으로 crypto 라이브러리들을 사용해야 하지만, 모든 웹브라우저에서 빠르게 잘 동작하는 crypto 라이브러리는 없으므로, 자신의 상황에 맞게 여러 라이브러리를 조합해서 사용해야 합니다. 저희의 경험이 다른 블록체인 개발자분들에게 도움이 되길 바랍니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=cc24eb972978" width="1" height="1"><hr><p><a href="https://medium.com/codechain-kr/javascript-crypto%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%99%80-webcrypto-cc24eb972978">Javascript Crypto라이브러리와 WebCrypto</a> was originally published in <a href="https://medium.com/codechain-kr">코드체인</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[현재 코드박스에서 풀타임 근무를 하고 있습니다.]]></title>
            <link>https://medium.com/@majecty/%ED%98%84%EC%9E%AC-%EC%BD%94%EB%93%9C%EB%B0%95%EC%8A%A4%EC%97%90%EC%84%9C-%ED%92%80%ED%83%80%EC%9E%84-%EA%B7%BC%EB%AC%B4%EB%A5%BC-%ED%95%98%EA%B3%A0-%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4-50fa0ea87967?source=rss-b7860e5e0b63------2</link>
            <guid isPermaLink="false">https://medium.com/p/50fa0ea87967</guid>
            <dc:creator><![CDATA[Park Juhyung]]></dc:creator>
            <pubDate>Tue, 30 Oct 2018 02:52:51 GMT</pubDate>
            <atom:updated>2018-10-30T02:52:51.706Z</atom:updated>
            <content:encoded><![CDATA[<p>현재 코드박스에서 풀타임 근무를 하고 있습니다.</p><p>별도로 제작 의뢰는 받지 않고 있습니다.</p><p>감사합니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=50fa0ea87967" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>