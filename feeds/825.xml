<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
<title>PS 이야기</title>
<link>https://blog.myungwoo.kr/</link>
<description>Problem Solving 공부를 하다</description>
<language>ko</language>
<pubDate>Mon, 13 May 2019 19:37:57 +0900</pubDate>
<generator>TISTORY</generator>
<managingEditor>전명우</managingEditor>
<image>
<title>PS 이야기</title>
<url>http://cfile2.uf.tistory.com/image/273FB34256BB0B25191682</url>
<link>https://blog.myungwoo.kr</link>
<description>Problem Solving 공부를 하다</description>
</image>
<item>
<title>IOI 2018 Day 2 문제 및 해법</title>
<link>https://blog.myungwoo.kr/125</link>
<description>&lt;p&gt;문제: &lt;a href=&quot;https://ioi2018.jp/competition/tasks/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;공식 홈페이지&lt;/a&gt;&lt;/p&gt;&lt;p&gt;채점: &lt;a href=&quot;https://contest.yandex.com/ioi/contest/8937/enter/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Yandex&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;1. doll&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;0번 정점을 시작점이라고 부르고 0번 정점은 나가는 간선이 정확히 1개다.&amp;nbsp;1번부터 M번까지 번호가 매겨진&amp;nbsp;나가는 간선이 정확히 1개인 트리거 정점 M개가 존재한다. 그리고 스위치라고 불리는 정점들은 번호가 음수로, 개수가 S개일 때, -1번부터 -S번까지 번호가 매겨진다. 스위치 정점은 나가는 간선이 정확히 2개이며 스위치 상태가 'X'일 때는 'X'로 표시된 간선으로 나가게 되며, 스위치 상태가 'Y'일 때는 'Y'로 표시된 간선으로 나가게 된다. 정점을 나가면서 동시에 스위치 정점의 상태가 뒤집힌다. 초기 0번 정점에서 이동을 시작하며, 이동을 하다가 다시 처음 0번 정점으로 돌아오는 순간 모든 스위치 정점의 상태는 'X'여야하며 트리거 정점은 정확히 N번 방문해야하며, 방문한 순서가 주어진다. 이렇게 이동할 수 있도록 스위치 정점을 적게 사용하여 회로를 구성하는 문제다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 문제에서 제일 핵심이 되는 문장은&amp;nbsp;&quot;다시 시작점으로 돌아왔을 때 모든 스위치의 상태가 초기 상태와 같아야한다&quot;다. 이 조건을 통해, 스위치들을 정점으로 한 루트가 있는 이진트리를 구성하면 어떨까 라는 생각을 할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;문제에서 주어진 예제처럼 트리거 정점의 개수&amp;nbsp;M=4개, 방문한 트리거 정점의 수 N=4개이며, 방문한 순서는 [1, 2, 1, 3]이라고 하자. 이 때, 다음과 같이 스위치 정점들을 통해 루트가 있는 이진트리를 생각할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:500px;width: 500px; height: 398px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99145C4A5B90F65335&quot; filemime=&quot;image/jpeg&quot; filename=&quot;doll-그림1.png&quot; height=&quot;398&quot; style=&quot;width: 500px; height: 398px;&quot; width=&quot;500&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;위 그림에서 스위치로 구성된 이진트리의 높이 $k=3$이라고 하자 이진트리 높이 $k$는 $2^k \geq N+1$를 만족하는 가장 작은 $k$로 결정한다. 그리고 불필요한 정점들을 최대한 제거한다. 그러면 사용한 스위치의 개수는 $N + \log_{2} N$이하가 되며, -1번 정점에 총 $2^k$번 방문하게 되며 다시 시작점 0번 정점으로 돌아갔을 때 모든 스위치의 상태는 'X'가 되고, 트리거 정점의 방문 순서 또한 주어진대로 만들 수 있다.&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이진트리를 그리는 자세한 방법은 코드를 참고하자.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more125_0&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '125_0','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content125_0&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &quot;doll.h&quot;

#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

const int MAXK = 1&amp;lt;&amp;lt;18;
#define pb push_back
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(), (v).end()

int N, M, K, H;
int IDX, num[MAXK];
int nxt[MAXK][2];

struct LEAF {
    int order;
    int node_num, sw;
};
vector &amp;lt;LEAF&amp;gt; leaves;

void make_tree(int n, int&amp;amp; left, int o, int l)
{
    if (!left) return;
    num[n] = ++IDX;

    if (n&amp;lt;&amp;lt;1 &amp;gt;= K){
        nxt[IDX][0] = nxt[IDX][1] = -1;
        leaves.pb({o, IDX, 0});
        leaves.pb({o|l, IDX, 1});
        left--;
        return;
    }

    make_tree(n+n+1, left, o|l, l&amp;lt;&amp;lt;1);
    nxt[num[n]][1] = num[n+n+1] ? -num[n+n+1] : -1;

    make_tree(n+n, left, o, l&amp;lt;&amp;lt;1);
    nxt[num[n]][0] = num[n+n] ? -num[n+n] : -1;
}

void create_circuit(int M, vector&amp;lt;int&amp;gt; A)
{
    ::M = M; ::N = sz(A);
    for (H=1;;H++)
        if (1&amp;lt;&amp;lt;H &amp;gt; N) break;
    K = 1&amp;lt;&amp;lt;H;
    int left = (N&amp;gt;&amp;gt;1)+1; make_tree(1, left, 0, 1);
    sort(all(leaves), [](const LEAF &amp;amp;a, const LEAF &amp;amp;b){
        return a.order &amp;lt; b.order;
    });
    for (int i=0;i&amp;lt;N;i++){
        auto &amp;amp;l = leaves[i];
        nxt[l.node_num][l.sw] = A[i];
    }
    auto &amp;amp;l = leaves.back();
    nxt[l.node_num][l.sw] = 0;

    vector &amp;lt;int&amp;gt; C(M+1, -1), X(IDX, 0), Y(IDX, 0);
    for (int i=0;i&amp;lt;IDX;i++)
        X[i] = nxt[i+1][0], Y[i] = nxt[i+1][1];

    answer(C, X, Y);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3&gt;2. highway&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;N개의 정점과 M개의 간선으로 이루어진 무방향성 그래프가 주어진다. ask 함수를 통해 각 간선의 가중치를 A 혹은 B로 설정했을 때, 정점 S와 정점 T&amp;nbsp;사이의 최단 거리를 알 수 있다. ask 함수 호출 횟수가 제한적일 때, ask 함수 호출을 통해 적절한 정보를 얻어 정점 S와 T가 어떤 정점인지를 알아내는 문제다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;font-size: 18px; font-weight: bold; margin-bottom: 10px !important;&quot;&gt;Subtask 1 (총 5점)&lt;/p&gt;&lt;p&gt;ask 함수는 최대 100번 호출할 수 있고, 주어지는 그래프는 트리이며, N ≤ 100 이고, S = 0이다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;모든 정점에 대해 그 정점이 T인지 확인을 해볼 수 있다. 정점 S와 정점 T 사이의 거리(간선 가중치 거리가 아닌 경로에 있는 간선 개수) $d$는 모든 간선의 가중치를 A로 두고 ask 함수 호출을 하면 알 수 있다. 그리고 정점 i에 대해 정점 T가 되는지 확인을 하는데, 정점 i가 정점 T인지 확인하기 위해서, 정점 S에서 정점 i까지 가는 모든 간선의 가중치를 B로 두고, 나머지 간선의 가중치는 A라고 두었을 때 거리가 $d \times B$가 되면 정점 i는 정점 T가 되는 것이 확실하다. 함수 호출 횟수는 최대 N번이 된다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;font-size: 18px; font-weight: bold; margin-bottom: 10px !important;&quot;&gt;Subtask 2&amp;nbsp;(총 12점)&lt;/p&gt;&lt;p&gt;ask 함수는 최대 60번 호출할 수 있고, 주어지는 그래프는 트리이며, S = 0이다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;정점 S와의 거리를 기준으로 오름차순으로 정점들을 정렬한 다음에, 이분탐색을 통해 정점 T를 찾을 수 있다. 함수 호출 횟수는 최대 $1 + \lceil\log_2 N\rceil = 18$번이 된다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more125_1&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '125_1','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content125_1&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &quot;highway.h&quot;

#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 90004
#define MAXM 130004
#define pb push_back
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(), (v).end()
typedef long long lld;

int N, M, A, B;
int U[MAXM], V[MAXM];
vector &amp;lt;int&amp;gt; con[MAXN];

lld C;
int dist[MAXN];

void bfs()
{
    for (int i=1;i&amp;lt;=N;i++) dist[i] = 2e9;
    queue &amp;lt;int&amp;gt; que;
    dist[1] = 0; que.push(1);
    while (!que.empty()){
        int q = que.front(); que.pop();
        for (int t: con[q])
            if (dist[t] == 2e9)
                dist[t] = dist[q]+1, que.push(t);
    }
}

int find(const vector&amp;lt;int&amp;gt; &amp;amp;arr)
{
    int s = 0, e = sz(arr)-1;
    while (s &amp;lt; e){
        int m = s+e &amp;gt;&amp;gt; 1;
        vector &amp;lt;bool&amp;gt; chk(N+1, 0);
        for (int i=m+1;i&amp;lt;=e;i++) chk[arr[i]] = 1;
        vector &amp;lt;int&amp;gt; w(M, 0);
        for (int i=0;i&amp;lt;M;i++) if (chk[U[i]] || chk[V[i]]) w[i] = 1;
        if (ask(w) &amp;gt; C) s = m+1;
        else e = m;
    }
    return arr[s];
}

void find_pair(int N, vector&amp;lt;int&amp;gt; U, vector&amp;lt;int&amp;gt; V, int A, int B)
{
    ::N = N, ::M = sz(U), ::A = A, ::B = B;
    for (int i=0;i&amp;lt;M;i++){
        ::U[i] = ++U[i], ::V[i] = ++V[i];
        con[U[i]].pb(V[i]);
        con[V[i]].pb(U[i]);
    }

    C = ask(vector&amp;lt;int&amp;gt;(M, 0));
    bfs();

    vector &amp;lt;int&amp;gt; arr;
    for (int i=1;i&amp;lt;=N;i++) arr.pb(i);
    sort(all(arr), [](const int &amp;amp;a, const int &amp;amp;b){
        return dist[a] &amp;lt; dist[b];
    });

    int s = 1, t = find(arr);
    answer(s-1, t-1);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;font-size: 18px; font-weight: bold; margin-bottom: 10px !important;&quot;&gt;Subtask 4&amp;nbsp;(총 51점)&lt;/p&gt;&lt;p&gt;ask 함수는 최대 60번 호출할 수 있고, 주어지는 그래프는 트리이며, S = 0이다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;한 번의 함수 호출을 통해 정점 S와 정점 T 사이의 거리 $d$를 알 수 있다. 그리고 정점 S와 정점 T 사이의 경로에 포함된 한 간선 e를 간선들의 집합에 대한 이분탐색을 통해 찾아낼 수 있다. 그리고 간선 e를 그래프에서 없애주어 그래프를 두 개의 서브트리로 나눈다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:600px;width: 600px; height: 231px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99BAE6355B91CF0229&quot; filemime=&quot;image/jpeg&quot; filename=&quot;highway-그림1.png&quot; height=&quot;231&quot; original=&quot;yes&quot; style=&quot;width: 600px; height: 231px;&quot; width=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;편의상 간선 e가 정점 x와 정점 y를 연결하는 간선이라고 하고, 또한 정점 x가 정점 S와 같은 서브트리 안에, 정점 y가 정점 T와 같은 서브트리 안에 있다고 하자. 정점 x가 있는 서브트리에 대해 Subtask 2와 동일한 상황이 되고,&amp;nbsp;마찬가지로 정점 y가 있는 서브트리에 대해 Subtask 2의 풀이와 동일하게 정점 S와 정점 T를 각각 독립적이게 찾을 수 있다. 따라서 총 함수 호출 횟수는 최대 $1 + 17 + 16 + 16&amp;nbsp;= 50$번이 된다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more125_2&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '125_2','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content125_2&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &quot;highway.h&quot;

#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 90004
#define MAXM 130004
#define pb push_back
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(), (v).end()
typedef long long lld;

int N, M, A, B;
int U[MAXM], V[MAXM];
vector &amp;lt;int&amp;gt; con[MAXN];

lld C; int X, Y;
int dist[2][MAXN];

int find_e()
{
    int s = 0, e = M-1;
    while (s &amp;lt; e){
        int m = s+e &amp;gt;&amp;gt; 1;
        vector &amp;lt;int&amp;gt; w(M, 0);
        fill(w.begin()+s, w.begin()+m+1, 1);
        if (ask(w) &amp;gt; C) e = m;
        else s = m+1;
    }
    return s;
}

void bfs(int n, int dist[], int r)
{
    for (int i=1;i&amp;lt;=N;i++) dist[i] = 2e9;
    queue &amp;lt;int&amp;gt; que;
    dist[n] = 0; que.push(n);
    while (!que.empty()){
        int q = que.front(); que.pop();
        for (int t: con[q]) if (t != r){
            if (dist[t] == 2e9)
                dist[t] = dist[q]+1, que.push(t);
        }
    }
}

int find(const vector&amp;lt;int&amp;gt; &amp;amp;arr)
{
    int s = 0, e = sz(arr)-1;
    while (s &amp;lt; e){
        int m = s+e &amp;gt;&amp;gt; 1;
        vector &amp;lt;bool&amp;gt; chk(N+1, 0);
        for (int i=m+1;i&amp;lt;=e;i++) chk[arr[i]] = 1;
        vector &amp;lt;int&amp;gt; w(M, 0);
        for (int i=0;i&amp;lt;M;i++) if (chk[U[i]] || chk[V[i]]) w[i] = 1;
        if (ask(w) &amp;gt; C) s = m+1;
        else e = m;
    }
    return arr[s];
}

void find_pair(int N, vector&amp;lt;int&amp;gt; U, vector&amp;lt;int&amp;gt; V, int A, int B)
{
    ::N = N, ::M = sz(U), ::A = A, ::B = B;
    for (int i=0;i&amp;lt;M;i++){
        ::U[i] = ++U[i], ::V[i] = ++V[i];
        con[U[i]].pb(V[i]);
        con[V[i]].pb(U[i]);
    }

    C = ask(vector&amp;lt;int&amp;gt;(M, 0));
    int e = find_e(); X = U[e], Y = V[e];
    bfs(X, dist[0], Y); bfs(Y, dist[1], X);
    
    vector &amp;lt;int&amp;gt; cx, cy;
    for (int i=1;i&amp;lt;=N;i++){
        if (dist[0][i] &amp;lt; 2e9) cx.pb(i);
        else cy.pb(i);
    }
    sort(all(cx), [](const int &amp;amp;a, const int &amp;amp;b){
        return dist[0][a] &amp;lt; dist[0][b];
    });
    sort(all(cy), [](const int &amp;amp;a, const int &amp;amp;b){
        return dist[1][a] &amp;lt; dist[1][b];
    });
    
    int s = find(cx);
    int t = find(cy);
    answer(s-1, t-1);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;font-size: 18px; font-weight: bold; margin-bottom: 10px !important;&quot;&gt;Subtask 6&amp;nbsp;(총 100 점)&lt;/p&gt;&lt;p&gt;ask 함수는 최대 50번 호출할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Subtask 4에서와 비슷한 방법으로 정점 S와 정점 T를 연결하는 최단 경로에 속한 임의의 간선 e를 구할 수 있다. 단, 정점 S와 정점 T를 연결하는 최단 경로가 여러 개가 존재할 수 있으므로 Subtask 4에서의 이분탐색을 살짝 보완해야한다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;편의상 간선 e가 정점 x와 정점 y를 연결하는 간선이라고 하자. 그리고 일반성을 잃지 않고 정점 S, x, y, T가 모두 속한 최단 경로에서 각 정점의 방문 순서가 S, x, y, T&amp;nbsp;순이라고 하자. 정점 S는 정점 y보다 정점 x와&amp;nbsp;더 가까울 것이며, 정점 T는&amp;nbsp;정점 x보다 정점 y와 더 가까울 것이다. 정점 y보다 정점 x와 더 가까운 정점들의 집합을 P라고 하고, 그렇지 않은 정점들의 집합을 Q라고 하자. 집합 P와 Q는 서로소 집합이고 집합 P와 집합 Q의 합집합은 전체 정점 집합이 된다. 자명히 정점 S는 집합 P에 있고, 정점 T는 집합 Q에 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;집합 P에 있는 정점들을 정점 x와의 최단 거리 기준으로 정렬해서 Subtask 2에서 했던 이분탐색으로 정점 S를 찾을 수 있다. 마찬가지로 집합 Q에 있는 정점들을 정점 y와의 최단 거리 기준으로 정렬해서 이분탐색으로 정점 T를 찾을 수 있다. 정리하면 Subtask 4에서 정점 x의 서브트리를 집합 P로 볼 수 있으며, 정점 y의 서브트리를 집합 Q로 보는 것과 같다. 즉, Subtask 4와 아주 비슷한 상황이 된다. 따라서 Subtask 4에서와 마찬가지로 최대 50번의 호출 안에 문제를 해결할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more125_3&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '125_3','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content125_3&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &quot;highway.h&quot;

#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 90004
#define MAXM 130004
#define pb push_back
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(), (v).end()
typedef long long lld;

int N, M, A, B;
int U[MAXM], V[MAXM];
vector &amp;lt;int&amp;gt; con[MAXN];

lld C; int X, Y;
int dist[2][MAXN];

int find_e()
{
    int s = 0, e = M-1;
    vector &amp;lt;int&amp;gt; w(M, 0);
    auto fill = [&amp;amp;w](int s, int e, int v){ ::fill(w.begin()+s, w.begin()+e+1, v); };
    while (s &amp;lt; e){
        int m = s+e &amp;gt;&amp;gt; 1;
        fill(s, m, 1);
        if (ask(w) &amp;gt; C) fill(s, m, 0), e = m;
        else s = m+1;
    }
    return s;
}

void bfs(int n, int dist[])
{
    for (int i=1;i&amp;lt;=N;i++) dist[i] = 2e9;
    queue &amp;lt;int&amp;gt; que;
    dist[n] = 0; que.push(n);
    while (!que.empty()){
        int q = que.front(); que.pop();
        for (int t: con[q])
            if (dist[t] == 2e9)
                dist[t] = dist[q]+1, que.push(t);
    }
}

int find(const vector&amp;lt;int&amp;gt; &amp;amp;arr)
{
    int s = 0, e = sz(arr)-1;
    while (s &amp;lt; e){
        int m = s+e &amp;gt;&amp;gt; 1;
        vector &amp;lt;bool&amp;gt; chk(N+1, 0);
        for (int i=m+1;i&amp;lt;=e;i++) chk[arr[i]] = 1;
        vector &amp;lt;int&amp;gt; w(M, 0);
        for (int i=0;i&amp;lt;M;i++) if (chk[U[i]] || chk[V[i]]) w[i] = 1;
        if (ask(w) &amp;gt; C) s = m+1;
        else e = m;
    }
    return arr[s];
}

void find_pair(int N, vector&amp;lt;int&amp;gt; U, vector&amp;lt;int&amp;gt; V, int A, int B)
{
    ::N = N, ::M = sz(U), ::A = A, ::B = B;
    for (int i=0;i&amp;lt;M;i++){
        ::U[i] = ++U[i], ::V[i] = ++V[i];
        con[U[i]].pb(V[i]);
        con[V[i]].pb(U[i]);
    }

    C = ask(vector&amp;lt;int&amp;gt;(M, 0));
    int e = find_e(); X = U[e], Y = V[e];
    bfs(X, dist[0]); bfs(Y, dist[1]);
    
    vector &amp;lt;int&amp;gt; cx, cy;
    for (int i=1;i&amp;lt;=N;i++){
        if (dist[0][i] &amp;lt; dist[1][i]) cx.pb(i);
        else cy.pb(i);
    }
    sort(all(cx), [](const int &amp;amp;a, const int &amp;amp;b){
        return dist[0][a] &amp;lt; dist[0][b];
    });
    sort(all(cy), [](const int &amp;amp;a, const int &amp;amp;b){
        return dist[1][a] &amp;lt; dist[1][b];
    });
    
    int s = find(cx);
    int t = find(cy);
    answer(s-1, t-1);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3&gt;3. meetings&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;N개의 산이 있고, 왼쪽부터 오른쪽까지 차례대로 0부터 N-1번까지 번호가 매겨져있다. 그리고 각 산에는 정확히 한 명씩 사람이 살고 있다. Q개의 모임이 있는데, i번째 모임은 L[i]번 산부터 R[i]번 산까지 살고 있는 모든 사람들을 한 곳에 모여야한다. 각 사람이 이동하면서 드는 비용은 이동 경로 위에 놓인 가장 높은 산의 높이만큼이고, 모임의 전체 비용은 모이는 각 사람의 비용 합이다. 문제는 각 모임마다 모임의 최소 비용을 구하는 것이다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;font-size: 18px; font-weight: bold; margin-bottom: 10px !important;&quot;&gt;Subtask 2&amp;nbsp;(총 19점)&lt;/p&gt;&lt;p&gt;N ≤ 5,000, Q ≤ 5,000&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;각 모임마다 $O(N)$ 시간복잡도로 최소 비용을 구하면 되며, 이는 왼쪽에서 오른쪽으로 가는 방향과 오른쪽에서 왼쪽으로 가는 방향, 두 방향에 대해 스택을 이용하여 비용을 계산할 수 있다. 전체 시간복잡도는 $O(QN)$이다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more125_4&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '125_4','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content125_4&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 5004
#define sz(v) ((int)(v).size())
typedef long long lld;

int N, Q;
int H[MAXN];
lld A[MAXN];

vector &amp;lt;lld&amp;gt; minimum_costs(vector&amp;lt;int&amp;gt; h, vector&amp;lt;int&amp;gt; L, vector&amp;lt;int&amp;gt; R)
{
    N = sz(h); Q = sz(L);
    if (N &amp;gt; 5000 || Q &amp;gt; 5000) return {};
    for (int i=1;i&amp;lt;=N;i++) H[i] = h[i-1];

    vector &amp;lt;lld&amp;gt; ans(Q);
    for (int i=0;i&amp;lt;Q;i++){
        int l = ++L[i], r = ++R[i];
        vector &amp;lt;int&amp;gt; stk; lld v = 0;
        for (int j=l;j&amp;lt;=r;j++){
            while (!stk.empty() &amp;amp;&amp;amp; H[stk.back()] &amp;lt;= H[j]){
                int t = stk.back(); stk.pop_back();
                int b = stk.empty() ? l-1 : stk.back();
                v -= (lld)H[t] * (t-b);
            }
            int b = stk.empty() ? l-1 : stk.back(); stk.push_back(j);
            v += (lld)H[j] * (j-b);
            A[j] = v;
        }
        stk.clear(); v = 0;
        for (int j=r;j&amp;gt;=l;j--){
            while (!stk.empty() &amp;amp;&amp;amp; H[stk.back()] &amp;lt;= H[j]){
                int t = stk.back(); stk.pop_back();
                int b = stk.empty() ? r+1 : stk.back();
                v -= (lld)H[t] * (b-t);
            }
            int b = stk.empty() ? r+1 : stk.back(); stk.push_back(j);
            v += (lld)H[j] * (b-j);
            A[j] += v;
        }

        ans[i] = 1e18;
        for (int j=l;j&amp;lt;=r;j++) ans[i] = min(ans[i], A[j]-H[j]);
    }
    return ans;
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;font-size: 18px; font-weight: bold; margin-bottom: 10px !important;&quot;&gt;Subtask 3&amp;nbsp;(누적&amp;nbsp;36점)&lt;/p&gt;&lt;p&gt;N ≤ 100,000, Q ≤ 100,000, H[i] ≤ 2&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 서브태스크에서는 높이가 1 또는 2로 두 종류만 있다. 그리디하게 생각해보면 모임 비용을 최소화하는 모임 장소는 $[L_i, R_i]$ 구간안에 있는 1로만 이루어진 가장 긴 부분구간에 있는 곳이다. Segment tree를 이용해 1로만 이루어진 가장 긴 부분구간의 크기를 구하면 문제를 해결할 수 있으며, 모임 당 시간복잡도는 $O(\lg N)$이고, 전체 시간복잡도는 $O((N+Q) \lg N)$이다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more125_5&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '125_5','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content125_5&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 100005
#define pb push_back
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(), (v).end()
typedef long long lld;

int N, Q;
int H[MAXN];

const int TS = 1&amp;lt;&amp;lt;18, ST = TS/2-1;
struct NODE {
    int ml, mr, ma; bool all;
} tree[TS];

void relax(NODE &amp;amp;n, const NODE &amp;amp;l, const NODE &amp;amp;r)
{
    n.all = l.all &amp;amp; r.all;
    n.ml = l.all ? l.ma + r.ml : l.ml;
    n.mr = r.all ? r.ma + l.mr : r.mr;
    n.ma = max({l.ma, r.ma, l.mr+r.ml});
}

vector &amp;lt;lld&amp;gt; minimum_costs(vector&amp;lt;int&amp;gt; h, vector&amp;lt;int&amp;gt; L, vector&amp;lt;int&amp;gt; R)
{
    N = sz(h); Q = sz(L);
    for (int i=1;i&amp;lt;=N;i++) H[i] = h[i-1];

    for (int i=1;i&amp;lt;=N;i++) if (H[i] == 1) tree[ST+i] = {1, 1, 1, 1};
    for (int i=ST;i;i--) relax(tree[i], tree[i+i], tree[i+i+1]);

    vector &amp;lt;lld&amp;gt; ans(Q);
    for (int i=0;i&amp;lt;Q;i++){
        int l = ++L[i], r = ++R[i];
        vector &amp;lt;NODE&amp;gt; arr1, arr2;
        for (l+=ST,r+=ST;l&amp;lt;=r;l&amp;gt;&amp;gt;=1,r&amp;gt;&amp;gt;=1){
            if (l&amp;amp;1) arr1.pb(tree[l++]);
            if (~r&amp;amp;1) arr2.pb(tree[r--]);
        }
        reverse(all(arr2)); arr1.insert(arr1.end(), all(arr2));
        NODE v = arr1[0];
        for (int i=1;i&amp;lt;sz(arr1);i++){
            NODE tmp; relax(tmp, v, arr1[i]); v = tmp;
        }
        ans[i] = (R[i]-L[i]+1)*2 - v.ma;
    }
    return ans;
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;font-size: 18px; font-weight: bold; margin-bottom: 10px !important;&quot;&gt;Subtask 4&amp;nbsp;(누적&amp;nbsp;60점)&lt;/p&gt;&lt;p&gt;N ≤ 100,000, Q ≤ 100,000, H[i] ≤ 20&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 서브태스크에서는 높이가 모두 20이하이다. 따라서 다음과 같은 정의를 가지고 있는 배열에 알맞는 값들을 $O(HN)$ 만에 계산할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;D[i][j] = i번째 산에서 전체 모임을 가지고 모든 산들의 높이가 j이하라고 할 때, 즉, 높이가 j보다 높은 산들은 높이를 j라고 가정할 때, 모임 비용을 N*j에서 뺀 것&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그리고 segment tree를 이용하여 다음 함수의 값을 $O(\lg N)$ 시간에 계산할 수 있다.&lt;/p&gt;&lt;p&gt;get(h, l, r) = l이상 r이하인 i에 대해 D[i][h]의 최대값&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;구간 $[L_i, R_i]$가 있을 때, 아래 그림처럼 구간에 대해 maximal 부분을 구한다.&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:600px;width: 600px; height: 238px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/993B95355B9679D72E&quot; filemime=&quot;image/jpeg&quot; filename=&quot;meetings-구간면적.png&quot; height=&quot;238&quot; style=&quot;width: 600px; height: 238px;&quot; width=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;각 빨간색 범위에 대해, 그 범위 안에 모임 장소가 있을 경우 최소 모임 비용을 get(h, l, r) 함수를 통해서 $O(\lg N)$ 구할 수 있다. 높이의 범위가 $H$이므로, 생기는 빨간색 범위의 개수는 $O(H)$가 되며, 전체 시간복잡도는 D 배열 값을 구하는 전처리 시간을 포함하여 $O(H(N + Q \lg N))$ 이 된다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more125_6&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '125_6','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content125_6&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 100005
#define pb push_back
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(), (v).end()
typedef long long lld;

int N, Q;
int H[MAXN];
lld D[MAXN][21];
vector &amp;lt;int&amp;gt; lstk[MAXN], rstk[MAXN];

const int TS = 1&amp;lt;&amp;lt;18, ST = TS/2-1;
lld tree[21][TS];

lld get(int h, int l, int r)
{
    lld ret = 0;
    for (l+=ST,r+=ST;l&amp;lt;=r;l&amp;gt;&amp;gt;=1,r&amp;gt;&amp;gt;=1){
        if (l&amp;amp;1) ret = max(ret, tree[h][l++]);
        if (~r&amp;amp;1) ret = max(ret, tree[h][r--]);
    }
    return ret;
}

vector &amp;lt;lld&amp;gt; minimum_costs(vector&amp;lt;int&amp;gt; h, vector&amp;lt;int&amp;gt; L, vector&amp;lt;int&amp;gt; R)
{
    N = sz(h); Q = sz(L);
    for (int i=1;i&amp;lt;=N;i++) H[i] = h[i-1];

    {
        vector &amp;lt;int&amp;gt; stk;
        for (int i=1;i&amp;lt;=N;i++){
            while (!stk.empty() &amp;amp;&amp;amp; H[stk.back()] &amp;lt;= H[i]) stk.pop_back();
            stk.pb(i);
            lstk[i] = stk;
        }
    }
    {
        vector &amp;lt;int&amp;gt; stk;
        for (int i=N;i;i--){
            while (!stk.empty() &amp;amp;&amp;amp; H[stk.back()] &amp;lt;= H[i]) stk.pop_back();
            stk.pb(i);
            rstk[i] = stk;
        }
    }

    for (int i=1;i&amp;lt;=N;i++){
        vector &amp;lt;int&amp;gt; l = lstk[i], r = rstk[i];
        lld sum = 0;
        for (int j=1;j&amp;lt;H[i];j++) D[i][j] = 1e18;
        for (int j=H[i]+1;j&amp;lt;21;j++){
            while (!l.empty() &amp;amp;&amp;amp; H[l.back()] &amp;lt; j) l.pop_back();
            while (!r.empty() &amp;amp;&amp;amp; H[r.back()] &amp;lt; j) r.pop_back();
            int lx = l.empty() ? 0 : l.back();
            int rx = r.empty() ? N+1 : r.back();
            int width = rx-lx-1;
            sum += width;
            D[i][j] = sum;
        }
    }

    for (int i=1;i&amp;lt;21;i++){
        for (int j=1;j&amp;lt;=N;j++) tree[i][ST+j] = D[j][i];
        for (int j=ST;j;j--) tree[i][j] = max(tree[i][j+j], tree[i][j+j+1]);
    }

    vector &amp;lt;lld&amp;gt; ans(Q);
    for (int i=0;i&amp;lt;Q;i++){
        int l = ++L[i], r = ++R[i];

        ans[i] = 1e18; int lx = 0, rx = 0;
        {
            auto ls = rstk[l];
            lld area = 0;
            { int t = r+1; for (int x: ls) if (x &amp;lt;= r) area += (lld)(t-x)*H[x], t = x; }
            while (!ls.empty() &amp;amp;&amp;amp; ls.back() &amp;lt;= r){
                int x = ls.back(); ls.pop_back();
                if (!lx){ lx = x; continue; }
                area -= (lld)(x-lx)*H[lx];
                ans[i] = min(ans[i], (lld)(x-l)*H[lx] + area - get(H[lx], lx, x-1));
                lx = x;
            }
        }
        {
            auto rs = lstk[r];
            lld area = 0;
            { int t = l-1; for (int x: rs) if (x &amp;gt;= l) area += (lld)(x-t)*H[x], t = x; }
            while (!rs.empty() &amp;amp;&amp;amp; rs.back() &amp;gt;= l){
                int x = rs.back(); rs.pop_back();
                if (!rx){ rx = x; continue; }
                area -= (lld)(rx-x)*H[rx];
                ans[i] = min(ans[i], (lld)(r-x)*H[rx] + area - get(H[rx], x+1, rx));
                rx = x;
            }
        }
        ans[i] = min(ans[i], (lld)(r-l+1)*H[lx] - get(H[lx], lx, rx));
    }
    return ans;
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;font-size: 18px; font-weight: bold; margin-bottom: 10px !important;&quot;&gt;Subtask 5&amp;nbsp;(총&amp;nbsp;100점)&lt;/p&gt;&lt;p&gt;N ≤ 750,000, Q ≤ 750,000&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;풀이 준비 중.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more125_7&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '125_7','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content125_7&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>IOI2018</category>
<author>전명우</author>
<guid>https://blog.myungwoo.kr/125</guid>
<comments>https://blog.myungwoo.kr/125#entry125comment</comments>
<pubDate>Fri, 07 Sep 2018 17:09:45 +0900</pubDate>
</item>
<item>
<title>IOI 2018 Day 1 문제 및 해법</title>
<link>https://blog.myungwoo.kr/124</link>
<description>&lt;p&gt;문제: &lt;a href=&quot;https://ioi2018.jp/competition/tasks/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;공식 홈페이지&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;채점: &lt;a href=&quot;https://contest.yandex.com/ioi/contest/8916/enter/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Yandex&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;1. combo&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;길이가 N인 'A', 'B', 'X', 'Y'로만 이루어진 문자열 S가 있다. 문자열 S의 첫 글자로 나타나는 알파뱃은 오직 한 번만 등장한다. press(p)라는 함수를 문제에서 제공하는데, press(p)에서 p는 길이가 4N 이하인 문자열이며, p의 부분문자열 중 문자열 S의 prefix 중 하나와 동일하며 가장 긴 문자열의 길이를 반환한다. 문제는&amp;nbsp;적은 횟수의 press(p)&amp;nbsp;함수 호출을 통해 문자열 S의 내용을 정확하게 알아내는 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;여담으로, p의 부분문자열 중 문자열 S의 prefix 중 하나와 동일하며 가장 긴 문자열의 길이란, 즉, 문자열 S를 패턴이라고 생각하고 p를 전체 문자열이라고 생각했을 때, KMP 알고리즘의 실패 함수 값 중 최대값을 의미한다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이 문제에서 풀이가 존재하는 이유이며, 가장 중요한 조건은 문자열 S의 첫 문자는 오직 한 번만 등장한다는 것이다. 우선, 첫 글자 후보는 네 종류이며 이분탐색 하듯이 2번의 질문을 통해 첫 글자가 무엇인지 알아낼 수 있다. 첫 글자를 알아내고 나면 뒤에 나오는 문자 후보는 세 종류로 줄어든다. 만약, 첫 글자가 'B'라고 한다면, 이후 등장하는 문자 후보는 'A', 'X', 'Y' 세 종류로 줄어든다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이후 2이상 N미만인 i에 대해 문자열 S의 i번째 문자를 왼쪽에서부터 차례대로 알아가는데 각 글자를 알아내는 것이 한 번의 질문으로 가능하다. 예를 들어, S의 길이 N이 3이상이고 S의 첫 글자가 'X'라고 하자. press(&quot;XAAXABXAYXB&quot;)를 질문했을 때, 만약 S의 2번째 글자가 'A'라면 함수 반환 값은 3이 될 것이며, S의 2번째 글자가 'B'라면 함수 반환 값은 2가 될 것이며, S의 2번째 글자가 'Y'라면 함수 반환 값은 1이 될 것이다. 즉, press 함수 반환 값에 따라 S의 2번째 글자가 결정된다. 이런 식으로 질문하면 N-1번째 문자까지 전부 알아낼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;마지막 글자도 첫 글자와 마찬가지로 2번의 질문을 통해 알아낼 수 있다. 그러면 여태까지 총 질문한 횟수는 2 + (N-2) + 2 = N+2가 된다. 정리하자면, N=1일 경우 2번의 질문만 하고, 그렇지 않을 경우 N+2번의 질문을 통해 문자열 S의 내용을 정확히 알아낼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more124_0&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '124_0','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content124_0&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &quot;combo.h&quot;

#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 2004

int N;
char S[MAXN];

string guess_sequence(int N)
{
    ::N = N;
    if (press(&quot;XY&quot;)){
        if (press(&quot;X&quot;)) S[0] = 'X';
        else S[0] = 'Y';
    }else{
        if (press(&quot;A&quot;)) S[0] = 'A';
        else S[0] = 'B';
    }
    vector &amp;lt;char&amp;gt; cs;
    for (char c: string(&quot;XYAB&quot;)) if (S[0] != c) cs.push_back(c);
    auto ask = [&amp;amp;cs](){
        string s;
        s.append(S); s.append(1, cs[0]); s.append(1, cs[0]);
        s.append(S); s.append(1, cs[0]); s.append(1, cs[1]);
        s.append(S); s.append(1, cs[0]); s.append(1, cs[2]);
        s.append(S); s.append(1, cs[1]);
        return press(s);
    };
    for (int i=1;i&amp;lt;N-1;i++)
        S[i] = cs[2-(ask()-i)];
    if (N &amp;gt; 1){
        if (press(string(S) + string(1, cs[0])) == N) S[N-1] = cs[0];
        else if (press(string(S) + string(1, cs[1])) == N) S[N-1] = cs[1];
        else S[N-1] = cs[2];
    }
    return S;
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3&gt;2. seats&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;높이 H, 너비 W, 크기 K=H×W의 격자판이 주어진다. 각 칸에는 0부터 K-1까지 번호가 서로 다르게 쓰여있다. 격자판에서 부분직사각형 영역에 번호가 0부터 차례대로 모두 존재한다면 부분직사각형 영역을 아름답다고 한다. 초기 격자판의 상태와, 특정 두 칸에 적힌 수를 서로 바꾸는 쿼리 Q개가 주어졌을 때, 차례대로 쿼리를 수행하면서 수를 서로 바꾼 직후마다 아름다운 부분직사각형 영역의 수를 구하는 문제다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;쿼리가 없다고 했을 때, 즉, 한 번만 아름다운 부분직사각형 영역의 수를 구하는 방법은 여러 가지다. 여러 방법 중 100점 풀이로 가는 방법은 별로 없다. 0번이 적힌 격자칸부터 번호 순서대로 격자칸을 색칠해나간다고 했을 때, 색칠된 모든 부분이 직사각형을 이룬다면 그 직사각형은 아름다운 부분직사각형 영역이 된다. 색칠해나가는 중간과정을 생각하면서 아래 그림을 보자.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:558px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99B1163A5B8FD9511A&quot; filemime=&quot;image/jpeg&quot; filename=&quot;그림1.png&quot; height=&quot;103&quot; width=&quot;558&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;맨 왼쪽 그림의 검은 격자칸은 상, 좌, 상좌대각선이 아직 색칠되어있지 않아서 색칠된 영역이 직사각형을 이룬다면 직사각형의 왼쪽-위 꼭지점이 될 것이다. 마찬가지로 이어지는 그림들도 오른쪽-위 꼭지점, 왼쪽-아래 꼭지점, 오른쪽-아래 꼭지점이 될 것이다. 각 꼭지점이 될 가능성이 있는 검정색 칸의 개수를 세고 더 했을 때 4개가 된다면 직사각형 영역이 될 가능성이 있다는 것이다. 이어서 다음 그림을 보자.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:280px;width: 280px; height: 276px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99F112485B8FED0C19&quot; filemime=&quot;image/jpeg&quot; filename=&quot;그림2.png&quot; height=&quot;276&quot; style=&quot;width: 280px; height: 276px;&quot; width=&quot;280&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;그림처럼 구멍이 존재하면 꼭지점 후보가 4개가 있다고 하더라도 색칠된 칸들은 채워진 직사각형 영역을 이루지 않는다. 1번 칸은 구멍의 왼쪽-위 꼭지점이 될 가능성이 있고, 2, 3, 4번 칸은 각각 구멍의 오른쪽-위, 왼쪽-아래, 오른쪽-아래 꼭지점이 될 가능성이 있다. 구멍의 꼭지점이 될 가능성이 있는 칸들의 개수를 세고 더했을 때 0개가 되면 비로소 색칠된 칸들은 직사각형 영역을 이루는 것을 알 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;즉, 직사각형의 꼭지점이 될 가능성이 있는 칸이 4개, 구멍의 꼭지점이 될 가능성이 있는 칸이 0개라면 직사각형을 이룬다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;칸을 하나씩 색칠해나가는 매 단계마다 직사각형의 꼭지점이 될 가능성이 있는 칸이 4개, 구멍의 꼭지점이 될 가능성이 있는 칸이 0개인 단계 수를 구하면 쿼리에서 요구하는 아름다운 부분직사각형 영역의 개수가 되는 것이고, 이를 segment tree를 잘 사용하여 서로 다른 두 칸에 적힌 수를 서로 바꿀 때마다 $O(\lg HW)$ 시간에 원하는 답을 구할 수 있다. 이 과정은 자료구조를 기술적으로 잘 사용하는 영역이므로 설명을 생략하며 첨부된 코드를 참고하길 바란다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이 문제를 해결하는 총 시간복잡도는 $O(HW + Q \lg HW)$이며, 실제 계산량은 시간복잡도 앞에 상수가 꽤 붙어 시간제한이 많이 빡빡해서 나름 최적화가 필요했다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more124_1&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '124_1','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content124_1&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;

#define MAXK 1000006

int yy[]={-1, 0, 1, 0}, xx[]={0, 1, 0, -1};
int H, W, K;
int R[MAXK], C[MAXK];
int S[2][MAXK];

struct Flex2D {
    int&amp; at(int y, int x){
        return mem[idx(y, x)];
    }
    void swap(int y1, int x1, int y2, int x2){
        ::swap(mem[idx(y1, x1)], mem[idx(y2, x2)]);
    }
private:
    int mem[MAXK];
    inline int idx(int y, int x){ return (y-1)*W+x-1; }
} A, B[2][4];

const int TS = 1&lt;&lt;21, ST = TS/2-1;
struct NODE {
    int added, min, mincnt;
} tree[TS];

void relax(int n)
{
    auto &amp;t = tree[n], &amp;l = tree[n+n], &amp;r = tree[n+n+1];
    t.added = l.added+r.added;
    t.min = min(l.min, l.added+r.min);
    t.mincnt = 0;
    if (t.min == l.min) t.mincnt += l.mincnt;
    if (t.min == l.added+r.min) t.mincnt += r.mincnt;
}

void add(int n, int v)
{
    if (n &gt; K) return;
    n += ST;
    tree[n].added += v; tree[n].min += v;
    for (n&gt;&gt;=1;n;n&gt;&gt;=1) relax(n);
}

void add(int l, int r, int v)
{
    if (l &gt; r) return;
    add(l, v); add(r+1, -v);
}

void recalc(int y, int x, int msk, bool run)
{
    for (int d=0;d&lt;4;d++) if (msk &amp; 1&lt;&lt;d){
        if (run)
            add(B[0][d].at(y, x), K, +1);
        int v = K+1;
        for (int dir: {d, d+1&amp;3}){
            int ny = y+yy[dir], nx = x+xx[dir];
            if (ny &lt; 1 || ny &gt; H || nx &lt; 1 || nx &gt; W) continue;
            v = min(v, A.at(ny, nx));
        }
        v = max(v, A.at(y, x));
        if (run)
            add(v, K, -1);
        B[0][d].at(y, x) = v;

        if (run)
            add(1, B[1][d].at(y, x)-1, +1);
        v = 0;
        for (int dir: {d, d+1&amp;3}){
            int ny = y+yy[dir], nx = x+xx[dir];
            if (ny &lt; 1 || ny &gt; H || nx &lt; 1 || nx &gt; W){ v = A.at(y, x); continue; }
            v = max(v, A.at(ny, nx));
        }
        v = min(v, A.at(y, x));
        if (run)
            add(1, v-1, -1);
        B[1][d].at(y, x) = v;
    }
}

void changed(int y, int x, int v)
{
    A.at(y, x) = v;
    recalc(y, x, 15, 1);
    for (int d=0;d&lt;4;d++){
        int ny = y+yy[d], nx = x+xx[d];
        if (ny &lt; 1 || ny &gt; H || nx &lt; 1 || nx &gt; W) continue;
        recalc(ny, nx, (1&lt;&lt;(d+2&amp;3))|(1&lt;&lt;(d+1&amp;3)), 1);
    }
}

void give_initial_chart(int H, int W, std::vector&lt;int&gt; R, std::vector&lt;int&gt; C)
{
    ::H = H; ::W = W; ::K = H*W;

    for (int i=0;i&lt;K;i++) A.at(++R[i], ++C[i]) = i+1;
    for (int i=0;i&lt;K;i++) ::R[i+1] = R[i], ::C[i+1] = C[i];

    for (int i=1;i&lt;=H;i++) for (int j=1;j&lt;=W;j++) recalc(i, j, 15, 0);
    for (int d=0;d&lt;4;d++) for (int i=1;i&lt;=H;i++) for (int j=1;j&lt;=W;j++){
        S[0][B[0][d].at(i, j)] += -1;
        S[1][1] += -1; S[1][B[1][d].at(i, j)] += 1;
    }
    for (int i=1;i&lt;=K;i++) S[0][i] += 4, S[1][1] += 4, S[1][i] -= 4;

    tree[ST+K+1].added = tree[ST+K+1].min = 1e9;
    for (int i=1;i&lt;=K;i++){
        tree[ST+i].added = tree[ST+i].min = S[0][i]+S[1][i];
        tree[ST+i].mincnt = 1;
    }
    for (int i=ST;i;i--) relax(i);
}

int swap_seats(int a, int b)
{
    ++a; ++ b;
    A.swap(R[a], C[a], R[b], C[b]);
    swap(R[a], R[b]);
    swap(C[a], C[b]);
    changed(R[a], C[a], A.at(R[a], C[a]));
    changed(R[b], C[b], A.at(R[b], C[b]));
    return tree[1].mincnt;
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3&gt;3. werewolf&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;정점이 N개, 간선이 M개인 무방향성 그래프가 주어진다. 정점에는 0이상 N-1이하의 번호가 서로 다르게 매겨져있다. Q개의 쿼리가 주어지고, 각 쿼리마다 s, e, l, r 값이 주어진다. 이는 정점 s부터 시작해서 정점 r까지 l, r 이라는 특성 값을 늑대 인간이 여행을 할 수 있는지를 물어보는 것이다. l, r이라는 특성 값을 가진 늑대 인간은 초기에 인간 상태로 여행을 시작하며 인간 상태일 떄는 정점 번호가 l 미만인 곳에 가지 못한다. 인간 상태로 여행을 하다가 정점 번호가 l이상 r이하인 곳에서 늑대로 변신할 수 있으며, 여행이 끝날 때에는 늑대 상태여야한다. 늑대 상태일 때는 정점 번호가 r 초과인 곳을 가지 못한다. 이러한 Q개의 쿼리를 해결하는 것이 문제이며, 쿼리를 오프라인(비실시간)으로 해결해도 된다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;다음와 같은 그래프가 주어졌다고 하자.&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:350px;width: 350px; height: 198px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/991616485B8F27DA19&quot; filemime=&quot;image/jpeg&quot; filename=&quot;werewolf-그래프1.png&quot; height=&quot;198&quot; original=&quot;yes&quot; style=&quot;width: 350px; height: 198px;&quot; width=&quot;350&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;빈 그래프에서 0번 정점부터 5번 정점까지 차례대로 추가했을 때, connected component들이 서로 합쳐지면서 최종 그래프는 connected graph가 될 것이다. 여기서 connected component들이 합쳐지는 과정을 루트가 있는 트리로 그리면 다음과 같다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:153px;width: 153px; height: 320px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99AA8D455B8F28CE13&quot; filemime=&quot;image/jpeg&quot; filename=&quot;werewolf-트리1.png&quot; height=&quot;320&quot; original=&quot;yes&quot; style=&quot;width: 153px; height: 320px;&quot; width=&quot;153&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;위 트리에서 루트는 5번 정점이 된다. 트리에서 0번 정점에서 1번 정점으로 가는 경로에서 가장 번호가 큰 정점은 3번 정점이며, 이는 원래 그래프에서 0번 정점에서 1번 정점으로 가는 경로들 중 정점 번호 최대값의 최소값이다. 또한 이는 0번 정점과 1번 정점의 LCA(최소공통조상)이 된다.&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;마찬가지로 반대 순서로 빈 그래프에서 5번 정점부터 0번 정점까지 차례대로 추가했을 경우로 루트가 있는 트리를 그리면 아래와 같이 나온다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:153px;width: 153px; height: 259px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/996E344E5B8F2A1F16&quot; filemime=&quot;image/jpeg&quot; filename=&quot;werewolf-트리2.png&quot; height=&quot;259&quot; original=&quot;yes&quot; style=&quot;width: 153px; height: 259px;&quot; width=&quot;153&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이번에는 루트가 0번 정점이 되며. 마찬가지로 트리에서 2번 정점에서 4번 정점으로 가는 경로에서 가장 번호가 작은 정점은 1번 정점이며, 이는 원래 그래프에서 2번 정점에서 4번 정점으로 가는 경로들 중 정점 번호 최소값의 최대값이다. 또한 이는 2번 정점과 4번 정점의 LCA(최소공통조상)이 된다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이렇게 두 종류의 트리를 구하고 트리에서 LCA가 가지는 의미를 알게되면, 문제에서 주어지는 쿼리를 다른 말로 바꿀 수 있다. 쿼리에서 s, e, l, r이 주어졌다고 하자. 루트가 0인 트리에서 정점 s의 조상 중 번호가 l 이상인 가장 높은 조상의 정점 번호를 x라 하고, 루트가 N-1인 트리에서 정점 e의 조상 중 번호가 r 이하인 가장 높은 조상의 정점 번호를 y라고 했을 때, 루트가 0인 트리에서 x의 서브트리에 있는 정점들과, 루트가 N-1인 트리에서 y의 서브트리에 있는 정점들 중 겹치는 것이 있는지를 물어보는 것으로 쿼리를 바꿔 생각할 수 있다.&lt;/p&gt;
&lt;p&gt;예를 들어, 위 상황에서 s=4, e=2, l=1, r=2 라고 했을 때, x=1, y=2가 되며, 루트가 0인 트리에서 x의 서브트리에 있는 정점들은 1, 2, 3, 4, 5이고, 루트가 N-1인 트리에서 y의 서브트리에 있는 정점들은 1, 2가 된다. 겹치는 정점이 있으므로 쿼리에 대한 답은 가능하다가 된다.&lt;/p&gt;
&lt;p&gt;또 다른 예로, 위 상황에서 s=4, e=2, l=2, r=2 라고 했을 때, x=3, y=2가 되며, 루트가 0인 트리에서 x의 서브트리에 있는 정점들은 3, 4가 되고, 루트가 N-1인 트리에서 y의 서브트리에 있는 정점들은 1, 2가 된다. 겹치는 정점이 없으므로 쿼리에 대한 답은 불가능하다가&amp;nbsp;된다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;서브트리 두 개에 겹치는 정점이 있는지 확인을 빠르게 해주기 위해서는 두 종류 트리에 있는 각 정점들을 DFS 순서로 번호를 다시 매겨야한다.&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:400px;width: 400px; height: 314px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99383D425B8F32D613&quot; filemime=&quot;image/jpeg&quot; filename=&quot;werewolf-트리번호.png&quot; height=&quot;314&quot; style=&quot;width: 400px; height: 314px;&quot; width=&quot;400&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;위 그림에서 파란색 수는 루트가 N-1인 트리에서 DFS 순서로 번호를 다시 매긴 것이고, 빨간색 수는 루트가 0인 트리에서 DFS 순서로 번호를 다시 매긴 것이다. 파란색 수를 인덱스로 생각하고 빨간색 수를 그 인덱스에 해당하는 값으로 생각하고 배열을 만들면 다음과 같이 나온다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:339px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/998C5D425B8F33E811&quot; filemime=&quot;image/jpeg&quot; filename=&quot;werewolf-배열.png&quot; height=&quot;68&quot; width=&quot;339&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;언급했던 예제 상황 중 x=1, y=2일 때 겹치는 정점이 있는 지 확인하는 것은 루트가 0인 트리에서 x의 서브트리에 있는 정점의 빨간색 수 범위는 2이상 6이하다. 루트가 N-1인 트리에서 y의 서브트리에 있는 정점의 파란색 수 범위는 5이상 6이하다. 즉, 새로 만든 배열의 부분 배열인 인덱스 5~6 사이에 2이상 6이하인 값이 있는지를 물어보는 것과 같다.&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;두 번째 예제 상황에서 x=3, y=2일 때 겹치는 정점이 있는 지 확인하는 것은 루트가 0인 트리에서 x의 서브트리에 있는 정점의 빨간색 수 범위는 5이상 6이하다. 루트가 N-1인 트리에서 y의 서브트리에 있는 정점의 파란색 수 범위는 5이상 6이하다. 즉, 새로 만든 배열의 부분 배열인 인덱스 5~6 사이에 5이상 6이하인 값이 있는지를 물어보는 것과 같다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;새로 구한 배열을 만들었을 때, 쿼리는 merge sort tree를 이용하여 쿼리당 $O(\lg^2 N)$ 시간복잡도로 온라인으로 해결할 수 있다. 이 때 총 시간복잡도는 $O(M&amp;nbsp;\lg N + Q \lg^2 N)$이 된다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more124_2&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '124_2','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content124_2&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 200005
#define pb push_back
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(), (v).end()

int N, M, Q;
int djs[MAXN];
vector &amp;lt;int&amp;gt; con[MAXN];

// 아래에서부터 올라오는 트리 구조
int par[MAXN][18], num[MAXN], out[MAXN];
vector &amp;lt;int&amp;gt; child[MAXN];

// 위에서부터 내려가는 트리 구조
int par2[MAXN][18], num2[MAXN], out2[MAXN];
vector &amp;lt;int&amp;gt; child2[MAXN];

const int TS = 1&amp;lt;&amp;lt;19, ST = TS/2-1;
vector &amp;lt;int&amp;gt; tree[TS];

int find(int n){ return djs[n] == n ? n : (djs[n] = find(djs[n])); }

int K = 0;
void dfs(int n)
{
    num[n] = ++K;
    for (int t: child[n]) dfs(t);
    out[n] = K;
}
int K2 = 0;
void dfs2(int n)
{
    num2[n] = ++K2;
    for (int t: child2[n]) dfs2(t);
    out2[n] = K2;
}

bool is_exists(int l, int r, int mn, int mx)
{
    for (l+=ST,r+=ST;l&amp;lt;=r;l&amp;gt;&amp;gt;=1,r&amp;gt;&amp;gt;=1){
        if (l&amp;amp;1){
            auto it = lower_bound(all(tree[l]), mn);
            if (it != tree[l].end() &amp;amp;&amp;amp; *it &amp;lt;= mx) return 1;
            l++;
        }
        if (~r&amp;amp;1){
            auto it = lower_bound(all(tree[r]), mn);
            if (it != tree[r].end() &amp;amp;&amp;amp; *it &amp;lt;= mx) return 1;
            r--;
        }
    }
    return 0;
}

vector&amp;lt;int&amp;gt; check_validity(int N, vector&amp;lt;int&amp;gt; X, vector&amp;lt;int&amp;gt; Y, vector&amp;lt;int&amp;gt; S, vector&amp;lt;int&amp;gt; E, vector&amp;lt;int&amp;gt; L, vector&amp;lt;int&amp;gt; R)
{
    ::N = N; ::M = sz(X); Q = sz(S);
    vector &amp;lt;int&amp;gt; ret(Q, 0);
    for (int i=0;i&amp;lt;M;i++){
        int a = ++X[i], b = ++Y[i];
        con[a].pb(b); con[b].pb(a);
    }

    for (int i=1;i&amp;lt;=N;i++) djs[i] = i;
    for (int i=1;i&amp;lt;=N;i++){
        for (int t: con[i]) if (t &amp;lt; i){
            if (find(t) != i){
                int m = find(t); djs[m] = i;
                par[m][0] = i; child[i].pb(m);
            }
        }
    }
    par[N][0] = N;
    for (int i=1;i&amp;lt;18;i++) for (int j=1;j&amp;lt;=N;j++) par[j][i] = par[par[j][i-1]][i-1];
    dfs(N);

    for (int i=1;i&amp;lt;=N;i++) djs[i] = i;
    for (int i=N;i;i--){
        for (int t: con[i]) if (t &amp;gt; i){
            if (find(t) != i){
                int m = find(t); djs[m] = i;
                par2[m][0] = i; child2[i].pb(m);
            }
        }
    }
    par2[1][0] = 1;
    for (int i=1;i&amp;lt;18;i++) for (int j=1;j&amp;lt;=N;j++) par2[j][i] = par2[par2[j][i-1]][i-1];
    dfs2(1);

    // Merge sort tree
    for (int i=1;i&amp;lt;=N;i++) tree[ST+num[i]].pb(num2[i]);
    for (int i=ST;i;i--){
        const auto &amp;amp;lc = tree[i+i], &amp;amp;rc = tree[i+i+1];
        for (int l=0,r=0;l&amp;lt;sz(lc)||r&amp;lt;sz(rc);){
            if (r == sz(rc) || l &amp;lt; sz(lc) &amp;amp;&amp;amp; lc[l] &amp;lt; rc[r]) tree[i].pb(lc[l++]);
            else tree[i].pb(rc[r++]);
        }
    }

    for (int i=0;i&amp;lt;Q;i++){
        S[i]++; E[i]++; L[i]++; R[i]++;
        int n = E[i];
        for (int j=18;j--;) if (par[n][j] &amp;lt;= R[i]) n = par[n][j];
        int l = num[n], r = out[n];

        n = S[i];
        for (int j=18;j--;) if (par2[n][j] &amp;gt;= L[i]) n = par2[n][j];
        int mn = num2[n], mx = out2[n];

        ret[i] = is_exists(l, r, mn, mx);
    }

    return ret;
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이 문제에서는 오프라인으로 쿼리가 주어지므로 merge sort tree에서의 탐색을 오프라인으로 진행했을 경우 총 시간복잡도는 $O(M \lg N + Q \lg QN)$가 된다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more124_3&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '124_3','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content124_3&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 200005
#define pb push_back
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(), (v).end()

int N, M, Q;
int djs[MAXN];
vector &amp;lt;int&amp;gt; con[MAXN];

// 아래에서부터 올라오는 트리 구조
int par[MAXN][18], num[MAXN], out[MAXN];
vector &amp;lt;int&amp;gt; child[MAXN];

// 위에서부터 내려가는 트리 구조
int par2[MAXN][18], num2[MAXN], out2[MAXN];
vector &amp;lt;int&amp;gt; child2[MAXN];

const int TS = 1&amp;lt;&amp;lt;19, ST = TS/2-1;
vector &amp;lt;int&amp;gt; tree[TS];

int find(int n){ return djs[n] == n ? n : (djs[n] = find(djs[n])); }

int K = 0;
void dfs(int n)
{
    num[n] = ++K;
    for (int t: child[n]) dfs(t);
    out[n] = K;
}
int K2 = 0;
void dfs2(int n)
{
    num2[n] = ++K2;
    for (int t: child2[n]) dfs2(t);
    out2[n] = K2;
}

vector&amp;lt;int&amp;gt; check_validity(int N, vector&amp;lt;int&amp;gt; X, vector&amp;lt;int&amp;gt; Y, vector&amp;lt;int&amp;gt; S, vector&amp;lt;int&amp;gt; E, vector&amp;lt;int&amp;gt; L, vector&amp;lt;int&amp;gt; R)
{
    ::N = N; ::M = sz(X); Q = sz(S);
    vector &amp;lt;int&amp;gt; ret(Q, 0);
    for (int i=0;i&amp;lt;M;i++){
        int a = ++X[i], b = ++Y[i];
        con[a].pb(b); con[b].pb(a);
    }

    for (int i=1;i&amp;lt;=N;i++) djs[i] = i;
    for (int i=1;i&amp;lt;=N;i++){
        for (int t: con[i]) if (t &amp;lt; i){
            if (find(t) != i){
                int m = find(t); djs[m] = i;
                par[m][0] = i; child[i].pb(m);
            }
        }
    }
    par[N][0] = N;
    for (int i=1;i&amp;lt;18;i++) for (int j=1;j&amp;lt;=N;j++) par[j][i] = par[par[j][i-1]][i-1];
    dfs(N);

    for (int i=1;i&amp;lt;=N;i++) djs[i] = i;
    for (int i=N;i;i--){
        for (int t: con[i]) if (t &amp;gt; i){
            if (find(t) != i){
                int m = find(t); djs[m] = i;
                par2[m][0] = i; child2[i].pb(m);
            }
        }
    }
    par2[1][0] = 1;
    for (int i=1;i&amp;lt;18;i++) for (int j=1;j&amp;lt;=N;j++) par2[j][i] = par2[par2[j][i-1]][i-1];
    dfs2(1);

    // Merge sort tree
    for (int i=1;i&amp;lt;=N;i++) tree[ST+num[i]].pb(num2[i]);
    for (int i=ST;i;i--){
        const auto &amp;amp;lc = tree[i+i], &amp;amp;rc = tree[i+i+1];
        for (int l=0,r=0;l&amp;lt;sz(lc)||r&amp;lt;sz(rc);){
            if (r == sz(rc) || l &amp;lt; sz(lc) &amp;amp;&amp;amp; lc[l] &amp;lt; rc[r]) tree[i].pb(lc[l++]);
            else tree[i].pb(rc[r++]);
        }
    }

    struct QUERY{
        int q, s, e, l, r;
    };
    vector &amp;lt;QUERY&amp;gt; queries;
    for (int i=0;i&amp;lt;Q;i++){
        S[i]++; E[i]++; L[i]++; R[i]++;
        int n = E[i];
        for (int j=18;j--;) if (par[n][j] &amp;lt;= R[i]) n = par[n][j];
        int l = num[n], r = out[n];

        n = S[i];
        for (int j=18;j--;) if (par2[n][j] &amp;gt;= L[i]) n = par2[n][j];
        int mn = num2[n], mx = out2[n];

        queries.pb({i, l, r, mn, mx});
    }
    sort(all(queries), [](const QUERY &amp;amp;a, const QUERY &amp;amp;b){
        return a.r &amp;gt; b.r;
    });

    auto check = [](vector&amp;lt;int&amp;gt; &amp;amp;node, int l, int r){
        while (!node.empty() &amp;amp;&amp;amp; node.back() &amp;gt; r) node.pop_back();
        return !node.empty() &amp;amp;&amp;amp; node.back() &amp;gt;= l;
    };
    for (const auto &amp;amp;q: queries){
        for (int l=ST+q.s,r=ST+q.e;l&amp;lt;=r;l&amp;gt;&amp;gt;=1,r&amp;gt;&amp;gt;=1){
            if (l&amp;amp;1) ret[q.q] |= check(tree[l++], q.l, q.r);
            if (~r&amp;amp;1) ret[q.q] |= check(tree[r--], q.l, q.r);
        }
    }

    return ret;
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>IOI2018</category>
<author>전명우</author>
<guid>https://blog.myungwoo.kr/124</guid>
<comments>https://blog.myungwoo.kr/124#entry124comment</comments>
<pubDate>Wed, 05 Sep 2018 11:14:01 +0900</pubDate>
</item>
<item>
<title>2018년 아시아태평양 정보올림피아드 (APIO2018) 풀이</title>
<link>https://blog.myungwoo.kr/123</link>
<description>&lt;h4&gt;A. 새 집 (New Home)&lt;/h4&gt;
&lt;p&gt;$N$개의 상점이 주어진다. $i$번째 상점은 위치 $x_i$에 지어지며, 종류는 $t_i$이고, $a_i$년 초에 생겨, $b_i$년 말에 없어진다. 상점의 종류는 $K$가지이다. $Q$개의 질문이 주어진다. $i$번째 질문은, $y_i$년 중순에 $l_i$위치에 집을 지을 경우, 상점 종류마다 제일 가까운 상점과의 거리를 구해 그 중 최대값을 요구한다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;예를 들어, $K=2$이고 어떤 특정 시점에 1번 종류 상점이 좌표 2, 5, 13에 있고, 2번 종류 상점이 좌표 6, 10, 15에 있다고 했을 때, 아래와 같은 그래프를 그릴 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9975873C5AFC00E615&quot; filemime=&quot;image/jpeg&quot; filename=&quot;그래프.png&quot; height=&quot;421&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;그래프에서 파란색 선은 1번 종류 상점에 대한 거리를 나타내고, 주황색 선은 2번 종류 상점에 대해 거리를 나타낸다. 이 순간 좌표 8에 집이 있다고 하면 문제에서 요구하는 답은 3이 될 것이고, 집이 좌표 11에 있다고 하면 문제에서 요구하는 답은 2가 된다. 즉, 집의 위치가 $l$라고 했을 때, 그래프를 그리고 수직선 $x=l$을 그린 뒤 생기는 교차점 중 $y$ 좌표가 제일 큰 것이 답이 된다.&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;시간이 지남에 따라 상점은 새로 생기기도 하고, 없어지기도 한다. 상점이 새로 생길 때와 없어질 때를 고려하여, 종류마다 위에서 그린 것과 같은 그래프를 multiset을 이용하여 유지할 수 있다. 이제 수직선 $x=l$에 대해 생기는 교차점 중 $y$ 좌표가 제일 큰 것을 찾으면 되는데, &lt;span style=&quot;font-family: Menlo, Monaco, Consolas, monospace;&quot;&gt;/&lt;/span&gt; 모양 사선과 &lt;span style=&quot;font-family: Menlo, Monaco, Consolas, monospace;&quot;&gt;\&lt;/span&gt; 모양 사선에 대해 따로 segment tree를 만들어 구하면 된다. 사선의&amp;nbsp;peak 지점 $x$ 좌표와 사선의 $x$절편을 이용하면 된다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more123_0&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '123_0','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content123_0&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea name=&quot;code&quot; class=&quot;brush:cpp;&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 300005
typedef pair&amp;lt;int, int&amp;gt; pii;

int N, K, Q;
int XX[MAXN], XC;
int ans[MAXN];
multiset&amp;lt;int&amp;gt; P[MAXN];

struct STORE {
    int x, t, a, b;
} A[MAXN];

struct QUERY {
    int x, t, idx;
} B[MAXN];

const int TS = 1048576, ST = TS/2-1;
int mnTree[TS], mxTree[TS];
multiset&amp;lt;int&amp;gt; leaves1[MAXN], leaves2[MAXN];

void _add(int x0, int xt, char dir)
{
    if (dir == '/'){
        int t = upper_bound(XX+1, XX+XC+1, xt)-XX-1;
        if (t &amp;lt; 1) return;
        leaves1[t].insert(x0); mnTree[ST+t] = *leaves1[t].begin();
        for (int n=ST+t&amp;gt;&amp;gt;1;n;n&amp;gt;&amp;gt;=1) mnTree[n] = min(mnTree[n+n], mnTree[n+n+1]);
    }else{
        int t = lower_bound(XX+1, XX+XC+1, xt)-XX;
        if (t &amp;gt; XC) return;
        leaves2[t].insert(x0); mxTree[ST+t] = *leaves2[t].rbegin();
        for (int n=ST+t&amp;gt;&amp;gt;1;n;n&amp;gt;&amp;gt;=1) mxTree[n] = max(mxTree[n+n], mxTree[n+n+1]);
    }
}

void _del(int x0, int xt, char dir)
{
    if (dir == '/'){
        int t = upper_bound(XX+1, XX+XC+1, xt)-XX-1;
        if (t &amp;lt; 1) return;
        leaves1[t].erase(leaves1[t].find(x0)); mnTree[ST+t] = leaves1[t].empty() ? 2e9 : *leaves1[t].begin();
        for (int n=ST+t&amp;gt;&amp;gt;1;n;n&amp;gt;&amp;gt;=1) mnTree[n] = min(mnTree[n+n], mnTree[n+n+1]);
    }else{
        int t = lower_bound(XX+1, XX+XC+1, xt)-XX;
        if (t &amp;gt; XC) return;
        leaves2[t].erase(leaves2[t].find(x0)); mxTree[ST+t] = leaves2[t].empty() ? -2e9 : *leaves2[t].rbegin();
        for (int n=ST+t&amp;gt;&amp;gt;1;n;n&amp;gt;&amp;gt;=1) mxTree[n] = max(mxTree[n+n], mxTree[n+n+1]);
    }
}

void add(int x, int t)
{
    auto l = P[t].lower_bound(x);
    auto r = l--;
    _del(*l, *l+*r&amp;gt;&amp;gt;1, '/');
    _del(*r, *l+*r&amp;gt;&amp;gt;1, '\\');
    _add(*l, *l+x&amp;gt;&amp;gt;1, '/');
    _add(x, *l+x&amp;gt;&amp;gt;1, '\\');
    _add(x, x+*r&amp;gt;&amp;gt;1, '/');
    _add(*r, x+*r&amp;gt;&amp;gt;1, '\\');
    P[t].insert(x);
}

void del(int x, int t)
{
    auto m = P[t].find(x);
    auto l = m; l--;
    auto r = m; r++;
    _del(*l, *l+x&amp;gt;&amp;gt;1, '/');
    _del(x, *l+x&amp;gt;&amp;gt;1, '\\');
    _del(x, x+*r&amp;gt;&amp;gt;1, '/');
    _del(*r, x+*r&amp;gt;&amp;gt;1, '\\');
    _add(*l, *l+*r&amp;gt;&amp;gt;1, '/');
    _add(*r, *l+*r&amp;gt;&amp;gt;1, '\\');
    P[t].erase(m);
}

int get(int x)
{
    int t = lower_bound(XX+1, XX+XC+1, x) - XX;
    int mn = 2e9;
    for (int l=ST+t,r=ST+XC;l&amp;lt;=r;l&amp;gt;&amp;gt;=1,r&amp;gt;&amp;gt;=1){
        if (l&amp;amp;1) mn = min(mn, mnTree[l++]);
        if (!(r&amp;amp;1)) mn = min(mn, mnTree[r--]);
    }
    int mx = -2e9;
    for (int l=ST+1,r=ST+t;l&amp;lt;=r;l&amp;gt;&amp;gt;=1,r&amp;gt;&amp;gt;=1){
        if (l&amp;amp;1) mx = max(mx, mxTree[l++]);
        if (!(r&amp;amp;1)) mx = max(mx, mxTree[r--]);
    }
    return max(x - mn, mx - x);
}

int main()
{
    scanf(&quot;%d%d%d&quot;, &amp;amp;N, &amp;amp;K, &amp;amp;Q);
    for (int i=1;i&amp;lt;=N;i++){
        int x, t, a, b;
        scanf(&quot;%d%d%d%d&quot;, &amp;amp;x, &amp;amp;t, &amp;amp;a, &amp;amp;b); x &amp;lt;&amp;lt;= 1;
        A[i] = {x, t, a, b};
    }
    for (int i=1;i&amp;lt;=Q;i++){
        int x, t; scanf(&quot;%d%d&quot;, &amp;amp;x, &amp;amp;t); x &amp;lt;&amp;lt;= 1;
        B[i] = {x, t, i};
        XX[++XC] = x;
    }
    sort(XX+1, XX+XC+1); XC = unique(XX+1, XX+XC+1)-XX-1;
    sort(A+1, A+N+1, [](const STORE &amp;amp;a, const STORE &amp;amp;b){
        return a.a &amp;lt; b.a;
    });
    sort(B+1, B+Q+1, [](const QUERY &amp;amp;a, const QUERY &amp;amp;b){
        return a.t &amp;lt; b.t;
    });
    for (int i=1;i&amp;lt;TS;i++) mnTree[i] = 2e9, mxTree[i] = -2e9;
    for (int i=1;i&amp;lt;=K;i++){
        P[i] = {(int)-4e8, (int)4e8};
        _add(-4e8, 0, '/');
        _add(4e8, 0, '\\');
    }
    priority_queue &amp;lt;pii&amp;gt; que;
    for (int i=1,j=1;i&amp;lt;=Q;i++){
        auto&amp;amp; q = B[i];
        while (j &amp;lt;= N &amp;amp;&amp;amp; A[j].a &amp;lt;= q.t){
            add(A[j].x, A[j].t);
            que.push({-A[j].b, j});
            j++;
        }
        while (!que.empty() &amp;amp;&amp;amp; -que.top().first &amp;lt; q.t){
            int x = que.top().second; que.pop();
            del(A[x].x, A[x].t);
        }
        ans[q.idx] = get(q.x);
    }
    for (int i=1;i&amp;lt;=Q;i++) printf(&quot;%d\n&quot;, ans[i] &amp;gt; 2e8 ? -1 : ans[i] &amp;gt;&amp;gt; 1);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4&gt;B. 원 고르기 (Circle selection)&lt;/h4&gt;
&lt;p&gt;2차원 좌표평면 위에 $N$개의 원이 주어진다. 남아있는 원들 중 반지름이 가장 큰 원을 고른다. 만약, 그러한 원이 여러 개라면 그 중 인덱스가 가장 작은 것을 고른다. 고른 원을 포함하여 고른 원과 조금이라고 겹치는 원들을 모두 없앤다. 이러한 과정을 남아있는 원이 없을 때까지 반복한다. 이 때, 각 원에 대해 어떤 원에 의해 자신이 없어졌는지를 구하는 문제다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;각 원에 대해 자신을 포함하면서 변이 x축 또는 y축에 평행한 가장 작은 정사각형을 그린다. 이 정사각형 영역이 겹칠 경우에만 원이 서로 겹치는지 판단한다. 즉, 반지름이 제일 큰 원을 고르고, 그 원과 정사각형 영역이 겹치는 원들을 추려내어, 실제로 원이 겹치는지 확인하고 원이 겹친다면 없애는 과정으로 진행한다. 이 과정 중 정사각형 영역이 겹치지만, 실제로 원은 겹치지 않아 없애지 못한 경우를 실패라고 하자. 실패의 총 횟수는 $O(N)$이다. 원마다 자신을&amp;nbsp;없애는데 실패한 경우를 생각하자. 자신을 없애기 위해 시도하려면 우선 자신보다 반지름이 작지 않고, 정사각형 영역은 겹치되 원은 겹치지 않아야한다. 그리고 자신을 없애기 위해 시도한 원들끼리 원이 서로 겹치면 안된다. 이러한 조건을 만족하면서 원을 가장 많이 그리면 &lt;strike&gt;최대 4개 &lt;/strike&gt;원의 크기와 상관 없이 상수 개수다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 문제의 점수를 가르는 것은 결국 반지름이 제일 큰 원을 선택하고 이 원과 정사각형 영역이 겹치는 원들을 빨리 찾아내고, 원들이 없어질 때 또한 빠르게 처리하는 것이다. 처리 과정 중 원들이 새로 생기지 않고 없어지기만 하는 점을 생각해보면, Merge sort tree를 떠올릴 수 있다. Merge sort tree에서 정사각형 모양의 2D range query를 통해 정사각형 영역이 겹치는 원들을 바로 찾아낼 수 있고, 원들의 삭제는 경로압축을 통해 간헐적으로 진행하면 실행 시간이 제일 좋다. 삭제 과정을&amp;nbsp;lazy하게 해주면 최적화에 도움이 된다. 즉, 2D range query에서 없어진 원이 발견될 때 경로 압축으로 삭제하자.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more123_1&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '123_1','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content123_1&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea name=&quot;code&quot; class=&quot;brush:cpp;&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 300005
#define pb push_back
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(), (v).end()
typedef long long lld;
typedef pair&amp;lt;int, int&amp;gt; pii;

int N;
int X[MAXN], Y[MAXN], R[MAXN], A[MAXN], P[MAXN], Q[MAXN];
int ans[MAXN];

int XX[MAXN*2], XC;

const int TS = 2097152, ST = TS/2-1;
struct NODE {
    vector &amp;lt;pii&amp;gt; arr;
    vector &amp;lt;int&amp;gt; nxt;
    int find(int n){ return nxt[n] == n ? n : (nxt[n] = find(nxt[n])); }
    void relax(){
        int n = sz(arr);
        nxt.resize(n+1);
        for (int i=0;i&amp;lt;=n;i++) nxt[i] = i;
    }
    void merge(const NODE &amp;amp;a, const NODE &amp;amp;b){
        int n = sz(a.arr), m = sz(b.arr);
        arr.resize(n+m);
        for (int i=0,j=0,k=0;i&amp;lt;n||j&amp;lt;m;){
            if (j == m || i &amp;lt; n &amp;amp;&amp;amp; a.arr[i] &amp;lt; b.arr[j]) arr[k++] = a.arr[i++];
            else arr[k++] = b.arr[j++];
        }
        relax();
    }
} tree[TS];

inline bool intersect(int a, int b){ return (lld)(X[a]-X[b])*(X[a]-X[b]) + (lld)(Y[a]-Y[b])*(Y[a]-Y[b]) &amp;lt;= (lld)(R[a]+R[b])*(R[a]+R[b]); }

void doIt(int n)
{
    auto iterate = [&amp;amp;](NODE &amp;amp;v){
        for (int i=lower_bound(all(v.arr), pii(Y[n]-R[n], 0))-v.arr.begin();;i++){
            i = v.find(i);
            if (i &amp;gt;= sz(v.arr) || v.arr[i].first &amp;gt; Y[n]+R[n]) break;
            int t = v.arr[i].second;
            if (ans[t])
                v.nxt[i] = v.find(i+1);
            else if (intersect(n, t))
                ans[t] = n;
        }
    };
    for (int l=ST+P[n],r=ST+Q[n];l&amp;lt;=r;l&amp;gt;&amp;gt;=1,r&amp;gt;&amp;gt;=1){
        if (l&amp;amp;1) iterate(tree[l++]);
        if (!(r&amp;amp;1)) iterate(tree[r--]);
    }
}

int main()
{
    scanf(&quot;%d&quot;, &amp;amp;N);
    for (int i=1;i&amp;lt;=N;i++){
        scanf(&quot;%d%d%d&quot;, X+i, Y+i, R+i);
        A[i] = i;
        XX[++XC] = X[i]-R[i];
        XX[++XC] = X[i]+R[i];
    }
    sort(XX+1, XX+XC+1); XC = unique(XX+1, XX+XC+1)-XX-1;
    sort(A+1, A+N+1, [](const int &amp;amp;a, const int &amp;amp;b){
        return R[a] != R[b] ? R[a] &amp;gt; R[b] : a &amp;lt; b;
    });

    for (int i=1;i&amp;lt;=N;i++){
        P[i] = lower_bound(XX+1, XX+XC+1, X[i]-R[i]) - XX;
        Q[i] = lower_bound(XX+1, XX+XC+1, X[i]+R[i]) - XX;
        tree[ST+P[i]].arr.pb({Y[i]-R[i], i});
        tree[ST+P[i]].arr.pb({Y[i]+R[i], i});
        tree[ST+Q[i]].arr.pb({Y[i]-R[i], i});
        tree[ST+Q[i]].arr.pb({Y[i]+R[i], i});
    }
    for (int i=1;i&amp;lt;=XC;i++) sort(all(tree[ST+i].arr)), tree[ST+i].relax();
    for (int i=ST;i;i--) tree[i].merge(tree[i+i], tree[i+i+1]);

    for (int i=1;i&amp;lt;=N;i++) if (!ans[A[i]])
        doIt(A[i]);
        
    for (int i=1;i&amp;lt;=N;i++) printf(&quot;%d%s&quot;, ans[i], i &amp;lt; N ? &quot; &quot; : &quot;&quot;);
    puts(&quot;&quot;);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4&gt;C. 이종 경기 (Duathlon)&lt;/h4&gt;
&lt;p&gt;N개의 정점과 M개의 무방향성 간선으로 이루어진 그래프가 주어진다. 이 그래프에서 서로 다른 세 정점 $s$, $c$, $f$를 선택하는데, $s$에서 $c$를 거쳐 $f$로 가는 단순경로(simple path)가 있어야한다. 이러한 조건을 만족하는 $(s, c, f)$ 순서쌍의 수를&amp;nbsp;구하는 문제다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;입력으로 주어지는 그래프가 연결그래프가 아닐 수 있지만, 각 연결요소에 대해 답을 따로 구하면 되므로 연결그래프에 대한 풀이를 생각하자. 무방향성 연결그래프에서 이중연결요소(&lt;a href=&quot;https://en.wikipedia.org/wiki/Biconnected_component&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Bi&lt;/a&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Biconnected_component&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Connected Components&lt;/a&gt;, BCC)를 생각할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;$s$에서 $c$를 거쳐 $f$로 가는 모든 경로가 단순경로가 아니라는 것은 반드시 두 번 이상 지나는 정점 $x$가 존재한다는 것이다. 그래프에서 정점 $x$를 지웠을 경우, $c$와 $s$의 연결과, $c$와 $f$의 연결이 끊어진다. 그러므로 정점 $x$가 그래프의 절단점이라는 것을 알 수 있다. 때문에, $s$와 $c$, $f$ 세 정점이 모두 같은 이중연결요소 안에 있다면 조건을 만족하는 단순경로가 반드시 존재함을 알 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이 문제를 비교적 간단히 해결하기 위해서는 답에 대한 여집합을 구하면 된다. 즉, 조건을 만족하는 단순경로가 없는 $(s, c, f)$ 순서쌍의 수를 구하면 되고, 위에서 말한 것에 따라 $s$와 $c$는 다른 이중연결요소에, $f$와 $c$는 다른 이중연결요소에 있어야한다. 위에서 링크한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Biconnected_component&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;위키 문서&lt;/a&gt;에 있는 이미지는 연결그래프의 이중연결요소들을 서로 다른 색으로 나타냈다. 참고로 여러 색을 포함하고 있는 정점은 모두 절단점이다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:384px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/993C354F5AFA953F15&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Graph-Biconnected-Components.png&quot; height=&quot;280&quot; width=&quot;384&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;정점 $c$가 빨간색 이중연결요소에 있는 경우 $(s, c, f)$의 수는 $(4-1) \times ^{11}\!P_{2} = 330$&lt;/p&gt;
&lt;p&gt;정점 $c$가 옥색 이중연결요소에 있는 경우 $(s, c, f)$의 수는 $(2-1) \times (^{4}\!P_{2} + ^{10}\!P_{2}) = 102$&lt;/p&gt;
&lt;p&gt;정점 $c$가 분홍색 이중연결요소에 있는 경우 $(s, c, f)$의 수는 $(2-1) \times (^{5}\!P_{2} + ^{9}\!P_{2}) = 92$&lt;/p&gt;
&lt;p&gt;정점 $c$가 노란색 이중연결요소에 있는 경우 $(s, c, f)$의 수는 $(2-1) \times (^{6}\!P_{2} + ^{8}\!P_{2}) = 86$&lt;/p&gt;
&lt;p&gt;정점 $c$가 파란색 이중연결요소에 있는 경우 $(s, c, f)$의 수는 $(2-1) \times ^{13}\!P_{2}&amp;nbsp;= 156$&lt;/p&gt;
&lt;p&gt;정점 $c$가 초록색 이중연결요소에 있는 경우 $(s, c, f)$의 수는 $(6-1) \times&amp;nbsp;(^{8}\!P_{2} + ^{2}\!P_{2})&amp;nbsp;= 290$&lt;/p&gt;
&lt;p&gt;정점 $c$가 회색색 이중연결요소에 있는 경우 $(s, c, f)$의 수는 $(2-1) \times&amp;nbsp;^{13}\!P_{2}&amp;nbsp;= 156$&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;최종적으로 답은 $^{14}\!P_{3} - (330+102+92+86+156+290+156) = 972$개다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more123_2&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '123_2','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content123_2&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea name=&quot;code&quot; class=&quot;brush:cpp;&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 100005
#define pb push_back
#define nP2(n) ((lld)(n)*(n-1))
#define nP3(n) ((lld)(n)*(n-1)*(n-2))
typedef long long lld;

int N, M, V;
int sz[MAXN], bccSz[MAXN]; lld pairCnt[MAXN];
int dep[MAXN], up[MAXN];
vector &amp;lt;int&amp;gt; con[MAXN];

void prec(int n, int p = 0)
{
    // DFS 트리에서 각 정점의 서브트리 크기를 미리 구해놓는 함수
    sz[n]++;
    for (int t: con[n]) if (t != p &amp;amp;&amp;amp; !sz[t]){
        prec(t, n); sz[n] += sz[t];
    }
}

lld dfs(int n, int p = 0)
{
    // BCC는 DFS 트리를 이용하여 구할 수 있다
    lld ret = 0; int cnt = 1;
    up[n] = dep[n] = dep[p]+1; bccSz[n] = 1;
    for (int t: con[n]) if (t != p){
        if (dep[t]){
            // 단순 up edge 계산
            up[n] = min(up[n], dep[t]);
        }else{
            ret += dfs(t, n);
            up[n] = min(up[n], up[t]);
            if (up[t] &amp;lt; dep[n]){
                // 이 경우, n과 p를 연결하는 간선과, n과 t를 연결하는 간선은 같은 BCC 안에 속하게 된다
                bccSz[n] += bccSz[t];
                pairCnt[n] += pairCnt[t];
            }
            else{
                // 정점 n이 절단점인 경우
                cnt += sz[t];
            }
        }
    }
    pairCnt[n] += nP2(cnt);
    if (p &amp;amp;&amp;amp; up[n] &amp;gt;= dep[p]){
        // 정점 n의 부모 정점 p가 절단점인 경우
        // 즉, 이 때 정점 n과 정점 p가 동시에 속한 BCC에 대해 경우의 수를 계산한다
        ret += (lld)bccSz[n] * (pairCnt[n] + nP2(V-sz[n]));
        // bccSz[n]: 실제 BCC 크기 - 1 (왜냐하면 정점 p가 개수에 포함되지 않았기 때문)
        // pairCnt[n]: DFS 트리에서 정점 n의 서브트리에 대한 (s, f) 순서쌍의 총 개수
        // nP2(V-sz[n]): DFS 트리에서 절단점 p와 연결되어있는 부분에 대해 (s, f) 순서쌍 개수
    }
    return ret;
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;amp;N, &amp;amp;M);
    for (int i=1;i&amp;lt;=M;i++){
        int a, b; scanf(&quot;%d%d&quot;, &amp;amp;a, &amp;amp;b);
        con[a].pb(b); con[b].pb(a);
    }
    lld ans = 0;
    for (int i=1;i&amp;lt;=N;i++) if (!sz[i]){
        prec(i); V = sz[i];
        ans += nP3(sz[i]) - dfs(i);
    }
    printf(&quot;%lld\n&quot;, ans);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>해법</category>
<author>전명우</author>
<guid>https://blog.myungwoo.kr/123</guid>
<comments>https://blog.myungwoo.kr/123#entry123comment</comments>
<pubDate>Thu, 17 May 2018 10:06:52 +0900</pubDate>
</item>
<item>
<title>ACM ICPC World Finals 2018</title>
<link>https://blog.myungwoo.kr/122</link>
<description>&lt;p&gt;&lt;a href=&quot;https://icpc.baylor.edu/worldfinals/problems/icpc2018.pdf&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;문제 링크&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3 id=&quot;prob_B&quot;&gt;B. Comma Sprinkler&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;길이가 최대 1,000,000인 문장들이 주어진다. 어떤 단어 앞에 콤마(,)가 오면 같은 단어&amp;nbsp;앞에 모두 콤마가 오도록 바꾸며, 어떤 단어 뒤에 콤마가 올 경우 같은 단어 뒤에 모두 콤마가 오도록 바꿔야한다. 단, 단어의 끝과 시작에서 부자연스럽게 콤마를 추가하진 않는다. 이 때, 최종 문장을 구하는 문제다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;같은 단어들을 묶어 정점으로 만든다. 그리고 정점을 단어 앞에 콤마가 오는 경우, 단어 뒤에 콤마가 오는 경우를 나타내는 두 정점으로 이원화한다. 단어 앞에 콤마가 오거나, 단어 뒤에 콤마가 오는 경우 해당하는 정점에 색칠은 한 뒤, 원래 문장에서 인접한 두 단어의 정점에는 방향성 간선을 만들어주어 Flood-Fill 한다. 그러면 시간복잡도 $O(V+E)$만에 문제에서 요구하는 조건을 만족시킬 수 있다. 단어를 정점으로 만들 때, set등을 쓰지 않고 trie를 사용하면 $O(N)$ 시간에 문제를 해결할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more122_0&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '122_0','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content122_0&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 1000006
#define pb push_back

int N, K;
bool V[MAXN][2];
char S[MAXN];
string words[MAXN];
vector &amp;lt;int&amp;gt; con[MAXN][2];
vector &amp;lt;pair&amp;lt;int, bool&amp;gt;&amp;gt; A;

struct NODE {
    NODE(): num(0){ for (int i=0;i&amp;lt;26;i++) nxt[i] = 0; }
    int num;
    NODE *nxt[26];
} root;

int getNum(char *str)
{
    NODE *now = &amp;amp;root;
    for (int i=0;str[i];i++){
        if (!now-&amp;gt;nxt[str[i]-'a'])
            now-&amp;gt;nxt[str[i]-'a'] = new NODE();
        now = now-&amp;gt;nxt[str[i]-'a'];
    }
    if (!now-&amp;gt;num){
        now-&amp;gt;num = ++K;
        words[K] = str;
    }
    return now-&amp;gt;num;
}

int main()
{
    fgets(S+1, MAXN-2, stdin);
    N = strlen(S+1);

    bool bef = 0; int last = 0;
    for (char *pt=strtok(S+1, &quot; \n\r&quot;);pt;pt=strtok(0, &quot; \n\r&quot;)){
        int n = strlen(pt);
        bool aft = 0, end = 0;
        if (pt[n-1] == ',')
            pt[--n] = 0, aft = 1;
        if (pt[n-1] == '.')
            pt[--n] = 0, end = 1;
        int k = getNum(pt);
        if (bef) V[k][0] = 1;
        if (aft) V[k][1] = 1;
        if (last)
            con[k][0].pb(last), con[last][1].pb(k);
        bef = aft; last = k;
        A.pb({k, end});
        if (end) last = 0;
    }

    queue &amp;lt;int&amp;gt; que;
    for (int i=1;i&amp;lt;=K;i++) for (int j=0;j&amp;lt;2;j++) if (V[i][j]) que.push(i), que.push(j);
    while (!que.empty()){
        int q = que.front(); que.pop();
        int p = que.front(); que.pop();
        for (int t: con[q][p]){
            if (V[t][!p]) continue;
            V[t][!p] = 1; que.push(t); que.push(!p);
        }
    }

    int prv = 0; bool end = 0, prv_out = 1;
    for (const auto &amp;amp;s: A){
        if (V[s.first][0] &amp;amp;&amp;amp; !end &amp;amp;&amp;amp; !prv_out) putchar(',');
        if (prv) putchar(' ');
        printf(&quot;%s&quot;, words[s.first].c_str());
        if (V[s.first][1] &amp;amp;&amp;amp; !s.second) putchar(','), prv_out = 1;
        else prv_out = 0;
        if (s.second) putchar('.');
        prv = s.first; end = s.second;
    }
    puts(&quot;&quot;);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3 id=&quot;prob_F&quot;&gt;F. Go with the Flow&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;단어 $N$개가 주어진다. 각 단어의 최대 길이는 80이다. 종이의 폭을 적절히 정해 생기는 공백 강(세로로 늘어진 공백 행렬)의 길이를 최대화하는 문제다. 단, 줄의 오른쪽 끝에 자연스럽게 생기는 공백은 공백 강에 포함되지 않는다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;폭으로 가능한 길이의 종류 수는 약 $80N$이며, 폭에 따라 생기는 공백의 개수는 최대 $N$개다. 임의의 폭을 정했을 때, 공백 강의 최대 길이를 two-pointers algorithm과 DP를 통해 $O(N)$ 시간복잡도로 구할 수 있다. 따라서 이 문제를 $O(N^2)$에 해결할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more122_1&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '122_1','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content122_1&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 2503
#define pb push_back
#define sz(v) ((int)(v).size())
typedef pair&amp;lt;int, int&amp;gt; pii;

int N, X;
int A[MAXN], S[MAXN];

auto f = [](int width){
    int next_width = 2e9;
    vector &amp;lt;pii&amp;gt; arr;
    for (int s=1,y=1;s&amp;lt;=N;s++,y++){
        int e = s;
        while (e &amp;lt; N &amp;amp;&amp;amp; S[e+1]-S[s-1]+e-s+1 &amp;lt;= width) e++;
        if (e &amp;lt; N) next_width = min(next_width, S[e+1]-S[s-1]+e-s+1);
        for (int i=s;i&amp;lt;e;i++)
            arr.pb({y, S[i]-S[s-1]+i-s+1});
        s = e;
    }
    int n = sz(arr);
    vector &amp;lt;int&amp;gt; dp(n, 1);
    int ret = 0;
    for (int i=0,p=0;i&amp;lt;n;i++){
        int y = arr[i].first, x = arr[i].second;
        while (p &amp;lt; n &amp;amp;&amp;amp; arr[p] &amp;lt; pii{y-1, x-1}) p++;
        for (int j=p;j&amp;lt;n;j++){
            if (arr[j] &amp;gt; pii{y-1, x+1}) break;
            dp[i] = max(dp[i], dp[j]+1);
        }
        ret = max(ret, dp[i]);
    }
    return make_tuple(ret, next_width);
};

int main()
{
    scanf(&quot;%d&quot;, &amp;amp;N);
    for (int i=1;i&amp;lt;=N;i++){
        char buf[82]={0,}; scanf(&quot;%s&quot;, buf);
        A[i] = strlen(buf); S[i] = S[i-1]+A[i];
        X = max(X, A[i]);
    }
    int ans = 0, answ;
    for (int width=X;width&amp;lt;2e9;){
        int mx, nxt;
        tie(mx, nxt) = f(width);
        if (ans &amp;lt; mx) ans = mx, answ = width;
        width = nxt;
    }
    printf(&quot;%d %d\n&quot;, answ, ans);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3 id=&quot;prob_K&quot;&gt;K. Wireless is the New Fiber&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;$N$개의 정점과, $M$개의 간선으로 이루어진 연결그래프가 주어진다. $N$개의 정점으로 구성된 기존 그래프와 전혀 다른 트리를 새로 만드는데, 차수(degree)가 변한 정점의 수를 최소화하도록 만드는 문제다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이 문제는 두 파트로 풀이가 나뉜다. 첫 번째 파트는 차수가 변환 정점 수를 최소화하면서 새로 만드는&amp;nbsp;트리의 각 정점 차수를 구하는 것이고, 두 번째 파트는 구한 각 정점의 차수를 기반으로 트리를 만들어서 출력하는 것이다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;우선, $N$개의 정점 차수 합이 $2 \times (N-1)$이면서 각 정점의 차수가 1이상 $N-1$이하라면, 해당 차수에 알맞은 트리를 항상 만들 수 있다. 이는 필요충분조건이다.&lt;/p&gt;&lt;p&gt;이를 이용하여, 첫 번째 파트를 해결한다. &quot;차수가 변한 정점의 개수가&amp;nbsp;$x$개 이하면서 모든 정점의 차수를 1이상 N-1이하로 맞출 수 있느냐&quot;라는 결정 문제를 생각해보자. 이는 greedy하게 해결이 가능한데, 차수가 제일 큰 상위 $x$개 정점의 차수를 변화시켜 가능한지 여부를 간단한 수학으로 계산하면 된다. Parametric search와 결정 문제 풀이를 이용해서 첫 번째 파트를 해결할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;두 번째 파트는 풀이가 더 간단하다. 각 정점의 차수를 모두 알고 있는 상태에서 트리를 구현하는 문제를 해결하면 된다. 차수 크기의 역순으로 정점들을 정렬한 뒤에, 차수가 큰 정점들끼리 우선으로 간선을 만들어주면 결국 트리가 완성된다. 이와 관련된 증명은 &quot;$k &amp;lt; N$일 때, 차수가 가장 큰 상위 $k$개&amp;nbsp;정점의 차수 합은 $2 \times (k-1)$을 넘는다.&quot;는 사실을 통해 할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more122_2&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '122_2','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content122_2&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 10004
#define pb push_back
#define all(v) (v).begin(), (v).end()
typedef pair&amp;lt;int, int&amp;gt; pii;

int N, M;
int deg[MAXN];

bool proc(int cnt, bool fix=0)
{
	vector &amp;lt;pii&amp;gt; arr;
	for (int i=1;i&amp;lt;=N;i++) arr.pb({deg[i], i});
	sort(all(arr), greater&amp;lt;pii&amp;gt;());
	int sum = 0;
	for (int i=cnt;i&amp;lt;N;i++) sum += arr[i].first;
	if (sum+cnt &amp;gt; 2*(N-1)) return 0;
	if (!fix || !cnt) return 1;
	int remain = 2*(N-1) - sum - cnt;
	for (int i=0;i&amp;lt;cnt;i++) deg[arr[i].second] = 1;
	int avg = remain / cnt, rest = remain % cnt;
	for (int i=0;i&amp;lt;cnt;i++) deg[arr[i].second] += avg + (i &amp;lt; rest);
	return 1;
}

int main()
{
	scanf(&quot;%d%d&quot;, &amp;amp;N, &amp;amp;M);
	for (int i=1;i&amp;lt;=M;i++){
		int a, b; scanf(&quot;%d%d&quot;, &amp;amp;a, &amp;amp;b); a++; b++;
		deg[a]++; deg[b]++;
	}
	int s = 0, e = N, ans;
	while (s &amp;lt;= e){
		int m = s+e &amp;gt;&amp;gt; 1;
		if (proc(m)) e = m-1, ans = m;
		else s = m+1;
	}
	proc(ans, 1);
	printf(&quot;%d\n%d %d\n&quot;, ans, N, N-1);
	vector &amp;lt;int&amp;gt; ord;
	for (int i=1;i&amp;lt;=N;i++) ord.pb(i);
	sort(all(ord), [](const int &amp;amp;a, const int &amp;amp;b){ return deg[a] &amp;gt; deg[b]; });
	int pt = 1;
	for (int n: ord){
		while (deg[n]--){
			printf(&quot;%d %d\n&quot;, n-1, ord[pt]-1);
			deg[ord[pt++]]--;
		}
	}
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3 id=&quot;prob_A&quot;&gt;A. Catch the Plane&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;$N$개의 버스정류장과 $M$개의 버스 운행 정보가 있다. 버스 운행 정보는 시작점과 도착점, 출발시각과 도착시각, 그리고 파업 확률이 주어진다. 한 순간에 한 정류장에서 여러 버스가 출발하면 그 중에 하나만 선택하여 &quot;탑승 시도&quot;를 할 수 있다. 이 때, 0번 정류장에서 시작하여 1번 정류장까지 이동할 때, 도착 확률이 최대가 되도록 전략을 짜는 문제다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;여기서 도착 시간제한 $K$가 입력으로 주어지지만, 모든 버스의 도착 시각이 $K$이내인 관계로 $K$ 값 자체와 시간제한 자체가 의미가 없다. 이 문제 풀이의 핵심 아이디어는 DP를 거꾸로 계산한다는 것이다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;다음과 같은 DP 테이블을 생각하자:&lt;/p&gt;&lt;p&gt;D[i][j] = j 시간에 i번 정류장에서 출발할 때, 도착 지점까지 가는 최고 확률&lt;/p&gt;&lt;p&gt;j 시간에 만약 k번 정류장으로 가는 버스가 있고 도착시각이 t이며 파업확률이 p라고 할 때, 이 버스 탑승을 시도할&amp;nbsp;경우 도착 확률은 D[k][t+1]*p + D[i][j+1]*(1-p)로 계산할 수 있다. 만약 탑승 시도를 하지 않고 시간을 보내는 경우 도착 확률은 D[i][j+1]이다. 이 중에 제일 높은 확률을 D[i][j]에 대입하는 것으로 점화식을 세울 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;문제는 시간 범위가 최대 10&lt;sup&gt;18&lt;/sup&gt;으로 굉장히 크다는 것이다. 위에서 설명한 DP를 버스 도착시각 역순으로 계산해가면서 대기 힙과 큐를 이용하여 계산하면 2차원 테이블 없이 1차원 배열만으로 이 문제의 답을 구할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more122_3&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '122_3','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content122_3&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 1000006
typedef long long lld;

int N, M; lld K;
double P[MAXN];

struct EDGE {
    int a, b; lld x, y; double p;
} edge[MAXN];

struct INFO {
    lld k; int n, e; double p;
    bool operator &amp;lt; (const INFO &amp;amp;ot)const{
        return k &amp;lt; ot.k;
    }
};

int main()
{
    scanf(&quot;%d%d%lld&quot;, &amp;amp;M, &amp;amp;N, &amp;amp;K);
    for (int i=1;i&amp;lt;=M;i++){
        int a, b; lld x, y; double p;
        scanf(&quot;%d%d%lld%lld%lf&quot;, &amp;amp;a, &amp;amp;b, &amp;amp;x, &amp;amp;y, &amp;amp;p);
        edge[i] = {++a, ++b, x, y, p};
    }
    sort(edge+1, edge+M+1, [](const EDGE &amp;amp;a, const EDGE &amp;amp;b){
        return a.y &amp;gt; b.y;
    });
    priority_queue &amp;lt;INFO&amp;gt; que;
    P[2] = 1; edge[M+1].y = -1;
    for (int i=1;i&amp;lt;=M+1;i++){
        queue &amp;lt;pair&amp;lt;int, double&amp;gt;&amp;gt; wait; lld last = -1;
        auto flush = [&amp;amp;wait](){
            while (!wait.empty()){
                auto q = wait.front(); wait.pop();
                P[q.first] = max(P[q.first], q.second);
            }
        };
        while (!que.empty()){
            INFO q = que.top();
            if (q.k &amp;lt;= edge[i].y) break;
            que.pop();
            if (last != q.k) flush(), last = q.k;
            wait.push({q.n, q.p*edge[q.e].p + P[q.n]*(1-edge[q.e].p)});
        }
        flush();
        if (i &amp;gt; M) break;
        que.push({edge[i].x, edge[i].a, i, P[edge[i].b]});
    }
    printf(&quot;%.9f\n&quot;, P[1]);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3 id=&quot;prob_H&quot;&gt;H. Single Cut of Failure&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;$W \times H$ 크기의 직사각형 안에 $N$개의 선분이 주어진다. 선분의 양 끝 점은 직사각형 변 위에 있으며, 꼭지점과 겹치지 않고 선분의 끝 점이 서로 겹치게 주어지지 않는다. 또한 선분이 직사각형 변에 포함되게 주어지지 않는다. 주어진 $N$개의 선분과 모두 교차하게 최소 개수의 선분을 그리는 문제다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;두 대각선을 X 모양으로 그리면 입력이 어떤 식으로 들어오든 상관 없이 모든 선분과 교차함을 알 수 있다. 따라서, 답은 1개 혹은 2개이며, 2개일 경우 출력 내용은 선분과 상관없이 고정된다. 즉, 이 문제는 1개의 선분만을 그려 모든 선분과 교차할 수 있는지 판단하고 가능하다면 그 선분을 어떻게 그릴 것인가를 구하면 해결된다. &lt;strike&gt;문제 제목이 Single Cut of Failure인 것은 풀이에 대한 스포일러다.&lt;/strike&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;입력으로 들어온 $N$개의 선분을 1차원 구간으로 펴서 $N$개의 구간으로 만들고 모든 구간과 교차하는 구간이 존재하는지 여부를 구해 답이 1개인지 확인하면 된다. 확인하는 과정에서 모든 구간과 교차하는 구간의 생김세 또한 구할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more122_4&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '122_4','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content122_4&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 1000006
#define mt make_tuple

int N, W, H;
struct Z{
    int s, e;
} A[MAXN];

int getNum(int x, int y)
{
    if (y == 0) return x;
    if (x == W) return W+y;
    if (y == H) return W+H+W-x;
    return W+H+W+H-y;
}

auto getCoord = [](double v){
    if (v &amp;lt; W) return mt(v, 0.); v -= W;
    if (v &amp;lt; H) return mt((double)W, v); v -= H;
    if (v &amp;lt; W) return mt(W-v, (double)H); v -= W;
    return mt(0., H-v);
};

bool checkOneShot()
{
    sort(A+1, A+N+1, [](const Z &amp;amp;a, const Z &amp;amp;b){
        return a.e &amp;lt; b.e;
    });
    vector &amp;lt;int&amp;gt; p(N+1, 0), q(N+1, 0);
    p[N] = q[N] = A[N].s;
    for (int i=N;--i;)
        p[i] = max(p[i+1], A[i].s),
        q[i] = min(q[i+1], A[i].s);
    int max_s = 0;
    for (int i=1;i&amp;lt;=N;i++){
        max_s = max(max_s, A[i].s);
        if (A[1].e &amp;lt;= max_s) break;
        // max_s 보다 0.5 큰 곳에 시작점을 놓고,
        // A[i].e 보다 큰 곳에 도착점을 놓는다.
        // j &amp;gt; i인 A[j].s는 모두 max_s보다 커야 한다.
        // j &amp;gt; i인 A[j].s는 모두 A[i+1].e 보다 작아야한다.
        // 그러면 A[i+1].e 보다 0.5 작은 곳에 도착점을 둔다.
        if (i == N || q[i+1] &amp;gt; max_s &amp;amp;&amp;amp; p[i+1] &amp;lt; A[i+1].e){
            double ax, ay, bx, by;
            tie(ax, ay) = getCoord(max_s+0.5);
            tie(bx, by) = getCoord(i == N ? H+H+W+W-0.5 : A[i+1].e-0.5);
            printf(&quot;1\n%.1f %.1f %.1f %.1f\n&quot;, ax, ay, bx, by);
            return 1;
        }
    }
    return 0;
}

int main()
{
    scanf(&quot;%d%d%d&quot;, &amp;amp;N, &amp;amp;W, &amp;amp;H);
    for (int i=1;i&amp;lt;=N;i++){
        int x, y;
        scanf(&quot;%d%d&quot;, &amp;amp;x, &amp;amp;y);
        A[i].s = getNum(x, y);
        scanf(&quot;%d%d&quot;, &amp;amp;x, &amp;amp;y);
        A[i].e = getNum(x, y);
        if (A[i].s &amp;gt; A[i].e) swap(A[i].s, A[i].e);
    }
    if (!checkOneShot())
        printf(&quot;2\n%d %.1f %d %.1f\n%d %.1f %d %.1f\n&quot;, 0, H-0.5, W, 0.5, 0, 0.5, W, H-0.5);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3 id=&quot;prob_I&quot;&gt;I. Triangles&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;입력으로 그림이 주어지면, 그림 안에 정삼각형의 개수를 세는 문제다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;우선,&amp;nbsp;△ 모양의 삼각형의 개수만 세면 전체 정삼각형의 개수를 셀 수 있다.&amp;nbsp;▽ 모양의 삼각형은 전체 그림을 상하로 뒤집은 다음 △ 모양의 삼각형의 개수를 한 번 더 세는 방식으로 셀 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;△ 모양의 삼각형의 개수는 각 지점마다 오른쪽 위(&lt;span style=&quot;font-family: Menlo, Monaco, Consolas, monospace;&quot;&gt;/&lt;/span&gt;)로 변의 길이와, 왼쪽 위로(&lt;span style=&quot;font-family: Menlo, Monaco, Consolas, monospace;&quot;&gt;\&lt;/span&gt;)로 변의 길이를 칸 마다 계산해두고, Fenwick Tree와 Heap을 통해 계산할 수 있다. 풀이를 말로 풀어쓰기 복잡하여, 풀이는 코드를 참고하자.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more122_5&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '122_5','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content122_5&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define notSpace(x) (x != 0 &amp;amp;&amp;amp; x != ' ')
typedef long long lld;

int yy[]={0, -1, -1, 0, 1, 1}, xx[]={-2, -1, 1, 2, 1, -1};
int N, M;
char A[6004][12003];
bool con[3002][6001][3];
int P[6001], Q[6001];
int bit[6001];

int add(int n, int v){ for (;n&amp;lt;=M;n+=(n&amp;amp;-n)) bit[n] += v; }
int get(int n){ int ret = 0; for (;n;n^=(n&amp;amp;-n)) ret += bit[n]; return ret; }

lld count()
{
	lld ret = 0;
	for (int i=1;i&amp;lt;=N;i++) for (int j=2-(i&amp;amp;1);j&amp;lt;=M;j+=2) for (int k=0;k&amp;lt;3;k++){
		int y = i+yy[k], x = j+xx[k];
		if (y &amp;lt; 1 || y &amp;gt; N || x &amp;lt; 1 || x &amp;gt; M) continue;
		int ty = i+i-1, tx = j+j-1;
		con[i][j][k] = notSpace(A[ty+yy[k]][tx+xx[k]]);
	}
	for (int i=1;i&amp;lt;=N;i++){
		struct QUE{
			int out, x;
			bool operator &amp;lt; (const QUE &amp;amp;ot)const{
				return out &amp;gt; ot.out;
			}
		};
		priority_queue &amp;lt;QUE&amp;gt; que;
		int horz = 0;
		for (int j=1;j&amp;lt;=M;j++) bit[j] = 0;
		for (int j=2-(i&amp;amp;1);j&amp;lt;=M;j+=2){
			while (!que.empty()){
				QUE q = que.top();
				if (q.out &amp;gt;= j) break;
				que.pop();
				add(q.x, -1);
			}
			P[j] = con[i][j][2] ? P[j+1] + 1 : 0;
			Q[j] = con[i][j][1] ? Q[j-1] + 1:  0;
			horz = con[i][j][0] ? horz + 1 : 0;
			int s = min(horz, Q[j]);
			ret += get(j)-get(j-s-s-1);

			que.push({j+P[j]+P[j], j});
			add(j, 1);
		}
	}
	// flip
	for (int i=1;i&amp;lt;N+N-i;i++) for (int j=1;j&amp;lt;M+M;j++) swap(A[i][j], A[N+N-i][j]);
	for (int i=1;i&amp;lt;N+N;i++) for (int j=1;j&amp;lt;M+M;j++){
		char c = A[i][j];
		if (c == '/') A[i][j] = '\\';
		if (c == '\\') A[i][j] = '/';
	}
	return ret;
}

int main()
{
	scanf(&quot;%d%d &quot;, &amp;amp;N, &amp;amp;M);
	for (int i=1;i&amp;lt;N+N;i++) gets(A[i]+1);
	if (!(N&amp;amp;1)) N++; // make N odd for Y axis flip
	lld ans = count()+count();
	printf(&quot;%lld\n&quot;, ans);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>World Finals</category>
<author>전명우</author>
<guid>https://blog.myungwoo.kr/122</guid>
<comments>https://blog.myungwoo.kr/122#entry122comment</comments>
<pubDate>Tue, 08 May 2018 18:07:17 +0900</pubDate>
</item>
<item>
<title>2017년 대학생 프로그래밍 경시대회 풀이</title>
<link>https://blog.myungwoo.kr/121</link>
<description>&lt;p&gt;&lt;a href=&quot;http://icpckorea.org/2017/regional/problemset-2017.pdf&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;문제 링크&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3&gt;D. Happy Number&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;문제에 적혀 있는 함수 $f$가 있다. $f(f(f(...f(n))))$을 했을 때, 1이 되는지를 구하는 문제다.&lt;/p&gt;&lt;p&gt;입력으로 주어지는 수는 최대 1,000,000,000인데, 큰 수가 주어진다하더라도 $f(n)$의 결과값은 작다. 때문에 이 문제는 함수 $f$를 구현하고 결과값이 1이 되는지만 확인하는 간단한 문제가 된다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more121_0&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '121_0','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content121_0&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int N;

int main()
{
    set &amp;lt;int&amp;gt; vis;
    scanf(&quot;%d&quot;, &amp;amp;N);
    while (N &amp;gt; 1){
        if (vis.count(N)){ puts(&quot;UNHAPPY&quot;); return 0; }
        vis.insert(N);
        int nxt = 0;
        for (int v=N;v;v/=10)
            nxt += (v%10)*(v%10);
        N = nxt;
    }
    puts(&quot;HAPPY&quot;);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3&gt;C. Game Map&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;N개의 정점과 M개의 간선으로 이루어진 무방향성 그래프가 주어진다. 임의의 정점에서 시작하여 방문하는 정점의 차수(degree)가 증가하도록 이동하는 경로 중에서 가장 긴 경로의 길이를 구하는 문제다.&lt;/p&gt;&lt;p&gt;아래와 같은 DP배열을 생각하자.&lt;/p&gt;&lt;p&gt;D[i] = 임의의 시작점에서 정점 i까지 오는 경로 중에서 가장 긴 경로의 길이.&lt;/p&gt;&lt;p&gt;차수가 낮은 정점부터 차례대로 DP 값을 뿌려주거나, DP 값을 계산하면 올바르게 DP 값을 구할 수 있다.&lt;/p&gt;&lt;p&gt;정점을 차수 순서대로 정렬해야하므로, 시간복잡도는 $O(N \lg N + M)$이 된다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more121_1&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '121_1','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content121_1&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 100005
#define pb push_back

int N, M;
int D[MAXN], deg[MAXN];
int order[MAXN];
vector &amp;lt;int&amp;gt; con[MAXN];

int main()
{
    scanf(&quot;%d%d&quot;, &amp;amp;N, &amp;amp;M);
    for (int i=1;i&amp;lt;=M;i++){
        int a, b; scanf(&quot;%d%d&quot;, &amp;amp;a, &amp;amp;b);
        deg[++a]++; deg[++b]++;
        con[a].pb(b); con[b].pb(a);
    }
    for (int i=1;i&amp;lt;=N;i++) order[i] = i;
    sort(order+1, order+N+1, [](const int &amp;amp;a, const int &amp;amp;b){
        return deg[a] &amp;lt; deg[b];
    });
    for (int i=1;i&amp;lt;=N;i++) D[i] = 1;
    for (int i=1;i&amp;lt;=N;i++){
        int n = order[i];
        for (int t: con[n]) if (deg[n] &amp;lt; deg[t])
            D[t] = max(D[t], D[n]+1);
        }
    int ans = 0;
    for (int i=1;i&amp;lt;=N;i++) ans = max(ans, D[i]);
    printf(&quot;%d\n&quot;, ans);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3&gt;F.&amp;nbsp;Philosopher's Walk&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;문제에서 주어진 그림처럼 재귀적으로 문양을 그린다. 문양의 크기 n과 순서 m이 주어졌을 때, 문양을 그리면서 m번째로 방문한 칸의 좌표를 구하는 문제다.&lt;/p&gt;&lt;p&gt;이 문제는 문양을 직접 2차원 배열에 그리지 않되, 재귀함수를 잘 짜서 문양을 그리는 로직을 작성하면 해결할 수 있다. 재귀함수의 구성이나, 자세한 테크닉은 코드를 참고하자. 시간복잡도는 $O(\lg N)$이다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more121_2&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '121_2','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content121_2&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int N, M;

void get(int n, int m, int sx=1, int sy=1, vector &amp;lt;int&amp;gt; order={0, 2, 3, 1})
{
    int h = n/2, k = h*h;
    if (m &amp;lt; 1 || m &amp;gt; n*n) return;
    if (n == 1){ printf(&quot;%d %d\n&quot;, sx, sy); return; }
    get(h, m,     sx+(order[0]&amp;amp;1)*h, sy+(order[0]&amp;amp;2)/2*h, {order[0], order[3], order[2], order[1]});
    get(h, m-k,   sx+(order[1]&amp;amp;1)*h, sy+(order[1]&amp;amp;2)/2*h, order);
    get(h, m-k*2, sx+(order[2]&amp;amp;1)*h, sy+(order[2]&amp;amp;2)/2*h, order);
    get(h, m-k*3, sx+(order[3]&amp;amp;1)*h, sy+(order[3]&amp;amp;2)/2*h, {order[2], order[1], order[0], order[3]});
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;amp;N, &amp;amp;M);
    get(N, M);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3&gt;H. Rock Paper Scissors&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;길이가 N인 가위바위보 문자열과 길이가 M인 가위바위보 문자열이 주어진다. 길이가 M인 가위바위보 문자열을 원하는 시점에서 시작하여, 최대한 많은 승수를 쌓는 문제다. 길이가 M인 가위바위보 문자열이 오른쪽으로 삐져나가도 괜찮다.&lt;/p&gt;&lt;p&gt;길이가 N인 가위바위보 문자열의 각 문자를 이기는 문자로 바꾼다. 즉,&amp;nbsp;'R'은 'P'로, 'P'는 'S'로, 'S'는 'R'로 바꾼다. 그러면 이제 문제는 길이가 N인 전체 문자열이 있고, 길이가 M인 패턴 문자열이 있고, 패턴과 가장 많은 문자가 겹치는 순간을 찾는 문제가 된다.&lt;/p&gt;&lt;p&gt;문자의 종류수가 3 종류라는 것을 감안했을 때, &lt;a href=&quot;http://blog.myungwoo.kr/54&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;FFT&lt;/a&gt;를 이용하여 각 문자 종류마다 패턴이 어느 위치에 갔을 때 겹치는 칸의 수를 구할 수 있다. 이를 합산하면 문제가 해결된다. 시간복잡도는 $O(N \lg N)$이다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more121_3&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '121_3','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content121_3&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot; style=&quot;margin-top: 0px; margin-bottom: 0px; height: 134px;&quot;&gt;#define _USE_MATH_DEFINES
#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 100005
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()
typedef complex&amp;lt;double&amp;gt; base;
 
void fft(vector &amp;lt;base&amp;gt; &amp;amp;a, bool invert)
{
    int n = sz(a);
    for (int i=1,j=0;i&amp;lt;n;i++){
        int bit = n &amp;gt;&amp;gt; 1;
        for (;j&amp;gt;=bit;bit&amp;gt;&amp;gt;=1) j -= bit;
        j += bit;
        if (i &amp;lt; j) swap(a[i],a[j]);
    }
    for (int len=2;len&amp;lt;=n;len&amp;lt;&amp;lt;=1){
        double ang = 2*M_PI/len*(invert?-1:1);
        base wlen(cos(ang),sin(ang));
        for (int i=0;i&amp;lt;n;i+=len){
            base w(1);
            for (int j=0;j&amp;lt;len/2;j++){
                base u = a[i+j], v = a[i+j+len/2]*w;
                a[i+j] = u+v;
                a[i+j+len/2] = u-v;
                w *= wlen;
            }
        }
    }
    if (invert){
        for (int i=0;i&amp;lt;n;i++) a[i] /= n;
    }
}
 
void multiply(const vector&amp;lt;int&amp;gt; &amp;amp;a,const vector&amp;lt;int&amp;gt; &amp;amp;b,vector&amp;lt;int&amp;gt; &amp;amp;res)
{
    vector &amp;lt;base&amp;gt; fa(all(a)), fb(all(b));
    int n = 1;
    while (n &amp;lt; max(sz(a),sz(b))) n &amp;lt;&amp;lt;= 1;
    fa.resize(n); fb.resize(n);
    fft(fa,false); fft(fb,false);
    for (int i=0;i&amp;lt;n;i++) fa[i] *= fb[i];
    fft(fa,true);
    res.resize(n);
    for (int i=0;i&amp;lt;n;i++) res[i] = int(fa[i].real()+(fa[i].real()&amp;gt;0?0.5:-0.5));
}

int N, M;
int code[128];
char A[MAXN], B[MAXN];

int main()
{
    code['R'] = 0, code['P'] = 1, code['S'] = 2;
    scanf(&quot;%d%d%s%s&quot;, &amp;amp;N, &amp;amp;M, A, B);
    vector &amp;lt;int&amp;gt; total(N+M, 0);
    for (int i=0;i&amp;lt;N;i++) A[i] = (code[A[i]]+1)%3;
    for (int i=0;i&amp;lt;M;i++) B[i] = code[B[i]];
    for (int i=0;i&amp;lt;3;i++){
        vector &amp;lt;int&amp;gt; a(N+M, 0), b(M, 0), res;
        for (int j=0;j&amp;lt;N;j++) a[j] = (A[j] == i);
        for (int j=0;j&amp;lt;M;j++) b[j] = (B[M-j-1] == i);
        multiply(a, b, res);
        for (int j=0;j&amp;lt;N+M;j++) total[j] += res[j];
    }
    int ans = 0;
    for (int i=M-1;i&amp;lt;N+M;i++) ans = max(ans, total[i]);
    printf(&quot;%d\n&quot;, ans);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3&gt;K. Untangling Chain&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;원점에서 시작하여 임의의 거리를 이동하고 90도 회전을 반복한다. 회전 방향들이 주어졌을 때, 이동 거리를 잘 정해 경로를 선으로 그렸을 때 교차하지 않도록하는 문제다.&lt;/p&gt;&lt;p&gt;여러 가지 방법이 가능한데, 알고 있는 방법 중 가장 간단한 방법을 코드로 첨부한다. 모든 입력 데이터에 대해 답은 존재하며, 방법은 귀납법으로 증명 가능하다. 증명 방향은 이동이 진행되면 될수록 앞으로 움직이는 정사각형 영역의 이 한 단계씩 줄어들고 그 영역을 벗어나지 않는다. 시간복잡도는 $O(N)$이다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more121_4&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '121_4','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content121_4&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 10004

int N;
int A[MAXN];

int main()
{
    scanf(&quot;%d&quot;, &amp;amp;N);
    for (int i=1;i&amp;lt;=N;i++) scanf(&quot;%*d%d&quot;, A+i);
    for (int i=1;i&amp;lt;=N;i++) printf(&quot;%d &quot;, A[i] == A[i+1] ? N-i+1 : 1); puts(&quot;&quot;);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3&gt;B. Connect3&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;두 사람이 4x4 크기의 격자판에서 번갈아가면서 3목을 진행한다. 단, 돌을 놓을 때는 맨 밑바닥에 놓거나, 놓으려는 자리 밑에 돌이 있어야지만 놓을 수 있다. 이 때 후공이 특정 위치에 돌을 놓는 순간 이기게 되는 경우의 수를 구하는 문제다.&lt;/p&gt;&lt;p&gt;기본적으로 돌을 놓기 위해서는 맨 밑바닥에 놓거나 놓으려는 자리 밑에 돌이 있어야한다. 때문에 가능한 경우의 수를 간략하게 계산하면, 최대 $(2^5-1)^4 = 923,521$가지 밖에 되지 않는다. 그리고 4x4 게임판 상태 표현은 $0$이상 $3^{16} = 43,046,721$미만의 정수 하나로 할 수 있다. 이러한 수를 살펴보면 이 문제는 간단히 brute force하여 해결할 수 있는 문제라는 것을 알 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more121_5&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '121_5','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content121_5&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

const int ALL = 43046721; // 3^16
int TP[16] = {1};
int S, Y, X, ans;
char vis[ALL], chkvis[ALL], cache[ALL];

inline int to_num(int y, int x){ return (y-1)*4+(x-1); }

const int dy[]={0, 1, 1, 1}, dx[]={1, 1, 0, -1};
inline int check(int now)
{
    char &amp;amp;ret = cache[now];
    if (chkvis[now]) return ret;
    chkvis[now] = 1;
    int A[5][5] = {0, };
    for (int i=1;i&amp;lt;=4;i++) for (int j=1;j&amp;lt;=4;j++){
        int t = to_num(i, j);
        A[i][j] = now / TP[t] % 3;
    }
    for (int i=1;i&amp;lt;=4;i++) for (int j=1;j&amp;lt;=4;j++) if (A[i][j]){
        for (int d=0;d&amp;lt;4;d++){
            int y = i, x = j, cnt = 0;
            for (;;){
                if (y &amp;gt; 4 || x &amp;lt; 1 || x &amp;gt; 4 || A[i][j] != A[y][x]) break;
                cnt++;
                y += dy[d], x += dx[d];
            }
            if (cnt &amp;gt; 2) return ret = A[i][j];
        }
    }
    return ret = 0;
}

void dfs(int now, int turn)
{
    if (vis[now]) return;
    vis[now] = 1;
    int A[5][5] = {0, };
    for (int i=1;i&amp;lt;=4;i++) for (int j=1;j&amp;lt;=4;j++){
        int t = to_num(i, j);
        A[i][j] = now / TP[t] % 3;
    }
    for (int j=1;j&amp;lt;=4;j++){
        for (int i=1;i&amp;lt;=4;i++) if (!A[i][j]){
            int t = to_num(i, j);
            int nxt = now + TP[t] * turn;
            int w = check(nxt);
            if (w){
                if (w == 2 &amp;amp;&amp;amp; i == Y &amp;amp;&amp;amp; j == X) ans++;
                break;
            }
            dfs(nxt, 3-turn);
            break;
        }
    }
}

int main()
{
    for (int i=1;i&amp;lt;16;i++) TP[i] = TP[i-1]*3;
    scanf(&quot;%d%d%d&quot;, &amp;amp;S, &amp;amp;Y, &amp;amp;X);
    dfs(TP[to_num(1, S)], 2);
    printf(&quot;%d\n&quot;, ans);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3&gt;G. Rectilinear Regions&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;오른쪽으로 내려가거나, 오른쪽으로 올라가는 '계단' 모양의 선 L과 U가 주어진다. 두 선에 의해 생기는 닫힌 직사각형 영역 중 선 L의 부분이 밑에 있고, 선 U의 부분이 위에 있는 직사각형 영역의 갯수와 면적 합을 구하는 문제다. 주어지는 꼭지점들의 X좌표는 서로 다르고, Y좌표 또한 서로 다르다.&lt;/p&gt;&lt;p&gt;각 선의 꼭지점 부분이 X좌표 순서대로 주어진다. 이를 이용해 plane sweeping을 진행하면 어렵지 않게 해결할 수 있다. 코드의 모양은 Merge Sort의 merge 과정과 유사하다. 시간복잡도는 $O(N)$이다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more121_6&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '121_6','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content121_6&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 25003
typedef long long lld;

int N, M;
int X1[MAXN], Y1[MAXN], X2[MAXN], Y2[MAXN];
int C; lld A;

int main()
{
    scanf(&quot;%d%d&quot;, &amp;amp;N, &amp;amp;M);
    scanf(&quot;%d&quot;, Y1); for (int i=1;i&amp;lt;=N;i++) scanf(&quot;%d%d&quot;, X1+i, Y1+i);
    scanf(&quot;%d&quot;, Y2); for (int i=1;i&amp;lt;=M;i++) scanf(&quot;%d%d&quot;, X2+i, Y2+i);
    lld tmp = 0; bool has_closed = Y1[0] &amp;gt; Y2[0];
    for (int i=1,j=1,prv=-1;i&amp;lt;=N||j&amp;lt;=M;){
        if (j &amp;gt; M || i &amp;lt;= N &amp;amp;&amp;amp; X1[i] &amp;lt; X2[j]){
            if (prv &amp;gt;= 0 &amp;amp;&amp;amp; Y1[i-1] &amp;lt; Y2[j-1]) tmp += (lld)(Y2[j-1]-Y1[i-1])*(X1[i]-prv);
            if (Y1[i] &amp;gt; Y2[j-1]){
                if (has_closed &amp;amp;&amp;amp; tmp) A += tmp, C++;
                tmp = 0; has_closed = 1;
            }
            prv = X1[i++];
        }else{
            if (prv &amp;gt;= 0 &amp;amp;&amp;amp; Y1[i-1] &amp;lt; Y2[j-1]) tmp += (lld)(Y2[j-1]-Y1[i-1])*(X2[j]-prv);
            if (Y1[i-1] &amp;gt; Y2[j]){
                if (has_closed &amp;amp;&amp;amp; tmp) A += tmp, C++;
                tmp = 0; has_closed = 1;
            }
            prv = X2[j++];
        }
    }
    printf(&quot;%d %lld\n&quot;, C, A);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3&gt;I.&amp;nbsp;Slot Machines&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;길이가 N인 수열이 주어진다. 이 수열의 왼쪽 $k$개의 원소를 제외하면 왼쪽에서부터 주기 $p$를 갖는다. 이 때, $k+p$가 최소가 되는 $k$, $p$를 구하는 문제다. 만약 $k+p$가 최소인 경우가 여러가지라면, $p$가 최소가 되는 경우를 찾으면 된다. 단, $p &amp;gt; 0$이다.&lt;/p&gt;&lt;p&gt;편의상 설명에서는 수열 대신 문자열을 사용하겠다. 수열의 수가 하나의 문자가 된 것일 뿐 달라지는 것은 전혀 없다.&lt;/p&gt;&lt;p&gt;우선, 입력으로 들어온 수열을 좌우반전시키고 &lt;a href=&quot;http://blog.myungwoo.kr/101#kmp-algorithm&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;KMP 알고리즘&lt;/a&gt;을 이용해서 실패함수 $f$의 값을 구하자.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:543px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9939D9335A0C2D1425&quot; filemime=&quot;image/jpeg&quot; filename=&quot;그림1.png&quot; height=&quot;179&quot; width=&quot;543&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;입력으로 문자열 &quot;EDBACBACBA&quot;가 주어졌고, 이를 좌우반전시킨 문자열 &quot;ABCABCABDE&quot;가 있다고 하자. $8$번째 문자의 실패함수 $f(8)=5$라는 것은 4번째 문자와 1번째 문자가 같고, 5번째 문자와 2번째 문자가 같고, ..., 8번째 문자와 5번째 문자가 같다는 것을 의미한다. 이는 입력으로 들어온 문자열의 $k$, $p$ 값 후보로 $k=2$, $p=3$이 가능하다는 것이고, 또한 $k=2$일 때 가장 작은 $p$가 됨도 알 수 있다.&amp;nbsp;이 경우 $k+p = 10 - f(8) = 5$라는 것이고 문제에서 $k+p$ 값을 최소화하라고 하였으니, $N - f(i)$ 중 제일 작은 값을 찾으면 된다. 시간복잡도는 $O(N)$이다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more121_7&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '121_7','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content121_7&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 1000006

int N;
int A[MAXN], P[MAXN];

int main()
{
    scanf(&quot;%d&quot;, &amp;amp;N);
    for (int i=N;i;i--) scanf(&quot;%d&quot;, A+i);
    int ans = N, p = 1;
    for (int i=2,k=0;i&amp;lt;=N;i++){
        while (k &amp;amp;&amp;amp; A[k+1] != A[i]) k = P[k];
        if (A[k+1] == A[i]) k++;
        P[i] = k;
        if (ans &amp;gt; N-P[i])
            ans = N-P[i], p = i-P[i];
    }
    printf(&quot;%d %d\n&quot;, ans-p, p);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3&gt;L.&amp;nbsp;Vacation Plans&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;최대 3명의 사람이 서로 다른 방향성 그래프에 살고 있다. 각 사람은 첫 날 자신이 속한 연결그래프의 1번 도시에 살고 있다. 각 사람은 날이 지날 때마다, 자신이 있는 정점의 호텔에 머물 것인지, 아니면 인접한 다른 정점으로 이동할 것인지 정할 수 있다. 호텔에 머무는데 특정 비용이 들고, 간선을 통해 이동할 때 특정 비용이 있다. 각 그래프에는 한 개의 공항이 있는데 세 사람이 모두 같은날 공항에 도착하기 위한 비용합의 최소값을 구하는 문제다.&lt;/p&gt;&lt;p&gt;편의상 항상 3명의 사람이 있다고 하자. 만약 입력으로 들어온 사람의 수가 2명인 경우에는, 가상의 3번째 사람과 그래프를 만들어, 3번째 그래프의 정점 개수는 1개이며, 공항은 1번 정점에 있고, 1번 정점의 호텔 비용이 0이라고 생각하면 된다. 또한 호텔에 머무는 것을 self edge로 표현할 수 있다. 그러면 호텔에 머무는 선택지를 self edge를 통해 간선 이동을 하는 것으로 볼 수 있어서 좀 더 문제가 단순해진다.&lt;/p&gt;&lt;p&gt;사람들에게 번호를 0번부터 매기자. 그리고 $i$번 사람이 있는 그래프의 정점 개수를 $N_i$, 간선 개수를 $M_i$라고 하자.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;[Dijkstra 풀이]&lt;/b&gt;&lt;/p&gt;&lt;p&gt;사람들이 각 날 동시에 움직이는 것이 아니라, 0번 사람부터 2번 사람까지 차례대로 움직인다고 생각하자. 이제 아래와 같은 DP 배열을 생각해보자.&lt;/p&gt;&lt;p&gt;D[i][j][k][l] = 어떤 날, 0번 사람은 i번 정점에, 1번 사람은 j번 정점에, 2번 사람은 k번 정점에 있고, 이제 l번 사람이 이동할 차례일 때 여태까지 지불한 비용합의 최소값&lt;/p&gt;&lt;p&gt;DP 배열의 상태 개수 $V = N_0 \times N_1 \times N_2 \times 3$이다. 현재 상태에서 다음 상태로 이동 가능한 경우 방향성 간선으로 표시했을 때 간선의 수 $E = (N_0N_1N_2(M_0+M_1+M_2))$이다. 이제 DP 배열의 내용을 Dijkstra 알고리즘을 이용하여 계산하면 시간복잡도 $O((E+V) \lg V)$에 해결할 수 있다. 실행시간은 1초 시간제한에 약 0.8초 정도 나온다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more121_8&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '121_8','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content121_8&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define pb push_back
#define sz(v) ((int)(v).size())
typedef long long lld;

int P, N[3], T[3];
lld D[51][51][51][3];
vector &amp;lt;int&amp;gt; con[3][51], conv[3][51];

int main()
{
    scanf(&quot;%d&quot;, &amp;amp;P);
    for (int i=0;i&amp;lt;P;i++){
        int m; scanf(&quot;%d%d&quot;, N+i, &amp;amp;m);
        for (int j=1;j&amp;lt;=N[i];j++){
            int v; scanf(&quot;%d&quot;, &amp;amp;v);
            con[i][j].pb(j); conv[i][j].pb(v);
        }
        while (m--){
            int a, b, c;
            scanf(&quot;%d%d%d&quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);
            con[i][a].pb(b); conv[i][a].pb(c);
        }
        scanf(&quot;%d&quot;, T+i);
    }
    for (int i=P;i&amp;lt;3;i++){
        con[i][1].pb(1); conv[i][1].pb(0);
        N[i] = T[i] = 1;
    }
    for (int i=1;i&amp;lt;=N[0];i++) for (int j=1;j&amp;lt;=N[1];j++) for (int k=1;k&amp;lt;=N[2];k++) for (int l=0;l&amp;lt;3;l++) D[i][j][k][l] = 1e18;
    struct Z {
        int a, b, c, d; lld v;
        bool operator &amp;lt; (const Z &amp;amp;ot)const{ return v &amp;gt; ot.v; }
    };
    priority_queue &amp;lt;Z&amp;gt; que;
    D[1][1][1][0] = 0; que.push({1, 1, 1, 0, 0});
    while (!que.empty()){
        Z q = que.top(); que.pop();
        int t = q.d;
        vector &amp;lt;int&amp;gt; a = {q.a, q.b, q.c};
        for (int i=sz(con[t][a[t]]);i--;){
            auto b = a;
            b[t] = con[t][a[t]][i]; int v = conv[t][a[t]][i];
            lld &amp;amp;d = D[b[0]][b[1]][b[2]][(q.d+1)%3];
            if (d &amp;gt; q.v+v)
                d = q.v+v, que.push({b[0], b[1], b[2], (q.d+1)%3, q.v+v});
        }
    }
    printf(&quot;%lld\n&quot;, D[T[0]][T[1]][T[2]][0]);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;[Bellman Ford 풀이]&lt;/b&gt;&lt;/p&gt;&lt;p&gt;정답이되는 날까지 걸리는 최대 기간은 $X = N_0 \times N_1 \times N_2$보다 작다. 이를 이용하여, 아래와 같은 DP 배열을 생각해보자.&lt;/p&gt;&lt;p&gt;D[x][i][j] = x일째 i번 사람이 j번 정점에 있을 때 최소 비용&lt;/p&gt;&lt;p&gt;0이상 $X$미만인 모든 x에 대해 D[x][0][T[0]]+D[x][1][T[1]]+D[x][2][T[2]]의 최소값을 구하면 답이 된다. 이 때, T[i]는 i번 사람이 있는 그래프에서 공항의 위치다. 실제로 코딩할 때, 3차원 배열이 아닌 toggling 기법을 이용하여 2차원 배열로 구현할 수 있다. 시간복잡도는 $O(N_0N_1N_2(M_0+M_1+M_2))$이며, 실행시간은 1초 시간제한에 약 0.2초 정도 나온다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p id=&quot;more121_9&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '121_9','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content121_9&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define pb push_back
#define sz(v) ((int)(v).size())
typedef long long lld;

int P, N[3], T[3];
lld D[3][51];

struct EDGE {
    int a, b, c;
};
vector &amp;lt;EDGE&amp;gt; E[3];

int main()
{
    scanf(&quot;%d&quot;, &amp;amp;P);
    for (int i=0;i&amp;lt;P;i++){
        int m; scanf(&quot;%d%d&quot;, N+i, &amp;amp;m);
        for (int j=1;j&amp;lt;=N[i];j++){
            int v; scanf(&quot;%d&quot;, &amp;amp;v);
            E[i].pb({j, j, v});
        }
        while (m--){
            int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);
            E[i].pb({a, b, c});
        }
        scanf(&quot;%d&quot;, T+i);
    }
    for (int i=P;i&amp;lt;3;i++){
        E[i].pb({1, 1, 0});
        N[i] = T[i] = 1;
    }
    for (int i=0;i&amp;lt;3;i++) for (int j=2;j&amp;lt;=N[i];j++) D[i][j] = 1e18;
    const int MAX_MOVE = N[0] * N[1] * N[2];
    lld ans = 1e18;
    for (int i=0;i&amp;lt;MAX_MOVE;i++){
        lld sum = 0;
        for (int j=0;j&amp;lt;3;j++) sum += D[j][T[j]];
        if (ans &amp;gt; sum) ans = sum;
        for (int j=0;j&amp;lt;3;j++){
            vector &amp;lt;lld&amp;gt; t(N[j]+1, 1e18);
            for (const auto &amp;amp;e: E[j])
                t[e.b] = min(t[e.b], D[j][e.a]+e.c);
            for (int k=1;k&amp;lt;=N[j];k++) D[j][k] = t[k];
        }
    }
    printf(&quot;%lld\n&quot;, ans);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3&gt;E.&amp;nbsp;How Many to Be Happy&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;N개의 정점과 M개의 간선으로 이루어진 그래프가 주어진다. 각 간선에 대해 자신을 포함한 MST가 존재하기 위해 제거해야되는 간선의 최소 개수의 합을 구하는 문제다.&lt;/p&gt;&lt;p&gt;a번 정점과 b번 정점을 연결하는 가중치 c인 간선이 있다고 하자. 이 간선을 포함한 MST가 존재하기 위한 필요충분조건은 a번 정점과 b번 정점을 연결하는 경로 중 가중치가 c보다 작은 간선으로만 이루어진 경로가 없는 것이다. 이 때, 제거해야하는 간선의 최소 개수는 가중치가 c보다 작은 간선들만 있는 새로운 그래프를 만들고, 그 그래프에서 a번 정점과 b번 정점 사이의 minimum cut이 된다.&lt;/p&gt;&lt;p&gt;Minimum cut은 maximum flow로 구할 수 있으며, maximum flow를 구하는 여러 알고리즘이 존재한다. 대부분의 maximum flow 알고리즘은 시간복잡도 상으로는 시간초과가 나올 것 같아보이지만, 이 문제에서는 간단한 Ford-Fulkerson 방법으로도 빠른 시간안에 통과한다. 첨부한 코드는 내가 알고 있는 실험적으로 제일 빠른 maximum flow 코드다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more121_10&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '121_10','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content121_10&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 109
#define MAXM 509
#define MAXE 1004
#define pb push_back

int N, M;

struct EDGE {
    int a, b, c;
} edge[MAXM];

int E;
int to[MAXE], flow[MAXE];
vector &amp;lt;int&amp;gt; cone[MAXN];
int dist[MAXN], cnt[MAXN];

void add_edge(int a, int b)
{
    cone[a].pb(E); to[E] = b; flow[E++] = 1;
    cone[b].pb(E); to[E] = a; flow[E++] = 1;
}

void bfs(int b)
{
    for (int i=1;i&amp;lt;=N;i++) dist[i] = N;
    queue &amp;lt;int&amp;gt; que;
    dist[b] = 0; que.push(b);
    while (!que.empty()){
        int q = que.front(); que.pop();
        for (int e: cone[q]){
            int t = to[e], f = flow[e^1];
            if (f &amp;amp;&amp;amp; dist[t] &amp;gt; dist[q]+1)
                dist[t] = dist[q]+1, que.push(t);
        }
    }
    for (int i=0;i&amp;lt;=N;i++) cnt[i] = 0;
    for (int i=1;i&amp;lt;=N;i++) cnt[dist[i]]++;
}

vector &amp;lt;int&amp;gt; pathe;
int dfs(int n, int dest)
{
    if (n == dest) return 1;
    for (int e: cone[n]){
        int t = to[e], f = flow[e];
        if (!f || dist[t]+1 != dist[n]) continue;
        pathe.pb(e);
        int k = dfs(t, dest);
        if (k) return k;
        pathe.pop_back();
    }
    int tmp = dist[n]; dist[n] = N;
    for (int e: cone[n]){
        int t = to[e], f = flow[e];
        if (f &amp;amp;&amp;amp; dist[n] &amp;gt; dist[t]+1) dist[n] = dist[t]+1;
    }
    cnt[dist[n]]++;
    if (!--cnt[tmp]) return -1;
    return 0;
}

int mincut(int a, int b, int c)
{
    int ret = 0;
    E = 0;
    for (int i=1;i&amp;lt;=N;i++) cone[i].clear();
    for (int i=1;edge[i].c&amp;lt;c;i++) add_edge(edge[i].a, edge[i].b);
    bfs(b);
    while (dist[a] &amp;lt; N){
        pathe.clear();
        int k = dfs(a, b);
        if (k &amp;lt; 0) break;
        if (!k) continue;
        for (int e: pathe) flow[e]--, flow[e^1]++;
        ret++;
    }
    return ret;
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;amp;N, &amp;amp;M);
    for (int i=1;i&amp;lt;=M;i++){
        int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);
        edge[i] = {a, b, c};
    }
    sort(edge+1, edge+M+1, [](const EDGE &amp;amp;a, const EDGE &amp;amp;b){
        return a.c &amp;lt; b.c;
    });
    int ans = 0;
    for (int i=1;i&amp;lt;=M;i++)
        ans += mincut(edge[i].a, edge[i].b, edge[i].c);
    printf(&quot;%d\n&quot;, ans);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h3&gt;A.&amp;nbsp;Broadcast Stations&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;N개의 정점으로 이루어진 트리가 주어진다. 정점에는 기지국을 놓을 수 있는데, 세기가 s인 기지국을 놓게 되면 자기 자신을 포함하여 거리 s이내의 정점에 신호가 간다. 적당히 기지국을 배치하여, 모든 정점이 신호를 수신하면서 세기 s의 합이 최소가 되도록 하는 문제다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;[제곱시간 풀이]&lt;/b&gt;&lt;/p&gt;&lt;p&gt;우선 트리를 1번 정점이 루트인 루트가 있는 트리로 만들자. 그리고 다음과 같은 두 개의 DP 배열을 생각하자.&lt;/p&gt;&lt;p&gt;D[i][j] = i가 루트인 서브트리에서 i번 정점에서 남는 신호 세기가 j인 경우 세기 합의 최소값&lt;/p&gt;&lt;p&gt;E[i][j] = i가 루트인 서브트리에서 i번 정점에서부터 j 단계 동안 신호를 수신하지 못한 정점이 있는 경우 세기 합의 최소값&lt;/p&gt;&lt;p&gt;이 때 DP 값을 계산하는 것은 비교적 어렵지 않게 가능하다. 이 문제에서 허들인 것은 언뜻보면 시간복잡도가 $O(N^3)$이 되어서 시간초과가 날 것 같다는 부분이다. 시간복잡도를 정확히 계산해보면, 각 정점 i에 대해 필요한 시간복잡도는 $O(\deg(i) \times N)$이 되고, 모든 i에 대해 이를 더하면 총 시간복잡도는 $O(N^2)$이 된다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more121_11&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '121_11','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content121_11&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 5003
#define pb push_back

int N;
int D[MAXN][MAXN], E[MAXN][MAXN];
vector &amp;lt;int&amp;gt; con[MAXN];

void dfs(int n, int from)
{
    vector &amp;lt;int&amp;gt; sum(N+1, 0);
    // Pre-compute
    for (int t: con[n]) if (t != from){
        dfs(t, n);
        for (int i=0;i&amp;lt;=N;i++) sum[i] += E[t][i];
    }

    // Initialize
    for (int i=0;i&amp;lt;=N;i++) D[n][i] = E[n][i] = N;

    // Calculation
    for (int t: con[n]) if (t != from){
        for (int i=1;i&amp;lt;=N;i++) D[n][i-1] = min(D[n][i-1], D[t][i]+(sum[i-1]-E[t][i-1]));
    }
    for (int i=1;i&amp;lt;=N;i++) E[n][i] = min(E[n][i], sum[i-1]);
    for (int i=1;i&amp;lt;=N;i++) D[n][i] = min(D[n][i], sum[i]+i);

    // Monotonize
    for (int i=N;i--;) D[n][i] = min(D[n][i], D[n][i+1]);
    E[n][0] = D[n][0];
    for (int i=1;i&amp;lt;=N;i++) E[n][i] = min(E[n][i], E[n][i-1]);
}

int main()
{
    scanf(&quot;%d&quot;, &amp;amp;N);
    for (int i=1;i&amp;lt;N;i++){
        int a, b; scanf(&quot;%d%d&quot;, &amp;amp;a, &amp;amp;b);
        con[a].pb(b); con[b].pb(a);
    }
    dfs(1, 0);
    printf(&quot;%d\n&quot;, D[1][0]);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;[선형시간 풀이]&lt;/b&gt;&lt;/p&gt;&lt;p&gt;선형시간 풀이에 접근하기 위해서는 다음과 같은 lemma가 필요하다.&lt;/p&gt;&lt;p&gt;&lt;b&gt;lemma)&lt;/b&gt; 트리에서 임의의 지름을 구하고, 그 지름 위에 있는 정점들에만 기지국을 놓아도 최적해를 구할 수 있다.&lt;/p&gt;&lt;p&gt;풀이 준비 중.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more121_12&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '121_12','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content121_12&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;&lt;/textarea&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;h3&gt;J.&amp;nbsp;Strongly Matchable&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;풀이 준비 중.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more121_13&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '121_13','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content121_13&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>2015 이후 한국대회</category>
<author>전명우</author>
<guid>https://blog.myungwoo.kr/121</guid>
<comments>https://blog.myungwoo.kr/121#entry121comment</comments>
<pubDate>Thu, 16 Nov 2017 00:22:35 +0900</pubDate>
</item>
<item>
<title>IOI 2017 결과 및 총평</title>
<link>https://blog.myungwoo.kr/119</link>
<description>&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:713px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/999D9733598D4D3833&quot; filemime=&quot;image/jpeg&quot; filename=&quot;캡처.PNG&quot; height=&quot;239&quot; width=&quot;713&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;전체 결과: &lt;a href=&quot;http://stats.ioinformatics.org/results/2017&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;IOI Statistics&lt;/a&gt;, &lt;a href=&quot;http://scoreboard.ioi2017.org/Ranking.html&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;IOI 2017 o&lt;/a&gt;&lt;a href=&quot;http://scoreboard.ioi2017.org/Ranking.html&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;fficial scoreboard&lt;/a&gt;&lt;/p&gt;&lt;p&gt;대한민국 결과: &lt;a href=&quot;http://stats.ioinformatics.org/results/KOR/2017&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;IOI Statistics&lt;/a&gt;&lt;/p&gt;&lt;p&gt;역대 대한민국 결과: &lt;a href=&quot;http://stats.ioinformatics.org/results/KOR&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;IOI Statistics&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;2017년 국제정보올림피아드에서 우리나라는 금1, 은2라는 성적을 거둬 종합 10위에 그쳤다. 2017년도 문제들은 예년이 비해 좀 어렵게 느껴진다. 그리고 한 동안 안나왔던 Output Only 문제가 Day 1에 출제되었다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Nowruz 문제는 2차원 격자판의 빈 칸에 적절히 장애물을 설치해서 빈 칸들이 서로 트리를 이루게했을 때, 리프 정점의 개수를 많게하면 점수를 더 받는 문제다. 김동현 군을 제외한 우리나라 대표학생들은 Output Only 문제에서 상당히 적은 점수를 받았다. 불행인지 다행인지 nowruz에서 조금 더 높은 점수를 받았더라하더라도 메달에 영향을 받는 학생은 없다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Wiring 문제는&amp;nbsp;개인적으로&amp;nbsp;푼 사람 수에 비해 많이 어려운 문제라고 생각한다. 최적해가 $O(N+M)$이지만 $N, M \leq 100,000$ 정도의 제한을 가지고 있어서, 적절한 $O(NM)$ 커팅이나 sqrt decomposition 같은 방법으로 만점을 받은 학생도 여럿 있다고 생각한다. Scientific Committee에서 의도한 풀이를 모르겠다. 확실한 것은 N제한이 최대 100만인데, $O(N \lg N)$ 풀이를 200ms 대에 통과시키면서 시간제한이 2초인 books&amp;nbsp;문제가 있는데 wiring 문제의&amp;nbsp;N, M 제한이 &lt;b&gt;최대 10만&lt;/b&gt;이라는 것은 의도한 다른 쉬운 풀이가 존재한다는 말이다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Train 문제는 대회에서 만점을 받은 학생이 4명밖에 안되지만, 어렵지 않은 문제라고 생각한다. 부분문제가 나뉘어져있는 꼴은 만점 풀이 접근과 상관 없어 보이고, 부분문제 각각이 독립적인 모양을 띄어 부분점수를 올리기 위해서는 nowruz 문제처럼 시간을 꽤나 투자해야할 것 같다. 문제를 알맞게 변형하면 꽤나 쉽게 풀이를 생각할 수 있는데, 만점자 수가 적어서 의아한 감이 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Prize 문제는 90점 이상을 받기는 굉장히 쉬운 문제라고 본다. 하지만 100점을 받기 위해서는 sqrt decomposition이라는 아이디어와 짜잘한 최적화가 필요하므로 어느정도 시간 투자를 필요로하는 문제다. 적당히 95점 정도의 점수를 받으면 우선 넘어가도 괜찮을 것 같아보인다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Simugrh 문제는 굉장히 어렵다... 51점을 받기 위해서는 문제에 대해 꽤나 깊게 분석해야하는데, 내가 모르는 다른 간단한 풀이가 있는 것인지 51점 이상 받은 학생들이 굉장히 많아서 놀랐다. 51점 풀이를 어떻게 생각했느냐에 따라 100점 풀이 접근 여부가 갈라져서 만점자가 적은 것 같다. 나는 51점 풀이에 대한 방향을 잘 잡았는지, 100점으로 발전시키는 것은 어렵지 않았다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;Books&amp;nbsp;문제는 많이 알려진 &quot;물건들고 정렬하기&quot; 문제다. 이 때, 종종 이용했던 아이디어로 50점을 받는 것은 매우 쉽게 느껴진다. 50점 풀이를 떠올린 후 100점 풀이가 멀지 않게 느껴져서 도전 욕구를 불러일으키는 문제다. 하지만 50점 풀이에서 100점 풀이로 가는 과정에서 생각 정리가 완벽하지 않으면 꽤나 심하게 말릴 수 있는 문제이기도 하다. 풀이의 정확성을 위해 생각해야하는 경우가 많고, 한 두&amp;nbsp;가지의&amp;nbsp;예외처리 등이 포함되어 있어 완벽한 생각 정리가 필요하다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;우리나라 대표학생들의 성적을 들여다보면 Day 2 성적이 굉장히 좋다. Day 1 때 Output Only 문제와 기대보다&amp;nbsp;높은 난이도의 문제들에 놀라 당황해서 좋은 성적은 아니지만,&amp;nbsp;Day 2에서는 잘 회복한 모습을 보여줘서 다행이다. Day 2 성적은 김현수 군을 제외한 세 학생의 성적에 크게 흠 잡을 곳이 없다. (서규호 군의 books 12점은 아쉽지만...)&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;끝으로, 전년도 대회에서는 좋은 모습을 보여줬지만 이번 대회에서 멘탈이 가루가 된 모습을 보여준&amp;nbsp;&lt;strike&gt;14년 만의 목메달 &lt;/strike&gt;김현수 군에게 이 자리를 빌어 심심찮은 위로의 말을 전한다.&lt;/p&gt;</description>
<category>IOI2017</category>
<author>전명우</author>
<guid>https://blog.myungwoo.kr/119</guid>
<comments>https://blog.myungwoo.kr/119#entry119comment</comments>
<pubDate>Fri, 11 Aug 2017 15:59:46 +0900</pubDate>
</item>
<item>
<title>IOI 2017 Day 2 문제 및 해법</title>
<link>https://blog.myungwoo.kr/118</link>
<description>&lt;p&gt;문제: &lt;a href=&quot;http://ioi2017.org/contest/tasks/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;공식 홈페이지&lt;/a&gt;&lt;/p&gt;&lt;p&gt;채점: &lt;a href=&quot;https://contest.yandex.com/ioi/contest/4772/enter/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Yandex&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;1. prize&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;1부터 v까지의 수가 적힌 크기가 N인 배열이 있다. 수 1의 갯수는 항상 1개고, 1보다 큰 t에 대해 수 t의 갯수는 수 t-1의 갯수의 제곱보다 많다. ask(i)를 호출하면, i보다 왼쪽에 있으면서 작은 수, i보다 오른쪽에 있으면서 큰 수를 알려준다. 이 때, 적은 횟수로 ask(i)를 호출하여 하나 뿐인 수 1의 위치를 찾는 문제다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;우선 배열에서 가장 많이 등장하는 수, 즉, 가장 큰 수는 등장 빈도가 과반이다. 가장 큰 수가 아닌 수의 최대 갯수는 조건에 따라 472개(1개, 4개, 21개, 446개, ...)다. 첫 번째로 가장 큰 수의 개수를 구하기 위해 최대 473번의 질문을 하여, 가장 큰 수의 위치 중 하나를 찾을 수 있다. 이후 풀이는 가장 큰 수가 아닌 수들의 위치를 모두 구한 뒤, ask(i)의 결과가 (0, 0)이 되는 위치를 구하는 식으로 진행된다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;가장 큰 수가 아닌 위치들은 배열을 크기가 최대 472인 그룹들로 분할하여 적은 질문 횟수로 구할 수 있다. 왼쪽에 있는 그룹부터 차례대로 그룹에 존재하는 가장 큰 수가 아닌 수들의 위치를 구해나가는데, 그룹마다 가장 큰 수가 아닌 수가 존재하는지 질문 한 번으로 확인을 할 수 있다. 만약 존재하지 않는다면, 해당 그룹에 대해서는 생략할 수 있고, 만약 존재한다면 그 그룹에서 이분탐색을 통해 최대 9번의 질문으로 특정 구간에서 가장 왼쪽에 있는 가장 큰 수가 아닌 수의 위치를 찾을 수 있다. 이를 반복하여, 모든 가장 큰 수가 아닌 수들을 찾을 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;100점을 받기 위해서는 총 5,000번 이내로 질문을 해야하는데, 여태까지를 비교적 naive하게 구현 할 경우 약 99점을 받게 된다. 100점을 받기 위해서는 처음에 가장 큰 수를 찾기 위해하는 473번의 질문을 그룹의 오른쪽 끝 점에 대해 질문을 해서 이후 질문을 미리하는 느낌으로 효율을 올리면 된다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more118_0&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '118_0','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content118_0&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &quot;prize.h&quot;

#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 200005
#define pb push_back

int N, M, K=472, G;
int S[450], E[450];

vector &amp;lt;int&amp;gt; cache[MAXN];
bool vis[MAXN];
vector&amp;lt;int&amp;gt; my_ask(int p)
{
	auto &amp;amp;ret = cache[p];
	if (vis[p]) return ret;
	vis[p] = 1;
	return ret = ask(p-1);
}

bool is_popular(int p)
{
	auto res = my_ask(p);
	return res[0]+res[1] == M;
}

int find_leftmost(int s, int e, int p)
{
	int ret = 0;
	while (s &amp;lt;= e){
		int m = (s+e)&amp;gt;&amp;gt;1;
		if (!is_popular(m)){
			ret = m; e = m-1;
		}else{
			if (my_ask(m)[0] != p) e = m-1;
			else s = m+1;
		}
	}
	return ret;
}

int find_best(int n)
{
	::N = n;
	S[++G] = 1; E[G] = 1;
	for (int i=2;i&amp;lt;=N;i++){
		if (E[G]-S[G]+1 == K) S[++G] = i;
		E[G] = i;
	}

	set &amp;lt;int&amp;gt; to_ask;
	for (int i=1;i&amp;lt;=G;i++) to_ask.insert(E[i]);
	for (int i=1;i&amp;lt;=N;i++){
		if (to_ask.size() &amp;gt; K) break;
		to_ask.insert(i);
	}
	for (int t: to_ask)
		M = max(M, my_ask(t)[0]+my_ask(t)[1]);

	vector &amp;lt;int&amp;gt; non_popular;
	for (int last=0,prefix=0,g=1;g&amp;lt;=G;){
		if (last == E[g] ||
			is_popular(E[g]) &amp;amp;&amp;amp; my_ask(E[g])[0] == prefix){ g++; continue; }
		int p = find_leftmost(max(last+1, S[g]), E[g], prefix);
		non_popular.pb(p);
		prefix++; last = p;
	}

	for (int t: non_popular)
		if (!my_ask(t)[0] &amp;amp;&amp;amp; !my_ask(t)[1]) return t-1;

	return 0;
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3&gt;2. simurgh&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;$N$개의 정점과 $M$개의 간선으로 이루어진 연결그래프가 주어진다. 이 연결그래프의 (우리가 알 수 없는) 어떤 스패닝 트리를 royal 스패닝 트리라고 하고, royal 스패닝 트리를 이루는 간선들을 royal 간선이라고 한다. 우리는 임의의 스패닝 트리에 대해 해당 스패닝 트리에 몇 개의 royal 간선이 있는지 물어볼 수 있다. 이를 통해 모든 royal 간선들을 찾는 문제다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;우선, 그래프에서 임의의 DFS 트리 $T$를 만들고, 모든 트리 간선에 대해 royal 여부를 판단하려고 한다. 이는 총 $2N$번의 질문을 통해 구할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;처음에 $T$에 대해서 질문을 해서 $T$ 안에 있는 royal 간선의 개수를 파악해둔다. 절선이 아니면서 정점 $u$와 정점 $v$를 연결하는 트리 간선 $e$에 대해서 (정점 $u$가 정점 $v$의 부모 정점이다) $low[v]$를 만드는 back 간선 $f$를 찾자. 즉, 간선 $f$는 정점 $v$에서 back 간선 하나만 통해 이동할 때, 최대한 위로 올라갈 수 있게 해주는 back 간선을 의미한다. $T$에서 간선 $e$를 빼고, 간선 $f$를 추가한 새로운 트리에 대해 질문한다. 이를 통해 $R[e]-R[f]$의 값을 알 수 있다. (여기서, $R[e]$는 간선 $e$가 royal 간선이면 1, 아니면 0을 의미하는 배열이다.) 그리고 간선 $f$에 대해서는 트리 $T$에 간선 $f$를 추가했을 때, 생기는 싸이클에 포함된 트리 간선 중 가장 위에 있는 간선 $d$를 찾아, 트리 $T$에서 간선 $d$를 지우고 간선 $f$를 추가해 $R[f]-R[d]$ 값을 알아낸다. 등장하는 모든 간선 $f$를 포함한 집합을 $F$라고 하자.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;구한 차이 값들을 종합하여, 트리 간선과&amp;nbsp;$F$에 포함된 back 간선 중 같은 biconnected component에 속한 간선끼리는 서로&amp;nbsp;$R$ 값의 차이를 알고 있다. 만약 $R$ 값이 모두 같은 것이 아니라면, 해당 간선들에 대해 $R$ 값이 0인지, 1인지 구분이 바로 가능하다. 만약 $R$ 값이 모두 같다면, 해당 간선들의 $R$ 값이 0이다. 왜냐하면, 해당 간선들이 모두 royal 간선이라면 싸이클이 생기기 때문이다. 이를 통해 모든 트리 간선과 $F$에 속한 간선들의 royal 여부를 계산할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;하나의 트리 간선에 대해 최대 2번의 질문을 했기 때문에 질문한 총 횟수는 $2N$번 정도이며, 이를 통해 트리 간선 중 royal 간선인 것들을 찾아냈다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;남은 것은 $F$에 속하지 않은 back 간선들의 royal 여부를 판단하는 것 뿐이다. $F$에 속하지 않은 back 간선들을 '무관심' 간선이라고 말하자.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1) 51점 풀이&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;모든 무관심 간선 각각에 대해, 한 번의 질문을 통해 royal 여부를 판단할 수 있다. 무관심 간선 $e$에 대해, 트리 $T$에 $e$를 추가하고, 생기는 싸이클 내부의&amp;nbsp;임의의 트리 간선 $d$를 지워서 새로운 트리를 만들고 질문하면, $R[d]-R[e]$ 값을 알 수 있다. 이미 $R[d]$ 값을 알고 있으므로 바로 $R[e]$ 값을 알 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;절선을 제외한 모든 간선에 대해 정확히 한 번씩 질문을 했으므로, 질문 횟수는 최대 $M$번이 되며 51점을 받는다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more118_1&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '118_1','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content118_1&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &quot;simurgh.h&quot;

#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 501
#define MAXM 125000
#define pb push_back
#define sz(v) ((int)(v).size())

int N, M;
int to[MAXN][MAXN];

int par[MAXN], up_e[MAXN];
int down_e[MAXM], now_child[MAXN];
int disc[MAXN], low[MAXN], low_e[MAXN];
bool interested[MAXM];

bool R[MAXM];

void dfs(int n)
{
	static int code = 0;
	disc[n] = low[n] = ++code;
	for (int t=1;t&amp;lt;=N;t++) if (to[n][t]){
		int e = to[n][t];
		if (!disc[t]){
			par[t] = n; up_e[t] = e; now_child[n] = t;
			dfs(t);
			if (low[n] &amp;gt; low[t])
				low[n] = low[t], low_e[n] = low_e[t];
		}else if (t != par[n] &amp;amp;&amp;amp; disc[t] &amp;lt; disc[n]){
			down_e[e] = now_child[t];
			if (low[n] &amp;gt; disc[t])
				low[n] = disc[t], low_e[n] = e;
		}
	}
}

int base;

int ask(int d=0, int a=0)
{
	vector &amp;lt;int&amp;gt; arr;
	for (int i=2;i&amp;lt;=N;i++) if (up_e[i] != d) arr.pb(up_e[i]);
	if (a) arr.pb(a);
	for (int i=0;i&amp;lt;N-1;i++) arr[i]--;
	return count_common_roads(arr);
}

int _par[MAXM], in[MAXM];
int find(int n){ return _par[n] == n ? n : (_par[n] = find(_par[n])); }

void add_relation(int a, int b, int diff)
{
	if (diff &amp;lt; 0) swap(a, b), diff *= -1;
	// diff = R[b] - R[a];

	if (!diff){
		a = find(a); b = find(b);
		if (a == b) return;
		_par[b] = a; in[a] += in[b]; 
	}
	else in[find(b)]++;
}

vector &amp;lt;int&amp;gt; find_roads(int n, vector&amp;lt;int&amp;gt; u, vector&amp;lt;int&amp;gt; v)
{
	::N = n; M = sz(u);
	for (int i=0;i&amp;lt;M;i++){
		int a = u[i]+1, b = v[i]+1;
		to[a][b] = to[b][a] = i+1;
	}
	dfs(1);
	for (int i=2;i&amp;lt;=N;i++)
		interested[up_e[i]] = interested[low_e[i]] = 1;

	base = ask();
	for (int i=1;i&amp;lt;=M;i++) _par[i] = i;
	for (int i=2;i&amp;lt;=N;i++) if (low_e[i]){
		int e = low_e[i], v = ask(up_e[i], e);
		add_relation(up_e[i], e, v-base);

		v = ask(up_e[down_e[e]], e);
		add_relation(up_e[down_e[e]], e, v-base);
	}
	for (int i=1;i&amp;lt;=M;i++) if (find(i) == i) R[i] = in[i];
	for (int i=1;i&amp;lt;=M;i++) R[i] = R[find(i)];

	for (int i=2;i&amp;lt;=N;i++) if (!low_e[i]) R[up_e[i]] = 1;

	for (int i=1;i&amp;lt;=M;i++) if (!interested[i]){
		int op = up_e[down_e[i]];
		int diff = ask(op, i) - base;
		if (diff &amp;gt; 0 || !diff &amp;amp;&amp;amp; R[op]) R[i] = 1;
	}

	vector &amp;lt;int&amp;gt; ret;
	for (int i=1;i&amp;lt;=M;i++) if (R[i]) ret.pb(i-1);
	return ret;
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2) 100점 풀이&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;트리 $T$의 각 간선에 대해 royal 여부를 알고 있다. 이를 이용하여 자기들끼리 싸이클을 이루지 않는 여러 개의 무관심 간선들이 있을 때, 이들 중 royal 간선의 개수를 세어주는 작업을 할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;어떤 정점 $v$에 대해 $v$에 인접한 무관심 간선들을 모으고, 이들 중 royal 간선을 찾는 상황을 생각해보자. $v$에 인접한 무관심 간선의 개수가 $c$개이고, 실제로 이들 중 royal 간선이 $k$개 있다라고 했을 때, 위에서 언급한 작업과 무관심 간선 집합을 반으로 줄여가는 행위를 이분탐색 비슷하게 반복하면, 약 $k \lg c$번의 질문을 통해 $k$개의 royal 간선을 모두 찾을 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;이를 모든 정점에 대해 해주면 추가 질문 횟수는 최대 $N \lfloor \lg N \rfloor + N$가 된다. 따라서 총 질문 횟수는 최대 $N \lfloor \lg N \rfloor + 3N$으로, 5,500번의 질문안에 모든 royal 간선을 찾을 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more118_2&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '118_2','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content118_2&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &quot;simurgh.h&quot;

#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 501
#define MAXM 125000
#define pb push_back
#define sz(v) ((int)(v).size())

int N, M;
int U[MAXM], V[MAXM];
int to[MAXN][MAXN];

int par[MAXN], up_e[MAXN];
int down_e[MAXM], now_child[MAXN];
int disc[MAXN], low[MAXN], low_e[MAXN];
bool interested[MAXM];

bool R[MAXM];

void dfs(int n)
{
	static int code = 0;
	disc[n] = low[n] = ++code;
	for (int t=1;t&amp;lt;=N;t++) if (to[n][t]){
		int e = to[n][t];
		if (!disc[t]){
			par[t] = n; up_e[t] = e; now_child[n] = t;
			dfs(t);
			if (low[n] &amp;gt; low[t])
				low[n] = low[t], low_e[n] = low_e[t];
		}else if (t != par[n] &amp;amp;&amp;amp; disc[t] &amp;lt; disc[n]){
			down_e[e] = now_child[t];
			if (low[n] &amp;gt; disc[t])
				low[n] = disc[t], low_e[n] = e;
		}
	}
}

int base;

int ask(int d=0, int a=0)
{
	vector &amp;lt;int&amp;gt; arr;
	for (int i=2;i&amp;lt;=N;i++) if (up_e[i] != d) arr.pb(up_e[i]);
	if (a) arr.pb(a);
	for (int i=0;i&amp;lt;N-1;i++) arr[i]--;
	return count_common_roads(arr);
}

int _par[MAXM], in[MAXM];
int find(int n){ return _par[n] == n ? n : (_par[n] = find(_par[n])); }

void add_relation(int a, int b, int diff)
{
	if (diff &amp;lt; 0) swap(a, b), diff *= -1;
	// diff = R[b] - R[a];

	if (!diff){
		a = find(a); b = find(b);
		if (a == b) return;
		_par[b] = a; in[a] += in[b]; 
	}
	else in[find(b)]++;
}

int K;
int A[MAXN];

int get_cnt(int s, int e)
{
	vector &amp;lt;int&amp;gt; earr, arr;
	for (int i=s;i&amp;lt;=e;i++) earr.pb(A[i]);
	for (int i=2;i&amp;lt;=N;i++) earr.pb(up_e[i]);

	for (int i=1;i&amp;lt;=N;i++) _par[i] = i;
	int base = 0;
	for (int e: earr){
		int a = find(U[e]), b = find(V[e]);
		if (a == b) continue;
		if (interested[e] &amp;amp;&amp;amp; R[e]) base++;
		arr.pb(e-1); _par[b] = a;
	}

	return count_common_roads(arr) - base;
}

void find_royal(int s, int e, int cnt)
{
	if (!cnt) return;
	if (s == e){ R[A[s]] = 1; return; }
	int m = s+e &amp;gt;&amp;gt; 1;
	int lc = get_cnt(s, m);
	find_royal(s, m, lc);
	find_royal(m+1, e, cnt-lc);
}

vector &amp;lt;int&amp;gt; find_roads(int n, vector&amp;lt;int&amp;gt; u, vector&amp;lt;int&amp;gt; v)
{
	::N = n; M = sz(u);
	for (int i=1;i&amp;lt;=M;i++){
		int a = u[i-1]+1, b = v[i-1]+1;
		to[a][b] = to[b][a] = i;
		U[i] = a, V[i] = b;
	}
	dfs(1);
	for (int i=2;i&amp;lt;=N;i++)
		interested[up_e[i]] = interested[low_e[i]] = 1;

	base = ask();
	for (int i=1;i&amp;lt;=M;i++) _par[i] = i;
	for (int i=2;i&amp;lt;=N;i++) if (low_e[i]){
		int e = low_e[i], v = ask(up_e[i], e);
		add_relation(up_e[i], e, v-base);

		v = ask(up_e[down_e[e]], e);
		add_relation(up_e[down_e[e]], e, v-base);
	}
	for (int i=1;i&amp;lt;=M;i++) if (find(i) == i) R[i] = in[i];
	for (int i=1;i&amp;lt;=M;i++) R[i] = R[find(i)];

	for (int i=2;i&amp;lt;=N;i++) if (!low_e[i]) R[up_e[i]] = 1;

	for (int i=1;i&amp;lt;N;i++){
		K = 0;
		for (int j=i+1;j&amp;lt;=N;j++) if (to[i][j]){
			int e = to[i][j];
			if (!interested[e]) A[++K] = e;
		}
		if (!K) continue;
		find_royal(1, K, get_cnt(1, K));
	}

	vector &amp;lt;int&amp;gt; ret;
	for (int i=1;i&amp;lt;=M;i++) if (R[i]) ret.pb(i-1);
	return ret;
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3&gt;3. books&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;0부터 N-1까지 총 N개의 수가 있는 순열이 주어진다. 사람이 시작 위치 S에서 이동하면서 순열을 정렬하려고 한다. 사람은 수를 최대 한 개만 들고 이동할 수 있고, 칸에 도착할 때마다 들고 있는 수와 칸에 놓여있는 수를 바꾸며 정렬한다. 이 때, 순열을 정렬하고 다시 시작점으로 돌아올 때 필요한 최소 이동 거리를 구하는 문제다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;우선, 순열을 정렬하기 위해서 |P[i] - i|의 합 만큼은 반드시 이동해야한다. 이외에 추가로 어쩔 수 없이 이동하는 것을 추가 이동이라고 하자. 이 문제에서는 꼭 필요한 이동 말고 추가 이동을 최소화하는 문제라고 볼 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;다음과 같은 순열을 정렬한다고 했을 때, 순열 정보를 토대로 여러 개의 싸이클이 나오는 것을 볼 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/996EEA33598AE0D01A&quot; filemime=&quot;image/jpeg&quot; filename=&quot;그림1.png&quot; height=&quot;194&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;서로 엉켜있는 싸이클들의 무리를 싸이클 덩어리라고 하자. 위 그림에서는 싸이클 덩어리가 총 3개 있다. 1번 싸이클 덩어리는 2번, 3번 싸이클 덩어리를 포함하고 있고, 자기 자신은 아무 싸이클 덩어리한테도 포함되어 있지 않다. 이러한 싸이클 덩어리를 루트 싸이클 덩어리라고 하자. 2번 싸이클 덩어리를 포함하는 가장 작은 싸이클 덩어리는 1번 싸이클 덩어리다. 이를 부모 싸이클 덩어리라고 부르자. 그러면 싸이클 덩어리 사이의 관계가 트리 혹은 forest 형태로 나타나게 된다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1) S = 0인 경우 풀이 (50점)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;S = 0인 경우, 시작점은 어떠한 싸이클 덩어리에도 포함되어 있지 않거나, 루트 싸이클 덩어리의 끝점이 된다. 이 경우는 문제를 해결하기가 쉽다. 왜냐하면 루트 싸이클 덩어리의 칸에서 사람이 정렬을 시작하는 경우 그 루트 싸이클 덩어리 영역 안에 포함되는 모든 싸이클들을 추가 이동 없이 필요한 만큼만 이동하면서 정렬할 수 있기 때문이다. 따라서 S = 0인 경우, 루트 싸이클 덩어리들 사이를 이동하는 추가 이동거리만 계산해주면 되므로 싸이클 덩어리를 자세히 구할 필요도 없이 루트 싸이클 덩어리들만 구하여 간단한 연산으로 추가 이동거리를 계산할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more118_3&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '118_3','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content118_3&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &quot;books.h&quot;

#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 1000006
#define sz(v) ((int)(v).size())
typedef long long lld;

int N, S, M;
int P[MAXN];
bool vis[MAXN];

struct Z{
	int s, e;
} A[MAXN];

lld minimum_walk(vector&amp;lt;int&amp;gt; p, int s)
{
	N = sz(p); S = ++s;
	for (int i=1;i&amp;lt;=N;i++) P[i] = p[i-1]+1;

	lld total = 0;
	for (int i=1;i&amp;lt;=N;i++) total += abs(i-P[i]);

	int last_s = 0, last_e = 0;
	for (int i=1;i&amp;lt;=N;i++) if (!vis[i] &amp;amp;&amp;amp; P[i] != i){
		int e = i;
		for (int t=i;!vis[t];t=P[t]){
			vis[t] = 1;
			e = max(e, t);
		}
		if (last_e &amp;amp;&amp;amp; last_e &amp;lt; i){
			A[++M] = {last_s, last_e};
			last_e = 0;
		}
		if (!last_e) last_s = i;
		last_e = max(last_e, e);
	}
	if (last_e) A[++M] = {last_s, last_e};

	if (S == 1){
		lld ret = total;
		A[0].e = 1;
		for (int i=1;i&amp;lt;=M;i++) ret += (A[i].s-A[i-1].e)*2;
		return ret;
	}
	return 0;
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2) 전체&amp;nbsp;풀이 (100점)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;우선, 위 그림처럼 싸이클 덩어리를 나누는 것은 union-find와 stack을 이용하여, $O(N \lg N)$ 시간에 해결할 수 있다. 그리고 S = 0인 경우 풀이에서 루트 싸이클 덩어리들 사이를 이동하는 추가 이동도 불가피하다는 것을 알 수 있다. 이 문제가 까다로운 이유는 시작점이 싸이클 덩어리 깊숙히 있는 경우, 루트 싸이클 덩어리까지 최단 거리로 이동해서 나오는 경우를 계산해주어야하기 때문이다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;그래서 싸이클 덩어리 마다 자신의 루트 싸이클 덩어리까지 가는 최단 추가 이동거리를 계산해야한다.&amp;nbsp;왼쪽에서 오른쪽으로 순회하는 것 한 번, 오른쪽에서 왼쪽으로 순회하는 것 한 번, 총 두 번의 선형 탐색을 통해 각 싸이클 덩어리마다 자신의 부모 싸이클 덩어리로 이동하는 최단거리가 나오게되고 이를 이용하여 루트 싸이클 덩어리까지 올라가는 최단거리를 구할 수 있다. 최단거리를 구하는 시간복잡도는 $O(N)$이다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;최단거리를 구하고나서는 시작점에서 i번 점까지 이동하고 i번 점에서 i번 점의 루트 싸이클 덩어리까지 올라가는 최단거리를 알고 있으므로 이를 이용하여 필요한 최소 추가 이동거리를 구할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;총 시간복잡도는 $O(N \lg N)$이지만 이는 union-find에 의한 $O(\lg N)$이므로 전체 실행시간은 매우 빠르게 나온다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more118_4&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '118_4','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content118_4&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &quot;books.h&quot;

#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 1000006
#define sz(v) ((int)(v).size())
typedef long long lld;

int N, S;
int P[MAXN];

int C;
int par[MAXN], num[MAXN];
int L[MAXN], R[MAXN], U[MAXN];
int DL[MAXN], DR[MAXN], D[MAXN];
int rec[MAXN];
int find(int n){ return par[n] == n ? n : (par[n] = find(par[n])); }

lld minimum_walk(vector&amp;lt;int&amp;gt; p, int s)
{
	N = sz(p); S = ++s;
	for (int i=1;i&amp;lt;=N;i++) P[i] = p[i-1]+1;

	lld ret = 0;
	for (int i=1;i&amp;lt;=N;i++) ret += abs(i-P[i]);
	if (!ret) return 0;

	for (int i=1;i&amp;lt;=N;i++) if (!num[i] &amp;amp;&amp;amp; P[i] != i){
		L[++C] = i;
		for (int t=i;!num[t];t=P[t]){
			num[t] = C;
			R[C] = max(R[C], t);
		}
	}
	for (int i=1;i&amp;lt;=C;i++) par[i] = i;

	stack &amp;lt;int&amp;gt; stk;
	for (int i=1;i&amp;lt;=N;i++) if (num[i]){
		if (L[num[i]] == i) stk.push(num[i]);
		else{
			int c = find(num[i]);
			while (L[stk.top()] &amp;gt; L[c]){
				int t = stk.top(); stk.pop();
				par[t] = c;
				R[c] = max(R[c], R[t]);
			}
			if (R[c] == i){
				stk.pop();
				if (!stk.empty()) U[c] = stk.top();
			}
		}
	}
	for (int i=1;i&amp;lt;=C;i++) U[i] = find(U[i]);

	int last = 0;
	for (int i=1;i&amp;lt;=C;i++) if (find(i) == i){
		if (last &amp;amp;&amp;amp; R[last] &amp;gt; R[i]) continue;
		if (last) ret += (L[i]-R[last])*2; 
		last = i;
	}

	bool in = 0; int l = N, r = 0;
	for (int i=1;i&amp;lt;=C;i++) if (find(i) == i){
		if (L[i] &amp;lt; S &amp;amp;&amp;amp; S &amp;lt; R[i]) in = 1;
		l = min(l, L[i]);
		r = max(r, R[i]);
	}
	if (!in &amp;amp;&amp;amp; l &amp;lt;= S &amp;amp;&amp;amp; S &amp;lt;= r) return ret;

	for (int i=1;i&amp;lt;=N;i++) if (num[i]){
		int c = find(num[i]);
		rec[c] = i;
		if (U[c] &amp;amp;&amp;amp; L[c] == i) DL[c] = i-rec[U[c]];
		if (R[c] == i) rec[U[c]] = max(rec[U[c]], i-DL[c]);
	}
	for (int i=N;i;i--) if (num[i]){
		int c = find(num[i]);
		rec[c] = i;
		if (U[c] &amp;amp;&amp;amp; R[c] == i) DR[c] = rec[U[c]]-i;
		if (L[c] == i) rec[U[c]] = min(rec[U[c]], i+DR[c]);
	}
	for (int i=1;i&amp;lt;=C;i++) D[i] = min(DL[i], DR[i]);
	for (int i=1;i&amp;lt;=C;i++) if (U[i]) D[i] += D[U[i]];

	int mn = N;
	for (int i=1;i&amp;lt;=N;i++) if (num[i]){
		int c = find(num[i]);
		mn = min(mn, D[c] + abs(S-i));
	}
	return ret + mn*2;
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>IOI2017</category>
<author>전명우</author>
<guid>https://blog.myungwoo.kr/118</guid>
<comments>https://blog.myungwoo.kr/118#entry118comment</comments>
<pubDate>Fri, 11 Aug 2017 14:53:42 +0900</pubDate>
</item>
<item>
<title>IOI 2017 Day 1 문제 및 해법</title>
<link>https://blog.myungwoo.kr/117</link>
<description>&lt;p&gt;문제: &lt;a href=&quot;http://ioi2017.org/contest/tasks/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;공식 홈페이지&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;채점: &lt;a href=&quot;https://contest.yandex.com/ioi/contest/4767/enter/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;Yandex&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;1. nowruz&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이 문제는 빈 칸과 장애물로 이루어진 직사각형 모양의 격자칸에서 빈 칸에 새로운 장애물을 적절히 넣어, 격자판의 빈 칸들을 트리 모양으로 만든다. 이 때, 만들어지는 트리에 포함된 리프 정점 수를 최대화하는 문제다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;IOI 2010 Maze 문제와 비슷한 감이 있는 문제다. 문제 세팅 자체도 2차원 격자판이라는 것도 비슷하지만, 최적해가 아니라 최적근접해를 구하는 output only 문제라는 사실이 비슷하다. 이런 류의 문제는 TopCoder Marathon Match 줄여서 MM에 주로 나오는 것으로 알고 있다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;예전에 maze 문제를 해결할 때, 공부에 도움이 됐던 &lt;a href=&quot;https://algospot.com/forum/read/1086/&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;일루님의 글&lt;/a&gt;을 소개하고, 이 문제에 맞는 자세한 풀이는 추후 시간이 나면 추가하겠다.&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;풀이 준비 중 입니다.&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more117_0&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '117_0','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content117_0&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3&gt;2. wiring&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;1차원 직선위에 빨간점 $N$개와 파란점 $M$개가 서로 다른 위치에 놓여있다. 이 때, 각 점은 하나 이상의 다른 색상의 점과 연결되어야하고, 연결할 때 필요한 전선 길이의 합을 최소화하는 문제다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;서로 다른 색의 두 점을 연결하는 것을 매칭이라고 하고, 매칭할 때 필요한 전선 길이를 매칭 비용이라고 하자. 각 점마다 적어도 한 개 이상의 매칭이&amp;nbsp;필요하므로 각 점마다 한 개씩 의무적으로 해주는 매칭이 있다. 점 $a$와 점 $b$를 연결하는 매칭이 있다라고 하면 이 매칭은 아래 세 가지 중 하나를 만족한다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;1) 매칭이 점 $a$ 입장에서만 의무적인 경우&lt;/p&gt;
&lt;p&gt;2) 매칭이 점 $b$ 입장에서만 의무적인 경우&lt;/p&gt;
&lt;p&gt;3) 매칭이 점 $a$와 점 $b$ 모두에게 의무적인 경우&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;처음에 입력으로 빨간점의 좌표와 파란점의 좌표가 각각 정렬되어 들어오는데, 이를 merge 하여 하나의 정렬된 배열로 만든다. 그리고 좌표 순서대로 번호를 매기고, 아래와 같은 DP를 생각하자.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;D[i] = 점 $i$까지 의무적인 매칭이 완료되었을 때, 필요한 최소 매칭 비용&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;점 $i$ 입장에서 의무적으로 한 개의&amp;nbsp;매칭을 해줘야하는데, 이는 두 가지 경우 중 하나가 된다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;1) 점 $i$ 입장에서 의무적인 매칭이 상대방에게는 의무가 아닌 경우&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;이 경우 점 $i$는&amp;nbsp;양 옆 주변으로 가장 가까운 다른 색의 점과 매칭해주면 된다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;2) 점 $i$&amp;nbsp;입장에서 의무적인 매칭이 상대방에게도 의무인 경우&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;이 경우 점 $i$는&amp;nbsp;왼쪽에 있는 점 $j$와 매칭이 된다고만 봐도 된다. 그리고 점 $j$와 점 $i$ 사이의&amp;nbsp;빨간점의 수와 파란점의 수가 같을 때만 고려해도 optimal 매칭을 구할 수 있다는 것도 알 수 있다. 마지막으로 앞의 조건을 만족하는 점 $j$가 여러 개일 때, 그 중 가장 오른쪽에 있는 점 $j$와 매칭하는 경우만 고려해도 모든 경우를 커버한다는 것도 알 수 있다. 따라서, 매칭되는 점 $j$는 존재하지 않거나 유일하다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;두 경우 각각에 대해 매칭 비용을 구하고 더 좋은 비용을 선택하면 D[i]를 구할 수 있다. 이러한 DP는 $O(N+M)$ 시간에 해결되며 최종적으로 답은 D[N+M]이 된다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;여담) 이 문제는 &lt;a href=&quot;https://www.acmicpc.net/problem/1659&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;ACM ICPC Seoul Regional 2007 J번 문제&lt;/a&gt;와 완전히 동일한 문제고, 이 문제에 대한 풀이를 cubelover가 블로그에 작성한 적이 있다. &lt;a href=&quot;http://cubelover.tistory.com/8&quot; target=&quot;_blank&quot; class=&quot;tx-link&quot;&gt;cubelover 블로그에 작성된 풀이&lt;/a&gt;는 내 풀이와 같은 풀이지만 조금 다른 단어로 자세히&amp;nbsp;설명되어 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more117_1&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '117_1','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content117_1&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &quot;wiring.h&quot;

#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

typedef long long lld;

#define MAXN 100005
#define sz(v) ((int)(v).size())

int N, M, K;
int A[MAXN], B[MAXN];
int near[MAXN*2], sp[MAXN*2]; lld S[MAXN*2]; int last[MAXN*4];
lld D[MAXN*2];

struct Z{
	int x; bool t;
} C[MAXN*2];

lld min_total_length(vector&amp;lt;int&amp;gt; r, vector&amp;lt;int&amp;gt; b) {
	N = sz(r); M = sz(b); K = N+M;
	for (int i=1;i&amp;lt;=N;i++) A[i] = r[i-1];
	for (int i=1;i&amp;lt;=M;i++) B[i] = b[i-1];
	
	/* Merge */
	for (int i=1,j=1,k=1;k&amp;lt;=K;k++){
		if (j &amp;gt; M || i &amp;lt;= N &amp;amp;&amp;amp; A[i] &amp;lt; B[j])
			C[k] = {A[i++], 0};
		else
			C[k] = {B[j++], 1};
	}

	/* Get nearest point */
	for (int i=1;i&amp;lt;=K;i++) near[i] = 2e9;
	{
		int rec[2] = {0,};
		for (int i=1;i&amp;lt;=K;i++){
			if (rec[!C[i].t]) near[i] = min(near[i], C[i].x-C[rec[!C[i].t]].x);
			rec[C[i].t] = i;
		}
	}
	{
		int rec[2] = {0,};
		for (int i=K;i&amp;gt;0;i--){
			if (rec[!C[i].t]) near[i] = min(near[i], C[rec[!C[i].t]].x-C[i].x);
			rec[C[i].t] = i;
		}
	}

	for (int i=1;i&amp;lt;=K;i++) sp[i] = -1;
	for (int i=0;i&amp;lt;=K+K;i++) last[i] = -1;
	last[K] = 0; int now = 0;
	for (int i=1;i&amp;lt;=K;i++){
		if (C[i].t) now++, S[i] = C[i].x;
		else now--, S[i] = -C[i].x;
		S[i] += S[i-1];
		if (last[now+K] &amp;gt;= 0)
			sp[i] = last[now+K];
		last[now+K] = i;
	}
	for (int i=1;i&amp;lt;=K;i++){
		D[i] = D[i-1] + near[i];
		if (sp[i] &amp;gt;= 0){
			int j = sp[i];
			D[i] = min(D[i], D[j] + abs(S[i]-S[j]));
		}
	}
	return D[K];
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3&gt;3. train&lt;/h3&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;$N$개의 정점이 있고, $M$개의 간선이 있는 방향성 그래프가 주어진다. 두 사람 A와 B가 게임을 진행한다. 이 중 1개 이상의 정점은 충전소가 놓여있고, 각 정점마다 A, B 두 사람 중 한 사람이 주인이 된다. 기차가 어떤 시작점에서 시작하여 이동을 시작한다. 기차가 어떤 정점에 최초로 도착하면 해당 정점의 주인이 그 정점에서 나가는 간선 중 하나를 선택하고 거기로 나간다. 이후 방문했을 때도, 이전에 정한 간선을 따른다. 이후에 기차는 같은 곳을 계속 돌게 되는데 도는 곳에 충전소가 있으면 A의 승리, 없으면 B의 승리다. 서로 최선을 다할 때, 각 정점마다 시작점이 될 때 누가 이기는지 구하는 문제다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이 문제에서 정점에 최초로 방문했을 때, 나가는 간선을 고르고 이후에도 유지가 된다고 적혀있다. 하지만 이러한 조건이 없어도 게임의 내용은 전혀 변하지 않는다. 즉, 정점을 방문할 때마다 나가는 간선을 고르는 것으로 문제 상황을 바꿔도 정확히 동일한 문제가 된다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;B의 승리가 확실한 시작점들을 계속 구해나갈 것이다. 우선 이를 위해, A가 어떤 간선을 선택하더라도 절대로 충전소로 갈 수 없는 시작점들의 집합을 $S$라고 할 때, 집합 $S$는 $S$의 여집합을 구하는 방식으로&amp;nbsp;아래와 같은 방법으로 찾아나갈 수 있다:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;1) 처음에 집합 $S$에 모든 정점들을 넣는다. 그리고 모든 충전소를 집합 $S$에서 지운다.&lt;/p&gt;
&lt;p&gt;2) 주인이 A인 정점 $v$에 대해서,&amp;nbsp;$v$에서 나가는 모든 간선이 집합 $S$에 없는 정점을 향한다면, 정점 $v$를 집합 $S$에서 지운다.&lt;/p&gt;
&lt;p&gt;3) 주인이 B인 정점 $v$에 대해서, $v$에서 집합 $S$에 없는 정점으로 향하는 간선이 있다면, 정점 $v$를 집합 $S$에서 지운다.&lt;/p&gt;
&lt;p&gt;4) 이를 반복한다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;집합 $S$에 있는 정점들은 시작점이 될 때 B의 승리가 확실한 정점들이다. 집합 $S$에 없더라도 B의 승리가 확실한 정점을 더 구할 수 있는데, 바로 A가 어떤 간선을 선택하더라도 반드시 집합 $S$에 속한 정점으로 오게되는 시작점들이다. 위에서 언급한 방법과 비슷한 방법으로 이러한 정점들을 구할 수 있다. 위의 방법은 위상정렬할 때, in degree가 0인 정점들을 계속 지워주는 것과 비슷한 방식으로 queue를 이용하여 총 시간복잡도 $O(M)$에 구현할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;다음과 같은 그래프를 생각해보자. 정점의 주인은 모두 A라고 하자. 아래의 그래프에서 집합 $S$에는 2번 정점만 있게 되고, 추가적으로 1번 정점까지 B의 승리가 확실한 시작점이 된다. 하지만, 0번 정점은 실제로 B의 승리가 확실한 정점임에도 불구하고 구하지 못한다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:400px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99F82133598D1AC029&quot; filemime=&quot;image/jpeg&quot; filename=&quot;그림1.png&quot; height=&quot;124&quot; width=&quot;400&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이유는 0번 정점은 A가 간선을 잘 선택하면 충전소에 갈 수도 있고, 또 간선을 잘 선택하면 집합&amp;nbsp;$S$에 속한 정점으로 가지 않을 수도 있기 때문이다. 좀 더 자세히 말하자면 0번 정점처럼 충전소에 가면 어쩔 수 없이 집합 $S$에 속한 정점으로 이동하게 되는 정점에 대한 처리가 남았다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;B의 승리가 확실한 시작점 중에 만약 충전소가 있다면 이는 의미가 전혀 없는 충전소가 된다. 이러한 충전소들을 지우고 같은 과정을 최대 $N$번 반복하면 0번 정점 같은 B의 승리가 확실한 정점들도 찾을 수 있다. 한 번 과정을 진행할 때마다 $O(M)$의 시간이 걸리므로, 총 시간복잡도 $O(NM)$에 B의 승리가 확실한 정점들을 모두 찾을 수 있고, B의 승리가 확실하지 않은 정점은 A의 승리가 확실하다는 것도 알 수 있다. 따라서 문제를 해결했다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more117_2&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '117_2','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content117_2&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea class=&quot;brush:cpp;&quot; name=&quot;code&quot;&gt;#include &quot;train.h&quot;

#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 5003
#define pb push_back
#define sz(v) ((int)(v).size())

int N, M;
int out_deg[MAXN];
vector &amp;lt;int&amp;gt; from[MAXN];
bool A[MAXN], R[MAXN];

bool S[MAXN], WB[MAXN];
int C[MAXN];

vector&amp;lt;int&amp;gt; who_wins(vector&amp;lt;int&amp;gt; a, vector&amp;lt;int&amp;gt; r, vector&amp;lt;int&amp;gt; u, vector&amp;lt;int&amp;gt; v)
{
	N = sz(a); M = sz(u);
	for (int i=0;i&amp;lt;M;i++){
		int a = ++u[i], b = ++v[i];
		from[b].pb(a); out_deg[a]++;
	}
	for (int i=1;i&amp;lt;=N;i++){
		A[i] = a[i-1];
		R[i] = r[i-1];
	}

	for (;;){
		queue &amp;lt;int&amp;gt; que;
		for (int i=1;i&amp;lt;=N;i++){
			S[i] = R[i];
			if (S[i]) que.push(i);
			C[i] = 0;
		}
		while (!que.empty()){
			int q = que.front(); que.pop();
			for (int t: from[q]) if (!S[t]){
				C[t]++;
				if (A[t] &amp;amp;&amp;amp; C[t] || !A[t] &amp;amp;&amp;amp; C[t] == out_deg[t])
					S[t] = 1, que.push(t);
			}
		}

		for (int i=1;i&amp;lt;=N;i++){
			WB[i] = !S[i];
			if (WB[i]) que.push(i);
			C[i] = 0;
		}
		while (!que.empty()){
			int q = que.front(); que.pop();
			for (int t: from[q]) if (!WB[t]){
				C[t]++;
				if (A[t] &amp;amp;&amp;amp; C[t] == out_deg[t] || !A[t] &amp;amp;&amp;amp; C[t])
					WB[t] = 1, que.push(t);
			}
		}

		bool sw = 0;
		for (int i=1;i&amp;lt;=N;i++) if (R[i] &amp;amp;&amp;amp; WB[i]) sw = 1, R[i] = 0;
		if (!sw) break;
	}

	vector &amp;lt;int&amp;gt; ret;
	for (int i=1;i&amp;lt;=N;i++) ret.pb(!WB[i]);
	return ret;
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>IOI2017</category>
<author>전명우</author>
<guid>https://blog.myungwoo.kr/117</guid>
<comments>https://blog.myungwoo.kr/117#entry117comment</comments>
<pubDate>Fri, 11 Aug 2017 14:43:05 +0900</pubDate>
</item>
<item>
<title>제34회 한국정보올림피아드 (KOI 2017) 중등부 풀이</title>
<link>https://blog.myungwoo.kr/116</link>
<description>&lt;h4&gt;1. 방 배정하기&amp;nbsp;(room)&lt;/h4&gt;
&lt;p&gt;수용인원이 A, B, C인 세 종류의 방이 있다. 이 방들을 적절히 예약하여 정확히 N명의 사람이 묵을 수 있도록 하는 문제다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;N이 최대 300으로 굉장히 작기 때문에 아래 DP 배열을 정의하고 값을 채우면 된다.&lt;/p&gt;
&lt;p&gt;D[i] = 정확히 i명의 사람이 묵을 수 있도록 예약할 수 있는가 (있으면 true, 없으면 false)&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;점화식은 다음과 같다:&lt;/p&gt;
&lt;p&gt;D[i] = D[i-A] OR D[i-B] OR D[i-C]&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more116_0&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '116_0','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content116_0&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea name=&quot;code&quot; class=&quot;brush:cpp;&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int A, B, C, N;
bool D[350];

int main()
{
	cin &amp;gt;&amp;gt; A &amp;gt;&amp;gt; B &amp;gt;&amp;gt; C &amp;gt;&amp;gt; N;
	D[0] = 1;
	for (int i=0;i&amp;lt;N;i++) if (D[i])
		D[i+A] = D[i+B] = D[i+C] = 1;
	printf(&quot;%d\n&quot;, D[N]);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4&gt;2. 곡선 자르기&amp;nbsp;(cut)&lt;/h4&gt;
&lt;p&gt;N개의 꼭짓점으로 이루어진 직교 단순 다각형이 주어진다. 이를 수평선 y=0으로 자른 뒤 윗부분으로 살렸을 때 선분들이 한 개 이상의 봉우리를 이루는 모양이 나온다. 봉우리들 중에서 다른 봉우리에 의해 포함되지 않는 봉우리의 개수와 다른 봉우리를 포함하지 않는 봉우리 개수를 구하는 문제다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;단순 다각형이란 같은 꼭짓점을 공유하는 두 선분을 제외한 나머지 선분 쌍이 서로 만나거나 교차하지 않는 다각형을 의미한다. 이 문제의 핵심은 봉우리를 잘 찾는 것이다. 봉우리를 찾는 방법은 아래에 첨부된 코드의 22번째 줄부터 32번째 줄까지를 참고하자.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;봉우리를 찾은 이후에, 각 봉우리를 [a, b]와 같은 구간으로 나타낼 수 있다. 그리고 단순 다각형이라는 조건 때문에, 모든 구간 쌍은 포함 관계가 없으면서 교차하지 않는다. 봉우리를 구간으로 표현하면 문제의 각색을 전부 제하고 다른 구간에 의해 포함되지 않는 구간의 개수와 다른 구간을 포함하지 않는 구간의 개수를 구하는 문제가 된다. 이는 구간들을 왼쪽 점 기준으로 정렬한 뒤에 손쉽게 해결할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more116_1&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '116_1','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content116_1&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea name=&quot;code&quot; class=&quot;brush:cpp;&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 1000006
typedef long long lld;

int N, M;
int X[MAXN*2], Y[MAXN*2];

struct Z{
	int a, b;
} A[MAXN];

int main()
{
	scanf(&quot;%d&quot;, &amp;amp;N);
	for (int i=1;i&amp;lt;=N;i++){
		scanf(&quot;%d%d&quot;, X+i, Y+i);
		X[N+i] = X[i]; Y[N+i] = Y[i];
	}

	for (int t=1;t&amp;lt;=N;t++) if (Y[t] &amp;lt; 0){
		int status = 0, last = 0;
		for (int s=0;s&amp;lt;N;s++){
			int i = t+s, j = i &amp;lt; N+N ? i+1 : 1;
			if (X[i] == X[j] &amp;amp;&amp;amp; (lld)Y[i]*Y[j] &amp;lt; 0){
				if (status) A[++M] = {min(last, X[i]), max(last, X[i])};
				else last = X[i]; 
				status ^= 1;
			}
		}
		break;
	}

	sort(A+1, A+M+1, [](const Z &amp;amp;a, const Z &amp;amp;b){
		return a.a &amp;lt; b.a;
	});

	int ans1 = 0, ans2 = 0, mx = -2e9;
	for (int i=1;i&amp;lt;=M;i++){
		if (mx &amp;lt; A[i].a) ans1++;
		mx = max(mx, A[i].b);
		if (i == M || A[i+1].a &amp;gt; A[i].b) ans2++;
	}
	printf(&quot;%d %d\n&quot;, ans1, ans2);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4&gt;3. 줄 서기&amp;nbsp;(line)&lt;/h4&gt;
&lt;p&gt;1부터 N까지 서로 다른 수로 이루어진 크기가 N인 수열, 즉, 크기가 N인 순열(permutation)에 대한 모든 inversion의 정보들이&amp;nbsp;주어진다. 이 때, 원래의 순열을 복원하는 문제다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;풀이1)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;맨 왼쪽 수부터 차례대로 수를 찾아나간다. i번쨰 수는 1부터 N까지 등장하지 않은 수 중에서 k번째로 작은 수가 되는데, 여기서 k는 (i번째 수보다 오른쪽에 있으면서 작은 수의 개수+1)이&amp;nbsp;된다. 등장하지 않은 수 중에서 k번째로 작은 수를 구하는 작업은 Fenwick tree를 통해 $O(\lg N)$ 시간에 구할 수 있다. 전체 시간복잡도는 $O(M+N \lg N)$이 된다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more116_2&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '116_2','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content116_2&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea name=&quot;code&quot; class=&quot;brush:cpp;&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 100005
#define MAXM 1000006

int N, M;
int P[MAXM], Q[MAXM];
int A[MAXN], cnt[MAXN];
int bit[MAXN];

void add(int n, int v)
{ for (;n&amp;lt;=N;n+=n&amp;amp;-n) bit[n] += v; }

int find(int k)
{
	int x = 0;
	for (int i=17;i--;){
		int t = x^(1&amp;lt;&amp;lt;i);
		if (t &amp;gt; N) continue;
		if (bit[t] &amp;lt; k) x = t, k -= bit[t];
	}
	return x+1;
}

int main()
{
	scanf(&quot;%d%d&quot;, &amp;amp;N, &amp;amp;M);
	for (int i=1;i&amp;lt;=N;i++) cnt[i] = 1;
	for (int i=1;i&amp;lt;=M;i++){
		scanf(&quot;%d%d&quot;, P+i, Q+i);
		cnt[P[i]]++;
	}

	for (int i=1;i&amp;lt;=N;i++) bit[i] = i&amp;amp;-i; 
	for (int i=1;i&amp;lt;=N;i++){
		if (cnt[i] &amp;gt; N-i+1){ puts(&quot;-1&quot;); return 0; }
		A[i] = find(cnt[i]);
		add(A[i], -1);
	}

	for (int i=1;i&amp;lt;=M;i++) if (A[P[i]] &amp;lt; A[Q[i]]){ puts(&quot;-1&quot;); return 0; }
	for (int i=1;i&amp;lt;=N;i++) printf(&quot;%d &quot;, A[i]); puts(&quot;&quot;);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;풀이2)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;수열의 각 원소마다 자신보다 작은 수의 개수를 세어줄 것이다. i번째 원소보다 작은 수의 개수를 cnt[i]라고 하자. 처음에 자신보다 왼쪽에 있는 수는 모두 작다고 가정하고, 자신보다 오른쪽에 있는 수는 모두 크다고 가정한다. 즉, 초기에 cnt[i] = i-1이 된다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;그리고 (a, b)라는 inversion이 입력으로 들어오면 처음 했던 가정 중 일부가 깨지게 된다. 즉, a번째 원소는 b번째 원소보다 왼쪽에 있으면서 더 크게 되기 때문에 cnt[b]가 1 줄어들게 되고, b번째 원소는 a번째 원소보다 오른쪽에 있으면서 더 작기 때문에 cnt[a]가 1 줄어들게 된다. 새로운 inversion에 대한 정보가 들어올 때마다 이처럼 cnt 배열의 값을 관리해줄 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;전체 시간복잡도는 $O(N+M)$이 된다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more116_3&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '116_3','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content116_3&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea name=&quot;code&quot; class=&quot;brush:cpp;&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 100005

int N, M;
int A[MAXN];
bool vis[MAXN];

int main()
{
	scanf(&quot;%d%d&quot;, &amp;amp;N, &amp;amp;M);
	for (int i=1;i&amp;lt;=N;i++) A[i] = i;
	for (int i=1;i&amp;lt;=M;i++){
		int a, b; scanf(&quot;%d%d&quot;, &amp;amp;a, &amp;amp;b);
		A[a]++; A[b]--;
	}

	for (int i=1;i&amp;lt;=N;i++){
		if (vis[A[i]]){ puts(&quot;-1&quot;); return 0; }
		vis[A[i]] = 1;
	}
	for (int i=1;i&amp;lt;=N;i++) printf(&quot;%d &quot;, A[i]); puts(&quot;&quot;);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4&gt;4. 산만한 고양이&amp;nbsp;(cat)&lt;/h4&gt;
&lt;p&gt;N개의 정점과 M개의 간선이 있는 무방향성 그래프가 주어진다. 이 그래프에서 정확히 한 개의 정점을 없애 모든 싸이클을 없앨 수 있는 정점들을 모두 구하는 문제다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이 문제를 해결하기 위해 여러 가지 접근이 떠오른다. 모든 싸이클을 없앨 수 있는 정점이란, 모든 싸이클에 포함된 정점이라고 접근을 할 수도 있다. 그렇지만 풀이는&amp;nbsp;정점을 없애고 났을 때 남은 모든 연결 요소가 트리가 된다는 사실에 접근해야 편하다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;우선, DFS 트리라는 것을 알아두면 매우 편하다. DFS 트리는 그래프에서 절점이나 절선을 구할 때 주로 이용된다. 왼쪽 그림과 같은 그래프가 있을 때, 오른쪽 그림의 트리는 가능한 DFS 트리 중 하나다. DFS 방문 순서에 따라 DFS 트리의 모양은 달라질 수 있다.&amp;nbsp;기존 그래프에서 모든 간선은 DFS 트리에서 tree edge(아래로 향한 실선 화살표)&amp;nbsp;혹은 back edge(위로 향한 점선 화살표) 둘 중 하나가 된다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:440px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/277550335979FA342C&quot; filemime=&quot;image/jpeg&quot; filename=&quot;그림1.png&quot; height=&quot;291&quot; width=&quot;440&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;어떤 한 정점을 지웠을 때 남은 연결 요소가 모두 트리가 되는지는 DFS 트리를 만들어놓고, 서브트리에 포함된 back edge의 수로 판단할 수 있다. DFS 트리를 만드는 방법과 판단의 자세한 로직은 코드를 참고하자.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more116_4&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '116_4','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content116_4&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea name=&quot;code&quot; class=&quot;brush:cpp;&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define MAXN 300005
#define pb push_back
typedef long long lld;

int N, M, C;
int dep[MAXN];
int U[MAXN], D[MAXN], F[MAXN];
/*
 * U[i] = i가 루트인 서브트리에 '완전히' 포함된 back edge의 수
 * D[i] = i가 루트인 서브트리에 '조금이라도' 포함된 back edge의 수
 * F[i] = i가 루트인 서브트리에서 i의 부모가 목적지인 back edge의 수
 */
vector &amp;lt;int&amp;gt; con[MAXN], child[MAXN];

void dfs(int n, int from)
{
	for (int t: con[n]) if (t != from){
		if (!dep[t]){
			// tree edge
			child[n].pb(t); dep[t] = dep[n]+1;
			int tmp = U[n]; dfs(t, n); F[t] = U[n]-tmp;
			U[n] += U[t]; D[n] += D[t];
		}else if (dep[t] &amp;lt; dep[n]){
			// back edge
			D[n]++; U[t]++;
		}
	}
}

int main()
{
	scanf(&quot;%d%d&quot;, &amp;amp;N, &amp;amp;M);
	for (int i=1;i&amp;lt;=M;i++){
		int a, b; scanf(&quot;%d%d&quot;, &amp;amp;a, &amp;amp;b);
		con[a].pb(b); con[b].pb(a);
	}
	dep[1] = 1; dfs(1, 0);

	lld ans = 0;
	for (int i=1;i&amp;lt;=N;i++){
		bool skip = 0;
		for (int t: child[i])
			if (D[t]-F[t] &amp;gt; 1 || U[t]) skip = 1;
		if (skip || M-(N-1)-D[i] != 0) continue;
		ans += i;
	}
	printf(&quot;%lld\n&quot;, ans);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>해법</category>
<author>전명우</author>
<guid>https://blog.myungwoo.kr/116</guid>
<comments>https://blog.myungwoo.kr/116#entry116comment</comments>
<pubDate>Thu, 27 Jul 2017 23:38:43 +0900</pubDate>
</item>
<item>
<title>제34회 한국정보올림피아드 (KOI 2017) 고등부 풀이</title>
<link>https://blog.myungwoo.kr/115</link>
<description>&lt;h4&gt;1. 물통 (bucket)&lt;/h4&gt;
&lt;p&gt;크기가 A인 물통과 크기가 B인 물통이 있고, 처음에는 모든 물통이 비어있다. 아래 4가지 동작을 통해 크기가 A인 물통에는 P 만큼, 크기가 B인 물통에는 Q 만큼의 물을 담는 최소 동작 횟수를 구하는 문제다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;1)&amp;nbsp;크기가 A인 물통을 비우거나 가득 채운다.&lt;/p&gt;
&lt;p&gt;2) 크기가 B인 물통을 비우거나 가득 채운다.&lt;/p&gt;
&lt;p&gt;3)&amp;nbsp;크기가 A인 물통에 담긴 물을 크기가 B인 물통에 옮긴다. 이 때, 크기가 B인 물통이 가득 차면 옮기는 것을 멈춘다.&lt;/p&gt;
&lt;p&gt;4)&amp;nbsp;크기가 B인 물통에 담긴 물을 크기가 B인 물통에 옮긴다. 이 때, 크기가 A인 물통이 가득 차면 옮기는 것을 멈춘다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;크기가 A인 물통에 a만큼의 물이, 크기가 B인 물통에 b만큼의 물이 담겨 있는 상태를 (a, b)라고 나타내자. 초기 상태나 위 4가지 동작 중 하나를 수행한 직후 다음과 같은 조건을 만족한다.&lt;/p&gt;&lt;br/&gt;&lt;blockquote class=&quot;tx-quote-tistory&quot;&gt;&lt;div&gt;a=0 혹은 a=A 혹은 b=0 혹은 b=B&lt;br /&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;p&gt;때문에 가능한 상태의 수는 $O(A+B)$라는 것을 알 수 있고, 이를 이용해 BFS를 통해 최소 동작 횟수를 구할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more115_0&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '115_0','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content115_0&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea name=&quot;code&quot; class=&quot;brush:cpp;&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

typedef pair&amp;lt;int, int&amp;gt; pii;

int A, B, P, Q;
int mem[100001][4];

struct Z{
	int a, b;
};
queue &amp;lt;Z&amp;gt; que;

int&amp;amp; D(int a, int b)
{
	if (!a) return mem[b][0];
	if (a == A) return mem[b][1];
	if (!b) return mem[a][2];
	if (b == B) return mem[a][3];
	return mem[0][2];
}

void push(int a, int b, int d)
{
	if (D(a, b) &amp;lt; 2e9) return;
	D(a, b) = d; que.push({a, b});
}

int main()
{
	cin &amp;gt;&amp;gt; A &amp;gt;&amp;gt; B &amp;gt;&amp;gt; P &amp;gt;&amp;gt; Q;
	for (int i=0;i&amp;lt;=B;i++) for (int j=0;j&amp;lt;4;j++) mem[i][j] = 2e9;
	push(0, 0, 0);
	while (!que.empty()){
		Z q = que.front(); que.pop();
		int a = q.a, b = q.b, d = D(a, b);
		push(0, b, d+1);
		push(a, 0, d+1);
		push(A, b, d+1);
		push(a, B, d+1);
		int v = min(A-a, b);
		push(a+v, b-v, d+1);
		v = min(a, B-b);
		push(a-v, b+v, d+1);
	}
	printf(&quot;%d\n&quot;, D(P, Q) &amp;lt; 2e9 ? D(P, Q) : -1);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4&gt;2. 문명&amp;nbsp;(civilization)&lt;/h4&gt;
&lt;p&gt;NxN 크기의 격자판에 초기 K개의 문명 발상지가 있다. 햇수가 지날수록 문명 발상지는 상하좌우로 인접한 칸에 문명을 전파시킨다. 이 때, 모든 문명이 하나로 결합될 때까지 걸리는 최소 햇수를 구하는 문제다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이 문제를 Parametric search로 접근해서 결정 문제를 Flood-Fill로 해결할 경우&amp;nbsp;$O(N^2 \lg N)$ 시간복잡도를 가지며, 54점을 받는다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이 문제를 $O(N^2 \alpha(n))$에 해결하기 위해서는 DSU(Disjoint Set Union, 서로소집합)을 이용하면 된다. 모든 문명이 하나로 결합된다는 것은 연결요소의 개수가 1개라는 것이고, Union-Find를 하면서 연결요소의 개수를 관리할 수 있기 때문에 연결요소의 개수가 1개가 되는 순간을 포착할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more115_1&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '115_1','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content115_1&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea name=&quot;code&quot; class=&quot;brush:cpp;&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int dy[] = {-1, 0, 1, 0}, dx[] = {0, 1, 0, -1};
int N, K, X, C;
int D[2001][2001], num[2001][2001];
int par[2000*2000+9];
bool vis[2001][2001];

int find(int n){ return par[n] == n ? n : (par[n] = find(par[n])); }

int main()
{
	scanf(&quot;%d%d&quot;, &amp;amp;N, &amp;amp;K);
	for (int i=1;i&amp;lt;=N;i++) for (int j=1;j&amp;lt;=N;j++) D[i][j] = 2e9, num[i][j] = ++X;
	for (int i=1;i&amp;lt;=X;i++) par[i] = i;
	queue &amp;lt;int&amp;gt; que;
	for (int i=1;i&amp;lt;=K;i++){
		int r, c; scanf(&quot;%d%d&quot;, &amp;amp;r, &amp;amp;c);
		D[r][c] = 0; que.push(r); que.push(c);
	}
	int ans = 0;
	for (;;ans++){
		while (!que.empty()){
			int y = que.front(); que.pop();
			int x = que.front(); que.pop();
			if (D[y][x] != ans){
				que.push(y); que.push(x);
				break;
			}
			vis[y][x] = 1; C++;
			for (int d=0;d&amp;lt;4;d++){
				int ny = y+dy[d], nx = x+dx[d];
				if (ny &amp;lt; 1 || ny &amp;gt; N || nx &amp;lt; 1 || nx &amp;gt; N) continue;
				if (vis[ny][nx]){
					int a = find(num[ny][nx]), b = find(num[y][x]);
					if (a != b) C--;
					par[b] = a;
				}else if (D[ny][nx] == 2e9){
					D[ny][nx] = D[y][x]+1;
					que.push(ny); que.push(nx);
				}
			}
		}
		if (C == 1) break;
	}
	printf(&quot;%d\n&quot;, ans);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4&gt;3. 요리 강좌&amp;nbsp;(cook)&lt;/h4&gt;
&lt;p&gt;N개의 학원 각각에서 M개의 강좌를 개설한다. 각 강좌는 순서대로 수강해야하고, 한 학원에서 연속해서 수강할 수 있는 강좌의 수는 최대 E개다. 그리고 S개 이상의 강좌를 연속해서 수강하면 학원을 옮길 수 있다. 그리고 학원을 옮길 때 비용 T 만큼을 지불해야한다. 마지막으로 각 학원마다 직전 강좌를 특정한 학원에서 수강한 학생을 받지 않는데, 이를 불허용 학원이라 한다. 각 학원마다 각 강좌를 수강하는데 필요한 비용이 주어졌을 때, 한 학생이 모든 강좌를 순서대로 수강하기 위해 필요한 최소 금액을 구하는 문제다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;다음과 같이 DP 배열을 정의한다:&lt;/p&gt;
&lt;p&gt;D[i][j] = i번째 강좌까지 수강을 마친 상황이고 마지막으로 강좌를 수강한 학원이 j이며, 이제 막 학원을 옮기려고 할 때 필요한 최소 비용&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;그러면 점화식은 다음과 같다:&lt;/p&gt;
&lt;p&gt;D[i][j] = min(D[k][l] + T + C[j][i] - C[j][k]) (단, S ≤&amp;nbsp;i-k ≤&amp;nbsp;E, l ≠&amp;nbsp;j, l ≠&amp;nbsp;j의 불허용 학원)&lt;/p&gt;
&lt;p&gt;여기서 C[j][i] 는 학원 j에서 첫 강좌부터 i번째 강좌까지 수강했을데 필요한 비용 (즉, 누적합)&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;DP의&amp;nbsp;점화식을 보면, i-E이상 i-S이하인 k에 대해 j와 j의 불허용 학원 번호와 다른 모든 l에 대해 D[k][l]-S[j][k]의 최소값을 구하여 T + S[j][i]를 더해주면 D[i][j]가 된다라고 말할 수 있다. [i-E, i-S]라는 구간은 i가 증가할 수록 오른쪽으로 이동하고 l의 조건이 j와 다름, &amp;nbsp;j의 불허용 학원과 다름, 즉, 2가지라는 것을 고려할 때, N개의 deque와 각 k에 대해 D[k][l]의 최소값 상위 3개를 구해놓음으로써 이 문제를 $O(NM)$ 시간에 DP 배열의&amp;nbsp;값들을 계산할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;DP 배열의 값들을 모두 계산한 뒤에, 답은 $O(NM)$ 시간복잡도로 naive하게 구할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more115_2&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '115_2','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content115_2&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea name=&quot;code&quot; class=&quot;brush:cpp;&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int N, M, S, E, T;
int A[3001][3001], B[3001];
int D[3001][3001], C[3001][3001];

struct Z{
	int v, t;
} mn[3001][3];

deque &amp;lt;Z&amp;gt; dq[3001];

int get_min(int day, int academy)
{
	if (mn[day][0].t != academy &amp;amp;&amp;amp; mn[day][0].t != B[academy]) return mn[day][0].v;
	if (mn[day][1].t != academy &amp;amp;&amp;amp; mn[day][1].t != B[academy]) return mn[day][1].v;
	return mn[day][2].v;
}

int main()
{
	scanf(&quot;%d%d%d%d%d&quot;, &amp;amp;N, &amp;amp;M, &amp;amp;S, &amp;amp;E, &amp;amp;T);
	for (int i=1;i&amp;lt;=N;i++) for (int j=1;j&amp;lt;=M;j++) scanf(&quot;%d&quot;, A[i]+j);
	for (int i=1;i&amp;lt;=N;i++) scanf(&quot;%d&quot;, B+i);
	for (int i=1;i&amp;lt;=N;i++) for (int j=1;j&amp;lt;=M;j++) C[i][j] = C[i][j-1] + A[i][j];
	for (int i=1;i&amp;lt;=M;i++){
		for (int j=1;j&amp;lt;=N;j++){
			if (i &amp;gt;= S){
				int v = get_min(i-S, j) - C[j][i-S];
				while (!dq[j].empty() &amp;amp;&amp;amp; dq[j].back().v &amp;gt;= v) dq[j].pop_back();
				dq[j].push_back({v, i-S});
			}
			while (!dq[j].empty() &amp;amp;&amp;amp; dq[j].front().t &amp;lt; i-E) dq[j].pop_front();
			if (dq[j].empty() || dq[j].front().v == 1e9) D[i][j] = 1e9;
			else D[i][j] = dq[j].front().v + T + C[j][i];
		}
		for (int j=0;j&amp;lt;3;j++) mn[i][j] = {(int)1e9, 0};
		for (int j=1;j&amp;lt;=N;j++) if (D[i][j] &amp;lt; 1e9){
			int v = D[i][j];
			if (v &amp;lt; mn[i][0].v)
				mn[i][2] = mn[i][1], mn[i][1] = mn[i][0], mn[i][0] = {v, j};
			else if (v &amp;lt; mn[i][1].v)
				mn[i][2] = mn[i][1], mn[i][1] = {v, j};
			else if (v &amp;lt; mn[i][2].v)
				mn[i][2] = {v, j};
		}
	}
	int ans = 1e9;
	for (int i=1;i&amp;lt;=N;i++){
		for (int j=M-E;j&amp;lt;M;j++){
			int v = get_min(j, i);
			if (v == 1e9) continue;
			ans = min(ans, v + C[i][M]-C[i][j]);
		}
	}
	printf(&quot;%d\n&quot;, ans);
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4&gt;4. 조개 줍기&amp;nbsp;(shell)&lt;/h4&gt;
&lt;p&gt;NxN 크기의 격자판에 음이 아닌 정수들이 적혀있다. 그리고 다음과 같이 DP 배열을 정의한다.&lt;/p&gt;
&lt;p&gt;D[i][j] = 맨 왼쪽 윗 칸인 시작점에서 i행 j열까지 오른쪽과 아래로만 이동하여 갈 때, 지나간 격자칸에 적힌 수 합의 최대값&lt;/p&gt;
&lt;p&gt;그리고 N개의 쿼리가 주어지는데, 각 쿼리는 어떤 특정 칸에 적힌 값을 1증가시키거나 1감소시킨다. 이 때, 각 쿼리를 수행한 후 모든 칸의 DP값의 합을 구하는 문제다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;만약 2행2열에 적힌 값이 변할 때, DP 값이 변하는 칸들은 다음과 같이 &quot;계단&quot; 형식으로 나타낼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: center; clear: none; float: none;&quot;&gt;&lt;span class=&quot;imageblock&quot; style=&quot;display:inline-block;width:820px;;height:auto;max-width:100%&quot;&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/27911733597814E132&quot; filemime=&quot;image/jpeg&quot; filename=&quot;그림1.png&quot; height=&quot;172&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;즉, 각 행에 대해 DP 값이 변하는 영역은 연속한 구간으로 나타낼 수 있다. 이를 이용하여 DP 값이 변하는 &quot;계단&quot; 모양의 영역을 구한 뒤 각 행에 대해 Fenwick tree를 통해 구간에 특정 값을 더하는 연산을 통하여 DP 값을 관리해줄 수 있다.&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;총 시간복잡도는 $O(N^2 \lg N)$이다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p id=&quot;more115_3&quot; class=&quot;moreless_fold&quot;&gt;
    &lt;span style=&quot;cursor: pointer;&quot; onclick=&quot;toggleMoreLess(this, '115_3','코드 보기','접기'); return false;&quot;&gt;
        코드 보기    &lt;/span&gt;
&lt;/p&gt;
&lt;div id=&quot;content115_3&quot; class=&quot;moreless_content&quot; style=&quot;display: none;&quot;&gt;&lt;textarea name=&quot;code&quot; class=&quot;brush:cpp;&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

typedef long long lld;

int N;
int A[1501][1501], D[1501][1501];
int bit[1501][1502];
int S[1501], E[1501];

void add(int n, int v, int bit[1502])
{ for (;n&amp;lt;=N;n+=n&amp;amp;(-n)) bit[n] += v; }
int get(int n, int bit[1502])
{ int ret = 0; for (;n;n^=n&amp;amp;(-n)) ret += bit[n]; return ret; }

inline int dp(int i, int j){ return D[i][j] + get(j, bit[i]); }

int main()
{
	scanf(&quot;%d&quot;, &amp;amp;N);
	for (int i=1;i&amp;lt;=N;i++) for (int j=1;j&amp;lt;=N;j++) scanf(&quot;%d&quot;, A[i]+j);
	lld ans = 0;
	for (int i=1;i&amp;lt;=N;i++) for (int j=1;j&amp;lt;=N;j++){
		D[i][j] = max(D[i-1][j], D[i][j-1]) + A[i][j];
		ans += D[i][j];
	}
	printf(&quot;%lld\n&quot;, ans);
	for (int t=1;t&amp;lt;=N;t++){
		char c; int y, x; scanf(&quot; %c%d%d&quot;, &amp;amp;c, &amp;amp;y, &amp;amp;x);
		int v = c == 'U' ? 1 : -1;
		for (int i=y;i&amp;lt;=N;i++) S[i] = N+1, E[i] = 0;
		S[y] = E[y] = x;
		for (int ny=y,nx=x;;){
			if (nx &amp;lt; N &amp;amp;&amp;amp; max(dp(ny-1, nx+1), dp(ny, nx))+v == max(dp(ny-1, nx+1), dp(ny, nx)+v)) nx++;
			else ny++;
			if (ny &amp;gt; N) break;
			E[ny] = nx;
		}
		for (int ny=y,nx=x;;){
			if (ny &amp;lt; N &amp;amp;&amp;amp; max(dp(ny+1, nx-1), dp(ny, nx))+v == max(dp(ny+1, nx-1), dp(ny, nx)+v)) ny++;
			else nx++;
			if (nx &amp;gt; N || E[ny] &amp;lt; nx) break;
			S[ny] = min(S[ny], nx);
		}
		for (int i=y;i&amp;lt;=N;i++) if (S[i] &amp;lt;= E[i]){
			add(S[i], v, bit[i]);
			add(E[i]+1, -v, bit[i]);
			ans += v * (E[i]-S[i]+1);
		}
		printf(&quot;%lld\n&quot;, ans);
	}
}&lt;/textarea&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</description>
<category>해법</category>
<author>전명우</author>
<guid>https://blog.myungwoo.kr/115</guid>
<comments>https://blog.myungwoo.kr/115#entry115comment</comments>
<pubDate>Wed, 26 Jul 2017 12:43:32 +0900</pubDate>
</item>
</channel>
</rss>