<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by JisuPark (jitkuu) on Medium]]></title>
        <description><![CDATA[Stories by JisuPark (jitkuu) on Medium]]></description>
        <link>https://medium.com/@JisuPark?source=rss-7de67ae1ab7f------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/0*PmdcLy4EipdQ19aQ./profile_images/1827085607/H3JchjPc_normal</url>
            <title>Stories by JisuPark (jitkuu) on Medium</title>
            <link>https://medium.com/@JisuPark?source=rss-7de67ae1ab7f------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 13 May 2019 17:30:31 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@JisuPark" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[안녕하세요.]]></title>
            <link>https://medium.com/@JisuPark/%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94-2e0f0b15a210?source=rss-7de67ae1ab7f------2</link>
            <guid isPermaLink="false">https://medium.com/p/2e0f0b15a210</guid>
            <category><![CDATA[reac]]></category>
            <category><![CDATA[hoc]]></category>
            <category><![CDATA[example]]></category>
            <dc:creator><![CDATA[JisuPark (jitkuu)]]></dc:creator>
            <pubDate>Thu, 11 May 2017 03:03:09 GMT</pubDate>
            <atom:updated>2017-05-11T03:03:09.563Z</atom:updated>
            <content:encoded><![CDATA[<p>안녕하세요.</p><p>잘 말씀해주셨습니다. 해당 예제는 사실 실제로 돌아가는 코드는 아니고요, 가장 처음 고차 컴포넌트 대중화에 기여한 <a href="https://medium.com/u/62e7de0d6312">Sebastian Markbåge</a>의 코드입니다. 해당 개념에 대한 논의가 있었던 쓰레드라서 삽입을 하였습니다.</p><p>실제로 동작하게 하려면 아래와 같이 해야합니다. <a href="https://jsfiddle.net/jisupark/z0qLotxm/">https://jsfiddle.net/jisupark/z0qLotxm/</a></p><p>감사합니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2e0f0b15a210" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[So impressive article. I totally agree with your point :D]]></title>
            <link>https://medium.com/@JisuPark/so-impressive-article-i-totally-agree-with-your-point-d-48feea7bc1c1?source=rss-7de67ae1ab7f------2</link>
            <guid isPermaLink="false">https://medium.com/p/48feea7bc1c1</guid>
            <dc:creator><![CDATA[JisuPark (jitkuu)]]></dc:creator>
            <pubDate>Mon, 27 Mar 2017 12:06:40 GMT</pubDate>
            <atom:updated>2017-03-27T12:06:40.940Z</atom:updated>
            <content:encoded><![CDATA[<p>So impressive article. I totally agree with your point :D</p><p>I’ll share with my colleagues. Thanks again!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=48feea7bc1c1" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[안녕하세요. 기대되네요 :)]]></title>
            <link>https://medium.com/@JisuPark/%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94-%EA%B8%B0%EB%8C%80%EB%90%98%EB%84%A4%EC%9A%94-9a25d3b0ce21?source=rss-7de67ae1ab7f------2</link>
            <guid isPermaLink="false">https://medium.com/p/9a25d3b0ce21</guid>
            <dc:creator><![CDATA[JisuPark (jitkuu)]]></dc:creator>
            <pubDate>Thu, 26 Jan 2017 05:13:06 GMT</pubDate>
            <atom:updated>2017-01-26T05:13:06.946Z</atom:updated>
            <content:encoded><![CDATA[<p>안녕하세요. 기대되네요 :)</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9a25d3b0ce21" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[말씀해주신게 맞습니다. 삽입한 예제가 적절하지 못하네요. 지적 감사드립니다!!]]></title>
            <link>https://medium.com/@JisuPark/%EB%A7%90%EC%94%80%ED%95%B4%EC%A3%BC%EC%8B%A0%EA%B2%8C-%EB%A7%9E%EC%8A%B5%EB%8B%88%EB%8B%A4-%EC%82%BD%EC%9E%85%ED%95%9C-%EC%98%88%EC%A0%9C%EA%B0%80-%EC%A0%81%EC%A0%88%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%98%EB%84%A4%EC%9A%94-%EC%A7%80%EC%A0%81-%EA%B0%90%EC%82%AC%EB%93%9C%EB%A6%BD%EB%8B%88%EB%8B%A4-f6880ebc858a?source=rss-7de67ae1ab7f------2</link>
            <guid isPermaLink="false">https://medium.com/p/f6880ebc858a</guid>
            <dc:creator><![CDATA[JisuPark (jitkuu)]]></dc:creator>
            <pubDate>Fri, 13 Jan 2017 14:02:23 GMT</pubDate>
            <atom:updated>2017-01-13T14:02:23.727Z</atom:updated>
            <content:encoded><![CDATA[<p>말씀해주신게 맞습니다. 삽입한 예제가 적절하지 못하네요. 지적 감사드립니다!!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f6880ebc858a" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[안녕하세요! 댓글 감사합니다.]]></title>
            <link>https://medium.com/@JisuPark/%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94-%EB%8C%93%EA%B8%80-%EA%B0%90%EC%82%AC%ED%95%A9%EB%8B%88%EB%8B%A4-a7f0e5e2796d?source=rss-7de67ae1ab7f------2</link>
            <guid isPermaLink="false">https://medium.com/p/a7f0e5e2796d</guid>
            <dc:creator><![CDATA[JisuPark (jitkuu)]]></dc:creator>
            <pubDate>Tue, 10 Jan 2017 02:28:41 GMT</pubDate>
            <atom:updated>2017-01-10T02:28:41.279Z</atom:updated>
            <content:encoded><![CDATA[<p>안녕하세요! 댓글 감사합니다.<br>render를 부르기 위한 API는 foreceUpdate가 있습니다. setState API는 컴포넌트의 Updating 프로세스를 triggering 하기 위한 API입니다. 따라서 제가 강조하고 싶었던 부분은 Updating 프로세스를 triggering 하려면, 자바스크립트에서는 기본적으로 reference 값을 기준으로 비교를 하기 때문에 명시적으로 state를 변경할 수 있는 setState를 사용한다는 점입니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a7f0e5e2796d" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[React의 기본, 컴포넌트를 알아보자]]></title>
            <link>https://medium.com/little-big-programming/react%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90-92c923011818?source=rss-7de67ae1ab7f------2</link>
            <guid isPermaLink="false">https://medium.com/p/92c923011818</guid>
            <category><![CDATA[react]]></category>
            <category><![CDATA[es6]]></category>
            <category><![CDATA[frontend]]></category>
            <category><![CDATA[리액트]]></category>
            <category><![CDATA[components]]></category>
            <dc:creator><![CDATA[JisuPark (jitkuu)]]></dc:creator>
            <pubDate>Mon, 09 Jan 2017 05:20:09 GMT</pubDate>
            <atom:updated>2017-01-14T08:54:57.297Z</atom:updated>
            <content:encoded><![CDATA[<h4>모두 알지만 잘 알지는 못하는 컴포넌트</h4><h4>TL;DR</h4><ul><li>UI = View(State)</li><li>React 컴포넌트 Lifecycle 함수들을 명확하게 이해하자.</li><li>React 컴포넌트의 props, state, setState API를 이해하자.</li><li>React 개발 시 알아두면 유용한 컴포넌트 디자인 패턴에 대해 알아보자.</li><li>State 관리와 React 앱의 성능에 대한 부분은 다루지 않는다.</li></ul><h3><strong>React를 한마디로 설명하면?</strong></h3><p>아마도 <a href="https://facebook.github.io/react/">홈페이지</a>에서 “A JAVASCRIPT LIBRARY FOR BUILDING USER INTERFACES”라고 설명하듯이 UI를 위한 JS 라이브러리로 표현할 수 있겠죠. 하지만 이 설명으로는 조금 부족하다고 느껴집니다. 저는 UI를 아래의 수식으로 표현한다면, React를 아래 수식에서 View 함수에 해당한다고 설명합니다.</p><pre><strong>UI = View(State)</strong></pre><p>위 식에서 UI는 View 함수에 어떤 State 값을 대입했을 때 나온 결과입니다. 중요한 점은 <strong>View를 State가 같다면 항상 같은 UI를 결과로 갖는 함수로 본다</strong>는 것이죠.</p><p>만약 React를 <strong>View 함수 개발에 도움을 주는 라이브러리</strong>로 본다면 <a href="https://medium.com/@dan_abramov/youre-missing-the-point-of-react-a20e34a51e1a#2d59">React의 특징이자 장점</a>들을 아래와 같이 자연스럽게 이해할 수 있습니다.</p><ol><li>함수의 정의가 그러하듯 <strong>단방향 사고</strong>를<strong> </strong>강제합니다.</li><li>함수가 그러하듯 <strong>특정 </strong><strong>state, </strong><strong>props에 따른 render 결과가 바뀌지 않습니다.</strong></li><li>함수 내용을 정의하듯 <strong>JSX</strong>를 통해 어떻게 화면을 그릴지 정의합니다.</li><li>함수 간 합성(Composition)이 가능하듯이 <strong>컴포넌트 간 합성</strong>을 할 수 있습니다.</li></ol><p>React를 이해하기 위해 기초인 View 함수에 집중해보죠.</p><h3><strong>React 컴포넌트</strong></h3><p>가장 먼저 알아야 하는 것은 React의 컴포넌트입니다. 컴포넌트는 개념적으로 props를 input으로 하고 UI가 어떻게 보여야 하는지 정의하는 <a href="https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html">React Element</a>를 output으로 하는 <strong>함수</strong>입니다. 따라서 <strong>합성을 이용</strong>하여 “UI를 재사용할 수 있고 독립적인 단위로 쪼개어 생각”할 수 있게 합니다. 그래서 컴포넌트는 React.Component를 상속받아 정의하지만 컴포넌트 간에는 <strong>상속보다는 합성</strong>을 사용하길 권장합니다.</p><p>UI를 구성하기 위해서는 화면에 컴포넌트를 그리고(<strong>Mounting)</strong>, 갱신하고(<strong>Updating)</strong>, 지워야(<strong>Unmounting)</strong> 합니다. 컴포넌트는 각 프로세스가 진행될 때에 따라 Lifecycle 함수로 불리는 특별한 함수가 실행됩니다. 개발자는 이를 재정의하여 컴포넌트를 제어하게 됩니다. 그러므로 Lifecycle 함수들을 완전하게 이해해야 합니다. 프로세스와 세부 프로세스, 그리고 각 프로세스에 대응하는 Lifecycle 함수들은 아래 다이어그램을 통해 쉽게 파악할 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*YD6sBv5Ly548pGl042z3DA.jpeg" /><figcaption>React Lifecycle in ES6. Inspired by <a href="https://twitter.com/sstur_/status/567937326669651969">Simon Sturmer</a></figcaption></figure><p>위 개념을 이해하면 쉽게 저지르는 실수를 줄일 수 있는데, 예를 들면 다음과 같습니다.</p><ul><li><strong>Mouting</strong>: Creating 중인 componentWillMount()에서 Ajax 요청을 날리면 응답 시간만큼 컴포넌트를 그리는 것이 늦어짐을 알 수 있습니다. 따라서 일반적으로 componentDidMount()에서 Ajax 요청을 하는 게 낫다는 것을 알 수 있습니다.</li><li><strong>Updating</strong>: Receiving State 중에 setState() API를 호출하면 프로세스가 끝난 후 또다시 Receiving State 할 것을 알 수 있습니다. 따라서 setState() API를 해당 Lifecycle 함수에서 호출하면 개념적으로 무한 루프에 빠질 수밖에 없다는 것을 알 수 있습니다. (물론 실제로도 무한 루프에 빠지게 됩니다.)</li></ul><h3>React 컴포넌트의 props와 state</h3><p>컴포넌트는 두 가지 인스턴스 속성(property) <strong>props</strong>와 <strong>state</strong>를 가지고 있습니다. props는 컴포넌트의 mounting, updating 프로세스 시점에 값이 할당될 뿐 컴포넌트 내부에서 값을 변경할 수 없습니다. 상황에 따라 변경되어야 하는 값들은 state를 이용해야합니다. 왜 props와 state로 나누어 사용하도록 설계했을까요? 무슨 이점이 있을까요?</p><p>먼저 개발자들에게 <strong>명확한 관념 모델</strong>(static mental model)을 제공합니다. 관념 모델은 무엇이 어떻게 동작하는지 이해할 때 진행되는 일련의 사고 프로세스를 의미합니다. 즉, <strong>논리적으로 이치에 맞는 사고 모델을 제공한다</strong>는 것이죠.</p><p>만약 input으로 들어오는 props를 컴포넌트 내부에서 변경할 수 있다면 어떻게 되어야할까요? props를 내려주는 부모 컴포넌트에도 영향이 가야 할까요? state가 없다면 유저 이벤트에 맞춰 변경돼야 하는 값은 어떻게 관리할까요? 개발자는 이러한 질문에 고민할 필요가 없습니다. <strong>컴포넌트 간에는 무조건 </strong><strong>props를 통해서만 데이터를 주고받고 </strong><strong>props는 컴포넌트 내부에서 변경되지 않습니다</strong>. 따라서 위/아래 양쪽에 대해 동시에 고민할 필요가 없고 아래 한쪽 방향(<strong>uni-directional</strong>) 그리고 자기 자신에 대해서만 고민하면 됩니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/854/1*1JzmOFt70B-EF3rQzrI9PQ.png" /><figcaption>계층 기준으로 부모 자식 관계를 표현한 React 컴포넌트 관계도</figcaption></figure><p>지금 컴포넌트에서 필요한 값이 props인지 state인지 판단하고 어느 Lifecycle과 관련이 있는지 이 값을 어떤 컴포넌트에 어떻게 넘겨줄지만 생각하여 코드를 작성하면 컴포넌트를 완성할 수 있습니다.</p><p>퍼포먼스 측면의 이점도 있습니다. 만약 props와 state가 하나의 객체로 관리된다면, Updating을 할지 결정하는 shouldComponentUpdate() 함수에서 <strong>O(keys(props+state))</strong>만큼 값이 변경되었는지를 비교해야 하지만, 애초에 props와 state로 분리되어 있으므로 <strong>O(keys(state))</strong>만큼만 비교하면 Updating을 결정할 수 있습니다.</p><h3>React 컴포넌트의 setState() API</h3><blockquote>setState에 대한 질문이나 소개하는 글을 많이 보지 못했는데 아마도 setState를 이용하기보단 바로 Redux나 MobX와 같은 state 관리 라이브러리를 사용하는 것 같습니다. 하지만 setState를 꼭 사용해보고 난 후에 Redux 혹은 MobX 사용을 고민해봐야 합니다. 2016년도를 강타한 <a href="https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f">how-it-feels-to-learn-javascript-in-2016</a>이라는 글에서 꼬집듯이 맹목적으로 사용하는 것이 아닌 <strong>왜 사용하는가?</strong>를 알아야 <a href="https://github.com/ehrudxo/react-makes-you-sad">무엇이 편해지고 언제 사용해야 좋은지 알 수 있기 때문이죠.</a></blockquote><p>컴포넌트는 setState()(이하 ‘setState’)라는 API가 존재합니다. 이름 그대로 컴포넌트의 state를 변경할 때 사용하는 API입니다. 그냥 state를 직접 변경할 수도 있을 텐데 왜 굳이 API를 통해서 변경해야 할까요? <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators">자바스크립트의 비교 연산자</a>는 피연산자의 값이 아닌 reference 값을 기준으로 참/거짓을 리턴하기 때문입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/528/1*GaPNj3s7e72YNZjMS7Z2zA.png" /><figcaption>비교 연산자는 오브젝트의 값이 아닌 reference 값을 비교한다.</figcaption></figure><p>만약 state의 값을 직접 변경할 경우에는 해당 오브젝트의 reference 값이 변하지 않아 컴포넌트는 state가 변경되지 않았다고 볼 수밖에 없습니다. 그러므로 <a href="https://facebook.github.io/react/docs/state-and-lifecycle.html#do-not-modify-state-directly">화면이 갱신되지 않는 것</a>이지요. 따라서 React는 setState를 이용해 기존 state와 머지하여 <strong>state의 변경 가능성</strong>을 명시적으로 알려줍니다. 머지를 통해 새로 생성된 state의 <strong>reference 값은 기존과 다르므로</strong> 컴포넌트에서는 shallow compare를 통해 변경되었음을 알 수 있습니다. 물론 reference 변경일 뿐이니 실제 값은 변경되지 않을 수도 있습니다.</p><p>한 가지 더 중요한 사실은 setState 호출 즉시 state가 변경되는 것이 아니라 <strong>비동기로 동작한다</strong>는 점입니다. 상태가 변경된 직후에 필요한 작업이 있다면 setState(nextState, callback)의 callback을 사용해야 합니다.</p><p>따라서 아래는 <strong>보장되지 않습니다</strong>.</p><ol><li>setState 호출 직후에 state가 즉시 갱신된다.</li><li>한 컨텍스트 내에서의 setState 호출 수와 컴포넌트 업데이트 수는 같다.</li></ol><p>하지만 다음은 <strong>보장됩니다.</strong></p><ol><li>setState 실행 순서</li><li>setState callback의 실행 순서</li><li>state 변화가 클릭 등의 event 실행 전에 컴포넌트에 반영된다.</li></ol><p>그렇다면 setState는 왜 비동기로 동작할까요? 이는 끊김 없는 원활한 UI/UX를 제공하기 위해 일정 수의 render를 꼭 수행시키기 위해서입니다. setState가 동기로 동작한다고 가정해보겠습니다. state 변경이 많으면 많을수록 render는 모든 변경이 적용될 때까지 늦어지기 때문에 실제 화면에서는 <strong>엄청나게 부자연스럽게 동작</strong>하게 될 것입니다. 비동기로 동작하게 되면 render 시점과 별개로 동작하기 때문에 자연스러운 갱신이 가능해집니다.</p><h3>React 컴포넌트 디자인 패턴</h3><p>지금까지 다룬 내용이 컴포넌트에 대한 부분이라면 이번에는 실제 컴포넌트 디자인 패턴에 대해서 다뤄보겠습니다. 디자인 패턴은 일반적으로 아래와 같은 목적을 위해 고안되었습니다.</p><ul><li>DRY (Don’t Repeat Yourself)를 유지한다.</li><li>재사용 가능한 컴포넌트를 만든다.</li><li>컴포넌트가 무엇을 하는지 명확하게 이해할 수 있다.</li></ul><h4>기본 컴포넌트 (Basic Component)</h4><pre>// class Button extends React.Component {<br>//   render() {<br>//     const { className } = this.props;<br>//     return &lt;button type=&quot;button&quot; className={className} &gt;;<br>//   }<br>// }</pre><pre>&lt;Button className=&quot;myBtn&quot; /&gt;</pre><p>기본 컴포넌트는 개발자가 컴포넌트에 일일이 &lt;button type=”button”&gt;를 작성해야 하는 것을 위와 같이 일반화하여 <strong>DRY</strong>를 유지하게 도와줍니다. 작은 노력으로 큰 효과를 주는 <strong>little-big </strong>한 디자인 패턴입니다.</p><h4>고차 컴포넌트 (Higher Order Component)</h4><p>고차 컴포넌트는 <a href="https://medium.com/u/62e7de0d6312">Sebastian Markbåge</a>의 <a href="https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775">gist</a>를 시작으로 대중화된 패턴입니다. <a href="https://github.com/reactjs/react-redux">react-redux</a> 의 <a href="https://github.com/reactjs/react-redux/blob/f892ec00d7e92ff7afb21498276472f0e3b000c5/src/connect/connect.js">connect()</a>나 <a href="https://facebook.github.io/relay/">Relay</a>의 <a href="https://facebook.github.io/relay/docs/guides-containers.html">createContainer()</a> 등이 고차 컴포넌트에 해당합니다. 고차 컴포넌트는 <strong>컴포넌트를 input으로 하고 컴포넌트를 output</strong>으로 하는 함수라고 생각하시면 됩니다. 수도코드로 표현하면 다음과 같습니다.</p><pre>// @<a href="https://flowtype.org/">flow</a><br>hoc = (input: React.Component): React.Component =&gt; output</pre><p><strong>여러 컴포넌트에서 공통으로 사용하는 로직을 한 컴포넌트의 역할로 분리하여</strong> 컴포넌트의 내부 로직을 간결하고 명확하게 유지하게 합니다. 이를 통해 컴포넌트들의 <strong>재사용성</strong>이 올라갑니다.</p><p>실제 구현은 아래와 같이 하게 됩니다.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/abf525a94d3520556c6db68ea028bffa/href">https://medium.com/media/abf525a94d3520556c6db68ea028bffa/href</a></iframe><blockquote>render 함수 안에서 HOC를 사용하면 매번 새로운 컴포넌트가 만들어져서 성능이 떨어집니다.</blockquote><p><strong>고차 컴포넌트는 공통 로직을 어떻게 분리하느냐가 핵심입니다.</strong></p><pre>Logic: { a, b, c, d }</pre><p>위와 같이 a, b, c, d라는 로직을 원소로 가지는 길이가 4인 집합 Logic을 생각해봅시다. Logic은 컴포넌트가 내부 로직으로 사용할 수 있는 모든 로직을 원소로 가집니다. 그렇다면 컴포넌트가 사용하는 내부 로직은 총 2⁴ 만큼의 경우의 수가 존재합니다. 이 때, <strong>가장 적은 수의 고차 컴포넌트로 가장 많은 수의 존재 가능한 내부 로직</strong>을 감당하려면 어떻게 해야 할까요? 수학적으로 당연히 원소 각각에 대한 고차 컴포넌트 4개를 작성하면 됩니다. 하지만 실제 애플리케이션에서 사용되는 로직의 조합의 수는 4보다 작을 수도 있습니다. 즉 <strong>실제로 사용하는 로직의 조합 수에 따라 </strong>고차 컴포넌트를 보다<strong> atomic </strong>하게 만들지 혹은 좀 더 <strong>specialize </strong>하게 만들지 결정하면 됩니다.</p><h4>무 상태 컴포넌트 (Stateless Component)</h4><p>무 상태 컴포넌트는 <strong>재사용성이 굉장히 높은 컴포넌트</strong>를<strong> </strong>작성할 수 있게 도와줍니다. 컴포넌트를 완전한 함수로 정의한다는 점이 특징입니다. 개인적으로는 더욱 명확한 의미를 전달할 수 있다는 점에서 state가 없을 경우엔 무상태 컴포넌트로 작성합니다. 기본 컴포넌트에서 보여드렸던 예제를 이용해 보면 다음과 같습니다.</p><pre>const Button = (props) =&gt; (<br>  &lt;button type=&quot;button&quot; className={props.className} /&gt;<br>)</pre><p>ES6의 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">Destructuring assignment</a>를 이용하여 더 명확하게 표현할 수도 있습니다.</p><pre>const Button = ({ className }) =&gt; (<br>  &lt;button type=&quot;button&quot; className={className} /&gt;<br>)</pre><p>혹은 ES6의 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator">Spread Syntax</a>와 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters">Rest parameters</a>를 이용하면 좀 더 안전하고 확장성이 높은 컴포넌트를 만들 수도 있습니다.</p><pre>const Button = ({ className, ...remainProps }) =&gt; (<br>  &lt;button type=&quot;button&quot; className={className} {...remainProps} /&gt;<br>)</pre><h4>특수화 (Specialization)</h4><p>특수화는 <strong>컴포넌트의 역할을 specialize 해서 보다 명확한 컴포넌트</strong>로 만들어줍니다. 상태에 따라 특정 컴포넌트가 구분이 될 때 특수화를 이용하면 보다 시맨틱적인 코드를 작성할 수 있습니다.</p><pre>const RedButton = () =&gt; &lt;Button className=&quot;red&quot;&gt;<br>const BlueButton = () =&gt; &lt;Button className=&quot;blue&quot;&gt;</pre><pre>// {this.props.theme === RED ? &lt;RedButton&gt; : &lt;BlueButton&gt;}</pre><h4>Presentational &amp; Container 컴포넌트</h4><blockquote>이 패턴은 <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">React 생태계의 슈퍼스타 </a><a href="https://medium.com/u/a3a8af6addc1">Dan Abramov</a>이 <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">Smart &amp; Dumb 컴포넌트란 이름으로 제시하였습니다. 후에 더욱 정확한 의미 전달을 위해 명칭이 변경되었습니다</a>.</blockquote><p>컴포넌트들은 MVC 구조에서 말하는 C(컨트롤러)의 역할을 해야 할 경우가 있습니다. 단순히 props, state로 화면을 그리는 데 필요한 값을 넘겨받는 것이 아니라 Ajax 요청이나 localStorage 등을 통해 데이터를 fetching 해야 할 경우에 말이죠. 컴포넌트가 화면에 대한 정의를 넘어서 <strong>데이터 fetching까지 담당하게 되면 specialize 하게 되어 재사용성이 떨어집니다. </strong>또한 <strong>로직과 Lifecycle이 복잡해져 무엇을 하는 컴포넌트인지 이해하기 어려워집니다.</strong></p><p>Presentational &amp; Container 컴포넌트 패턴은 이러한 문제점을 해결하고 컴포넌트 테스트를 더욱 쉽게 합니다. 핵심 아이디어는 한 컴포넌트 내에 존재하는 <strong>render</strong>와 관련된 로직과 <strong>데이터</strong>와 관련된 로직을 각각 Presentational 컴포넌트, Container 컴포넌트로 분리하는 것이지요. 따라서 각 컴포넌트는 아래와 같은 특징이 있습니다.</p><p>Presentational 컴포넌트는</p><ul><li>JSX를 이용한 <strong>마크업이 존재</strong>합니다.</li><li>render에 필요한 <strong>데이터는 이미 존재</strong>한다고 가정합니다.</li><li>UI를 위한 state가 존재할 수 있습니다.</li></ul><p>Container 컴포넌트는</p><ul><li>JSX를 이용한 <strong>마크업이 거의 없습니다</strong>.</li><li>Ajax 요청, HOC 등을 이용해 <strong>render에 필요한 데이터를 Fetching</strong> 합니다.</li><li>데이터 Fetching 등을 위한 state가 존재할 수 있습니다.</li></ul><p>위에서 알 수 있듯 <strong>state의 존재 여부가 Presentational &amp; Container 컴포넌트를 구분 짓는 것이 아닙니다</strong>.</p><blockquote>실제 예제는 <a href="https://medium.com/u/49e1066348ce">michael chan</a>의 <a href="https://gist.github.com/chantastic/fc9e3853464dffdb1e3c">gist</a>를 참고하세요. 본문이 너무 길어져 따로 첨부하지 않겠습니다.</blockquote><h3>몇 가지 사소하지만 큰 Little-big tips</h3><ul><li><strong>Property Initializer</strong>: Babel의 <a href="https://babeljs.io/docs/plugins/preset-stage-2/">stage-2-preset</a>부터 지원되는 <a href="https://babeljs.io/docs/plugins/transform-class-properties/">Class properties transform</a>이란 플러그인을 이용하면 아래와 같이 컴포넌트의 constructor를 깔끔하게 관리할 수 있습니다. 자세한 스펙은 <a href="https://tc39.github.io/proposal-class-public-fields/">proposal</a>을 참고하세요.</li></ul><pre>class Button extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = { isChanged: false };<br>    this.handleClickButton = this.handleClickButton.bind(this);<br>  }</pre><pre>  handleClickButton(e) {<br>    this.setState({ isChanged: true });<br>  }</pre><pre>  render() {<br>    const { value } = this.props;<br>    return (<br>      &lt;button onClick={this.handleClickButton}&gt;{value}&lt;/button&gt;<br>    );<br>  }<br>}</pre><pre>Button.defaultProps = { value: &#39;default value&#39; };</pre><p>위와 같은 컴포넌트는 Property Initializer를 활용하면 아래와 같이 정의할 수 있습니다.</p><pre>class Button extends React.Component {<br>  static defaultProps = { value: &#39;default value&#39; };</pre><pre>  state = { isChanged: false };  </pre><pre>  handleClickButton = (e) =&gt; this.setState({ isChanged: true });</pre><pre>  render() {<br>    const { value } = this.props;<br>    return (<br>      &lt;button onClick={this.handleClickButton}&gt;{value}&lt;/button&gt;<br>    );<br>  }<br>}</pre><ul><li><strong>&lt;body&gt; 요소에 컴포넌트를 </strong><strong>render 하지 않습니다</strong>: 특정 사이트나 크롬 익스텐션 등이 &lt;body&gt; 요소 기준으로 DOM을 조작할 수 있으므로<strong> </strong>Virtual DOM을 통해 DOM을 관리하는 React에 엄청난 사이드 이펙트를 끼칠 수 있습니다.</li><li><a href="https://github.com/AlexGilleran/jsx-control-statements"><strong>jsx-control-statement</strong></a>: 만약 babel 6를 쓴다면 고려해볼만한 babel plugin입니다. JSX 상에서 제어문을 사용할 수 있게 확장해줍니다. 보다 가독성 높은 JSX 코드를 사용하게 도와줍니다.</li><li><a href="https://facebook.github.io/react/docs/react-api.html#react.purecomponent"><strong>React.PureComponent</strong></a><strong>도 존재합니다: </strong>shouldComponentUpdate() 함수에서 shallow compare 하도록 이미 정의되어있는 Pure 컴포넌트를 이용하면 보다 수월하게 Updating 프로세스를 관리할 수 있습니다.</li></ul><h4><strong>마무리</strong></h4><p>React를 사용하면서 컴포넌트에 대해 고민하고 정리했던 개념들을 최대한 쉽게 설명하고 싶었습니다. React를 기본부터 차근차근 이해하고 싶으신 분들께 도움이 되었으면 좋겠습니다. 피드백은 항상 환영합니다. 혹시 더 궁금하거나 소통하고 싶은 분들은 <a href="https://gitter.im/little-big-programming/Lobby">Little Big Programming Gitter</a> 에서 만나요~</p><p><a href="https://gitter.im/little-big-programming/Lobby">little-big-programming/Lobby</a></p><h4>글쓴이에 대해서</h4><p>현재는 Frontend 개발에 집중하고 있습니다. 개발 영역만이 아닌 삶 전반적인 부분에서 애자일을 지향합니다. 원격 근무에 관심이 많습니다. 개발자가 온전히 개발에 집중할 수 있도록 도와주는 업무 자동화, 개발 인프라 등에 재미를 느낍니다.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=92c923011818" width="1" height="1"><hr><p><a href="https://medium.com/little-big-programming/react%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90-92c923011818">React의 기본, 컴포넌트를 알아보자</a> was originally published in <a href="https://medium.com/little-big-programming">little big programming</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[React.js가 IE 브라우저 지원 중단했다면서요?]]></title>
            <link>https://medium.com/little-big-programming/react-js%EA%B0%80-ie-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%A7%80%EC%9B%90-%EC%A4%91%EB%8B%A8%ED%96%88%EB%8B%A4%EB%A9%B4%EC%84%9C%EC%9A%94-a9734bc323cb?source=rss-7de67ae1ab7f------2</link>
            <guid isPermaLink="false">https://medium.com/p/a9734bc323cb</guid>
            <category><![CDATA[cross-browsing]]></category>
            <category><![CDATA[reactjs]]></category>
            <category><![CDATA[polyfill]]></category>
            <category><![CDATA[react]]></category>
            <category><![CDATA[ie]]></category>
            <dc:creator><![CDATA[JisuPark (jitkuu)]]></dc:creator>
            <pubDate>Mon, 05 Sep 2016 03:24:02 GMT</pubDate>
            <atom:updated>2016-11-09T05:07:45.509Z</atom:updated>
            <content:encoded><![CDATA[<h4>어떻게든 IE를 지원하려는 당신을 위한 안내서</h4><h4>TL;DR</h4><ul><li>아직 시작하지 않았다면 늦지 않았다. <strong>지원하지 말자고 설득해보자!</strong></li><li>Polyfills을 통해 IE 8에서 지원하지 않는 구문을 동작하게 하자.</li><li>Getter/Setter는 금물이다.</li><li>IE 8을 지원하는 라이브러리 버전들에 대해 알아보자.</li></ul><p>제목에 대한 답입니다. <a href="https://facebook.github.io/react/blog/2016/01/12/discontinuing-ie8-support.html">네</a>. 당장 React.js의 IE 8 관련 버그의 우선 순위를 낮추고, 결국엔 지원을 중단할 것이라고 밝혔습니다.</p><p>그러나 이 글은 <strong>IE 8을 지원하려는 React 개발자</strong>들을 위해 작성되었습니다.</p><h4>이 글의 목적</h4><p>IE 8을 지원 해야하는 개발자는 크게 아래 두가지 상황을 맞이하게 됩니다.</p><ol><li>IE 8을 지원하는 React application을 개발할 것이다.</li><li>React application을 이미 개발했고 IE 8을 추가 지원해야한다.</li></ol><p>이 글은 1번에 해당되는 개발자들은 <strong>React가 아닌 다른 방법으로 개발</strong>을 하고 2번에 해당되는 개발자들은 <strong>IE 8에 성공적으로 대응</strong>하기를 기원하며 작성되었습니다.</p><h4>왜 지원을 해야하죠?</h4><p>최근 6개월 동안 국내의 경우 <a href="http://gs.statcounter.com/#browser_version-KR-monthly-201602-201607-bar">약 4%</a>의 유저가 여전히 IE 8 을 사용하고 있습니다. 무시해도 될만큼 적은 비율로 보이지만, 네이버에서는 아예 <a href="http://tools.naver.com/service/internet-explorer/index.nhn">네이버에 최적화된 IE 8</a>를 제공하고 있습니다. 어느 서비스에서는 IE 7, 8이 10% 가량 유지되기도 하고요. 이처럼 IE 8 지원 여부 및 이유는 서비스 별 특징에 따라 다를 수 있습니다. 즉, 글을 읽고 있는 여러분들도 언젠가 마주칠 수 있는 상황인 거죠.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1009/1*m7JvIuZ_jhM74sCiHmJ2AA.png" /><figcaption><a href="https://www.microsoft.com/en-us/WindowsForBusiness/End-of-IE-support">Microsoft에서도 버린 IE 8, 9, 10.은 장수를 위해 가급적 우리나라에서 보지 않았으면 합니다.</a></figcaption></figure><h4>혹시나? 역시나!</h4><p>React 공식 <a href="https://github.com/reactjs/react-tutorial">튜토리얼</a>을 이용해 간단히 한번 살펴보겠습니다.</p><p>입맛에 맞는 서버를 실행시키고 브라우저로 접속해보면, 아래와 같이 <strong>간단한</strong> react 앱이 잘 동작합니다. 물론 <a href="http://farukat.es/journal/2011/02/528-modern-browser">모던 브라우저</a>에서 말이죠.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Q9uVgrzERBYm0Xy-KoLXng.png" /><figcaption>Chrome v53에서 렌더링한 React Tutorial</figcaption></figure><p>IE 8에선 어떻게 되나 한번 볼까요?</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/780/1*vRbBciFG5a9IqmUJzyU2SQ.jpeg" /><figcaption>기대를 실망시키지 않는 우리의 IE 8</figcaption></figure><p>…그럼 지금부터 IE 8에서도 동작하도록 패치를 해볼까요?</p><h4>React Tutorial 설명</h4><blockquote>기존 babel-browser는 <a href="https://github.com/reactjs/react-tutorial/pull/158">#158</a> 이후에 react tutorial에서 제거되어 해당 내용을 수정하였습니다. (16.09.07)</blockquote><p>본격적인 패치에 앞서 React Tutorial의 가장 핵심인 <a href="https://github.com/Daniel15/babel-standalone">babel-standalone</a>를 소개해드리겠습니다.</p><pre>&lt;script src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot; /&gt;</pre><p>public/index.html에 포함되어 있는 위 script는 아래와 같은 “text/babel”의 type 속성 값을 가지는 script 태그의 code를 babel을 이용해 ECMAScript 5(이하 ‘ES 5’)로 transcompile 해주는 라이브러리입니다.</p><pre>&lt;script type=&quot;text/babel&quot; src=&quot;scripts/example.js&quot; /&gt;</pre><p>결과적으로 위 example.js는 babel-standalone에 의해 ES 5로 transform되죠. 물론 현재 tutorial은 ES 5로 작성되어있지만 3rd party 라이브러리들도 같이 transform된다는 점에서 필수입니다.</p><blockquote>참고로 <a href="https://github.com/Daniel15/babel-standalone">babel-standalone</a>는 babel에서 제공하는 공식 라이브러리는 아닙니다. 현재 babel에서 <a href="https://babeljs.io/docs/usage/browser/">deprecated</a>된 babel-browser의 대체재로 babel의 <a href="https://babeljs.io/docs/usage/browser/">공식문서</a>에서 소개하고 있는 라이브러리입니다.</blockquote><p><strong>그렇기때문에</strong> 현재로서는 어떠한 코드를 추가하더라도 IE 8에서는 동작하지 않습니다. 왜냐하면 babel에서 transform 해준 결과물은 ES 5이기 때문에 ES5 호환성에 대해서 <a href="http://kangax.github.io/compat-table/es5/">빨간색으로 도배되어있는</a> IE 8은 죽었다 깨어나도 지원하지 못합니다.</p><h4>Tutorial #1. es3-loader</h4><p>하지만 물러설 순 없지요. ES 5를 ES 3로 transform 해주는 <a href="https://github.com/spicyj/es3ify">es3ify</a>라는 라이브러리가 있습니다. 이를 이용해 IE 8이 지원하는 ES 3로 transform 해보도록 하죠.</p><blockquote>지금부터는 babel-browser가 제공하는 기능을 넘어서기 때문에 webpack+babel 사용을 전제로 설명드리겠습니다. 또한 아래에서 설명하는 코드들은 기존 튜토리얼을 fork해서 만든 <a href="https://github.com/little-big-programming/react-tutorial-ie8/tree/feature/tutorials">react-tutorial-ie8의 feature/tutorial 브랜치</a>에서 보실 수 있습니다.</blockquote><p><a href="https://github.com/JisuPark/react-tutorial-ie8/commit/bf14bf36a126e5a22c13fa015aa1a519caad6eea">bf14bf commit</a>과 같이 webpack 설정 파일에 <a href="https://webpack.github.io/docs/loaders.html">post loader</a>로 es3ify-loader를 추가해줍니다(아래 참고). 이는 babel transform이 완료된 코드에 es3ify를 이용해 다시 transform 하는 것을 의미합니다.</p><pre>postLoaders: [<br>  {<br>    test: /\.js[x]?$/,<br>    loaders: [&#39;es3ify-loader&#39;]<br>  }<br>]</pre><p>그리고 최종 빌드된 파일 webpack.bundle.js를 index.html에 추가합니다. 이때, 이미 transform된 JS 이므로 script 태그의 type은 “text/javascript”로 수정합니다.</p><pre>&lt;script type=&quot;text/javascript&quot; src=&quot;scripts/webpack.bundle.js&quot; /&gt;</pre><blockquote>이 과정에서 IE 8을 애초에 지원하지 않는다고 밝힌 react@15.x와 react-dom@15.x, jQuery@3.x의 버전은 알맞은 버전으로 수정합니다. 알맞은 버전 찾는 법은 따로 설명하지 않겠습니다.</blockquote><p><strong>그리고나서 IE 8에서 어떻게 되는지 볼까요?</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*C_FUDQL1BuClb8nTSHQf1A.jpeg" /><figcaption><strong>야호! 아까보다는 훨씬 양호!</strong></figcaption></figure><p>네 아직 갈 길이 남았습니다. 하지만 기존에 있던 오류들은 많이 사라졌네요.</p><h4>Tutorial #2. babel-polyfill</h4><p>위에서 본 오류에 따르면 1419번째 줄, 다시 말해 아래 구문에서 오류가 나는 것으로 보이는군요.</p><pre>svgElements.forEach(<strong>function </strong>(nodeName) {<br>  markupWrap[nodeName] = svgWrap;<br>  shouldWrap[nodeName] = <strong>true</strong>;<br>});</pre><p>아주 단순한 문제입니다. IE 8은 말그대로 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Compatibility">forEach method를 모르고 있습니다</a>. 그렇다면 당연히 해당 method를 정의해주면 해결되겠습니다. 이때 바로 polyfill이 필요하게 됩니다. polyfill은 모던 브라우저에서만 지원되는 기능을 올드 브라우저에서도 동작하게끔 도와주는 역할을 합니다. 방금 위에서 사용한 es3ify나 Media Query를 쓸 수 있게 도와주는 <a href="https://github.com/scottjehl/Respond">respond.js</a>를 생각해보시면 되겠네요.</p><p><a href="https://github.com/JisuPark/react-tutorial-ie8/commit/d56a2421d109529b7845c507cc919334ffee5111">d56a24 commit</a>과 같이 babel-polyfill을 package.json과 webpack 설정 파일에 추가해주면 tutorial application이 IE 8에서 잘 동작하는 것을 확인할 수 있습니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*2lJ1BvYGdKvyeg5pesmWRg.jpeg" /><figcaption>드디어 동작하는 Tutorial Application!</figcaption></figure><blockquote>만약 babel-polyfill의 크기가 부담스럽다면 babel-polyfill에서 실질적인 polyfill역할을 담당하는 core-js를 필요한 부분만 활용하면 됩니다. 자세한 방법은 지난 번에 퍼블리시된 <a href="https://medium.com/little-big-programming/spa-스크립트-용량-어디까지-줄일-수-있을까-69c7e05bb3b3"><strong><em>SPA 스크립트 용량 어디까지 줄일 수 있을까?</em></strong></a><em>의</em> <strong>ES2015(ES6) 와 commonjs</strong> 부분을 참고해주세요.</blockquote><p>축하합니다!</p><p>이렇게 첫 번째 IE 8 지원을 마쳤습니다.</p><h4>Real World #1. 내가 만났던 오류와 polyfill을 통한 대처</h4><p>지금까지는 간단한 예제로 IE 8 대응 방법을 살펴보았는데요. 실제로 만나게 될 오류들은 훨씬 다양합니다. 제가 만났던 오류들과 해결을 위한 대응은 다음과 같습니다. 구체적인 내용은 해당 라이브러리의 링크를 참고해주세요.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*9B5xF4x5OmP5ryAMX4Q0NA.png" /><figcaption>위 Case들은 <a href="https://paper.dropbox.com/doc/React-Tutorial-IE-8-zYl17k69oSUUMiSEhU5r0">https://paper.dropbox.com/doc/React-Tutorial-IE-8-zYl17k69oSUUMiSEhU5r0</a>에 정리 중. 제보 환영</figcaption></figure><ul><li><a href="https://github.com/es-shims/es5-shim">es5-shim</a>: ES 5 함수들용 polyfill.</li><li><a href="https://github.com/es-shims/es5-shim">es5-sham</a>: es5-shim 확장 polyfill (es5-shim을 필요로 함)</li><li><a href="https://github.com/zloirock/core-js">core-js</a>: ES 5부터 7 그리고 비표준 함수용 polyfill.</li><li><a href="https://github.com/babel/babel/tree/master/packages/babel-polyfill">babel-polyfill</a>: core-js + <a href="https://github.com/facebook/regenerator">regenerator</a></li><li><a href="https://github.com/paulmillr/console-polyfill">console-polyfill</a>: Browser console 지원용 polyfill</li><li><a href="https://github.com/stefanpenner/es6-promise">es6-promise</a>: ES 6의 Promise 지원용 polyfill</li><li><a href="https://github.com/camsong/fetch-ie8">fetch-ie8</a>: window.fetch 지원용 polyfill</li></ul><blockquote>현재 Production에서 사용 중인 polyfill은 console-polyfill, es5-shim, es6-promise, fetch-ie8 입니다.</blockquote><h4>Real World #2 Getter/Setter 절대 금물</h4><p>ES6의 getter와 setter를 사용할 경우 babel에서는 <a href="https://babeljs.io/docs/usage/caveats/">Object.defineProperty을 이용하여 transform</a>을 합니다. 하지만 해당 구문을 IE 8에서는 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">DOM Object에서만 사용할 수 있게</a> 규정하게 두어서 항상 오류가 발생합니다.</p><p>해당 오류는 CommentBox 이름을 수정하는 기능을 추가한 <a href="https://github.com/JisuPark/react-tutorial-ie8/commit/abce88119672727d7d3195100f4d0f72aa2921c0">abce88 commit</a>을 참고하시면 됩니다. ES 6와 Getter/Setter를 이용하여 해당 오류를 발생하는 예제입니다.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Xw_YTD1ohWynCHFMrCDyww.jpeg" /><figcaption>Getter/Setter는 위와 같은 에러나 Exception thrown and not caught 같은 무서운 에러를 뿜어냅니다.</figcaption></figure><blockquote>__proto__ 를 통한 상속도 IE &lt; 10 에서는 지원되지 않으므로 금물입니다.</blockquote><h4>Real World #3 IE 8 지원을 위한 라이브러리 버전</h4><p>실제 어플리케이션 개발을 하다보면 node 라이브러리들을 많이 쓰게 되는데요, 각 라이브러리들의 browser support를 항상 확인하고, 실제 build된 코드도 읽어보는 습관을 들이는 것이 좋습니다. IE 8 지원 시에 쓸 수 있는 라이브러리들 버전 몇 가지 공유드리겠습니다.</p><ul><li><a href="https://github.com/reactjs/react-router">react-router</a>: ^1.0.3 버전만 <a href="https://github.com/reactjs/react-router/blob/2d407e6738a17f0afa8cd5cbd9732bc966deba72/CHANGES.md#v101">IE 8에서 원활하게 동작</a>합니다.</li><li>history: ^1.17.0 (react-router와의 dependency)</li><li><a href="https://github.com/lodash/lodash">lodash</a>: &lt; 4.0 버전만 <a href="https://github.com/lodash/lodash/releases/tag/4.0.0">IE 8에서 원활하게 동</a>작합니다.</li></ul><h4>Real World #4 react 0.14의 span</h4><p>react &lt; 15에서는 text에 기본적으로 span 태그가 붙으면서 css가 깨지는 경우가 많습니다. 관련 내용을 퍼블리셔 혹은 xml 담당에게 전달하여 예기치 않은 스타일 충돌 및 깨짐을 방지하세요. 퍼블리셔와 협업하는 방법은 추후에 더 자세히 알아보도록 하지요.</p><blockquote>v15에는 <a href="https://github.com/facebook/react/pull/5753">이 커밋</a>이 포함되어 더 이상 span이 생성되지 않습니다.</blockquote><h4>FAQ</h4><ul><li>Q: flow 써도 되나요? A: 네 잘됩니다. 영향없어요.</li><li>Q: 오 얼마나 걸리셨나요? A: 시간보다는 practice가 없어서 하나하나 빌드 &amp; 테스트하면서 rewrite했습니다. 🙊🙊</li></ul><h4>글을 정리하며..</h4><p>지금까지 제가 경험했던 IE 8 이슈와 대응 방법에 대해 공유드렸습니다…만 아직도 늦지 않았습니다. react로 꼭 IE 8을 지원하셔야 하나요? <strong>농담입니다</strong>. 사실 아무리 이해를 잘하고 적용을 잘해도 결국엔 올드 브라우저들에 대한 지원이 조금씩 사라지면 같이 쓸모없어질 능력(!)이라 아쉽지만, 한번쯤은 경험해도 나쁘진 않은 것 같습니다. Redux 관련해서는 부수적으로 설명해야할 것들이 많아져서 일부러 제외했지만, 혹시나 궁금하시다면 댓글 혹은 <a href="https://twitter.com/catm1nt">@catm1nt</a>에 남겨주세요.</p><blockquote>긴 글 읽어주셔서 감사합니다. 도움이 되셨다면 공유, 댓글, 추천, 구독 부탁드리겠습니다. <a href="https://github.com/little-big-programming/react-tutorial-ie8/">react-tutorial-ie8</a> 프로젝트에 Production에서 만나는 IE 8 관련 이슈를 계속 업데이트할 예정이니 Star 부탁드립니다.</blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a9734bc323cb" width="1" height="1"><hr><p><a href="https://medium.com/little-big-programming/react-js%EA%B0%80-ie-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%A7%80%EC%9B%90-%EC%A4%91%EB%8B%A8%ED%96%88%EB%8B%A4%EB%A9%B4%EC%84%9C%EC%9A%94-a9734bc323cb">React.js가 IE 브라우저 지원 중단했다면서요?</a> was originally published in <a href="https://medium.com/little-big-programming">little big programming</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
    </channel>
</rss>