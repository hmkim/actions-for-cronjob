<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
<title>자바캔(Java Can Do IT)</title>
<link>https://javacan.tistory.com/</link>
<description>최범균이 운영하는 자바 및 웹 관련 컨텐츠 제공 블로그</description>
<language>ko</language>
<pubDate>Tue, 14 May 2019 00:31:59 +0900</pubDate>
<generator>TISTORY</generator>
<managingEditor>madvirus</managingEditor>
<image>
<title>자바캔(Java Can Do IT)</title>
<url>http://cfile23.uf.tistory.com/image/2770E13A5327C9750E9C13</url>
<link>https://javacan.tistory.com</link>
<description>최범균이 운영하는 자바 및 웹 관련 컨텐츠 제공 블로그</description>
</image>
<item>
<title>적당히 잘하는 개발자</title>
<link>https://javacan.tistory.com/entry/%EC%A0%81%EB%8B%B9%ED%9E%88-%EC%9E%98%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90</link>
<description>졸업 전만 해도 굉장한 개발자가 되고 싶었다. 뛰어난 설계 능력과 코딩 속도를 자랑하는 그런 실력자 말이다. 이런 막연한 목표는 오래가지 않아 사라졌다. 3-4년 정도 경력을 쌓는 동안 '적당히 잘하는 개발자'로 원하는 수준이 바뀌었다. 언제인지도 모르게 '굉장한' 개발자가 되기 어렵다는 걸 깨닫고 나름 노력하면 될 수 있는 '적당히 잘하는'으로 목표를 낮춘 것이다. 회사 생활을 하면서 뭔가 대단한 걸 만들 재주가 없다는 것을 알게 되었고 남이 만든..&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://javacan.tistory.com/514&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>개발자이야기</category>
<author>최범균 madvirus</author>
<guid>https://javacan.tistory.com/514</guid>
<comments>https://javacan.tistory.com/entry/%EC%A0%81%EB%8B%B9%ED%9E%88-%EC%9E%98%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90#entry514comment</comments>
<pubDate>Thu, 02 May 2019 21:38:54 +0900</pubDate>
</item>
<item>
<title>Centos 7에 kubeadm을 이용해서 쿠버네티스 (1.13 기준) 설치하기</title>
<link>https://javacan.tistory.com/entry/k8s-install-in-centos7</link>
<description> Centos 7 버전에 쿠버네티스(kubernetes)를 설치하는 과정을 정리한다. 보다 자세한 내용은 다음 문서를 참고한다. Installing kubeadm Creating a single master cluster with kubeadm 0. Centos 7 준비 쿠버네티스 테스트 용도로 세 개의 가상 머신을 준비했다. 각 가상 머신에 Centos 7을 설치했고 IP와 호스트 이름을 다음과 같이 설정했다. 172.16.1.100 k8s-mas..&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://javacan.tistory.com/511&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>k8s</category>
<category>Kubernetes</category>
<category>쿠버네티스 설치</category>
<author>최범균 madvirus</author>
<guid>https://javacan.tistory.com/511</guid>
<comments>https://javacan.tistory.com/entry/k8s-install-in-centos7#entry511comment</comments>
<pubDate>Fri, 18 Jan 2019 22:34:48 +0900</pubDate>
</item>
<item>
<title>스프링 부트에서 EnvironmentPostProcessor로 기본 프로필 설정하기</title>
<link>https://javacan.tistory.com/entry/activate-some-profile-when-no-active-profiles-in-boot</link>
<description>최근에 사용하는 프로필이 dev, prod, local, test 4개가 존재하는 스프링 부트 어플리케이션을 개발하고 있다. 로컬에서 'mvn spring-boot:run' 명령어를 실행하면 local 프로필을 사용해서 부트 앱을 실행하고 싶었다. src/main/resources 폴더에 application-prod.properties, application-dev.properties, application-local.properties 파일이 함..&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://javacan.tistory.com/510&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring, JPA, ORM</category>
<category>ConfigurableEnvironment</category>
<category>Spring boot</category>
<category>부트</category>
<author>최범균 madvirus</author>
<guid>https://javacan.tistory.com/510</guid>
<comments>https://javacan.tistory.com/entry/activate-some-profile-when-no-active-profiles-in-boot#entry510comment</comments>
<pubDate>Fri, 21 Dec 2018 04:09:22 +0900</pubDate>
</item>
<item>
<title>스프링 스케줄러 런타임에 cron 설정 변경하기</title>
<link>https://javacan.tistory.com/entry/change-spring-cron-schedule-at-runtime</link>
<description>스프링 스케줄러를 이용해서 cron 설정을 런타임에 변경하는 방법을 살펴본다. 1. TaskScheduler 설정 먼저 TaskScheduler를 설정한다. @Configuration public class SchedulingConfiguration { @Bean public ThreadPoolTaskScheduler schedulerExecutor() { ThreadPoolTaskScheduler taskScheduler = new ThreadPo..&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://javacan.tistory.com/509&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Spring, JPA, ORM</category>
<category>cron</category>
<category>ScheduledFuture</category>
<category>TaskScheduler</category>
<author>최범균 madvirus</author>
<guid>https://javacan.tistory.com/509</guid>
<comments>https://javacan.tistory.com/entry/change-spring-cron-schedule-at-runtime#entry509comment</comments>
<pubDate>Thu, 20 Dec 2018 23:08:42 +0900</pubDate>
</item>
<item>
<title>아파치 2.4에 추가된 filesize 식을 이용해서 특정 크기를 넘어서는 파일 접근 차단하기</title>
<link>https://javacan.tistory.com/entry/forbid-large-size-file-access-using-filesize-in-apache24</link>
<description>클라우드 서버에 실수로 용량이 큰 이미지 파일을 올리면 과도한 트래픽 발생으로 높은 비용을 지불할 수도 있다. 이런 상황을 방지하는 방법 중 하나는 아파치 웹 서버 설정에서 응답 파일의 크기를 제한하는 것이다. 아파치 웹 서버에서는 RewirteCond에서 filesize() 식을 사용해서 특정 크기보다 큰 파일에 대한 접근을 거부할 수 있다. 다음은 &lt;Directory&gt; 설정은 1 MB(1048576 바이트) 큰 파일에 접근할 때 403 상태 코드..&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://javacan.tistory.com/508&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>리눅스,Tomcat,서버 등</category>
<author>최범균 madvirus</author>
<guid>https://javacan.tistory.com/508</guid>
<comments>https://javacan.tistory.com/entry/forbid-large-size-file-access-using-filesize-in-apache24#entry508comment</comments>
<pubDate>Sat, 08 Dec 2018 23:32:09 +0900</pubDate>
</item>
<item>
<title>리액터 네티(Reactor Netty)로 간단한 TCP 서버 만들기</title>
<link>https://javacan.tistory.com/entry/reactor-netty-simple-tcp-server</link>
<description>다소 동접이 발생하는 간단한 TCP 서버를 구현할 기술을 찾다가 리액터 네티(Reactor Netty)를 알게 되었다. 리액터 네티를 이용하면 네티를 기반으로 한 네트워크 프로그램을 리액터 API로 만들 수 있다. 리액터 네티를 사용하면 네티를 직접 사용하는 것보다 간결한 코드로 비동기 네트워크 프로그램을 만들 수 있는 이점이 있다. 다음은 리액터 네티(Reactor Netty)의 주요 특징이다. 네티 기반 리액터 API 사용 논블로킹 TCP, UD..&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://javacan.tistory.com/507&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Reactive</category>
<category>Reactor Netty</category>
<category>tcp</category>
<category>리액터 네티</category>
<author>최범균 madvirus</author>
<guid>https://javacan.tistory.com/507</guid>
<comments>https://javacan.tistory.com/entry/reactor-netty-simple-tcp-server#entry507comment</comments>
<pubDate>Fri, 07 Dec 2018 09:00:40 +0900</pubDate>
</item>
<item>
<title>시간 당 실행 횟수 제한 라이브러리 3종 소개: RateLimiter, RateLimitJ, Bucket4j</title>
<link>https://javacan.tistory.com/entry/ratelimiter-ratelimitj-bucket4j-intro</link>
<description>특정 시간 동안 실행 횟수를 제한하기 위한 라이브러를 검색해서 아래 3가지 정도를 찾았다. RateLimiter (guava, https://github.com/google/guava) RateLimitJ (https://github.com/mokies/ratelimitj) Bucket4j (https://github.com/vladimir-bukhtoyarov/bucket4j) 이 글에서는 각 라이브러리의 사용법을 간단하게 살펴본다. Guava R..&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://javacan.tistory.com/505&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Java</category>
<category>Bucket4j</category>
<category>RateLimiter</category>
<category>RateLimitJ</category>
<author>최범균 madvirus</author>
<guid>https://javacan.tistory.com/505</guid>
<comments>https://javacan.tistory.com/entry/ratelimiter-ratelimitj-bucket4j-intro#entry505comment</comments>
<pubDate>Wed, 26 Sep 2018 22:20:21 +0900</pubDate>
</item>
<item>
<title>데브옵스 핸드북 실천법 핵심 요약</title>
<link>https://javacan.tistory.com/entry/devops-handbook-core-practice-summary</link>
<description> 이 글은 DevOps Handbook 책을 읽고 몇 가지 핵심 실천법을 정리한 것이다. (원서 링크, 번역서 링크) *주의: 요약 글에 오류/오역이 존재할 수 있고 더 중요한 내용을 누락했을 수도 있으니 애매한 부분은 반드시 원문을 참고하기 바란다. 데브옵스 시작하기 밸류스트림 선택 데브옵스 전환을 시도할 밸류 스트림은 신중히 선택할 것: 성공해야 확대 기회 생김 동조 잘하고 혁신적인 그룹과 시작하기: 보수적인 그룹은 처음부터 설득하지 말고 충분히..&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://javacan.tistory.com/503&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>기타 자료 등</category>
<category>DevOps</category>
<category>데브옵스</category>
<category>실천법</category>
<author>최범균 madvirus</author>
<guid>https://javacan.tistory.com/503</guid>
<comments>https://javacan.tistory.com/entry/devops-handbook-core-practice-summary#entry503comment</comments>
<pubDate>Mon, 20 Aug 2018 16:49:44 +0900</pubDate>
</item>
<item>
<title>스프링 리액터 시작하기 10 - 로깅, 체크포인트</title>
<link>https://javacan.tistory.com/entry/Reactor-Start-10-logging-checkpoint</link>
<description>스프링 리액터 로깅과 체크포인트 로깅 리액터의 동작을 보다 자세히 보고 싶다면 다음과 같이 log() 메서드를 사용한다. 아래 코드를 보자. Flux.just(1, 2, 4, 5, 6) .log() .map(x -&gt; x * 2) .subscribe(x -&gt; logger.info(&quot;next: {}&quot;, x)); 로깅 프레임워크로 SLF4j를 사용할 경우 실행한 결과는 다음과 같다. 08:38:29.990 [main] DEBUG reactor.util.L..&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://javacan.tistory.com/502&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Reactive</category>
<category>로깅</category>
<category>리액터</category>
<category>체크포인트</category>
<author>최범균 madvirus</author>
<guid>https://javacan.tistory.com/502</guid>
<comments>https://javacan.tistory.com/entry/Reactor-Start-10-logging-checkpoint#entry502comment</comments>
<pubDate>Wed, 08 Aug 2018 10:36:01 +0900</pubDate>
</item>
<item>
<title>스프링 리액터 시작하기 9 - 묶어서 처리하기(window buffer)</title>
<link>https://javacan.tistory.com/entry/Reactor-Start-9-window-buffer</link>
<description>리액터 윈도우 일정 개수로 묶어서 Flux 만들기: window(int), window(int, int) Flux#window(int) 메서드를 사용하면 시퀀스가 발생시키는 데이터를 일정 개수로 묶을 수 있다. 다음은 예제 코드이다. Flux&lt;Flux&lt;Integer&gt;&gt; windowSeq = Flux.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) .window(4); // 4개 간격으로 4개씩 새로운 Flux로 묶음 windowSeq..&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://javacan.tistory.com/501&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Reactive</category>
<category>buffer</category>
<category>reactor</category>
<category>window</category>
<category>버퍼</category>
<category>스프링 리액터</category>
<category>윈도우</category>
<author>최범균 madvirus</author>
<guid>https://javacan.tistory.com/501</guid>
<comments>https://javacan.tistory.com/entry/Reactor-Start-9-window-buffer#entry501comment</comments>
<pubDate>Mon, 06 Aug 2018 18:12:53 +0900</pubDate>
</item>
<item>
<title>스프링 리액터 시작하기 8 - 모으기(aggregation)</title>
<link>https://javacan.tistory.com/entry/Reactor-Start-8-Aggregation</link>
<description>리액터 모으기(aggregation) 연산 List 콜렉션으로 모으기: collectList() Flux는 데이터를 콜렉션으로 모을 수 있는 기능을 제공한다. 이 중에서 List로 모아주는 collectList()는 다음과 같이 사용한다. Mono&lt;List&lt;Integer&gt;&gt; mono = someFlux.collectList(); mono.subscribe(lst -&gt; System.out.println(lst)); collectList()의 리턴 타입..&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://javacan.tistory.com/500&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>aggregation</category>
<category>리액터</category>
<category>모으기</category>
<author>최범균 madvirus</author>
<guid>https://javacan.tistory.com/500</guid>
<comments>https://javacan.tistory.com/entry/Reactor-Start-8-Aggregation#entry500comment</comments>
<pubDate>Fri, 03 Aug 2018 15:41:47 +0900</pubDate>
</item>
<item>
<title>스프링 리액터 시작하기 7 - 병렬 실행</title>
<link>https://javacan.tistory.com/entry/Reactor-Start-7-Parallel</link>
<description>병렬(Parallel) 처리 시퀀스는 순차적으로 next 신호를 발생하고 Subscriber는 순차적으로 신호를 처리한다. 리액터는 시퀀스가 발생하는 next 신호를 병렬로 처리할 수 있는 방법을 제공한다. 이 글에서는 Flux의 parallel()을 사용하는 방법과 zip()을 이용한 방법에 대해 살펴본다. parallel()과 runOn()으로 Flux 병렬 처리하기 Flux#parallel()과 runOn()을 사용하면 Flux가 생성하는 ne..&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://javacan.tistory.com/499&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Reactive</category>
<category>ParallelFlux</category>
<category>리액터</category>
<category>병렬 실행</category>
<author>최범균 madvirus</author>
<guid>https://javacan.tistory.com/499</guid>
<comments>https://javacan.tistory.com/entry/Reactor-Start-7-Parallel#entry499comment</comments>
<pubDate>Fri, 03 Aug 2018 07:00:13 +0900</pubDate>
</item>
<item>
<title>스프링 리액터 시작하기 6 - 쓰레드 스케줄링</title>
<link>https://javacan.tistory.com/entry/Reactor-Start-6-Thread-Scheduling</link>
<description>리액터 쓰레드 스케줄링 리액터는 비동기 실행을 강제하지 않는다. 예를 들어 아래 코드를 보자. Flux.range(1, 3) .map(i -&gt; { logger.info(&quot;map {} to {}&quot;, i, i + 2); return i + 2; }) .flatMap(i -&gt; { logger.info(&quot;flatMap {} to Flux.range({}, {})&quot;, i, 1, i); return Flux.range(1, i); }) .subscribe(i ..&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://javacan.tistory.com/497&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Reactive</category>
<category>Flux.interval</category>
<category>scheduler</category>
<category>리액터</category>
<category>스케줄링</category>
<category>쓰레드</category>
<author>최범균 madvirus</author>
<guid>https://javacan.tistory.com/497</guid>
<comments>https://javacan.tistory.com/entry/Reactor-Start-6-Thread-Scheduling#entry497comment</comments>
<pubDate>Wed, 01 Aug 2018 17:01:47 +0900</pubDate>
</item>
<item>
<title>코틀린 인 액션 스터디 정리 자료</title>
<link>https://javacan.tistory.com/entry/Kotlin-in-action-study-summary</link>
<description>예전에 신림프로그래머 페이스북 그룹에서 진행한 &quot;코틀린 인 액션&quot; 책 스터디 정리한 자료       &lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://javacan.tistory.com/498&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Kotlin Scala Python</category>
<category>Kotlin</category>
<category>신린프로그래머</category>
<category>코틀린</category>
<author>최범균 madvirus</author>
<guid>https://javacan.tistory.com/498</guid>
<comments>https://javacan.tistory.com/entry/Kotlin-in-action-study-summary#entry498comment</comments>
<pubDate>Wed, 25 Jul 2018 08:39:35 +0900</pubDate>
</item>
<item>
<title>스프링 리액터 시작하기 5 - 에러 처리</title>
<link>https://javacan.tistory.com/entry/Reactor-Start-5-error-handling</link>
<description>에러 처리 시퀀스는 데이터를 발생하는 과정에서 에러를 발생할 수 있다. 리액터는 에러를 처리하는 여러 방법을 제공하는데 이 글에서는 레퍼런스 문서에서 언급하는 에러 처리 방법을 차례대로 살펴볼 것이다. 참고로 에러 신호는 종료 신호이다. 따라서 에러 신호가 발생하면 시퀀스는 종료되고 더 이상 데이터를 발생하지 않는다. 에러 신호 처리 에러 신호가 발생하면 Subscriber의 onError 메서드가 호출된다. 이 메서드를 구현한 Subscriber를..&lt;div style=&quot;text-align:left; padding-top:10px;clear:both&quot;&gt;
&lt;iframe src=&quot;//www.facebook.com/plugins/like.php?href=https://javacan.tistory.com/496&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
<category>Reactive</category>
<category>error</category>
<category>reactor</category>
<category>리액터</category>
<category>에러 처리</category>
<author>최범균 madvirus</author>
<guid>https://javacan.tistory.com/496</guid>
<comments>https://javacan.tistory.com/entry/Reactor-Start-5-error-handling#entry496comment</comments>
<pubDate>Mon, 23 Jul 2018 16:21:45 +0900</pubDate>
</item>
</channel>
</rss>