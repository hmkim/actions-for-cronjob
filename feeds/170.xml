<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="https://quarl894.github.io/atom.xml" rel="self" type="application/atom+xml" /><link href="https://quarl894.github.io/" rel="alternate" type="text/html" /><updated>2019-01-07T16:41:40+00:00</updated><id>https://quarl894.github.io/atom.xml</id><title type="html">YoungJung Blog</title><subtitle>Software Programmer</subtitle><author><name>김영중</name></author><entry><title type="html">Mvp 패턴 1 개념</title><link href="https://quarl894.github.io/articles/2019-01/MVP-%ED%8C%A8%ED%84%B4-1-%EA%B0%9C%EB%85%90" rel="alternate" type="text/html" title="Mvp 패턴   1 개념" /><published>2019-01-07T16:20:00+00:00</published><updated>2019-01-07T16:20:00+00:00</updated><id>https://quarl894.github.io/articles/2019-01/MVP%20%ED%8C%A8%ED%84%B4%20-%201%20%EA%B0%9C%EB%85%90</id><content type="html" xml:base="https://quarl894.github.io/articles/2019-01/MVP-%ED%8C%A8%ED%84%B4-1-%EA%B0%9C%EB%85%90">&lt;h3 id=&quot;개념&quot;&gt;[개념]&lt;/h3&gt;

&lt;p&gt;MVP 패턴은 Model-View-Presnet로 이루어진다.&lt;/p&gt;

&lt;p&gt;Model : 데이터 관리&lt;/p&gt;

&lt;p&gt;View : 화면 표현&lt;/p&gt;

&lt;p&gt;Presenter : Model 과 View를 연결시키는 다리 역할&lt;/p&gt;

&lt;p&gt;기본적으로 모든 데이터 관리는 Model, 모든 화면 표현은 View가 둘 사이를 이어주는 것은 Presenter가 수행함.&lt;/p&gt;

&lt;h3 id=&quot;간단-예시&quot;&gt;[간단 예시]&lt;/h3&gt;

&lt;p&gt;상황 : 검색 버튼을 누르면 화면에 이미지가 뜸&lt;/p&gt;

&lt;p&gt;사용자&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;검색 버튼을 클릭함&lt;/li&gt;
  &lt;li&gt;화면에 이미지가 뜸&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;앱&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;M, V, P 초기화 : 앱이 생성되면서 Model, View, Presenter가 생성되고 등록됨.&lt;/li&gt;
  &lt;li&gt;P -&amp;gt; V : Presenter에서 View에게 버튼을 그리라고 명령&lt;/li&gt;
  &lt;li&gt;V : 버튼을 그리고 대기&lt;/li&gt;
  &lt;li&gt;사용자가 버튼을 누름.&lt;/li&gt;
  &lt;li&gt;V -&amp;gt; P : View가 Presenter에게 버튼이 눌림을 알림.&lt;/li&gt;
  &lt;li&gt;P -&amp;gt; M : 검색해서 이미지를 가져오라고 명령.&lt;/li&gt;
  &lt;li&gt;M 동작 : 검색해서 이미지를 찾음.&lt;/li&gt;
  &lt;li&gt;M -&amp;gt; P : 검색한 이미지를 전달함.&lt;/li&gt;
  &lt;li&gt;p -&amp;gt; V : View에게 이미지를 전달하고 화면에 띄우라고 명령&lt;/li&gt;
  &lt;li&gt;V 동작 : 이미지를 화면에 띄움&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;각자의 일을 절대 침범하지 않음.&lt;/p&gt;

&lt;h3 id=&quot;mvc-vs-mvp&quot;&gt;[MVC vs MVP]&lt;/h3&gt;

&lt;p&gt;MVC는 Model - View - Controller로 이루어진 디자인 패턴입니다.&lt;/p&gt;

&lt;p&gt;Controller와 Presenter의 역할을 비슷하지만 다릅니다.&lt;/p&gt;

&lt;p&gt;MVC패턴은 사용자가 이벤트를 발생했을 때 Controller가 먼저 반응을 합니다.&lt;/p&gt;

&lt;p&gt;그 후 Model에게 데이터를 요청하고 맞는 View에게 반환합니다.&lt;/p&gt;

&lt;p&gt;MVP패턴은 사용자가 이벤트를 발생했을 때 View가 먼저 반응을 합니다.&lt;/p&gt;

&lt;p&gt;그 후 해당 이벤트를 담당하는 Presenter를 호출하고 Model의 작업을 받은 후 View에게 반환합니다.&lt;/p&gt;

&lt;p&gt;하지만 Android에서는 사용자 이벤트 반응이 View가 첫번째일수 밖에 없어 View가 곧 Controller역할도 수행해야 합니다.&lt;/p&gt;

&lt;p&gt;이 때문에, 각각의 책임을 분리시키지 못하고, 모듈화시키기가 어렵습니다.&lt;/p&gt;

&lt;h3 id=&quot;mvp를-써야하는-이유&quot;&gt;[MVP를 써야하는 이유]&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;코드를 모듈화 시킬 수 있다.&lt;/li&gt;
  &lt;li&gt;협업시에 기능별로 분리되어 있어 작업하기 수월하다.&lt;/li&gt;
  &lt;li&gt;유닛테스트 하기 용이하다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;참고자료&quot;&gt;참고자료&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://awesometic.tistory.com/32?category=964088&quot;&gt;MVP blog&lt;/a&gt;&lt;/p&gt;</content><author><name>김영중</name></author><category term="Android" /><summary type="html">[개념]</summary></entry><entry><title type="html">Android 상식알아가기</title><link href="https://quarl894.github.io/articles/2018-12/Android-%EC%83%81%EC%8B%9D%EC%95%8C%EC%95%84%EA%B0%80%EA%B8%B0" rel="alternate" type="text/html" title="Android 상식알아가기" /><published>2018-12-27T08:20:00+00:00</published><updated>2018-12-27T08:20:00+00:00</updated><id>https://quarl894.github.io/articles/2018-12/Android%20%EC%83%81%EC%8B%9D%EC%95%8C%EC%95%84%EA%B0%80%EA%B8%B0</id><content type="html" xml:base="https://quarl894.github.io/articles/2018-12/Android-%EC%83%81%EC%8B%9D%EC%95%8C%EC%95%84%EA%B0%80%EA%B8%B0">&lt;h3 id=&quot;개요&quot;&gt;[개요]&lt;/h3&gt;

&lt;p&gt;Android 개발을 하면서 자연스럽게 접하는 것들이 많습니다. 하지만, 왜 이렇게 쓰는지 그냥 넘기고 사용하는 것들이 많습니다. 이런것들은 하나씩 포스팅하여 알아가려고 합니다.&lt;/p&gt;

&lt;h2 id=&quot;dp-vs-sp&quot;&gt;DP vs SP&lt;/h2&gt;

&lt;p&gt;layout 개발시 TextView의 값을 디자이너는 dp로 줬는데 인터넷에서는 sp로 해야한다는 글을 볼 수 있습니다.
먼저, 글꼴은 sp로 주는 것이 일반적입니다.&lt;/p&gt;

&lt;p&gt;dp와 sp의 정의부터 알아봅시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://quarl894.github.io/assets/posts/20181227/dp_sp.png&quot; alt=&quot;dp_sp&quot; /&gt;&lt;/p&gt;

&lt;p&gt;dp와 sp는 화면의 크기에 따라 비율이 바뀝니다. 따라서, 다양한 기기 호환을 위해 px대신에 android에서 사용합니다.&lt;/p&gt;

&lt;p&gt;그럼 왜 글꼴은 sp냐?&lt;/p&gt;

&lt;p&gt;== sp는 System의 font설정에 따라 값이 변경됩니다. ==&lt;/p&gt;

&lt;p&gt;만약에 노인분들이나 저시각자를 위해 System상에서 Font를 크게 적용시켰다면 sp는 그에 맞게 대처합니다.&lt;/p&gt;

&lt;p&gt;하지만, dp는 화면의 크기에 따라 달라지지, font 설정은 영향을 미치지 않습니다.&lt;/p&gt;

&lt;p&gt;따라서, Font를 따로 설정을 안할경우 둘 사이에 차이점은 없습니다. 단, 우리는 대부분 Font를 커스텀하기 때문에 sp로 하는 것을 추천드립니다.&lt;/p&gt;</content><author><name>김영중</name></author><category term="Android, tip" /><summary type="html">[개요]</summary></entry><entry><title type="html">에라토스테네스의 체 외워야할 알고리즘</title><link href="https://quarl894.github.io/articles/2018-10/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98-%EC%B2%B4-%EC%99%B8%EC%9B%8C%EC%95%BC%ED%95%A0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98" rel="alternate" type="text/html" title="에라토스테네스의 체   외워야할 알고리즘" /><published>2018-10-01T16:20:00+00:00</published><updated>2018-10-01T16:20:00+00:00</updated><id>https://quarl894.github.io/articles/2018-10/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98%20%EC%B2%B4%20-%20%EC%99%B8%EC%9B%8C%EC%95%BC%ED%95%A0%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</id><content type="html" xml:base="https://quarl894.github.io/articles/2018-10/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98-%EC%B2%B4-%EC%99%B8%EC%9B%8C%EC%95%BC%ED%95%A0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">&lt;h3 id=&quot;소수-구하기&quot;&gt;[소수 구하기]&lt;/h3&gt;

&lt;p&gt;시간복잡도 : O(nloglongn)&lt;/p&gt;

&lt;h4 id=&quot;간략한-설명&quot;&gt;간략한 설명&lt;/h4&gt;

&lt;p&gt;2부터 자기자신을 제외한 배수를 지워나간다.
반복되면서 2,3,5,7 … 등의 자신만 나눠지는 소수만이 살아남게 된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Eratos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;prime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;prime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;prime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;prime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//true가 소수&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//해당 배수는 다 false&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;prime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;참고자료 : &lt;a href=&quot;http://&quot;&gt;https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4&lt;/a&gt;&lt;/p&gt;</content><author><name>김영중</name></author><category term="소수, 알고리즘" /><summary type="html">[소수 구하기]</summary></entry><entry><title type="html">허불허 어른을 위한 돼지 저금통</title><link href="https://quarl894.github.io/articles/2018-05/%ED%97%88%EB%B6%88%ED%97%88-%EC%96%B4%EB%A5%B8%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%8F%BC%EC%A7%80-%EC%A0%80%EA%B8%88%ED%86%B5" rel="alternate" type="text/html" title="허불허 어른을 위한 돼지 저금통" /><published>2018-05-27T06:20:00+00:00</published><updated>2018-05-27T06:20:00+00:00</updated><id>https://quarl894.github.io/articles/2018-05/%ED%97%88%EB%B6%88%ED%97%88-%EC%96%B4%EB%A5%B8%EC%9D%84%20%EC%9C%84%ED%95%9C%20%EB%8F%BC%EC%A7%80%20%EC%A0%80%EA%B8%88%ED%86%B5</id><content type="html" xml:base="https://quarl894.github.io/articles/2018-05/%ED%97%88%EB%B6%88%ED%97%88-%EC%96%B4%EB%A5%B8%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%8F%BC%EC%A7%80-%EC%A0%80%EA%B8%88%ED%86%B5">&lt;p&gt;&lt;img src=&quot;https://quarl894.github.io/assets/posts/20180527/img_huh.jpeg&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다운로드 링크 : &lt;a href=&quot;https://play.google.com/store/apps/details?id=youngjung.test.free&quot;&gt;허불허&lt;/a&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;설명&quot;&gt;[설명]&lt;/h3&gt;

&lt;p&gt;어릴 적에 모두 돼지 저금통에 저금을 해본 기억이 있으실 겁니다. 돼지 저금통은 많은 어린이들의 첫 경제 관념을 형성하는 것에 도움을 주고 있습니다. 그렇다면 어른을 위한 돼지 저금통은 없을까요? “허불허”는 모든 어른들이 가지고 있는 돼지 저금통에 한푼 두푼 모아 성취감을 느꼈던 아날로그적인 기억을 디지털화하였습니다. ‘목돈을 마련하는 것’과 ‘소비패턴을 파악하는 것’은 재테크의 첫 걸음이라고 할 수 있습니다. 이는 아주 단순하고 쉬운 두 가지 방법, ‘충동구매할 뻔한 것을 저금’하고, ‘카테고리 랭킹을 확인함’으로써 이룰 수 있습니다.&lt;/p&gt;

&lt;p&gt;“재테크.. 듣기만 해도 너무 복잡하고 어려워서 어떻게 시작해야할 지 모르겠어요..”
“매번 돈을 쓸 때 마다 똑똑한 소비인지 의심이 돼요.”&lt;/p&gt;

&lt;p&gt;이제 결제버튼을 누르기 전에 가볍게 “허불허” 하세요! 재미있게 허불허하면서 자연스럽게 소비패턴을 바꾸고 목표도 달성하는 자신을 발견하게 될 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;주요-기능&quot;&gt;[주요 기능]&lt;/h3&gt;

&lt;h4 id=&quot;의뢰하기&quot;&gt;의뢰하기&lt;/h4&gt;
&lt;p&gt;자신의 소비를 검증받기 위한 의뢰 영수증을 작성해보세요.&lt;/p&gt;

&lt;h4 id=&quot;의뢰서-평가&quot;&gt;의뢰서 평가&lt;/h4&gt;
&lt;p&gt;다른 사람들로부터 받은 의뢰서를 평가해주세요!&lt;/p&gt;

&lt;h4 id=&quot;레벨링-시스템&quot;&gt;레벨링 시스템&lt;/h4&gt;
&lt;p&gt;허불허를 사용하는 당신은 도장요정입니다. 앱을 사용하면 사용할 수록 도장요정이 더욱 똑똑해져요!&lt;/p&gt;

&lt;h4 id=&quot;재테크-정보&quot;&gt;재테크 정보&lt;/h4&gt;
&lt;p&gt;레벨에 따라 열리는 실전 재테크 정보와 함께 여러분의 첫 재테크를 완성해보세요!&lt;/p&gt;

&lt;h4 id=&quot;평가된-영수증-리스트&quot;&gt;평가된 영수증 리스트&lt;/h4&gt;
&lt;p&gt;다른 사람들이 평가해준 영수증들을 토대로 구매를 할지 말지 결정해보세요. 구매를 하지 않는다면 바로 저금하기를 눌러 금액을 누적시킬 수 있어요!&lt;/p&gt;

&lt;h4 id=&quot;마이페이지&quot;&gt;마이페이지&lt;/h4&gt;
&lt;p&gt;자신이 설정한 목표 대비 현재까지 모은 금액을 그래프로 확인 가능해요. 카테고리 랭킹을 통해 몰랐던 나의 소비패턴도 알 수 있어요!&lt;/p&gt;

&lt;h4 id=&quot;푸쉬알림-기능&quot;&gt;푸쉬알림 기능&lt;/h4&gt;
&lt;p&gt;의뢰서가 평가되면 자동으로 푸쉬 알림이 갑니다.&lt;/p&gt;

&lt;h3 id=&quot;사용-기술--라이브러리&quot;&gt;사용 기술 &amp;amp; 라이브러리&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Google Login API&lt;/li&gt;
  &lt;li&gt;Firebase RealtimeDataBase&lt;/li&gt;
  &lt;li&gt;Firebase Cloud functions&lt;/li&gt;
  &lt;li&gt;Firebase Cloud messaging&lt;/li&gt;
  &lt;li&gt;ahoy-onboarding libray&lt;/li&gt;
  &lt;li&gt;RecycerView&lt;/li&gt;
  &lt;li&gt;Calligraphy library&lt;/li&gt;
  &lt;li&gt;Circleindicator&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;-이-서비스를-개발한-사람들&quot;&gt;※ 이 서비스를 개발한 사람들&lt;/h4&gt;

&lt;p&gt;기획자 : 최다희&lt;/p&gt;

&lt;p&gt;디자이너 : 김지희&lt;/p&gt;

&lt;p&gt;개발자 : 김영중, 이상우, 편주영&lt;/p&gt;</content><author><name>김영중</name></author><category term="구글 플레이, 런칭" /><summary type="html"></summary></entry><entry><title type="html">Java &amp;amp; android 개발상식(1)</title><link href="https://quarl894.github.io/articles/2018-04/Java-&-Android-%EA%B0%9C%EB%B0%9C%EC%83%81%EC%8B%9D(1)" rel="alternate" type="text/html" title="Java &amp; android 개발상식(1)" /><published>2018-04-24T13:14:00+00:00</published><updated>2018-04-24T13:14:00+00:00</updated><id>https://quarl894.github.io/articles/2018-04/Java%20&amp;%20Android%20%EA%B0%9C%EB%B0%9C%EC%83%81%EC%8B%9D(1)</id><content type="html" xml:base="https://quarl894.github.io/articles/2018-04/Java-&amp;-Android-%EA%B0%9C%EB%B0%9C%EC%83%81%EC%8B%9D(1)">&lt;h2 id=&quot;안드로이드에서-enum-사용을-자제시킨-이유는&quot;&gt;안드로이드에서 Enum 사용을 자제시킨 이유는?&lt;/h2&gt;

&lt;p&gt;ENUM의 각 값은 객체이며 각 선언은 객체를 참조하기 위해 런타임 메모리를 사용합니다.&lt;/p&gt;

&lt;p&gt;따라서 ENUM 값은 Integer 또는 String 상수보다 많은 메모리를 사용합니다.&lt;/p&gt;

&lt;p&gt;단일 ENUM을 추가하면 최종 DEX 파일의 크기 가 증가합니다. 또한 런타임 오버 헤드 문제가 발생하고 응용 프로그램에 더 많은 공간이 필요합니다.&lt;/p&gt;

&lt;p&gt;Android에서 ENUM을 과도하게 사용하면 DEX 크기가 증가하고 런타임 메모리 할당 크기가 늘어납니다.&lt;/p&gt;

&lt;p&gt;응용 프로그램이 더 많은 ENUM을 사용하는 경우 ENUM 대신 정수 또는 문자열 상수를 사용하는 것이 좋습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://brunch.co.kr/@oemilk/94&quot;&gt;참고 사이트&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;string-객체-생성과-문자열-리터럴&quot;&gt;String 객체 생성과 문자열 리터럴&lt;/h2&gt;

&lt;h4 id=&quot;string-생성-방법&quot;&gt;String 생성 방법&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;new 연산자를 이용한 방식&lt;/li&gt;
  &lt;li&gt;리터럴을 이용한 방식&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1번 방식처럼 new 연산자를 사용하면 Heap 영역에 존재하게 되고 리터럴을 이용하면 String constant pool 영역에 존재하게 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;동작방식&quot;&gt;동작방식&lt;/h4&gt;

&lt;p&gt;리터럴로 선언하게 된 변수는 내부적으로 String의 intern() 메소드를 호출합니다. intern() 메소드는 주어진 문자열이 String constant pool에 있는지 검색 후 있다면 주소를 반환하고 없다면 String constant pool에 넣고 새로운 주소값을 반환하게 됩니다.&lt;/p&gt;

&lt;p&gt;밑의 코드에서 s3.intern()을 하게 되면 먼저 String constant pool에 저장되어있던 s1의 주소를 불러오게 되므로 s1==s3가 true를 반환하게 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;equal-메소드와-의-차이&quot;&gt;equal 메소드와 ==의 차이&lt;/h4&gt;

&lt;p&gt;equal은 문자열을 비교합니다. 주소가 아닌 내용을 비교하기 때문에 문자열이 같다면 true를 반환하게 됩니다.&lt;/p&gt;

&lt;p&gt;==은 주소를 비교합니다. 따라서, 문자열이 같아도 Heap영역에 있는 주소와 String constant pool에 있는 주소는 다르기 때문에 false를 반환하게 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//true&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//true&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//false&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//true&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;s3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;intern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//true&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;자바-어노테이션이란&quot;&gt;자바 어노테이션이란?&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;어노테이션은 본질적인 목적은 소스 코드에 메타데이터를 표현하는 것입니다. 단순히 부가적인 표현뿐만 아니라 리플렉션reflection을 이용하면 어노테이션 지정만으로도 원하는 클래스를 주입한다는지 하는 것이 가능합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;많이들 접한 @Override나 @SuppressWarningS 등 자바에서 기본으로 제공하는 어노테이션들이 있다.&lt;/p&gt;

&lt;p&gt;또한 Meta 어노테이션으로 메타 어노테이션을 이용하여 커스텀 어노테이션을 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://jdm.kr/blog/216&quot;&gt;자세한 내용&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;힙-메모리-영역과-스택-메모리-영역&quot;&gt;힙 메모리 영역과 스택 메모리 영역&lt;/h2&gt;

&lt;p&gt;프로그램이 시작되면 메모리 영역에 올라가게 됩니다. 메모리 영역에 올라온 프로그램들은 CPU의 명령을 통해서 실행되게 되는데 크게 4가지로 구분되어 메모리에 올라갑니다.&lt;/p&gt;

&lt;h4 id=&quot;코드-영역-code-segment&quot;&gt;코드 영역 (Code Segment)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;실제 프로그램 코드 자체가 적재되는 영역을 말합니다. C나 JAVA등의 개발 언어로 짜여진 프로그램은 컴퓨터가 이해할 수 있는 기계어의 형태로 컴파일 되어 파일 등에 저장되는데, 실제 이 파일의 프로그램에 대한 전체적인 코드 자체가 올라가는 영역입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로그램 자체 영역으로 보시면 됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;데이터-영역-data-segment&quot;&gt;데이터 영역 (Data Segment)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램이 실행되면서 필요한 변수가 저장되는 영역인데, 이 데이터 영역은 프로그램이 구동되는 동안 항상 접근 가능한 변수가 저장되는 영역이라고 생각하시면 됩니다. 즉, 전역 변수(Global Variables)와 정적 변수(Static Variables)를 위한 할당 공간입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;스택-영역-stack-segment&quot;&gt;스택 영역 (Stack Segment)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;함수(또는 메서드, 프로시져 등) 내에 정의된 지역 변수(Local Variables)가 저장되는 영역입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;스택의 구조를 활용하여 함수의 지역 변수 메모리를 관리하면 위의 메커니즘을 쉽게 구현할 수 있기 때문에 스택 형태로 영역을 만들어 활용하였고, 그리하여 스택 영역(스택 세그먼트)라 이름이 붙었습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;힙-영역-heap-segment&quot;&gt;힙 영역 (Heap Segment)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;힙 영역은 위에서 관리가 가능한 데이터 외에 다른 형태의 데이터를 관리하기 위한 빈 공간(Free Space)입니다. 어떤 형태의 데이터가 있을까요? 바로 동적 할당(Dynamic Allocation)을 통해 생성된 동적 변수(Dynamic Variables)를 관리하기 위한 영역입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;힙 영역은 위의 다른 영역(데이터, 스택 등)을 모두 할당하고 남은 공간입니다. (남은 공간이라하여 딱히 영역에 제한이 있거나 그런 것은 아니고, 시스템의 메모리 공간 여유에 따라서 달라집니다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Java 나 C++ 등에서 ‘new’ 를 통해, C에서 ‘malloc’, ‘calloc’ 등을 통해 동적으로 생성되는 변수를 저장하기 위해 할당되는 영역이라고 생각하시면 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;데이터 영역과 스택 영역은 컴파일러가 미리 공간을 예측하고 할당할 수 있지만, 동적 변수는 어느 시점에 어느 정도의 공간으로 할당 될지 정확하게 예측할 수 없기 때문에 프로그램 실행 중(Runtime)에 결정됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://quarl894.github.io/assets/posts/20180424/memory_img.png&quot; alt=&quot;메모리 영역&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://ooz.co.kr/244&quot;&gt;참조 사이트&lt;/a&gt;&lt;/p&gt;</content><author><name>김영중</name></author><category term="Android" /><summary type="html">안드로이드에서 Enum 사용을 자제시킨 이유는?</summary></entry><entry><title type="html">비트마스크 기초편</title><link href="https://quarl894.github.io/articles/2018-03/%EB%B9%84%ED%8A%B8%EB%A7%88%EC%8A%A4%ED%81%AC-%EA%B8%B0%EC%B4%88%ED%8E%B8" rel="alternate" type="text/html" title="비트마스크 기초편" /><published>2018-03-22T14:10:00+00:00</published><updated>2018-03-22T14:10:00+00:00</updated><id>https://quarl894.github.io/articles/2018-03/%EB%B9%84%ED%8A%B8%EB%A7%88%EC%8A%A4%ED%81%AC%20%EA%B8%B0%EC%B4%88%ED%8E%B8</id><content type="html" xml:base="https://quarl894.github.io/articles/2018-03/%EB%B9%84%ED%8A%B8%EB%A7%88%EC%8A%A4%ED%81%AC-%EA%B8%B0%EC%B4%88%ED%8E%B8">&lt;h2 id=&quot;어려운-비트마스크&quot;&gt;어려운 비트마스크&lt;/h2&gt;

&lt;p&gt;비트마스크는 알고리즘을 풀 때 간간히 필요합니다.&lt;/p&gt;

&lt;p&gt;비트마스크 없이는 못 푸는 문제를 점점 많이 접하게 되서 공부차 올립니다.&lt;/p&gt;

&lt;h2 id=&quot;비트마스크를-사용한-코드의-장점&quot;&gt;비트마스크를 사용한 코드의 장점&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;더 빠른 수행 시간&lt;/li&gt;
  &lt;li&gt;더 간결한 코드&lt;/li&gt;
  &lt;li&gt;더 작은 메모리 사용량&lt;/li&gt;
  &lt;li&gt;연관 배열을 배열로 대체 : boolean으로 체크하는 배열을 비트마스크를 써서 int[]로 나타낼 수 있다. 큰 시간과 메모리 차이를 불러온다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;비트마스크-사용법&quot;&gt;비트마스크 사용법&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;8개의 비트를 사용하고자 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;int bitmask를 비트마스크 변수로 선언한다.&lt;/p&gt;

&lt;p&gt;비트는 맨 오른쪽 비트가 0번 비트고 총 8개 비트면 0~7의 범위를 갖는다.&lt;/p&gt;

&lt;p&gt;bitmask 변수의 우측 8개 비트만 사용한다는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;비트 상태 0 : 꺼짐. 1 : 켜짐&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://quarl894.github.io/assets/posts/20180322/bitmask.png&quot; alt=&quot;bitmask&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이런식이 된다.&lt;/p&gt;

&lt;p&gt;배열로 표현한다면 idx[8]={1,2,4,8,16,32,64,128}; 이 된다.&lt;/p&gt;

&lt;p&gt;idx[n]==(1«n) 이다. 연산자 우선순위에 유의한다&lt;/p&gt;

&lt;h2 id=&quot;비트-기본-연산&quot;&gt;비트 기본 연산&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://quarl894.github.io/assets/posts/20180322/bitmask_1.png&quot; alt=&quot;비트연산&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;비트마스크-기본-문제&quot;&gt;비트마스크 기본 문제&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/12813&quot;&gt;이진수 연산&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/11723&quot;&gt;집합&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/11811&quot;&gt;데스스타&lt;/a&gt;&lt;/p&gt;</content><author><name>김영중</name></author><category term="비트마스크" /><summary type="html">어려운 비트마스크</summary></entry><entry><title type="html">It 직무 평가 시험</title><link href="https://quarl894.github.io/articles/2018-03/IT-%EC%A7%81%EB%AC%B4-%ED%8F%89%EA%B0%80-%EC%8B%9C%ED%97%98" rel="alternate" type="text/html" title="It 직무 평가 시험" /><published>2018-03-15T12:50:00+00:00</published><updated>2018-03-15T12:50:00+00:00</updated><id>https://quarl894.github.io/articles/2018-03/IT%20%EC%A7%81%EB%AC%B4%20%ED%8F%89%EA%B0%80%20%EC%8B%9C%ED%97%98</id><content type="html" xml:base="https://quarl894.github.io/articles/2018-03/IT-%EC%A7%81%EB%AC%B4-%ED%8F%89%EA%B0%80-%EC%8B%9C%ED%97%98">&lt;h2 id=&quot;시험-복원-문제-정리&quot;&gt;시험 복원 문제 정리&lt;/h2&gt;

&lt;p&gt;음…. 먼저 시험은 정처기와 비슷하게 나왔습니다. 정처기를 미리 공부했다면 잘 봤을텐데…ㅎㅎ&lt;/p&gt;

&lt;h2 id=&quot;데이터베이스&quot;&gt;데이터베이스&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;데이터베이스 특징 중 옳지 않은 것은?&lt;/li&gt;
  &lt;li&gt;스키마 종류 중 옳지 않은 것은?&lt;/li&gt;
  &lt;li&gt;트랜잭션 특성 중 옳지 않은 것은?&lt;/li&gt;
  &lt;li&gt;회복 기법 중 옳지 않은 것은?&lt;/li&gt;
  &lt;li&gt;그림 주어지고 후위 순회 시 옳은 것은?&lt;/li&gt;
  &lt;li&gt;데이터베이스 설계시 고려해야 할 사항 중 옳지 않은 것은?&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;전자계산기&quot;&gt;전자계산기&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;직접 주소지정방식에서 고려해야 할 사항이 아닌 것은?&lt;/li&gt;
  &lt;li&gt;Channel 의한 I/O 특징 중 옳지 않은 것은?(CPU와 관련하여 물어봄)&lt;/li&gt;
  &lt;li&gt;인터럽트 설명해주고 어떤 인터럽트인가?&lt;/li&gt;
  &lt;li&gt;메모리 인터리빙 특징&lt;/li&gt;
  &lt;li&gt;메모리 관리 하드웨어 MMU 특징 중 옳지 않은 것은?&lt;/li&gt;
  &lt;li&gt;가상메모리 특징 중 옳지 않은 것은?&lt;/li&gt;
  &lt;li&gt;MISD 설명주어지고 MISD 고르는 문제&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;운영체제&quot;&gt;운영체제&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;로더의 역할 중 옳지 않은 것은?&lt;/li&gt;
  &lt;li&gt;PCB에서 얻을 수 없는 정보는?&lt;/li&gt;
  &lt;li&gt;멀티 스레드 특징 중 옳지 않은 것은?&lt;/li&gt;
  &lt;li&gt;LRU가 무엇인가?&lt;/li&gt;
  &lt;li&gt;가상 기억장치 특징&lt;/li&gt;
  &lt;li&gt;스케줄링 중 하나 설명 주어지고 어떤 스케줄링인가?(SCAN)&lt;/li&gt;
  &lt;li&gt;직접 파일 특징 중 옳지 않은 것은?&lt;/li&gt;
  &lt;li&gt;커널 특징 중 옳지 않은 것은?&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소프트웨어-공학&quot;&gt;소프트웨어 공학&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;좋은 소프트웨어를 만들기 위해 고려해야할 사항이 아닌것은?&lt;/li&gt;
  &lt;li&gt;소프트웨어 프로젝트 개발 영역을 결정하는 주요 요소가 아닌것은?&lt;/li&gt;
  &lt;li&gt;HIPO 특징 중 옳지 않은 것은?&lt;/li&gt;
  &lt;li&gt;HIPO 종류 설명 중 옳지 않은 것은?&lt;/li&gt;
  &lt;li&gt;응집도와 결합도 관련 문제 (응집도는 높을수록 좋음. 결합도는 낮을수록 좋음)&lt;/li&gt;
  &lt;li&gt;화이트 박스와 블랙 박스 테스트 구분 문제&lt;/li&gt;
  &lt;li&gt;다형성? 영어로 설명주어지고 답 찾는 문제&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;데이터-통신&quot;&gt;데이터 통신&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;다중 접속 방식 설명 주어지고 찾는 문제&lt;/li&gt;
  &lt;li&gt;네트워크 관련장비 특징 중 해당하는 것 찾기(리피터,라우터,스위치, 게이트웨이)&lt;/li&gt;
  &lt;li&gt;DSU가 무엇인지&lt;/li&gt;
  &lt;li&gt;프레임구조에서 프레임 종류를 알 수 있는 곳은?&lt;/li&gt;
  &lt;li&gt;경로 설정 방식 설명 주어지고 해당하는 방식 찾기&lt;/li&gt;
  &lt;li&gt;망 특징 주어지고 해당하는 망 형태 찾기&lt;/li&gt;
  &lt;li&gt;CSMA/CD 특징&lt;/li&gt;
&lt;/ol&gt;</content><author><name>김영중</name></author><category term="직무평가시험" /><summary type="html">시험 복원 문제 정리</summary></entry><entry><title type="html">It 직무 평가 시헙 답 정리</title><link href="https://quarl894.github.io/articles/2018-03/IT-%EC%A7%81%EB%AC%B4-%ED%8F%89%EA%B0%80-%EC%8B%9C%ED%97%99-%EB%8B%B5-%EC%A0%95%EB%A6%AC" rel="alternate" type="text/html" title="It 직무 평가 시헙 답 정리" /><published>2018-03-15T12:50:00+00:00</published><updated>2018-03-15T12:50:00+00:00</updated><id>https://quarl894.github.io/articles/2018-03/IT%20%EC%A7%81%EB%AC%B4%20%ED%8F%89%EA%B0%80%20%EC%8B%9C%ED%97%99%20%EB%8B%B5%20%EC%A0%95%EB%A6%AC</id><content type="html" xml:base="https://quarl894.github.io/articles/2018-03/IT-%EC%A7%81%EB%AC%B4-%ED%8F%89%EA%B0%80-%EC%8B%9C%ED%97%99-%EB%8B%B5-%EC%A0%95%EB%A6%AC">&lt;h2 id=&quot;중요도에-따른-설명-추가&quot;&gt;중요도에 따른 설명 추가&lt;/h2&gt;

&lt;p&gt;시험 외 중요하다 생각하는 것들 추가&lt;/p&gt;

&lt;h2 id=&quot;데이터베이스&quot;&gt;데이터베이스&lt;/h2&gt;

&lt;h4 id=&quot;데이터베이스-특징-중-옳지-않은-것은&quot;&gt;데이터베이스 특징 중 옳지 않은 것은?&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 실시간 접근성, 동시 공유, 계속적인 변화, 내용에 의한 참조&lt;/p&gt;

&lt;h4 id=&quot;스키마-종류-중-옳지-않은-것은&quot;&gt;스키마 종류 중 옳지 않은 것은?&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 외부 스키마(사용자 관점), 개념 스키마(조직이나 기관 관점), 내부 스키마(물리적 관점)&lt;/p&gt;

&lt;h4 id=&quot;트랜잭션-특성-중-옳지-않은-것은&quot;&gt;트랜잭션 특성 중 옳지 않은 것은?&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 원자성, 일관성, 영속성, 독립성&lt;/p&gt;

&lt;h4 id=&quot;회복-기법-중-옳지-않은-것은&quot;&gt;회복 기법 중 옳지 않은 것은?&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 그림자 페이지 교체, 연기 갱신, 즉각 갱신, 검사점&lt;/p&gt;

&lt;p&gt;-&amp;gt; 그림 주어지고 후위 순회 시 옳은 것은?&lt;/p&gt;

&lt;h4 id=&quot;데이터베이스-설계시-고려해야-할-사항-중-옳지-않은-것은&quot;&gt;데이터베이스 설계시 고려해야 할 사항 중 옳지 않은 것은?&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 하드웨어 성능&lt;/p&gt;

&lt;h4 id=&quot;데이터-모델의-구성-3요소&quot;&gt;데이터 모델의 구성 3요소&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 구조, 연산, 제약조건&lt;/p&gt;

&lt;h4 id=&quot;분산-데이터-베이스-제공하는-4가지-투명성&quot;&gt;분산 데이터 베이스 제공하는 4가지 투명성&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 위치, 중복, 병행, 장애&lt;/p&gt;

&lt;h4 id=&quot;병행-기법-종류&quot;&gt;병행 기법 종류&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 타임스탬프, 로킹, 낙관적 기법&lt;/p&gt;

&lt;h2 id=&quot;전자계산기&quot;&gt;전자계산기&lt;/h2&gt;

&lt;h4 id=&quot;channel-의한-io-특징-중-옳지-않은-것은cpu와-관련하여-물어봄&quot;&gt;Channel 의한 I/O 특징 중 옳지 않은 것은?(CPU와 관련하여 물어봄)&lt;/h4&gt;

&lt;p&gt;-&amp;gt; CPU 관여 없이 입출력 수행, CPU와 독립적인 처리가 이뤄짐, 자체적으로 코드 수정 가능, 명령어 구성요소에 속도와는 관련없다,&lt;/p&gt;

&lt;h4 id=&quot;인터럽트-설명해주고-어떤-인터럽트인가&quot;&gt;인터럽트 설명해주고 어떤 인터럽트인가?&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 외부: 기계 장애, 내부: 명령어 오작동, SVC 시스템 호출 : 사용자가 의도적으로 호출한 경우&lt;/p&gt;

&lt;h4 id=&quot;메모리-인터리빙-특징&quot;&gt;메모리 인터리빙 특징&lt;/h4&gt;

&lt;p&gt;-&amp;gt; Instruction의 빠른 처리 속도를 위해 중앙처리장치의 속도와 기억장치의 속도를 유효 Cycle 동안 병행 실행.&lt;/p&gt;

&lt;p&gt;-&amp;gt; 기억장치 모듈에 순차적으로 번갈아가면서 접근(저장 공간 확대X)&lt;/p&gt;

&lt;p&gt;-&amp;gt; 데이터를 디스크에 분산 저장&lt;/p&gt;

&lt;p&gt;-&amp;gt; 연속된 위치를 서로 다른 뱅크로 구성하여 하나의 주소를 통하여 여러 개의 주소를 동시에 접근&lt;/p&gt;

&lt;p&gt;-&amp;gt; 모듈 수 만큼 데이터 양에 해당하는 워드의 수를 동시에 읽을 수 있음.&lt;/p&gt;

&lt;p&gt;-&amp;gt; 중앙처리 장치와 기억장치 사이에 실질적인 대역폭을 늘리기 위한 방법으로 사용&lt;/p&gt;

&lt;h4 id=&quot;메모리-관리-하드웨어-mmu-특징-중-옳지-않은-것은&quot;&gt;메모리 관리 하드웨어 MMU 특징 중 옳지 않은 것은?&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 논리 주소를 물리 주소로 변환&lt;/p&gt;

&lt;p&gt;-&amp;gt; 허용되지 않는 메모리 접근을 방지&lt;/p&gt;

&lt;p&gt;-&amp;gt; 메모리 동적 재배치&lt;/p&gt;

&lt;p&gt;-&amp;gt; 가상 주소 공간을 물리 주소 공간으로 변환(압축X)&lt;/p&gt;

&lt;h4 id=&quot;가상메모리-특징-중-옳지-않은-것은&quot;&gt;가상메모리 특징 중 옳지 않은 것은?&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 가상 기억장치의 목적은 주기억장치의 용량 확보(속도 개선X)&lt;/p&gt;

&lt;h4 id=&quot;misd-설명주어지고-misd-고르는-문제&quot;&gt;MISD 설명주어지고 MISD 고르는 문제&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 다중 명령어, 단일 데이터 흐름&lt;/p&gt;

&lt;h2 id=&quot;운영체제&quot;&gt;운영체제&lt;/h2&gt;

&lt;h4 id=&quot;로더의-역할-중-옳지-않은-것은&quot;&gt;로더의 역할 중 옳지 않은 것은?&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 할당, 연결, 재배치, 적재&lt;/p&gt;

&lt;h4 id=&quot;pcb에서-얻을-수-없는-정보는있는-거-외우기&quot;&gt;PCB에서 얻을 수 없는 정보는?(있는 거 외우기)&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 프로세스 상태, 프로그램 카운터, 우선순위, 레지스터 보관 장소, 고유 구별자, 부모/자식 프로세스에 대한 포인터&lt;/p&gt;

&lt;h4 id=&quot;멀티-스레드-특징-중-옳지-않은-것은&quot;&gt;멀티 스레드 특징 중 옳지 않은 것은?&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 병행성 증진, 프로세스 내부에만 존재, 서로 독립적 다중 수행 가능&lt;/p&gt;

&lt;h4 id=&quot;lru가-무엇인가&quot;&gt;LRU가 무엇인가?&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 가장 오랫동안 사용되지 않은 페이지 교체&lt;/p&gt;

&lt;h4 id=&quot;가상-기억장치-특징&quot;&gt;가상 기억장치 특징&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 가상 기억장치의 주소를 주 기억장치의 주소로 바꾸는 주소 매핑 필요&lt;/p&gt;

&lt;h4 id=&quot;스케줄링-중-하나-설명-주어지고-어떤-스케줄링인가scan&quot;&gt;스케줄링 중 하나 설명 주어지고 어떤 스케줄링인가?(SCAN)&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 진행 방향상 가장 짧은 거리에 있는 작업 먼저 실시&lt;/p&gt;

&lt;h4 id=&quot;직접-파일-특징-중-옳지-않은-것은&quot;&gt;직접 파일 특징 중 옳지 않은 것은?&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 레코드는 해싱 함수에 의해 계산된 물리적 주소를 통해 직접 접근 가능&lt;/p&gt;

&lt;p&gt;-&amp;gt; 물리적 구조에 대한 지식 필요&lt;/p&gt;

&lt;p&gt;-&amp;gt; 판독이나 순서에 제약이 없음&lt;/p&gt;

&lt;h4 id=&quot;커널-특징-중-옳지-않은-것은&quot;&gt;커널 특징 중 옳지 않은 것은?&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 하드웨어를 보호(캡슐화), 주기억장치에 상주, 프로세스 관리, 기억장치 관리, 입출력 관리&lt;/p&gt;

&lt;h2 id=&quot;소프트웨어-공학&quot;&gt;소프트웨어 공학&lt;/h2&gt;

&lt;h4 id=&quot;좋은-소프트웨어를-만들기-위해-고려해야할-사항이-아닌것은&quot;&gt;좋은 소프트웨어를 만들기 위해 고려해야할 사항이 아닌것은?&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 비용 X&lt;/p&gt;

&lt;h4 id=&quot;소프트웨어-프로젝트-개발-영역을-결정하는-주요-요소가-아닌것은&quot;&gt;소프트웨어 프로젝트 개발 영역을 결정하는 주요 요소가 아닌것은?&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 기능, 성능, 제약 조건, 인터페이스, 신뢰도&lt;/p&gt;

&lt;h4 id=&quot;hipo-특징-중-옳지-않은-것은&quot;&gt;HIPO 특징 중 옳지 않은 것은?&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 하향식 소프트웨어 개발 문서화 도구&lt;/p&gt;

&lt;p&gt;-&amp;gt; 인터페이스를 계층구조로 표현한 도형&lt;/p&gt;

&lt;h4 id=&quot;hipo-종류-설명-중-옳지-않은-것은&quot;&gt;HIPO 종류 설명 중 옳지 않은 것은?&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 가시적 도표 : 전체적인 기능과 흐름을 보여줌&lt;/p&gt;

&lt;p&gt;-&amp;gt; 총체적 도표 : 입력,처리,출력에 대한 전반적인 정보 제공&lt;/p&gt;

&lt;p&gt;-&amp;gt; 세부적 도표 : 가시적 도표에 표시된 기능을 구성하는 기본 요소를 상세히 기술&lt;/p&gt;

&lt;h4 id=&quot;응집도와-결합도-관련-문제-응집도는-높을수록-좋음-결합도는-낮을수록-좋음&quot;&gt;응집도와 결합도 관련 문제 (응집도는 높을수록 좋음. 결합도는 낮을수록 좋음)&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 응집도 높고 결합도 낮게&lt;/p&gt;

&lt;h4 id=&quot;화이트-박스와-블랙-박스-테스트-구분-문제&quot;&gt;화이트 박스와 블랙 박스 테스트 구분 문제&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 화이트 박스 : 기초 경로, 조건, 루프, 데이터 흐름&lt;/p&gt;

&lt;p&gt;-&amp;gt; 블랙 박스 : 동치 분할, 경계값, 원인-효과, 오류 예측, 비교 검사&lt;/p&gt;

&lt;h4 id=&quot;다형성-영어로-설명주어지고-답-찾는-문제&quot;&gt;다형성? 영어로 설명주어지고 답 찾는 문제&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 하나의 메시지에 여러가지 응답&lt;/p&gt;

&lt;h2 id=&quot;데이터-통신&quot;&gt;데이터 통신&lt;/h2&gt;

&lt;h4 id=&quot;다중-접속-방식-설명-주어지고-찾는-문제&quot;&gt;다중 접속 방식 설명 주어지고 찾는 문제&lt;/h4&gt;

&lt;p&gt;-&amp;gt; FDMA : 주파수 분할&lt;/p&gt;

&lt;p&gt;-&amp;gt; TDMA : 시간 분할&lt;/p&gt;

&lt;p&gt;-&amp;gt; CDMA : 주파수 +시간 분할&lt;/p&gt;

&lt;h4 id=&quot;네트워크-관련장비-특징-중-해당하는-것-찾기리피터라우터스위치-게이트웨이&quot;&gt;네트워크 관련장비 특징 중 해당하는 것 찾기(리피터,라우터,스위치, 게이트웨이)&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 브리지 : 데이터 링크 계층 장비&lt;/p&gt;

&lt;p&gt;-&amp;gt; 라우터 : 경로 설정&lt;/p&gt;

&lt;p&gt;-&amp;gt; 게이트웨이 : 다른 네트워크 연결, 형식 변환&lt;/p&gt;

&lt;h4 id=&quot;dsu가-무엇인지&quot;&gt;DSU가 무엇인지&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 신호의 변조없이 단지 유니폴라 신호를 바이폴라 신호로 변환&lt;/p&gt;

&lt;h4 id=&quot;프레임구조에서-프레임-종류를-알-수-있는-곳은&quot;&gt;프레임구조에서 프레임 종류를 알 수 있는 곳은?&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 제어부&lt;/p&gt;

&lt;p&gt;-&amp;gt; 구조: 플래그 - 주소부 - 제어부 - 정보부 - FCS(오류검출) -플래그&lt;/p&gt;

&lt;h4 id=&quot;경로-설정-방식-설명-주어지고-해당하는-방식-찾기&quot;&gt;경로 설정 방식 설명 주어지고 해당하는 방식 찾기&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 고정 : 미리 분석해서 경로를 미리 지정해놓는 방식&lt;/p&gt;

&lt;p&gt;-&amp;gt; 적응 : 전송 경로를 동적으로 결정&lt;/p&gt;

&lt;p&gt;-&amp;gt; 범람 : 각 노드에 들어오는 패킷을 도착된 링크를 제외한 다른 모든 링크로 복사하여 전송&lt;/p&gt;

&lt;h4 id=&quot;망-특징-주어지고-해당하는-망-형태-찾기&quot;&gt;망 특징 주어지고 해당하는 망 형태 찾기&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 버스형 : 한 개의 통신회선&lt;/p&gt;

&lt;h4 id=&quot;csmacd-특징&quot;&gt;CSMA/CD 특징&lt;/h4&gt;

&lt;p&gt;-&amp;gt; 자유 경쟁, 버스형, 계층형에서 이용, 일정 길이 이하 충돌 검출 못함, 전송량이 적을 때 효율적, 충돌 감지 시 전체에게 알림.&lt;/p&gt;</content><author><name>김영중</name></author><category term="직무평가시험답" /><summary type="html">중요도에 따른 설명 추가</summary></entry><entry><title type="html">코딩 잘하는법</title><link href="https://quarl894.github.io/articles/2018-02/%EC%BD%94%EB%94%A9-%EC%9E%98%ED%95%98%EB%8A%94%EB%B2%95" rel="alternate" type="text/html" title="코딩 잘하는법" /><published>2018-02-23T13:20:00+00:00</published><updated>2018-02-23T13:20:00+00:00</updated><id>https://quarl894.github.io/articles/2018-02/%EC%BD%94%EB%94%A9%20%EC%9E%98%ED%95%98%EB%8A%94%EB%B2%95</id><content type="html" xml:base="https://quarl894.github.io/articles/2018-02/%EC%BD%94%EB%94%A9-%EC%9E%98%ED%95%98%EB%8A%94%EB%B2%95">&lt;h2 id=&quot;코딩-잘하는-법&quot;&gt;코딩 잘하는 법&lt;/h2&gt;

&lt;p&gt;알고 계시다면 댓글로 알려주세요 제발요…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://quarl894.github.io/assets/posts/20180223/cry.jpg&quot; alt=&quot;cry&quot; /&gt;&lt;/p&gt;</content><author><name>김영중</name></author><category term="코딩" /><summary type="html">코딩 잘하는 법</summary></entry><entry><title type="html">Study cs 10일차(네트워크)</title><link href="https://quarl894.github.io/articles/2018-02/Study-CS-10%EC%9D%BC%EC%B0%A8(%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)" rel="alternate" type="text/html" title="Study cs 10일차(네트워크)" /><published>2018-02-19T13:20:00+00:00</published><updated>2018-02-19T13:20:00+00:00</updated><id>https://quarl894.github.io/articles/2018-02/Study%20CS%2010%EC%9D%BC%EC%B0%A8(%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)</id><content type="html" xml:base="https://quarl894.github.io/articles/2018-02/Study-CS-10%EC%9D%BC%EC%B0%A8(%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)">&lt;h2 id=&quot;get-vs-post&quot;&gt;GET VS POST&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://quarl894.github.io/assets/posts/20180219/get_post.jpg&quot; alt=&quot;GET&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;tcp-vs-udp&quot;&gt;TCP VS UDP&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://quarl894.github.io/assets/posts/20180219/tcp_udp.png&quot; alt=&quot;TCP&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-way-handshake-를-사용하는-이유는&quot;&gt;3-way-handshake 를 사용하는 이유는?&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Client -&amp;gt; Server에게 존재 및 준비 완료&lt;/li&gt;
  &lt;li&gt;Server -&amp;gt; Client 패킷 받을 준비 완료&lt;/li&gt;
  &lt;li&gt;준비 완료되면 보냄&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;CLinet, Server 둘다 존재를 알리고 패킷을 보낼 수 있다는 신호를 보내야 되기 대문에 2-way로는 부족하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;http의-문제점&quot;&gt;HTTP의 문제점&lt;/h2&gt;

&lt;p&gt;HTTP는 평문 통신이기 때문에 도청이 가능하다.&lt;/p&gt;

&lt;p&gt;통신 상대를 확인하지 않기 때문에 위장이 가능하다.&lt;/p&gt;

&lt;p&gt;완전성을 증명할 수 없기 때문에 변조가 가능하다.&lt;/p&gt;

&lt;h3 id=&quot;tcpip-보안-방법&quot;&gt;TCP/IP 보안 방법&lt;/h3&gt;

&lt;h4 id=&quot;통신-자체를-암호화&quot;&gt;통신 자체를 암호화&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;SSL(Secure Socket Layer) or TLS(Transport Layer Security)라는 다른 프로토콜을 조합함으로써 HTTP의 통신 내용을 암호화할 수 있다. SSL을 조합한 HTTP를 HTTPS(HTTP Secure) or HTTP over SSL이라고 부른다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;콘텐츠를-암호화&quot;&gt;콘텐츠를 암호화&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;말 그대로 HTTP를 사용해서 운반하는 내용인, HTTP 메시지에 포함되는 콘텐츠만 암호화하는 것이다. 암호화해서 전송하면 받은 측에서는 그 암호를 해독하여 출력하는 처리가 필요하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;dns-round-robin-방식의-문제점&quot;&gt;DNS Round Robin 방식의 문제점&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1.서버의 수 만큼 공인 IP 주소가 필요함&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;부하 분산을 위해 서버의 대수를 늘리기 위해서는 그 만큼의 공인 IP가 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.균등하게 분산되지 않음&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;모바일 사이트 등에서 문제가 될 수 있는데, 스마트폰의 접속은 캐리어 게이트웨이 라고 하는 프록시 서버를 경유 한다. 프록시 서버에서는 이름변환 결과가 일정 시간 동안 캐싱되므로 같은 프록시 서버를 경유 하는 접속은 항상 같은 서버로 접속된다. 또한 PC용 웹 브라우저도 DNS 질의 결과를 캐싱하기 때문에 균등하게 부하분산 되지 않는다. DNS 레코드의 TTL 값을 짧게 설정함으로써 어느 정도 해소가 되지만, TTL에 따라 캐시를 해제하는 것은 아니므로 반드시 주의가 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.서버가 다운되도 확인 불가&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DNS 서버는 웹 서버의 부하나 접속 수 등의 상황에 따라 질의결과를 제어할 수 없다. 웹 서버의 부하가 높아서 응답이 느려지거나 접속수가 꽉 차서 접속을 처리할 수 없는 상황인 지를 전혀 감지할 수가 없기 때문에 어떤 원인으로 다운되더라도 이를 검출하지 못하고 유저들에게 제공한다. 이때문에 유저들은 간혹 다운된 서버로 연결이 되기도 한다. DNS 라운드 로빈은 어디까지나 부하분산 을 위한 방법이지 다중화 방법은 아니므로 다른 S/W와 조합해서 관리할 필요가 있다.&lt;/p&gt;

&lt;h2 id=&quot;방화벽-캐시서버가-하는-역할은&quot;&gt;방화벽 캐시서버가 하는 역할은?&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;패킷은 인터넷 핵심부를 통과하여 웹 서버측의 LAN에 도착한다.&lt;/li&gt;
  &lt;li&gt;기다리고 있던 방화벽이 도착한 패킷을 검사한다.&lt;/li&gt;
  &lt;li&gt;패킷이 웹 서버까지 가야하는지 가지 않아도 되는지를 판단하는 캐시서버가 존재한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;굳이 서버까지 가지 않아도 되는 경우를 골라낸다.
액세스한 페이지의 데이터가 캐시서버에 있으면 웹 서버에 의뢰하지 않고 바로 그 값을 읽을 수 있다. 페이지의 데이터 중에 다시 이용할 수 있는 것이 있으면 캐시 서버에 저장된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;주소창에-특정-url-값을-입력시-브라우저-내에선-어떤일이-일어나는가&quot;&gt;주소창에 특정 URL 값을 입력시 브라우저 내에선 어떤일이 일어나는가?&lt;/h2&gt;

&lt;p&gt;1.url에 입력된 값을 브라우저 내부에서 결정된 규칙에 따라 그 의미를 조사한다.&lt;/p&gt;

&lt;p&gt;2.조사된 의미에 따라 Request 메시지를 만든다.&lt;/p&gt;

&lt;p&gt;3.만들어진 메시지를 웹 서버로 전송한다.&lt;/p&gt;</content><author><name>김영중</name></author><category term="네트워크" /><summary type="html">GET VS POST</summary></entry></feed>