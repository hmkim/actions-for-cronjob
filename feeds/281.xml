<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Huns.me</title>
	<atom:link href="http://huns.me/feed" rel="self" type="application/rss+xml" />
	<link>https://huns.me</link>
	<description>김코딩님이 코딩 잘하고 싶어서 만든 블로그</description>
	<lastBuildDate>
	Sat, 11 May 2019 05:42:02 +0000	</lastBuildDate>
	<language>ko-KR</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.1.1</generator>
	<item>
		<title>CORS 실패 시, 응답 개체의 status는 왜 0일까?</title>
		<link>https://huns.me/development/2297</link>
				<comments>https://huns.me/development/2297#comments</comments>
				<pubDate>Sat, 11 May 2019 05:42:00 +0000</pubDate>
		<dc:creator><![CDATA[개발왕 김코딩]]></dc:creator>
				<category><![CDATA[개발 이야기]]></category>

		<guid isPermaLink="false">https://huns.me/?p=2297</guid>
				<description><![CDATA[<a href="https://huns.me/development/2297" class="more_link more_link_dots"> &#8230; </a>]]></description>
								<content:encoded><![CDATA[
<h2><strong>문제를 만나다</strong></h2>



<p>클라이언트의 도메인과 서버의 도메인이 서로 다른 경우, 브라우저는 크로스 도메인(Cross Domain) 보안 정책에 따라 요청을 차단한다. 이 상황을 우회하는 <a href="https://huns.me/development/1291" target="_blank" rel="noreferrer noopener">몇 가지 해법</a>이 있는데, 스마트에디터 원은 주로 CORS를 이용하고 있다. 최근에 네이버 지식인에 스마트에디터 원을 적용하다가 CORS 정책을 위반하는 상황을 만났는데, 아래의 스크린은 이 상황을 보여준다.</p>



<figure class="wp-block-image"><a href="https://blog.naver.com/PostView.nhn?blogId=jukrang&amp;Redirect=View&amp;logNo=221534914187&amp;categoryNo=11&amp;isAfterWrite=true#"><img src="https://postfiles.pstatic.net/MjAxOTA1MDJfMjcw/MDAxNTU2NzY0MTA2ODI0.vhlN7YKhFGH0_Van0FuiPs1PQqjdaSBOD5nIIliGViQg.dRNvw8YfqYjROXfj7JSeYn5mpg2Arag_f8d2w484Dmog.PNG.jukrang/SE-13e1dd27-78db-4010-ba17-c139b6350438.png?type=w773" alt=""/></a></figure>



<p>개발하는 도중에 종종 만나는 상황이라 그리 놀랄 일은 아니다. 서버 측에서 응답 헤더의 속성 중, Access-Control-Allow-Origin에 접근을 허용하는 클라이언트의 도메인을 넣어주면 끝이다.</p>



<p>그런데 네트워크 요청에 대한 응답으로 에러를 전달받은 경우에 안내 메시지를 화면에 노출하도록 처리하고 있음에도 아무런 메시지를 노출하지 않는 것이 마음에 걸렸다. 원인을 찾아서 조금 더 상황을 들여다보다가 재미있는 점을 발견했다. 분명 에러 상황인데 응답 상태 코드(Status Code)가 200이네? 물론 Response의 Header에는 Status가 없지만.</p>



<figure class="wp-block-image"><a href="https://blog.naver.com/PostView.nhn?blogId=jukrang&amp;Redirect=View&amp;logNo=221534914187&amp;categoryNo=11&amp;isAfterWrite=true#"><img src="https://postfiles.pstatic.net/MjAxOTA1MDJfMjgx/MDAxNTU2NzY0MTU3ODEz.61lgX4400iL_INdM51OVob8V4zgoTAhzrTVZN2D5kdcg.sXJLsrVTCswBb3dx7uxFrVzrnAIcJIPt9a7cAi8laFcg.PNG.jukrang/SE-c84a1804-fd68-4f1f-85fa-e5d8a529d47a.png?type=w773" alt=""/></a></figure>



<p>더군다나 응답 결과로 만들어진 Response 개체의 status 값은 0이다. 뭘까&#8230; 이 부조화한 상황은.</p>



<figure class="wp-block-image"><a href="https://blog.naver.com/PostView.nhn?blogId=jukrang&amp;Redirect=View&amp;logNo=221534914187&amp;categoryNo=11&amp;isAfterWrite=true#"><img src="https://postfiles.pstatic.net/MjAxOTA1MDJfNTcg/MDAxNTU2NzY0MDQ0ODMz.0jbjQoJsALvuCzrRZrGhg5Q1bd5cDpXYqNzxJcOrSuog.KowmwDg5kwQZpk1G29MFcO4auYrixl_6YXbtb-FJJAkg.PNG.jukrang/%EC%B2%A8%EB%B6%803.png?type=w773" alt=""/></a></figure>



<p>응답 개체의 status가 에러를 표현(401, 404, 500과 같은) 하는 경우에만 대응하도록 코드를 작성하였기에 status가 0인 상황은 제대로 대응하지 못한 셈이다. 조건이야 추가하면 그만인데, 이런 결과가 만들어진 이유가 궁금했고, 밀려오는 호기심을 견디지 못해 스펙을 뒤지기 시작했다.</p>



<h2><strong>스펙에서 답을 찾다</strong></h2>



<p>브라우저에서 서버로 HTTP 요청을 보낼 때, 우리는 XMLHttpRequest나 Fetch API를 주로 이용한다.</p>



<pre class="crayon-plain-tag">/* XHR 개체를 이용하는 과거 방식 */
const request = new XMLHttpRequest();
request.open(&quot;GET&quot;, &quot;http://www.example.org/example.txt&quot;);
request.send();</pre>



<pre class="crayon-plain-tag">/* Fetch API를 이용하는 새로운 방식 */
const myRequest = new Request('http://localhost/flowers.jpg');

fetch(myRequest)
  .then(response =&gt; response.blob())
  .then(blob =&gt; {
    myImage.src = URL.createObjectURL(blob);
  });</pre>



<p>그 어떤 방식을 이용하든, 브라우저는 서버로 요청을 전송할 때 요청의 유형을 판단하여 요청 개체의 mode라는 프로퍼티에 담아 전달한다.  Fetch API 스펙은 총 다섯 개의 mode를 정의한다. 다양한 요청을 몇 가지로 유형화하여 이후의 처리 과정을 추상화하기 위해서 만든 설정으로 보인다.</p>



<blockquote style="text-align:left" class="wp-block-quote"><p><strong>&#8220;same-origin</strong>&#8220;</p><p>Used to ensure requests are made to same-origin URLs. Fetch will return a network error if the request is not made to a same-origin URL.</p><p></p><p><strong>&#8220;cors&#8221;</strong></p><p>Makes the request a CORS request. Fetch will return a network error if the requested resource does not understand the CORS protocol.</p><p></p><p><strong>&#8220;no-cors&#8221;</strong></p><p>Restricts requests to using CORS-safelisted methods and CORS-safelisted request-headers. Upon success, fetch will return an opaque filtered response.</p><p></p><p><strong>&#8220;navigate&#8221;</strong></p><p>This is a special mode used only when navigating between documents.</p><p></p><p><strong>&#8220;websocket&#8221;</strong></p><p>This is a special mode used only when establishing a WebSocket connection. Even though the default request mode is &#8220;no-cors&#8221;, standards are highly discouraged from using it for new features. It is rather unsafe.</p><cite>https://fetch.spec.whatwg.org/#concept-request-mode</cite></blockquote>



<p>​XHR이든, Fetch API이든, 우리가 흔히 AJAX라고 부르는 요청은, cors를 기본 mode로 갖는다. </p>



<p>이에 반해 이미지나 CSS와 같은 리소스를 가져오는 요청, 즉 클라이언트의 코드 레벨이 아닌 하부 시스템에 의해 네트워크 요청이 만들어지는 경우(link, script, img, audio 등…)에 요청 개체는 no-cors를 기본값으로 갖는다. 다만, crossorigin 속성을 부여하면 mode는 cors가 된다.</p>



<pre class="crayon-plain-tag">// 아래의 경우는 mode가 cors 
&amp;lt;link rel=&quot;manifest&quot; href=&quot;/app.webmanifest&quot; crossorigin=&quot;use-credentials&quot;&gt;</pre>



<p>이 내용은 MDN에서 확인할 수 있다.</p>



<blockquote style="text-align:left" class="wp-block-quote"><p>Requests can be initiated in a variety of ways, and the mode for a request depends on the particular means by which it was initiated.</p><p>​For example, when a Request object is created using the Request.Request constructor, the value of the mode property for that Request is set to cors</p><p>However, for requests created other than by the Request.Request constructor, no-cors is typically used as the mode; for example, for embedded resources where the request is initiated from markup, unless the crossorigin attribute is present, the request is in most cases made using the no-cors mode — that is, for the &lt;link> or &lt;script> elements (except when used with modules), or &lt;img>, &lt;audio>, &lt;video>, &lt;object>, &lt;embed>, or &lt;iframe>elements.</p><cite>https://developer.mozilla.org/en-US/docs/Web/API/Request/mode#Default_mode</cite></blockquote>



<p> <a href="https://www.w3.org/TR/cors/" target="_blank" rel="noreferrer noopener">W3C의 Cross-Origin Resource Sharing 스펙</a>은 cors 모드인 요청을 처리하는 과정에서 CORS 확인에 실패하면 network error 처리 프로세스를 따를 것을 요구한다.</p>



<blockquote style="text-align:left" class="wp-block-quote"><p><em>Perform a resource sharing check. If it returns fail, apply the network error steps.</em></p><cite>https://www.w3.org/TR/cors/#network-error-steps</cite></blockquote>



<p>network error는 또 다른 스펙인 <a href="https://fetch.spec.whatwg.org/" target="_blank" rel="noreferrer noopener">WHATWG의 Fetch Standard</a>에서 정의하고 있는데, type이 error이며, status는 0이고,  status message가 빈 문자열을 갖는 응답 개체를 의미한다.</p>



<blockquote style="text-align:left" class="wp-block-quote"><p><em>A network error is a response whose status is always 0, status message is always the empty byte sequence, header list is always empty, body is always null, and trailer is always empty.</em></p><cite>https://fetch.spec.whatwg.org/#concept-network-error</cite></blockquote>



<p>꽤 길게 적었지만 요약하자면 이렇다.</p>



<blockquote style="text-align:left" class="wp-block-quote"><p>CORS 실패 → 네트워크 에러 발생 → status가 0</p></blockquote>



<p>이 내용을 이해하려고 3개의 스펙 문서를 어지럽게 돌아다녀야 하는 게 불만이었지만, XHR → CORS → Fetch로 스펙이 발달해온 과정과 스펙 사이의 의존관계를 생각해보니 조금은 인자해졌다.</p>



<p><a rel="noreferrer noopener" href="https://xhr.spec.whatwg.org/" target="_blank">XMLHttpRequest</a><br /><a rel="noreferrer noopener" href="https://www.w3.org/TR/cors/" target="_blank">Cross-Origin Resources Shaaring</a><br /><a rel="noreferrer noopener" href="https://fetch.spec.whatwg.org/" target="_blank">Fetch Standard</a></p>
]]></content:encoded>
							<wfw:commentRss>https://huns.me/development/2297/feed</wfw:commentRss>
		<slash:comments>1</slash:comments>
							</item>
		<item>
		<title>나는 그동안 무엇으로 성장했을까?</title>
		<link>https://huns.me/development/2281</link>
				<comments>https://huns.me/development/2281#comments</comments>
				<pubDate>Wed, 06 Mar 2019 12:43:13 +0000</pubDate>
		<dc:creator><![CDATA[개발왕 김코딩]]></dc:creator>
				<category><![CDATA[개발 이야기]]></category>
		<category><![CDATA[개발자]]></category>
		<category><![CDATA[성장]]></category>
		<category><![CDATA[회고]]></category>

		<guid isPermaLink="false">http://huns.me/?p=2281</guid>
				<description><![CDATA[<a href="https://huns.me/development/2281" class="more_link more_link_dots"> &#8230; </a>]]></description>
								<content:encoded><![CDATA[
<figure class="wp-block-image"><img src="http://huns.me/wp/wp-content/uploads/2019/03/unsplash_527bf4b4ae00d_1-1024x682.jpeg" alt="" class="wp-image-2285" srcset="https://huns.me/wp/wp-content/uploads/2019/03/unsplash_527bf4b4ae00d_1-1024x682.jpeg 1024w, https://huns.me/wp/wp-content/uploads/2019/03/unsplash_527bf4b4ae00d_1-300x200.jpeg 300w, https://huns.me/wp/wp-content/uploads/2019/03/unsplash_527bf4b4ae00d_1-768x512.jpeg 768w, https://huns.me/wp/wp-content/uploads/2019/03/unsplash_527bf4b4ae00d_1-600x400.jpeg 600w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>


<div id="SE-7b5c37ca-e2ee-4893-841d-75f07d1e80a0" class="se-component se-quotation se-l-quotation_underline">
<div class="se-component-content">
<div class="se-section se-section-quotation se-l-quotation_underline">
<div> </div>
<div class="se-module se-module-text se-quote"><span style="color: #23282d; font-size: 1.6em; font-weight: 600;">&#8220;API 수집가&#8221;</span></div>
</div>
</div>
</div>
<div id="SE-6b1b5208-57f2-4b5d-9651-ac6b8db42f95" class="se-component se-text se-l-default">
<div class="se-component-content">
<div class="se-section se-section-text se-l-default">
<div class="se-module se-module-text">
<p id="SE-8a99653d-b600-4331-9bad-7f705c526dbb" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-985bfa38-efe1-49ce-9f30-2cbc602592ba" class="se-fs-fs16 se-ff-   ">개발 어린이 시절에는 다양한 라이브러리와 프레임워크를 사용해 보는 것을 성장이라고 생각했다. 새로운 기술을 찾고, 예제 코드를 작성하고, 사용해봤다는 걸 열심히 자랑했다. 사용해 본, 또는 공부한 프레임워크의 종류는 늘어갔지만 밖에서 자랑한 것만큼 현실이 아름답지는 않았다. 여전히 내 코드는 유지보수하기 힘들었고, 버그가 많았으며, 빠듯한 일정에 허덕였다.</span></p>
<p id="SE-c4538645-f4f6-445e-808a-b21d8f70098a" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-af1e055f-de1c-494e-8af5-eb3ecf4dbafb" class="se-fs-fs16 se-ff-   ">깊이는 제쳐두고, 넓은 폭만을 동경했다. 낯선 것에 익숙해지는 데에는 시간이 필요했다. 배운 것을 잘 쓰기 위해서는 많은 수련을 해야 한다는 당연한 사실을 그때는 몰랐다. 그냥 도구가 문제를 제대로 풀지 못한다고 믿었다. 도구를 비난하는 게 가장 쉬웠다. 이 녀석은 내 말에 대꾸를 하지 못한다.</span><span id="SE-92a5b24e-573c-4990-8c37-305fb1b0f210" class="se-fs-fs16 se-ff-   ">​</span></p>
<p id="SE-8a641f29-3686-4f92-ab84-56a5bcc1e0a4" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-e4fad28b-f073-4531-be60-c92dce90e17e" class="se-fs-fs16 se-ff-   ">새로운 기술을 탐닉하는 것 자체를 나무랄 일은 아니다. 열정과 호기심이 있기에 가능한 일이다. 더 나은 개발자로 성장해가는 과정의 하나이고, 스펀지처럼 빨아들일 수 있는 그때가 어쩌면 탐닉하기에 가장 좋은 때인지도 모르겠다. 경험이 쌓이면 새로운 걸 받아들이기 힘들어지기도 한다. 장점과 단점은 동전의 앞면과 뒷면이다.</span><span id="SE-9e637b51-7e7c-4a06-9ea6-6c55803ada54" class="se-fs-fs16 se-ff-   ">​</span></p>
<p id="SE-945b8658-386d-4b1a-a8bf-030f0b3d6ca4" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-65ed196f-43fe-491e-878b-8b61025ebf0e" class="se-fs-fs16 se-ff-   ">API 수집가. </span></p>
<p id="SE-eee6f656-6c0c-4d00-9388-be0e78c2b3d5" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-efc8a33b-a171-481b-a779-b77a9eb1f9ef" class="se-fs-fs16 se-ff-   ">어쨌든 나의 개발 어린이 시절은 새로 나온 API를 수집하는 게 일이었다. 그 시절 내 관심은 오로지 </span><span id="SE-99d38e42-3b5c-498a-b1d3-3aaa52ead3a9" class="se-fs-fs16 se-ff-   "><b>코드</b></span><span id="SE-21ce96c9-93ef-4539-b958-e5aa9fc97cf3" class="se-fs-fs16 se-ff-   ">에 머물러 있었다. 코드는 나에게 목적이었다. 코드를 어떻게 작성해야 할지, 어떤 알고리즘이 시간 복잡도가 가장 낮은지, 어떤 라이브러리가 더 예쁜 인터페이스를 제공하는지. 이런 질문을 주로 머리에 담고 살았다. 개발은 나 자신과의 싸움이었다. 나만 잘하면 되는 그런 일.</span></p>
</div>
</div>
</div>
</div>
<div id="SE-895e34a2-e0d7-4ae1-8573-c42d5857f284" class="se-component se-quotation se-l-quotation_underline">
<div class="se-component-content">
<div class="se-section se-section-quotation se-l-quotation_underline">
<div class="se-module se-module-text se-quote">
<h2 id="SE-64a102cd-e647-467e-9271-cd6f4e7488e3" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-4023c4e2-3d34-4d4d-81ff-3450b0c1af37" class="se-fs-fs24 se-ff-   ">&#8220;꼰대 아니야?&#8221;</span></h2>
</div>
</div>
</div>
</div>
<div id="SE-9cbda834-3fd9-44a3-a682-b063bdc7952f" class="se-component se-text se-l-default">
<div class="se-component-content">
<div class="se-section se-section-text se-l-default">
<div class="se-module se-module-text">
<p id="SE-d22e53ee-f7ae-42b4-a784-984d5e2e7399" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-43b3955e-3e28-458c-a630-23c1ca25d2e6" class="se-fs-fs16 se-ff-   ">사람은 자신에게 유리한 쪽으로 현상을 해석하려는 경향이 있나 보다. 새로운 API로 팀이 겪는 모든 문제를 해결하고 싶었다. </span><span id="SE-4be9ddaf-6c42-4605-8c8e-982d194c5172" class="se-fs-fs16 se-ff-   ">훌륭한 개발자라면 최신의, 아름다운 논리로 무장한 기술을 당연히 칭송해야 하지 않겠는가. 그렇게 낡은 jQuery를 밀어내고 React를 도입하면 꽃길을 걸을 수 있을 거라 믿었다. </span><span id="SE-967100d1-418e-48d6-96bb-81f52a48e227" class="se-fs-fs16 se-ff-   ">​</span></p>
<p id="SE-984fed08-044f-4625-8084-8afe09abb46f" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-b77539c1-186a-486a-a1df-d3f205f336aa" class="se-fs-fs16 se-ff-   ">React를 공부했고, 콘퍼런스에서 발표도 했다. 발표했음을 동료에게 자랑하며 지식을 뽐냈다. 팀에 도입을 제안했다. 동료의 반응은 냉담했다. 내 말이 논리적으로 합당하고, 그걸 증명할 수만 있다면 당연히 모두가 따라줄 거라 믿었던 내 기대가 무너졌다. 사실 제대로 증명하지도 못했다. 결론을 내려놓고 근거를 가져다 끼워 맞춘 논리는 어색하기 마련이다.</span><span id="SE-83ca9a0b-6d3e-4396-8378-a756d6645c0f" class="se-fs-fs16 se-ff-   ">​</span></p>
<p id="SE-3520bffd-e47c-4525-b924-c6b320cbf790" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-d7892a1a-072b-43c5-81b0-bf443d544800" class="se-fs-fs16 se-ff-   ">기대와 현실의 간극을 동료를 비난하는 걸로 매워야 했다. 내 말을 안 들어주는 사람은 권위적인 꼰대이며, 우리 조직에는 수직적 잔재가 남아있다고 말이다. 킹왕짱 신기술 앞에 조심스러운 동료가 지나치게 보수적이라고 생각했다. 그래야 견딜 수 있었다. </span></p>
<p id="SE-804e812c-0289-4962-8fc2-76a4f0fb06f2" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-2b126e66-5be2-4113-8e97-f34c87333004" class="se-fs-fs16 se-ff-   ">한참이 지난 후 엉뚱하게 웹툰을 보다가 깨달았다. 이것이 신뢰의 문제임을.</span></p>
</div>
</div>
</div>
</div>
<div id="SE-b0a39dba-96a1-4638-b4d0-64073429b188" class="se-component se-quotation se-l-quotation_underline">
<div class="se-component-content">
<div class="se-section se-section-quotation se-l-quotation_underline">
<div class="se-module se-module-text se-quote">
<h2 id="SE-8ebd1d46-07c3-4390-8296-18df58dbabfb" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-7ae3f7eb-4698-419b-86ab-fc11f3e5c9a0" class="se-fs-fs24 se-ff-   ">&#8220;사람들은 옳은 사람 말 안 들어. </span>좋은 사람 말을 듣지.&#8221;</h2>
</div>
<p id="SE-832926a7-6cd0-49af-966c-25aa400f4094" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-83f0e346-2871-480a-89e3-44e299d05d9a" class="se-fs- se-ff-   " style="font-size: 8pt;">ㄴ송곳, 네이버 웹툰</span></p>
</div>
</div>
</div>
<div id="SE-d1a3c7ce-6a9d-42bb-b69f-6b4c44bc4ce0" class="se-component se-text se-l-default">
<div class="se-component-content">
<div class="se-section se-section-text se-l-default">
<div class="se-module se-module-text">
<p id="SE-c6d2fff8-e29f-472e-b83f-7c56b096e470" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-2055302b-19a4-4dc2-931a-624b78cd1092" class="se-fs-fs16 se-ff-   ">어찌어찌 어렵사리 React를 도입했다. 이후로 우리는 꽃길을 걸었을까? 그럴 리가. React만으로는 해결할 수 없는, React를 사용해서 발생하는 문제가 가득했고, 나는, 그리고 우리는 서툴렀다.</span></p>
<ul>
<li id="SE-8d78ccd3-1d97-490c-b9df-8a78b047c4d1" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-3d29e41f-a33c-4a18-b22f-7d50cb992836" class="se-fs- se-ff-   ">React의 조정(Reconcilation) 비용은 어떻게 줄여야 해요?</span></li>
<li id="SE-c48abe65-51be-4672-a965-84fecb008910" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-7f54e365-2d80-4d24-a17a-934578ed25fc" class="se-fs- se-ff-   ">키 입력 처리 성능이 너무 떨어져요!</span></li>
<li id="SE-5c13199a-062b-43ec-b0cb-b525e10fea45" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-606377e1-f049-402c-af3b-5b7cfc19a76d" class="se-fs- se-ff-   ">Mobx가 이벤트 구독, 처리하는 비용이 너무 큰 거 아니에요?</span></li>
<li id="SE-ea58f1dc-3e4e-4983-9961-678f88723891" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-2ac88fb3-e1e5-49c8-8cc7-090f1c04cdfb" class="se-fs- se-ff-   ">커서 렌더링 할 때 CPU를 너무 많이 점유하네요.</span></li>
<li id="SE-f45334f4-63e8-4c29-9a45-8ebd1fd66be8" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-548e83ce-5692-42c0-b12a-079a57dc7514" class="se-fs- se-ff-   ">QA에 들어가면 버그가 너무 많이 나와요.</span></li>
<li id="SE-e7019cef-7873-4594-a091-84a1d7bd495c" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-d6b7e3e0-7011-4ab6-8939-f11908d96e44" class="se-fs- se-ff-   ">Undo/Redo 알고리즘이 오류투성이에요.</span></li>
<li id="SE-c08c1a73-12ef-4d0c-9601-529b94b47063" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-226bedf1-7a8c-41a7-9a3b-b763699a167b" class="se-fs- se-ff-   ">참고할만한 스펙이 없어요!</span></li>
<li id="SE-028c08ba-0b90-42e1-8d18-6198a1884187" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-590cf2bd-7962-47fd-b589-6f2a300678bf" class="se-fs- se-ff-   ">어떤 게 더 나은 UX일까요?</span></li>
<li id="SE-77548f74-79f2-4f19-a33c-eeb2fedc5f88" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-98c844b0-c074-4e91-af8d-b2f9b9afff65" class="se-fs- se-ff-   ">커뮤니케이션 관계가 너무 복잡해요.</span></li>
<li id="SE-df319a8b-a8df-4491-824e-f3a397f5be2c" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-3a7ec1ef-6495-4c12-9c88-4160a804cd6f" class="se-fs- se-ff-   ">프로젝트 투입 인원이 부족해요.</span></li>
<li id="SE-cc3c23d2-a48d-4654-a44c-c4a108a1d2db" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-ea730387-8b4f-48a9-a34f-888966284a6f" class="se-fs- se-ff-   ">일정이 너무 촉박해요.</span></li>
<li id="SE-c580fe65-87b0-4139-8ef4-50fb42d1a416" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-8cca05af-f269-464a-9f80-4e54e4049e38" class="se-fs- se-ff-   ">설계 의도를 읽기가 힘들어요.</span></li>
<li id="SE-95c185e0-ee62-4edc-b9b7-ce23859ac2ff" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-1ab9a08b-bccb-47d8-b989-58b3a6f3f087" class="se-fs- se-ff-   ">옆 파트에 일이 너무 몰려서, 우리도 일을 진행할 수 없어요.</span></li>
<li id="SE-3facacee-c883-4e6f-8c22-6d5d90a22bbb" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-74716fea-6e11-4d67-8745-fbefc6e6a105" class="se-fs- se-ff-   ">예상치 못하게 치고 들어오는 이슈가 너무 많아요.</span></li>
<li id="SE-2b130a5c-5d9d-4eb2-85f7-29a14c0f7baf" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-75cdb4ea-d839-425d-8dee-3d8f9390803a" class="se-fs- se-ff-   ">단위 테스트 커버리지가 불충분해요.</span></li>
<li id="SE-421ba3ae-578e-4f29-ad77-bc518524b513" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-05839727-194e-4774-91a5-7eb8064d22db" class="se-fs- se-ff-   ">팀에 사람이 너무 많아요.</span></li>
</ul>
<p id="SE-14ac11ff-b3d6-4af1-abfd-c2da2c52de12" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-0ecc0263-cdde-49b5-ae16-5afd1c874769" class="se-fs-fs16 se-ff-   ">나열하자니 끝이 없다.</span></p>
<p id="SE-813c7ce3-a7e3-4634-9587-caec1a1b51f0" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-41f685e2-7209-4d6f-ad7a-80efa841a837" class="se-fs-fs16 se-ff-   ">이런 문제는 React, Functional Programming, Webpack, MVVM, NoSQL로는 해결할 수 없다. 어디에도 자랑할 수 있을 기술 스택으로 무장하고 있었지만 일정은 매번 빗나갔으며, 버그는 여전히 많았고, 스펙은 늘 모호하고, 커뮤니케이션은 언제나 어려웠다.</span></p>
<p id="SE-9e13a4c1-f2d0-41fb-96d1-74cc4ff6acd3" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-ec2f655c-264f-4d0d-a780-55f9b1e324e3" class="se-fs-fs16 se-ff-   ">답답한 마음에 코드 밖을 떠나 팀이 안고 있는 문제를 고민하고 해법을 찾기 시작했다.</span></p>
<p> </p>
</div>
</div>
</div>
</div>
<div id="SE-c3cf756b-924e-473c-958d-10da1fedc3d4" class="se-component se-horizontalLine se-l-line5">
<div class="se-component-content">
<div class="se-section se-section-horizontalLine se-l-line5 se-section-align-left">
<div class="se-module se-module-horizontalLine"><hr class="se-hr" /></div>
</div>
</div>
</div>
<div id="SE-71c238f7-6fd3-4cb1-81b0-1bbde532ea83" class="se-component se-text se-l-default">
<div class="se-component-content">
<div class="se-section se-section-text se-l-default">
<div class="se-module se-module-text">
<p id="SE-a6d4da67-8c7c-4692-853a-d0a5c32bca0b" class="se-text-paragraph se-text-paragraph-align- ">&#8216;추정이 매번 빗나가니 구성원이 모여서 상대 추정하는 방식으로 바꿔보면 어떨까?&#8217;</p>
<p class="se-text-paragraph se-text-paragraph-align- ">&#8216;개발과 QA 사이의 간격이 너무 넓은데, 스몰 릴리즈를 해보면 어떨까? 프로세스가 있어야겠네.&#8217;</p>
<p class="se-text-paragraph se-text-paragraph-align- ">&#8216;스펙 작성에 대한 책임은 논외로 하더라도, 인수 테스트 작성은 모두가 할 수 있으면 좋겠다.&#8217;</p>
<p class="se-text-paragraph se-text-paragraph-align- ">&#8216;팀 안에 생기는 문제를 지속적으로 개선해 나갈 수 있게 회고를 만들어야겠다.&#8217;</p>
<p class="se-text-paragraph se-text-paragraph-align- ">&#8216;성능 이슈는 원인이 복잡하게 엮여있으니, 다 같이 모여서 디버깅합시다.&#8217;</p>
</div>
</div>
</div>
</div>
<div id="SE-b2e2fd45-f924-418b-b00a-959123988468" class="se-component se-horizontalLine se-l-line5">
<div class="se-component-content">
<div class="se-section se-section-horizontalLine se-l-line5 se-section-align-left">
<div class="se-module se-module-horizontalLine"><hr /></div>
</div>
</div>
</div>
<div id="SE-32a744c2-79c3-47a3-ac54-08b59c6a4740" class="se-component se-text se-l-default">
<div class="se-component-content">
<div class="se-section se-section-text se-l-default">
<div class="se-module se-module-text">
<p> </p>
<p id="SE-f453b847-173d-4db9-9dab-aa74789c742e" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-6a566d24-752c-4726-b5cc-c3cdc016c875" class="se-fs-fs16 se-ff-   ">해결책을 찾고, 찾은 해결책을 적용하기 위해서 동료들과 토론하고 설득하고 협상하는 과정에서 배우는 게 있었다. 그 즈음이었던 것 같다. 라이브러리나 프레임워크 외에도 개발자가 관심을 가져야 할 것이 많다는 걸 깨달은 때가.</span><span id="SE-c0c87da5-0417-4089-b81e-90e198c3be11" class="se-fs-fs16 se-ff-   ">​</span></p>
<p id="SE-d285eb84-3a60-40ae-9311-d5d1ed3a8f92" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-7e91ee68-2fdd-461a-92f5-30107d45603b" class="se-fs-fs16 se-ff-   ">내가 하는 일의 성격을 다시 정의했다. </span></p>
</div>
</div>
</div>
</div>
<div id="SE-93521457-9c3c-454e-b16b-3a519c7908aa" class="se-component se-quotation se-l-quotation_underline">
<div class="se-component-content">
<div class="se-section se-section-quotation se-l-quotation_underline">
<div class="se-module se-module-text se-quote">
<h2 id="SE-89c77ea3-bd1d-4121-a3c9-bf76468ed9e0" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-b39f18de-6782-413b-ba93-305007ff171c" class="se-fs-fs24 se-ff-   ">&#8220;사람이, </span>사람과 함께, 사람에게 필요한 무언가를 만드는 일&#8221;</h2>
</div>
</div>
</div>
</div>
<div id="SE-725c38e3-ad5f-4c73-959b-e514e7f9ee91" class="se-component se-text se-l-default">
<div class="se-component-content">
<div class="se-section se-section-text se-l-default">
<div class="se-module se-module-text">
<p id="SE-71717f90-9293-4d68-99be-9f1ed257b5d3" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-51ef9e52-3397-40ce-812c-b9d510256d9d" class="se-fs-fs16 se-ff-   ">사람을 모르고 사람과 일을 할 수는 없겠다 싶었다. 설득하고, 협상하고, 인내하는 일련의 과정을 이끌어야만 내가 원하는 것을 얻을 수 있다는 걸 경험으로 배웠다. 이 과정에서 불편한 사람과 대화도 해야 할 것이며, 다수 앞에 나서야 할 일도 있다. 때로는 내가 중요하게 여기는 것을 일부 포기하기도 해야 했다. API를 수집하는 일 외에도 알아야 할, 싫지만 견뎌야 할, 어렵지만 잘 해야 할 일이 있었다. </span></p>
<p id="SE-14291497-71ef-41c5-9757-24b392de4a67" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-63a9d22c-10d6-4c73-b610-6134843d291a" class="se-fs-fs16 se-ff-   ">React가 아무리 좋은 기술이고, 내가 React를 잘 안다고 해도 이 녀석을 팀이 받아들일 수 있게 설득할 수 있는 능력이 없다면 React가 다 무슨 소용이람. 당위성을 설명하고, 일정을 확보해야 한다. </span></p>
<p id="SE-e4932432-5eee-4895-af84-c7cd2b4bbc7c" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-cbaea19c-27cd-4a92-aad2-673ae33413d2" class="se-fs-fs16 se-ff-   ">어렵사리 도입을 결정해도 꽃길만 걸을 수는 없다. 레거시 위에서 낡은 것과 새로운 것을 엮는 일의 난도는, 인터넷에 떠도는 예제를 작성하는 것에 비해 훨씬 어렵다. 옛것과 새것이 공존하는 혼란의 시기도 견뎌야 한다. 혼란에 지친 동료의 투정을 다독이며 앞으로 나아가는 가시밭길의 쓰라림은 또 어떤가.</span></p>
<p id="SE-9e05b348-11ea-4f2d-9f29-b5db0f63bc76" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-a09d5837-83f4-4e70-a4ca-d451fb2fa60b" class="se-fs-fs16 se-ff-   ">생각이 여기에 미치니, 1차원이었던 세상(코딩)이 2차원(팀), 3차원(조직과 조직)으로 확장되어 보이기 시작했다. 제품을 개발하는 전 과정을 아우르는 모든 것들을 관심사에 담았다.</span><span id="SE-5478d763-8c23-4df6-8fcc-81ae7bf3c147" class="se-fs-fs16 se-ff-   ">​</span></p>
<p id="SE-d399254c-e34f-4ad3-85b0-6dc3d040b596" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-c92d9302-ab60-4884-a69a-c89ba8ffcbc8" class="se-fs-fs16 se-ff-   ">고민의 결이 바뀌었다.</span></p>
</div>
</div>
</div>
</div>
<div id="SE-1481f4c9-5f7e-4e3a-852a-40e9367ace8a" class="se-component se-quotation se-l-quotation_underline">
<div class="se-component-content">
<div class="se-section se-section-quotation se-l-quotation_underline">
<div class="se-module se-module-text se-quote">
<h2 id="SE-3526ca9e-a295-4444-b399-3759ab8acccc" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-7f4ee7ae-b0f0-4ca7-8654-00c7e1c00192" class="se-fs-fs24 se-ff-   ">&#8220;어떻게 하면 우리가 제품을 </span>더 잘 만들 수 있을까?&#8221;</h2>
</div>
</div>
</div>
</div>
<div id="SE-0144a30e-69f2-45c3-a0f8-cd0339070ce2" class="se-component se-text se-l-default">
<div class="se-component-content">
<div class="se-section se-section-text se-l-default">
<div class="se-module se-module-text">
<p id="SE-c176567f-778f-43a6-a80b-14a1aa25344c" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-9454ddd3-50d7-4e04-b520-ff782dca1471" class="se-fs-fs16 se-ff-   ">얼마 전 내 페이스북 타임라인에 올라온 박성철 님의 포스트가 재밌다. 어떤 논문에 나와있는 내용을 근거로 </span><span id="SE-79dc86c3-55c9-4fe8-8607-703ea58748f6" class="se-fs-fs16 se-ff-   "><b>학교와 실무에서 배우지 못해, 정작 실무에서 필요로하는 만큼 역량을 쌓기 힘든 분야 10가지</b></span><span id="SE-95d66584-bc9a-4d76-aa36-3b9e62248008" class="se-fs-fs16 se-ff-   ">를 나열하고 있다.</span><span id="SE-b535a8a0-7ccc-40b4-bfde-6da764b9e21a" class="se-fs- se-ff-   ">​</span></p>
<ol>
<li id="SE-9feadb0c-85b4-4728-a945-b356cf7f85d8" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-3f1586ce-6562-464c-80dc-098e951f33d7" class="se-fs- se-ff-  se-style-unset ">협상</span></li>
<li id="SE-b0624dd3-35c2-42f0-8961-63d4818cd033" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-afcee27a-bd7e-4ec7-aff3-227df71b96e8" class="se-fs- se-ff-  se-style-unset ">인간-컴퓨터 상호작용 / 사용자 인터페이스</span></li>
<li id="SE-9d309dad-7210-4b24-a75f-5f14794738f9" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-83e30ec4-4c9e-4a60-a410-9c3cb16e8ab8" class="se-fs- se-ff-  se-style-unset ">리더십</span></li>
<li id="SE-9836d126-ecca-4286-a6a6-5cf8c5ca9741" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-3511bb34-641f-4c0d-896b-db0b42896a26" class="se-fs- se-ff-  se-style-unset ">실시간 시스템 설계</span></li>
<li id="SE-657e53dc-9c05-445e-ba80-73ec68a64ca6" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-c2bfdffb-1ef4-43d9-9d86-23f1cb15e3a5" class="se-fs- se-ff-  se-style-unset ">관리</span></li>
<li id="SE-d0e1f636-22df-4060-9806-aa369c3a76c8" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-db7599e8-d2f4-4bd6-a6e9-73544bb8ea54" class="se-fs- se-ff-  se-style-unset ">소프트웨어 비용 추정</span></li>
<li id="SE-53e1ee50-a512-4fdf-9fb0-48110cf0148d" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-e843295e-6dd6-4a77-8267-db5fd59676dc" class="se-fs- se-ff-  se-style-unset ">소프트웨어 지표</span></li>
<li id="SE-9350f814-3099-49cb-9530-414b89fd24d4" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-9f01ce49-df62-4b17-a8af-2f46ec8317d7" class="se-fs- se-ff-  se-style-unset ">소프트웨어 신뢰성(reliability)과 장애 내성(fault tolerance)</span></li>
<li id="SE-b3b22f4b-f1ce-4794-b0e0-fac0e6838bc5" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-b7a94418-6b3b-4bdd-99b7-3a606dc73c6d" class="se-fs- se-ff-  se-style-unset ">윤리와 전문가 의식</span></li>
<li id="SE-a8ddc877-150e-4dd3-972b-4c85b252afd9" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-499ad730-5d45-4341-b13c-21c887f0fb32" class="se-fs- se-ff-  se-style-unset ">요구사항 수집/분석</span></li>
</ol>
</div>
</div>
</div>
</div>
<div id="SE-53c6e9b7-0074-4ffd-87cc-2a8f172ab51a" class="se-component se-text se-l-default">
<div class="se-component-content">
<div class="se-section se-section-text se-l-default">
<div class="se-module se-module-text">
<p id="SE-24205ab6-6992-4a51-af8f-ca71bcbd96e7" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-e20968cb-6a86-4144-b1ec-fcd54916f6b7" class="se-fs-fs16 se-ff-   ">모두 다 제품을 잘 만들기 위해서 우리가 챙겨야할 것들이다. 물론 한 개인이 모든 방면에서 뛰어나기는 어렵다. 그게 사람이기에 사람은 분업을, 더 나아가 협업을 한다.</span></p>
<p id="SE-17df00e7-4149-4f56-87cb-ff7f00bf94fe" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-eb6593ac-13a8-464f-9a8f-8fb68c9ef22c" class="se-fs-fs16 se-ff-   ">어쨌든 이런 내용은 종합적으로 엮어서 체계적으로 가르쳐주는 데가 없다. 더군다나 나처럼 인문학도에, 비전공자인 경우는 아예 이런 주제가 있다는 걸 모르고 사는 경우도 많다. </span></p>
<p id="SE-ef658130-55b8-4a10-ad83-ef0d6c7888be" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-92588bc1-e19e-4b5c-af4e-cd7582999d4d" class="se-fs-fs16 se-ff-   ">운이 좋았다. 복잡한 조직에서, 복잡한 제품을 만들며, 복잡한 문제 속에 놓여있었기에 자연스레 이런 주제에도 관심을 가질 수 있었다. 체계적으로 배울 수 있는 곳이 없었기에 인터넷에 떠도는 글을 찾아서 읽거나, 선배에게 조언을 듣거나, 파편적으로 책을 찾아서 보고 얻은 지식을 연결해서 패턴을 찾았다. </span><span id="SE-1ddff165-078a-48e8-88a7-b1934fcaae47" class="se-fs-fs16 se-ff-   ">​</span></p>
<p id="SE-b2dc05f9-e290-49f9-b9c3-f2aa50afc00f" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-41f954e2-155d-48cd-a9c6-3ddfaf71de9f" class="se-fs-fs16 se-ff-   ">하지만 배운 내용을 하루 아침에 실전에서 발휘할 수는 없었다. 리팩터링 책을 아무리 읽고 읽어도 도대체 어디에 써먹어야 할지 알 수 없듯이. 프레젠테이션 교육을 받았다고 내일 당장 내가 스티브 잡스가 될 수는 없듯이.</span></p>
<p id="SE-245ccdbf-1965-427f-830d-a4e1789264cb" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-4fae268f-ad92-4bde-bb83-c8dbf2543f4f" class="se-fs-fs16 se-ff-   ">읽어둔 이론을 토대로 현실과 이론 사이의 연결고리를 찾고, 현실에 조금씩 적용해나가며 경험치를 쌓았다. 물론 경험이라는 것 또한 단순히 쌓는 걸로 체득되지는 않았다. 경험은 애써 잡아두지 않으면 흩어져서 사라져버린다. 뒤를 돌아보고 개선하고 시도하고 다시 반복하는 과정. 이게 없으면 흔히 농담으로 말하는 </span><span id="SE-e701b211-bd82-41e9-8b5e-809acee060b7" class="se-fs-fs16 se-ff-   "><b>나이(연차)를 똥으로 먹은 사람</b></span><span id="SE-ecf3e21c-dbf6-4976-967d-47ed769cd26d" class="se-fs-fs16 se-ff-   ">이 되기 쉽겠더라. </span></p>
<p id="SE-4967b626-b08f-4185-bedf-a7391168855c" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-7e89b47c-029d-4599-8678-46a981470df5" class="se-fs-fs16 se-ff-   ">어제를 돌아보며 경험을 체계화하고 개선하는 사이클을 반복했다. 조금씩 아는 것들이 생겼고 나아졌지만 때로는 미친 척하는 용기도 필요했다. 확신하기 어려운 일을 동료들 앞에 서서 해보자고 제안할 때면 그냥 혼자 코딩하던 시절이 그리울 때도 있다. 사람들 앞에 서는 순간이면 숨이 가빠진다. 그걸 견뎌야만 원하는 걸 얻을 수 있었기에 참고 있을 뿐. 다행히도 견디다 보니 조금은 무뎌지더라.</span></p>
</div>
</div>
</div>
</div>
<div id="SE-0c1a1988-133b-4a21-87cf-1f5fcd69d0b3" class="se-component se-quotation se-l-quotation_underline">
<div class="se-component-content">
<div class="se-section se-section-quotation se-l-quotation_underline">
<div class="se-module se-module-text se-quote">
<h2 id="SE-5158792a-0e4b-4ac7-847b-52b230d6b368" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-89b3eb15-aff7-45fb-88e6-6e3a0d05baa6" class="se-fs-fs24 se-ff-   ">&#8220;개발자에게 성장이란 무엇일까?&#8221;</span></h2>
</div>
</div>
</div>
</div>
<div id="SE-776a9218-c35b-4233-bb44-e1347ce32401" class="se-component se-text se-l-default">
<div class="se-component-content">
<div class="se-section se-section-text se-l-default">
<div class="se-module se-module-text">
<p id="SE-90deb3f9-3399-4d48-a9a0-186768dca313" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-7765d178-61f4-401d-9017-9d8e6bfd9de6" class="se-fs-fs16 se-ff-   ">작년에 팀에서 성장에 대해서 설문조사를 한 적이 있다. 개인의 성장과 조직의 성장 사이의 간극을 찾고 서로의 목표를 최대한 맞춰보려는 시도였다. 그러기 위해서는 저마다가 생각하는 성장의 의미를 읽어야만 했다. 질문을 받았지만 선뜻 답이 나오질 않았다. 진지하게 고민해본 적이 없었다.</span></p>
<p id="SE-6a1e0126-c59a-4878-b48f-dff202c39f0b" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-c50eb54d-b09c-42a7-a11f-e6f900c9c222" class="se-fs-fs16 se-ff-   ">언젠가 팀의 업무 프로세스를 개선하려고 사용자 스토리를 도입할 것을 제안했던 적이 있다. 이 제안을 하기 위해서 같은 책을 5번은 읽었고, 관련 글을 인터넷에서 20개도 넘게 찾아서 읽었으며, 의도를 설명하는 전체 </span><span id="SE-26e8634d-8be4-46af-9de1-a7b5eac23363" class="se-fs-fs16 se-ff-   ">메일을 3번은 쓴 것 같다. 위키를 2번 정도 작성해서 공유했으며, 모든 동료가 모인 자리에서 2번이나 설명을 했다. 아니 3번이었나? </span></p>
<p id="SE-09175e6d-2136-4539-bad7-9d386da8384c" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-5a5ff957-fcdb-490a-a00a-31777df11a7f" class="se-fs-fs16 se-ff-   ">어쨌든. 물론 개인 대 개인으로 자잘하게 설명한 경우는 더 많다. 이제는 모두 이해했을까 싶었을 때 누군가 내게 물었다.</span><span id="SE-48a3834b-7eaa-4257-995c-f68c9e6902c6" class="se-fs-fs16 se-ff-   ">​</span></p>
<p id="SE-26d4f73a-4d3c-4cf0-b911-1a8d8fcaa3c2" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-0ddbdeab-9fbc-4611-9e3d-af96602f9516" class="se-fs-fs16 se-ff-   se-decoration-unset">&#8220;스토리 포인트가 꼭 필요한가요?&#8221;</span></p>
<p>.</p>
<p>.</p>
<p>.</p>
<p id="SE-c6a0622f-62d3-4e51-ae7e-b064bcf85ee4" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-97d469c9-6aa0-440e-9ba2-5afdb97ebc36" class="se-fs-fs16 se-ff-   ">이제 와서 돌아보니 더 나은 방향을 찾아서 동료와, 리더와, 제품과, 코드와 투닥거리는 이 모든 과정이 성장이었더라.</span><span id="SE-34cda410-93ae-4d3b-9be7-4179acff04b7" class="se-fs-fs16 se-ff-   ">​</span></p>
<p id="SE-9469453f-d3e2-48bc-87be-211f3f201d65" class="se-text-paragraph se-text-paragraph-align- "><span id="SE-cda979ed-c81a-490b-a112-77352061adb3" class="se-fs-fs16 se-ff-   ">오늘 나에게 누군가 성장이 무어냐고 묻는다면, </span><span id="SE-6a2c65d6-fa37-41a5-bbef-17815c8cdbef" class="se-fs-fs16 se-ff-   "><u><b>다양한 사람의 의지가 뒤섞이는 개발이라는 큰 운동장에서, 본인의 역할을 질문하고 찾아가는 과정</b></u></span><span id="SE-5fec5c1c-53e7-463d-bde2-19797a572f92" class="se-fs-fs16 se-ff-   ">이라고 답하고 싶다. </span></p>
<p id="SE-1f1e0237-4415-4c86-8941-1b70b453f981" class="se-text-paragraph se-text-paragraph-align- ">직업 전문인으로서, 개발자에게 코딩은 목적이 아닌 수단이어야 한다는 꼰대 아닌 꼰대 같은 생각을 가끔 한다. 개발이라는 더 큰 관점에서 자신의 업무를 돌아보면 좋겠다. 나를 보고, 동료를 보고, 조직을 보고, 제품을 보고, 일이 흘러가는 흐름을 보자.</p>
<p class="se-text-paragraph se-text-paragraph-align- ">모두가 그 안에서 자신의 가치를 찾을 수 있기를 바라며.</p>
</div>
</div>
</div>
</div>]]></content:encoded>
							<wfw:commentRss>https://huns.me/development/2281/feed</wfw:commentRss>
		<slash:comments>1</slash:comments>
							</item>
		<item>
		<title>Webpack 4의 Tree Shaking에 대한 이해</title>
		<link>https://huns.me/development/2265</link>
				<comments>https://huns.me/development/2265#comments</comments>
				<pubDate>Thu, 08 Nov 2018 10:04:40 +0000</pubDate>
		<dc:creator><![CDATA[개발왕 김코딩]]></dc:creator>
				<category><![CDATA[개발 이야기]]></category>
		<category><![CDATA[optimization]]></category>
		<category><![CDATA[sideEffects]]></category>
		<category><![CDATA[tree shaking]]></category>
		<category><![CDATA[webpack]]></category>
		<category><![CDATA[최적화]]></category>

		<guid isPermaLink="false">http://huns.me/?p=2265</guid>
				<description><![CDATA[<a href="https://huns.me/development/2265" class="more_link more_link_dots"> &#8230; </a>]]></description>
								<content:encoded><![CDATA[<p>회사에서 만들고 있는 새로운 버전의 스마트에디터는 Webpack 4를 빌드 도구로 사용한다. 초기 로딩 성능을 최적화하기 위해서 Webpack 4의 Tree Shaking 지원을 검토하다가 삽질을 많이 했다. 공부 안 하고 대충하면 될 줄 알았는데 안 되더라.</p>
<p>경험을 내 안에 썩혀두기가 아까워서 팀에 공유할 목적으로 삽질기를 작성했다. 외부의 누군가에게도 도움이 될 것 같아 원문을 조금 다듬어서 블로그로 옮긴다. 의식의 흐름을 따라 쓴 글이라 두서가 없으니, 찰떡같이 읽어주시길.</p>
<h1>1.Tree Shaking이란?</h1>
<p>Tree Shaking은 직역하면 <strong>나무 흔들기 </strong>정도로 표현할 수 있다. Webpack이 JS 모듈을 번들링할 때 사용하지 않는 코드를 제거하는 최적화 과정을 말한다. 나무를 흔들면 잎이 떨어지듯이 사용하지 않는 코드를 털어낸다는 뜻이다. 개념에 이름을 붙일 때 은유를 이용하는 걸 좋아한다. 메타포!<br />
​<br />
원래 이 용어를 처음 최적화 개념에 사용한 건 rollup.js지만 Webpack 4가 대단히 영리한 최적화 빌드를 보여주면서 주목받는 사이 rollup.js는 잊힌 느낌이다.</p>
<p>인터넷에 떠도는 예제와 달리 현실의 설정은 매우 복잡하다. 95개의 패키지를 가지고 있는 Monorepo니 복잡할 수밖에. 그래서 그런지 아무리 설정을 바꿔봐도 최종 번들 파일의 사이즈가 좀처럼 줄어들지를 않았다. 제대로 이해하고 써야겠다는 생각에 <a href="https://github.com/CoderK/tree-shaking-with-side-effect-test">예제 코드</a>를 만들어서 테스트를 하기로 했다.</p><pre class="crayon-plain-tag">export function a() { console.log("a"); }
export function b() { console.log("b"); }
export function c() { console.log("c"); }</pre><p></p><pre class="crayon-plain-tag">export { a, b, c } from "./abc";
export { add as reexportedAdd, multiply as reexportedMultiply } from "./math";</pre><p></p><pre class="crayon-plain-tag">export function add() {
    var sum = 0, i = 0, args = arguments, l = args.length;
    while (i &lt; l) {
        sum += args[i++];
    }
    return sum;
}

export function multiply() {
    console.log("이것은 곱하기!");
    var product = 1, i = 0, args = arguments, l = args.length;
    while (i &lt; l) {
        product *= args[i++];
    }
    return product;
}

export function list() {
    console.log("이것은 리스트!");
    return Array.from(arguments);
}</pre><p></p><pre class="crayon-plain-tag">import { add } from './math';
import * as library from "./library";

add(1, 2);

library.reexportedMultiply(1, 2);</pre><p>index.js가 엔트리 포인트다. 의도적으로 math.js의 list 함수를 import 하되, 사용하지 않도록 구성했다. Tree Shaking이 정상 동작한다면, 최종 빌드 된 파일에는 list 함수가 없어야한다.</p>
<p>추적을 쉽게 하기 위해서 콘솔에 문자열을 출력하는 코드를 함수 중간에 추가했다. production 빌드를 하면 소스가 난독화가 되어버려 list 함수를 찾기가 어렵다. 문자열은 난독화되지 않기 때문에 빌드 파일에서 저 문자열을 검색하면 Tree Shaking 수행여부를 확인할 수 있으리라.</p>
<p>먼저 development 모드로 빌드를 했다. Webpack의 기본 옵션은 development 모드일 때 코드를 최적화하지 않도록 구성되어 있다. 따라서 최적화의 하나인 Tree Shaking을 수행하지 않아야 한다.</p><pre class="crayon-plain-tag">…(생략)



"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "list", function() { return list; });
function add() {
    var sum = 0, i = 0, args = arguments, l = args.length;
    while (i &lt; l) {
        sum += args[i++];
    }
    return sum;
}

function multiply() {
    console.log("이것은 곱하기!");
    var product = 1, i = 0, args = arguments, l = args.length;
    while (i &lt; l) {
        product *= args[i++];
    }
    return product;
}

function list() {
    console.log("이것은 리스트!");
    return Array.from(arguments);
}


…(생략)</pre><p>번들 파일 안에 list 함수가 있는 게 보인다. 이번에는 production 모드로 빌드를 해서 비교를 해보자.</p>
<p><span style="font-size: 10pt;">(가독성 향상을 위해서 beautify하였음)</span></p><pre class="crayon-plain-tag">…(생략)


}([function(t, e, n) {
    "use strict";

    function r() {
        for (var t = 0, e = 0, n = arguments, r = n.length; e &lt; r;) t += n[e++];
        return t
    }

    function o() {
        console.log("이것은 곱하기!");
        for (var t = 1, e = 0, n = arguments, r = n.length; e &lt; r;) t *= n[e++];
        return t
    }
    n.d(e, "a", function() {
        return r
    }), n.d(e, "b", function() {
        return o
    })
}, function(t, e, n) {
    "use strict"
}, function(t, e, n) {
    "use strict";
    n(1);
    var r = n(0);
    n.d(e, "a", function() {
        return r.b
    })
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        o = n(2);
    Object(r.a)(1, 2), o.a(1, 2)
}]);


…(생략)</pre><p>코드가 난독화되어 읽기 어렵지만 list 함수에 심어놓은 콘솔 출력 문자열이 보이지 않는 걸로 보아 Tree Shaking이 되었다고 유추할 수 있다.</p>
<p>한 가지 의문이 생긴다. Webpack은 아래와 같은 import 구문도 최적화를 할 수 있는 걸까?</p><pre class="crayon-plain-tag">import * as library from "./library";</pre><p>Webpack 4 이전까지는 이런 구문을 최적화하지 못하였다. 그래서 인터넷에 떠도는 일부 유통기한이 지난 문서에서 최적화를 위해서 이런 구문을 사용하지 말라는 내용을 가끔 볼 수 있었다. 이제는 아닌가 보네?</p>
<p>확인을 하고 넘어가야 직성이 풀릴 듯하여 검색을 하기 시작했다.</p>
<h1>3. import * as … from</h1>
<p>개발을 하다 보면 특정 모듈을 가져와서 import와 동시에 export 하고 싶을 때가 있다. 주로 모듈의 인덱스 파일을 작성할 때 그렇다.</p><pre class="crayon-plain-tag">import * as library from "./library";</pre><p>이런 구문을 뭐라고 불러야 할지 모르겠다. 이 글에서는 <code>re-export</code>라고 부를 생각이다. Tree Shaking을 스마트에디터에 적용하려고 보니, 이 패턴을 너무 많은 곳에서 쓰고 있어서 퍽 난감했다. 또, 의지의 영역으로 들어온 것인가. 한숨을 쉬고 있던 그때. 응? Tree Shaking이 되네?</p>
<p>궁금해서 Webpack의 공식 문서를 찬찬히 읽어보다가 흥미로운 내용을 발견했다. Webpack 4에 생긴 providedExports라는 최적화 옵션.</p><pre class="crayon-plain-tag">module.exports = {
  //...
  optimization: {
    providedExports: true
  }
};</pre><p>문서는 이 옵션의 용도를 이렇게 설명한다.</p>
<blockquote><p>Tells webpack to figure out which exports are provided by modules to generate more efficient code for export * from &#8230;. By default optimization.providedExports is enabled.<br />
<a href="https://webpack.js.org/configuration/optimization/#optimization-providedexports" rel="nofollow">https://webpack.js.org/configuration/optimization/#optimization-providedexports</a></p></blockquote>
<p><code>export * from</code>을 위해 만들어진 옵션. 나에게 필요한 그것. Webpack 만세!</p>
<p>Webpack 4는 optimization 프로퍼티로 최적화 설정을 전달받는다. production 빌드를 할 때, 개발자가 optimization을 별도로 설정하지 않으면 기본 값을 적용한다. providedExports는 기본값이 true다. 따로 설정을 하지 않아도 re-export 구문을 최적화한다. 당연한 이야기지만 false로 설정하면 re-export 구문은 최적화 대상에서 제외된다.</p>
<p>누가 이걸 false로 설정할까 싶지만, 모든 최적화에는 비용이 들기 마련이다. re-export 구문을 분석하고 최적화하는 과정 역시 그렇다. re-export 구문을 사용하지 않는다면 굳이 빌드 시간을 더 소비할 이유가 없다.</p>
<p>providedExports를 false로 설정하고 빌드를 해보면, 빌드 버전에서 list 함수를 볼 수 있다.</p><pre class="crayon-plain-tag">}([function(n, t, r) {
    "use strict";

    function e() {
        for (var n = 0, t = 0, r = arguments, e = r.length; t &lt; e;) n += r[t++];
        return n
    }

    function o() {
        console.log("이것은 곱하기!");
        for (var n = 1, t = 0, r = arguments, e = r.length; t &lt; e;) n *= r[t++];
        return n
    }

    function u() {
        return console.log("이것은 리스트!"), Array.from(arguments)
    }
    r.r(t), r.d(t, "add", function() {
        return e
    }), r.d(t, "multiply", function() {
        return o
    }), r.d(t, "list", function() {
        return u
    })
}, function(n, t, r) {</pre><p></p>
<h1>4. lodash와 sideEffects</h1>
<p>Tree Shaking을 찾아보다가, lodash가 생각이 났다. 사용하지 않는 lodash 모듈을 빌드 버전에서 제외하려고 babel-plugin-lodash를 사용해왔다. Webpack 4의 Tree Shaking이 있으니, 이제 이 플러그인과 작별해도 되겠네? 테스트를 해보자.</p>
<p>예제에 lodash 패키지를 추가하고,</p><pre class="crayon-plain-tag">npm -i lodash</pre><p>index.js의 코드를 아래와 같이 수정한 다음에 development 모드로 빌드를 했다.</p><pre class="crayon-plain-tag">import { add } from './math';
import * as library from "./library";
import { defaults } from "lodash";

defaults("최적화!");

add(1, 2);
library.reexportedMultiply(1, 2);</pre><p>번들링은 끝이 났고 최종 산출물에서 아까 추가한 코드가 보인다.</p><pre class="crayon-plain-tag">Object(lodash__WEBPACK_IMPORTED_MODULE_2__["defaults"])("최적화!");</pre><p>import 하지 않은 lodash의 다른 모듈은? Webpack의 보일러 플레이트 코드와 뒤섞여 혼란한 와중에서도 찾기 쉬운 이름의 함수를 검색하는 게 좋을 것 같다. <code>differenceWith</code> 함수를 검색했다.</p><pre class="crayon-plain-tag">var differenceWith = baseRest(function(array, values) {
  var comparator = last(values);
  if (isArrayLikeObject(comparator)) {
    comparator = undefined;
  }
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
    : [];
});</pre><p>development 모드에서는 기본적으로 optimization 옵션이 동작하지 않으니 당연한 결과다. production 빌드를 하면? 없겠지.</p><pre class="crayon-plain-tag">}, he.debounce = ef, he.defaults = Yf, he.defaultsDeep = Qf, he.defer = uf, he.delay = of , he.difference = so, he.differenceBy = ho, he.differenceWith = po, he.drop = function(n, t, r) {
    var e = null == n ? 0 : n.length;
    return e ? Su(n, (t = r || t === i ? 1 : Mf(t)) &lt; 0 ? 0 : t, e) : []
}, he.dropRight = function(n, t, r) {</pre><p>그런데 있다. Tree Shaking이 동작하지 않았다. 왜?</p>
<p>​한참 삽질을 하던 중, Webpack의 공식 문서를 읽어보고서야 범인을 알 수 있었다. 범인은 sideEffects.</p>
<p><a href="https://webpack.js.org/configuration/optimization/#optimization-sideeffects">https://webpack.js.org/configuration/optimization/#optimization-sideeffects</a></p>
<p><span style="font-size: 10pt;">(Webpack 최적화 옵션의 sideEffects와는 다릅니다.)</span></p>
<p>Tree Shaking을 수행하면 사용하지 않는 코드가 탈락된다. 이로 인해 사이드 이펙트가 발생할 수 있는데, 코드를 직접 평가하고 실행해보지 않는 이상 Webpack이 사이드 이펙트 발생 여부를 알 수는 없다. 그래서 Webpack이 찾은 대안이 sideEffects다.</p>
<p>직접 코드를 평가하고 실행하는 대신에, Webpack은 외부 패키지의 package.json에 있는 sideEffects 설정을 보고 사이드 이펙트 존재 여부를 판단하다. 사이드 발생 여부에 대한 판단 책임을 코드 작성자에게 넘긴 셈이다. 만든 사람이 제일 잘 알테니깐.<br />
​<br />
이 옵션을 명시하지 않으면 Tree Shaking 시에 사이드 이펙트가 발생할 수 있다고 판단하여 해당 패키지를 Tree Shaking의 대상에서 제외한다. 따라서 package.json에 sideEffects 프로퍼티를 false로 명시해야만 Three Shaking을 적용받을 수 있다.</p>
<p>위에서 설치한 lodash의 package.json을 확인하자.</p><pre class="crayon-plain-tag">{
  "_from": "lodash",
  "_id": "lodash@4.17.11",
  "_inBundle": false,
  "_integrity": "sha512-cQKh8igo5QUhZ7lg38DYWAxMvjSAKG0A8wGSVimP07SIUEK2UO+arSRKbRZWtelMtN5V0Hkwh5ryOto/SshYIg==",
  "_location": "/lodash",
  "_phantomChildren": {},
  "_requested": {
    "type": "tag",
    "registry": true,
    "raw": "lodash",
    "name": "lodash",
    "escapedName": "lodash",
    "rawSpec": "",
    "saveSpec": null,
    "fetchSpec": "latest"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.11.tgz",
  "_shasum": "b39ea6229ef607ecd89e2c8df12536891cac9b8d",
  "_spec": "lodash",
  "_where": "/Users/Naver/Workspace/coderk/tree-shaking-test",
  "author": {
    "name": "John-David Dalton",
    "email": "john.david.dalton@gmail.com",
    "url": "http://allyoucanleet.com/"
  },
  "bugs": {
    "url": "https://github.com/lodash/lodash/issues"
  },
  "bundleDependencies": false,
  "contributors": [
    {
      "name": "John-David Dalton",
      "email": "john.david.dalton@gmail.com",
      "url": "http://allyoucanleet.com/"
    },
    {
      "name": "Mathias Bynens",
      "email": "mathias@qiwi.be",
      "url": "https://mathiasbynens.be/"
    }
  ],
  "deprecated": false,
  "description": "Lodash modular utilities.",
  "homepage": "https://lodash.com/",
  "icon": "https://lodash.com/icon.svg",
  "keywords": [
    "modules",
    "stdlib",
    "util"
  ],
  "license": "MIT",
  "main": "lodash.js",
  "name": "lodash",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/lodash/lodash.git"
  },
  "scripts": {
    "test": "echo \"See https://travis-ci.org/lodash-archive/lodash-cli for testing details.\""
  },
  "version": "4.17.11"
}</pre><p>역시나 sideEffects 옵션이 없다. lodash의 package.json에 sideEffects:false 옵션을 주고 다시 빌드를 하면 잘 될까?</p><pre class="crayon-plain-tag">sideEffects: false</pre><p>왠지 여전히 트리 쉐이킹이 되지 않는다.</p><pre class="crayon-plain-tag">}, he.debounce = ef, he.defaults = Yf, he.defaultsDeep = Qf, he.defer = uf, he.delay = of , he.difference = so, he.differenceBy = ho, he.differenceWith = po, he.drop = function(n, t, r) {
    var e = null == n ? 0 : n.length;
    return e ? Su(n, (t = r || t === i ? 1 : Mf(t)) &lt; 0 ? 0 : t, e) : []
}, he.dropRight = function(n, t, r) {</pre><p>궁금해서 구글링을 하던 중에 Webpack이 ES Module로 의존성을 관리하는 모듈만 Tree Shaking을 한다는 사실이 갑자기 머릿속에 떠올랐다. 혹시?</p>
<p><a href="https://github.com/lodash/lodash/blob/4.17.11-npm/padEnd.js">https://github.com/lodash/lodash/blob/4.17.11-npm/padEnd.js</a></p>
<p>역시나. <a href="https://github.com/lodash/lodash/blob/4.17.11-npm/padEnd.js" rel="nofollow">lodash-npm</a>는 CommonJS 스펙의 require를 사용한다. 애초에 Tree Shaking 대상이 아닌 것이다. lodash 팀은 lodash-es에는 sideEffects 옵션을 false로 명시했지만, npm 버전의 lodash에는 해당 옵션을 넣지 않았다. 의미가 없으니까.</p>
<p><span style="font-size: 10pt;">(lodash-es의 sideEffect 옵션은 <a href="https://github.com/lodash/lodash/pull/3533/commits/e9384031f6063cbcf7772650731c9984e2d29ca9" rel="nofollow">이 커밋</a>에서 추가되었다)</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content:encoded>
							<wfw:commentRss>https://huns.me/development/2265/feed</wfw:commentRss>
		<slash:comments>1</slash:comments>
							</item>
		<item>
		<title>추상화를 조심스럽게 선택하라</title>
		<link>https://huns.me/development/2252</link>
				<comments>https://huns.me/development/2252#respond</comments>
				<pubDate>Fri, 31 Aug 2018 01:12:42 +0000</pubDate>
		<dc:creator><![CDATA[개발왕 김코딩]]></dc:creator>
				<category><![CDATA[개발 이야기]]></category>
		<category><![CDATA[book]]></category>
		<category><![CDATA[DDD]]></category>
		<category><![CDATA[Review]]></category>
		<category><![CDATA[책]]></category>

		<guid isPermaLink="false">http://huns.me/?p=2252</guid>
				<description><![CDATA[<a href="https://huns.me/development/2252" class="more_link more_link_dots"> &#8230; </a>]]></description>
								<content:encoded><![CDATA[<div>요즘에 <a href="http://www.yes24.com/24/goods/48577718?scode=032&amp;OzSrank=2" target="_blank" rel="noreferrer noopener">&#8220;도메인 주도 설계 핵심(Domain-Driven Design Distilled)&#8221;</a>라는 책을 읽고 읽다. DDD를 주제로 하는 책은 이것까지 총 4-5권은 읽은 것 같다. 그중에 몇 권은 두 세번은 넘게 읽은 듯한데, 볼 때마다 새롭고 어렵다. 알듯하다가도 온라인에서 고수들이 하는 이야기를 듣고 있노라면 아직 내가 DDD를 잘 모르는구나 싶을 때가 종종 있다.</div>
<div>​</div>
<div>이 책은 어려운 주제를 딱딱하게 설명하는 전형적인 재미없는 책이다. 한 가지 다른 책들과 달리, 프로세스 관점에서 이야기를 풀어나가는 점은 흥미로웠다. 책으로는 이해하기 어려웠던 실무 관점의 이야기를 이 책에서 약간이나마 간접 경험을 할 수 있었다.</div>
<div></div>
<div></div>
<p>DDD는 단순한 패턴의 모음이나 설계 기법이 아닌, 개발 전 과정을 관통하는 프로세스를 담고 있다. DDD의 개념을 얼추 이해해도 실무에 적용하기는 쉽지 않았던 것이 그 때문이었을까.​</p>
<p>동료와 설계 논의를 하다 보면 추상화의 수준을 놓고 설왕설래할 때가 많다. 결국 코딩이라는 게 추상화로 시작해서 추상화로 끝나는 것 같다는 생각을 요즘 가끔 한다. 그만큼 추상화는 개발자에게 중요한 문제다. 추상화 수준이 너무 높으면 오버엔지니어링이 되어 비효율을 만들고, 추상화 수준이 너무 낮으면 유지보수가 힘들어진다. 적정 수준을 찾으라는데, 대체 그 적정 수준이란 어느 지점을 말하는 건지. 늘 곤란하다.</p>
<p>DDD는 적정 수준의 기준을 <a href="https://martinfowler.com/bliki/UbiquitousLanguage.html">보편 언어(Ubiquitous Language)</a>에서 찾는다. 물론 만능 키는 아니겠지. 좋은 설계를 고민하는 개발자라면 한 번쯤 읽어볼 만한 내용인 듯해서 한 섹션을 발췌했다.​</p>
<p>​</p>
<div></div>
<div></div>
<div></div>
<div>&#8212;</div>
<div>
<div><span style="font-size: 14pt;"><strong>추상화를 조심스럽게 선택하라</strong></span></div>
<div><span style="font-size: 12pt;">​</span></div>
<div><span style="font-size: 12pt;">효과적인 소프트웨어 모델은 항상 일을 하는 비즈니스의 방식을 고려한 </span><span style="font-size: 12pt;">일련의 추상화에 기반을 두고 있다. </span><span style="font-size: 12pt;">이때 모델링하는 각 개념마다 적절한 수준의 추상화를 선택해야 한다. </span><span style="font-size: 12pt;">만일, 보편 언어와 관련된 가이드를 따른다면 적절한 추상화를 설정할 수 있다. </span><span style="font-size: 12pt;">적어도 모델링 언어의 기반에 지식을 전달해주는 도메인 전문가가 있기 때문에 </span><span style="font-size: 12pt;">훨씬 정확하게 추상화를 모델링할 수 있다.</span></div>
<div><span style="font-size: 12pt;">​</span></div>
<div><span style="font-size: 12pt;">하지만 가끔은 잘못된 문제를 푸는 것에 지나치게 몰두한 나머지, </span><span style="font-size: 12pt;">소프트웨어 개발자가 지나칠 정도로 추상화를 적용하기도 한다. </span><span style="font-size: 12pt;">예를 들면, 애자일 프로젝트 관리 컨텍스트에서의 스크럼 관련 사항을 돌이켜보자. </span><span style="font-size: 12pt;">전에 논의했던 Product, BacklogItem, Release 그리고 Sprint 개념을 모델링하는 것은 타당하다. </span></div>
<div><span style="font-size: 12pt;">​</span></div>
<div><span style="font-size: 12pt;">그렇지만 소프트웨어 개발자가 스크럼의 보편언어를 모델링하는 것에 </span><span style="font-size: 12pt;">그다지 관심을 기울이지 않은 채, </span><span style="font-size: 12pt;">현재와 미래의 모든 스크럼 관련 개념을 모델링하는 것에 </span><span style="font-size: 12pt;">더 많은 관심을 갖고 있다면 어떻게 될까?</span></div>
<div><span style="font-size: 12pt;">​</span></div>
<div><span style="font-size: 12pt;">이런 관점이 계속되면, 개발자들은 ScrumElement, ScrumElementContainer와 같은 개념을 생각해낼 것이다.  </span><span style="font-size: 12pt;">ScrumElement는 Product와 BacklogItem에 대한 현재의 요구를 만족시키고, </span><span style="font-size: 12pt;">ScrumElementContainer는 Release와 Sprint의 명확한 개념을 분명히 표현해줄 것이기 때문이다. </span><span style="font-size: 12pt;">ScrumElement는 typeName 프로퍼티를 가질 것이고, </span><span style="font-size: 12pt;">아마도 그 값은 상황에 맞게 &#8220;Product&#8221;나 &#8220;BacklogItem&#8221;으로 설정될 것이다. </span><span style="font-size: 12pt;">ScrumElementContainer에 대해서도 같은 종류의 typeName 프로퍼티를 설계하고, </span><span style="font-size: 12pt;">이를 &#8220;Release&#8221;나 &#8220;Sprint&#8221;로 설정할 것이다.</span></div>
<div><span style="font-size: 12pt;">​</span></div>
<div><span style="font-size: 12pt;">이런 방식에서 나타나는 여러 문제점들이 보이는가? </span><span style="font-size: 12pt;">여기에는 적지 않은, 그러나 반드시 고려해야 하는 것들이 있다.</span></div>
<div><span style="font-size: 12pt;">​</span></div>
<div><span style="font-size: 12pt;">1. </span><span style="font-size: 12pt;">소프트웨어 모델의 언어가 도메인 전문가의 멘탈 모델과 일치하지 않는다.</span></div>
<div></div>
<div><span style="font-size: 12pt;">​</span><span style="font-size: 12pt;">2. </span><span style="font-size: 12pt;">추상화 수준이 너무 높아서 각 개별적인 형태의 세부 사항을 모델링하기 시작하면 </span><span style="font-size: 12pt;">어려운 상황에 빠질 것이다.</span></div>
<div></div>
<div><span style="font-size: 12pt;">​</span><span style="font-size: 12pt;">3. </span><span style="font-size: 12pt;">이것은 각각의 클래스마다 특수한 경우를 정의할 것이고, </span><span style="font-size: 12pt;">명백한 문제들에 대한 일반적인 접근을 통해 복잡한 클래스 계층 구조를 만들 것이다.</span></div>
<div></div>
<div><span style="font-size: 12pt;">​</span><span style="font-size: 12pt;">4. </span><span style="font-size: 12pt;">우선적으로 중요하지 않은 문제를 해결하려다가 필요한 것보다 훨씬 많은 코드를 생산할 것이다.</span></div>
<div></div>
<div><span style="font-size: 12pt;">​</span><span style="font-size: 12pt;">5. </span><span style="font-size: 12pt;">잘못된 추상화 수준은 심지어 사용자 인터페이스까지 영향을 미쳐 </span><span style="font-size: 12pt;">사용자에게 혼란을 주는 경우도 종종 발생한다.</span></div>
<div></div>
<div><span style="font-size: 12pt;">​</span><span style="font-size: 12pt;">6. </span><span style="font-size: 12pt;">이로 인해 상당한 시간과 비용을 낭비할 수 있다.</span></div>
<div></div>
<div><span style="font-size: 12pt;">​</span><span style="font-size: 12pt;">7.  </span><span style="font-size: 12pt;">프로젝트 초반에 미래의 모든 요구를 생각하고 반영할 수는 없다. </span><span style="font-size: 12pt;">새로운 스크럼 개념들은 앞으로도 계속 추가될 것이고, </span><span style="font-size: 12pt;">기존 모델은 그 요구사항을 예견하는 데 실패할 수밖에 없기 때문이다.</span></div>
<div><span style="font-size: 12pt;">​</span></div>
<div><span style="font-size: 12pt;">이런 잘못된 방식을 따르는 상황이 나타날지 의문을 갖는 사람들도 있겠지만, </span><span style="font-size: 12pt;">이런 <span style="color: #ff00ff;">부적절한 추상화 수준은 기술적인 측면으로 구현을 생각하는 상황에서 자주 등장</span>한다.</span></div>
<div><span style="font-size: 12pt;">​</span><span style="font-size: 12pt;">&#8230;(이하 생략)</span></div>
</div>
<div>​</div>
]]></content:encoded>
							<wfw:commentRss>https://huns.me/development/2252/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
							</item>
		<item>
		<title>3년간의 TDD 인생 회고</title>
		<link>https://huns.me/development/2206</link>
				<comments>https://huns.me/development/2206#comments</comments>
				<pubDate>Sun, 05 Feb 2017 03:16:31 +0000</pubDate>
		<dc:creator><![CDATA[개발왕 김코딩]]></dc:creator>
				<category><![CDATA[개발 이야기]]></category>
		<category><![CDATA[TDD]]></category>
		<category><![CDATA[개발]]></category>
		<category><![CDATA[회고]]></category>

		<guid isPermaLink="false">http://huns.me/?p=2206</guid>
				<description><![CDATA[<a href="https://huns.me/development/2206" class="more_link more_link_dots"> &#8230; </a>]]></description>
								<content:encoded><![CDATA[<div>
<h2>1막</h2>
<p><a href="http://huns.me/wp/wp-content/uploads/2017/02/j39x2xx_8cq-jeremy-yap.jpg"><img class=" wp-image-2209 alignleft" src="http://huns.me/wp/wp-content/uploads/2017/02/j39x2xx_8cq-jeremy-yap-1024x683.jpg" alt="어두운 방에 있는 영사기에서 빛이 새어나오는 사진" width="377" height="251" srcset="https://huns.me/wp/wp-content/uploads/2017/02/j39x2xx_8cq-jeremy-yap-1024x683.jpg 1024w, https://huns.me/wp/wp-content/uploads/2017/02/j39x2xx_8cq-jeremy-yap-300x200.jpg 300w, https://huns.me/wp/wp-content/uploads/2017/02/j39x2xx_8cq-jeremy-yap-768x512.jpg 768w, https://huns.me/wp/wp-content/uploads/2017/02/j39x2xx_8cq-jeremy-yap-600x400.jpg 600w" sizes="(max-width: 377px) 100vw, 377px" /></a></p>
<p>나는 글을 쓸 때, 우선 대충 글의 전체 구조를 완성한 후에 아주 여러 번 마음에 들 때까지 고쳐서 최종본을 완성하는 방식을 선호한다. <span class="se_ff_nanumgothic">주제에 매력을 더 많이 느낄수록 공을 더 많이 들인다.<span class="Apple-converted-space se_ff_nanumgothic"> </span></span><span class="se_ff_nanumgothic">언젠가 한 번은 글을 발행하고 난 후에, 수정 발행을 무려 80번 넘게 한 적도 있었다.</span><span class="se_ff_nanumgothic"> </span>코드를 작성할 때도 비슷하다. 대충 구현해서 의도한 결과를 빨리 만들고, 마음에 들 때까지 수정하기를 반복한다. 언제부터 이런 습관이 생겼는지는 잘 모르겠다. 신입 시절부터 그랬던 것 같은데, 이 과정을 리팩터링이라고 부른다는 사실을 이해한 건 2년 차쯤이다.</p>
<p>리팩터링을 한 후에는 당연히 제품에 문제가 없는지 테스트를 통해 확인한다. 프로젝트 초반에는 테스트하기가 쉽다. 구현한 게 적으니까. 코드량이 많아지면서 운동장 사정이 변한다. 작은 수정에도 얽히는 부분이 많다. 수정하고 나서 확인해야 할 지점이 너무 많다 보니 수동으로 테스트하는 과정이 매우 귀찮아진다. 귀찮아서 꼼꼼하게 테스트하지 않고 일부 과정을 생략했다가 미처 확인하지 못한 오류 때문에 곤혹스러운 경험을 여러 번 했다. 자연스레 테스트 자동화에 관심이 생겼다. 하지만 사후에 테스트를 작성한다는 건 밀린 방학 숙제처럼 지겹고 재미가 없었다. 테스트 작성이 구현과 별개의 과정으로 느껴졌다. 테스트 작성에 회의가 생길 때쯤 TDD를 만났다.</p>
<p>테스트를 먼저 작성한다는 게 이상했다. 이상해서 신기했다. 신기해서 멋있었다. 테스트 작성이 구현 과정과 함께 묶여있다. 테스트 작성을 미루지 않아도 되잖아? 뭔지는 잘 모르겠지만 테스트를 먼저 작성하면 당시 내가 겪는 문제를 해결할 수 있을 것 같았다.<span class="Apple-converted-space"> </span>그렇게 TDD에 입문했지만 책만 가지고 혼자 공부하기가 버거웠다. 배경 지식이 너무 없어서, 도통 무슨 이야기인지 잘 모르겠더라. 사실 테스트가 뭔지도 잘 몰랐다. 그저 관심과 호기심만 가득했다. 그렇게 뭣도 없는 TDD 인생의 1막이 끝났다.</p>
</div>
<div>
<div>
<h2>2막 1장</h2>
<p>2013년 즈음이었나, 선배 개발자 형한테 짝 코딩으로 TDD를 배울 기회가 있었다. 제대로 배워보려고 당시에 학습한 내용을 블로그에 글로 쓰면서 TDD 인생 2막을 열었다. 열심히 쓰다가 귀차니즘이 돋아서 시리즈를 마지막까지 완성하지 못한 게 아쉽다. 어쨌든 이날의 경험을 짧은 내 개발자 인생에서 가장 짜릿했던 일로 꼽는다.</p>
<ul>
<li><a href="http://huns.me/development/716">도전 JavaScript TDD &#8211; 1.시작</a></li>
<li><a href="http://huns.me/development/823">도전 JavaScript TDD &#8211; 2. TDD 리듬</a></li>
<li><a href="http://huns.me/development/939">도전 JavaScript TDD &#8211; 3. 점진적 명세 작성</a></li>
</ul>
<p>2막을 열고 올해로 3년째지만, 정작 실전에서 프로젝트 막판까지 TDD를 놓지 않았던 건 불과 한 달 전이다. 프로젝트 초반에는 항상 테스트를 열심히 작성하지만 코드가 조금만 복잡해지면, 관리를 못 해서 허둥대다가 모든 게 망가졌다. 테스트는 복잡했고, 어려웠다. 일정에 쫓겨서 마음이 급해지면 가장 먼저 테스트를 생략했다. 약간만 코드를 수정해도 빨간색으로 징징거리는 테스트 코드가 되려 짐처럼 느껴졌다. 관리하지 못한 테스트는 결국 방치되다가 버려졌다.</p>
</div>
<div>
<div>
<div>
<div>
<div>
<div>
<p>TDD가 좋은 설계를 유도한다는 글을 많이 봤지만 내 설계는 조금도 나아지지 않았다. 답답했다. 그때는 몰랐다. TDD가 좋은 설계를 보장하지 않는다는 사실을. 망가진 테스트가 높은 커버리지를 보여주는 것도 웃겼다. 정작 별거 아닌 버그도 못 잡아내는 녀석인데. 그렇게 알쏭달쏭한 2막을 보냈다.</p>
<p>그럼에도 끊임없이 TDD를 시도했다. 지금 생각해보면 TDD를 배우고자 하는 동기가 강했다. 코드 품질에 관심이 많았던 터라, 코드를 변경할 때마다 안전을 보장해 줄 장치가 필요했다. <b>TDD를 절대로 신뢰해서가 아니라, 다른 대안을 찾지 못 해서 매달렸다</b>.</p>
<p>재미있게도 매번 실패하면서도 배우는 게 있었는데, 이 과정에서 조금씩 나아지는 느낌을 받았다. 그게 날 자극했다. 단위 테스트 작성에 대한 경험치가 쌓였다. 명세를 어떻게 작성할지 고민하면서 코딩하기 전에 문제를 먼저 정의하는 습관이 생겼다. 디버깅을 하는 요령이 생기면서 버그를 찾는 시간이 짧아졌다. 공용 인터페이스를 중심으로 객체를 설계하는 방식에 익숙해졌다. 테스트 코드와 구현 코드 사이의 의존성을 고민하면서, 부분의 문제를 해결한 후 전체 구조를 생각하는 과정이 자연스러워졌다. 무엇보다 리팩터링에 자신감이 붙었다.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div>
<h2>2막 2장</h2>
<p>그래서 지금은 TDD를 잘하느냐고 묻는다면 그렇지는 않다. 그동안 TDD에 투자한 비용을 이제야 조금씩 회수하고 있다는 느낌을 받는 정도랄까. 아직도 의식하고 행하지 않으면 구현 코드로 손이 먼저 간다. 아직도 명세를 작성하는 스타일이 자리를 잡지 못했다. 여전히 마음이 급해지면 테스트를 오지 않을 ‘나중’으로 미룬다. 그와중에 빈도가 줄었다는 건 좋은 일.</p>
<p>단위 테스트 자동화로 리팩터링에 자신감이 붙었지만, 역으로 테스트가 리팩터링에 장애물처럼 느껴질 때가 가끔 있다. 문제의 근본이 테스트 코드와 구현 코드 간의 의존성, 그리고 리팩터링 진행 방식에 있다는 걸 마틴 파울러의 <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=7047630">“리팩터링”</a>을 읽고 나서야 깨달았다. 나는 마구잡이로 리팩터링하는 좋지 않은 습관을 가지고 있었고 테스트는 내가 가지고 있는 문제를 알려줬을 뿐이다.</p>
</div>
<div>
<div>
<div>
<div>
<div>
<div>
<p>여전히 TDD를 ‘수련&#8217;하고 있다. ‘수련’이라는 표현에는 <b>&#8216;끊임없는 연습을 통해서 지속적인 향상을 추구’</b>한다는 의미가 담겨있다. 쉽게 얻을 수 없다는 뜻이 묻어있다. 쉽게 얻을 수 있다면 끊임없이 연습을 할 이유가 없으니까.</p>
<p>TDD를 향해 나아가는 길은 꽤나 더디고 지루하지만, 이 과정에서 얻는 열매는 분명 달콤하다. 이런 사실을 잘 모르고 덤빈다면 TDD의 매력을 맛보기도 전에 나락으로 떨어지기 십상이다. 내가 계속 실패하면서도 아직까지 TDD를 붙잡고 있을 수 있었던 이유는 동기가 분명해서다. 지속적으로 리팩터링하고 싶은 간절함, 뭐 그런 거. 그렇지 않았다면 TDD 적응에 처음 몇 번 실패했을 때, TDD를 욕하며 돌아서지 않았을까?</p>
<p>TDD를 통해서 좋은 경험을 하고 있음에도, 쉽사리 주변에 권장은 하지 않는 편이다. 단지 TDD에 대해서 물어오면 대답해주는 정도가 내가 반응하는 경계선이다. 동기라는 건 강제할 수 있는 게 아니거니와, 내가 완성하지 못한 지식을 누군가에게 강요한다는 게 조금 께름칙하기도 하고.</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div>
<h2>3막으로</h2>
<p>지난주에는 TDD에 관심있는 동료들과 짝 코딩을 했다. 참여 인원은 5명. 짝 코딩이라기보다는 떼 코딩이 적절하겠다. TDD에 대한 생각을 손과 입으로 누군가에게 전달하려다 보니 좀 더 깊은 영역을 고민하게 되더라. 옆에서 길을 안내하는 입장으로서, 가능한 동료의 생각을 간섭하지 않으려 했는데 아주 많이 인내해야 했다. 나에게 TDD를 알려 준 선배 개발자 형의 당시 심정을 짐작할 수 있어서 작은 웃음이 나왔다. 나의 인내력은 그 형에 한참 못 미쳤다.</p>
<p>집에서는 작성한지 3년쯤 지난 <a href="https://github.com/CoderK/Huntris">레거시 코드</a>에 테스트를 보완해서 리팩터링하고, 추가 기능을 TDD로 확장해나가는 연습을 하고 있다. 일종의 테스트 연습장인 셈이다.</p>
<p>한 발 나간다. 뒤를 돌아본다. 문제가 있다. 고친다. 다시 한 발 나간다. 반복. 마치 누군가의 인생 여정처럼. 그렇게 나의 TDD 인생도 2막에서 3막으로 무르익어 간다.</p>
</div>
<p>&nbsp;</p>
]]></content:encoded>
							<wfw:commentRss>https://huns.me/development/2206/feed</wfw:commentRss>
		<slash:comments>1</slash:comments>
							</item>
		<item>
		<title>유지보수는 쉬운 일이 아닙니다</title>
		<link>https://huns.me/development/2183</link>
				<comments>https://huns.me/development/2183#respond</comments>
				<pubDate>Thu, 26 Jan 2017 15:53:16 +0000</pubDate>
		<dc:creator><![CDATA[개발왕 김코딩]]></dc:creator>
				<category><![CDATA[개발 이야기]]></category>
		<category><![CDATA[개발자]]></category>
		<category><![CDATA[레거시]]></category>
		<category><![CDATA[로버트 L. 글래스]]></category>
		<category><![CDATA[소프트웨어]]></category>
		<category><![CDATA[유지보수]]></category>

		<guid isPermaLink="false">http://huns.me/?p=2183</guid>
				<description><![CDATA[<a href="https://huns.me/development/2183" class="more_link more_link_dots"> &#8230; </a>]]></description>
								<content:encoded><![CDATA[<div>
<p><a href="http://huns.me/wp/wp-content/uploads/2017/01/business-1839876_1920.jpg"><img class="alignleft wp-image-2186" src="http://huns.me/wp/wp-content/uploads/2017/01/business-1839876_1920-1024x683.jpg" alt="맥북 위에 핸드폰이 올려져있고, 하얀 노트가 좌측에 놓여있는 사진" width="347" height="231" srcset="https://huns.me/wp/wp-content/uploads/2017/01/business-1839876_1920-1024x683.jpg 1024w, https://huns.me/wp/wp-content/uploads/2017/01/business-1839876_1920-300x200.jpg 300w, https://huns.me/wp/wp-content/uploads/2017/01/business-1839876_1920-768x512.jpg 768w, https://huns.me/wp/wp-content/uploads/2017/01/business-1839876_1920-600x400.jpg 600w" sizes="(max-width: 347px) 100vw, 347px" /></a></p>
<p>가끔 소프트웨어 유지보수는 신규 개발보다 쉬워서, 어렵지 않게 할 수 있는, 지루한 일이라는 이야기를 들을 때가 있다. 유지하고 보수하는 일이 개인의 성향과 맞지 않아 지루할 수 있다고는 생각하지만, 쉬운 일이라는 데에는 몇 가지 이유로 동의하지 않는다.</p>
<p>레거시 코드를 유지보수할 때는 아주 작은 부분마저도 쉽게 고치기 어렵다. 코드의 정글을 지나, 어렵게 문제의 심장부로 보이는 곳까지 찾아갔지만 눈앞에는 마치 영화 속 시한폭탄처럼 알 수 없는 빨간 줄, 노란 줄, 파란 줄이 놓여있다. 고민하다가 파란 줄을 잘랐다.  여기저기서 오류가 터진다. 사이드 이펙트가 찾아왔다. 자동화된 테스트라도 있으면 좋으련만, 그마저도 없다면 이때부터는 &#8216;웰컴 투 더 헬’이다. 그래서 레거시에 뭔가를 추가하거나 수정하는 작업은 새로운 코드를 작성할 때 보다 더 예민하고 넓은 시야로 코드를 봐야 한다. 한 마디로 어렵다는 소리.</p>
<p>유지보수할 때는 창의력을 발휘하기도 어렵다. 기존의 체계가 생각을 제약한다. 제약을 더 많이 받기 때문에 더 많은 창의력이 필요하지만, <b>생각을 강하게 제약하는 체계 안에서 새로운 해법을 찾는다는 건 결코 쉬운 일이 아니</b><b>다</b>. 이런 환경을 즐기는 성향이 아니라면 미치고 팔짝 뛸 만한 상황이다. 그만큼 수고롭다. 간단하게 할 수 있는 일을 멀리 돌아가는 느낌 또한 유쾌하지 않다.<span class="Apple-converted-space"> </span>기존 체계가 깔끔하고 유연하다면 참 좋으련만, 그런 레거시 코드는 보이지 않는다. 그래서 우리는 보통 레거시라는 단어에, 오랜 세월 쌓이고 쌓여 딱딱하게 굳어져 이제는 어쩔 수 없는 녀석이란 의미를 담는다.</p>
</div>
<div>
<div>
<p class="p1">로버트 L. 글래스는 자신이 저서인 &#8216;<a href="http://www.yes24.com/24/goods/3406730?scode=032&amp;OzSrank=2">소프트웨어 크리에이티비티</a>&#8216;에서, <b>“소프트웨어 제작이라는 복잡한 세상에서 (위반해서는 안 되는 체계적인 제약을 받으며 창의력을 발휘하는) 유지보수보다 더 복잡한 활동은 없으리라 생각한다&#8221;</b>라고 했다. 유지보수는 이처럼 어렵고, 많은 비용을 필요로하는 활동이다.<span class="Apple-converted-space"> </span></p>
<p>그래서 유지보수하기 좋은 코드를 작성하는 일은 사업적 측면과 무관하지 않다.<b> </b>요즘처럼 변경이 상수인 시대에 잦은 변경을 받아들일 수 없어서, 소프트웨어를 재개발해야 한다면 회사는 큰 비용을 치러야만 한다.<span class="Apple-converted-space"> </span>클린 코드나 테스트 자동화가 이야기하는 가치는 결코 사업 그 자체와 동떨어져 있지 않다.<span class="Apple-converted-space"> </span>그런 의미에서<b> 더 나은 코드를 찾아 끊임없이 고민</b>하는 일은 내일의 나, 너, 팀, 그리고 회사까지, 관련 있는<span class="Apple-converted-space"> </span><b>모두를 위한 배려이자 직업 개발자의 의무</b>가 아닐까.<span class="Apple-converted-space"> </span></p>
<p><span class="Apple-converted-space">글을 쓰다보니 유지보수를 가볍게 생각하는 사람은 클린 코드나 테스트 자동화가 말하는 가치에 공감하기는 어렵겠다는 생각이 스친다.<br />
</span><span class="Apple-converted-space"><br />
</span><span class="Apple-converted-space">아, 그렇구나. 그런 거였어.</span></p>
</div>
<p>&nbsp;</p>
</div>
]]></content:encoded>
							<wfw:commentRss>https://huns.me/development/2183/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
							</item>
		<item>
		<title>정신과 시간의 방, 그리고 실용주의 프로그래머</title>
		<link>https://huns.me/development/2159</link>
				<comments>https://huns.me/development/2159#comments</comments>
				<pubDate>Thu, 29 Dec 2016 13:28:52 +0000</pubDate>
		<dc:creator><![CDATA[개발왕 김코딩]]></dc:creator>
				<category><![CDATA[개발 이야기]]></category>

		<guid isPermaLink="false">http://huns.me/?p=2159</guid>
				<description><![CDATA[<a href="https://huns.me/development/2159" class="more_link more_link_dots"> &#8230; </a>]]></description>
								<content:encoded><![CDATA[<p>요즘은 회사에서 매일 4~5시간씩 동료들과 설계 회의를 하고 있다. 내년에 있을 큰미션을 준비하기 위해서다. 하루에 두 시간 정도만 회의를 해도 녹초가 되기 일쑤인데 하루 반나절, 그 이상을 줄기차게 떠든다는 게 여간 힘든 일이 아니다.</p>
<p><img class="alignright wp-image-2160" src="http://huns.me/wp/wp-content/uploads/2016/12/v3bwnxeinqa-liane-metzler-1024x683.jpg" alt="하얀 건물에 하얀 계단이 어지럽게 꼬여있는 사진" width="400" height="267" srcset="https://huns.me/wp/wp-content/uploads/2016/12/v3bwnxeinqa-liane-metzler-1024x683.jpg 1024w, https://huns.me/wp/wp-content/uploads/2016/12/v3bwnxeinqa-liane-metzler-300x200.jpg 300w, https://huns.me/wp/wp-content/uploads/2016/12/v3bwnxeinqa-liane-metzler-768x512.jpg 768w, https://huns.me/wp/wp-content/uploads/2016/12/v3bwnxeinqa-liane-metzler-600x400.jpg 600w" sizes="(max-width: 400px) 100vw, 400px" />긴 회의를 마치고 <b>&#8216;정신과 시간의 방&#8217;</b>에서 나올 즈음이면 심신이 시루떡이다. 시간도 시간이지만, 논쟁을 해야 하는 문제의 성격이 우리를 더 지치게 만든다. 대부분이 과학적 증명보다는 <b>가치 판단</b>의 문제에 가깝다. 답이 없다. 철학과 개발이 맞닿은 지점을 어렴풋이 본다. 이런 거구나.</p>
<p>뭐든 내 맘 같지 않음이 당연하다는 걸 알면서도 누군가와 생각을 놓고 줄다리기하는 과정이 대단히 피곤한 건 어쩔 수 없다. 내 철학을 포기하는 건 쉬운 일이 아니지만 분명한 근거를 바탕으로 상대를 설득하지 못했다면 내가 아는 것들을 의심해보는 게 옳다. 차라리 한 수 접고 더 공부할 수 있는 원동력으로 삼는 게 현명한 길이고, 포기함으로써 성장하는 느낌은 즐겁다. 소주 한 잔을 마시고 떠먹는 아이스크림처럼 달콤 쌉싸래하다.</p>
<p><b>실재 없는 이론의 나열은 허상</b>이라는 걸 몸으로 느낀다. 패턴이나 설계 원칙을 설명하라면 유창하지는 않아도 허접하지 않게 설명할 수 있다. 하지만 안다고 제품에 녹일 수 있는 것도 아니거니와, 실재하는 사례가 곁들여지지 않은 주장은 무뎌서 날이 서지 않는다. 문제는 정작 중요한 순간에는 경험한 사례가 잘 떠오르질 않는다는 점이다. 코드 베이스가 커져서 복잡해지고 나서야 문제가 발생하기에 간단한 코드로 재현하기도 어렵다. 평소에 이슈를 만났을 때 상황과 원인을 잘 메모해서 모아두지 못한 게 아쉽다.</p>
<p><img class="alignleft wp-image-2161" src="http://huns.me/wp/wp-content/uploads/2016/12/s_vbdmtsdia-mike-erskine-1024x683.jpg" alt="어두운 밤, 산에 캠핑온 사람들이 모닥불을 피워놓고 둘러 앉아 있는 모습" width="400" height="267" srcset="https://huns.me/wp/wp-content/uploads/2016/12/s_vbdmtsdia-mike-erskine-1024x683.jpg 1024w, https://huns.me/wp/wp-content/uploads/2016/12/s_vbdmtsdia-mike-erskine-300x200.jpg 300w, https://huns.me/wp/wp-content/uploads/2016/12/s_vbdmtsdia-mike-erskine-768x512.jpg 768w, https://huns.me/wp/wp-content/uploads/2016/12/s_vbdmtsdia-mike-erskine-600x400.jpg 600w" sizes="(max-width: 400px) 100vw, 400px" />개발자는 역시 <b>코드로 말하는 게 제일</b>이다. 긴 논의를 거쳐 서로의 생각이 일치했다고 동의하고 고개 끄덕이는 순간조차도 머릿속에 다른 그림을 그리는 경우가 흔하다. 노트북을 꺼내서 짝코딩으로 얼른 간단한 코드 조각을 만들고 리뷰하니 커뮤니케이션이 훨씬 명확해졌다. 입은 짧게 털고, 코딩은 조금 길게. 그게 실용적이다.</p>
<p>내가 하는 일이 <b>고도의 사회 활동</b>(맞는 표현인지는 잘 모르겠지만 뜻은 통하겠지)이라는 사실을 깨달아 가고 있다. 2년 전까지만 해도 나에게 개발은 그저 나 자신과의 싸움이었다. 많은 동료, 여러 부서와 협업을 해야 하는 조직에 합류하고 난 뒤 경험치가 쌓이면서 내 일을 바라보는 나 자신의 관점이 많이 변했다는 걸 느낀다. 그저 ‘좋다’는 느낌적 느낌이나, 바다 건너 이름 모를 누군가의 깨알 같은 사례를 공유하는 걸로는 아무것도 할 수 없다. 모두가 같이 이해하고, 같이 느낄 수 있어야 한다. 요즘 <b>‘콘텍스트’</b>라는 단어를 머리에 달고 산다.</p>
<p>전체의 일부가 된다는 건 여러모로 쉬운 일이 아니지만 내년에는 이런 일도 잘하는 나이고 싶다. 애자일한, <b>실용주의 프로그래머</b>, 뭐 그런 엔지니어 말이다.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content:encoded>
							<wfw:commentRss>https://huns.me/development/2159/feed</wfw:commentRss>
		<slash:comments>1</slash:comments>
							</item>
		<item>
		<title>MS는 ReactiveX를 왜 만들었을까? (feat. RxJS)</title>
		<link>https://huns.me/development/2051</link>
				<comments>https://huns.me/development/2051#respond</comments>
				<pubDate>Fri, 09 Sep 2016 04:26:01 +0000</pubDate>
		<dc:creator><![CDATA[개발왕 김코딩]]></dc:creator>
				<category><![CDATA[개발 이야기]]></category>
		<category><![CDATA[rx]]></category>
		<category><![CDATA[rxjs]]></category>
		<category><![CDATA[리액티브 프로그래밍]]></category>

		<guid isPermaLink="false">http://huns.me/?p=2051</guid>
				<description><![CDATA[<a href="https://huns.me/development/2051" class="more_link more_link_dots"> &#8230; </a>]]></description>
								<content:encoded><![CDATA[<p>&nbsp;</p>
<p><figure id="attachment_2123" aria-describedby="caption-attachment-2123" style="width: 325px" class="wp-caption alignleft"><a href="http://huns.me/wp/wp-content/uploads/2016/09/ngrx.png"><img class="wp-image-2123" src="http://huns.me/wp/wp-content/uploads/2016/09/ngrx.png" alt="컨퍼런스에서 ngrx를 주제로 발표하는 남자의 사진" width="325" height="148" srcset="https://huns.me/wp/wp-content/uploads/2016/09/ngrx.png 871w, https://huns.me/wp/wp-content/uploads/2016/09/ngrx-300x137.png 300w, https://huns.me/wp/wp-content/uploads/2016/09/ngrx-768x350.png 768w" sizes="(max-width: 325px) 100vw, 325px" /></a><figcaption id="caption-attachment-2123" class="wp-caption-text">angular2와 rx의 만남이라!</figcaption></figure></p>
<p>요즘 웹 프론트엔드 분야에서 재밌는 주제를 하나 꼽자면, RxJS가 떠오른다. 그 동안 웹 프론트엔드 쪽에서는 큰 관심을 못 받던 기술이었는데 최근에 RxJS와 관련한 이야기가 솔솔 나오는 이유는 Angular2가 RxJS를 기본으로 탑재한 덕인 것 같다.</p>
<p>내가 RxJS를 처음 알게 된 건 React 커뮤니티를 통해서였다. 이미 Angular2 등장 이전부터 React 커뮤니티에서는 React와 Rx를 결합하려는 시도가 있었다. 그래서 Rx를 가볍게 훑어본 적이 있었는데 언뜻 보기에 옵저버 패턴으로 이벤트를 바인딩하는 API를 제공하는 라이브러리 정도로 보였다. 별로 새로울 게 없다고 그냥 넘겼더랬다. 사실 그땐 사는 게 너무 바빠서 뭘 깊게 들여다 볼 여유가 없었다. 그렇게 Rx는 내 머리에서 잊혔다. 시간이 흐르고, 내 삶에 여유가 조금 찾아왔다. 마침 Angular2도 찾아오셨다.</p>
<p>응?</p>
<p>그런데 Angular2가 Rx를 달고 나왔네? Angular2는 Rx를 뭐에 쓰는 거지? 궁금했다. 소문에 의하면 Redux한테 반기를 들고 나온 Cycle.js는 Rx 비슷한(xstream) 무언가로 모든 건 스트림이네, 어쩌네 하는 소리를 떠들고 다닌다던데, 이건 또 뭐람? 궁금했지만 애써 들여다보고 싶지는 않았다. 귀찮았으니까. 그런데 때마침 지인들이 Rx를 스터디를 한다길래 살포시 숟가락 하나 얹었다.</p>
<p><a href="http://reactivex.io/intro.html" rev="en_rl_small">http://reactivex.io/intro.html</a></p>
<p>공식 사이트부터 들어가 봤다. 예제 코드 좀 훑어보고, 소개 글을 읽었다. 여기에 나와있는 설명 그대로, Rx는 <strong>비동기 데이터 스트림을 처리</strong>하는 API를 제공하는 라이브러리다.</p>
<p>그렇군. 어려운 단어는 없는데 뭔지는 잘 모르겠다. 그런데 리액티브 프로그래밍(Reactive Programming, RP), 함수형 리액티브 프로그래밍(Functional Reactive Programming, FRP), LINQ(Language-Intergrated Query), 얘네들은 다 뭐람? 들어본 적은 있으나, 설명을 못하겠는 걸 보니 모르는 게 분명하다. 너무 궁금하다. 내 성격에 이걸 이해 못하면 코드 한 줄도 못 짤 분위기다.</p>
<p>Rx를 만든 배경을 조사해보면, 개념이 좀 명확해지지 않을까? 그래서 Rx의 역사를 찾아 뒤를 캐봤다.</p>
<h2><b>Rx(ReactiveX)의 어제</b></h2>
<p>하지만 Rx의 역사를 찾는 일은 쉽지 않았는데, 매끄럽게 정리되어 있는 글을 도통 찾을 수가 없었다. 할 수 없이 인터넷에 떠도는 솜털 구름 같은 정보들을 찾아서 하나씩 가내수공업으로 이어 붙였다. 모호한 이야기가 많아서 이마저도 쉽지 않았다. 어떤 내용은 기사에 달려있는 댓글을 하나씩 읽어서 상황을 유추해야만 했다. 유물 찾으러 다니는 고고학자의 기분이 이런 걸까.</p>
<p>그렇게 디지털 공간을 헤메고 다니다가 Volta라는 녀석에게서 흥미로운 냄새를 맡았다.</p>
<h4><b>2007년 12월, Live Labs Volta</b></h4>
<p>때는 2007년.</p>
<p>MS의 인터넷 제품과 서비스 연구 조직이었던 Live Labs는 Volta라는 프로젝트를 발표한다. Volta는 지금은 흔적만 남아있는 프로젝트로, 정보의 바다라는 인터넷에서도 Volta에 대한 정보는 찾기 어렵다. 어렵게 수집한 정보를 토대로 Volta를 설명해보자면, <strong>다양한 기술을 하나의 플랫폼 안에서 실행할 수 있는 환경을 제공</strong>함으로써 기술 습득 비용을 줄이이는 것을 목적으로 하는 프로젝트라고 할 수 있다.</p>
<p>지금의 GWT(Google Web Toolkit)와 유사하다. 다른 점은 Java로 작성한 코드를 JavaScript로 변환하는 한정적인 범위를 처리하는 GWT와 다르게 Volta는 좀 더 광범위(many to many)한 환경에 대응하려는 기술이었다는 점이다. Volta를 만든 에릭 마이어는 이를 GWT와 Volta는 사과와 오렌지의 차이와 같다고 표현했다. 같은 과일이지만 겉과 속이 다르다는 뜻이다.</p>
<p>Volta 프로젝트는 갑작스레 어떤 이유로 중단되었고, 아직까지도 부활하지 못했다. 아래의 몇몇 기사를 통해 Volta의 대략적인 컨셉은 살펴볼 수 있었다.</p>
<ul>
<li><a href="http://Microsoft architect compares Volta and Google's GWT">Microsoft architect compares Volta and Google&#8217;s GWT</a></li>
<li><a href="http://www.zdnet.co.kr/news/news_view.asp?artice_id=00000039164019">MS, 웹 애플리케이션 개발 킷「볼타」릴리스</a></li>
<li class="entry-title"><a href="https://blogs.msdn.microsoft.com/bkchung/2007/12/06/microsoft-live-labs-volta-ctp/">Microsoft Live Labs의 Volta 프로젝트 CTP</a></li>
<li><a href="http://blog.lemonbrain.net/21">진정한 웹다중Tier개발의 시작? VOLTA플랫폼</a></li>
</ul>
<p>개발자가 특정 어노테이션을 이용하여 코드를 작성하면, .NET 언어와 라이브러리/개발도구를 이용해서 MSIL로 컴파일한다. 그러면, MSIL 안에 있는 어노테이션을 Volta가 해석해서 다양한 환경에서 실행할 수 있는 보일러 플레이트 코드를 삽입한다. 이렇게 만들어진 MSIL을 브라우저에서 실행한다. 대략 이런 개념이다.</p>
<p>한편, Rx와 Volta의 관계에 대한 비밀은 로고에 있다. 두 녀석의 로고가 똑같다.</p>
<p><a href="http://huns.me/wp/wp-content/uploads/2016/09/voltal-and-reactivex.png"><img class="왼쪽에는 Volta의 로고, 오른쪽은 ReactiveX의 로고 사진. 둘의 로고가 같다. aligncenter wp-image-2125 size-full" src="http://huns.me/wp/wp-content/uploads/2016/09/voltal-and-reactivex.png" alt="volta와 reactivex의 로고. 둘의 로고가 같다." width="897" height="295" srcset="https://huns.me/wp/wp-content/uploads/2016/09/voltal-and-reactivex.png 897w, https://huns.me/wp/wp-content/uploads/2016/09/voltal-and-reactivex-300x99.png 300w, https://huns.me/wp/wp-content/uploads/2016/09/voltal-and-reactivex-768x253.png 768w" sizes="(max-width: 897px) 100vw, 897px" /></a></p>
<p>이는 Rx가 Volta에서 시작되었기 때문이다. Volta는 사라졌지만, 개발팀은 프로젝트의 일부를 Reactive Framework라는 프로젝트로 분리하여 계속 개발을 진행하였는데, 이게 훗날의 Rx다.</p>
<p>정확히 당시에 어떤 문제를 해결하기 위해서 Reactive Framework를 만들었는지는 알 수 없다. 다만 JavaScript와 같은 이벤트 기반의 동적 언어와 C# 같은 정적 언어 간의 코드 호환성을 맞추려다보면 필연적으로 비동기 로직을 쉽게 처리할 수 있는 방법을 고민했을 것이고, 이를 해결하는 과정에서 Reactive Framework를 만들지 않았을까?</p>
<p>그저 추측이지만 완전히 근거 없는 소리는 아니다. Rx를 주제로 에릭 마이어가 한 인터뷰에서 Rx를 만든 이유가 비동기 프로그래밍에 있다는 사실을 유추할 수 있다.</p>
<blockquote><p>&#8220;Of all the work I’ve done in my career so far, this is the most exciting. […] I know it’s a bold statement, but I really believe that the problem of asynchronous programming events has been solved.&#8221;</p>
<p id="ph_pcontent3_0_MainHeading" class="title"><a href="https://campustechnology.com/articles/2009/08/10/microsofts-new-.net-rx-framework-tackles-challenges-of-asynchronous-programming.aspx">Microsoft&#8217;s New .NET Rx Framework Tackles Challenges of Asynchronous Programming</a></p>
</blockquote>
<h4><b>2009. 11. 17, Reactive Extensions for .NET의 첫 릴리즈</b></h4>
<p>Volta에서 떨어져 나온 Reactive Framework는 2009년에 Reactive Extensions로 이름을 바꾸고, 아래의 세 가지 버전의 Rx를 공식 출시한다.</p>
<ul>
<li>Reactive Extensions For .NET 3.5 Sp1</li>
<li>Reactive Extensions For .NET 4 beta 2</li>
<li>Rx for Silverlight3</li>
</ul>
<p>우리가 아는 Rx의 첫 등장이다. 하지만 이 당시 Rx는 오픈 소스가 아니었다.</p>
<p><a href="https://blogs.msdn.microsoft.com/rxteam/2010/10/28/release-notes/">ReactiveX Release Notes</a></p>
<p>출시 이전까지 사람들은 Reactive Framework라는 코드명을 줄여서 Rx라고 불렀다. 에릭 마이어 또한 Reactive Framework라는 이름으로 개발, 교육, 홍보를 했는데 정작 릴리즈 당시의 제품명은 Reactive Extensions For .NET였다. 이름이 바뀐 자세한 맥락은 알 수 없으나, <a href="https://channel9.msdn.com/Shows/Going+Deep/E2E-Erik-Meijer-and-Wes-Dyer-Reactive-Framework-Rx-Under-the-Hood-1-of-2" rev="en_rl_minimal">이 글</a>에 있는 <a href="https://twitter.com/Carmine007" rev="en_rl_minimal">Charles Torre</a>라는 사람의 댓글을 통해 그 이유를 유추해 본다.</p>
<p>.NET 자체가 프레임워크였기 때문에 Reactive Framework라는 이름은 사용자에게 혼란을 초래할 수 있다. Rx라는 명칭을 그대로 유지하면서, 사용자의 혼란을 줄이고 .NET 프레임워크를 확장한다는 의미를 더해줄 수 있는 Reactive Extensions라는 이름은 어떨까?</p>
<p>그럴듯하다.</p>
<h4><b>2010. 03. 17, RxJS 첫 릴리즈</b></h4>
<p>MS는 이듬해 3월에는 Rx의 JavaScript 버전인 RxJS를 공개한다.</p>
<p>웹 프론트엔드 UI가 화려하고 복잡해지면서 AJAX 기술의 비중이 높아지던 시점이다. 비동기 행위를 쉽게 처리할 수 있는 방법이 필요했다. RxJS가 만들어질 당시에는 JavaScript의 콜백 지옥을 완화할 Promise 같은 마땅한 대체 기술(Promises/A+가 처음 나온 게 2012년 12월 6일)이 없었다는 점을 생각해보면 RxJS의 등장은 감격스럽다.</p>
<p>하지만 당시에 JavaScript 개발자들한테 큰 호응을 얻지는 못한 것 같다. 이유는 잘 모르겠으나, RxJS는 어렵고 낯선 기술이 아니었을까? 아니면 RxJS를 사용해야 할 정도의 문제를 겪고 있는 프로젝트가 많지 않았다든지. 그러고 보면 콜백 지옥 문제가 큰 화두로 등장한 건, node.js가 대중적인 인기를 끌면서부터 였던 것 같다.</p>
<p>(사실 요즘 Rx를 공부하면서 Rx가 인기를 얻지 못한 이유에 대해서 몇 가지 생각을 정리했지만 이 글의 주제는 아니므로 다음을 기약한다)</p>
<h4><b>2012. 11. 06, ReactiveX, 오픈 소스로</b></h4>
<p>드디어 2012년 11월에 <a href="http://www.hanselman.com/blog/ReactiveExtensionsRxIsNowOpenSource.aspx">MS는 Rx의 세 가지 버전인, Rx .NET, RxJS, Rx++을 오픈 소스로 공개</a>한다. RxJava를 알고 있는 사람들이 많을 텐데, <a href="https://github.com/ReactiveX/RxJava/wiki">RxJava</a>는 넷플릭스에서 만들어서 공개한 버전이다.</p>
<h2><b>Rx는 어떻게 문제를 해결하는가?</b></h2>
<p>앞에서 Rx의 탄생 배경이 비동기 프로그래밍 문제를 해결하는 데 있다고 했다. 비동기 프로그래밍은 어렵다. 비동기 코드가 많아지면 제어의 흐름이 복잡하게 얽혀 코드를 예측하기 어려워진다. 따라서 전통적인 절차적 프로그래밍으로는 이 문제를 풀기가 쉽지 않다.</p>
<p>그렇다면 Rx는 어떻게 비동기 프로그래밍 문제를 해결한다는 걸까? 이제부터 Rx가 제안하는 대안을 알아보자. 핵심 키워드는 리액티브 프로그래밍과 LINQ다.</p>
<h4><b>리액티브 프로그래밍</b></h4>
<p>소프트웨어를 둘러싼 요즘의 환경은 과거와 많이 달라졌다. 인터넷 환경이 발달하면서 트래픽이 전에 비해 엄청나게 증가하였고, 무어의 법칙은 한계에 도달했다. 멀티 코어 프로세서에서 대안을 찾기 시작하면서 동시성 프로그래밍이 중요해졌다. 클라우드 컴퓨팅 환경도 등장했다. 사용자 요구사항은 점점 까다로워져 더 정교하고 화려한 UI 인터랙션과 더 빠른 반응 속도를 요구한다. 전에 비해 훨씬 복잡해진 소프트웨어의 안정성은, 언제나 중요한 문제다.</p>
<p>리액티브  매니페스토는 이 시대의 소프트웨어는 좋은 반응성(Responsive)을 가져야 하며, 좋은 반응성을 갖기 위해 회복탄력성(Resilient)과 유연성(Elastic)을 갖도록 시스템을 설계해야 한다고 주장한다. 이를 달성할 수 있는 방법으로 메시지(Message-Driven)로 시스템과 시스템, 모듈과 모듈을 연결하는 방법을 제안한다. 결국 비동기 처리를 적극 활용하는 데에서 문제의 해법을 찾는다.</p>
<blockquote>
<div><i>&#8220;Reactive Systems rely on asynchronous message-passing to establish a boundary between components that ensures loose coupling, isolation and location transparency.&#8221;</i></div>
<p><i><a href="http://www.reactivemanifesto.org/">The Reactive Manifesto</a></i></p></blockquote>
<p>이런 흐름은 자연스레 리액티브 프로그래밍에 대한 개발자들의 관심으로 이어졌다. 위키에 나와있는 리액티브 프로그래밍의 정의는 이렇다.</p>
<blockquote><p>데이터 플로우와 상태 변경을 전파한다는 생각에 근간을 둔 프로그래밍 패러다임</p>
<p><a href="https://en.wikipedia.org/wiki/Reactive_programming">Reactive Programming in Wikipedia, The Free Encyclopedia</a></p></blockquote>
<p>이 정의에는 리액티브 프로그래밍의 목적이 빠져있다. 무엇을 위해서, 데이터 플로우 관점에서 사고하고, 변경을 전파하는 걸까? 리액티브 프로그래밍이 처음 등장했던 배경을 돌아보자.</p>
<p><span style="font-size: 10pt;">(데이터 플로우 프로그래밍(Dataflow Programming)의 하위 개념으로서의 리액티브 프로그래밍을 이야기하자면 훨신 더 이전으로 거슬러 올라가야하는데 이해의 수준이 아직 거기까지 가지 못했으므로 이 글에서는 언급하지 않을 생각이다.)</span></p>
<p>리액티브 프로그래밍의 처음 시작이 어디인지는 명확하지 않다. 다만 추측할 수 있는 단서는 있다. 1985년에 David Harel, Amir Pnueil가 발표한 <a href="http://s3.amazonaws.com/academia.edu.documents/30783693/ReactiveSystems.pdf?AWSAccessKeyId=AKIAJ56TQJRTWSMTNPEA&amp;Expires=1470547942&amp;Signature=4yF7csn8uvK4wjhrRRrYAmivkzo%3D&amp;response-content-disposition=inline%3B%20filename%3DOn_the_development_of_reactive_systems.pdf" rev="en_rl_minimal">On the development of reactive systems</a>라는 논문에 처음으로 리액티브 시스템(Reactive Systems)이라는 용어가 등장한다. 이 논문에서 이야기하는 리액티브 시스템은 아래와 같은 특징을 가진다.</p>
<blockquote><p>Reactive systems… are repeatedly prompted by the outside world and their role is to continusouly respond external inputs</p></blockquote>
<p>즉, 리액티브 시스템이란 외부에서 들어오는 요청에 계속해서 응답하는 시스템이다. 이 논문은 리액티브 시스템을 구현하는 데에 적합한 프로그래밍 방법론에 대한 이야기를 담고 있는데, 이를 리액티브 프로그래밍으로 이해할 수 있다.</p>
<p>여기에서 힌트를 하나 얻었다. 계속해서 응답한다는 건 <strong>&#8216;반응&#8217;</strong>한다는 뜻이다. 그렇다면 리액티브 프로그래밍의 목적이 외부에서 들어온 자극에 반응하는 구조를 만드는 데 있다고 볼 수 있지 않을까? 여기에서 &#8216;반응&#8217;은 아래 두 가지 의미를 내포한다.</p>
<ul>
<li>자극은 밖에서 안으로 흐른다.</li>
<li>자극이 있어야만 반응하는 수동성을 갖는다.</li>
</ul>
<p>정리하자면 프로그램이 외부와 상호 작용하는 방식을 거꾸로 뒤집어서 수동적 반응성을 획득하는 일, 이것이 리액티브 프로그래밍의 목적이다. 에릭 마이어가 리액티브 프레임워크를 소개하는 강연에서 보여주었던 아래 그림은 리액티브 프로그래밍의 핵심을 잘 보여준다.</p>
<p><figure id="attachment_2126" aria-describedby="caption-attachment-2126" style="width: 960px" class="wp-caption aligncenter"><a href="http://huns.me/wp/wp-content/uploads/2016/09/reactive-eric.png"><img class="wp-image-2126 size-large" title="리액티브 환경과 인터랙티브 환경에서 제어가 흐르는 모습을 비교하는 그림" src="http://huns.me/wp/wp-content/uploads/2016/09/reactive-eric-1024x640.png" alt="에릭 마이어가 리액티브 프로그래밍을 소개하며 강연에서 사용했던 발표 자료로 외부에서 안으로 자극이 들어오는 리액티브 프로그래밍의 본질을 잘 보여준다." width="960" height="600" srcset="https://huns.me/wp/wp-content/uploads/2016/09/reactive-eric.png 1024w, https://huns.me/wp/wp-content/uploads/2016/09/reactive-eric-300x188.png 300w, https://huns.me/wp/wp-content/uploads/2016/09/reactive-eric-768x480.png 768w, https://huns.me/wp/wp-content/uploads/2016/09/reactive-eric-640x400.png 640w" sizes="(max-width: 960px) 100vw, 960px" /></a><figcaption id="caption-attachment-2126" class="wp-caption-text">출처를 까먹어서 찾을 수가 없다&#8230; 찾는 대로 업데이트 할 예정.</figcaption></figure></p>
<p>이 설명에 따르면 프로그램이 외부 환경과 커뮤니케이션을 하는 방법은 크게 두 가지가 있다. pull-scenario, 그리고 push-scenario.</p>
<ul>
<li><strong>pull-scenario</strong>는 우리에게 익숙한 방식으로 프로그램이 외부 환경에 명령하여 원하는 결과를 획득하는 방식이다. 이 경우 프로그램이 직접 제어의 흐름을 통제한다.</li>
<li><strong>push-scenario</strong>는 이를 뒤집어서, 환경이 프로그램 안으로 요청을 밀어넣는다. 외부 환경에 명령을 하고 응답이 오기까지 기다리는 것이 아니라, 외부에서 응답이 오면 그때 반응한다.</li>
</ul>
<p>push-scenario의 장점은 제어의 흐름을 통제할 권한을 외부 환경으로 넘김으로써 응답 대기 비용을 줄일 수 있다. 비동기 처리에 유리하다. 이 모습은 옵저버 패턴이나 리액터 패턴과 유사다. 그런데 리액티브 프레임워크 개발팀은 이 지점에서 한 가지 재밌는 사실을 발견한다. 바로 Iterator 패턴과 Observer 패턴이 쌍대(Duality)관계라는 점이다.</p>
<p>쌍대관계란 용어는 여러 분야에서 다양하게 쓰이며, 문맥에 따라 미묘한 의미의 차이가 있어 설명하기가 참 어려운데(사실 나도 잘 이해하고 있는건지 모르겠다), <strong>A와 B가 있을 때 A에서 성립하는 정리를 뒤집어서 B에도 적용할 수 있는 경우</strong>를 말한다. 한 마디로 A와 B의 본질이 같다는 뜻이다.</p>
<p>Iterator는 연속하는 데이터를 pull-scenario로 가져온다. Observer는 외부에서 데이터를 주입 받는(주로 이벤트로) push-scenario라고 볼 수 있다. 이벤트를 여러 번 호출하면, 연속하는 데이터를 주입할 수 있는데 이는 Iterator와 본질이 같다. 다만 데이터가 흐르는 방향이 다를 뿐이다.  Rx는 외부에서 안으로 연속해서 밀어넣는 데이터를 받을 수 있는 인터페이스를 제공함으로써 리액티브 프로그래밍을 지원한다. Observable이다.</p>
<table>
<thead>
<tr>
<th>event</th>
<th>Iterable (pull)</th>
<th>Observable (push)</th>
</tr>
</thead>
<tbody>
<tr>
<td>retrieve data</td>
<td><code>T next()</code></td>
<td><code>onNext(T)</code></td>
</tr>
<tr>
<td>discover error</td>
<td>throws <code>Exception</code></td>
<td><code>onError(Exception)</code></td>
</tr>
<tr>
<td>complete</td>
<td><code>!hasNext()</code></td>
<td><code>onCompleted()</code></td>
</tr>
</tbody>
</table>
<p>여기까지 보면 느낌이 Promise랑 비슷하다. 차이가 있다면 Promise는 단일 값을 처리하고, Observable은 여러 값을 처리한다.</p>
<h4><b>LINQ와 이벤트 결합(LINQ To Events)</b></h4>
<p>Rx는 외부에서 들어온 데이터를 단순히 목적지까지 운반하는 데 그치지 않는다. 더 나아가 이벤트와 LINQ라는 개념을 결합한 인터페이스를 제공하는데, 이를 이용하면 Observable로 전달받은 데이터를 LINQ 스타일로 처리할 수 있다. 이를 오퍼레이터(operator)라고 한다.</p>
<p>LINQ(Language Intergrated Query)는 에릭 마이어가 만든 통합 질의 언어다. LINQ는 C# 3.0에 처음 등장했는데, 쿼리를 언어에 통합하여 코드 상에서 데이터를 질의할 때 SQL 쿼리처럼 표현할 수 있게 도와주는 일종의 확장 문법이다. 이를 이용하면 데이터 콜렉션에 대한 복잡한 절차적 질의를, 마치 SQL로 처리하는 것처럼 간결하게 변경할 수 있다. C#에서 제공하는 LINQ는 아래와 같은 모습이다.</p><pre class="crayon-plain-tag">using (ServiceContext svcContext = new ServiceContext(_serviceProxy))
{
 var query_where1 = from a in svcContext.AccountSet
                    where a.Name.Contains("Contoso")
                    select a;
 foreach (var a in query_where1)
 {
  System.Console.WriteLine(a.Name + " " + a.Address1_City);
 }
}</pre><p>C#은 쿼리 구문(Query Syntax)과 메서드 구문(Method Syntax)이라는 두 가지 타입의 LINQ를 제공한다. 이 둘의 차이는 아래의 링크에서 확인할 수 있다.</p>
<p class="title"><a href="https://msdn.microsoft.com/ko-kr/library/bb397947.aspx">Query Syntax and Method Syntax in LINQ (C#)</a></p>
<p></p><pre class="crayon-plain-tag">//Query syntax:
IEnumerable&lt;int&gt; numQuery1 = 
    from num in numbers
    where num % 2 == 0
    orderby num
    select num;

//Method syntax:
IEnumerable&lt;int&gt; numQuery2 = numbers
    .Where(num =&gt; num % 2 == 0)
    .OrderBy(n =&gt; n);</pre><p>JavaScript 개발자라면 underscore나 lodash 같은 함수형 유틸 라이브러리를 접하면서 LINQ에 대한 이야기를 많이 들어봤을 텐데, Rx가 제공하는 LINQ 스타일 오퍼레이터는 메서드 구문의 LINQ와 유사하다.</p>
<h6><b>“Your Mouse Is DataBase&#8221;</b></h6>
<p>Observable은 프로그램이 연산을 수행하는 관점을 뒤집음으로써 비동기 처리에 유리한 구조를 만들 수 있는 토대를 제공한다. LINQ는 외부에서 스트림으로 들어오는 데이터를 쉽게 처리할 수 있는 방법을 제공한다.</p>
<p><figure id="attachment_2068" aria-describedby="caption-attachment-2068" style="width: 374px" class="wp-caption aligncenter"><a href="https://www.youtube.com/watch?v=sTSQlYX5DU0" target="_blank" rel="https://www.youtube.com/watch?v=sTSQlYX5DU0"><img class="wp-image-2068" title="에릭마이어가 리액티브 프로그래밍을 강연하는 모습" src="http://huns.me/wp/wp-content/uploads/2016/09/maxresdefault-1024x576.jpg" alt="에릭마이어가 리액티브 프로그래밍을 강연하는 모습" width="374" height="210" srcset="https://huns.me/wp/wp-content/uploads/2016/09/maxresdefault-1024x576.jpg 1024w, https://huns.me/wp/wp-content/uploads/2016/09/maxresdefault-300x169.jpg 300w, https://huns.me/wp/wp-content/uploads/2016/09/maxresdefault-768x432.jpg 768w, https://huns.me/wp/wp-content/uploads/2016/09/maxresdefault-711x400.jpg 711w" sizes="(max-width: 374px) 100vw, 374px" /></a><figcaption id="caption-attachment-2068" class="wp-caption-text">출처: https://www.youtube.com/watch?v=sTSQlYX5DU0</figcaption></figure></p>
<p>리액티브 프로그래밍과 LINQ의 개념을 바탕으로 Rx가 비동기 데이터를 처리하는 방식을 이해하기 위해 드래그 앤 드롭을 예로 들어보자.</p>
<p>마우스를 움직일 때마다 변하는 현재 위치 좌표는 외부에서 안으로 들어오는 자극이자, 데이터다. 이 좌표 데이터들은 Rx의 Observable이 만들어 놓은 문을 통해 프로그램 안으로 진입한다. 프로그램 안으로 들어온 데이터는 LINQ로 미리 작성해둔 오퍼레이터 사이를 헤엄쳐 최종 목적지에 도달한다. 프로그램은 최종 목적지로 들어온 데이터를 확인하여 응답한다. 이 과정은 마우스가 이동을 멈추지 않는 한 끊임없이 계속해서 이뤄진다. 마치 강물이 흐르듯이. 이게 Rx가 제안하는, 데이터 관점의 비동기 처리 방식이다.</p><pre class="crayon-plain-tag">const dragElement = document.getElementById('dragElement');
const mouseDrag$ = Rx.Observable
    .fromEvent(dragElement, 'mouseup')
    .map(md =&gt; ({
        startX: md.offsetX,
        startY: md.offsetY
    }));

mouseDrag$.subscribe(pos =&gt; {
    console.log(pos);
});</pre><p>에릭 마이어의 말처럼, Rx 세상 속에서 <a href="http://queue.acm.org/detail.cfm?id=2169076">Your Mouse는 DataBase</a>다.</p>
<p>(Rx는 이외에도 스케줄러나 함수형 패러다임을 지원하는 다양한 장치를 제공한다. 다만 이 글에서는 핵심만 짚었을 뿐이다)</p>
<h2><b>끝으로&#8230;</b></h2>
<p>Rx를 조사하면서 리액티브 프로그래밍에 대한 다양한 이해가 존재하는 것만큼 Rx에 대한 이해 또한 다양하다는 사실을 알았다. Rx와 리액티브 프로그래밍을 동일시 하거나, 함수형 리액티브 프로그래밍을 리액티브 프로그래밍 그 자체로 생각하는 견해를 종종 볼 수 있다.</p>
<div>시대에 따라 용어가 내포하는 개념은 넓어지기도 하고, 좁아지기도 하기에 어느 쪽 해석이 전적으로 틀렸다고 말하긴 어렵다. 그래서 개념과 주장이 난무하여 혼란스러울 때, 잠깐 손을 놓고 지나온 길을 돌아보는 일은 꽤나 의미있다.</div>
<div>
<div></div>
<blockquote><p>어떤 개념을 정말로 이해하려면 그 개념이 최초로 언급된 당시의 전후 맥락을 재구성해 볼 필요가 있다. 이렇게 해야 개념의 정수가 그 모든 중간자를 거치고도 살아남았음을 확인할 수 있다.</p>
<p>&#8211; 프로그래머의 길, 멘토에게 묻다 &#8211;</p></blockquote>
</div>
<p>Rx는 다양한 문맥에서 다양한 방식으로 쓰인다. 하지만 목적하는 바는 비슷하다. 해법이 조금 다를 뿐이다. 최근의 웹 프론트엔드 분야만 놓고 보자면 XHR을 이용한 비동기 요청을 처리할 때 Promise를 대체하는 정도로 제한적으로 사용하는가 하면, Cycle.js(Rx의 경량화 버전이라 할 수 있는 xstream을 이용) 처럼 아예 프레임워크 설계 수준까지 끌어올려서 사용하는 경우도 있다.</p>
<p>한 달 정도 공부한, 웹 프론트엔드에서의 RxJS에 대한 나의 느낌은 물음표다. 제한해서 사용한다면 꽤나 괜찮은 녀석일 것 같은데, 이에 비해 들여야하는 학습 비용이 너무 크게 느껴졌다. 오퍼레이터는 이름으로 용도를 유추하기 너무 힘들다. 오퍼레이터를 모르면 코드를 읽을 수가 없다. 협업 상황에서 치명적인 마이너스 요인이다.</p>
<p>그럼에도 낯선 세계가 주는 경험은 매우 흥미로웠고, Rx를 둘러싼 배경을 들여다보면서 다양한 인사이트를 얻을 수 있었다. 특히 Redux를 다른 관점에서 이해(<strong>Redux는 이미 리액티브하다</strong>)하게 되었는데 이에 대한 이야기는 다른 글에서 할 생각이다(이렇게 말하고 글을 이어 쓴 적이 한 번도 없더라&#8230;). 사실 Rx 보다는 리액티브 프로그래밍에 관심이 더 많다.</p>
<p>연습 삼아서 간단한 개인 프로젝트를 해봤다. 작성한 코드는 아래 링크에서 볼 수 있다.</p>
<p><a href="https://github.com/CoderK/github-filter-extension">github-filter-extension with RxJS</a></p>
<p>순전히 재미와 연습을 목적으로 구현한 거라 오버엔지니어링을 많이 했다. 특히 RxJS의 스트림을 극적으로 활용하는 함수형 Rx의 느낌을 맞보고 싶어서 Cycle.js의 MVI 설계를 네이티브로 따라 해 봤다. 함수형 코드의 구조화를 고민하다 보니 모듈을 좀 과하게 분리해놓은 감이 있다. 역시나 쪼렙인지라. RxJS를 이용해서 코딩을 하다가 대략 멍해지는 순간을 많이 만났다.</p>
<p>조사를 하면서 많은 자료를 찾았는데 논문 수준의 글은 내가 이해하기에 버거웠고, 쉽게 읽히는 글들은 깊이가 부족했다. 그래서 중간에 제대로 이해하지 못한 내용이 있을 수도 있다. 잘못 설명하고 있는 부분이 있다면 언제든 댓글이나 SNS로 의견 주시기 바라며 글을 마친다.</p>
<p>&nbsp;</p>
<hr />
<ol>
<li>공부하면서 참고했던 자료는 <a href="https://github.com/CoderK/What-I-Have-Learned/blob/master/README.md#rx와-리액티브-프로그래밍2016">여기</a>에 모아두었습니다.</li>
<li>레진에서 Rx를 주제로 발표할 기회가 있었는데, 이 때 발표한 내용에는 FRP에 대한 설명도 들어가 있으니 관심있는 분은 <a href="http://www.slideshare.net/jeokrang/rx-70197043">여기</a>를 참고하세요.</li>
</ol>
<p>&nbsp;</p>
]]></content:encoded>
							<wfw:commentRss>https://huns.me/development/2051/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
							</item>
		<item>
		<title>리액트 딜레마</title>
		<link>https://huns.me/development/2011</link>
				<comments>https://huns.me/development/2011#comments</comments>
				<pubDate>Mon, 22 Aug 2016 04:09:10 +0000</pubDate>
		<dc:creator><![CDATA[개발왕 김코딩]]></dc:creator>
				<category><![CDATA[개발 이야기]]></category>
		<category><![CDATA[react]]></category>
		<category><![CDATA[단상]]></category>

		<guid isPermaLink="false">http://huns.me/?p=2011</guid>
				<description><![CDATA[<a href="https://huns.me/development/2011" class="more_link more_link_dots"> &#8230; </a>]]></description>
								<content:encoded><![CDATA[<div>
<p>페이스북은 React를 &#8216;MVC에서 View만을 담당하는 작고 가벼운 라이브러리&#8217;라고 소개했다. 여기에는 이견이 없다.</p>
<p>그런데 잠깐, View만 가지고 만들 수 있는 게 뭐가 있을까?</p>
<p>하나의 애플리케이션 안에는 여러 가지의 관심사가 존재하고, 각각의 관심사를 처리하는 기술 또한 다양하다.  React 프로젝트를 하다 보면 React가 해결할 수 없는 영역을 채워줄 대안을 찾게 되고, 결국에는 단일 프레임워크스러운 무언가를 만들고 있는 자신을 발견한다. 이들을 찾아서 학습하고, 비교하고, 선택하는 과정도 비용이다.</p>
<p>React만으로 해결할 수 있는 문제의 범위는 생각 보다 좁다. 단순한 위젯이나 범용적으로 만든 라이브러리성 컴포넌트 정도가 떠오른다. 그런데 이렇게 단순한 녀석이라면, React 환경에 맞춰서 구현해야하는 특별한 이유가 없는 한, 그냥 순수 JavaScript나 jQuery를 이용해서 만드는 게 더 생산적일 수도 있다. React 개발 환경을 구축하고 코드를 트랜스파일 하는 과정 역시 지속적으로 지불해야 할 비용이니까.</p>
<p>결국 &#8216;React는 작고 가벼운 라이브러리지만, React만 가지고서 할 수 있는 일은 많지 않기에 진정으로 작고 가볍기 어렵다&#8217;는 결론에 도달했고, 나는 이걸 &#8216;리액트 딜레마&#8217;라고 부른다. 물론 나만 쓰는 용어다. 이런 딜레마가 완전히 단점이라고 말하기는 어렵다. 장점과 단점은 종이 한 장 차이라던가. 개발자에게 다양한 선택지를 준다는 점에서 React는 분명 가볍다.</p>
</div>
<p>역으로 이런 생각도 해봤다. Monolithic Framework(Angular같은)는 정말 하나로 모든 문제를 해결할까? 글쎄, 프로젝트 성격에 따라서 다를 수는 있겠지만 보편적으로 어렵지 않을까. 이런 고민을 하던 중에 페이스북에서 만난, 박성철 님의 글이 인상 깊다.</p>
<p><iframe width="500" height="510" style="border: none; overflow: hidden;" src="https://www.facebook.com/plugins/post.php?href=https%3A%2F%2Fwww.facebook.com%2Ffupfin.geek%2Fposts%2F353216358400687&amp;width=500" scrolling="no" frameborder="0" allowtransparency="true"></iframe></p>
]]></content:encoded>
							<wfw:commentRss>https://huns.me/development/2011/feed</wfw:commentRss>
		<slash:comments>1</slash:comments>
							</item>
		<item>
		<title>로버트 마틴의 클린 코더(The Clean Coder),  그리고 단상</title>
		<link>https://huns.me/development/1999</link>
				<comments>https://huns.me/development/1999#respond</comments>
				<pubDate>Sat, 13 Aug 2016 02:45:34 +0000</pubDate>
		<dc:creator><![CDATA[개발왕 김코딩]]></dc:creator>
				<category><![CDATA[개발 이야기]]></category>
		<category><![CDATA[단상]]></category>
		<category><![CDATA[책]]></category>
		<category><![CDATA[클린 코더]]></category>

		<guid isPermaLink="false">http://huns.me/?p=1999</guid>
				<description><![CDATA[<a href="https://huns.me/development/1999" class="more_link more_link_dots"> &#8230; </a>]]></description>
								<content:encoded><![CDATA[<p>많은 책을 읽는 편은 아니지만 꾸준히 읽으려고 애쓴다. 책을 그저 읽는 수준에서 마무리를 해버리면, 읽으면서 느낀 감정이나 생각이 너무 쉽게 사라져 버리는 게 못내 아쉽다. 그래서 메모를 많이 남기는 편인데, 여기에 더해 짧게 나마 감상도 남겨볼 생각이다. 리뷰라고 하기엔 거창한 것 같아 다른 단어를 고민해봤으나 적당한 단어가 떠오르지 않으니 그냥 &#8216;단상&#8217;이라고 하자.</p>
<p>첫 도전은 로버트 마틴의 유명한 책인 <a href="http://www.acornpub.co.kr/book/clean-coder"><b>&#8216;클린 코더&#8217;</b></a>다.</p>
<p>클린 코더(The Clean Coder)는 <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=7390287">클린 코드(Clean Code)</a>로 유명한 엉클 밥이 프로 개발자에 대한 자신의 생각을 전하는 책이다.<span class="Apple-converted-space">  책 표지가 오래전에 나온 책인 클린 코드의 초판 디자인과 비슷해서 같은 책으로 혼동하는 경우가 많은 듯하다. 최신 버전의 클린 코드는 하얀색 표지로 새롭게 단장해서 이전과 전혀 다른 모습을 하고 있다.</span></p>
<p>클린 코더의 책 표지 디자인은 꽤나 시대에 뒤떨어진 느낌인데, 출판사 측에서 책을 쓸 당시 저자의 의도를 최대한 반영하고 싶었던 거라고, 혼자 추측해 본다. 믿거나 말거나.</p>
<p>클린 코더는 어떤 코딩 기법을 전하는 책이 아니다.<span class="Apple-converted-space"> 프로 </span>개발자로서 업무를 대하는 태도나 자세에 대한, 다소(?) 진부한 이야기를 처음부터 끝까지 잔소리처럼 늘어놓는다. 누군가는 로버트 마틴이나 되는 개발자니까 할 수 있는 소리라고, 책 속에서나 가능한 비현실적인 이야기라고 할지도 모르겠다.</p>
<p>하지만 &#8216;도저히 도달할 수 없는 이상&#8217;을 그저 멍하니 바라보는 체념으로 가득한 세상 속에서, 좀 더 나은 순간이 오기를 학수고대하는 삶을 사는 나에게 로버트 마틴의 잔소리는 꽤나 특별했다. 왜 누군가에게는 가능한 현실이, 누군가에게는 불가능한 현실일까? 우리가 이상이라고 생각하는 것들은 정말 이상일까? 이 모든 것이 단순히 환경의 문제일까? 충분히 할 수 있는 일임에도 애둘러 핑계를 대며 회피하고 있는 것은 아닐까? 늘 의문으로 가득하다. 이 책을 읽으며 현실과 이상 사이를 넘나들었던 시간은 좋은 경험이었다.</p>
<p>이 외에도, 책 중간중간에 섞여있는 솔직 담백한 로버트 마틴의 자전적인 경험담은 유쾌하고 재밌다. 그중에 로버트 마틴이 젊은 시절에 일정 추정에 실패한 후, 속상해서 필름이 끊길 정도로 술을 마셨다는 에피소드가 가장 기억에 많이 남는다. 개발자라면 흔히 겪는 경험임에도 뭔가 묵직하게 와 닿았던 이유는 주인공이 로버트 마틴이어서 그렇다. 로버트 마틴 같은 대가는 태어날 때부터 천재일 것 같고 살면서 실패 한 번 경험해보지 못 했을 거 같았는데, 이런 사람도 깨지고 부딪히는 과정을 거치면서 끊임없이 학습하고 성장했다는 사실은 많은 걸 생각하게 한다.</p>
<p>그래서 그런 걸까. 또다시 궁금해졌다. 나는 지금 어디쯤 와 있는 걸까. 어디까지 갈 수 있을까.</p>
]]></content:encoded>
							<wfw:commentRss>https://huns.me/development/1999/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
							</item>
	</channel>
</rss>
