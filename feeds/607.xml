<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	>

<channel>
	<title>yuchi&#039;s development</title>
	<atom:link href="https://megayuchi.com/feed/" rel="self" type="application/rss+xml" />
	<link>https://megayuchi.com</link>
	<description>Game Development, Windows Development, Figure , Anime</description>
	<lastBuildDate>
	Mon, 22 Apr 2019 16:18:01 +0000	</lastBuildDate>
	<language>ko-KR</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
<cloud domain='megayuchi.com' port='80' path='/?rsscloud=notify' registerProcedure='' protocol='http-post' />
<image>
		<url>https://s0.wp.com/i/buttonw-com.png</url>
		<title>yuchi&#039;s development</title>
		<link>https://megayuchi.com</link>
	</image>
	<atom:link rel="search" type="application/opensearchdescription+xml" href="https://megayuchi.com/osd.xml" title="yuchi&#039;s development" />
	<atom:link rel='hub' href='https://megayuchi.com/?pushpress=hub'/>
	<item>
		<title>nvapi에서 NvAPI_GetMemoryInfo()주소 얻어오기 &#8211; (어셈블리어 학습해야하나요?)</title>
		<link>https://megayuchi.com/2019/04/23/nvapi%ec%97%90%ec%84%9c-nvapi_getmemoryinfo%ec%a3%bc%ec%86%8c-%ec%96%bb%ec%96%b4%ec%98%a4%ea%b8%b0-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ed%95%99%ec%8a%b5%ed%95%b4%ec%95%bc%ed%95%98%eb%82%98/</link>
				<comments>https://megayuchi.com/2019/04/23/nvapi%ec%97%90%ec%84%9c-nvapi_getmemoryinfo%ec%a3%bc%ec%86%8c-%ec%96%bb%ec%96%b4%ec%98%a4%ea%b8%b0-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ed%95%99%ec%8a%b5%ed%95%b4%ec%95%bc%ed%95%98%eb%82%98/#respond</comments>
				<pubDate>Mon, 22 Apr 2019 15:54:50 +0000</pubDate>
		<dc:creator><![CDATA[megayuchi]]></dc:creator>
				<category><![CDATA[Development]]></category>
		<category><![CDATA[Assembly]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[GPU]]></category>
		<category><![CDATA[nvidia]]></category>
		<category><![CDATA[Visual Studio]]></category>

		<guid isPermaLink="false">http://megayuchi.com/?p=5779</guid>
				<description><![CDATA[Voxel Horizon은 NVAPI를 사용한다. NVAPI는 GPU의 상태를 확인하거나 일부 기능을 제어할 수 있는 nvidia 그래픽 드라이버에서 제공하는 API이다. NVAPI SDK는 nvidia 개발자 홈페이지에서 다운로드할 수 있다. C스타일의 .h / .lib / .dll로 구성된 아주 간단한 SDK다. 이걸로 게임 플레이중 GPU점유율과 GPU온도, 남은 GPU메모리의 양을 확인한다. 물론 일반 유저들을 위한 기능은 아니고 개발할때 필요한 디버깅용 기능으로 &#8230; <a class="more-link" href="https://megayuchi.com/2019/04/23/nvapi%ec%97%90%ec%84%9c-nvapi_getmemoryinfo%ec%a3%bc%ec%86%8c-%ec%96%bb%ec%96%b4%ec%98%a4%ea%b8%b0-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ed%95%99%ec%8a%b5%ed%95%b4%ec%95%bc%ed%95%98%eb%82%98/">More <span class="screen-reader-text">nvapi에서 NvAPI_GetMemoryInfo()주소 얻어오기 &#8211; (어셈블리어&#160;학습해야하나요?)</span></a>]]></description>
								<content:encoded><![CDATA[<p>Voxel Horizon은 NVAPI를 사용한다. NVAPI는 GPU의 상태를 확인하거나 일부 기능을 제어할 수 있는 nvidia 그래픽 드라이버에서 제공하는 API이다.<br />
NVAPI SDK는 nvidia 개발자 홈페이지에서 다운로드할 수 있다. C스타일의 .h / .lib / .dll로 구성된 아주 간단한 SDK다.<br />
이걸로 게임 플레이중 GPU점유율과 GPU온도, 남은 GPU메모리의 양을 확인한다. 물론 일반 유저들을 위한 기능은 아니고 개발할때 필요한 디버깅용 기능으로 넣었다.</p>
<p>그런데 이 nvapi SDK와 예제를 그대로 사용할 경우 약간 문제가 있다.<br />
당연히 nvidia 그래픽 카드가 없는 PC에선 사용할 수 없다. 사용할 수 없으면 그냥 안쓰고 게임 돌아가면 된다. GPU 점유율 표시 안되면 그만이다. 근데 크래시하면 큰 문제다.</p>
<p>nvapi.h에 선언된 함수들을 사용하기 위해 기본적으로 NVAPI를 사용할때 .lib를 링크한다. 그런데 이렇게 하면 implicit DLL linking이 된다.<br />
쉽게 말해서 nvapi를 사용한 exe가 실행이 될때 exe가 있는 폴더, 혹은 windows\system32폴더 밑에 nvapi.dll이 있어야한다. 그렇지 않으면 내가 만든 exe로 제어권이 넘어오기도 전에 크래시해버린다.<br />
nvidia 그래픽 카드 사용자라의 PC라면 Wndows\system32폴더에 nvapi.dll이 있을것이다. 하지만 nvidia 그래픽 카드가 없는 PC라면 nvapi.dll은 없을것이고 바로 크래시한다.</p>
<p>해결방법은 간단하다. explicit DLL linking을 사용하면 된다.<br />
LoadLibrary()로 DLL를 로드하고 GetProcAddress()로 특정함수의 주소를 얻어와서 호출하면 된다.</p>
<p>그런데 또 문제가 있다.<br />
<a href="https://megayuchi.files.wordpress.com/2019/04/nvapi_exports.png"><img data-attachment-id="5780" data-permalink="https://megayuchi.com/2019/04/23/nvapi%ec%97%90%ec%84%9c-nvapi_getmemoryinfo%ec%a3%bc%ec%86%8c-%ec%96%bb%ec%96%b4%ec%98%a4%ea%b8%b0-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ed%95%99%ec%8a%b5%ed%95%b4%ec%95%bc%ed%95%98%eb%82%98/nvapi_exports/" data-orig-file="https://megayuchi.files.wordpress.com/2019/04/nvapi_exports.png?w=748" data-orig-size="1013,546" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="nvapi_exports" data-image-description="" data-medium-file="https://megayuchi.files.wordpress.com/2019/04/nvapi_exports.png?w=748?w=300" data-large-file="https://megayuchi.files.wordpress.com/2019/04/nvapi_exports.png?w=748?w=748" class="alignnone size-full wp-image-5780" src="https://megayuchi.files.wordpress.com/2019/04/nvapi_exports.png?w=748" alt="nvapi_exports" srcset="https://megayuchi.files.wordpress.com/2019/04/nvapi_exports.png?w=748 748w, https://megayuchi.files.wordpress.com/2019/04/nvapi_exports.png?w=150 150w, https://megayuchi.files.wordpress.com/2019/04/nvapi_exports.png?w=300 300w, https://megayuchi.files.wordpress.com/2019/04/nvapi_exports.png?w=768 768w, https://megayuchi.files.wordpress.com/2019/04/nvapi_exports.png 1013w" sizes="(max-width: 748px) 100vw, 748px"   /></a></p>
<p>nvapi.dll은 nvapi_QueryInterface함수 하나만 노출하고 있다. GPU온도를 얻는 NvAPI_GPU_GetThermalSettings()라든가 GPU메모리 상태를 얻기 위한 NvAPI_GetMemoryInfo()함수가 필요한데 이런 함수들은 노출되어있지 않다. 즉 GetProcAddress()로 이 함수들의 주소를 얻어올수 없다.</p>
<p>구글검색을 해보면 nvapi_QueryInterface()에 특정 상수를 넣어서 나머지 함수들의 주소를 얻어오는 예제가 잔뜩 나온다.<br />
nvapi_QueryInterface가 인자로 받는 상수는 아마도 uuid 비슷한것으로 보인다. 64비트 32비트 상관없이 같은 숫자를 받으니까 상대 어드레스라든가 그런건 아닌거 같다. 좌우간 uuid든 뭐든 nvapi_QueryInterface에 전달할 ID값만 알고 있으면 필요한 함수의 주소는 다 얻어올수 있다.</p>
<p>검색하면 필요한 함수의 ID값은 다 찾을 수 있다. 그런데 그 중에 틀린 값도 있다.<br />
다들 같은 코드를 복붙했는지 틀린 값도 똑같다.<br />
예를 들면 이 함수 NvAPI_GetMemoryInfo()가 그렇다.<br />
<a href="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_invalid.png"><img data-attachment-id="5784" data-permalink="https://megayuchi.com/2019/04/23/nvapi%ec%97%90%ec%84%9c-nvapi_getmemoryinfo%ec%a3%bc%ec%86%8c-%ec%96%bb%ec%96%b4%ec%98%a4%ea%b8%b0-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ed%95%99%ec%8a%b5%ed%95%b4%ec%95%bc%ed%95%98%eb%82%98/nvapi_gpu_memoryinfo_invalid/" data-orig-file="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_invalid.png?w=748" data-orig-size="581,155" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="nvapi_gpu_memoryinfo_invalid" data-image-description="" data-medium-file="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_invalid.png?w=748?w=300" data-large-file="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_invalid.png?w=748?w=581" class="alignnone size-full wp-image-5784" src="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_invalid.png?w=748" alt="nvapi_gpu_memoryinfo_invalid" srcset="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_invalid.png 581w, https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_invalid.png?w=150 150w, https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_invalid.png?w=300 300w" sizes="(max-width: 581px) 100vw, 581px"   /></a><br />
이거 잘못된 값이다. 어쩌면 누군가 저 코드를 작성했을 시점엔 맞는 값이었을지도 모르겠지만 좌우간 지금은 아니다. 저 값으로 NvAPI_GetMemoryInfo()의 주소를 얻어올 수 없다. 전혀 다른 함수의 주소를 돌려준다.</p>
<p>디스어셈블리 창을 띄워놓고 nvapi.h에 선언된 함수들을 조금 따라가보면 내부적으로 nvapi_QueryInterface()함수를 호출하여 해당 기능을 수행하는 함수의 어드레스를 얻어오도록 되어있다. 그걸 호출해서 실제 기능을 수행한다.<br />
즉 nvapi.lib를 링크했을때(implicit linking으로 nvapi.dll을 로딩) nvapi.h에 선언된 NvAPI_GetMemoryInfo()를 호출하면 nvapi_QueryInterface()에 어떤 ID값을 넣고 그걸로 진짜 NvAPI_GetMemoryInfo()의 주소를 받아와서 그걸 실행한다는 것이다.</p>
<p>그럼 간단하다. nvapi.lib를 링크한 상태로 NvAPI_GetMemoryInfo()의 어셈블리 코드를 쫓아가보면 어떤 ID값을 nvapi_QueryInterface()함수에 전달하는지 알 수 있을 것이다.</p>
<p>먼저 nvapi_QueryInterface()의 주소를 얻는다. 이건 그냥 API호출로 간단하게 얻을수 있다.<br />
<a href="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_00.png"><br />
<img data-attachment-id="5783" data-permalink="https://megayuchi.com/2019/04/23/nvapi%ec%97%90%ec%84%9c-nvapi_getmemoryinfo%ec%a3%bc%ec%86%8c-%ec%96%bb%ec%96%b4%ec%98%a4%ea%b8%b0-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ed%95%99%ec%8a%b5%ed%95%b4%ec%95%bc%ed%95%98%eb%82%98/nvapi_gpu_memoryinfo_00/" data-orig-file="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_00.png?w=748" data-orig-size="879,203" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="nvapi_gpu_memoryinfo_00" data-image-description="" data-medium-file="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_00.png?w=748?w=300" data-large-file="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_00.png?w=748?w=748" class="alignnone size-full wp-image-5783" src="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_00.png?w=748" alt="nvapi_gpu_memoryinfo_00" srcset="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_00.png?w=748 748w, https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_00.png?w=150 150w, https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_00.png?w=300 300w, https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_00.png?w=768 768w, https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_00.png 879w" sizes="(max-width: 748px) 100vw, 748px"   /></a></p>
<p>nvapi_QueryInterface의 주소는 0x00007ffc22365e00이다. 일단 이걸 확인해둔다.<br />
<a href="https://megayuchi.files.wordpress.com/2019/04/nvapi_queryinterface_addr.png"><img data-attachment-id="5785" data-permalink="https://megayuchi.com/2019/04/23/nvapi%ec%97%90%ec%84%9c-nvapi_getmemoryinfo%ec%a3%bc%ec%86%8c-%ec%96%bb%ec%96%b4%ec%98%a4%ea%b8%b0-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ed%95%99%ec%8a%b5%ed%95%b4%ec%95%bc%ed%95%98%eb%82%98/nvapi_queryinterface_addr/" data-orig-file="https://megayuchi.files.wordpress.com/2019/04/nvapi_queryinterface_addr.png?w=748" data-orig-size="762,108" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="nvapi_queryinterface_addr" data-image-description="" data-medium-file="https://megayuchi.files.wordpress.com/2019/04/nvapi_queryinterface_addr.png?w=748?w=300" data-large-file="https://megayuchi.files.wordpress.com/2019/04/nvapi_queryinterface_addr.png?w=748?w=748" class="alignnone size-full wp-image-5785" src="https://megayuchi.files.wordpress.com/2019/04/nvapi_queryinterface_addr.png?w=748" alt="nvapi_queryinterface_addr" srcset="https://megayuchi.files.wordpress.com/2019/04/nvapi_queryinterface_addr.png?w=748 748w, https://megayuchi.files.wordpress.com/2019/04/nvapi_queryinterface_addr.png?w=150 150w, https://megayuchi.files.wordpress.com/2019/04/nvapi_queryinterface_addr.png?w=300 300w, https://megayuchi.files.wordpress.com/2019/04/nvapi_queryinterface_addr.png 762w" sizes="(max-width: 748px) 100vw, 748px"   /></a></p>
<p>이제 nvapi.lib의 NvAPI_GetMemoryInfo()를 따라가본다.<br />
<a href="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_01.png"><br />
<img data-attachment-id="5781" data-permalink="https://megayuchi.com/2019/04/23/nvapi%ec%97%90%ec%84%9c-nvapi_getmemoryinfo%ec%a3%bc%ec%86%8c-%ec%96%bb%ec%96%b4%ec%98%a4%ea%b8%b0-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ed%95%99%ec%8a%b5%ed%95%b4%ec%95%bc%ed%95%98%eb%82%98/nvapi_gpu_memoryinfo_01/" data-orig-file="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_01.png?w=748" data-orig-size="891,577" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="nvapi_gpu_memoryinfo_01" data-image-description="" data-medium-file="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_01.png?w=748?w=300" data-large-file="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_01.png?w=748?w=748" class="alignnone size-full wp-image-5781" src="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_01.png?w=748" alt="nvapi_gpu_memoryinfo_01" srcset="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_01.png?w=748 748w, https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_01.png?w=150 150w, https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_01.png?w=300 300w, https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_01.png?w=768 768w, https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_01.png 891w" sizes="(max-width: 748px) 100vw, 748px"   /></a></p>
<p>여기부터 nvapi.lib에 들어있는 NvAPI_GetMemoryInfo()함수다. 실질적으로 이 녀석이 메모리 정보를 주진 않는다. nvapi_QueryInterface()에 ID값을 넣고 얻은 함수가 실제 메모리 정보를 준다. 이 녀석은 중계를 할 뿐이다.<br />
<a href="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_05.png"><br />
<img data-attachment-id="5787" data-permalink="https://megayuchi.com/2019/04/23/nvapi%ec%97%90%ec%84%9c-nvapi_getmemoryinfo%ec%a3%bc%ec%86%8c-%ec%96%bb%ec%96%b4%ec%98%a4%ea%b8%b0-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ed%95%99%ec%8a%b5%ed%95%b4%ec%95%bc%ed%95%98%eb%82%98/nvapi_gpu_memoryinfo_05/" data-orig-file="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_05.png?w=748" data-orig-size="1328,858" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="nvapi_gpu_memoryinfo_05" data-image-description="" data-medium-file="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_05.png?w=748?w=300" data-large-file="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_05.png?w=748?w=748" class="alignnone size-full wp-image-5787" src="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_05.png?w=748" alt="nvapi_gpu_memoryinfo_05.PNG" srcset="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_05.png?w=748 748w, https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_05.png?w=150 150w, https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_05.png?w=300 300w, https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_05.png?w=768 768w, https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_05.png 1328w" sizes="(max-width: 748px) 100vw, 748px"   /></a><br />
디스어셈블리 창에서 F10을 눌러서 몇줄 따라내려가보면<br />
이와 같이 nvAPI_QueryInterface함수의 포인터를 로드하는 코드가 보인다.<br />
mov         rax,qword ptr [g_nvapi_lpNvAPI_gpuQueryInterface (07FF7B0EBCB98h)]</p>
<p>조금 더 내려가면. call rax명령이 보인다. 함수 포인터를 호출하는 흔하디 흔한 간접호출 코드다.<br />
호출 직전 rax레지스터의 값을 확인해보면 0x00007ffc22365e00로 앞에서 확인한 nvAPI_QueryInterface의 주소와 같다. 이제 nvAPI_QueryInterface()를 호출하는것이 확실하다.</p>
<p>그럼 파라미터로 어떤 값을 전달할까? x64에선 x64용 fastcall을 사용하므로 파라미터가 4개 이하려면 rcx,rdx,r8,r9 레지스터로 전달한다. call 명령 전에 ecx레지스터(rcx레지스터의 하위 32비트에 해당)에 7F9B368h를 넣는게 보인다.OK.  </p>
<p>NvAPI_GetMemoryInfo()의 ID값은 7F9B368h이다.</p>
<p>이제 진짜 NvAPI_GPU_GetMemoryInfo()함수의 주소를 얻을 수 있다.<br />
<a href="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_call.png"><img data-attachment-id="5788" data-permalink="https://megayuchi.com/2019/04/23/nvapi%ec%97%90%ec%84%9c-nvapi_getmemoryinfo%ec%a3%bc%ec%86%8c-%ec%96%bb%ec%96%b4%ec%98%a4%ea%b8%b0-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ed%95%99%ec%8a%b5%ed%95%b4%ec%95%bc%ed%95%98%eb%82%98/nvapi_gpu_memoryinfo_call/" data-orig-file="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_call.png?w=748" data-orig-size="1159,143" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="nvapi_gpu_memoryinfo_call" data-image-description="" data-medium-file="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_call.png?w=748?w=300" data-large-file="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_call.png?w=748?w=748" class="alignnone size-full wp-image-5788" src="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_call.png?w=748" alt="nvapi_gpu_memoryinfo_call" srcset="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_call.png?w=748 748w, https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_call.png?w=150 150w, https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_call.png?w=300 300w, https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_call.png?w=768 768w, https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_call.png 1159w" sizes="(max-width: 748px) 100vw, 748px"   /></a></p>
<p>그리고 이렇게 잘 사용중.<br />
<a href="https://megayuchi.files.wordpress.com/2019/04/voxel_horizon_gpu_info_full.png"><img data-attachment-id="5789" data-permalink="https://megayuchi.com/2019/04/23/nvapi%ec%97%90%ec%84%9c-nvapi_getmemoryinfo%ec%a3%bc%ec%86%8c-%ec%96%bb%ec%96%b4%ec%98%a4%ea%b8%b0-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ed%95%99%ec%8a%b5%ed%95%b4%ec%95%bc%ed%95%98%eb%82%98/voxel_horizon_gpu_info_full/" data-orig-file="https://megayuchi.files.wordpress.com/2019/04/voxel_horizon_gpu_info_full.png?w=748" data-orig-size="1282,832" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="voxel_horizon_gpu_info_full" data-image-description="" data-medium-file="https://megayuchi.files.wordpress.com/2019/04/voxel_horizon_gpu_info_full.png?w=748?w=300" data-large-file="https://megayuchi.files.wordpress.com/2019/04/voxel_horizon_gpu_info_full.png?w=748?w=748" class="alignnone size-full wp-image-5789" src="https://megayuchi.files.wordpress.com/2019/04/voxel_horizon_gpu_info_full.png?w=748" alt="voxel_horizon_gpu_info_full" srcset="https://megayuchi.files.wordpress.com/2019/04/voxel_horizon_gpu_info_full.png?w=748 748w, https://megayuchi.files.wordpress.com/2019/04/voxel_horizon_gpu_info_full.png?w=150 150w, https://megayuchi.files.wordpress.com/2019/04/voxel_horizon_gpu_info_full.png?w=300 300w, https://megayuchi.files.wordpress.com/2019/04/voxel_horizon_gpu_info_full.png?w=768 768w, https://megayuchi.files.wordpress.com/2019/04/voxel_horizon_gpu_info_full.png 1282w" sizes="(max-width: 748px) 100vw, 748px"   /></a><br />
<a href="https://megayuchi.files.wordpress.com/2019/04/voxel_horizon_gpu_info.png"><img data-attachment-id="5790" data-permalink="https://megayuchi.com/2019/04/23/nvapi%ec%97%90%ec%84%9c-nvapi_getmemoryinfo%ec%a3%bc%ec%86%8c-%ec%96%bb%ec%96%b4%ec%98%a4%ea%b8%b0-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ed%95%99%ec%8a%b5%ed%95%b4%ec%95%bc%ed%95%98%eb%82%98/voxel_horizon_gpu_info/" data-orig-file="https://megayuchi.files.wordpress.com/2019/04/voxel_horizon_gpu_info.png?w=748" data-orig-size="141,63" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="voxel_horizon_gpu_info" data-image-description="" data-medium-file="https://megayuchi.files.wordpress.com/2019/04/voxel_horizon_gpu_info.png?w=748?w=141" data-large-file="https://megayuchi.files.wordpress.com/2019/04/voxel_horizon_gpu_info.png?w=748?w=141" class="alignnone size-full wp-image-5790" src="https://megayuchi.files.wordpress.com/2019/04/voxel_horizon_gpu_info.png?w=748" alt="voxel_horizon_gpu_info"   /></a></p>
<p>nvapi의 함수 주소를 얻어온 방법 자체는 사실 아무것도 아니다. 그래서 포스팅할 생각은 없었다.<br />
그런데 최근 어셈블리 학습이 필요하냐는 질문을 받았다. 각잡고 학습할 필요는 없다고 답변했다. 물론 학습할 필요가 없다는 뜻이 절대 아니다. 책 펴놓고 학습할 필요까진 없고 효율적으로 학습하라는 뜻이다.<br />
Visual Studio에서 Disasembly 창을 항상 띄워놓고 C/C++코드가 어떻게 어셈블리 코드로 바뀌었는지 확인하는 습관을 들이라는 얘기다.<br />
그러면 이런 때에도 써먹을 수 있다는 얘길 하고 싶었다.</p>
<p>그러니까 이번 포스팅의 핵심 내용은 &#8220;어셈블리 학습을 하면 이런데 쓸 수 있습니다&#8221; 라는 사례 소개인 것이다.</p>
]]></content:encoded>
							<wfw:commentRss>https://megayuchi.com/2019/04/23/nvapi%ec%97%90%ec%84%9c-nvapi_getmemoryinfo%ec%a3%bc%ec%86%8c-%ec%96%bb%ec%96%b4%ec%98%a4%ea%b8%b0-%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ed%95%99%ec%8a%b5%ed%95%b4%ec%95%bc%ed%95%98%eb%82%98/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
						
		<media:thumbnail url="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_05.png" />
		<media:content url="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_05.png" medium="image">
			<media:title type="html">nvapi_gpu_memoryinfo_05</media:title>
		</media:content>

		<media:content url="https://0.gravatar.com/avatar/046295b08cb47c0a19144d444fe02443?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">dgtman</media:title>
		</media:content>

		<media:content url="https://megayuchi.files.wordpress.com/2019/04/nvapi_exports.png" medium="image">
			<media:title type="html">nvapi_exports</media:title>
		</media:content>

		<media:content url="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_invalid.png" medium="image">
			<media:title type="html">nvapi_gpu_memoryinfo_invalid</media:title>
		</media:content>

		<media:content url="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_00.png" medium="image">
			<media:title type="html">nvapi_gpu_memoryinfo_00</media:title>
		</media:content>

		<media:content url="https://megayuchi.files.wordpress.com/2019/04/nvapi_queryinterface_addr.png" medium="image">
			<media:title type="html">nvapi_queryinterface_addr</media:title>
		</media:content>

		<media:content url="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_01.png" medium="image">
			<media:title type="html">nvapi_gpu_memoryinfo_01</media:title>
		</media:content>

		<media:content url="https://megayuchi.files.wordpress.com/2019/04/nvapi_gpu_memoryinfo_call.png" medium="image">
			<media:title type="html">nvapi_gpu_memoryinfo_call</media:title>
		</media:content>

		<media:content url="https://megayuchi.files.wordpress.com/2019/04/voxel_horizon_gpu_info_full.png" medium="image">
			<media:title type="html">voxel_horizon_gpu_info_full</media:title>
		</media:content>

		<media:content url="https://megayuchi.files.wordpress.com/2019/04/voxel_horizon_gpu_info.png" medium="image">
			<media:title type="html">voxel_horizon_gpu_info</media:title>
		</media:content>
	</item>
		<item>
		<title>Direct X 프로그래밍 학습에 대한 조언</title>
		<link>https://megayuchi.com/2019/04/18/direct-x-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d-%ed%95%99%ec%8a%b5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%a1%b0%ec%96%b8/</link>
				<comments>https://megayuchi.com/2019/04/18/direct-x-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d-%ed%95%99%ec%8a%b5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%a1%b0%ec%96%b8/#comments</comments>
				<pubDate>Wed, 17 Apr 2019 17:14:15 +0000</pubDate>
		<dc:creator><![CDATA[megayuchi]]></dc:creator>
				<category><![CDATA[Development]]></category>
		<category><![CDATA[Pub]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[DIrectX]]></category>
		<category><![CDATA[Win32]]></category>

		<guid isPermaLink="false">http://megayuchi.com/?p=5774</guid>
				<description><![CDATA[간만에 페이스북 DirectX 그룹에 질문이 올라와서 답변을 달았다. 답변 달다보니 몇 가지 강조할 내용은 정리해서 어디 남겨야겠단 생각이 들었다. DirectX 프로그래밍을 학습하려고 한다면&#8230; 1. 현대적인 C++과 달리 모든 DirectX, 그러니까 DirectX 2부터 12까지 모두 포인터를 죽도록 사용하며 아주 능숙하게 사용해야합니다. 포인터 사용에 능숙하지 못하다면 C/C++프로그래밍 기초부터 다시 학습하도록 합니다. 2. DirectX 프로그래밍을 학습하려면 COM에 대한 &#8230; <a class="more-link" href="https://megayuchi.com/2019/04/18/direct-x-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d-%ed%95%99%ec%8a%b5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%a1%b0%ec%96%b8/">More <span class="screen-reader-text">Direct X 프로그래밍 학습에 대한&#160;조언</span></a>]]></description>
								<content:encoded><![CDATA[<p>간만에 페이스북 DirectX 그룹에 질문이 올라와서 답변을 달았다.<br />
답변 달다보니  몇 가지 강조할 내용은 정리해서 어디 남겨야겠단 생각이 들었다.</p>
<p>DirectX 프로그래밍을 학습하려고 한다면&#8230;</p>
<p>1. 현대적인 C++과 달리 모든 DirectX, 그러니까 DirectX 2부터 12까지 모두 포인터를 죽도록 사용하며 아주 능숙하게 사용해야합니다. 포인터 사용에 능숙하지 못하다면 C/C++프로그래밍 기초부터 다시 학습하도록 합니다.</p>
<p>2. DirectX 프로그래밍을 학습하려면 COM에 대한 이해가 필요합니다. 여기서 필요한 COM지식은 C++의 virtual function과 다중상속 개념을 이해하고 실습하는 것과 거의 같습니다. 실제로 in-process COM은 C++의 virtual function과 다중상속 기능을 이용해서 구현되었습니다. 시중의 COM서적들은 불필요하게 방대한 내용을 담고 있으며 DirectX와 같은 in-process COM과 너무 동떨어진 내용을 담고 있습니다. 따라서 COM책을 구해서 본다면 개요 정도만 읽고 넘어갑니다. 그보단 DirectX코드를 사용할때 disassmbly코드를 따라가는 쪽이 훨씬 도움이 많이 됩니다. 혹은 MSDN을 참고하도록 합니다.</p>
<p>3. DirectX 12부터 MS는 샘플코드에 CComPtr클래스 떡칠을 하기 시작했습니다. 자기들은 그게 편할지 모르겠지만 이 망할 캡슐화된 클래스는 동작원리를 감춥니다. 초보자에게는 혼란만 가중시킬 뿐입니다. COM에 대해서 잘 모른다면 CComPtr을 사용해선 안됩니다. 완전히 잘못 사용하게 될뿐더러 뭐가 잘못됐는지 이해하지 못합니다.</p>
<p>4. 3의 연장선상에서 하는 얘긴데 학습단계에서 빌어먹을 wrapper클래스는 가져다 쓰지도 만들어쓰지도 않도록 합니다. raw포인터와 raw api만을 사용합니다.</p>
<p>5. DirectX 9을 사용해봤다면 DirectX 11을 학습하는데 큰 어려움이 없습니다. 그렇다고 처음 시작하면서 9를 먼저 학습할 필요는 없습니다. DirectX 9를 모르고 DirectX 11을 처음 학습한다면 약간 어렵겠지만 큰 문제가 되진 않습니다. 그러니 11부터 시작하도록 합니다.</p>
<p>6. 10과 11은 거의 유사합니다. 10에서 Compute Shader와 멀티 스레드 렌더링 관련 기능이 추가된게 11입니다. 현재 10으로 개발하는 게임은 없고 99%의 Windows및 XBOX게임은 DirectX 11 타겟으로 개발합니다. 그러니 10도 건너뜁니다. 다만 DirectX 10의 샘플 코드는 학습 및 응용에 도움이 됩니다.</p>
<p>7. DirectX 12를 학습하려고 한다면 DirectX 11에 대해 빠싹하게 알고 있어야 합니다. DirectX 11과 12는 완전 다르지만 그래도 11은 기본적으로 알고 있어야 합니다. 11을 알면 도움이 되는 정도가 아니고 11을 모르면 12는 결코 이해하지 못합니다. 첫째로는 12의 API이름과 11의 API이름이 거의 같기 때문이고, 둘째로는 11의 기본적인 사항에서 무엇이 어떤 의도로 어떻게 변경되었는가를 이해해야 12의 프로그래밍이 가능하기 때문입니다. 따라서 11은 필수입니다.</p>
<p>요즘같이 엔진 가져다 쓰는 개발이 대부분인 시대에 DirectX를 학습하려는 사람은 거의 없겠지만 만약 시도하는 이가 있다면 이 글을 읽고 삽질을 덜 하길 바랍니다.</p>
]]></content:encoded>
							<wfw:commentRss>https://megayuchi.com/2019/04/18/direct-x-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d-%ed%95%99%ec%8a%b5%ec%97%90-%eb%8c%80%ed%95%9c-%ec%a1%b0%ec%96%b8/feed/</wfw:commentRss>
		<slash:comments>9</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/046295b08cb47c0a19144d444fe02443?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">dgtman</media:title>
		</media:content>
	</item>
		<item>
		<title>기술? 숙련도?</title>
		<link>https://megayuchi.com/2019/04/16/5768/</link>
				<comments>https://megayuchi.com/2019/04/16/5768/#comments</comments>
				<pubDate>Mon, 15 Apr 2019 15:30:58 +0000</pubDate>
		<dc:creator><![CDATA[megayuchi]]></dc:creator>
				<category><![CDATA[Pub]]></category>

		<guid isPermaLink="false">http://megayuchi.com/?p=5768</guid>
				<description><![CDATA[뭐든 깊게 들어가면 잘하는게 어렵다고 한다. 그러니까 기술의 장르에 따라 쉽고 어려운게 없다고 한다. 어느 정도 맞는 말이지만 난 완전히 동의하진 않는다. 1부터 100까지 합을 매일 연습해보면 값을 외우지 않더라도 굉장히 빠른 속도로 계산해낼 수 있을 것이다. 그러나 느리든 빠르든 누구든 할 수 있다. 숙련도의 차이일 뿐. 시간을 들이면 누구든 빨라진다. 하지만 가우스처럼 신박한 방법을 &#8230; <a class="more-link" href="https://megayuchi.com/2019/04/16/5768/">More <span class="screen-reader-text">기술? 숙련도?</span></a>]]></description>
								<content:encoded><![CDATA[<p>뭐든 깊게 들어가면 잘하는게 어렵다고 한다. 그러니까 기술의 장르에 따라 쉽고 어려운게 없다고 한다.<br />
어느 정도 맞는 말이지만 난 완전히 동의하진 않는다.</p>
<p>1부터 100까지 합을 매일 연습해보면 값을 외우지 않더라도 굉장히 빠른 속도로 계산해낼 수 있을 것이다.<br />
그러나 느리든 빠르든 누구든 할 수 있다.<br />
숙련도의 차이일 뿐. 시간을 들이면 누구든 빨라진다.<br />
하지만 가우스처럼 신박한 방법을 생각해내서 없던 알고리즘을 만들어내는건 아무나 못한다.<br />
노가다로 풀거나 신박한 알고리즘으로 풀거나 1부터 100까지 합을 구했다는 점은 같을지 모르지만 절대로 넘지 못할 벽이 존재하는 것이다.</p>
<p>플랫폼에서 주어진 기능 가지고 각종 컨트롤 배치해서 뭔가 보여주는거, 물론 아주 잘하려면 상당한 숙련도가 필요할 것이다.<br />
그렇지만 hypervisor만드는 사람이 한나절 학습하면, 아니 일주일 학습하면 대충이라도 못할까?<br />
반대로 컨트롤 배치하던 사람이 일주일은 고사하고 1년 학습하면 Hypervisor만들겠냔 말이다.<br />
여기선 넘을 수 없는 벽이 존재한다.</p>
<p>난 진입장벽이 낮은 작업에서 숙련도가 높아지는 것으로 만족할 수 없다.<br />
그것이 엔지니어의 실력이라고는 결.코 생각지 않는다.<br />
난 남들이 쉽게 진입하지 못하는걸 하고 싶다.</p>
<p>그게 내가 생각하는 기술이다.</p>
]]></content:encoded>
							<wfw:commentRss>https://megayuchi.com/2019/04/16/5768/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/046295b08cb47c0a19144d444fe02443?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">dgtman</media:title>
		</media:content>
	</item>
		<item>
		<title>MSX판 프린세스 메이커1을 플레이하기까지 구구절절한 사연</title>
		<link>https://megayuchi.com/2019/04/15/msx%ed%8c%90-%ed%94%84%eb%a6%b0%ec%84%b8%ec%8a%a4-%eb%a9%94%ec%9d%b4%ec%bb%a41%ec%9d%84-%ed%94%8c%eb%a0%88%ec%9d%b4%ed%95%98%ea%b8%b0%ea%b9%8c%ec%a7%80-%ea%b5%ac%ea%b5%ac%ec%a0%88%ec%a0%88%ed%95%9c/</link>
				<comments>https://megayuchi.com/2019/04/15/msx%ed%8c%90-%ed%94%84%eb%a6%b0%ec%84%b8%ec%8a%a4-%eb%a9%94%ec%9d%b4%ec%bb%a41%ec%9d%84-%ed%94%8c%eb%a0%88%ec%9d%b4%ed%95%98%ea%b8%b0%ea%b9%8c%ec%a7%80-%ea%b5%ac%ea%b5%ac%ec%a0%88%ec%a0%88%ed%95%9c/#comments</comments>
				<pubDate>Sun, 14 Apr 2019 15:50:17 +0000</pubDate>
		<dc:creator><![CDATA[megayuchi]]></dc:creator>
				<category><![CDATA[Pub]]></category>

		<guid isPermaLink="false">http://megayuchi.com/?p=5766</guid>
				<description><![CDATA[MSX판 프린세스 메이커1을 플레이하기까지 구구절절한 사연. 1992년즈음일텐데. 당시 나는 HDD가 없이 360KB FDD 2대만 장착된 당연히 허큘리스 그래픽 카드가 달린 XT를 사용하고 있었다. 아 MNP기능 없는 2400BPS모뎀은 달려있었음. 그리고 나의 멀티미디어 머신 MSX2+가 있었다. 어느날 파라동 자료실(하이텔도 아니고 KETEL에서 KORTEL로 이름 바뀌었을때)에 MSX용 프린세스메이커가 올라왔다. 프.린.세.스.메.이.커! PC9801에나 있는 그 게임이! MSX판을 마이크로 캐빈에서 포팅했는데 과연 &#8230; <a class="more-link" href="https://megayuchi.com/2019/04/15/msx%ed%8c%90-%ed%94%84%eb%a6%b0%ec%84%b8%ec%8a%a4-%eb%a9%94%ec%9d%b4%ec%bb%a41%ec%9d%84-%ed%94%8c%eb%a0%88%ec%9d%b4%ed%95%98%ea%b8%b0%ea%b9%8c%ec%a7%80-%ea%b5%ac%ea%b5%ac%ec%a0%88%ec%a0%88%ed%95%9c/">More <span class="screen-reader-text">MSX판 프린세스 메이커1을 플레이하기까지 구구절절한&#160;사연</span></a>]]></description>
								<content:encoded><![CDATA[<p>MSX판 프린세스 메이커1을 플레이하기까지 구구절절한 사연.<br />
1992년즈음일텐데.<br />
당시 나는 HDD가 없이 360KB FDD 2대만 장착된 당연히 허큘리스 그래픽 카드가 달린 XT를 사용하고 있었다. 아 MNP기능 없는 2400BPS모뎀은 달려있었음.<br />
그리고 나의 멀티미디어 머신 MSX2+가 있었다.<br />
어느날 파라동 자료실(하이텔도 아니고 KETEL에서 KORTEL로 이름 바뀌었을때)에 MSX용 프린세스메이커가 올라왔다.<br />
프.린.세.스.메.이.커! PC9801에나 있는 그 게임이!<br />
MSX판을 마이크로 캐빈에서 포팅했는데 과연 명가 마이크로캐빈 답게 훌륭하게 포팅했다.<br />
MSX판은 인터레이스 모드를 사용해서 컷씬 장면은 무려 524&#215;424의 고퀄리티로 이미지를 출력해줬고 음성도 지원했다.<br />
게임 구성이 720KB 디스크 이미 6장이었던걸로 기억하는데..정확친 않다.<br />
하여간 문제가 여러가지 있었는데 일단 720KB x 6만큼의 용량을 한번에 저장할 장치가 없었다.<br />
그래서 고석기 군으로부터 XT에 장착 가능한 32MB짜리 MFM HDD와 컨트롤러를 빌렸다.<br />
그리고 이틀간 7시간에 걸쳐서 720KB짜리 디스크 이미지 6장을 다운 받았다. 초당 238Bytes씩 받았다. MB도 아니고 KB도 아니고 Bytes다. z-modem 다운로드 화면에선 정확히 238 cps(Characters Per Sec)를 표시해주고 있었지.<br />
그걸 360KB짜리 디스켓 12장에 옮겨담았다. 당시에 slice라는 유틸이 있었다. 원하는 만큼의 사이즈로 분할해서 파일로 만들어주는..요샌 압축유틸에 다 있는 그 기능이다. slice로 12장의 디스켓에 옮겨담고 당시 내가 공짜로 PC통신을 할때 애용하던 장소로 향했다.<br />
용산 전자월드타워 바로 앞에 지하로 내려가는 입구가 있는데 거기가 예전에 하이텔 PC통신 플라자 였다.<br />
모뎀이 장착된 PC가 3대 있었고 죽돌이들이 하루종일 거기 앉아있었다. 그 외에는 모뎀이 없는 대신 3.5&#8243; FDD와 5.25&#8243; FDD가 동시에 장착된 아무도 사용하지 않는 PC가 있었다.<br />
그 PC에서 12장의 디스켓을 6개의 이미지로 다시 풀었다. 그리고 가져간 3.5&#8243; 디스켓 6장에 옮겨담았다.<br />
그렇게 해서 집에 가져왔는데 플레이가 한방에 되었던가? 잘 기억이 나지 않는데 뭔가 문제가 있어서 용산에 한번 더 다녀왔던것 같기도 하고&#8230;<br />
그래서 결국 플레이를 했다.<br />
아 그 감동이란&#8230;</p>
]]></content:encoded>
							<wfw:commentRss>https://megayuchi.com/2019/04/15/msx%ed%8c%90-%ed%94%84%eb%a6%b0%ec%84%b8%ec%8a%a4-%eb%a9%94%ec%9d%b4%ec%bb%a41%ec%9d%84-%ed%94%8c%eb%a0%88%ec%9d%b4%ed%95%98%ea%b8%b0%ea%b9%8c%ec%a7%80-%ea%b5%ac%ea%b5%ac%ec%a0%88%ec%a0%88%ed%95%9c/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/046295b08cb47c0a19144d444fe02443?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">dgtman</media:title>
		</media:content>
	</item>
		<item>
		<title>응답성(response time)과 처리량(throuthput)은 다르다.</title>
		<link>https://megayuchi.com/2019/03/25/%ec%9d%91%eb%8b%b5%ec%84%b1response-time%ea%b3%bc-%ec%b2%98%eb%a6%ac%eb%9f%89throuthput%ec%9d%80-%eb%8b%a4%eb%a5%b4%eb%8b%a4/</link>
				<comments>https://megayuchi.com/2019/03/25/%ec%9d%91%eb%8b%b5%ec%84%b1response-time%ea%b3%bc-%ec%b2%98%eb%a6%ac%eb%9f%89throuthput%ec%9d%80-%eb%8b%a4%eb%a5%b4%eb%8b%a4/#comments</comments>
				<pubDate>Mon, 25 Mar 2019 07:24:51 +0000</pubDate>
		<dc:creator><![CDATA[megayuchi]]></dc:creator>
				<category><![CDATA[Development]]></category>
		<category><![CDATA[IT]]></category>
		<category><![CDATA[benchmark]]></category>
		<category><![CDATA[Multi Thread]]></category>
		<category><![CDATA[Performance]]></category>

		<guid isPermaLink="false">http://megayuchi.com/?p=5763</guid>
				<description><![CDATA[시간당 처리량과 응답성은 분명히 다르다. 시간당 처리량이 떨어져서 응답성이 떨어지는 경우에는 처리량을 높여서 응답성을 개선할 수 있다. 하지만 일정 수준 이상 처리량이 개선되면 응답성을 향상시키지 못한다. 100ms정도가 빠른 응답성이라고 가정하는 세상에선 처리량을 높이는게 응답성 향상으로 연결되겠지만 1ms정도에도 민감하게 반응하는 세상에선 처리량과 응답성이 거의 관련이 없을 가능성이 높다. 프로그래머라 해도 이 차이를 이해하지 못하는 경우가 많다. &#8230; <a class="more-link" href="https://megayuchi.com/2019/03/25/%ec%9d%91%eb%8b%b5%ec%84%b1response-time%ea%b3%bc-%ec%b2%98%eb%a6%ac%eb%9f%89throuthput%ec%9d%80-%eb%8b%a4%eb%a5%b4%eb%8b%a4/">More <span class="screen-reader-text">응답성(response time)과 처리량(throuthput)은 다르다.</span></a>]]></description>
								<content:encoded><![CDATA[<p>시간당 처리량과 응답성은 분명히 다르다. 시간당 처리량이 떨어져서 응답성이 떨어지는 경우에는 처리량을 높여서 응답성을 개선할 수 있다. 하지만 일정 수준 이상 처리량이 개선되면 응답성을 향상시키지 못한다.</p>
<p>100ms정도가 빠른 응답성이라고 가정하는 세상에선 처리량을 높이는게 응답성 향상으로 연결되겠지만 1ms정도에도 민감하게 반응하는 세상에선 처리량과 응답성이 거의 관련이 없을 가능성이 높다.<br />
프로그래머라 해도 이 차이를 이해하지 못하는 경우가 많다.</p>
<p>회선을 증설해서 클라우드 게이밍의 latency를 줄일수 있지 않은가? 게임에서 멀티스레드를 사용하면 응답성이 좋아지지 않는가? 라고 묻는 경우가 대표적인 케이스다.</p>
<p>SW Occlusion Culling 기능을 구현할때의 경험을 적어보겠다.<br />
KD-Tree를 탐색하면서 렌더링할 오브젝트를 골라낸다.여기서 시스템 메모리에 depth buffer를 만들고 렌더링이 확정된 오브젝트의 z값을 그린다. 그리고 렌더링할지 안할지 모르는 node(오브젝트가 아니다)의 AABB를 z-test한다. z-test결과 렌더링된 픽셀이 한개도 없으면 이 node에 속한 모든 오브젝트는 한꺼번에 트리 탐색에서 제외된다. 당연히 렌더링 파이프라인에도 아예 들어가지 않게 된다. 이걸 구현하는데 있어 핵심은 텍스쳐링만 안하는 SW Rasterizer를 구현하는거다. 당연히 삼각형을 빠르게 그리는게 제일 중요하다.</p>
<p>그러니까&#8230; 어떻게든 단위 시간 안에 많은 삼각형을 그리려고 별 짓을 다 했다.<br />
SSE, AVX는 당연히 사용했다.<br />
그래도 성능이 원하는 수준으로 나오지 않아서 절대 도움이 안될거라고 생각했던 멀티 스레드를 도입했다. 어쨌든 노는 코어가 있으니까 얘네들을 최대한 활용하면 성능이 올라가지 않을까.</p>
<p>커널 오브젝트를 Wait하는 경우를 최대한 줄이기 위해서 메인스레드가 나머지 워커스레드들을 깨우고 대기하는 대신 SetEvent()로 깨운 후에 결과를 확인하지 않고 그대로 삼각형 레스터라이즈로 진행한다. 나머지 워커 스레드들은 깨어나는대로 작업큐에 들어있는 삼각형 목록을 경쟁적으로 잡아다가 레스터라이즈 작업에 들어간다.</p>
<p>뭐 이런식이다. 동기화에 걸리는 시간을 최대한 줄이고자 직접 만들어쓰는 가장 가벼운 스핀락만 사용했다. 정말 악착같이 최적화를 했으나&#8230;</p>
<p>결과적으로 지금은 멀티스레드 코드는 사용하지 않는다.<br />
가끔은 멀티스레드 코드가 빠를때도 있었다. 하지만 전반적으로 싱글스레드 버전이 더 빨랐다.<br />
그 이유는</p>
<p>1. 다수의 코어가 활성화 되면서 터보 부스트가 꺼진다. 클럭이 떨어지면서 성능이 떨어진다.</p>
<p>2. 컨텍스트 스위칭할때 상당한 클럭을 까먹는다.</p>
<p>3. 아무리 wait를 안하려고 해도 언젠가 한번은 해야되는데 여기서 엄청 지체된다.</p>
<p>결론은 클럭 높은게 짱. 2.4Ghz 6코어 제온으로 멀티 스레드 코드 돌려봐야 4.5GHz 4코어 CPU에서 싱글 스레드 돌리는거보다 한참 느리더라. </p>
<p>물론 1시간 동안 삼각형을 몇개나 찍을수 있나로 테스트했으면 당연히 멀티스레드 버전이 높은 성능을 보였을것이다. 문제는 난 최대 4ms안에 삼각형을 많이 찍는게 중요했거든. 레스터라이즈중에 4ms를 넘기면 그대로 루프를 빠져나와버렸다. 그 이상 시간을 지체하면 프레임레이트에 오히려 나쁜 영향을 주기 때문이다. </p>
<p>&#8216;동영상 인코딩 하는거나 라이트맵 굽는것처럼 병렬화 하기 좋고 애초에 시간 엄청 걸리는 작업 아니면 몇ms 응답성 향상시키자고 멀티스레드 쓰는건 진짜 바보짓이다.&#8217; 라는 사실을 다시 한번 깨닫게 된 경험이었다.</p>
]]></content:encoded>
							<wfw:commentRss>https://megayuchi.com/2019/03/25/%ec%9d%91%eb%8b%b5%ec%84%b1response-time%ea%b3%bc-%ec%b2%98%eb%a6%ac%eb%9f%89throuthput%ec%9d%80-%eb%8b%a4%eb%a5%b4%eb%8b%a4/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/046295b08cb47c0a19144d444fe02443?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">dgtman</media:title>
		</media:content>
	</item>
		<item>
		<title>Azure VM 및 개인 장비 벤치마크</title>
		<link>https://megayuchi.com/2019/03/18/azure-vm-%eb%b0%8f-%ea%b0%9c%ec%9d%b8-%ec%9e%a5%eb%b9%84-%eb%b2%a4%ec%b9%98%eb%a7%88%ed%81%ac/</link>
				<comments>https://megayuchi.com/2019/03/18/azure-vm-%eb%b0%8f-%ea%b0%9c%ec%9d%b8-%ec%9e%a5%eb%b9%84-%eb%b2%a4%ec%b9%98%eb%a7%88%ed%81%ac/#comments</comments>
				<pubDate>Mon, 18 Mar 2019 00:28:25 +0000</pubDate>
		<dc:creator><![CDATA[megayuchi]]></dc:creator>
				<category><![CDATA[Development]]></category>
		<category><![CDATA[IT]]></category>
		<category><![CDATA[azure]]></category>
		<category><![CDATA[benchmark]]></category>
		<category><![CDATA[VM]]></category>

		<guid isPermaLink="false">http://megayuchi.com/?p=5757</guid>
				<description><![CDATA[Voxel Horizon의 서비스에 필요한 VM사양을 알아보다가 생각난 김에 개인장비들까지 벤치마크를 돌려서 정리했다. Geekbench 4.3.3을 사용했다. Azaure DS2 v3는 현재 테스트 서버로 사용하고 있는 인스턴스 타입이다. F4S와 F8S_v2는 Voxel Horizon서비스 할때 실제로 사용하려고 하는 인스턴스 타입이다. NV6는 GPU인스턴스로 CUDA와 DirectX테스트를 위해 가끔 사용하는 인스턴스 타입이다. 돈없는 개인이 노려볼만한 스펙의 인스턴스가 DS2 v3인데 성능이 GPDWIN2만도 못한게 함정. &#8230; <a class="more-link" href="https://megayuchi.com/2019/03/18/azure-vm-%eb%b0%8f-%ea%b0%9c%ec%9d%b8-%ec%9e%a5%eb%b9%84-%eb%b2%a4%ec%b9%98%eb%a7%88%ed%81%ac/">More <span class="screen-reader-text">Azure VM 및 개인 장비&#160;벤치마크</span></a>]]></description>
								<content:encoded><![CDATA[<p>Voxel Horizon의 서비스에 필요한 VM사양을 알아보다가 생각난 김에 개인장비들까지 벤치마크를 돌려서 정리했다.</p>
<p>Geekbench 4.3.3을 사용했다.<br />
Azaure DS2 v3는 현재 테스트 서버로 사용하고 있는 인스턴스 타입이다.<br />
F4S와 F8S_v2는 Voxel Horizon서비스 할때 실제로 사용하려고 하는 인스턴스 타입이다.<br />
NV6는 GPU인스턴스로 CUDA와 DirectX테스트를 위해 가끔 사용하는 인스턴스 타입이다.</p>
<p>돈없는 개인이 노려볼만한 스펙의 인스턴스가 DS2 v3인데 성능이 GPDWIN2만도 못한게 함정. 놀라울 정도로 성능이 떨어진다. 실질적으로 F4s이상은 사용해야한다.</p>
<table width="1238">
<tbody>
<tr>
<td width="345"></td>
<td width="135">Cores or vCores</td>
<td width="133">RAM</td>
<td width="119">Single</td>
<td width="118">Multi</td>
<td width="388"></td>
</tr>
<tr>
<td width="345">Desktop i7 8700K</td>
<td>6</td>
<td>16GB</td>
<td width="119">5469</td>
<td width="118">24495</td>
<td><a href="https://browser.geekbench.com/v4/cpu/12443656">https://browser.geekbench.com/v4/cpu/12443656</a></td>
</tr>
<tr>
<td>Desktop I3 2100</td>
<td>2</td>
<td>16GB</td>
<td width="119">2940</td>
<td width="118">5694</td>
<td><a href="https://browser.geekbench.com/v4/cpu/12433376">https://browser.geekbench.com/v4/cpu/12433376</a></td>
</tr>
<tr>
<td>Alienware 15 (2015 early)</td>
<td>4</td>
<td>16GB</td>
<td width="119">3884</td>
<td width="118">11668</td>
<td><a href="https://browser.geekbench.com/v4/cpu/12444110">https://browser.geekbench.com/v4/cpu/12444110</a></td>
</tr>
<tr>
<td>Surface Pro 2</td>
<td>2</td>
<td>4GB</td>
<td width="119">3205</td>
<td width="118">5980</td>
<td><a href="https://browser.geekbench.com/v4/cpu/12440758">https://browser.geekbench.com/v4/cpu/12440758</a></td>
</tr>
<tr>
<td>Surface Book 1</td>
<td>2</td>
<td>8GB</td>
<td width="119">3726</td>
<td width="118">7271</td>
<td><a href="https://browser.geekbench.com/v4/cpu/12443671">https://browser.geekbench.com/v4/cpu/12443671</a></td>
</tr>
<tr>
<td>Surface Book 2</td>
<td>4</td>
<td>16GB</td>
<td width="119">4655</td>
<td width="118">13879</td>
<td><a href="https://browser.geekbench.com/v4/cpu/12432908">https://browser.geekbench.com/v4/cpu/12432908</a></td>
</tr>
<tr>
<td>GPDWIN2 64-bit x86 Intel Core M3-7Y30</td>
<td>2</td>
<td>8GB</td>
<td width="119">3174</td>
<td width="118">6304</td>
<td><a href="https://browser.geekbench.com/v4/cpu/12433095">https://browser.geekbench.com/v4/cpu/12433095</a></td>
</tr>
<tr>
<td>Azure Standard NV6 (6 vcpus, 56 GB memory)</td>
<td>6</td>
<td>56GB</td>
<td width="119">3317</td>
<td width="118">15651</td>
<td><a href="https://browser.geekbench.com/v4/cpu/12432990">https://browser.geekbench.com/v4/cpu/12432990</a></td>
</tr>
<tr>
<td>Azure Standard F4s (4 vcpus, 8 GB memory)</td>
<td>4</td>
<td>8GB</td>
<td width="119">3040</td>
<td width="118">9240</td>
<td><a href="https://browser.geekbench.com/v4/cpu/12433157">https://browser.geekbench.com/v4/cpu/12433157</a></td>
</tr>
<tr>
<td>Azure Standard F8s_v2 (8 vcpus, 16 GB memory)</td>
<td>8</td>
<td>16GB</td>
<td width="119">3880</td>
<td width="118">15791</td>
<td><a href="https://browser.geekbench.com/v4/cpu/12433261">https://browser.geekbench.com/v4/cpu/12433261</a></td>
</tr>
<tr>
<td>Azure Standard F16s_v2 (16 vcpus, 32 GB memory)</td>
<td>16</td>
<td>32GB</td>
<td width="119">3929</td>
<td width="118">27709</td>
<td><a href="https://browser.geekbench.com/v4/cpu/12432849">https://browser.geekbench.com/v4/cpu/12432849</a></td>
</tr>
<tr>
<td>Azure Standard F32s_v2 (32 vcpus, 64 GB memory)</td>
<td>32</td>
<td>64GB</td>
<td width="119">3859</td>
<td width="118">39824</td>
<td><a href="https://browser.geekbench.com/v4/cpu/12433386">https://browser.geekbench.com/v4/cpu/12433386</a></td>
</tr>
<tr>
<td>Azure Standard D2s v3 (2 vcpus, 8 GB memory)</td>
<td>2</td>
<td>8GB</td>
<td width="119">2807</td>
<td width="118">3593</td>
<td><a href="https://browser.geekbench.com/v4/cpu/12433044">https://browser.geekbench.com/v4/cpu/12433044</a></td>
</tr>
</tbody>
</table>
<p>Multi 점수 순위</p>
<table width="732">
<tbody>
<tr>
<td width="345">Azure Standard F32s_v2 (32 vcpus, 64 GB memory)</td>
<td width="135">32</td>
<td width="133">64GB</td>
<td width="119">39824</td>
</tr>
<tr>
<td>Azure Standard F16s_v2 (16 vcpus, 32 GB memory)</td>
<td>16</td>
<td>32GB</td>
<td width="119">27709</td>
</tr>
<tr>
<td width="345">Desktop i7 8700K</td>
<td>6</td>
<td>16GB</td>
<td width="119">24495</td>
</tr>
<tr>
<td>Azure Standard F8s_v2 (8 vcpus, 16 GB memory)</td>
<td>8</td>
<td>16GB</td>
<td width="119">15791</td>
</tr>
<tr>
<td>Azure Standard NV6 (6 vcpus, 56 GB memory)</td>
<td>6</td>
<td>56GB</td>
<td width="119">15651</td>
</tr>
<tr>
<td>Surface Book 2</td>
<td>4</td>
<td>16GB</td>
<td width="119">13879</td>
</tr>
<tr>
<td>Alienware 15 (2015 early)</td>
<td>4</td>
<td>16GB</td>
<td width="119">11668</td>
</tr>
<tr>
<td>Azure Standard F4s (4 vcpus, 8 GB memory)</td>
<td>4</td>
<td>8GB</td>
<td width="119">9240</td>
</tr>
<tr>
<td>Surface Book 1</td>
<td>2</td>
<td>8GB</td>
<td width="119">7271</td>
</tr>
<tr>
<td>GPDWIN2 64-bit x86 Intel Core M3-7Y30</td>
<td>2</td>
<td>8GB</td>
<td width="119">6304</td>
</tr>
<tr>
<td>Surface Pro 2</td>
<td>2</td>
<td>4GB</td>
<td width="119">5980</td>
</tr>
<tr>
<td>Desktop I3 2100</td>
<td>2</td>
<td>16GB</td>
<td width="119">5694</td>
</tr>
<tr>
<td>Azure Standard D2s v3 (2 vcpus, 8 GB memory)</td>
<td>2</td>
<td>8GB</td>
<td width="119">3593</td>
</tr>
</tbody>
</table>
<p>Single 점수 순위</p>
<table width="732">
<tbody>
<tr>
<td width="345">Desktop i7 8700K</td>
<td width="135">6</td>
<td width="133">16GB</td>
<td width="119">5469</td>
</tr>
<tr>
<td>Surface Book 2</td>
<td>4</td>
<td>16GB</td>
<td width="119">4655</td>
</tr>
<tr>
<td>Azure Standard F16s_v2 (16 vcpus, 32 GB memory)</td>
<td>16</td>
<td>32GB</td>
<td width="119">3929</td>
</tr>
<tr>
<td>Alienware 15 (2015 early)</td>
<td>4</td>
<td>16GB</td>
<td width="119">3884</td>
</tr>
<tr>
<td>Azure Standard F8s_v2 (8 vcpus, 16 GB memory)</td>
<td>8</td>
<td>16GB</td>
<td width="119">3880</td>
</tr>
<tr>
<td>Azure Standard F32s_v2 (32 vcpus, 64 GB memory)</td>
<td>32</td>
<td>64GB</td>
<td width="119">3859</td>
</tr>
<tr>
<td>Surface Book 1</td>
<td>2</td>
<td>8GB</td>
<td width="119">3726</td>
</tr>
<tr>
<td>Azure Standard NV6 (6 vcpus, 56 GB memory)</td>
<td>6</td>
<td>56GB</td>
<td width="119">3317</td>
</tr>
<tr>
<td>Surface Pro 2</td>
<td>2</td>
<td>4GB</td>
<td width="119">3205</td>
</tr>
<tr>
<td>GPDWIN2 64-bit x86 Intel Core M3-7Y30</td>
<td>2</td>
<td>8GB</td>
<td width="119">3174</td>
</tr>
<tr>
<td>Azure Standard F4s (4 vcpus, 8 GB memory)</td>
<td>4</td>
<td>8GB</td>
<td width="119">3040</td>
</tr>
<tr>
<td>Desktop I3 2100</td>
<td>2</td>
<td>16GB</td>
<td width="119">2940</td>
</tr>
<tr>
<td>Azure Standard D2s v3 (2 vcpus, 8 GB memory)</td>
<td>2</td>
<td>8GB</td>
<td width="119">2807</td>
</tr>
</tbody>
</table>
]]></content:encoded>
							<wfw:commentRss>https://megayuchi.com/2019/03/18/azure-vm-%eb%b0%8f-%ea%b0%9c%ec%9d%b8-%ec%9e%a5%eb%b9%84-%eb%b2%a4%ec%b9%98%eb%a7%88%ed%81%ac/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/046295b08cb47c0a19144d444fe02443?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">dgtman</media:title>
		</media:content>
	</item>
		<item>
		<title>Game Dev  &#8211; Voxel Horizon &#8211; 가변 월드 사이즈 적용을 위한 사전작업</title>
		<link>https://megayuchi.com/2019/03/06/game-dev-voxel-horizon-%ea%b0%80%eb%b3%80-%ec%9b%94%eb%93%9c-%ec%82%ac%ec%9d%b4%ec%a6%88-%ec%a0%81%ec%9a%a9%ec%9d%84-%ec%9c%84%ed%95%9c-%ec%82%ac%ec%a0%84%ec%9e%91%ec%97%85/</link>
				<comments>https://megayuchi.com/2019/03/06/game-dev-voxel-horizon-%ea%b0%80%eb%b3%80-%ec%9b%94%eb%93%9c-%ec%82%ac%ec%9d%b4%ec%a6%88-%ec%a0%81%ec%9a%a9%ec%9d%84-%ec%9c%84%ed%95%9c-%ec%82%ac%ec%a0%84%ec%9e%91%ec%97%85/#comments</comments>
				<pubDate>Wed, 06 Mar 2019 13:41:33 +0000</pubDate>
		<dc:creator><![CDATA[megayuchi]]></dc:creator>
				<category><![CDATA[Development]]></category>
		<category><![CDATA[Game Dev]]></category>
		<category><![CDATA[Voxel Horizon]]></category>

		<guid isPermaLink="false">http://megayuchi.com/?p=5753</guid>
				<description><![CDATA[먼저번에 node사이즈를 꽤 줄여서 KD-Tree메모리로 56MB 사용하던것을 18M로 줄였다. 그 다음으로 맵 유형에 따라 Tree의 사이즈를 가변적으로 선택할 수 있도록 작업하고 있다. 지금까지는 월드 사이즈를 1km x 1km x 0.32km 고정으로 설정했었다. 이것은 kd-tree가 커버하는 사이즈이기도 하며 복셀월드에서 복셀들이 차지하는 실제 사이즈와는 관계가 없다. 퍼블릭맵에서는 1km x 1km를 기본으로 하고 있으므로 문제가 될것이 없다. 하지만 &#8230; <a class="more-link" href="https://megayuchi.com/2019/03/06/game-dev-voxel-horizon-%ea%b0%80%eb%b3%80-%ec%9b%94%eb%93%9c-%ec%82%ac%ec%9d%b4%ec%a6%88-%ec%a0%81%ec%9a%a9%ec%9d%84-%ec%9c%84%ed%95%9c-%ec%82%ac%ec%a0%84%ec%9e%91%ec%97%85/">More <span class="screen-reader-text">Game Dev  &#8211; Voxel Horizon &#8211; 가변 월드 사이즈 적용을 위한&#160;사전작업</span></a>]]></description>
								<content:encoded><![CDATA[<p>먼저번에 node사이즈를 꽤 줄여서 KD-Tree메모리로 56MB 사용하던것을 18M로 줄였다. 그 다음으로 맵 유형에 따라 Tree의 사이즈를 가변적으로 선택할 수 있도록 작업하고 있다.</p>
<p>지금까지는 월드 사이즈를 1km x 1km x 0.32km 고정으로 설정했었다. 이것은 kd-tree가 커버하는 사이즈이기도 하며 복셀월드에서 복셀들이 차지하는 실제 사이즈와는 관계가 없다.<br />
퍼블릭맵에서는 1km x 1km를 기본으로 하고 있으므로 문제가 될것이 없다. 하지만 개인맵의 경우 256m x 256m 정도면 충분할것인데 1km x 1km를 가정한 tree사이즈는 꽤 낭비가 된다. 1km x 1km x 0.32km를 위한 KD-Tree사이즈는 현재 18MB정도이다. 256m x 256m x 320m에 딱 맞춘 tree를 생성한다면 메모리 사이즈를 1/16정도로 줄일 수 있다.</p>
<p>다음과 같은 간단한 목표를 정했다.<br />
1) 퍼블릭맵과 개인맵등 몇가지 유형으로 맵의 최대 사이즈를 설정한다.<br />
2) 맵 사이즈가 작으면 그에 맞는 크기의 tree를 생성한다.</p>
<p>아주 심플하고 별 작업 아닌거 같다. 처음엔 그렇게 생각했다.<br />
우선 예전에 엔진과 클라이언트/서버에서 오브젝트의 좌표를 다룰때 어떻게 다뤘는가를 살펴보자.</p>
<p>이전엔 패킷이나 파일에 복셀 오브젝트의 좌표를 저장할때 float좌표 대신 2 bytes * 3 = 6 bytes를 사용했다.<br />
복셀월드의 최대 사이즈를 고정해뒀었으므로 float좌표를 int좌표로 저장할 수 있다. 즉<br />
복셀 오브젝트의 float 좌표 = world_min + voxel_object_size * int좌표<br />
라는 관계가 성립한다.<br />
오브젝트의 좌표를 float 4bytes씩 12 bytes를 쓰는대신 int타입으로 관리하면 월드 최대 사이즈를 감안할때 좌표 성분당 2 bytes에도 충분히 들어가므로 6 bytes로 줄일 수 있다. 이게 복셀 지오메트리를 패킷으로 전달할땐 꽤 의미가 크다.</p>
<p>그런데 월드 사이즈가 가변이 되면 이렇게 저장해둔 정수형 좌표들은 전혀 사용할 수 없다. world_min이 고정이 아니기 때문이다. 고정된 world_min을 가정하고 저장된 int좌표는 아무짝에 쓸모가 없다. </p>
<p>그래서 6 bytes좌표 사이즈를 유지하면서 world_min이 달라져도 상관없도록 패킷과 파일에 저장할때의 좌표체계는 다음과 같이 수정했다.</p>
<p>성분당 좌표(x,y,z) = float좌표 / 오브젝트의 사이즈<br />
성분당 좌표의 크기는 2 bytes 씩 총 6 bytes다.</p>
<p>이렇게 하면 오브젝트 사이즈는 400cm이므로 부호까지 감안하면 short타입 한 성분(x,y,z)으로 약 13km를 커버할 수 있다.</p>
<p>이제 실무적인 문제인데 엔진에 예전좌표계로 처리하는 코드가 꽤 있고 엔진 API를 사용하는 서버와 클라이언트 코드도 예전 좌표계로 처리하는 코드의 양이 상당하다. 게다가 그 코드들을 이용해서 파일에 저장된 복셀 파일들도 문제다. 새로운 좌표체계로 변환하거나 호환성을 유지하도록 하려면 작업량이 꽤 된다.</p>
<p>그래서 단순히 &#8216;맵의 최대 사이즈를 가변으로 하자&#8217;라는 목표를 달성하기 위해서 대량의 코드수정이 불가피하게 됐다.</p>
<p>매우 재미없고 지루하고 신경 곤두서는 작업이었다.</p>
<p>1) 엔진부터 시작해서 복셀 오브젝트의 위치에 int좌표계를 사용하는 코드는 싸그리 float기반으로 바꿨다. 이 float좌표계가 패킷과 파일에 저장될때는 short 2 bytes * 3 = 6 bytes로 저장되고 반대로도 가져올 수 있도록 코드를 수정했다.</p>
<p>2) 기존에 저장된 파일들을 로드할 경우 버전 체크를 해서 호환성을 유지할 수 있도록 했다.</p>
<p>3) 복셀 엔진에서 꽤 복잡한 코드를 자랑하는 소유권 저장 테이블이 기존 int좌표체계를 사용하므로 얘네들을 몽땅 float기반으로 바꿨다.</p>
<p>이렇게 엔진과 엔진 api를 사용하는 서버/클라이언트까지 코드를 싸그리 다 고치는데 이틀 걸렸다.</p>
<p>그리고 수정한 모든 코드 라인에 브레이크 포인트를 다 찍어서 브레이크 포인트가 하나도 남지 않을때까지 테스트를 했다. 총 3일 소요.</p>
<p>이제 트리 사이즈를 가변으로 할 수 있는 준비가 됐다.</p>
]]></content:encoded>
							<wfw:commentRss>https://megayuchi.com/2019/03/06/game-dev-voxel-horizon-%ea%b0%80%eb%b3%80-%ec%9b%94%eb%93%9c-%ec%82%ac%ec%9d%b4%ec%a6%88-%ec%a0%81%ec%9a%a9%ec%9d%84-%ec%9c%84%ed%95%9c-%ec%82%ac%ec%a0%84%ec%9e%91%ec%97%85/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/046295b08cb47c0a19144d444fe02443?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">dgtman</media:title>
		</media:content>
	</item>
		<item>
		<title>사업 구상(?)은 아니고 그냥 푸념.</title>
		<link>https://megayuchi.com/2019/02/27/%ec%82%ac%ec%97%85-%ea%b5%ac%ec%83%81/</link>
				<comments>https://megayuchi.com/2019/02/27/%ec%82%ac%ec%97%85-%ea%b5%ac%ec%83%81/#comments</comments>
				<pubDate>Wed, 27 Feb 2019 11:29:21 +0000</pubDate>
		<dc:creator><![CDATA[megayuchi]]></dc:creator>
				<category><![CDATA[Development]]></category>
		<category><![CDATA[Pub]]></category>

		<guid isPermaLink="false">http://megayuchi.com/?p=5748</guid>
				<description><![CDATA[네 프로젝트에 자신 있으면 빚내서 창업을 하면 되지 않느냐? 라고 하는 소리도 가끔 듣는다. 돈벌 자신이 있는건 아니다. 그렇다고 또 자신이 완전 없는것도 아니다. 문제는 수익 창출에 걸리는 시간과 과정이다. 내가 생각하는 수익 모델과 수익을 창출할때까지 걸리는 시간, 과정을 생각해보면 빚내서 사업하는건 자살 행위다. 난 몇개월 반짝 개발해서 한방을 노리는 그런걸 만들려는게 아니다. (만약에 회사를 &#8230; <a class="more-link" href="https://megayuchi.com/2019/02/27/%ec%82%ac%ec%97%85-%ea%b5%ac%ec%83%81/">More <span class="screen-reader-text">사업 구상(?)은 아니고 그냥&#160;푸념.</span></a>]]></description>
								<content:encoded><![CDATA[<p>네 프로젝트에 자신 있으면 빚내서 창업을 하면 되지 않느냐?<br />
라고 하는 소리도 가끔 듣는다.<br />
돈벌 자신이 있는건 아니다. 그렇다고 또 자신이 완전 없는것도 아니다. 문제는 수익 창출에 걸리는 시간과 과정이다.<br />
내가 생각하는 수익 모델과 수익을 창출할때까지 걸리는 시간, 과정을 생각해보면 빚내서 사업하는건 자살 행위다.</p>
<p>난 몇개월 반짝 개발해서 한방을 노리는 그런걸 만들려는게 아니다.<br />
(만약에 회사를 만든다면) 다른 업체가 쉽게 따라하지 못하는 기술기반을 가지고 길게 가는 회사를 만들고 싶다.<br />
지금 하는것도 그렇고 난 &#8216;이 게임에 모든걸 건다&#8217;라는 생각은 결코 하지 않는다.</p>
<p>게임 자체는 망할수도 있다. 게임은 망해도 기술은 남는다. 아니 남아야 한다. 외부 기술을 사서 사용하는 경우 게임이 망하면 남는게 없다. </p>
<p>그래픽 엔진과 그래픽스 기술을 그대로 접목한 서버기술까지 다 가지고 있고 계속 유지/발전시켜왔다.<br />
장담하는데 다른 어느 업체의 온라인 게임 기술보다 서버와 클라이언트가 긴밀하게 잘 붙어있다. 서버를 유지보수하면 클라이언트도 유지보수 된다. 클라이언트를 유지보수하면 서버도 유지보수 된다. 따라서 월등히 적은 인원으로 유지보수해나갈 수 있다. </p>
<p>게임 내 컨텐츠의  양적인 부분으론 A급 MMO처럼은 만들 수 없다. 하지만 기반 기술의 완성도 면에선 절대 뒤지지 않는다. MMO기술 베이스로 딱 보여줄것만 보여주는 B급 게임은 저렴한 비용으로 찍어낼 수 있다. 찍어내면서도 엔진은 계속 업데이트 된다. 엔진이 업데이트 되면 게임도 자동으로 업데이트 된다.</p>
<p>Project D Online을 혼자 서비스 할 수 있었던게 그 때문이다. 스팀에서 판매를 중지한 이후에도 기반 기술들을 계속 업데이트 해왔기 때문에 2014년전에 서비스를 중지한 Project D Online도 지금 DX12로 돌아가고 UWP버전(XBOX에서 돌릴 수 있다)도 지원한다.</p>
<p>대박이 나면 좋겠지만 대박에 모든걸 걸기엔 리스크가 너무 크다. 그보단 적은 비용으로 게임을 계속 찍어내는 쪽이 더 현실성 있다고 생각한다. 저품질의 게임을 찍어내는것이 아니고 어느정도 이상의 퀄리티를 보장하는 게임을 찍어낸다. 또 계속 업데이트 해나갈 수 있다면 충분히 승산이 있다.</p>
<p>내가 2003년에 만든 엔진으로 아직 서비스하는 모 게임이 있다. 엔진쪽은 유지보수가 전혀 안되고 있어서 날로 그래픽이 더 나빠지지만 (라이트맵 굽는 방법도 완전히 잊혀진것 같다) 그래도 아직 서비스하고 있고 플레이하는 사람들이 있다. 온라인 게임은 업데이트를 꾸준히 해주면 다 수요가 있다. 큰 돈은 못벌어도 꾸준한 수입은 된다.</p>
<p>그런데 이런 방식으로 초반에 돈 벌긴 힘들다. 정상 궤도에 들어가려면 게임을 2개 정도는 출시해야하고 회사가 2-3년은 버텨줘야 한다. 회사 1년 유지하는 비용조차 개인이 낼 수 있는 빚으로는 감당할 수 없다. 하물며 2-3년치 자금을 어떻게 조달하나.<br />
그러니 개인으로 인디 게임 만들어서 스팀에 올리는걸 생각하는게 고작인 것이다.</p>
]]></content:encoded>
							<wfw:commentRss>https://megayuchi.com/2019/02/27/%ec%82%ac%ec%97%85-%ea%b5%ac%ec%83%81/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/046295b08cb47c0a19144d444fe02443?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">dgtman</media:title>
		</media:content>
	</item>
		<item>
		<title>Voxel Horizon &#8211; 개인맵</title>
		<link>https://megayuchi.com/2019/02/25/voxel-horizon-%ea%b0%9c%ec%9d%b8%eb%a7%b5/</link>
				<comments>https://megayuchi.com/2019/02/25/voxel-horizon-%ea%b0%9c%ec%9d%b8%eb%a7%b5/#comments</comments>
				<pubDate>Mon, 25 Feb 2019 14:24:52 +0000</pubDate>
		<dc:creator><![CDATA[megayuchi]]></dc:creator>
				<category><![CDATA[Development]]></category>
		<category><![CDATA[Game Dev]]></category>
		<category><![CDATA[Voxel Horizon]]></category>

		<guid isPermaLink="false">http://megayuchi.com/?p=5745</guid>
				<description><![CDATA[플레이어가 공용맵에서 지형을 마구 뽀개거나 마구 건물을 짓거나 하면 다른 플레이어에게 큰 피해가 된다. 따라서 공용맵에선 복셀 편집 기능을 제한해야 한다. 그래서 공용맵에선 플레이어당 편집 범위가 32m x 32m로 제한된다. 또한 마을이나 전투필드처럼 NPC가 배치되는 맵의 경우 지형을 함부로 변경하면 곤란하다. 안전장치로 마을이나 전투 필드에선 복셀을 파괴하더라도 몇초후 자동복구 되도록 했다. 그런데 이렇게 제약사항이 많아지면 &#8230; <a class="more-link" href="https://megayuchi.com/2019/02/25/voxel-horizon-%ea%b0%9c%ec%9d%b8%eb%a7%b5/">More <span class="screen-reader-text">Voxel Horizon &#8211;&#160;개인맵</span></a>]]></description>
								<content:encoded><![CDATA[<p>플레이어가 공용맵에서 지형을 마구 뽀개거나 마구 건물을 짓거나 하면 다른 플레이어에게 큰 피해가 된다. 따라서 공용맵에선 복셀 편집 기능을 제한해야 한다.<br />
그래서 공용맵에선 플레이어당 편집 범위가 32m x 32m로 제한된다.<br />
또한 마을이나 전투필드처럼 NPC가 배치되는 맵의 경우 지형을 함부로 변경하면 곤란하다. 안전장치로 마을이나 전투 필드에선 복셀을 파괴하더라도 몇초후 자동복구 되도록 했다.</p>
<p>그런데 이렇게 제약사항이 많아지면 즐겁게 건축물을 만들 수 없다. 건물 짓는것뿐만 아니라 크래프팅 외에도 공용맵에선 이런저런 문제들로 제약을 둘 수 밖에 없다. 옆에서 건물 짓고 있는데 자기들끼리 전투한다고 마구 쏴대는것도 곤란하다. 전투를 위해서도 어떤 격리된 공간이 필요하다.</p>
<p>그래서 개인맵 기능을 구현하고 있다.<br />
내가 만든 맵에 다른 플레이어를 초대해서 전투를 하거나 같이 건물을 짓는다. 이것이 이 게임의 주요 컨셉이다.</p>
<p>대략 기능 목록은 이렇다.</p>
<ul>
<li>모든 플레이어는 자신만의 개인맵을 생성/폐기할 수 있다.</li>
<li>모든 플레이어들은 현재 존재하는 개인맵의 목록을 볼 수 있다.</li>
<li>플레이어는 다른 플레이어가 만든 만든 맵에 입장할 수 있다. 단 맵 주인의 허가가 필요하다.</li>
<li>플레이어는 내가 만든 맵에 다른 플레이어를 초청할 수 있다. 이 경우도 초청을 받은 플레이어가 수락해야한다.</li>
<li>맵 주인은 맵에 입장한 다른 플레이어들을 쫓아낼 수 있다.</li>
<li>맵 주인은 다른 플레이어에게 전투/편집 권한을 선택적으로 부여할 수 있다.(아직 미구현)</li>
<li>맵 주인은 맵을 전투모드 또는 크래프트 모드로 전환할 수 있다.(아직 미구현)</li>
</ul>
<p>기능 자체는 별거 아니지만 실제 구현하는데는 꽤 시간이 걸렸다.<br />
원인은 다음과 같다.</p>
<p>[인스턴싱 관련 버그]<br />
개인맵은 기본적으로 인스턴싱을 사용한다.<br />
기본 템플릿으로 로드해둔 복셀기반의 씬으로부터 인스턴스맵을 만든다. 이 경우 템플릿에 있는 복셀 지오메트리들은 복사되지도 새로 생성되지도 않는다. 인스턴스맵은 이 지오메트리를 참조해서 충돌처리와 렌더링을 수행한다. 그러다가 전투나 복셀 편집으로 인해 복셀 지오메트리에 변화가 생기면 입이벤트가 발생한 복셀 오브젝트는 참조에서 인스턴스로 바뀐다.<br />
이 기능 자체는 꽤 오래전에 만들어뒀고 문제없이 잘 작동한다고 생각했다.<br />
이걸 서버에서 본격적으로 사용하기 시작했고 전투 외에 복셀 편집 기능을 추가하니 문제가 생겼다. 아니 원래 있었던 버그가 드러났다.<br />
이 문제를 해결하느라 제법 시간을 소모했다. 물론 그 덕에 복셀 엔진의 안정성을 꽤 높일 수 있었다.</p>
<p>[픽킹 문제]<br />
새로운 복셀을 추가할때, 복셀을 제거할때, 색을 칠할때, 각각의 복셀 지오메트리 픽킹 방법이 있다. 픽킹에 대해선 문제가 약간 있는건 알고 있었지만 나중에 처리할 생각으로 계속 미뤄두고 있었다. 개인맵에서 복셀 편집 기능을 테스트하다보니 픽킹 문제가 상당히 거슬렸다. 개인맵은 복셀편집이 주니까. 이 상태로는 개인맵의 테스트 자체도 제대로 이루어지지 않는다.<br />
복셀 관련 픽킹 코드를 손봐서 거의 문제없이 돌도록(일단 알고 있는 문젠제는 없도록) 처리했다.</p>
<p>일단 기본적인 기능은 구현했다. 아직 할일이 많다. 개인맵 관련 UI는 아직 만들지 않았다. 복셀 지오메트리가 소모하는 메모리도 더 줄여야하고 인스턴스맵 생성도 백그라운드 태스크로 빼야한다.<br />
그래도 이 정도로 일단 플레이는 가능하다.<br />
잘 돈다.</p>
<div class="jetpack-video-wrapper"><iframe class='youtube-player' type='text/html' width='748' height='421' src='https://www.youtube.com/embed/ohEgPJ397QQ?version=3&#038;rel=1&#038;fs=1&#038;autohide=2&#038;showsearch=0&#038;showinfo=1&#038;iv_load_policy=1&#038;wmode=transparent' allowfullscreen='true' style='border:0;'></iframe></div>
]]></content:encoded>
							<wfw:commentRss>https://megayuchi.com/2019/02/25/voxel-horizon-%ea%b0%9c%ec%9d%b8%eb%a7%b5/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
						
		<media:thumbnail url="https://megayuchi.files.wordpress.com/2019/02/2019_0225_private_map_basic.jpg" />
		<media:content url="https://megayuchi.files.wordpress.com/2019/02/2019_0225_private_map_basic.jpg" medium="image">
			<media:title type="html">2019_0225_private_map_basic</media:title>
		</media:content>

		<media:content url="https://0.gravatar.com/avatar/046295b08cb47c0a19144d444fe02443?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">dgtman</media:title>
		</media:content>
	</item>
		<item>
		<title>홋카이도 여행기 2018.11.20 &#8211; 11.23</title>
		<link>https://megayuchi.com/2019/02/16/%ed%99%8b%ec%b9%b4%ec%9d%b4%eb%8f%84-%ec%97%ac%ed%96%89%ea%b8%b0-2018-11-20-11-23/</link>
				<comments>https://megayuchi.com/2019/02/16/%ed%99%8b%ec%b9%b4%ec%9d%b4%eb%8f%84-%ec%97%ac%ed%96%89%ea%b8%b0-2018-11-20-11-23/#comments</comments>
				<pubDate>Sat, 16 Feb 2019 00:07:16 +0000</pubDate>
		<dc:creator><![CDATA[megayuchi]]></dc:creator>
				<category><![CDATA[Travelogue]]></category>

		<guid isPermaLink="false">http://megayuchi.com/?p=5743</guid>
				<description><![CDATA[https://sway.office.com/XuPJu1Ud4zt4KUrb?ref=Link]]></description>
								<content:encoded><![CDATA[<p><a href="https://sway.office.com/XuPJu1Ud4zt4KUrb?ref=Link" rel="nofollow">https://sway.office.com/XuPJu1Ud4zt4KUrb?ref=Link</a></p>
]]></content:encoded>
							<wfw:commentRss>https://megayuchi.com/2019/02/16/%ed%99%8b%ec%b9%b4%ec%9d%b4%eb%8f%84-%ec%97%ac%ed%96%89%ea%b8%b0-2018-11-20-11-23/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/046295b08cb47c0a19144d444fe02443?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">dgtman</media:title>
		</media:content>
	</item>
	</channel>
</rss>
