<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko_KR"><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="https://osmania-dev.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://osmania-dev.github.io/" rel="alternate" type="text/html" hreflang="ko_KR" /><updated>2018-07-30T16:18:36+00:00</updated><id>https://osmania-dev.github.io/</id><title type="html">오스매냐</title><subtitle>컴퓨터가 좋았고 개발이 즐거웠고&lt;br/&gt;늘 알아가는 것이 재미있고&lt;br/&gt; 만들어가는 시간이 흥미로운 개발자.
</subtitle><author><name>Danny Cho(osmania)</name><email>osmania0611@gmail.com</email></author><entry><title type="html">SpringCamp 2018 - 11번가 Spring Cloud 기반 MSA 전환 1년간의 이야기</title><link href="https://osmania-dev.github.io/review/2018/04/21/springcamp-2018-3/" rel="alternate" type="text/html" title="SpringCamp 2018 - 11번가 Spring Cloud 기반 MSA 전환 1년간의 이야기" /><published>2018-04-21T00:00:00+00:00</published><updated>2018-04-21T00:00:00+00:00</updated><id>https://osmania-dev.github.io/review/2018/04/21/springcamp-2018-3</id><content type="html" xml:base="https://osmania-dev.github.io/review/2018/04/21/springcamp-2018-3/">&lt;h2 id=&quot;11번가-spring-cloud-기반-msa-전환-1년간의-이야기---윤용성-sk플래닛&quot;&gt;11번가 Spring Cloud 기반 MSA 전환 1년간의 이야기 - 윤용성 SK플래닛&lt;/h2&gt;
&lt;p&gt;[아쉽게 사진을 못찍었다]&lt;/p&gt;

&lt;h2 id=&quot;기존&quot;&gt;기존&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;2016년 거대 모놀리틱 시스템&lt;/li&gt;
  &lt;li&gt;코드르르 한번애 배포
    &lt;ul&gt;
      &lt;li&gt;잦은 장애&lt;/li&gt;
      &lt;li&gt;정기배포&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;새로운 기술 접해볼 기회 봉쇄
    &lt;ul&gt;
      &lt;li&gt;java 1.6&lt;/li&gt;
      &lt;li&gt;spring 2.X&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;개발환경 띄우는 것 조차 버거움&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;필요한-것만-점진적으로&quot;&gt;필요한 것만 점진적으로&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Vine&lt;/li&gt;
  &lt;li&gt;DB Flag 기반으로 기존과 새로운 API로의 전달로 제어&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;msa-플랫폼&quot;&gt;MSA 플랫폼&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;기존의 Best 방식을 적용하기
    &lt;ul&gt;
      &lt;li&gt;넷플릭스 OSS&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;개발자가 친숙한
    &lt;ul&gt;
      &lt;li&gt;Spring Boot&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스프링 클라우드 선택
    &lt;ul&gt;
      &lt;li&gt;히스트릭스&lt;/li&gt;
      &lt;li&gt;리본&lt;/li&gt;
      &lt;li&gt;유레카&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;hystrix&quot;&gt;Hystrix&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;circuit braker&lt;/li&gt;
  &lt;li&gt;failback&lt;/li&gt;
  &lt;li&gt;thread&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;histrix-적용&quot;&gt;Histrix 적용&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HistrixCommand&lt;/li&gt;
  &lt;li&gt;내가 호출한 메서드에 실행되지 않을 수 있음&lt;/li&gt;
  &lt;li&gt;메서드 단위로 모니터릳
    &lt;ul&gt;
      &lt;li&gt;규칙에 따라 서킷 프레이커&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실패한 경우 - Failback&lt;/li&gt;
  &lt;li&gt;타임아웃&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;서킷-프레이커&quot;&gt;서킷 프레이커&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;일정시간 동안 일정 에러가 나오면 에러비율이 일정수준 나오면 다른 쪽으로 찾아간다&lt;/li&gt;
  &lt;li&gt;일정시간 동안 차단, 이후에 다시 열고 실패하면 다시 닫음&lt;/li&gt;
  &lt;li&gt;1초단 20개 이상의 호출이 발생한 경우 50%이상 실패하면 서킷&lt;/li&gt;
  &lt;li&gt;서킷브레이커마다 키를 생성하는 것이 중요
    &lt;ul&gt;
      &lt;li&gt;동일기능에 대해서 같은 키를 가지면 같이 사용됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;failback&quot;&gt;FailBack&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;서킷이 오픈되면 실행됨&lt;/li&gt;
  &lt;li&gt;특정 익셉션&lt;/li&gt;
  &lt;li&gt;스레드 또는 세마포어&lt;/li&gt;
  &lt;li&gt;타임아웃&lt;/li&gt;
  &lt;li&gt;기능이 동작하지 않으면
    &lt;ul&gt;
      &lt;li&gt;다른 처리를 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HistrixBadRequestException
    &lt;ul&gt;
      &lt;li&gt;이 익셉션이 발새하면 페일백 하지 않음&lt;/li&gt;
      &lt;li&gt;잘못된 유저의 작업을 일반 익셉션을 던지면 이부분을 잡아버림&lt;/li&gt;
      &lt;li&gt;CAller의 잘못한 경우는 이 익셉션 처리가 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;timeout&quot;&gt;timeout&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;기본이 굉장이 짧으니 수정필요&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;스레드-세마포어&quot;&gt;스레드, 세마포어&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;연동 시스템의 갯수와 상태에 따라 세마포어를 분리해서 한쪽의 서버의 문제를 다른쪽으로 전파하지 않음&lt;/li&gt;
  &lt;li&gt;스레드는 스레드당 하나의 서킷 브레이커, 서킷이 되면 지정한 다른 스레드풀을 사용가능함
    &lt;ul&gt;
      &lt;li&gt;스레드 로컬이 사라지게 되어 주의필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;리본&quot;&gt;리본&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;리본은 별도로 선언하지 않고&lt;/li&gt;
  &lt;li&gt;로드밸런실을 처리함&lt;/li&gt;
  &lt;li&gt;기능
    &lt;ul&gt;
      &lt;li&gt;아이룰 : 서버 목록에서 고르기&lt;/li&gt;
      &lt;li&gt;아이핑 : 특정 서버에 부하 집중&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;유레카&quot;&gt;유레카&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;서버의 내임과 서버 추가를 관리하는 기능&lt;/li&gt;
  &lt;li&gt;서버가 뜰때 등록, 다운에서 다운시킴&lt;/li&gt;
  &lt;li&gt;스프링 어플리케이션 이름에 따라서 동작&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;적용&quot;&gt;적용&lt;/h2&gt;
&lt;h3 id=&quot;gateway&quot;&gt;Gateway&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;자체개발 vs Zuul&lt;/li&gt;
  &lt;li&gt;Spring Cloud Zuul&lt;/li&gt;
  &lt;li&gt;클라우드 구성
    &lt;ul&gt;
      &lt;li&gt;Zuul, 히스트릭, 리본, 유레카 모두 하나의 덩어리로&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Zuul
    &lt;ul&gt;
      &lt;li&gt;세마포어를 기본으로 가짐&lt;/li&gt;
      &lt;li&gt;서버군 별로 별도의 세마포어&lt;/li&gt;
      &lt;li&gt;스레드 타임아웃이 스레드 중단이 생성되지 않으므로 스레드 풀단위가 필요하다고 생각
        &lt;ul&gt;
          &lt;li&gt;서버군별로 스레드가 있지 않으면 다른 서버에 타임아웃을 이용한 끓기가 안되기 때문에 영향을 받게 된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;server-to-server&quot;&gt;Server to Server&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;서버들끼리 호출은 어쩌지????&lt;/li&gt;
  &lt;li&gt;게이트웨이 통하기
    &lt;ul&gt;
      &lt;li&gt;한곳에 집중&lt;/li&gt;
      &lt;li&gt;관리가 쉬움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;P2P
    &lt;ul&gt;
      &lt;li&gt;주소를 다 알아야한다.&lt;/li&gt;
      &lt;li&gt;유레카가 있으면 서버들간의 주소가 불필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;리본 + 유레카 = P2P&lt;/li&gt;
  &lt;li&gt;RestTemplate
    &lt;ul&gt;
      &lt;li&gt;loadbalanced : 리본과 유레카 기반으로 동작함&lt;/li&gt;
      &lt;li&gt;빈으로 생성해서 해야함&lt;/li&gt;
      &lt;li&gt;URL을 유레카 서버군의 이름을 주면 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스프링 클라우드 feign
    &lt;ul&gt;
      &lt;li&gt;feign 클라이언트 이름을 지정&lt;/li&gt;
      &lt;li&gt;리본 + 유레카&lt;/li&gt;
      &lt;li&gt;feign.hystrix.true -&amp;gt; 히스트릭스 적용됨&lt;/li&gt;
      &lt;li&gt;메소드 단위로 서킷브레이킹&lt;/li&gt;
      &lt;li&gt;컨피규레이션을 지정하면 커스텀하게 지정할 수 있음
        &lt;ul&gt;
          &lt;li&gt;파라메터를 제거하고 메서드 명 기준으로 수정 -&amp;gt; 오버로딩도 같이 포함&lt;/li&gt;
          &lt;li&gt;디스플레이 + 프로적트로 스레드풀 명을 지정하게 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;장애-시나리오&quot;&gt;장애 시나리오&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;서버 한대가 다운된다면???
    &lt;ul&gt;
      &lt;li&gt;리본 : 다음 서버를 다시 호출해줌
        &lt;ul&gt;
          &lt;li&gt;리트라이 횟수, 대상 수, 리트라이 추가로 해줄 응답&lt;/li&gt;
          &lt;li&gt;리트라이 디펜던시를 넣어야 동작&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;유레카 : heart beat에 유실로 로드밸런싱에서 제거함&lt;/li&gt;
      &lt;li&gt;서킷브레이커
        &lt;ul&gt;
          &lt;li&gt;50%가 기본이므로 33% 에러는 동작하지 않음&lt;/li&gt;
          &lt;li&gt;타임아웃, isoation, failback 으로 처리는 됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;한개의 API만 잘못된 경우
    &lt;ul&gt;
      &lt;li&gt;시간관계상……..&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;적용된-내용&quot;&gt;적용된 내용&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Spring Cloud Config
    &lt;ul&gt;
      &lt;li&gt;Config에 중앙관리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모니터링
    &lt;ul&gt;
      &lt;li&gt;Spring Cloud Sleuth
        &lt;ul&gt;
          &lt;li&gt;컨텍스트 정보를 옮겨줌&lt;/li&gt;
          &lt;li&gt;로그상에서 UUID 가 추가됨
            &lt;ul&gt;
              &lt;li&gt;로그 검색 시스템이 있다면 uuid로 트레이싱&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;집킨 호환 트레이스를 제공함
            &lt;ul&gt;
              &lt;li&gt;DB는 제공하지 않음
                &lt;ul&gt;
                  &lt;li&gt;AOP로 구간을 정의할 수 있음&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;터빈
            &lt;ul&gt;
              &lt;li&gt;현재 서킷 브레이커를 모니터링&lt;/li&gt;
              &lt;li&gt;히스트릭스 모니터링 용&lt;/li&gt;
              &lt;li&gt;실시간 정보이기 때문에 지난 데이터를 보기 어려움
                &lt;ul&gt;
                  &lt;li&gt;지난 내용은 따로 저장해서 시계열 정보를 사용하는 것이 좋음&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;스프링 부트 어드민
            &lt;ul&gt;
              &lt;li&gt;유레카 기반으로 동작함&lt;/li&gt;
              &lt;li&gt;actuator 정보를 사용함&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;회고&quot;&gt;회고&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;오픈소스
    &lt;ul&gt;
      &lt;li&gt;버그, 문서 부실 -&amp;gt; 이해필요&lt;/li&gt;
      &lt;li&gt;소스코드를 보면서 무엇이든 할 수 있음&lt;/li&gt;
      &lt;li&gt;버그리포트, 문서 보강&lt;/li&gt;
      &lt;li&gt;해결하는 과정에서 팀이 성장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;후기&quot;&gt;후기&lt;/h2&gt;
&lt;p&gt;스프링 클라우드를 정말 잘 적용한 프로젝트를 보았다. 클라우드 프로젝트간의 관계와 연동을 위한 매우 어렵고 긴 시간의 학습이 있었을 텐데 우리는 별다른 수고 없이 얕은 수준이지만 세미나를 통해서 얻을 수 있었다.&lt;br /&gt;
현재 프로젝트에서 Histrix를 적용할 계획을 가지고 있었기 때문에 더욱 흥미롭게 들을 수 있었다. 현재 Spring Cloud Gateway가 아직 정식출시되지 않은 상황이지만 11번가에서 겪었던 어려움들이 일부분 해소된 것으로 보인다. 이 다음단계도 SK플래닛에서 경험하고 공유해주면 좋겠다는 생각도 하게 된다.&lt;/p&gt;</content><author><name>Danny Cho(osmania)</name><email>osmania0611@gmail.com</email></author><category term="spring" /><category term="seminar" /><category term="api" /><summary type="html">11번가 Spring Cloud 기반 MSA 전환 1년간의 이야기 - 윤용성 SK플래닛 [아쉽게 사진을 못찍었다]</summary></entry><entry><title type="html">SpringCamp 2018 - 이벤트 기반 분산 시스템을 향한 여정</title><link href="https://osmania-dev.github.io/review/2018/04/21/springcamp-2018-2/" rel="alternate" type="text/html" title="SpringCamp 2018 - 이벤트 기반 분산 시스템을 향한 여정" /><published>2018-04-21T00:00:00+00:00</published><updated>2018-04-21T00:00:00+00:00</updated><id>https://osmania-dev.github.io/review/2018/04/21/springcamp-2018-2</id><content type="html" xml:base="https://osmania-dev.github.io/review/2018/04/21/springcamp-2018-2/">&lt;h2 id=&quot;이벤트-기반-분산-시스템을-향한-여정---박용권-우아한형제들-배민찬&quot;&gt;이벤트 기반 분산 시스템을 향한 여정 - 박용권 (우아한형제들-배민찬)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/post/spring/springcamp2018/session2.jpg&quot; alt=&quot;session2&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;기존-배민찬&quot;&gt;기존 배민찬&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;2016년 PHP 기반의 기존 상용서비스 구매&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;오프라인-중심-처리&quot;&gt;오프라인 중심 처리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사람의 직접 엑셀을 다루면서 시스템에 접근하는 방식&lt;/li&gt;
  &lt;li&gt;서비스가 커지다보니 한계에 도달함&lt;/li&gt;
  &lt;li&gt;자동화 시스템이 필요하다는 인식이 생김
    &lt;ul&gt;
      &lt;li&gt;도입의 시기가 빨라야 좋음 - 사업&lt;/li&gt;
      &lt;li&gt;상용의 시스템과 기존의 관리 시스템을 연동하는 업무&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;시스템별-연결하는-과정&quot;&gt;시스템별 연결하는 과정&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;어댑터 프로젝트
    &lt;ul&gt;
      &lt;li&gt;스프링 부트, 아마존&lt;/li&gt;
      &lt;li&gt;두 시스템을 연결하는 중간 계층&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시스템의 역할
    &lt;ul&gt;
      &lt;li&gt;두시스템의 용어와 도메인을 번역&lt;/li&gt;
      &lt;li&gt;스토어와 물류의 결합도를 메시징 기반으로 비동기 처리
        &lt;ul&gt;
          &lt;li&gt;수신된 메시지가 중복되지 않는 것을 보장해야함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;어댑터를 둔 이유
    &lt;ul&gt;
      &lt;li&gt;새로운 기능은 새로운 시스템과 아키텍처에 쌓아 올리자&lt;/li&gt;
      &lt;li&gt;비즈니스 성정, 부채청산&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;어댑터가 점점 커짐
    &lt;ul&gt;
      &lt;li&gt;도메인 경계 발견 -&amp;gt; SCM 시스템으로 확잗&lt;/li&gt;
      &lt;li&gt;응집력 있는 도메인을 묶기 (모듈)
        &lt;ul&gt;
          &lt;li&gt;도메인의 경계를 따라서 나눔&lt;/li&gt;
          &lt;li&gt;바운디드 컨텐스트 - DDD&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;왜 모듈화?
        &lt;ul&gt;
          &lt;li&gt;인식할 수 있는 형태로 내부적으로 구분하면 분리가능&lt;/li&gt;
          &lt;li&gt;추후 독립서비스로 가능과 내부적으로 구분된 서비스&lt;/li&gt;
          &lt;li&gt;모듈간의 상호작용이 메서드로 상호작용
            &lt;ul&gt;
              &lt;li&gt;예외처리 쉬움&lt;/li&gt;
              &lt;li&gt;연결이 쉬움&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;단일 트랜젝션&lt;/li&gt;
          &lt;li&gt;IDE로 쉽게 리펙토링&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;또 다른 모놀리식 시스템화 현상
        &lt;ul&gt;
          &lt;li&gt;이벤트를 통해서 모듈간의 결합을 낮춘다&lt;/li&gt;
          &lt;li&gt;이벤트 생산과 소비를 통한 느슨한 결합&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;이벤트-방식&quot;&gt;이벤트 방식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;어플리케이션 리스너&lt;/li&gt;
  &lt;li&gt;어플리케이션 컨텍스트
    &lt;ul&gt;
      &lt;li&gt;채널의 역할&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;시스템과-시스템의-결합&quot;&gt;시스템과 시스템의 결합&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;분산과 결합에 대한 아키텍처 정리 필요성&lt;/li&gt;
  &lt;li&gt;시스템 서비스 통합을 위한 세가지
    &lt;ul&gt;
      &lt;li&gt;메시징, 원격, API&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RPC
    &lt;ul&gt;
      &lt;li&gt;원격 서비스 콜&lt;/li&gt;
      &lt;li&gt;강격할&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;REST
    &lt;ul&gt;
      &lt;li&gt;분산 시스템에 적합하다고 알려짐&lt;/li&gt;
      &lt;li&gt;네트웍의 장애전파 방지, 트랜젝션 분기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;메세징
    &lt;ul&gt;
      &lt;li&gt;이벤트 기반과 유사한 장점&lt;/li&gt;
      &lt;li&gt;프로세스 흐름을 파악하기 어렵다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;컨텍스트-협업-두가지&quot;&gt;컨텍스트 협업 두가지&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;동기 &amp;lt;-&amp;gt; 비동기&lt;/li&gt;
  &lt;li&gt;요청,응답 &amp;lt;-&amp;gt; 메시징&lt;/li&gt;
  &lt;li&gt;비동기가 적합한 구간, 동기가 적합한 구간으로 나누는 걸로 합의&lt;/li&gt;
  &lt;li&gt;메시지 통제
    &lt;ul&gt;
      &lt;li&gt;어댑터의 재등장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;메시징-방법&quot;&gt;메시징 방법&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;SQS : 점대점&lt;/li&gt;
  &lt;li&gt;SNS: 전송을 보장하지 않음&lt;/li&gt;
  &lt;li&gt;kinesis : 샤드가 늘고 중러드는 것이 자동화가 안됨 -&amp;gt; 학습, 운영비용 증가&lt;/li&gt;
  &lt;li&gt;AWS MQ : 한국 리젼에 없음&lt;/li&gt;
  &lt;li&gt;최종안 : SNS + SQS 상호보완
    &lt;ul&gt;
      &lt;li&gt;SNS가 SQS에 메시지를 전달하는 방식&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;메시지-보내고-받기&quot;&gt;메시지 보내고 받기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 메시징&lt;/li&gt;
  &lt;li&gt;메시지를 SQS를 추상화 해서 사용(Sring cloud aws)&lt;/li&gt;
  &lt;li&gt;spring cloud stream - 다중 바인드 지원(AWS 지원안함)&lt;/li&gt;
  &lt;li&gt;이벤트 전송에 스키마를 담을 수 있음
    &lt;ul&gt;
      &lt;li&gt;타입에 따라서 json 직렬화, 역직렬화 작업으로 메시지 처리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;풀어야할-과제&quot;&gt;풀어야할 과제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;모니터링
    &lt;ul&gt;
      &lt;li&gt;이벤트 스토어&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터 일관성&lt;/li&gt;
  &lt;li&gt;이벤드 소싱&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;후기&quot;&gt;후기&lt;/h2&gt;
&lt;p&gt;시스템을 연결하기 위해 풀어가는 최종적인 방법은 현재 내가 다루는 시스템과 거의 흡사하다. 하지만 그 결과로 가기위해 고민하고 판단했던 내용들이 많은 경우가 나의 고민과 비슷했고 그것을 풀어가는 방식이 배우 부러웠던 세미나이다.&lt;br /&gt;
이 세미나의 핵심은 어떤 기술과 패턴으로 해결을 했다는 것이 아니라 어떠한 고민은 하게 되었고 그 고민을 어떠한 방식으로 풀어갔느냐가 중요하다. 레거시와의 분리, 가벼운 수준의 도메인 분리, 그리고 확장에 따른 확실한 분리, 분리된 도메인들을 엮기위한 방식들… MSA를 시작하는 곳이라면 이 세미나는 기술적인 뿐만 아니라 풀어가는 방법에 대한 큰 인사이트를 줄 것이다.&lt;/p&gt;

&lt;iframe src=&quot;//www.slideshare.net/slideshow/embed_code/key/xSnFAa7RtOSi0P&quot; width=&quot;595&quot; height=&quot;485&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen=&quot;&quot;&gt; &lt;/iframe&gt;
&lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;//www.slideshare.net/arawnkr/ss-94475606&quot; title=&quot;이벤트 기반 분산 시스템을 향한 여정&quot; target=&quot;_blank&quot;&gt;이벤트 기반 분산 시스템을 향한 여정&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&quot;https://www.slideshare.net/arawnkr&quot; target=&quot;_blank&quot;&gt;Arawn Park&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;</content><author><name>Danny Cho(osmania)</name><email>osmania0611@gmail.com</email></author><category term="spring" /><category term="seminar" /><category term="api" /><summary type="html">이벤트 기반 분산 시스템을 향한 여정 - 박용권 (우아한형제들-배민찬)</summary></entry><entry><title type="html">SpringCamp 2018 - Consumer Driven Contract 기법을 활용한 마이크로서비스 API의 진화</title><link href="https://osmania-dev.github.io/review/2018/04/21/springcamp-2018-1/" rel="alternate" type="text/html" title="SpringCamp 2018 - Consumer Driven Contract 기법을 활용한 마이크로서비스 API의 진화" /><published>2018-04-21T00:00:00+00:00</published><updated>2018-04-21T00:00:00+00:00</updated><id>https://osmania-dev.github.io/review/2018/04/21/springcamp-2018-1</id><content type="html" xml:base="https://osmania-dev.github.io/review/2018/04/21/springcamp-2018-1/">&lt;h2 id=&quot;consumer-driven-contract-기법을-활용한-마이크로서비스-api의-진화---김민석-플랫폼-아키텍트&quot;&gt;Consumer Driven Contract 기법을 활용한 마이크로서비스 API의 진화 - 김민석 (플랫폼 아키텍트)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/post/spring/springcamp2018/session1.jpg&quot; alt=&quot;session1&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;행사소개&quot;&gt;행사소개&lt;/h2&gt;
&lt;p&gt;스프링 원 투어 - 서울&lt;/p&gt;

&lt;h2 id=&quot;애자일-msa-새로운-문제&quot;&gt;애자일, MSA, 새로운 문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;마이크로서비스 에서 API?
    &lt;ul&gt;
      &lt;li&gt;API : REST, Message 기반&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;API 개선 라이프사이클
    &lt;ul&gt;
      &lt;li&gt;바운디드 톤텍트 -&amp;gt; API&lt;/li&gt;
      &lt;li&gt;제공자와 사용자가 스펙을 정하게 된다(테스트 드리븐)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;환경이 점점
    &lt;ul&gt;
      &lt;li&gt;서비스팀이 작아지고 많아짐&lt;/li&gt;
      &lt;li&gt;API 개선이 더 잦아짐(애자일)&lt;/li&gt;
      &lt;li&gt;팀간의 협업이 요구됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;어려운 문제
    &lt;ul&gt;
      &lt;li&gt;이미 약속된 것들을 유지하면서 수정하는 방법&lt;/li&gt;
      &lt;li&gt;과연 이 서비스가 컨슈머가 원하는 것이 맞는 것인가에 대한 인사이트&lt;/li&gt;
      &lt;li&gt;릴리즈 사이클을 짧게 가져는 것?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;진화를 위한 패턴
    &lt;ul&gt;
      &lt;li&gt;Single Message Argument&lt;/li&gt;
      &lt;li&gt;Dataset Amendment&lt;/li&gt;
      &lt;li&gt;Tolerant Reader&lt;/li&gt;
      &lt;li&gt;Schema&lt;/li&gt;
      &lt;li&gt;Consumer&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cdc-consumer-driven-contracts&quot;&gt;CDC (Consumer Driven Contracts)&lt;/h3&gt;
&lt;p&gt;요구사항을 중심으로 서비스를 제공하는 것&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;불필요한 서비스를 줄임&lt;/li&gt;
      &lt;li&gt;개선에 대한 통찰&lt;/li&gt;
      &lt;li&gt;애자일 자동화 가속&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;성공하려면?
    &lt;ul&gt;
      &lt;li&gt;스펙 정의 도구 필요&lt;/li&gt;
      &lt;li&gt;API문서 / 테스트&lt;/li&gt;
      &lt;li&gt;테스트 코드 유지&lt;/li&gt;
      &lt;li&gt;API Gateway / 모니터링&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;핵심은 서로간의 커뮤니케이션!!&lt;/li&gt;
  &lt;li&gt;API 관리도구
    &lt;ul&gt;
      &lt;li&gt;apigee, aws api gateway, kong, swagger
        &lt;ul&gt;
          &lt;li&gt;스펙정의&lt;/li&gt;
          &lt;li&gt;문서화, 테스트&lt;/li&gt;
          &lt;li&gt;운영도구&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;코드가-변화에-대응하는가&quot;&gt;코드가 변화에 대응하는가?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;End to End 테스트는 확실하나 비효율
    &lt;ul&gt;
      &lt;li&gt;모든 구성을 준비&lt;/li&gt;
      &lt;li&gt;느린 실행시간&lt;/li&gt;
      &lt;li&gt;디버깅이 어려움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mock 활용 테스트
    &lt;ul&gt;
      &lt;li&gt;전체를 구성하지 않고 흉내를 냄&lt;/li&gt;
      &lt;li&gt;피드백이 빠름&lt;/li&gt;
      &lt;li&gt;작은 테스트 작업&lt;/li&gt;
      &lt;li&gt;실제 서비스에서 실패할 수도 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;테스트를 만들 때 임의의 타입을 서로 만들어 테스트를 성공하게 만듬
    &lt;ul&gt;
      &lt;li&gt;컨슈머의 코드는
        &lt;ul&gt;
          &lt;li&gt;정합성이 맞는지 보장하는 메커니즘이 없음&lt;/li&gt;
          &lt;li&gt;json 데이터 파일의 최신 관리가 어려움&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;spring-cloud-contract&quot;&gt;Spring Cloud Contract&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;컨트랙트 공유 메커니즘 제공
    &lt;ul&gt;
      &lt;li&gt;읽기 쉬운 형태로&lt;/li&gt;
      &lt;li&gt;REST, Message&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자동화를 통해 최신화 유지
    &lt;ul&gt;
      &lt;li&gt;프로듀서가 자동으로 Stub을 생성&lt;/li&gt;
      &lt;li&gt;자동화되어 확실성이 높아짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Contract verifier (제공자)&lt;/li&gt;
  &lt;li&gt;contract stub runner (클라이언트)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;contract-에서-자동으로-stubjar-생성&quot;&gt;Contract 에서 자동으로 stub.jar 생성&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Consumer는 sub을 내려받아서 mock 서버 생성&lt;/li&gt;
  &lt;li&gt;워크플로우
    &lt;ul&gt;
      &lt;li&gt;제공자가 stub생성&lt;/li&gt;
      &lt;li&gt;git으로 제공&lt;/li&gt;
      &lt;li&gt;컨슈머가 내려받아서 mock 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;데모&quot;&gt;데모&lt;/h2&gt;

&lt;h3 id=&quot;stub-생성-사용&quot;&gt;stub 생성, 사용&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;groovy, yml 형식의 DSL&lt;/li&gt;
  &lt;li&gt;WireMock - annotation&lt;/li&gt;
  &lt;li&gt;consumer
    &lt;ul&gt;
      &lt;li&gt;verifier 디펜던시&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;stub을-mock-server로-실행-stub-runner&quot;&gt;Stub을 Mock Server로 실행 (stub runner)&lt;/h3&gt;

&lt;h3 id=&quot;stateful---wire-mock&quot;&gt;Stateful - wire mock&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;이전 상태에 기반한 상태전이 테스트 가능
    &lt;ul&gt;
      &lt;li&gt;콘트렉트 순서를 정하면 상태를 유지하면서 확인 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cloud-dusehd&quot;&gt;cloud dusehd&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 클라우드를 포함해서 테스트 케이스 지원&lt;/li&gt;
  &lt;li&gt;유레카를 사용하는 경우 -&amp;gt; 유레카 동작이 되는 것에 대한 테스트 케이스 존재&lt;/li&gt;
  &lt;li&gt;유레카가 Stub등록에 대한 포트를 자동분리해줘서 복잡한 형태의 테스트 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;방안1--컨트렉트-파일을-프로듀서-프로젝트에-포함&quot;&gt;방안1 : 컨트렉트 파일을 프로듀서 프로젝트에 포함&lt;/h3&gt;

&lt;h3 id=&quot;polygot-언어-지원&quot;&gt;polygot 언어 지원&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;/contracts가 있으면 그걸 기반으로 생성해줌&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;pact-지원&quot;&gt;PACT 지원&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;pact 파일을 통해 stub생성&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;spring-cloud-pipeline-활용&quot;&gt;spring cloud pipeline 활용&lt;/h3&gt;

&lt;h3 id=&quot;메시징-지원&quot;&gt;메시징 지원&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;AMQP, Stream&lt;/li&gt;
  &lt;li&gt;MessageVerifier 사용&lt;/li&gt;
  &lt;li&gt;컨슈머 - 리스닝 이벤트를 지정&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;CDC를 위해 부족한 부분을 채움&lt;/li&gt;
  &lt;li&gt;커뮤니케이션과 테스트 용의&lt;/li&gt;
  &lt;li&gt;Stub을 통한 일관성&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;후기&quot;&gt;후기&lt;/h2&gt;
&lt;p&gt;CDC의 정의를 명확하게 알수 있게 해준 세미나이다. Stub을 활용해서 테스트를 만들어가는 과정이 예전에 사용되던 SOAP이 떠오르게 하였다. CDC를 하기 위해서는 어려운 점이 있고 그 부분을 스프링의 프로젝트가 채워주는 방향이다. 꼭 CDC가 아니더라도 API 제공자와 사용자간의 확인을 위해서도 좋은 도구가 될 것으로 생각한다.&lt;/p&gt;</content><author><name>Danny Cho(osmania)</name><email>osmania0611@gmail.com</email></author><category term="spring" /><category term="seminar" /><category term="api" /><summary type="html">Consumer Driven Contract 기법을 활용한 마이크로서비스 API의 진화 - 김민석 (플랫폼 아키텍트)</summary></entry><entry><title type="html">AWS Summit 2018 후기 - AWS를 활용한 상품 추천 서비스 구축</title><link href="https://osmania-dev.github.io/review/2018/04/19/aws-summit-2018-6/" rel="alternate" type="text/html" title="AWS Summit 2018 후기 - AWS를 활용한 상품 추천 서비스 구축" /><published>2018-04-19T00:00:00+00:00</published><updated>2018-04-19T00:00:00+00:00</updated><id>https://osmania-dev.github.io/review/2018/04/19/aws-summit-2018-6</id><content type="html" xml:base="https://osmania-dev.github.io/review/2018/04/19/aws-summit-2018-6/">&lt;h2 id=&quot;aws를-활용한-상품-추천-서비스-구축-김태현---0419-1710&quot;&gt;AWS를 활용한 상품 추천 서비스 구축 (김태현 - 04/19 17:10)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/post/aws/summit2018/session4.jpg&quot; alt=&quot;session&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;추천이란&quot;&gt;추천이란?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;아마존 추천상품&lt;/li&gt;
  &lt;li&gt;넷플릭스 영화추천&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;추천-서비스-필요이유&quot;&gt;추천 서비스 필요이유?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;아마존 매출 35% 추천&lt;/li&gt;
  &lt;li&gt;넷플릭스 75% 추천에서 영화선택&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;추천-알고리즘&quot;&gt;추천 알고리즘&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;CF (Collaborative Filtering)
    &lt;ul&gt;
      &lt;li&gt;User base&lt;/li&gt;
      &lt;li&gt;time&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CBF (Contents Based Filtering)
    &lt;ul&gt;
      &lt;li&gt;text&lt;/li&gt;
      &lt;li&gt;이미지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;AR&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cf&quot;&gt;CF&lt;/h3&gt;
&lt;h4 id=&quot;cf-user-based&quot;&gt;CF User Based&lt;/h4&gt;
&lt;p&gt;유사한 성향의 사람을 찾는 방식&lt;br /&gt;
대상 유저와 동일 대상을 참조한 경우 유사한 유저를 찾고 해당 유저에서 관련 상품 제공&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이커머스에서는 큰 효과는 없음&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cf-item-based&quot;&gt;CF Item Based&lt;/h4&gt;
&lt;p&gt;연관된 상품을 찾는 추천방식&lt;br /&gt;
해당 상품을 많이 본 사람들이 본 상품&lt;/p&gt;

&lt;h4 id=&quot;cf를-구현하는-법&quot;&gt;CF를 구현하는 법&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;사용자와 아이템을 매트릭스로 만들고 유사함을 찾음&lt;/li&gt;
  &lt;li&gt;사용자의 아이템을 그래프로 그려 찾기
    &lt;ul&gt;
      &lt;li&gt;상품별로 동일 사용자의 카운팅을 찾음 = 구현이 매우 쉽다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;규모의-문제&quot;&gt;규모의 문제&lt;/h4&gt;
&lt;p&gt;사이즈가 작을 때는 분석이 쉽지만 사이즈가 커지면 오래 걸리게 된다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;pre clustering 클러스터 사이즈를 잘게 쪼갬
    &lt;ul&gt;
      &lt;li&gt;MinHash : 해쉬의 작은 값을 찾음, 그룹핑을 하는 방법&lt;/li&gt;
      &lt;li&gt;클러스터 사이즈를 줄여서 추천 검색 시간을 단축&lt;/li&gt;
      &lt;li&gt;안하면, 메모리가 죽거나, 추천 계산이 끝나지 않거나 이슈 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;단점&quot;&gt;단점&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Cold Start
    &lt;ul&gt;
      &lt;li&gt;신규 상품 추천이 안됨(비교이기 때문)&lt;/li&gt;
      &lt;li&gt;사용자가 보지 않는 상품&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;해결책
    &lt;ul&gt;
      &lt;li&gt;CBF&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cbf&quot;&gt;CBF&lt;/h3&gt;
&lt;h4 id=&quot;text&quot;&gt;text&lt;/h4&gt;
&lt;p&gt;디스크립션과 타이틀에서 텍스트를 뽑아낸다. word2vec&lt;br /&gt;
유사한 상품의 추천으로 사용가능.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;단점 : 의도와 다르게 중요하지 않은 텍스트에 가중치가 들어가서 다른 결과가 나올 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;이미지&quot;&gt;이미지&lt;/h4&gt;
&lt;p&gt;Deep learning for image&lt;br /&gt;
이미지를 러인해서 벡턷값을 뽑고 벡터를 이용해서 유사한 상품을 찾는다.&lt;br /&gt;
예) 유사 옷 검색&lt;/p&gt;

&lt;h3 id=&quot;hybrid&quot;&gt;Hybrid&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CF : 효과 높음, 커버리지 낮음&lt;/li&gt;
  &lt;li&gt;CBF : 커버리지 높음&lt;/li&gt;
  &lt;li&gt;CF + CBF : 메인은 CF, 추천결과가 모자란 경우 CBF&lt;/li&gt;
  &lt;li&gt;패션이나 가구는 CBF가 효과가 좋을 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ar&quot;&gt;AR&lt;/h3&gt;
&lt;p&gt;연관이 있는 상품을 찾는다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;키보드 -&amp;gt; 마우스&lt;/li&gt;
  &lt;li&gt;청바지 -&amp;gt; 흰티&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;단점-1&quot;&gt;단점&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;커버리지 낮음&lt;/li&gt;
  &lt;li&gt;해결책
    &lt;ul&gt;
      &lt;li&gt;AR(정확도 상승) + CF(커버리지 상승)&lt;/li&gt;
      &lt;li&gt;구매로그 기반의 CF를 사용하면 AR과 같은 효과를 얻음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;유사도-알고리즘&quot;&gt;유사도 알고리즘&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;jaccard&lt;/li&gt;
  &lt;li&gt;cosine&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jaccard&quot;&gt;jaccard&lt;/h3&gt;
&lt;p&gt;두그룹의 공통점을 가지고 유사도를 찾음&lt;br /&gt;
두 사람이 얼마나 같은 상품을 봤는지 에 대한 것(교집합)&lt;/p&gt;

&lt;h3 id=&quot;cosine&quot;&gt;cosine&lt;/h3&gt;
&lt;p&gt;두개의 백터가 얼마나 같은 방향을 가리키고 있는가 측정&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;추천-시스템-아키텍처&quot;&gt;추천 시스템 아키텍처&lt;/h2&gt;

&lt;h3 id=&quot;최근-본-상품&quot;&gt;최근 본 상품&lt;/h3&gt;
&lt;p&gt;Gateway -&amp;gt; lambda -&amp;gt; elastic cache&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Redis Sorted Set
    &lt;ul&gt;
      &lt;li&gt;사용자의 아이템을 시간 스코어를 넣으면 정렬된 최근 본 상품 정리가 가능&lt;/li&gt;
      &lt;li&gt;TTL MaxItem으로 관리가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;데이터-레이크&quot;&gt;데이터 레이크&lt;/h3&gt;
&lt;p&gt;Gateway -&amp;gt; lambda -&amp;gt; firehose | -&amp;gt; s2 -&amp;gt; glue&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;S3 저장&lt;/li&gt;
  &lt;li&gt;Glue 카탈로그 정리&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;상품추천&quot;&gt;상품추천&lt;/h3&gt;
&lt;p&gt;S3 -&amp;gt; EMR -&amp;gt; DynamoDB&lt;/p&gt;

&lt;h3 id=&quot;추천-아키텍처&quot;&gt;추천 아키텍처&lt;/h3&gt;
&lt;p&gt;S3 -&amp;gt; SageMaker&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;머신러닝 기반 모델을 빠르게 구성&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;성능평가&quot;&gt;성능평가&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;AB Test
    &lt;ul&gt;
      &lt;li&gt;Online
        &lt;ul&gt;
          &lt;li&gt;CTR (클릴율)&lt;/li&gt;
          &lt;li&gt;CVR (클릭 후 구매)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Offline
        &lt;ul&gt;
          &lt;li&gt;RMSE&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MAB
    &lt;ul&gt;
      &lt;li&gt;일정비율 테스트 하고 자동으로 한쪽에 몰아줌&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;데이터와 서비스 이해&lt;/li&gt;
  &lt;li&gt;데이터 레이크 필요&lt;/li&gt;
  &lt;li&gt;머신러닝/딥러닝 통계 지식ㅍㄹ요&lt;/li&gt;
  &lt;li&gt;온라인, 오프라인 검증 및 테스트&lt;/li&gt;
  &lt;li&gt;추천은 UR부터 추천 알고리즘까지 유기적 연결&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;후기&quot;&gt;후기&lt;/h2&gt;
&lt;p&gt;추천에 대한 기반 지식이 없는 상황에서 여러가지 추천 알고리즘과 그 고려방식이 매우 새로웠다. 그동안 내가 경험한 서비스는 유저의 행동이나 상황, 제공되는 대상의 특성을 분석한 것이 아닌 비즈니스를 관리하는 부서에서 제공하기를 원하는 것들을 경험에 기반한 조건으로 제공하는 경우가 대부분이었다. 지금도 그러한 추천방식을 개발하고 있는 중이고 나름의 효과는 있다고 생각되나 유저가 진짜로 관심가질만한 추천과 그 효과를 분석하기 위핸 데이터 수집이 중요하다는 것을 느끼게된 세션이다. 조금더 알아보고 싶어 졌다.&lt;/p&gt;

&lt;iframe src=&quot;//www.slideshare.net/slideshow/embed_code/key/2H3izukvdsrAET&quot; width=&quot;595&quot; height=&quot;485&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen=&quot;&quot;&gt; &lt;/iframe&gt;
&lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;//www.slideshare.net/awskorea/building-product-recommendation-service-using-aws-taehyun-kim&quot; title=&quot;AWS를 활용한 상품 추천 서비스 구축::김태현:: AWS Summit Seoul 2018&quot; target=&quot;_blank&quot;&gt;AWS를 활용한 상품 추천 서비스 구축::김태현:: AWS Summit Seoul 2018&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&quot;https://www.slideshare.net/awskorea&quot; target=&quot;_blank&quot;&gt;Amazon Web Services Korea&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;</content><author><name>Danny Cho(osmania)</name><email>osmania0611@gmail.com</email></author><category term="aws" /><category term="seminar" /><summary type="html">AWS를 활용한 상품 추천 서비스 구축 (김태현 - 04/19 17:10)</summary></entry><entry><title type="html">AWS Summit 2018 후기 - 왜 우리는 마이크로서비스를 구현하고자 하는가?</title><link href="https://osmania-dev.github.io/review/2018/04/19/aws-summit-2018-4/" rel="alternate" type="text/html" title="AWS Summit 2018 후기 - 왜 우리는 마이크로서비스를 구현하고자 하는가?" /><published>2018-04-19T00:00:00+00:00</published><updated>2018-04-19T00:00:00+00:00</updated><id>https://osmania-dev.github.io/review/2018/04/19/aws-summit-2018-4</id><content type="html" xml:base="https://osmania-dev.github.io/review/2018/04/19/aws-summit-2018-4/">&lt;h2 id=&quot;왜-우리는-마이크로서비스를-구현하고자-하는가-김민성---0419-1230&quot;&gt;왜 우리는 마이크로서비스를 구현하고자 하는가? (김민성 - 04/19 12:30)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/post/aws/summit2018/session4.jpg&quot; alt=&quot;session&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;왜-마이크로&quot;&gt;왜 마이크로?&lt;/h2&gt;
&lt;p&gt;입하 &amp;lt;-&amp;gt; 라이브러리, 디비 &amp;lt;-&amp;gt; 출하&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;하나의 변경이 다른 업무에도 영향을 준다.&lt;/li&gt;
  &lt;li&gt;다른팀이 하는 업무를 모르기에 영향을 알 수 없음&lt;/li&gt;
  &lt;li&gt;빌드, 테스트, 배포에 많은 시간이 소요
    &lt;ul&gt;
      &lt;li&gt;한 커밋의 문제가 있을 경우 전체 롤백&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;마이크로는&quot;&gt;마이크로는?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;서비스 단위로 한다&lt;/li&gt;
  &lt;li&gt;서비스는 독자&lt;/li&gt;
  &lt;li&gt;다른 서비스 내부구조를 몰라도 코드 업데이트 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;조직--딜리버리-파이프라인--아키텍처&quot;&gt;조직 / 딜리버리 파이프라인 / 아키텍처&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;조직 : DevOps
    &lt;ul&gt;
      &lt;li&gt;운영과 개발 조직의 통합&lt;/li&gt;
      &lt;li&gt;오너쉽, 책임, 인센티브&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;딜리버리 : CI/CD
    &lt;ul&gt;
      &lt;li&gt;지속적 딜리버리&lt;/li&gt;
      &lt;li&gt;자동화된 배포&lt;/li&gt;
      &lt;li&gt;다운타임 없는 배포&lt;/li&gt;
      &lt;li&gt;믿을 수 있는 배포&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;아키텍처 : 모놀리딕 -&amp;gt; 마이크로서비스
    &lt;ul&gt;
      &lt;li&gt;SOA&lt;/li&gt;
      &lt;li&gt;단일목적&lt;/li&gt;
      &lt;li&gt;API연계&lt;/li&gt;
      &lt;li&gt;비결합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;비즈니스-신속성의-완성&quot;&gt;비즈니스 신속성의 완성&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;운영 개발조직의 통합
    &lt;ul&gt;
      &lt;li&gt;제한된 인원이므로 가용성, 성능 유지로 도구 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;완벽한 오너십과 책임, &lt;strong&gt;인센티브&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;변화에는 리스트가 있음 -&amp;gt; 인센티브 보상&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;GS Shop 이준희 차장 / 물류/QA 본부&lt;/p&gt;

&lt;h2 id=&quot;마이크로-서비스를-해야하는-이유&quot;&gt;마이크로 서비스를 해야하는 이유&lt;/h2&gt;
&lt;p&gt;지금도 잘되는데 무엇을 왜 바꾸려고 하는가?&lt;br /&gt;
-&amp;gt; 바굴게 없다면 바풀 필요가 없다.&lt;br /&gt;
&amp;lt;- 원하는 비즈니스를 이루기 위한 방법일 뿐이다.&lt;/p&gt;

&lt;h2 id=&quot;모놀리틱---마이크로-서비스&quot;&gt;모놀리틱 - 마이크로 서비스&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;정해진 구조와 정해진 사이즈, 맞추어진 개발자와 인프라
    &lt;ul&gt;
      &lt;li&gt;추가가 필요할때 추가의 공간이 필요함&lt;/li&gt;
      &lt;li&gt;공간을 만들기 위한 시간과 적절성을 알 수 없다.&lt;/li&gt;
      &lt;li&gt;정확하게 추가된 공간이 맞는지는 고객만이 알 수 있다.&lt;/li&gt;
      &lt;li&gt;인력에 대한 리소스도 새로운 개발자, 외주로 하게 된다.
        &lt;ul&gt;
          &lt;li&gt;새로운 시스팀에 대한 이해의 시간이 필요&lt;/li&gt;
          &lt;li&gt;기존 개발자들도 필요한 것이 기존 시스템에 어떠한 영향이 있는 지 확인 테스트가 필요&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;적용을 하기 위해 결과적으로 기획, 개발에 대한 시간이 오래걸려서 시장의 시기를 놓치게 된다. -&amp;gt; 테스트를 해도 위험성이 높다&lt;/li&gt;
      &lt;li&gt;배포 이후에도 시장에 대한 의심을 계속하게 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;작은 시스템은 리스크도 그 영역, 작업도 그 영역
    &lt;ul&gt;
      &lt;li&gt;늘어나고 작업하는 것이 유연해진다.&lt;/li&gt;
      &lt;li&gt;문제점 : 각 서비스의 데이터가 통합되지 않음&lt;/li&gt;
      &lt;li&gt;데이터를 모아서 분석하는 시스템을 구축(데이타 파이프라인)
        &lt;ul&gt;
          &lt;li&gt;분석 시스템으로 고객에 좀더 빠르게 만족하는 서비스, 피드백이 빨라짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;조직에서도 새로운 인력이 아닌 기존인력이 데브옵스
        &lt;ul&gt;
          &lt;li&gt;작은 단위의 서비스 배포로 기능변화&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;목표점과-방향&quot;&gt;목표점과 방향&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;기술적 입장&lt;br /&gt;
모놀리틱 - 온프레미스, IT아웃소싱 | 심플, 스켈러블, 컨티니우스 | 마이크로 서비스 - 클라우드, 데브옵스&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;비즈니스적 입장&lt;br /&gt;
워터플 - 경험기반, 확인되지 않은 기능 | 데이터, 테스터블, 런 | Lean(지속적 변경용이) - 데이터 드리븐, MVP&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;조직의 입장 &lt;br /&gt;
매니징 오리엔트 - 마라톤 | 노 웨이스트, 스피드 | 애자일 - 스프린트&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;msa&quot;&gt;MSA&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;어떻게 해야하는가 궁금?
-&amp;gt; 우리의 목표는? 이루었는가?&lt;/li&gt;
  &lt;li&gt;우리의 목표가 MSA인가? -&amp;gt; 비즈니스적 목표와 수단&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;마이크로-구성패턴&quot;&gt;마이크로 구성패턴&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;어플리케이션 로직, 독립적 데이터&lt;/li&gt;
  &lt;li&gt;API를 통해서만 오픈되어야 한다. public API를 기반으로 접근해야함
    &lt;ul&gt;
      &lt;li&gt;어플, 스키마 변경시 문제 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;라이브러리 역시 공통?&lt;/li&gt;
  &lt;li&gt;서비스간의 커뮤니케이션
    &lt;ul&gt;
      &lt;li&gt;각 서비스는 디펜던시, 누가 호출하는지도 모름&lt;/li&gt;
      &lt;li&gt;영향을 받기 때문에 문제 발생시 누가 챙기나?
        &lt;ul&gt;
          &lt;li&gt;내 서비스는 내가&lt;/li&gt;
          &lt;li&gt;모니터링을 통해 즉시 대응(Cloud Whatch)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;보안-인증, 인가, 감사
    &lt;ul&gt;
      &lt;li&gt;인증(Authentication) : 클라이언트 식별&lt;/li&gt;
      &lt;li&gt;인가(Authorization) : 허용된 범위의 액션&lt;/li&gt;
      &lt;li&gt;감사(Audit)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;확장성 확보
    &lt;ul&gt;
      &lt;li&gt;마이크로 서비스는 얼마나 호출할지 모름
        &lt;ul&gt;
          &lt;li&gt;확장성 있는 아키텍처 필요&lt;/li&gt;
          &lt;li&gt;리드 데이터베이스, 캐시, 오토스켈일링&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;하위 호환성
    &lt;ul&gt;
      &lt;li&gt;API는 서비스와 파트너 서비스와의 약속&lt;/li&gt;
      &lt;li&gt;한번 배포되면 호출가능한 계속 관리되어야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;후기&quot;&gt;후기&lt;/h2&gt;
&lt;p&gt;이미 알고 있었던 MSA의 개념을 다시한번 확인하고 그 내용을 잘 정리된 마치 하나의 문장으로 설명을 듣는 것과 같이 내용이 너무 머리속으로 깊이 들어오는 세션이었다. 애자일과 MSA의 관계, 그리고 MSA를 왜 해야하는지에 대해서는 경영진, 개발자, 서비스와 관련된 모든 사람들이 이와같은 내용으로 이해하고 공감하는 것이 필요하다고 느꼈다. 경험에 기반한 업무보다는 데이터에 기반한 업무를 할 수 있어야한다는 생각도 더 강하게 만드는 세션이다.&lt;/p&gt;

&lt;iframe src=&quot;//www.slideshare.net/slideshow/embed_code/key/HjNDliQEU4I4F3&quot; width=&quot;595&quot; height=&quot;485&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen=&quot;&quot;&gt; &lt;/iframe&gt;
&lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;//www.slideshare.net/awskorea/application-of-ci-cd-for-micro-service-architecture-kim-min-sung&quot; title=&quot;왜 우리는 마이크로서비스를 구현하고자 하는가?::김민성::AWS Summit Seoul 2018&quot; target=&quot;_blank&quot;&gt;왜 우리는 마이크로서비스를 구현하고자 하는가?::김민성::AWS Summit Seoul 2018&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&quot;https://www.slideshare.net/awskorea&quot; target=&quot;_blank&quot;&gt;Amazon Web Services Korea&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;</content><author><name>Danny Cho(osmania)</name><email>osmania0611@gmail.com</email></author><category term="aws" /><category term="seminar" /><summary type="html">왜 우리는 마이크로서비스를 구현하고자 하는가? (김민성 - 04/19 12:30)</summary></entry><entry><title type="html">AWS Summit 2018 후기 - 실전! AWS 기반 데이터베이스 마이그레이션</title><link href="https://osmania-dev.github.io/review/2018/04/18/aws-summit-2018-3/" rel="alternate" type="text/html" title="AWS Summit 2018 후기 - 실전! AWS 기반 데이터베이스 마이그레이션" /><published>2018-04-18T00:00:00+00:00</published><updated>2018-04-18T00:00:00+00:00</updated><id>https://osmania-dev.github.io/review/2018/04/18/aws-summit-2018-3</id><content type="html" xml:base="https://osmania-dev.github.io/review/2018/04/18/aws-summit-2018-3/">&lt;h2 id=&quot;실전-aws-기반-데이터베이스-마이그레이션-최홍식---0418-1710&quot;&gt;실전! AWS 기반 데이터베이스 마이그레이션 (최홍식 - 04/18 17:10)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/post/aws/summit2018/summit2.jpg&quot; alt=&quot;summit2&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;서비스-정의&quot;&gt;서비스 정의&lt;/h2&gt;
&lt;h3 id=&quot;진행과정&quot;&gt;진행과정&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;기존 : 기존 디비 백업, S3 업로드 새로운 새로운 디비 설치, 디비 이전, 기존 디비 다운&lt;/li&gt;
  &lt;li&gt;RDS : 위의 과정을 자동으로&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;마이그레이션-작업에-필요한-것&quot;&gt;마이그레이션 작업에 필요한 것&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 복제 솔루션 필요&lt;/li&gt;
  &lt;li&gt;긴 어플리케이션 다운&lt;/li&gt;
  &lt;li&gt;설정 복잡&lt;/li&gt;
  &lt;li&gt;DB별 응용프로그램 코드 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dms-서비스는&quot;&gt;DMS 서비스는?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;온 프라미스를 AWS로 이전&lt;/li&gt;
  &lt;li&gt;이기종 디비간의 이전&lt;/li&gt;
  &lt;li&gt;스키마 자동 변경&lt;/li&gt;
  &lt;li&gt;최소 다운타임&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;사용사례&quot;&gt;사용사례&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 변환, 어플리케이션 업데이트&lt;/li&gt;
  &lt;li&gt;DW를 Redishift로 마이그레이션&lt;/li&gt;
  &lt;li&gt;리젼간 복제 유지&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;서비스&quot;&gt;서비스&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;DMS : 데이터 마이그레이션&lt;/li&gt;
  &lt;li&gt;SCT : 이기종간의 스키마 변환
    &lt;ul&gt;
      &lt;li&gt;OLTP 디비 변환&lt;/li&gt;
      &lt;li&gt;DW 이전&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;데이터-마이그레이션-계획수립&quot;&gt;데이터 마이그레이션 계획수립&lt;/h2&gt;
&lt;h3 id=&quot;계획단계&quot;&gt;계획단계&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;제약사항 : https://wiki.postgresql.org/wiki/Oracle_to_Postgres_Conversion&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;마이그레이션-이슈-해결방안&quot;&gt;마이그레이션 이슈 해결방안&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;SQL, Table 등의 엑세스 정보 확인&lt;/li&gt;
  &lt;li&gt;DB의 비지니스 로직은 어플리케이션으로 되도록 이동
    &lt;ul&gt;
      &lt;li&gt;테이블 감사, 타임스템프 업데이트 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;마이그레이션-단계&quot;&gt;마이그레이션 단계&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CloudWatch 로깅 필수&lt;/li&gt;
  &lt;li&gt;default UTC Time zone 설정 - DMS는 UTC&lt;/li&gt;
  &lt;li&gt;파티셔닝 정리&lt;/li&gt;
  &lt;li&gt;계정관리&lt;/li&gt;
  &lt;li&gt;버큠밍&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;테스트-확인&quot;&gt;테스트 확인&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;스냅샷으로 인스턴스 확인
    &lt;ul&gt;
      &lt;li&gt;기능, 부하, 성능 테스트&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;테스트 시작전 트리거, 인덱스 활성화&lt;/li&gt;
  &lt;li&gt;데이터 벨리데이션 활성화&lt;/li&gt;
  &lt;li&gt;데이터 타입 변환확인&lt;/li&gt;
  &lt;li&gt;쿼리 플랜 안정화&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;전환단계&quot;&gt;전환단계&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;전환 시랲를 위한 Failback
    &lt;ul&gt;
      &lt;li&gt;오라클을 포스트로 하는 경우 실패를 대비해서 RDS 오라클도 같이 준비한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;실행전-준비사항&quot;&gt;실행전 준비사항&lt;/h2&gt;
&lt;p&gt;DMS 문서에서 확인 필요&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;각종 설정 팁 확인 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;후기&quot;&gt;후기&lt;/h2&gt;
&lt;p&gt;DB 데이터 이전을 생각하면서 상당히 기대하고 들었던 세션이다. 모든지 자동으로 해줄 것 같은 AWS에 마이그레이션이라고 하니 이전, 이후만 지정하면 알아서 될 것이라고 생각하기 쉽지만 사실은 전환하는 과정을 자동으로 해줄 뿐 대부분의 확인은 결국 사람이 해야한다. 어떠한 부분을 확인해야하고 확인 하는 방법에 대한 것들을 알수 있는 세션이었다.&lt;/p&gt;

&lt;iframe src=&quot;//www.slideshare.net/slideshow/embed_code/key/b61WhQHE6LVdAo&quot; width=&quot;595&quot; height=&quot;485&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen=&quot;&quot;&gt; &lt;/iframe&gt;
&lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;//www.slideshare.net/awskorea/aws-based-database-migration-practice-hongsik-choi&quot; title=&quot;실전! AWS 기반 데이터베이스 마이그레이션::최홍식::AWS Summit Seoul 2018&quot; target=&quot;_blank&quot;&gt;실전! AWS 기반 데이터베이스 마이그레이션::최홍식::AWS Summit Seoul 2018&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&quot;https://www.slideshare.net/awskorea&quot; target=&quot;_blank&quot;&gt;Amazon Web Services Korea&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;</content><author><name>Danny Cho(osmania)</name><email>osmania0611@gmail.com</email></author><category term="aws" /><category term="seminar" /><summary type="html">실전! AWS 기반 데이터베이스 마이그레이션 (최홍식 - 04/18 17:10)</summary></entry><entry><title type="html">AWS Summit 2018 후기 - 모바일 게임을 만들기 위한 AWS 활용 고군분투기</title><link href="https://osmania-dev.github.io/review/2018/04/18/aws-summit-2018-2/" rel="alternate" type="text/html" title="AWS Summit 2018 후기 - 모바일 게임을 만들기 위한 AWS 활용 고군분투기" /><published>2018-04-18T00:00:00+00:00</published><updated>2018-04-18T00:00:00+00:00</updated><id>https://osmania-dev.github.io/review/2018/04/18/aws-summit-2018-2</id><content type="html" xml:base="https://osmania-dev.github.io/review/2018/04/18/aws-summit-2018-2/">&lt;h2 id=&quot;모바일-게임을-만들기-위한-aws-활용-고군분투기-최용호---0418-1230&quot;&gt;모바일 게임을 만들기 위한 AWS 활용 고군분투기 (최용호 - 04/18 12:30)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/post/aws/summit2018/session2.jpg&quot; alt=&quot;session2&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;자동화-고민&quot;&gt;자동화 고민&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;개발환경 구성
    &lt;ul&gt;
      &lt;li&gt;기존의 환경구성 방식은 중간에 문제시 재설정 및 재설치 필요&lt;/li&gt;
      &lt;li&gt;개발환경의 자동화 Docker&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Docker
    &lt;ul&gt;
      &lt;li&gt;독커를 서비스별로 디렉터리 구성&lt;/li&gt;
      &lt;li&gt;설정파일을 레포지토리에 형상관리 문서화 필요없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;빌드 &amp;amp; 배포
    &lt;ul&gt;
      &lt;li&gt;기존 : 빌드서버 -&amp;gt; war -&amp;gt; SCP -&amp;gt; Tomcat&lt;/li&gt;
      &lt;li&gt;jenkins 자동화&lt;/li&gt;
      &lt;li&gt;라이브 : Jenkins build -&amp;gt; S3 -&amp;gt; Beanstalk&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;네트워크 구성
    &lt;ul&gt;
      &lt;li&gt;AWS 기본 네트워크 구성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;서비스-구성의-고민&quot;&gt;서비스 구성의 고민&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;AWS 에서 Docker
    &lt;ul&gt;
      &lt;li&gt;ECS - 서울리전 X&lt;/li&gt;
      &lt;li&gt;Beanstalk
        &lt;ul&gt;
          &lt;li&gt;Application -&amp;gt; Environment -&amp;gt; Version Upload -&amp;gt; Version Deploy&lt;/li&gt;
          &lt;li&gt;어플리케이션 분리(개발/운영) 버전이 혼용되지 않음&lt;/li&gt;
          &lt;li&gt;주의사항
            &lt;ul&gt;
              &lt;li&gt;오토스케링 시작구성, VPC 등 위험요소는 ELB 새로 생성되어 웜업 필요&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;부하테스트-고민&quot;&gt;부하테스트 고민&lt;/h2&gt;
&lt;p&gt;원하는 만큼 확장가능한 부하테스트가 목표&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;jmeter
    &lt;ul&gt;
      &lt;li&gt;스팟 인스턴스 비용절감&lt;/li&gt;
      &lt;li&gt;System management에 run command 이용해서 jmeter 실행/종료
        &lt;ul&gt;
          &lt;li&gt;별도 페이지로 Run 실행처리함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;진행상황 로그는 클라우드 와치에 로그수집&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pinpoint
    &lt;ul&gt;
      &lt;li&gt;시스템 유지의 부담&lt;/li&gt;
      &lt;li&gt;X-ray로 전환&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;데이터-활용-고민&quot;&gt;데이터 활용 고민&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;지표 데이터 설계
    &lt;ul&gt;
      &lt;li&gt;상위 하위&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;저장/시각화
    &lt;ul&gt;
      &lt;li&gt;Elastic stack&lt;/li&gt;
      &lt;li&gt;상위 아이디로 하위 아이디(동작) 에 대한 히스토리 구분&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Elastic 노드관리
    &lt;ul&gt;
      &lt;li&gt;1대의 인스턴스의 한계치 조사&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장애대응
    &lt;ul&gt;
      &lt;li&gt;인스턴스가 죽을경우 파일비트가 전송을 다 못할수도
        &lt;ul&gt;
          &lt;li&gt;종료시 스크립트로 해소하고 종료&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Elastic Search는 리플리카 노드관리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;관리요소가 많아서 -&amp;gt; AWS
    &lt;ul&gt;
      &lt;li&gt;Kinesis Agent -&amp;gt; Kinesis Streams -&amp;gt; Lambda -&amp;gt; Elastic Search&lt;/li&gt;
      &lt;li&gt;데이터 유실을 막기위한 Agent -&amp;gt; S3 = Athena로 로그확인&lt;/li&gt;
      &lt;li&gt;로그레벨 년 월 일 &amp;lt;- 아데나 스캔 범위를 좁힘(비용)&lt;/li&gt;
      &lt;li&gt;일자별 아데나 테이블은 관리 힘듬 -&amp;gt; 년월일 파티션처리(쿼리의 where절로 제한 스캔 가능)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시각화
    &lt;ul&gt;
      &lt;li&gt;kibana&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;후기&quot;&gt;후기&lt;/h2&gt;
&lt;p&gt;전반적으로 간단하게 정리된 AWS 서비스를 활용한 서비스 구성기이다. 이런 아키텍처를 잡아가는데 있었던 고민이나 그 고민을 통핸 결정과정을 조금더 자세하게 다루었으면 하는 아쉬움이 있었다.&lt;br /&gt;
부하테스트를 하는 과정에서 Run Command의 사용은 새로운 활용방안을 생각하게 해주었다.&lt;/p&gt;

&lt;iframe src=&quot;//www.slideshare.net/slideshow/embed_code/key/K5RZS4OisjUM8R&quot; width=&quot;595&quot; height=&quot;485&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen=&quot;&quot;&gt; &lt;/iframe&gt;
&lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;//www.slideshare.net/awskorea/struggles-of-utilizing-aws-to-build-moblie-games-choi-yongho&quot; title=&quot;모바일 게임을 만들기 위한 AWS 활용 고군분투기::최용호::AWS Summit Seoul 2018&quot; target=&quot;_blank&quot;&gt;모바일 게임을 만들기 위한 AWS 활용 고군분투기::최용호::AWS Summit Seoul 2018&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&quot;https://www.slideshare.net/awskorea&quot; target=&quot;_blank&quot;&gt;Amazon Web Services Korea&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;</content><author><name>Danny Cho(osmania)</name><email>osmania0611@gmail.com</email></author><category term="aws" /><category term="seminar" /><summary type="html">모바일 게임을 만들기 위한 AWS 활용 고군분투기 (최용호 - 04/18 12:30)</summary></entry><entry><title type="html">AWS Summit 2018 후기 - 천만 사용자를 위한 AWS 클라우드 아키텍처 진화하기</title><link href="https://osmania-dev.github.io/review/2018/04/18/aws-summit-2018-1/" rel="alternate" type="text/html" title="AWS Summit 2018 후기 - 천만 사용자를 위한 AWS 클라우드 아키텍처 진화하기" /><published>2018-04-18T00:00:00+00:00</published><updated>2018-04-18T00:00:00+00:00</updated><id>https://osmania-dev.github.io/review/2018/04/18/aws-summit-2018-1</id><content type="html" xml:base="https://osmania-dev.github.io/review/2018/04/18/aws-summit-2018-1/">&lt;h2 id=&quot;aws-summit-seoul-2018-후기&quot;&gt;AWS Summit Seoul 2018 후기&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/post/aws/summit2018/summit.jpg&quot; alt=&quot;summit&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AWSome Day 참석한 이후로 처음으로 조금더 실무에 가까운 세션을 듣기 위해 AWS Summit 2018을 찾았다. 4/18-19 양일간 진행되는 세션에서 18일은 주로 기능과 학습을 위한 내용위주였고 19일은 실질적으로 활용의 예를 보고 서비스를 구성하는데 필요한 인사이트를 얻는 방향의 주제를 가지고 있었다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/ko/summits/seoul/agenda/&quot;&gt;AWS Summit 2018 Seoul 세션정보&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;천만-사용자를-위한-aws-클라우드-아키텍처-진화하기-0418-0900&quot;&gt;천만 사용자를 위한 AWS 클라우드 아키텍처 진화하기 (04/18 09:00)&lt;/h2&gt;
&lt;p&gt;사용자가 늘어나면서 그것을 대응하기 위한 아키텍처를 변화시키고 생각해봐야할 것들을 알려주는 세션이다. 찬석한 세션들을 정리하고 그 내용으로 얻는 경험과 생각들을 정리하고자 한다.&lt;/p&gt;

&lt;h3 id=&quot;사용자--1&quot;&gt;사용자 &amp;gt;= 1&lt;/h3&gt;
&lt;p&gt;기본적인 EC2를 이용해 서비스를 구성하고 Route53 으로 생성한 서비스에 도메인을 연결해 첫 사용자가 서비스에 접근 가능하게 하는 것을 시작으로 한다. 사용량이 늘어나면 EC2 사이즈를 스케일 업해 처리한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이중화 없음&lt;/li&gt;
  &lt;li&gt;장애 Failover 불가능&lt;/li&gt;
  &lt;li&gt;서버 1대에 모든 서비스 구성&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;사용자--100&quot;&gt;사용자 &amp;gt; 100&lt;/h3&gt;
&lt;p&gt;DB를 RDS로 이관하고 비니지스를 위한 코어 서비스 개발에 집중한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RDS
    &lt;ul&gt;
      &lt;li&gt;관리형 서비스 오로라&lt;/li&gt;
      &lt;li&gt;수평확장을 권장&lt;/li&gt;
      &lt;li&gt;스토리지의 분산처리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;사용자--1000&quot;&gt;사용자 &amp;gt; 1,000&lt;/h3&gt;
&lt;p&gt;수평적, 수직적 확장을 위한 조치가 필요하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ELB
    &lt;ul&gt;
      &lt;li&gt;Application LB : HTTP/HTTPS 트레픽 최적화, 웹소켓&lt;/li&gt;
      &lt;li&gt;Network LB : Layer 4 TCP 트레픽 처리, 높은 처리량, IP 고정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Multi-AZ&lt;/li&gt;
  &lt;li&gt;Database 이중화&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;사용자--10000---100000&quot;&gt;사용자 &amp;gt; 10,000 - 100,000&lt;/h3&gt;
&lt;p&gt;집중되는 부하를 이동시켜야 한다. 정적컨텐츠를 웹서버에서 처리하기 보다는 S3로 이동하는 것이 좋다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;S3로 정적파일, 백업, 어플리케이션 로그들을 넣어 부하분산, 엣지 로케이션으로 가능&lt;/li&gt;
  &lt;li&gt;CloudFront
    &lt;ul&gt;
      &lt;li&gt;Origin 에 낮은부하&lt;/li&gt;
      &lt;li&gt;ACM 이동용 인증서&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;동적 처리도 부하를 이동시켜야 한다. DynamoDB와 ElasticCache 를 활용해 부하분산처리&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;DynamoDB : 자주 사용되는 세션/상태정보 저장&lt;/li&gt;
  &lt;li&gt;ElasticCache : DB 캐싱&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;오토 스켈링을 통해 부하변화에 따라 조정한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;하루 일주기, 또는 특정 이벤트에 따라 부하가 급증하는 형태 (오르락 내리락)&lt;/li&gt;
  &lt;li&gt;사용량에 맞춰서 컴퓨팅 자원을 조절한다.
    &lt;ul&gt;
      &lt;li&gt;메트릭에 따라서 추가, 삭제 (클라우드 와치)&lt;/li&gt;
      &lt;li&gt;EC2, Dynamo, Aurora, ECS, EMR 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;사용자--50만&quot;&gt;사용자 &amp;gt; 50만+&lt;/h3&gt;
&lt;p&gt;웹서버에 모두 있는 경우 메트릭을 잡기 어렵다. 웹서버를 경량화 하고 서비스를 통해 메트릭을 감시하며 모니터링과 자동화를 해야한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모니터링
    &lt;ul&gt;
      &lt;li&gt;서비스별 다양한 메트릭 정보제공&lt;/li&gt;
      &lt;li&gt;로그그룹 -&amp;gt; ES&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;X-Ray
    &lt;ul&gt;
      &lt;li&gt;여러 서비스의 요청에서 응답까지 보고 병목지점을 찾음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;마이크로 서비스로 계층을 분해해 추가적인 개선
    &lt;ul&gt;
      &lt;li&gt;프리젠테이션, 로직티어, 데이터 티어를 분리해서 느슨한 결합으로 티어간 변경을 용이하게 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서버리스(람다)
    &lt;ul&gt;
      &lt;li&gt;서버없이 코드만으로 서비스를 수행&lt;/li&gt;
      &lt;li&gt;API Gateway와 연동하는 경우가 많음&lt;/li&gt;
      &lt;li&gt;SNS 큐 기반&lt;/li&gt;
      &lt;li&gt;Kinesis 스크림 기반&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;사용자--1000만&quot;&gt;사용자 &amp;gt; 1000만+&lt;/h3&gt;
&lt;p&gt;데이터 베이스에 쓰기 부하 병목이 발생할 수 있다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기능기반 분리&lt;/li&gt;
  &lt;li&gt;수평적 활장을 위한 샤딩&lt;/li&gt;
  &lt;li&gt;다른 유형의 디비 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;데이터베이스-분리&quot;&gt;데이터베이스 분리&lt;/h4&gt;
&lt;p&gt;하나의 디비에 다 넣어 놓는 것은 효율이 안될수도 있어 관계형 디비가 적합하지 않는 케이스 존재&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;DynamoDB -&amp;gt; Key/Value, 도큐먼트&lt;/li&gt;
  &lt;li&gt;넵튠 - 그래프(관걔에 대한 저장 탐색)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;체크리스트&quot;&gt;체크리스트&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;멀티 AZ로 고가용성&lt;/li&gt;
  &lt;li&gt;자가확장&lt;/li&gt;
  &lt;li&gt;모든 계층의 이중화&lt;/li&gt;
  &lt;li&gt;인프라 내/외부 캐시&lt;/li&gt;
  &lt;li&gt;배포자동화&lt;/li&gt;
  &lt;li&gt;모니터링/측정/도구&lt;/li&gt;
  &lt;li&gt;계층 분리해서 마이크로 서비스&lt;/li&gt;
  &lt;li&gt;오토 스켈링&lt;/li&gt;
  &lt;li&gt;직접 만드릭보단 관리형 서비스&lt;/li&gt;
  &lt;li&gt;상황에 맞는 디비사용&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;후기&quot;&gt;후기&lt;/h2&gt;
&lt;p&gt;전반적으로 각 상황에 따른 AWS 서비스 설명이 주를 이루는 세션이었다. 처음 AWS를 도입하는 상황이라면 유저의 증가에 따라 어떤 서비스를 선택해야하는 지 알수 있는 세션이다. 역할에 따른 서비스 분리와 데이터 분산, 마이크로 아키텍처를 도입하는 시점에 대해서는 공감이 되는 부분도 잇었다.&lt;br /&gt;
그대로 따라하기 보다는 자신의 서비스 상황에 맞춰서 필요한 AWS 서비스를 선택하면 좋을 것으로 생각한다.&lt;/p&gt;

&lt;iframe src=&quot;//www.slideshare.net/slideshow/embed_code/key/c6snqCMmFik1o&quot; width=&quot;595&quot; height=&quot;485&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen=&quot;&quot;&gt; &lt;/iframe&gt;
&lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;//www.slideshare.net/awskorea/aws-cloud-architecture-evolution-for-one-thousand-users-changsu-lee&quot; title=&quot;천만 사용자를 위한 AWS 클라우드 아키텍처 진화하기::이창수::AWS Summit Seoul 2018&quot; target=&quot;_blank&quot;&gt;천만 사용자를 위한 AWS 클라우드 아키텍처 진화하기::이창수::AWS Summit Seoul 2018&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&quot;https://www.slideshare.net/awskorea&quot; target=&quot;_blank&quot;&gt;Amazon Web Services Korea&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;</content><author><name>Danny Cho(osmania)</name><email>osmania0611@gmail.com</email></author><category term="aws" /><category term="seminar" /><summary type="html">AWS Summit Seoul 2018 후기</summary></entry><entry><title type="html">REST API 날짜/시간 표현 정하기</title><link href="https://osmania-dev.github.io/programming/2018/03/23/REST-API-%EC%84%A4%EA%B3%84%EC%9D%98-%EB%82%A0%EC%A7%9C%ED%91%9C%ED%98%84/" rel="alternate" type="text/html" title="REST API 날짜/시간 표현 정하기" /><published>2018-03-23T00:00:00+00:00</published><updated>2018-03-23T00:00:00+00:00</updated><id>https://osmania-dev.github.io/programming/2018/03/23/REST-API-%EC%84%A4%EA%B3%84%EC%9D%98-%EB%82%A0%EC%A7%9C%ED%91%9C%ED%98%84</id><content type="html" xml:base="https://osmania-dev.github.io/programming/2018/03/23/REST-API-%EC%84%A4%EA%B3%84%EC%9D%98-%EB%82%A0%EC%A7%9C%ED%91%9C%ED%98%84/">&lt;p&gt;&lt;a href=&quot;http://www.popit.kr/rest-api-날짜시간-표현-정하기/&quot;&gt;popit&lt;/a&gt;에도 등록된 글 입니다.&lt;/p&gt;

&lt;p&gt;2달전 제 뒤에 앉아았는 개발자님께서 왜 알아보기 어렵게 날짜를 숫자로 사용해야하나고 의문을 가진 적이 있다. API를 처음 구성할 때 참고했던 API가 사용했다는 이유로, spring 400에러 응답에서도 long 형태의 시간표현을 한 사례, 타임존과 DB처리에서 장점이 있다는 이유로 적용했던 Unix Time형태의 날짜 표현방식이 문제가 될 수도 있다는 생각이 들었다. 그렇게 불편하다면 한번 바꿔볼까? 하는 생각과 함께 고민을 시작한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/post/iso8601/clock.jpeg&quot; alt=&quot;clock&quot; /&gt;&lt;/p&gt;

&lt;p&gt;REST API를 설계하기 위해 REST에 대해 학습하는 과정에서 우리는 URI, Method, Http Status 에만 집중한다. 하지만 API를 개발하고 사용하는 목표는 결국 데이터를 주고 받는데 있기 때문에 데이터가 담기는 Parameter, Request/Response Body의 형태를 정하고 Interface로 약속해야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;문자열&lt;/li&gt;
  &lt;li&gt;숫자&lt;/li&gt;
  &lt;li&gt;논리(Boolean)&lt;/li&gt;
  &lt;li&gt;날짜 / 시간&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;보통 데이터를 표현하기 위해서는 위의 4가지 형태가 필요하고 그 중에서 날짜와 시간은 프로그래밍 언어마다 그 구성형태가 다르다. 많이 사용하는 json 응답에서 이 날짜와 시간을 표현하기 위한 방안을 고민하고 적용방안에 대해 이야기하고자 한다.&lt;/p&gt;

&lt;h1 id=&quot;unix-time-vs-iso-8601&quot;&gt;Unix Time vs ISO 8601&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/assets/post/iso8601/timestamp.png&quot; alt=&quot;unix time&quot; /&gt;&lt;/p&gt;

&lt;p&gt;API를 위한 시간표현에서 가장 인기있는 것은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix Time&lt;/a&gt;과 &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO-8601&lt;/a&gt;이고 이 외에도 다양한 방법이 존재하지만 자신들만의 형태를 가질 것이 아니라면 의미가 없기 때문에 이 두가지만 고려했다.&lt;/p&gt;

&lt;h2 id=&quot;표현방식에-따른-가독성과-변환&quot;&gt;표현방식에 따른 가독성과 변환&lt;/h2&gt;
&lt;p&gt;Unix Time은 &lt;strong&gt;1970-01-01 UTC 에서의 경과시간을 초(or 밀리초&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;)로 환산해서 숫자&lt;/strong&gt;로 나타내고 ISO 8601은 &lt;strong&gt;사람이 인식할 수 있는 문자&lt;/strong&gt;로 나타낸다.&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;unix_time&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1521739975&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;unix_time_milisecond&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1521739975123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;iso-8601&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2018-03-22T17:32:55+09:00&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;iso-8601_timestamp&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2018-03-22T17:32:55.123+09:00&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;샘플을 보면 느끼겠지만 Unix Time은 사람이 인지할 수 있는 형식이 아니기 때문에 주고받는 과정에서 바로 이해하기 어려우나 ISO 8601은 즉시 인지가 가능하다. 반면 프로그램 상에서는 각 언어와 환경마다 대부분 가지고 있는 Date 처리에서 unix time은 즉시 변환이 가능지만 ISO 8601은 언어와 버전에 따라서 지원되지 않는 경우가 존재한다.&lt;br /&gt;
javascript를 예로 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/parse&quot;&gt;ECMAScript 5&lt;/a&gt;부터 Date에서 RFC2822 또는 ISO 8601를 지원하는데 IE9 미만에서는 ECMAScript 5를 하지 못하기 때문에 바벨과 같은 트랜스파일러를 사용하는 것과 같은 주의가 필요하다. &lt;del&gt;그나저나 아직도 IE7,8을 대응하냐고 하면..&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;유저테스트와 문서화에서도 이 가독성이 영향을 주는데, Front 개발자의 도움으로 Swagger에서 날짜변환 Tool을 임베드해서 그 단점을 보완하며 사용하고 있지만 사실 입력할 때마다 불편함을 느낀다.
&lt;img src=&quot;/assets/post/iso8601/swagger.png&quot; alt=&quot;swagger&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;타임존과-정확성&quot;&gt;타임존과 정확성&lt;/h2&gt;
&lt;p&gt;국내에서만 제공하는 서비스를 하고 있다면 그다지 중요한 부분이 아니지만 region에 따라서 시간대가 다른 서비스를 하고 있을 경우 ISO는 약점으로 작용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;local&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2018-03-23T13:10:10&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;utc&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2018-03-23T13:10:10Z&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;utc_offset&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2018-03-23T13:10:10+09:00&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Unix Time의 경우 UTC로부터의 Offset이기 때문에 타임존과 상관없이 일정한 값을 가지므로 그 표현과 사용에 큰 제약이 없다. IOS 8601은 위와 같이 명시하지 않으면 로컬타임으로 인식하는데 다른 시간대를 사용하는 지역에 동시에 서비스를 하거나 서머타임을 적용하는 경우 시간에 대한 혼동이 올 수 있다. 입력받은 시간을 다른 타임존으로 인식해서 사용해야 하는 경우에도 단순한 덧셈 뺄셈이지만 시간 확인에 대한 어려움을 경험하게 된다.&lt;/p&gt;

&lt;h2 id=&quot;제한된-정보표현&quot;&gt;제한된 정보표현&lt;/h2&gt;
&lt;p&gt;시간 정보가 필요없고 날짜만 사용하는 경우 Unix Time은 표현법이 애매해진다. 무조건 시간의 정보를 포함해서 사용해야하기 때문에 이것이 날짜만 포함된 데이터인지 시간과 함께 있는 데이터인지 구분할 수 없다. ISO는 시간영역을 제거하면 되기 때문에 년/월/일, 년/월, 년 등의 제한된 정보를 표현하는데 좋다.&lt;/p&gt;
&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;unix_time_date&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1521763200000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;iso_8601_date&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2018-03-23&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;iso_8601_month&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2018-03&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;iso_8601_year&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2018&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;spring-boot-에서-사용방법&quot;&gt;Spring Boot 에서 사용방법&lt;/h1&gt;
&lt;p&gt;그래서 그 두가지를 실제로 개발하려면 뭘 어떻게 해야할까? 개발환경에 대한 영향을 보기 위해 Spring Boot를 기반으로 두 방식의 사용방법을 확인했다.
기본적으로 LocalDate를 사용해서 json 응답하면 &lt;del&gt;지나치게 친절하고 장황한 왜 이런 응답을 할까 싶은&lt;/del&gt; 아래의 응답을 보게 된다. 이 응답과 Parameter로 시간을 받을 때 처리를 바꾸는 작업을 해야한다.&lt;/p&gt;
&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  
   &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;localDate&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;year&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2018&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;month&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;JANUARY&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;era&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;CE&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;dayOfYear&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;dayOfWeek&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;MONDAY&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;leapYear&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;dayOfMonth&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;monthValue&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;chronology&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  
         &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ISO&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
         &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;calendarType&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;iso8601&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
   &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;parameter-처리&quot;&gt;Parameter 처리&lt;/h2&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@GetMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/orders&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ResponseEntity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Order&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getOrdersByDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@RequestParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;date&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;nd&quot;&gt;@DateTimeFormat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iso&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DateTimeFormat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ISO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;DATE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LocalDate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  
      &lt;span class=&quot;c1&quot;&gt;// Do&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;DateTimeFormat으로 요청 Parameter의 형태를 지정하면 별다른 변환처리 없이 ISO 형태의 데이터 수신이 가능하다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@GetMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/orders&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ResponseEntity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Order&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getOrdersByDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@RequestParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;date&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dateNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;LocalDate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;date&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Instant&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ofEpochMilli&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dateNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;atZone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ZoneId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;systemDefault&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toLocalDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

      &lt;span class=&quot;c1&quot;&gt;// Do&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;반면 Spring 에서 제공하는 기능이 없는 Unix Time은 별도로 long을 LocalDate로 바꾸는 작업이 필요하다.&lt;/p&gt;

&lt;h2 id=&quot;spring-boot-15-iso-8601&quot;&gt;Spring Boot 1.5 (ISO 8601)&lt;/h2&gt;
&lt;p&gt;1.5 버전에서는 Java 8의 Date/Time API를 처리하기 위해 아래의 작업이 필요하다.&lt;/p&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.fasterxml.jackson.datatype&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;jackson-datatype-jsr310&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-gradle highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;dependencies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compile&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;group:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'com.fasterxml.jackson.datatype'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;name:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'jackson-datatype-jsr310'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;version:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'2.9.4'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;spring.jackson.serialization.WRITE_DATES_AS_TIMESTAMPS = false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;maven pom.xml 또는 Gradle에 위의 디펜던시를 추가하고 application.properties에 serialize 설정을 추가하면 ISO 8601 기반의 응답으로 변경된다.&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  
   &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;localDate&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2018-01-01&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
   &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;localTime&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;10:24&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
   &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;localDateTime&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2018-01-01T10:24:00&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
   &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;zonedDateTime&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2018-01-01T10:24:00+09:00&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;spring-boot-20-iso-8601&quot;&gt;Spring Boot 2.0 (ISO 8601)&lt;/h2&gt;
&lt;p&gt;2.0이 되면서 훨씬 간편해졌다. Java 8을 최소 버전으로 지원하면서 별다른 설정없이 아래의 응답을 제공한다.&lt;/p&gt;
&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;localDateTime&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2018-01-01T10:24:00.445428&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;offsetDateTime&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2018-01-01T10:24:00.445428+09:00&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;unix-time-응답설정&quot;&gt;Unix Time 응답설정&lt;/h2&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@JsonComponent&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JsonConverter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocalDateTimeJsonSerializer&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JsonSerializer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LocalDateTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;serialize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LocalDateTime&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;localDateTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JsonGenerator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jsonGenerator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SerializerProvider&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serializerProvider&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localDateTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;atZone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ZoneId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;systemDefault&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toInstant&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;jsonGenerator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;writeNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocalDateTimeJsonDeserializer&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JsonDeserializer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LocalDateTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LocalDateTime&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deserialize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;JsonParser&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jsonParser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DeserializationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deserializationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jsonParser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getValueAsLong&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LocalDateTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ofInstant&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toInstant&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ZoneId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;systemDefault&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Spring에서 처리해주는 부분은 없고 Json 응답의 serialize/deserialize 를 등록해서 전역적으로 변경하도록 지정하면 모든 LocalDateTime에 대해서 long 형으로 변환하고 long 데이터는 LocalDateTime 으로 받을 때 변환되어 받아진다.&lt;/p&gt;

&lt;h1 id=&quot;글을-마치며-나름의-결론&quot;&gt;글을 마치며 나름의 결론&lt;/h1&gt;
&lt;p&gt;Spring을 기반으로 이야기하다보니 각 표현방식의 장단점을 넘어 ISO 8601이 더 효과적으로 보인다. 하지만 API를 개발하는 개발자와 그것을 사용하는 클라이언트 간에 어떠한 형태로든 약속이 되어 있다면 그 방법이 일관된 커뮤니케이션을 위해서 효과적이라고 생각한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이미 정해진 인터페이스는 굳이 변경하지 말자&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;우리의 경우처럼 비록 2년동안 사용해왔던 표현형식이 있지만 각 부분들 담당하는 개발자와 시스템간에 변경에 대한 이해가 있거나 아직 API 구성을 시작하지 않은 상황이라면 Spring 환경에서는 ISO 8601을 추천하고 싶다.&lt;/em&gt;&lt;br /&gt;
또한 Spring의 기본 제공되는 것 외에도 직접 Unix Time을 사용하도록 할 수 있으나 자신이 사용하는 기술진영과 프레임워크에서 주도하는 방식을 이용해서 설계하는 것이 향후 버전대응에도 유리할 것으로 기대한다.&lt;/p&gt;

&lt;p&gt;인터페이스는 약속이다. 각자의 상황과 이해에 따른 합의된 선택을 하면 후회가 없지 않을까?&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;javascript의 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/now&quot;&gt;Date&lt;/a&gt;는 milisecond 단위로 표현한다. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Danny Cho(osmania)</name><email>osmania0611@gmail.com</email></author><category term="api" /><category term="standard" /><category term="spring" /><summary type="html">popit에도 등록된 글 입니다.</summary></entry><entry><title type="html">공부하는 개발자</title><link href="https://osmania-dev.github.io/blahblah/2018/02/28/%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90/" rel="alternate" type="text/html" title="공부하는 개발자" /><published>2018-02-28T00:00:00+00:00</published><updated>2018-02-28T00:00:00+00:00</updated><id>https://osmania-dev.github.io/blahblah/2018/02/28/%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90</id><content type="html" xml:base="https://osmania-dev.github.io/blahblah/2018/02/28/%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90/">&lt;p&gt;&lt;img src=&quot;/assets/post/study.jpg&quot; alt=&quot;study&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;당신은-공부하고-있나요&quot;&gt;당신은 공부하고 있나요?&lt;/h1&gt;
&lt;p&gt;많은 개발자들에게 공부하고 있냐고 물어보면 할 생각이 있다거나 할 시간이 없다는 이야기를 한다.
극히 소수의 개발자들이 공부를 하고 있다고 답변을 하는데 그 내용을 들어보면 기술의 기초를 알아가는데 그치고 있다.
공부를 왜 해야하는지, 공부를 어떻게 하는지 나 자신도 확신할 수는 없지만 그동안의 경험을 바탕으로 정리해보았다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;참 지겹게도 들어온 공부해라 공부해라&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;사회에 나와서 일을 하면서 우리는 이 이야기를 얼마나 들어봤을까? 내 경험으로는 신입 초기에 비지니스를 잘 알아야 하니까 우리 업무를 이 문서를 통해 모두 익혀야 한다는 정도의 이야기를 들었던 것이 전부였다. 수능과 같은 시험을 잘 보기위해 공부를 해왔던 많은 사람들은 상황이 주어지지 않으면 스스로 공부라는 것을 하는데 낮설게 느낀다. 과연 공부할 필요가 있을까?&lt;/p&gt;

&lt;h1 id=&quot;의문점들&quot;&gt;의문점들…&lt;/h1&gt;
&lt;p&gt;주변으로부터 또는 내 스스로 공부해야한다는 그 말에 몇가지 의문을 가진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Who : 난 경력도 많고 업무도 잘하니까 난 공부할 필요없어&lt;/li&gt;
  &lt;li&gt;What : 어떤 걸 공부하지? 비즈니스만 잘 알면 되는거 아닌가?&lt;/li&gt;
  &lt;li&gt;How : 학원을 다녀야하나? 우리회사는 교육이 없어…&lt;/li&gt;
  &lt;li&gt;When : 업무하기도 바쁜데.. 회사를 위해 내 시간까지 써야하나?&lt;/li&gt;
  &lt;li&gt;Where : 막막한데 공부할 자료는 어디에 있나?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사실 이 의문점들 모두가 공감이 가기도 한다. 우리가 살아가는데 큰 어려움도 없는데 더 정확히 이야기해서 돈버는데 지장이 없는데 공부를 할 이유가 뭐가 있겠는가&lt;br /&gt;
그동안 학교 수업이나 학원을 통해서 누군가 가르쳐주는 것만 받았는데 회사에서 안 가르쳐주면 뭘 어떤식으로 해야할까? 회사를 위해서 왜 내가 이 시간들을 써야하는가…&lt;/p&gt;

&lt;h1 id=&quot;생각을-해보자&quot;&gt;생각을 해보자&lt;/h1&gt;
&lt;h2 id=&quot;개발을-대하는-자세&quot;&gt;개발을 대하는 자세&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/post/work.png&quot; alt=&quot;work attitude&quot; /&gt;&lt;br /&gt;
우리는 일을 대할 때 정말 하고 싶은 일이 있고 자신이 할수 있는 일이기 때문에 하는 일이 있고 별 흥미는 없지만 해야만 하기 때문에 하는 일들이 있다.&lt;br /&gt;
개발이라는 일이 그냥 해야만 하는 일이라면 더 잘해야할 이유를 찾기 어려울 것이다. 그 상황이라면 개인적으로 참 안타깝다는 생각이 들면서도 정말 그런 사람들이 많을까? 우리 인생의 거의 대부분을 일을 하면서 보내게 되는데 개발을 대하는 상황이 그렇다면 마음이 참 아프다.&lt;br /&gt;
하지만 잘하는 일이거나 너무 하고 싶은 일이라면 지금 하고있는 일을 더 잘하고 싶지 않은가? 충분히 만족할 만큼의 실력과 경험을 갖추었다고 생각하는가? 우리는 짧게는 20년동안 살아오면서 공부던 일이던 그것을 대하는 자세에 따라서 결과물이 크게 다르다는 것을 알고 있다. 개인의 만족을 위해서 공부를 하던 일을 잘하기 위해서 공부를 하던 우리의 자세가 일단 하고자 하는 긍정의 상태라면 조금이라도 공부해야한다는 생각을 가지고 있을 것으로 생각한다. 우리모두 공부하자!!&lt;/p&gt;

&lt;h2 id=&quot;슈퍼개발자가-되고-싶어요&quot;&gt;슈퍼개발자가 되고 싶어요&lt;/h2&gt;
&lt;p&gt;의욕인 강한 개발자는 새로운 기술을 모두 익히고 그것을 선도하고 능숙하기 다루기를 바란다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/kamranahmedse/developer-roadmap#-back-end-roadmap&quot;&gt;2018 Web Back-end Roadmap&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;지금도 빠르게 변화하고 새롭게 나타나는 많은 기술들을 모두 알 수 있을까? 이런 의지는 개인적으로는 멋지다고 생각한다. 하지만 한명의 개발자가 모든 것을 알 수는 없다. 그렇게 너무 넓은 범위를 알아가려고 하면 깊이 보다는 얇고 넓게 알게 된다. 물론 그것도 의미가 있다. 하지만 각 언어와 환경에서 추구하는 것을 이해하지 못하고 기초적인 사용하는 법에만 집중하면 제대로 알고 있다고 할 수 있는 지 의문이다.&lt;/p&gt;

&lt;h2 id=&quot;expert-beginner&quot;&gt;Expert Beginner&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/post/expertbeginner.png&quot; alt=&quot;expert beginner&quot; /&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.daedtech.com/how-developers-stop-learning-rise-of-the-expert-beginner/&quot;&gt;Expert Beginner (1)&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://github.com/kamranahmedse/developer-roadmap#-back-end-roadmap&quot;&gt;Expert Beginner (2)&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;전문적-초심자&quot;&gt;전문적 초심자&lt;/h3&gt;
&lt;p&gt;Erik Dietrich 가 주장하기를 개발자는 &lt;strong&gt;초심자, 숙련된 초심자, 실력자, 능숙한 개발자, 전문가&lt;/strong&gt;로 구분이 된다고 한다. 우리는 초심자 단계에서 다른 사람들을 통해 배우고 흉내내면서 큰 그림을 그리지 못하고 정해진 규칙을 따라한다. 이 단계에서 초심자는 숙련된 초심자 단계까지 &lt;strong&gt;낮은 곳에 달린 열매&lt;/strong&gt;들을 따며 매우 빠르게 성장한다.&lt;br /&gt;
이때 숙련된 초심자는 재능의 벽에 부딪히거나 자발적으로 의미있는 성장을 하려는 시도를 멈추고자 하는 마음가짐을 가지는 성장의 구속이 일어날 수 있다. 재능의 벽은 대부분 해당하지 않고 대부분 두번째에 속하고 이 단계를 우리는 전문적 초심자라고 명명한다.&lt;/p&gt;

&lt;h3 id=&quot;현실안주의-전염성&quot;&gt;현실안주의 전염성&lt;/h3&gt;
&lt;p&gt;능숙 단계에 있는 개발자는 자신이 전문적이지 않다라는 것을 학습과 경험을 통해 알고 있다. 
하지만 빠르게 성장하면서 매해 경험이 쌓이고 주니어에서 시니어가 되고 사원, 주임, 대리, 과장 등이 되면서 우리는 시니어, 리더, 아키텍트, 책임 등 자연스럽게 연차가 쌓이면 어느 정도의 권위나 영향력을 가진 위치를 가지게 된다. &lt;strong&gt;초심자 시절에 경험한 것들만 지속적으로 경험한 사람은 자연스럽게 전문적 초심자&lt;/strong&gt;가 되는 과정이다.&lt;/p&gt;

&lt;p&gt;하나의 집단에서 오랫동안 안주하면서 높은 연봉을 받을 준비를 마치고 주변과 그들 스스로 더 많은 것을 할 수 있다는 사실을 모르는 채 그것을 못 견디는 사람들은 떠나고 일부는 떠나지 않고 남는다. 이들은 자신의 차례를 기다리면, 실제 능력과 상관없이 무조건적인 권력을 얻게 된다는 것과 이 곳에서는 그저 그런 상태로 있어도 괜찮거나, 심지어는 더 좋을 수도 있다는 것을 깨달으면서 전문적 초심자가 전염되는 현상을 보인다.&lt;/p&gt;

&lt;h3 id=&quot;현실을-탓하거나-스스로-함정에-빠지지-말자&quot;&gt;현실을 탓하거나 스스로 함정에 빠지지 말자&lt;/h3&gt;
&lt;p&gt;전문적 초심자로 느껴지는 주변에 인물들이 있는가? 그렇기 때문에 바뀌지 않고 모두가 안주한다고 생각하는가? 주변의 상황을 변하게 만드는 것은 상당히 어렵다. 변하지 않는 요인은 개선하려고 노력하면서 스스로 그것을 벗어나 성장하기 위한 노력을 하면 전문적 초심자가 아닌 실력자/능숙한 개발자로 성장할 가능성을 높힌다. 또한 공부하려는 노력 그 자체로 현실에 안주하려는 자신을 함정에 빠지지 않게 하는 효과도 있다. Expert Beginner를 주장한 블로그에서는 조직의 부패와 성장의 정체를 주로 이야기 하는데 조직의 개념이 아닌 개인의 관점에서 &lt;strong&gt;스스로 성장할 수 있는 기회를 만드는 것은 자신의 학습&lt;/strong&gt;이라고 이야기 하고 싶다.&lt;/p&gt;

&lt;h2 id=&quot;개발공부-tips&quot;&gt;개발공부 Tips&lt;/h2&gt;
&lt;p&gt;여러가지 팁들이 있겠지만 이제 공부를 시작하거나 해보고자 하는 의지를 가졌다면 몇가지 조언하면서 마무리 하고 싶다.&lt;/p&gt;

&lt;h3 id=&quot;최신기술의-키워드와-관심&quot;&gt;최신기술의 키워드와 관심&lt;/h3&gt;
&lt;p&gt;최신 기술을 다루고 공부하는 것이 더 멋지고 가치있다고 느끼는 경우가 많다. 뒤쳐지지 않기 위해 최신 기술을 따라가려고 노력하기 보다는 그 기술들의 키워드에 관심을 가지는 것은 매우 중요하다. 왜 그 기술들이 나왔고 그것이 자신의 업무에 어떠한 영향을 미치는 지 트렌드를 알고 학습하고 있어야 빠르게 변화하는 시대적 흐름을 대응할 수 있다. 그러나 우리들 대부분은 현재 자신이 하고 있는 업무에 연관된 기술조차도 제대로 이해하지 못하는 경우가 너무 많다. 그 기 기술만으로도 할 수 있는 것들이 많으니 일단 자신이 잘 아는 것, 잘 안다고 생각하는 것들부터 공부하는 것을 추천하고 싶다.&lt;/p&gt;

&lt;h3 id=&quot;레퍼런스와-도서로-공부&quot;&gt;레퍼런스와 도서로 공부&lt;/h3&gt;
&lt;p&gt;인터넷에서 볼 수 있는 글들 그중에서도 블로그 글들은 전체적인 흐름이나 상세한 내용보다는 단편적인 정보로 이루어진 경우가 상당히 많다. 이 정보들만 접하게 되면 마치 그 내용이 그 기술에 전부로 착각하기가 쉽고 예외적인 상황을 대응하기가 어렵다.&lt;br /&gt;
기술에 대해 가장 자세하고 정확한 정보는 레퍼런스에 있다. 이곳에는 우리가 필요로 하는 초기 설정이나 활용방법, 예외사항, 기술의 깊이있는 내용들이 많다. 레퍼런스를 기반으로 학습하고 전체적 흐름을 볼 수 있는 도서를 보는 것을 추천한다.&lt;/p&gt;

&lt;h3 id=&quot;직접-개발하고-기록&quot;&gt;직접 개발하고 기록&lt;/h3&gt;
&lt;p&gt;아무리 눈으로 귀로 학습해도 직접해보지 않으면 자신의 것이 되지 않는다. 공부를 했다면 반드시 한번은 직접 개발해보고 그 과정과 결과를 기록하는 것이 중요하다. 그것이 쌓이면 큰 자산이 될 것이라고 믿는다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;많은 이야기를 했지만 결론은 공부하자!!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;iframe src=&quot;//www.slideshare.net/slideshow/embed_code/key/5Cqf5xuHEP2j4F&quot; width=&quot;595&quot; height=&quot;485&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen=&quot;&quot;&gt; &lt;/iframe&gt;
&lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;//www.slideshare.net/ssuseradae0e/why-developers-study-91077569&quot; title=&quot;공부하는 개발자(Why developers study?)&quot; target=&quot;_blank&quot;&gt;공부하는 개발자(Why developers study?)&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&quot;https://www.slideshare.net/ssuseradae0e&quot; target=&quot;_blank&quot;&gt;광희 조&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;</content><author><name>Danny Cho(osmania)</name><email>osmania0611@gmail.com</email></author><category term="blahblah" /><category term="seminar" /><summary type="html"></summary></entry></feed>