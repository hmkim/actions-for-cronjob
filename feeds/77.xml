<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>좋은 JavaScript 코드 작성을 위한 블로그</title>
  <subtitle>JavaScript 프로그래밍 노하우, 다양한 오류 사례를 공유합니다.</subtitle>
  <link type="application/atom+xml" href="/deepscan/atom.xml" rel="self"/>
  <link type="text/html" href="https://cimfalab.github.io/deepscan/" rel="alternate"/>
  <updated>2018-08-27T04:58:24+00:00</updated>
  <id>https://cimfalab.github.io/deepscan/</id>

  
  <entry>
    <title>정적 분석으로 자바스크립트 코드의 오류와 코드 스멜 찾기</title>
    <link href="/deepscan/2018/08/javascript-static-analysis?utm_source=RSS&amp;utm_medium=RSS&amp;utm_campaign=/2018/08/javascript-static-analysis"/>
    <updated>2018-08-27T05:00:00+00:00</updated>
    <id>/deepscan/2018/08/javascript-static-analysis</id>
    <content type="html">&lt;p&gt;JavaScript의 강세가 여전히 지속되고 있습니다.&lt;/p&gt;

&lt;p&gt;2016년 이후 GitHub 통계에서 (pull request 기준) 가장 인기 있는 언어의 위치를 계속 차지하고 있고,
많이들 아시는 Martin Fowler의 &amp;lt;리팩토링(Refactoring)&amp;gt;이 올해 개정판이 나오는데 예제 언어가 Java에서 JavaScript로 바뀌는 것도 하나의 징후인 것 같습니다.&lt;/p&gt;

&lt;p&gt;JavaScript에도 정적 분석 도구를 통한 코드 품질 관리가 필요하다는 나름의 생각으로 운영하고 있는 &lt;a href=&quot;https://deepscan.io/&quot;&gt;DeepScan 서비스&lt;/a&gt;도 좀 더 힘을 얻을 것 같고요.&lt;/p&gt;

&lt;p&gt;몇 달 전에 DeepScan에서 축적된 데이터 기반으로 정적 분석 도구의 JavaScript 적용에 관한 백서를 썼었는데요,
이번에 한글 번역이 돼서 링크 공유합니다.&lt;/p&gt;

&lt;p&gt;내용을 요약하면 아래와 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;JavaScript 활용이 늘어나지만 개발 및 유지보수에 어려움이 있다. 기존 언어들은 정적 분석 도구를 통해 미리 코드 에러에 대응하여 품질 비용을 낮추어 왔다. JavaScript에도 정적 분석 기술을 적용하면 어떨까?&lt;/li&gt;
  &lt;li&gt;정적 분석 도구의 동작 원리&lt;/li&gt;
  &lt;li&gt;정적 분석 서비스를 운영하면서 수집된 오류 통계와 예제를 통해 JavaScript 개발자들이 많이 실수하는 패턴을 알 수 있다. 또 수정에 걸린 시간을 통해 개발자들이 중요하게 생각하는 에러의 종류도 알 수 있다.&lt;/li&gt;
  &lt;li&gt;정적 분석 도구 도입을 위한 체크리스트&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;본문은 아래 링크에서 보실 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;한글 버전: &lt;a href=&quot;https://m.post.naver.com/viewer/postView.nhn?volumeNo=16517463&quot;&gt;네이버 포스트&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;영문 버전: &lt;a href=&quot;https://medium.com/deepscan/detecting-javascript-errors-and-code-smells-with-static-analysis-504787b0acad&quot;&gt;Medium&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  
  <entry>
    <title>React 개발자가 실수하기 쉬운 몇 가지 (3)</title>
    <link href="/deepscan/2017/07/react-3?utm_source=RSS&amp;utm_medium=RSS&amp;utm_campaign=/2017/07/react-3"/>
    <updated>2017-07-19T05:00:00+00:00</updated>
    <id>/deepscan/2017/07/react-3</id>
    <content type="html">&lt;blockquote class=&quot;preface&quot;&gt;
  &lt;p&gt;제가 개발 중인 JavaScript 정적 분석 도구 &lt;a href=&quot;https://deepscan.io&quot;&gt;DeepScan&lt;/a&gt;은 JavaScript의 일반적인 오류 외에도 최근 핫한 React를 잘 지원하려는 목표를 갖고 있습니다.&lt;/p&gt;

  &lt;p&gt;ESLint나 주변 React 개발자들의 피드백을 통해 십여 종의 React 검증 규칙을 개발해 왔는데, 이 중에서 React를 처음 배우는 개발자들이 실수하기 쉬운 내용을 추려 시리즈로 연재합니다.&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;/deepscan/2017/06/react-1&quot;&gt;React 개발자가 실수하기 쉬운 몇 가지 (1)&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/deepscan/2017/07/react-2&quot;&gt;React 개발자가 실수하기 쉬운 몇 가지 (2)&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;React 개발자가 실수하기 쉬운 몇 가지 (3)&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;/deepscan/2017/07/react-2&quot;&gt;지난 글&lt;/a&gt;에서 오픈소스의 사례로 다음과 같은 React의 실수 패턴을 알아봤습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;render 함수의 반환 값을 직접 사용&lt;/li&gt;
  &lt;li&gt;이벤트 핸들러 함수에서 이벤트 전파가 중단되지 않는 경우&lt;/li&gt;
  &lt;li&gt;JSX에서 JavaScript 주석을 사용하는 경우&lt;/li&gt;
  &lt;li&gt;length 속성 검사&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;오늘도 다양한 실수 패턴을 알아보도록 하겠습니다.&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#이벤트-핸들러를-문자열로-지정한-경우&quot; id=&quot;markdown-toc-이벤트-핸들러를-문자열로-지정한-경우&quot;&gt;이벤트 핸들러를 문자열로 지정한 경우&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#deepscan-rule&quot; id=&quot;markdown-toc-deepscan-rule&quot;&gt;DeepScan Rule&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#이벤트-핸들러-함수가-올바로-바인딩-되지-않은-경우&quot; id=&quot;markdown-toc-이벤트-핸들러-함수가-올바로-바인딩-되지-않은-경우&quot;&gt;이벤트 핸들러 함수가 올바로 바인딩 되지 않은 경우&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#deepscan-rule-1&quot; id=&quot;markdown-toc-deepscan-rule-1&quot;&gt;DeepScan Rule&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#엘리먼트의-스타일-속성을-잘못-지정한-경우&quot; id=&quot;markdown-toc-엘리먼트의-스타일-속성을-잘못-지정한-경우&quot;&gt;엘리먼트의 스타일 속성을 잘못 지정한 경우&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#deepscan-rule-2&quot; id=&quot;markdown-toc-deepscan-rule-2&quot;&gt;DeepScan Rule&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#자식-엘리먼트의-key-속성을-지정하지-않은-경우&quot; id=&quot;markdown-toc-자식-엘리먼트의-key-속성을-지정하지-않은-경우&quot;&gt;자식 엘리먼트의 key 속성을 지정하지 않은 경우&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#deepscan-rule-3&quot; id=&quot;markdown-toc-deepscan-rule-3&quot;&gt;DeepScan Rule&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#wrap-up&quot; id=&quot;markdown-toc-wrap-up&quot;&gt;Wrap-Up&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;이벤트-핸들러를-문자열로-지정한-경우&quot;&gt;이벤트 핸들러를 문자열로 지정한 경우&lt;/h2&gt;
&lt;p&gt;HTML에서는 이벤트 핸들러를 문자열로 지정합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;image src=&quot;hello.png&quot; onclick=&quot;alert('Hi')&quot;/&amp;gt;&lt;/code&gt; 같이 문자열에 스크립트 코드를 넣죠.&lt;/p&gt;

&lt;p&gt;하지만 React의 이벤트 핸들러는 HTML과 달리 항상 함수 객체로 지정되어야 합니다. 이벤트 핸들러를 문자열로 지정하면 React에서 예외가 발생합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/react&quot;&gt;React&lt;/a&gt;의 테스트 코드에서도 문자열로 지정된 이벤트 핸들러에 대한 체크를 볼 수 있습니다.&lt;/p&gt;

&lt;pre class=&quot;&quot; data-start=&quot;&quot; data-line=&quot;28&quot; data-line-offset=&quot;25&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;it('should prevent non-function listeners, at dispatch', () =&amp;gt; {
  var node = ReactTestUtils.renderIntoDocument(
    &amp;lt;div onClick=&quot;not a function&quot; /&amp;gt;,
  );
  expect(function() {
    ReactTestUtils.SimulateNative.click(node);
  }).toThrowError(
    'Expected onClick listener to be a function, instead got type string',
  );
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;&lt;a href=&quot;https://github.com/facebook/react/blob/197e184859140524e1de92abfc6d678bbc85b340/src/renderers/__tests__/EventPluginHub-test.js&quot;&gt;__tests__/EventPluginHub-test.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;React의 이벤트 핸들러는 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div onClick=&quot;console.log('clicked')&quot;&amp;gt;&lt;/code&gt; 같이 쓰지 않고 아래처럼 함수 객체가 지정되어야 함을 기억하세요.&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'react'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Hello&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Component&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;handleClick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'clicked'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;onClick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;handleClick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
                    &lt;span class=&quot;nx&quot;&gt;Hello&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/div&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;            &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;deepscan-rule&quot;&gt;DeepScan Rule&lt;/h3&gt;

&lt;p&gt;DeepScan의 &lt;a href=&quot;https://deepscan.io/docs/rules/bad-event-handler/&quot;&gt;BAD_EVENT_HANDLER&lt;/a&gt; 규칙은 이벤트 핸들러에 문자열이 지정된 경우를 찾아 개발자의 실수를 방지할 수 있습니다.&lt;/p&gt;
&lt;table class=&quot;table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;&quot;&gt;Event handler of a React element cannot be a string. Consider specifying a function instead.
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;err&quot;&gt;&amp;lt;div onClick=&quot;not a function&quot; /&amp;gt;,
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;이벤트-핸들러-함수가-올바로-바인딩-되지-않은-경우&quot;&gt;이벤트 핸들러 함수가 올바로 바인딩 되지 않은 경우&lt;/h2&gt;
&lt;p&gt;이벤트 핸들러 관련해서 하나 더 보도록 하죠.&lt;/p&gt;

&lt;p&gt;React는 이벤트 핸들러를 호출할 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; 객체를 제공하지 않기 때문에 이벤트 핸들러 함수에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;의 속성에 접근하는 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;TypeError&lt;/code&gt; 예외가 발생합니다.&lt;/p&gt;

&lt;p&gt;이를 해결하기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Function.prototype.bind()&lt;/code&gt;를 이용해 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; 객체를 명시적으로 지정하거나 ES6의 화살표 함수(arrow function)를 사용해야 합니다. 참고로 &lt;code class=&quot;highlighter-rouge&quot;&gt;React.createClass()&lt;/code&gt;에서는 멤버 함수가 자동으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; 객체와 바인딩 되므로 이를 클래스로 변환할 때는 특히 주의할 필요가 있습니다.&lt;/p&gt;

&lt;p&gt;아래 오픈소스 &lt;a href=&quot;https://github.com/Automattic/wp-calypso&quot;&gt;wp-calypso&lt;/a&gt;의 예를 보면 이벤트 핸들러로 지정된 &lt;code class=&quot;highlighter-rouge&quot;&gt;this.trackUpgradeClick&lt;/code&gt; 함수가 제대로 바인딩 되어 있지 않아 에러가 발생합니다.&lt;/p&gt;

&lt;pre class=&quot;&quot; data-start=&quot;&quot; data-line=&quot;279,282,285,312&quot; data-line-offset=&quot;267&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;import React, { Component } from 'react';

class SiteSettingsFormGeneral extends Component {
	blogAddress() {
		translate(
			'Buy a custom domain, ' +
			'map a domain you already own, ' +
			'or redirect this site.',
			{
				components: {
					domainSearchLink: (
						&amp;lt;a href={ '/domains/add/' + site.slug } onClick={ this.trackUpgradeClick } /&amp;gt;
					),
					mapDomainLink: (
						&amp;lt;a href={ '/domains/add/mapping/' + site.slug } onClick={ this.trackUpgradeClick } /&amp;gt;
					),
					redirectLink: (
						&amp;lt;a href={ '/domains/add/site-redirect/' + site.slug } onClick={ this.trackUpgradeClick } /&amp;gt;
					)
				}
			}
		)




		return (
			&amp;lt;FormFieldset className=&quot;site-settings__has-divider&quot;&amp;gt;
				&amp;lt;FormLabel htmlFor=&quot;blogaddress&quot;&amp;gt;{ translate( 'Site Address' ) }&amp;lt;/FormLabel&amp;gt;
				&amp;lt;div className=&quot;site-settings__blogaddress-settings&quot;&amp;gt;
					&amp;lt;FormInput
						name=&quot;blogaddress&quot;
						type=&quot;text&quot;
						id=&quot;blogaddress&quot;
						value={ site.domain }
						disabled=&quot;disabled&quot; /&amp;gt;
					{ customAddress }
				&amp;lt;/div&amp;gt;
				{ addressDescription }
			&amp;lt;/FormFieldset&amp;gt;
		);
	}

	trackUpgradeClick() {
		this.props.recordTracksEvent( 'calypso_upgrade_nudge_cta_click', { cta_name: 'settings_site_address' } );
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;&lt;a href=&quot;https://github.com/Automattic/wp-calypso/blob/a843773ea709cca3b078a4391ae295335794a1ad/client/my-sites/site-settings/form-general.jsx&quot;&gt;site-settings/form-general.jsx&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;다행히 이 &lt;a href=&quot;https://github.com/Automattic/wp-calypso/commit/ea5848efa50b071da28529580d2e7778a2ee2dc9&quot;&gt;커밋&lt;/a&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;trackUpgradeClick&lt;/code&gt;을 화살표 함수로 변경한 것을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/react-bad-event-handler-invalid-this.png&quot; alt=&quot;&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;deepscan-rule-1&quot;&gt;DeepScan Rule&lt;/h3&gt;

&lt;p&gt;DeepScan의 &lt;a href=&quot;https://deepscan.io/docs/rules/event-handler-invalid-this/&quot;&gt;EVENT_HANDLER_INVALID_THIS&lt;/a&gt; 규칙은 이벤트 핸들러 함수가 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; 객체와 바인딩 되지 않은 경우를 찾아 개발자의 실수를 방지할 수 있습니다.&lt;/p&gt;
&lt;table class=&quot;table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;&quot;&gt;Function 'this.trackUpgradeClick' is used as a React event handler without 'this' binding. But 'this' object is accessed in the function body at line 312.
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;err&quot;&gt;&amp;lt;a href={ '/domains/add/' + site.slug } onClick={ this.trackUpgradeClick } /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;trackUpgradeClick&lt;/code&gt; 함수 내부인 312 라인에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; 객체가 사용되기 때문에 문제가 된다는 것을 바로 알 수 있네요.&lt;/p&gt;

&lt;h2 id=&quot;엘리먼트의-스타일-속성을-잘못-지정한-경우&quot;&gt;엘리먼트의 스타일 속성을 잘못 지정한 경우&lt;/h2&gt;
&lt;p&gt;이벤트 핸들러를 문자열로 지정할 수 없는 것과 유사하게 React는 &lt;code class=&quot;highlighter-rouge&quot;&gt;style&lt;/code&gt; 속성에 CSS 규칙을 표현하는 문자열을 허용하지 않습니다.&lt;/p&gt;

&lt;p&gt;React에서는 HTML과 달리 &lt;code class=&quot;highlighter-rouge&quot;&gt;style&lt;/code&gt; 속성을 항상 객체로 지정해야 하고 객체, &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt; 외의 값을 지정한 경우 예외가 발생합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/react&quot;&gt;React&lt;/a&gt;의 테스트 코드에서도 이에 대한 체크를 볼 수 있습니다.&lt;/p&gt;

&lt;pre class=&quot;&quot; data-start=&quot;&quot; data-line=&quot;1171&quot; data-line-offset=&quot;1167&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;    it('should report component containing invalid styles', () =&amp;gt; {
      class Animal extends React.Component {
        render() {
          return &amp;lt;div style={1} /&amp;gt;;
        }
      }

      expect(function() {
        ReactDOM.render(&amp;lt;Animal /&amp;gt;, container);
      }).toThrowError(
        'The `style` prop expects a mapping from style properties to values, ' +
          &quot;not a string. For example, style= &quot; +
          'when using JSX.\n\nThis DOM node was rendered by `Animal`.',
      );
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;&lt;a href=&quot;https://github.com/facebook/react/blob/197e184859140524e1de92abfc6d678bbc85b340/src/renderers/dom/shared/__tests__/ReactDOMComponent-test.js&quot;&gt;__tests__/ReactDOMComponent-test.js&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;deepscan-rule-2&quot;&gt;DeepScan Rule&lt;/h3&gt;

&lt;p&gt;DeepScan의 &lt;a href=&quot;https://deepscan.io/docs/rules/bad-style-prop/&quot;&gt;BAD_STYLE_PROP&lt;/a&gt; 규칙은 &lt;code class=&quot;highlighter-rouge&quot;&gt;style&lt;/code&gt; 속성이 객체가 아닌 값으로 지정된 경우를 찾아 개발자의 실수를 방지할 수 있습니다.&lt;/p&gt;
&lt;table class=&quot;table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;&quot;&gt;'style' prop of a React DOM element cannot be a numeric value. Consider specifying an object instead.
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;err&quot;&gt;return &amp;lt;div style={1} /&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;자식-엘리먼트의-key-속성을-지정하지-않은-경우&quot;&gt;자식 엘리먼트의 key 속성을 지정하지 않은 경우&lt;/h2&gt;
&lt;p&gt;React에서는 DOM 트리를 업데이트할 때 &lt;a href=&quot;https://facebook.github.io/react/docs/reconciliation.html#recursing-on-children&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt; 속성을 활용한 diff 알고리즘&lt;/a&gt;을 통해 렌더링을 최적화합니다.&lt;/p&gt;

&lt;p&gt;그런데 DOM 노드의 각 자식 엘리먼트에 &lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt; 속성이 없으면 해당 diff 알고리즘을 활용하지 못하고 렌더링 성능에 영향을 줄 수 있습니다. React에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt; 속성이 없을 경우 경고하는 이유이기도 하죠.&lt;/p&gt;

&lt;p&gt;따라서 엘리먼트가 부모 노드의 자식으로서 컬렉션에 포함되는 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt; 속성을 지정하는 습관을 가져야 합니다.&lt;/p&gt;

&lt;p&gt;아래 오픈소스 &lt;a href=&quot;https://github.com/uber/react-vis&quot;&gt;react-vis&lt;/a&gt;도 &lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt; 속성 없이 사용하는데,&lt;/p&gt;

&lt;pre class=&quot;&quot; data-start=&quot;&quot; data-line=&quot;28,37&quot; data-line-offset=&quot;25&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function renderSection(section, index) {
  const content = [(
    &amp;lt;div className={`fcol fg bullet-info ${(index % 2) ? '' : 'bullet-info-reversed'}`}&amp;gt;
      &amp;lt;div className=&quot;bullet-point-title&quot;&amp;gt;
        {section.title}
      &amp;lt;/div&amp;gt;
      &amp;lt;div className=&quot;bullet-point-text&quot;&amp;gt;
        {section.text}
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  ), (
    &amp;lt;div className=&quot;bullet-example&quot;&amp;gt;
      {section.component}
    &amp;lt;/div&amp;gt;
  )];
  return (
    &amp;lt;div className=&quot;bullet-point f&quot;&amp;gt;
      {!(index % 2) ? content.reverse() : content}
    &amp;lt;/div&amp;gt;
  );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;&lt;a href=&quot;https://github.com/uber/react-vis/blob/baf8a946bc39b9e36c597107f347e532b8b26f62/docs/docs-app/components/home.js&quot;&gt;components/home.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;향후 &lt;a href=&quot;https://github.com/uber/react-vis/commit/6d003947f5a9807f129be8d0cb463c819d617820&quot;&gt;커밋&lt;/a&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt; 속성이 추가되었음을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/react-missing-key-prop.png&quot; alt=&quot;&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;deepscan-rule-3&quot;&gt;DeepScan Rule&lt;/h3&gt;

&lt;p&gt;DeepScan의 &lt;a href=&quot;https://deepscan.io/docs/rules/missing-key-prop/&quot;&gt;MISSING_KEY_PROP&lt;/a&gt; 규칙은 컬렉션 내의 엘리먼트에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt; 속성이 빠진 경우를 찾아 개발자의 실수를 방지할 수 있습니다.&lt;/p&gt;
&lt;table class=&quot;table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;&quot;&gt;Each child React element in a collection should have a 'key' prop.
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;err&quot;&gt;[(
    &amp;lt;div className=&quot;bullet-example&quot;&amp;gt;
      {section.component}
    &amp;lt;/div&amp;gt;
)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap-Up&lt;/h2&gt;

&lt;p&gt;위에 제시된 코드들은 &lt;a href=&quot;https://deepscan.io/demo/&quot;&gt;데모 페이지&lt;/a&gt;에서 바로 붙여넣어 체크해 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;오늘 살펴본 React 코드 오류는 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이벤트 핸들러를 문자열로 지정한 경우&lt;/li&gt;
  &lt;li&gt;이벤트 핸들러 함수가 올바로 바인딩 되지 않은 경우&lt;/li&gt;
  &lt;li&gt;엘리먼트의 스타일 속성을 잘못 지정한 경우&lt;/li&gt;
  &lt;li&gt;자식 엘리먼트의 key 속성을 지정하지 않은 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;특히 React를 처음 배우는 분들에게 도움이 되길 바라며 오늘 글을 마칩니다.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>React 개발자가 실수하기 쉬운 몇 가지 (2)</title>
    <link href="/deepscan/2017/07/react-2?utm_source=RSS&amp;utm_medium=RSS&amp;utm_campaign=/2017/07/react-2"/>
    <updated>2017-07-03T14:00:00+00:00</updated>
    <id>/deepscan/2017/07/react-2</id>
    <content type="html">&lt;blockquote class=&quot;preface&quot;&gt;
  &lt;p&gt;제가 개발 중인 JavaScript 정적 분석 도구 &lt;a href=&quot;https://deepscan.io&quot;&gt;DeepScan&lt;/a&gt;은 JavaScript의 일반적인 오류 외에도 최근 핫한 React를 잘 지원하려는 목표를 갖고 있습니다.&lt;/p&gt;

  &lt;p&gt;ESLint나 주변 React 개발자들의 피드백을 통해 십여 종의 React 검증 규칙을 개발해 왔는데, 이 중에서 React를 처음 배우는 개발자들이 실수하기 쉬운 내용을 추려 시리즈로 연재합니다.&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;/deepscan/2017/06/react-1&quot;&gt;React 개발자가 실수하기 쉬운 몇 가지 (1)&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;React 개발자가 실수하기 쉬운 몇 가지 (2)&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/deepscan/2017/07/react-3&quot;&gt;React 개발자가 실수하기 쉬운 몇 가지 (3)&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;/deepscan/2017/06/react-1&quot;&gt;지난 글&lt;/a&gt;에서 오픈소스 &lt;a href=&quot;https://github.com/Automattic/wp-calypso&quot;&gt;wp-calypso&lt;/a&gt;의 사례로 다음과 같은 React의 실수 패턴을 알아봤습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;React API의 오타&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;render&lt;/code&gt; 함수에서 잘못된 값을 반환&lt;/li&gt;
  &lt;li&gt;이벤트 핸들러 함수를 잘못 지정한 경우&lt;/li&gt;
  &lt;li&gt;DOM element에서 잘못된 속성 지정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;오늘은 다른 오픈소스의 사례로 더 다양한 실수 패턴을 알아보도록 하겠습니다.&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#render-함수의-반환-값을-직접-사용&quot; id=&quot;markdown-toc-render-함수의-반환-값을-직접-사용&quot;&gt;render 함수의 반환 값을 직접 사용&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#deepscan-rule&quot; id=&quot;markdown-toc-deepscan-rule&quot;&gt;DeepScan Rule&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#이벤트-핸들러-함수에서-이벤트-전파가-중단되지-않는-경우&quot; id=&quot;markdown-toc-이벤트-핸들러-함수에서-이벤트-전파가-중단되지-않는-경우&quot;&gt;이벤트 핸들러 함수에서 이벤트 전파가 중단되지 않는 경우&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#deepscan-rule-1&quot; id=&quot;markdown-toc-deepscan-rule-1&quot;&gt;DeepScan Rule&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#jsx에서-javascript-주석을-사용하는-경우&quot; id=&quot;markdown-toc-jsx에서-javascript-주석을-사용하는-경우&quot;&gt;JSX에서 JavaScript 주석을 사용하는 경우&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#deepscan-rule-2&quot; id=&quot;markdown-toc-deepscan-rule-2&quot;&gt;DeepScan Rule&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#length-속성-검사&quot; id=&quot;markdown-toc-length-속성-검사&quot;&gt;length 속성 검사&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#deepscan-rule-3&quot; id=&quot;markdown-toc-deepscan-rule-3&quot;&gt;DeepScan Rule&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#wrap-up&quot; id=&quot;markdown-toc-wrap-up&quot;&gt;Wrap-Up&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;render-함수의-반환-값을-직접-사용&quot;&gt;render 함수의 반환 값을 직접 사용&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ReactDOM.render&lt;/code&gt; 함수에서 반환하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ReactComponent&lt;/code&gt; 인스턴스를 사용하는 경우가 있습니다.&lt;/p&gt;

&lt;p&gt;이 방법은 권장되지 않는데, 그 이유는 향후 React 버전에서 &lt;a href=&quot;https://facebook.github.io/react/docs/react-dom.html#render&quot;&gt;렌더링이 비동기적으로 일어날 수 있고&lt;/a&gt; 그 결과 반환 값을 즉시 사용하는 것으로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ReactComponent&lt;/code&gt; 인스턴스를 얻을 수가 없기 때문입니다.&lt;/p&gt;

&lt;p&gt;아래 오픈소스 &lt;a href=&quot;https://github.com/kriasoft/react-starter-kit&quot;&gt;react-starter-kit&lt;/a&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;render&lt;/code&gt; 함수의 반환 값을 그대로 사용하는데 이 값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;가 되어 원하는 초기화가 수행되지 않을 수 있습니다.&lt;/p&gt;

&lt;pre class=&quot;&quot; data-start=&quot;&quot; data-line=&quot;127&quot; data-line-offset=&quot;121&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;import ReactDOM from 'react-dom';

let appInstance;

async function onLocationChange(location, action) {
    appInstance = ReactDOM.render(
      &amp;lt;App context={context}&amp;gt;{route.component}&amp;lt;/App&amp;gt;,
      container,
      () =&amp;gt; onRenderComplete(route, location),
    );
}

if (appInstance) {
  // Force-update the whole tree, including components that refuse to update
  deepForceUpdate(appInstance);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;&lt;a href=&quot;https://github.com/kriasoft/react-starter-kit/blob/1d6153ed75919075bdd13a7b9715418b546da05f/src/client.js&quot;&gt;src/client.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이 경우는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ref&lt;/code&gt; 콜백 함수를 통해 인스턴스를 얻어야 합니다.&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;onLocationChange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ReactDOM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/App&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,
&lt;/span&gt;      &lt;span class=&quot;nx&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;onRenderComplete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;deepscan-rule&quot;&gt;DeepScan Rule&lt;/h3&gt;

&lt;p&gt;DeepScan의 &lt;a href=&quot;https://deepscan.io/docs/rules/async-render-return-value/&quot;&gt;ASYNC_RENDER_RETURN_VALUE&lt;/a&gt; 규칙은 &lt;code class=&quot;highlighter-rouge&quot;&gt;render&lt;/code&gt; 함수의 반환 값을 직접 사용하는 경우를 찾아 개발자의 실수를 방지할 수 있습니다.&lt;/p&gt;
&lt;table class=&quot;table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;&quot;&gt;Consider not using 'ReactDOM.render()' result because future versions of React may render components asynchronously.
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;err&quot;&gt;appInstance = ReactDOM.render(
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;이벤트-핸들러-함수에서-이벤트-전파가-중단되지-않는-경우&quot;&gt;이벤트 핸들러 함수에서 이벤트 전파가 중단되지 않는 경우&lt;/h2&gt;
&lt;p&gt;HTML에서는 이벤트 핸들러 함수에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;를 반환하면 이벤트 전파 및 기본 동작이 중단됩니다.&lt;/p&gt;

&lt;p&gt;하지만 React는 별도의 이벤트 시스템을 사용하고, 이벤트 전파나 기본 동작을 중단하려면 인자로 받은 React 이벤트 객체의 &lt;code class=&quot;highlighter-rouge&quot;&gt;stopPropagation()&lt;/code&gt;이나 &lt;code class=&quot;highlighter-rouge&quot;&gt;preventDefault()&lt;/code&gt;를 명시적으로 호출해야 합니다.&lt;/p&gt;

&lt;p&gt;아래 오픈소스 &lt;a href=&quot;https://github.com/brave/browser-laptop&quot;&gt;browser-laptop&lt;/a&gt;의 예를 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;onMaximizeClick&lt;/code&gt; 이벤트 핸들러에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;return false&lt;/code&gt; 같이 기존 방식대로 사용하고 있어 이벤트 전파가 중단되지 않습니다.&lt;/p&gt;

&lt;pre class=&quot;&quot; data-start=&quot;&quot; data-line=&quot;43&quot; data-line-offset=&quot;34&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;const React = require('react')

class WindowCaptionButtons extends ImmutableComponent {
  onMaximizeClick (e) {
    if (isFullScreen()) {
      // If full screen, toggle full screen status and restore window (make smaller)
      windowActions.shouldExitFullScreen(getCurrentWindowId())
      if (isMaximized()) windowActions.shouldUnmaximize(getCurrentWindowId())
      return false
    }
    return (!isMaximized()) ? windowActions.shouldMaximize(getCurrentWindowId()) : windowActions.shouldUnmaximize(getCurrentWindowId())
  }

  render () {
    const props = { tabIndex: -1 }

    return &amp;lt;div&amp;gt;
      &amp;lt;div className='container'&amp;gt;
        &amp;lt;button
          {...props}
          onClick={this.onMaximizeClick}
          title={locale.translation(this.maximizeTitle)}&amp;gt;
        &amp;lt;/button&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;&lt;a href=&quot;https://github.com/brave/browser-laptop/blob/87428bc2430fd743798ae910a17dcdb585141415/app/renderer/components/navigation/windowCaptionButtons.js&quot;&gt;navigation/windowCaptionButtons.js&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;deepscan-rule-1&quot;&gt;DeepScan Rule&lt;/h3&gt;

&lt;p&gt;DeepScan의 &lt;a href=&quot;https://deepscan.io/docs/rules/bad-event-handler-return-false/&quot;&gt;BAD_EVENT_HANDLER_RETURN_FALSE&lt;/a&gt; 규칙은 이벤트 핸들러로 사용되는 함수에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;를 반환하는 경우를 찾아 개발자의 실수를 방지할 수 있습니다.&lt;/p&gt;
&lt;table class=&quot;table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;&quot;&gt;In React, returning false from an event handler has no effect. Consider using 'preventDefault()' or 'stopPropagation()' of the event object.
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;err&quot;&gt;return false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;jsx에서-javascript-주석을-사용하는-경우&quot;&gt;JSX에서 JavaScript 주석을 사용하는 경우&lt;/h2&gt;
&lt;p&gt;JSX에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;//&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;/* */&lt;/code&gt; 같은 JavaScript 주석을 사용할 경우 주의가 필요합니다.&lt;/p&gt;

&lt;p&gt;주석이 JSX의 컴포넌트 하위 텍스트 노드로 인식되면 주석 내용이 브라우저 화면에 보이기 때문인데, 주석은 &lt;code class=&quot;highlighter-rouge&quot;&gt;{/* */}&lt;/code&gt; 같이 중괄호로 감싸야 합니다.&lt;/p&gt;

&lt;p&gt;아래 오픈소스 &lt;a href=&quot;https://github.com/nikgraf/belle&quot;&gt;belle&lt;/a&gt;에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;onUpdate should not be called for valueLink&lt;/code&gt;라는 주석이 그대로 화면에 노출되는 문제가 있습니다.&lt;/p&gt;

&lt;pre class=&quot;&quot; data-start=&quot;&quot; data-line=&quot;32&quot; data-line-offset=&quot;19&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;import React from 'react';

export default React.createClass({
  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;h2&amp;gt;Rating&amp;lt;/h2&amp;gt;

        &amp;lt;Card&amp;gt;

          &amp;lt;Button onClick={ this._updateRatingToThree }&amp;gt;Update Rating to value 3&amp;lt;/Button&amp;gt;

          //onUpdate should not be called for valueLink
          &amp;lt;h3&amp;gt;ValueLink&amp;lt;/h3&amp;gt;

        &amp;lt;/Card&amp;gt;

      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;&lt;a href=&quot;https://github.com/nikgraf/belle/blob/d6472a632b2f1c62f6e8954cae659bee3e6d8a9d/examples/components/RatingPlayground.js&quot;&gt;components/RatingPlayground.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이 경우는 다음과 같이 써야 합니다.&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* onUpdate should not be called for valueLink */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;h3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ValueLink&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/h3&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;반대로 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;h3&amp;gt;// is a double slash.&amp;lt;/h3&amp;gt;&lt;/code&gt; 같이 실제로 “//”를 써야 하는 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;h3&amp;gt;{&quot;// is a double slash.&quot;}&amp;lt;/h3&amp;gt;&lt;/code&gt;처럼 주석이 아닌 문자열임이 드러나도록 명확하게 쓰는 것이 좋은 습관으로 알려져 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;deepscan-rule-2&quot;&gt;DeepScan Rule&lt;/h3&gt;

&lt;p&gt;DeepScan의 &lt;a href=&quot;https://deepscan.io/docs/rules/bad-jsx-comment/&quot;&gt;BAD_JSX_COMMENT&lt;/a&gt; 규칙은 JSX 내에서 JavaScript 주석을 사용하는 경우를 찾아 개발자의 실수를 방지할 수 있습니다.&lt;/p&gt;
&lt;table class=&quot;table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;&quot;&gt;This text is recognized as a JSX child instead of a comment. Consider using JavaScript comment inside braces.
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;err&quot;&gt;//onUpdate should not be called for valueLink
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;length-속성-검사&quot;&gt;length 속성 검사&lt;/h2&gt;
&lt;p&gt;React에서 자식 엘리먼트(child element)를 &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;로 지정한 경우 렌더링에서 제외됩니다. 따라서 선택적인 렌더링을 할 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;cond &amp;amp;&amp;amp; &amp;lt;div&amp;gt;...&amp;lt;/div&amp;gt;&lt;/code&gt; 같은 JSX 구문을 많이 사용합니다.&lt;/p&gt;

&lt;p&gt;그런데 숫자 값 0에 대해선 이렇게 적용되지 않고 0이 그대로 화면에 출력됩니다.
즉 &lt;code class=&quot;highlighter-rouge&quot;&gt;array.length &amp;amp;&amp;amp; &amp;lt;div&amp;gt;...&amp;lt;/div&amp;gt;&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;array&lt;/code&gt;가 비어 있다면 0이 출력되므로, 이 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;length&lt;/code&gt; 속성을 직접 검사하는 대신 다음과 같이 사용해야 합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;array.length &amp;gt; 0&lt;/code&gt; 같은 비교 구문으로 사용&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;array.length &amp;amp;&amp;amp; &amp;lt;div&amp;gt;...&amp;lt;/div&amp;gt; || ''&lt;/code&gt; 같이 끝에 빈 문자열을 OR 조건으로 추가&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;아래 오픈소스 &lt;a href=&quot;https://github.com/ptmt/react-native-macos&quot;&gt;react-native-macos&lt;/a&gt;도 &lt;code class=&quot;highlighter-rouge&quot;&gt;length&lt;/code&gt; 속성을 직접 검사하기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;this.props.params&lt;/code&gt;가 비어 있다면 0이 출력됩니다.&lt;/p&gt;

&lt;pre class=&quot;&quot; data-start=&quot;&quot; data-line=&quot;657&quot; data-line-offset=&quot;644&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var React = require('React');

var Method = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&quot;prop&quot;&amp;gt;
        &amp;lt;Header level={4} className=&quot;methodTitle&quot; toSlug={this.props.name}&amp;gt;
          {this.props.modifiers &amp;amp;&amp;amp; this.props.modifiers.length &amp;amp;&amp;amp; &amp;lt;span className=&quot;methodType&quot;&amp;gt;
            {this.props.modifiers.join(' ') + ' '}
          &amp;lt;/span&amp;gt; || ''}
          {this.props.name}
          &amp;lt;span className=&quot;methodType&quot;&amp;gt;
            ({this.props.params &amp;amp;&amp;amp; this.props.params.length &amp;amp;&amp;amp; this.props.params
              .map((param) =&amp;gt; {
                var res = param.name;
                res += param.optional ? '?' : '';
                return res;
              })
              .join(', ')})
              {this.props.returns &amp;amp;&amp;amp; ': ' + this.renderTypehint(this.props.returns.type)}
          &amp;lt;/span&amp;gt;
        &amp;lt;/Header&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;&lt;a href=&quot;https://github.com/ptmt/react-native-macos/blob/5d32075363993191ba94605247992497f70aeb20/website/layout/AutodocsLayout.js&quot;&gt;layout/AutodocsLayout.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이 &lt;a href=&quot;https://github.com/ptmt/react-native-macos/commit/a7a3922b89d821b9a34d26bdcc7676e747a27160#diff-0c2bccba86d026e1fc586ac3c113d4a9&quot;&gt;커밋&lt;/a&gt;을 보면 위에서 얘기한 것 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;|| ''&lt;/code&gt; 조건을 붙여 수정한 것을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/react-bad-length-check.png&quot; alt=&quot;&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;deepscan-rule-3&quot;&gt;DeepScan Rule&lt;/h3&gt;

&lt;p&gt;DeepScan의 &lt;a href=&quot;https://deepscan.io/docs/rules/bad-length-check/&quot;&gt;BAD_LENGTH_CHECK&lt;/a&gt; 규칙은 &lt;code class=&quot;highlighter-rouge&quot;&gt;length&lt;/code&gt; 속성을 직접 검사하는 경우를 찾아 개발자의 실수를 방지할 수 있습니다.&lt;/p&gt;
&lt;table class=&quot;table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;&quot;&gt;Numeric value 0 can be rendered because 'this.props.params.length' itself is checked. Consider checking 'this.props.params.length &amp;gt; 0' instead.
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;err&quot;&gt;({this.props.params &amp;amp;&amp;amp; this.props.params.length &amp;amp;&amp;amp; this.props.params
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap-Up&lt;/h2&gt;

&lt;p&gt;위에 제시된 코드들은 &lt;a href=&quot;https://deepscan.io/demo/&quot;&gt;데모 페이지&lt;/a&gt;에서 바로 붙여넣어 체크해 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;오늘 살펴본 React 코드 오류는 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;render 함수의 반환 값을 직접 사용&lt;/li&gt;
  &lt;li&gt;이벤트 핸들러 함수에서 이벤트 전파가 중단되지 않는 경우&lt;/li&gt;
  &lt;li&gt;JSX에서 JavaScript 주석을 사용하는 경우&lt;/li&gt;
  &lt;li&gt;length 속성 검사&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;특히 React를 처음 배우는 분들에게 도움이 되면 좋겠습니다.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>React 개발자가 실수하기 쉬운 몇 가지 (1)</title>
    <link href="/deepscan/2017/06/react-1?utm_source=RSS&amp;utm_medium=RSS&amp;utm_campaign=/2017/06/react-1"/>
    <updated>2017-06-30T12:00:00+00:00</updated>
    <id>/deepscan/2017/06/react-1</id>
    <content type="html">&lt;blockquote class=&quot;preface&quot;&gt;
  &lt;p&gt;제가 개발 중인 JavaScript 정적 분석 도구 &lt;a href=&quot;https://deepscan.io&quot;&gt;DeepScan&lt;/a&gt;은 JavaScript의 일반적인 오류 외에도 최근 핫한 React를 잘 지원하려는 목표를 갖고 있습니다.&lt;/p&gt;

  &lt;p&gt;ESLint나 주변 React 개발자들의 피드백을 통해 십여 종의 React 검증 규칙을 개발해 왔는데, 이 중에서 React를 처음 배우는 개발자들이 실수하기 쉬운 내용을 추려 시리즈로 연재합니다.&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;React 개발자가 실수하기 쉬운 몇 가지 (1)&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/deepscan/2017/07/react-2&quot;&gt;React 개발자가 실수하기 쉬운 몇 가지 (2)&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/deepscan/2017/07/react-3&quot;&gt;React 개발자가 실수하기 쉬운 몇 가지 (3)&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;React는 페이스북이 개발과 마케팅을 주도하는 UI 개발용 JavaScript 라이브러리입니다.&lt;/p&gt;

&lt;p&gt;컴포넌트 구조, DOM과 분리된 상태 관리, 빠른 렌더링, JavaScript 중심의 구현 같은 특징으로 많은 인기를 얻고 있는데 기존에 HTML과 함께 DOM을 JavaScript로 직접 처리하는 데 익숙한 프론트엔드 개발자들에게는 조금 낯선 것도 사실입니다.&lt;/p&gt;

&lt;p&gt;이 글에서는 React를 배우는 개발자들이 실수하기 쉬운 내용을 패턴&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;으로 정리해서 오픈소스 &lt;a href=&quot;https://github.com/Automattic/wp-calypso&quot;&gt;wp-calypso&lt;/a&gt;의 코드와 함께 설명합니다.&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#react-api의-오타&quot; id=&quot;markdown-toc-react-api의-오타&quot;&gt;React API의 오타&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#컴포넌트의-lifecycle-메소드&quot; id=&quot;markdown-toc-컴포넌트의-lifecycle-메소드&quot;&gt;컴포넌트의 lifecycle 메소드&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#proptypes&quot; id=&quot;markdown-toc-proptypes&quot;&gt;PropTypes&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#deepscan-rule&quot; id=&quot;markdown-toc-deepscan-rule&quot;&gt;DeepScan Rule&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#render-함수에서-잘못된-값을-반환&quot; id=&quot;markdown-toc-render-함수에서-잘못된-값을-반환&quot;&gt;render 함수에서 잘못된 값을 반환&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#deepscan-rule-1&quot; id=&quot;markdown-toc-deepscan-rule-1&quot;&gt;DeepScan Rule&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#이벤트-핸들러-함수를-잘못-지정한-경우&quot; id=&quot;markdown-toc-이벤트-핸들러-함수를-잘못-지정한-경우&quot;&gt;이벤트 핸들러 함수를 잘못 지정한 경우&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#deepscan-rule-2&quot; id=&quot;markdown-toc-deepscan-rule-2&quot;&gt;DeepScan Rule&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dom-엘리먼트에서-잘못된-속성-지정&quot; id=&quot;markdown-toc-dom-엘리먼트에서-잘못된-속성-지정&quot;&gt;DOM 엘리먼트에서 잘못된 속성 지정&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#deepscan-rule-3&quot; id=&quot;markdown-toc-deepscan-rule-3&quot;&gt;DeepScan Rule&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#wrap-up&quot; id=&quot;markdown-toc-wrap-up&quot;&gt;Wrap-Up&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;react-api의-오타&quot;&gt;React API의 오타&lt;/h2&gt;
&lt;p&gt;매우 단순한 성격의 오류로서 React 컴포넌트의 lifecycle 메소드 이름이나 PropTypes를 잘못 쓰는 경우입니다.&lt;/p&gt;

&lt;h3 id=&quot;컴포넌트의-lifecycle-메소드&quot;&gt;컴포넌트의 lifecycle 메소드&lt;/h3&gt;
&lt;p&gt;React 컴포넌트는 생성되거나 상태 변경이 완료되었거나 하는 생명주기에 따른 &lt;a href=&quot;https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle&quot;&gt;lifecycle 메소드&lt;/a&gt;를 갖고 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;componentWillMount()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;componentDidMount()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;componentWillUnmount()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;componentWillReceiveProps()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shouldComponentUpdate()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;componentWillUpdate()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;componentDidUpdate()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;render()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그런데 이 이름이 조금 길고 camel case여서 개발자가 실수하는 경우가 왕왕 있습니다.&lt;/p&gt;

&lt;p&gt;아래 예를 보죠.&lt;/p&gt;

&lt;pre class=&quot;&quot; data-start=&quot;&quot; data-line=&quot;24&quot; data-line-offset=&quot;10&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;import { Component } from 'react';

class SyncReaderFollows extends Component {
    check() {
        if ( this.props.shouldSync ) {
            this.props.requestFollows();
        }
    }
 
    componentDidMount() {
        this.check();
    }
 
    componentDidUpate() {
        this.check();
    }
 
    render() {
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;&lt;a href=&quot;https://github.com/Automattic/wp-calypso/blob/7b44d03539f5519d0448aa071d714f53245f3804/client/components/data/sync-reader-follows/index.js&quot;&gt;sync-reader-follows/index.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;상태 변경 완료 후, 즉 &lt;code class=&quot;highlighter-rouge&quot;&gt;componentDidUpdate&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;check&lt;/code&gt; 함수의 호출을 의도했지만 실제로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;componentDidUpate&lt;/code&gt; 오타 때문에 원하는 대로 동작하지 않습니다.&lt;/p&gt;

&lt;h3 id=&quot;proptypes&quot;&gt;PropTypes&lt;/h3&gt;
&lt;p&gt;React의 PropTypes는 컴포넌트가 가진 속성들의 타입(필수 여부, 값의 형식 등)을 지정할 수 있게 합니다.&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'react'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;PropTypes&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'prop-types'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Item&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Component&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;propTypes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;PropTypes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isRequired&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;comment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;PropTypes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;propTypes&lt;/code&gt;라는 camel case로 정의하는데, 개발자들이 &lt;code class=&quot;highlighter-rouge&quot;&gt;PropTypes&lt;/code&gt;라고 그대로 사용하는 경우가 있습니다.&lt;/p&gt;

&lt;pre class=&quot;&quot; data-start=&quot;&quot; data-line=&quot;10&quot; data-line-offset=&quot;4&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;import React, { PureComponent, PropTypes } from 'react';
import { localize } from 'i18n-calypso';
import { truncateArticleContent } from '../helpers';

export class GooglePlusSharePreview extends PureComponent {
    static PropTypes = {
        articleUrl: PropTypes.string,
        externalProfilePicture: PropTypes.string,
        externalProfileUrl: PropTypes.string,
        externalName: PropTypes.string,
        imageUrl: PropTypes.string,
        message: PropTypes.string,
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;&lt;a href=&quot;https://github.com/Automattic/wp-calypso/blob/0f9275a3ceef14565f9cfb58918967186633092b/client/components/share/google-plus-share-preview/index.js&quot;&gt;google-plus-share-preview/index.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PropTypes&lt;/code&gt;라는 오타에 의해 &lt;code class=&quot;highlighter-rouge&quot;&gt;GooglePlusSharePreview&lt;/code&gt; 컴포넌트에 대한 PropTypes 검사가 동작하지 않게 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;deepscan-rule&quot;&gt;DeepScan Rule&lt;/h3&gt;

&lt;p&gt;DeepScan의 &lt;a href=&quot;https://deepscan.io/docs/rules/react-api-typo/&quot;&gt;REACT_API_TYPO&lt;/a&gt; 규칙은 이런 오타를 찾아 개발자의 실수를 방지할 수 있습니다.
또 단순한 오타 지적 외에 적절한 메소드 이름을 제안해 개발자가 쉽게 코드를 수정할 수 있습니다.&lt;/p&gt;
&lt;table class=&quot;table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;&quot;&gt;'componentDidUpate' could be a typo. Did you mean 'componentDidUpdate'?
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;err&quot;&gt;componentDidUpate() {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;&quot;&gt;'PropTypes' could be a typo. Did you mean 'propTypes' instead?
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;err&quot;&gt;static PropTypes = {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;render-함수에서-잘못된-값을-반환&quot;&gt;render 함수에서 잘못된 값을 반환&lt;/h2&gt;
&lt;p&gt;React의 &lt;code class=&quot;highlighter-rouge&quot;&gt;render&lt;/code&gt; 함수는 UI에 표시할 DOM tree(React element)를 반환합니다. 표시할 정보가 없으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt; 혹은 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;를 반환할 수 있고요.
이 외의 값을 반환할 경우 에러가 발생합니다.&lt;/p&gt;

&lt;pre class=&quot;&quot; data-start=&quot;&quot; data-line=&quot;76&quot; data-line-offset=&quot;70&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var React = require( 'react' );

module.exports = React.createClass( {
    render: function() {
        if ( ! this.props.site || ! this.props.plugin ) {
            return;
        }
        if ( this.props.site.canUpdateFiles &amp;amp;&amp;amp;
                ( ( this.props.site.plugin.update &amp;amp;&amp;amp; ! this.props.site.plugin.update.recentlyUpdated ) || this.isUpdating() ) ) {
            if ( ! this.props.expanded ) {
                /* eslint-disable wpcalypso/jsx-gridicon-size */
                return &lt;span classname=&quot;plugin-site-update-indicator&quot;&gt;&amp;lt;Gridicon icon=&quot;sync&quot; size={ 20 } /&amp;gt;&lt;/span&gt;;
                /* eslint-enable wpcalypso/jsx-gridicon-size */
            }
     
            return this.renderUpdate();
        }
        return null;
    }
} );
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;&lt;a href=&quot;https://github.com/Automattic/wp-calypso/blob/2c00bb4cb7310560f9111313b04143caed5079ed/client/my-sites/plugins/plugin-site-update-indicator/index.jsx&quot;&gt;plugin-site-update-indicator/index.jsx&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;개발자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;props&lt;/code&gt;를 체크해 값이 없으면 렌더링을 하지 않을 목적으로 바로 return하였을 것입니다. 하지만 React의 &lt;code class=&quot;highlighter-rouge&quot;&gt;render&lt;/code&gt; 함수는 React element, &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt; 그리고 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;만 반환할 수 있어서 위와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;가 반환되면 예외가 발생하고 렌더링 이후의 다른 lifecycle 메소드가 수행되지 않습니다.&lt;/p&gt;

&lt;p&gt;헷갈리기 쉬운 부분이죠?&lt;/p&gt;

&lt;h3 id=&quot;deepscan-rule-1&quot;&gt;DeepScan Rule&lt;/h3&gt;

&lt;p&gt;DeepScan의 &lt;a href=&quot;https://deepscan.io/docs/rules/bad-react-api-return-value/&quot;&gt;BAD_REACT_API_RETURN_VALUE&lt;/a&gt; 규칙은 &lt;code class=&quot;highlighter-rouge&quot;&gt;render&lt;/code&gt; 함수의 반환 값을 체크하고 적절한 반환 값에 대한 가이드를 제공해 개발자의 실수를 방지할 수 있습니다.&lt;/p&gt;

&lt;table class=&quot;table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;&quot;&gt;The 'render()' function of a React component returns an undefined value at this point. Consider returning false or null.
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;err&quot;&gt;return;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;이벤트-핸들러-함수를-잘못-지정한-경우&quot;&gt;이벤트 핸들러 함수를 잘못 지정한 경우&lt;/h2&gt;
&lt;p&gt;이벤트 핸들러로 함수 객체가 지정되어야 하는데 잘못된 값이 지정된 경우입니다.&lt;/p&gt;

&lt;pre class=&quot;&quot; data-start=&quot;&quot; data-line=&quot;133-135,155&quot; data-line-offset=&quot;129&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;import React, { Component } from 'react';

const EditUserForm = React.createClass( {
    recordFieldFocus( fieldId ) {
        analytics.ga.recordEvent( 'People', 'Focused on field on User Edit', 'Field', fieldId );
    },

    handleChange( event ) {
        this.setState( {
            [ event.target.name ]: event.target.value
        } );
    },

    renderField( fieldId ) {
        let returnField = null;
        switch ( fieldId ) {
            case 'roles':
                returnField = (
                    &amp;lt;RoleSelect
                        id=&quot;roles&quot;
                        name=&quot;roles&quot;
                        key=&quot;roles&quot;
                        siteId={ this.props.siteId }
                        value={ this.state.roles }
                        onChange={ this.handleChange }
                        onFocus={ this.recordFieldFocus( 'roles' ) }
                    /&amp;gt;
                );
                break;
        }
    }
} );
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;&lt;a href=&quot;https://github.com/Automattic/wp-calypso/blob/5a0ad4ef359b404eec128eec336e1f417acd297e/client/my-sites/people/edit-team-member-form/index.jsx&quot;&gt;edit-team-member-form/index.jsx&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onFocus&lt;/code&gt; 이벤트 핸들러에 함수를 지정해야 하는데 함수를 호출한 결과인 &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt; 값이 지정되고 있습니다. 그 결과 Google Analytics에서 해당 focus 이벤트에 대한 기록이 빠질 것입니다.&lt;/p&gt;

&lt;p&gt;이 경우는 다음과 같이 문제를 해결할 수 있습니다.&lt;/p&gt;

&lt;p&gt;ES5 &lt;code class=&quot;highlighter-rouge&quot;&gt;bind&lt;/code&gt; 함수:&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;onFocus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;recordFieldFocus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'roles'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ES6 arrow 함수:&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;onFocus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;recordFieldFocus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'roles'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;단, 위 방식은 렌더링할 때마다 새로운 함수를 생성하므로 성능 이슈가 있고, 생성자에서 한 번 바인딩하거나 별도 컴포넌트로 분리하는 것이 &lt;a href=&quot;https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-bind.md&quot;&gt;권장&lt;/a&gt;되고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;deepscan-rule-2&quot;&gt;DeepScan Rule&lt;/h3&gt;

&lt;p&gt;DeepScan의 &lt;a href=&quot;https://deepscan.io/docs/rules/missing-return-value/&quot;&gt;MISSING_RETURN_VALUE&lt;/a&gt; 규칙은 함수의 반환 값을 체크해 잘못된 이벤트 핸들러 지정을 방지할 수 있습니다.
이벤트 핸들러에 지정된 함수의 정의 위치도 메시지에서 알려주기 때문에 개발자는 문제 원인이 되는 함수를 바로 확인해 볼 수 있습니다.&lt;/p&gt;

&lt;table class=&quot;table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;&quot;&gt;No value is returned from function 'recordFieldFocus' defined at line 133.
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;err&quot;&gt;onFocus={ this.recordFieldFocus( 'roles' ) }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;dom-엘리먼트에서-잘못된-속성-지정&quot;&gt;DOM 엘리먼트에서 잘못된 속성 지정&lt;/h2&gt;
&lt;p&gt;React의 DOM 엘리먼트(element)에서 React 속성이 아닌 기존 DOM 속성을 사용하는 경우입니다.
React의 DOM 엘리먼트 속성은 &lt;a href=&quot;https://facebook.github.io/react/docs/dom-elements.html&quot;&gt;camel case&lt;/a&gt;이므로 기존 속성을 사용할 경우 동작하지 않을 수 있습니다.&lt;/p&gt;

&lt;p&gt;대표적인 예로 다음 두 가지를 들 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;React에서는 클래스 지정을 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;className&lt;/code&gt;을 사용해야 하는데 기존 DOM 속성인 &lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;를 사용한 경우&lt;/li&gt;
  &lt;li&gt;React의 클릭 이벤트 핸들러는 &lt;code class=&quot;highlighter-rouge&quot;&gt;onClick&lt;/code&gt;인데 &lt;code class=&quot;highlighter-rouge&quot;&gt;onclick&lt;/code&gt;으로 사용한 경우. 대소문자 구분이 없는 HTML에 익숙한 기존 프론트엔드 개발자에게 특히 혼동되기 쉬운 부분인 것 같습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre class=&quot;&quot; data-start=&quot;&quot; data-line=&quot;36,38&quot; data-line-offset=&quot;25&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;import React, { PropTypes } from 'react';

export default React.createClass( {
    getImportError: function() {
        return this.translate(
            '%(errorDescription)sTry again or contact support.', {
                args: {
                    errorDescription: this.props.description
                },
                components: {
                    a: &amp;lt;a href=&quot;#&quot; onclick={ this.retryImport }/&amp;gt;,
                    br: &amp;lt;br /&amp;gt;,
                    cs: &amp;lt;a href=&quot;#&quot; onclick={ this.contactSupport } /&amp;gt;
                }
            }
        );
    }
} );
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;&lt;a href=&quot;https://github.com/Automattic/wp-calypso/blob/c7b9c133e53c053ea0591a61957ecd46b1982bc3/client/my-sites/importer/error-pane.jsx&quot;&gt;importer/error-pane.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;위 코드에서는 클릭 이벤트가 실행되지 않습니다.&lt;/p&gt;

&lt;p&gt;오픈소스 &lt;a href=&quot;https://github.com/ptmt/react-native-macos&quot;&gt;react-native-macos&lt;/a&gt;에서도 &lt;code class=&quot;highlighter-rouge&quot;&gt;frameBorder&lt;/code&gt; 속성을 &lt;code class=&quot;highlighter-rouge&quot;&gt;frameborder&lt;/code&gt;로 사용하는 오류를 발견할 수 있네요.&lt;/p&gt;
&lt;pre class=&quot;&quot; data-start=&quot;&quot; data-line=&quot;808&quot; data-line-offset=&quot;797&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;var React = require('React');

var Modal = React.createClass({
  render: function() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;div className=&quot;modal&quot;&amp;gt;
          &amp;lt;div className=&quot;modal-content&quot;&amp;gt;
            &amp;lt;button className=&quot;modal-button-close&quot;&amp;gt;&amp;times;&amp;lt;/button&amp;gt;
            &amp;lt;div className=&quot;center&quot;&amp;gt;
              &amp;lt;iframe className=&quot;simulator&quot; src={url} width=&quot;256&quot; height=&quot;550&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
              &amp;lt;p&amp;gt;Powered by &amp;lt;a target=&quot;_blank&quot; href=&quot;https://appetize.io&quot;&amp;gt;appetize.io&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
            &amp;lt;/div&amp;gt;
          &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div className=&quot;modal-backdrop&quot; /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;&lt;a href=&quot;https://github.com/ptmt/react-native-macos/blob/5d32075363993191ba94605247992497f70aeb20/website/layout/AutodocsLayout.js&quot;&gt;layout/AutodocsLayout.js&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;deepscan-rule-3&quot;&gt;DeepScan Rule&lt;/h3&gt;

&lt;p&gt;DeepScan의 &lt;a href=&quot;https://deepscan.io/docs/rules/bad-unknown-prop/&quot;&gt;BAD_UNKNOWN_PROP&lt;/a&gt; 규칙은 DOM element의 속성 이름을 체크하고 적절한 속성 이름에 대한 가이드를 제공해 잘못된 속성이 지정되지 않도록 합니다.&lt;/p&gt;

&lt;table class=&quot;table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;&quot;&gt;'onclick' is not a valid prop for React DOM element. Did you mean 'onClick' event handler instead?
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;err&quot;&gt;a: &amp;lt;a href=&quot;#&quot; onclick={ this.retryImport }/&amp;gt;,
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;&quot;&gt;'frameborder' is not a valid prop for React DOM element. Did you mean 'frameBorder' DOM property instead?
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;err&quot;&gt;&amp;lt;iframe className=&quot;simulator&quot; src={url} width=&quot;256&quot; height=&quot;550&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap-Up&lt;/h2&gt;

&lt;p&gt;위에 제시된 코드들은 &lt;a href=&quot;https://deepscan.io/demo/&quot;&gt;데모 페이지&lt;/a&gt;에서 바로 붙여넣어 체크해 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;가볍고 단순하지만, 또 바로 익숙해지지는 않는 React!&lt;/p&gt;

&lt;p&gt;React 개발에 도움이 될 만한 내용을 앞으로도 계속 공유하겠습니다.&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://deepscan.io/docs/rules/#react&quot;&gt;https://deepscan.io/docs/rules/#react&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  
  <entry>
    <title>제품 매니저와 사업</title>
    <link href="/deepscan/2017/05/product-manager?utm_source=RSS&amp;utm_medium=RSS&amp;utm_campaign=/2017/05/product-manager"/>
    <updated>2017-05-25T08:00:00+00:00</updated>
    <id>/deepscan/2017/05/product-manager</id>
    <content type="html">&lt;blockquote class=&quot;preface&quot;&gt;
  &lt;p&gt;작년부터 개발자가 아닌 제품 매니저로서 사업화나 고객 개발 같은 일을 주로 하고 있습니다.&lt;/p&gt;

  &lt;p&gt;익숙하지 않은 일이다 보니 이런저런 책이나 글을 많이 읽으면서 담당 제품의 사업화에 적용해 보려고 노력 중인데요, 얼마 전 &lt;a href=&quot;https://deepscan.io&quot;&gt;DeepScan 서비스&lt;/a&gt;를 오픈하면서 &lt;a href=&quot;https://medium.com/@wonjoonchee/%EC%9A%B0%EB%A6%AC%EB%8A%94-%EB%A7%90-%EC%95%88%EC%9E%A5%EC%9D%84-%ED%8C%8C%EB%8A%94%EA%B2%8C-%EC%95%84%EB%8B%88%EB%8B%A4-slack-%EC%9D%98-ceo-%EA%B0%80-%ED%94%84%EB%A6%AC%EB%B7%B0-%EC%B6%9C%EC%8B%9C-2%EC%A3%BC%EC%A0%84-%EC%A7%81%EC%9B%90%EB%93%A4%EC%97%90%EA%B2%8C-%EC%93%B4-%EA%B8%80-809b64a3c&quot;&gt;Slack CEO의 글&lt;/a&gt;과 권도균 님의 &amp;lt;스타트업 경영 수업&amp;gt;, 자포스의 &amp;lt;딜리버링 해피니스&amp;gt; 등을 읽으며 나름 사업에 중요하다고 생각했던 것들을 정리해 팀원들에게 공유했습니다.&lt;/p&gt;

  &lt;p&gt;각자의 상황이 다르겠지만, 가치 있는 제품을 세상에 선보이기 위해 노력하는 분들과 공감하고자 블로그에도 옮겨 적습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;안녕하세요!&lt;br /&gt;
DeepScan 서비스가 곧 외부에 오픈됩니다.&lt;br /&gt;
마케팅도 하지 않는 미미한 알파 오픈이지만 그래도 우리 팀의 첫 오픈이기도 한 만큼 서비스와 사업 관련해서 얘기하고 싶었습니다.&lt;br /&gt;
각자의 일이 어떻게 우리 사업에 들어맞을지 이해하기를 바라기도 하고, 저도 왜 이 일을 하는지 정리하고 싶어서요.&lt;br /&gt;
조금 길지만, 끝까지 읽어 보시고 궁금한 점이 있으면 제게 와서 질문하세요!&lt;/p&gt;

&lt;h2 id=&quot;사업이란-무엇인가&quot;&gt;사업이란 무엇인가?&lt;/h2&gt;
&lt;p&gt;누군가 제게 묻더군요.&lt;br /&gt;
 “DeepScan은 어떻게 개발하게 된 건가요?”&lt;br /&gt;
 “아 그게 뭐 무려 KAIST에서 그 어려운 프로그래밍 언어를 전공한 사람들이 모여있다 보니 여차저차해서.. (뭘 그런 걸 물어봐) 어쨌건 우리 제품 기능이 말이에요…”&lt;/p&gt;

&lt;p&gt;그런데 나중에 곰곰 생각해 보니 이 스토리에는 우리가 가진 기술은 있는데 사용자는 없더라고요.&lt;br /&gt;
 GitHub(사무실 임대할 돈이 없어 자신들의 분산 작업을 위해 개발)나 Slack(게임 개발 중 자신들의 팀 협업을 위해 개발) 같이 우리가 불편해서 만들기 시작한 것도 아니고, 데이지(고객에게 인포그래픽을 만들어 주다가 시장 필요를 발견하고 시각화 솔루션을 개발)처럼 현장의 고객이 어떤 불편을 겪는 것을 보고 만들기 시작한 것도 아니니까요.&lt;/p&gt;

&lt;p&gt;이것을 스타트업 비즈니스에서는 제품-시장 궁합(product-market fit)이라고 하는데요, 제품의 가치(value proposition)와 고객의 필요와 문제점은 항상 짝을 이룬다는 것입니다. 그래서 ‘솔루션’인 것이죠, 고객의 ‘문제를 해결’하는.&lt;br /&gt;
 어쩌면 우리 DeepScan은 제품-시장 궁합이 맞는 즉 현실 세계의 구체적인 고객이 가진 구체적인 문제를 풀려고 했던 것이 아니고 우리 마음속의 버킷 리스트를 지우는 일은 아니었을까요?&lt;/p&gt;

&lt;p&gt;또 사업이란 뭔가 거창한 것이라고 생각되죠. 세계 최고의 엔진, 웹 사이트의 포괄적인 문제 해결, 아직 아무도 상용화에 성공하지 못한 근사한 ‘무엇’을 만드는 일.&lt;br /&gt;
 하지만 사실 사업은 지루하고 쫀쫀하며, 트렌디한 무엇을 하는 것이 아닌 현재의 일을 ‘어떻게’ 하느냐에 대한 것 같습니다. 좀 허접하더라도 자신의 문제 해결을 위해 남들보다 조금 더 나은 우리 제품을 기꺼이 사용할 사용자를 찾고, 현실의 첫 고객을 만족시키고, 첫 매출을 벌고 AWS 운영비를 충당하는.&lt;br /&gt;
 그런데 이게 저 거창한 일보다 더 어렵죠. 세상에 없던 것을 우리 생각대로 만드는 것이 아니라 현실 사용자의 문제를 진짜로 해결해 주고 만족시켜야 하는 일이니까요.&lt;/p&gt;

&lt;p&gt;결국 제가 생각하는 사업은 남들보다 조금이라도 더 낫게 고객의 문제를 해결해서 고객을 만족시키는 것, 그것입니다.&lt;/p&gt;

&lt;h2 id=&quot;작은-곳에-집중하기&quot;&gt;작은 곳에 집중하기&lt;/h2&gt;
&lt;p&gt;그렇다면 이제 우리의 사업은 무엇일까요? 우리는 누구의 문제를 남들보다 어떻게 더 잘 해결하고 있을까요?&lt;br /&gt;
 우리가 풀고자 하는 것은 JavaScript 코드의 품질 향상이라는 문제입니다. JavaScript를 많이 사용하는 개발자들, ESLint를 충실히 사용하는 개발자들, 전통적인 코드 품질 관리를 해 왔던 관리자들을 위해서요.&lt;br /&gt;
 코드의 품질 관리 영역은 이미 ESLint나 SonarQube가 존재하고 있어서 누구는 무료 툴만 있는 시장이라 하고, 누구는 이미 경쟁이 있는 시장이라 좋지 않다고 합니다. 하지만 Code Climate이 5년 이상 사업을 하고 있고, 500억 이상의 투자(SonarSource의 작년 투자 유치 금액)가 이뤄지는 시장이기도 합니다. 아 물론 이들은 JavaScript만 하지는 않지만.&lt;br /&gt;
 우리는 이 코드 품질 관리 시장에서 JavaScript 전문 코드 인스펙션 도구라는 우리의 터를 한 뼘이라도 잡고(조금 어려운 말로 ‘차별화를 통해 경쟁하지 않는 자신만의 시장을 가져라’라고 하더군요) 그 터를 넓히기 위해 노력해야 합니다. 우리 서비스를 이용하는 그 작은 곳에 있는 사람들에게 맞는 제품이면서, 까다로운 그들이 주변에 얘기할 만큼 좋아야죠. 그들이 만족하지 않으면 그다음의 터는 없을 테니까요.&lt;/p&gt;

&lt;p&gt;또, 얼핏 생각하면 코드 품질 외에 브라우저 호환성이나 보안 취약점을 추가로 지원해 주면 좋겠죠?&lt;br /&gt;
 하지만 전 좀 다르게 생각합니다. 저 부분을 추가한다고 우리가 집중하고 있는 기능에 더 경쟁력이 생기지도 않고, 실제로 보안 취약점 체크가 필요한 사용자는 보안 취약점 체크가 주력인 다른 제품을 쓸 것이거든요. JavaScript의 코드 품질이 주력이면 거기에 경쟁력 있는 제품이 되기 위해서만 집중해서 노력하면 됩니다. 고객은 자신의 문제를 해결하는 한 두 가지의 핵심 기능 때문에 그 서비스를 사용하니까요.&lt;br /&gt;
 ‘만 명이 좋아하는 서비스보다 백 명이 사랑하는 서비스’가 더 성장할 가능성이 있다고 하는 이유도 위와 같을 것입니다.&lt;/p&gt;

&lt;p&gt;여담이지만 제가 요즘 React 지원에 꽂혀 있는데, 많은 사람이 좋아할 일반적인 검증 규칙보다 React를 사용하는 작은(그러나 성장하고 있는) 그룹이 열광할 만한 구체적인 검증 규칙이 충성도 높은 사용자를 만들 거라고 생각하기 때문입니다. GitHub가 Rails 커뮤니티에서 성장했듯이 그 충성도 높은 고객으로부터 사업이 시작되고 주변 사용자가 끌어당겨 지면서 사업이 크는 거죠, 결국 사업은 고객 만족이니까요.&lt;/p&gt;

&lt;p&gt;아 누가 자꾸 우리 제품이 Fortify보다 좋냐고 물어본다고요? 앞으로는 이렇게 대답하세요, “DeepScan은 보안 취약점은 다루지 않습니다. 우리가 집중하는 영역은 JavaScript 코드의 품질 관리입니다”.&lt;/p&gt;

&lt;h2 id=&quot;사용자-관점에서-생각하고-실행하기&quot;&gt;사용자 관점에서 생각하고 실행하기&lt;/h2&gt;
&lt;p&gt;요즘 어디 가서 오픈하겠다고 하면 다들 걱정해 줍니다. 서버는 있는지, 동접은 어떻게 처리할 건지, 마케팅은 어떻게 할건지. 힘듭니다..&lt;br /&gt;
 마케팅. 필요하죠. 베타에서는 소셜 마케팅이든 언론 인터뷰든 하겠고요.&lt;/p&gt;

&lt;p&gt;그런데 이런 돈 들여서 하는 마케팅보다 더 중요한(더구나 모두가 할 수 있는) 시작점이 있는데 그것은 바로 현재 자신이 하고 있는 일에서 작게라도 하나씩 뭔가를 개선하는 것입니다.&lt;/p&gt;

&lt;p&gt;알파는 주변 지인한테 홍보하는 식으로 진행이 될 것인데,&lt;br /&gt;
 소규모의 사람이라도 서비스를 방문한다는 것이고 그들이 사용할 때 뭔가 걸리는 것이 없도록 계속 다듬어서 좋은 인상을 주는 것이 바로 마케팅이고 고객 서비스가 됩니다.&lt;/p&gt;

&lt;p&gt;분석기를 개발한다면 메시지가 어떻게 사용자에게 읽힐까, 개발자의 코드 품질 향상을 도와주기 위해 어떻게 말해줘야 할까를 생각해야 하고 사이트를 개발한다면 사용자가 매끄럽게 사용할 수 있는 방법을 계속 고민해서 적용하는 일이 그 예가 될 겁니다.&lt;br /&gt;
 뭔가 뒤에 있는 것으로 보이는 분석기라 해도 여러분이 지금 IDE에서 입력하는 바로 그 메시지가 사용자한테 보여지고, 그게 그냥 우리 서비스 자체입니다.&lt;/p&gt;

&lt;p&gt;지금 newrelic.com에 가서 로고에 대고 오른쪽 클릭을 해 보세요. ‘Just trying to be helpful.’ 전 참 사려 깊게 느껴지더라고요.&lt;br /&gt;
 고객 서비스가 admin@deepscan.io로 어떤 응대를 하는 것만이 아닌 여러분의 일상적인 개발이 포함되는 활동이라고 생각하면서,&lt;br /&gt;
 지금 하던 일을 더 깊이 들여다보고 작게라도 뭔가를 개선해서 그렇게 작은 변화들이 모이면 올해 말에는 더 향상된 서비스가 되어 있을 거라 믿습니다.&lt;/p&gt;

&lt;p&gt;그리고 한정된 자원을 가지고 있는 우리 같은 조직에서 조금 더 필요한 역량은 실행력과 속도인 것 같습니다.&lt;br /&gt;
 홈페이지에 틀린 단어를 발견했는데 며칠 동안 방치되거나 사용자 혹은 동료의 좋은 제안이 별다른 결과 없이 무시되는 것은 좋지 않겠죠. 분석기를 개발한다면 끝에 ‘.’이 빠진 메시지를 발견했을 때 누군가의 일감으로 일이 진행되길 기다리지 않고 바로 고치는 것. 사이트를 개발한다면 홈페이지의 틀린 단어를 바로 고치거나 알리는 것이 작은 예가 될 것 같네요, 아 쫀쫀해.&lt;/p&gt;

&lt;p&gt;다른 누군가의 과제를 수행하는 것이 아니라 전 세계를 대상으로 하는 우리 서비스이기 때문에 사용자로부터 좋은 피드백을 받아서 신나게 일하고, 사용자가 문제를 제기하면 스스로 못 참아서 개선하고, 아이디어는 말 대신 빠르게 프로토타이핑해서 그 결과로 동료들과 얘기할 수 있으면 좋겠습니다.&lt;/p&gt;

&lt;p&gt;그래서 집의 아이들에게 자랑스럽게 보여 줄 서비스가 되도록요. 참, 아이들이 사용하게는 하지 마세요. 우리 서비스 약관에 13세 이상만 사용할 수 있다고 되어 있으니까요!&lt;/p&gt;

&lt;h2 id=&quot;끈질기게-나아가기&quot;&gt;끈질기게 나아가기&lt;/h2&gt;
&lt;p&gt;알파이긴 하지만 어쨌건 외부에 오픈되는 것이니 뭔가 사업이 진행되는 것 같죠?&lt;/p&gt;

&lt;p&gt;하지만 목표에 도달하는 것은 생각보다 훨씬 더 오래 걸릴 거고 지금은 그냥 사업 준비에 불과하다고 생각합니다. 서버를 임대하고 서비스를 오픈하고 사용자를 모집하는 이런 과정들이 필요한 것이긴 하지만 정작 사업은 우리 서비스에 만족하는 한 명의 고객이 생기거나 목표로 하는 고객과 시장에 대해 우리가 몰랐던 새로운 사실을 알게 될 때가 진짜 시작일 것 같습니다.&lt;br /&gt;
 지금은 우리 존재를 소박하게 알리고 우리 서비스를 필요로 하는 문제를 가진 고객을 찾아가는 과정일 뿐이므로 사람이 안 모인다고 너무 낙담할 필요도 없이 시범 경기처럼 가볍게 하지만 진지하게 가죠.&lt;/p&gt;

&lt;p&gt;솔직히 내년에 이 사업이 어떻게 될지 알 수 없고 연말에 사업 평가도 있겠지만 올 한 해는 지치지 않고, 꾸준히, 동요 없이 일하시면 좋겠고요.&lt;br /&gt;
 팀의 비전, 사명 이런 것들이 어디 위키에 있을 수도 있는데 사실 팀의 비전이나 가치가 어디에 있는지는 그 팀이 어디에 인력과 시간을 집중하는지 보면 되죠. 그런 면에서 팀 인력이 적은 숫자도 아니고, 우리 팀이 진짜로 이 사업을 추구하려고 하는구나 생각하시면 되겠습니다.&lt;/p&gt;

&lt;p&gt;앞에서 얘기했지만 저는 처음에 사업이라는 게 뭔가 거창하게 느껴져서, 정기적으로 우리 제품이나 서비스에 대한 새로운 야망이나 더 큰 계획을 준비하고 빵빵 발표해야 한다고 생각한 적이 있었는데, 지금은 그냥 “작게 성공하자”고 생각하고 있습니다.&lt;br /&gt;
 소수의 고객이라도 만족시키고 가치를 인정받고 그렇게 작은 성공을 쌓아가면서 지속하다 보면 큰 기회를 얻을 수 있을 거라고요.&lt;/p&gt;

&lt;p&gt;한 걸음씩, 우리가 만들고 싶은 서비스를 향해.&lt;/p&gt;

&lt;h2 id=&quot;마무리&quot;&gt;마무리&lt;/h2&gt;
&lt;p&gt;이제 글을 마무리하려고 합니다.&lt;/p&gt;

&lt;p&gt;코드 품질 관리 사업자들이 여럿 있지만 비슷해 보여도 같은 사업은 없습니다. Code Climate은 다양한 언어의 linter 결과를 잘 관리해서 보여주는 브로커이고, bitHound는 npm 패키지의 취약점 체크로 사업을 하고 있죠.&lt;br /&gt;
DeepScan은 ‘최소한의 오탐율’로 ‘JavaScript 코드 에러와 오류 패턴을 검출’하는 데 특화된 서비스입니다.&lt;br /&gt;
차별화되어 있지만 반대로 참고할만한 성공 사례들이 별로 없고 따라서 서비스를 하면서 사용자의 반응과 요구를 알기 위해 노력하고 그를 바탕으로 개선할 필요가 있습니다.
또 사업 평가에서 회원 수나 프로젝트 수 등을 따지겠지만, 사실 이런 것이 목표는 아닙니다.&lt;br /&gt;
우리 사업의 목표(본질)는 JavaScript 개발자들이 맞춤법 검사기처럼 그냥 상시적으로 돌릴 만큼 JavaScript 코드 품질 향상에 도움을 주는 도구이자 서비스인 것이고, 회원 수는 그냥 그에 따른 결과이겠죠. 마케팅을 통해 일시적으로 ‘성장’할 수는 있겠지만, 이 ‘본질’이 추구되지 않으면 결국 의미가 없을 것입니다.&lt;/p&gt;

&lt;p&gt;그러므로 가치 있는 서비스를 세상에 선보이기 위해 집중해서 잘 해보자는 거였는데, 이런저런 생각들과 여기저기 읽은 글들이 얽혀 쓸데없이 길었습니다.&lt;/p&gt;

&lt;p&gt;고맙습니다.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>JavaScript 정적 분석 도구 DeepScan 소개</title>
    <link href="/deepscan/2017/03/deepscan?utm_source=RSS&amp;utm_medium=RSS&amp;utm_campaign=/2017/03/deepscan"/>
    <updated>2017-03-23T11:00:00+00:00</updated>
    <id>/deepscan/2017/03/deepscan</id>
    <content type="html">&lt;p&gt;JavaScript가 참 많이 사용됩니다. 단순한 웹 UI용 언어에서 지금은 서버 및 데스크톱 앱 개발을 망라하는 인기 있는 언어가 되었습니다. &lt;a href=&quot;https://octoverse.github.com/&quot;&gt;GitHub&lt;/a&gt;에 따르면 2016년 가장 많은 pull request가 있었던 언어라고 할 정도로요.&lt;/p&gt;

&lt;p&gt;하지만 JavaScript의 매력이기도 할 유연한 타입이나 동적 실행은 그 활용 범위와 관리할 코드 크기가 커지면서 오히려 뛰어난 코드 품질을 유지하는 데 방해가 되고 있습니다. TypeScript의 사용이 늘어나고 Flow 같은 타입 체커가 나오는 이유이겠죠.&lt;/p&gt;

&lt;p&gt;그렇다면, JavaScript에도 C나 Java의 Prevent 같이 개발자들이 코드 품질 유지에 도움을 주는 도구가 있다면 어떨까요? ESLint 같이 단순한 구문 체크가 아니라 프로그램의 실행 흐름을 이해하고 에러나 흔한 실수를 미리 잡아 줄 수 있다면 어떨까요?&lt;/p&gt;

&lt;p&gt;이런 생각에서 다음과 같은 JavaScript 코드 인스펙션 도구 DeepScan을 만들게 되었습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;JavaScript 정적 분석 기술에 기반해 프로그램의 실행 흐름을 이해한다.&lt;/li&gt;
  &lt;li&gt;개발자들이 진짜 에러에 집중할 수 있도록 노이즈(false alarm)가 적다.&lt;/li&gt;
  &lt;li&gt;에러와 코드 품질 관점의 유용한 규칙들을 제공한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그리고 얼마 전 DeepScan 기반의 GitHub 연동형 서비스 &lt;a href=&quot;https://deepscan.io&quot;&gt;deepscan.io&lt;/a&gt;를 시작하게 되었습니다.
GitHub 계정만 있으면 자신의 리파지토리를 분석할 수 있고, 바로 임의의 코드를 분석해 볼 수 있는 &lt;a href=&quot;https://deepscan.io/demo&quot;&gt;데모&lt;/a&gt;도 제공합니다.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/jyD8zzsdzmw&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href=&quot;https://deepscan.io&quot;&gt;방문&lt;/a&gt;해 보세요!&lt;/p&gt;

&lt;p&gt;아직 알파 서비스라 갈 길이 멀지만 JavaScript 개발자에게 유용한 도구가 될 것이라고 믿고 있습니다.
서비스에 대한 피드백이나 이런 규칙이 필요해 같은 아이디어 모두 환영합니다^^. 블로그 댓글이나 &lt;a href=&quot;mailto:support@deepscan.io&quot;&gt;support@deepscan.io&lt;/a&gt; 어디로든요!&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>JavaScript 정적 분석기로 살펴본 좋은 JavaScript 코딩</title>
    <link href="/deepscan/2016/11/good-coding-practices?utm_source=RSS&amp;utm_medium=RSS&amp;utm_campaign=/2016/11/good-coding-practices"/>
    <updated>2016-11-22T01:00:00+00:00</updated>
    <id>/deepscan/2016/11/good-coding-practices</id>
    <content type="html">&lt;p&gt;최근 발표된 GitHub의 &lt;a href=&quot;https://octoverse.github.com/&quot;&gt;2016년 통계&lt;/a&gt;에서도 알 수 있듯이 JavaScript는 가장 인기 있는 언어로서 웹 UI를 넘어 서버, 모바일, 데스크톱, IoT 등 다양한 영역으로 확대되고 있습니다.&lt;/p&gt;

&lt;p&gt;하지만 JavaScript는 그 언어적인 특성으로 인해 개발을 진행할수록 유지보수가 어렵고 코드 품질이 저하될 가능성이 크기 때문에 개발 생산성과 코드 품질 향상에 도움을 줄 도구가 필요하다고 생각합니다.&lt;/p&gt;

&lt;p&gt;이에 JavaScript 정적 분석 기술을 통해 코드를 실행하지 않고도 잠재적인 오류 가능성이 있는 부분을 찾는 분석기를 개발하면서 ECMAScript의 예외와 개발자들이 자주 실수하는 패턴들(pitfalls)로부터 분석기의 규칙(분석기가 찾아낼 오류 패턴)을 발굴하고 웹 사이트와 GitHub의 오픈 소스를 대상으로 분석해 보고 있습니다.&lt;/p&gt;

&lt;p&gt;얼마 전 해당 오류 패턴과 정적 분석기 도입 고려 사항에 대해 발표했던 자료가 있는데, 좋은 JavaScript 코드 작성을 위해 도움이 될 만한 내용이라고 생각되어 공유합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://swipe.to/&quot;&gt;Swipe&lt;/a&gt;로 작성된 웹 슬라이드이므로 PC나 모바일에서 아래 링크를 클릭하세요:&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://swipe.to/1599c&quot; class=&quot;btn&quot;&gt;Go to slide&lt;/a&gt;&lt;/div&gt;
</content>
  </entry>
  
  <entry>
    <title>JavaScript에서 함수 사용 시 주의할 점</title>
    <link href="/deepscan/2016/10/function-misuse?utm_source=RSS&amp;utm_medium=RSS&amp;utm_campaign=/2016/10/function-misuse"/>
    <updated>2016-10-01T07:00:00+00:00</updated>
    <id>/deepscan/2016/10/function-misuse</id>
    <content type="html">&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#중복-정의&quot; id=&quot;markdown-toc-중복-정의&quot;&gt;중복 정의&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#호출-인자-누락&quot; id=&quot;markdown-toc-호출-인자-누락&quot;&gt;호출 인자 누락&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#호출-인자의-속성-누락&quot; id=&quot;markdown-toc-호출-인자의-속성-누락&quot;&gt;호출 인자의 속성 누락&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#api-호출-시-인자-타입-오류&quot; id=&quot;markdown-toc-api-호출-시-인자-타입-오류&quot;&gt;API 호출 시 인자 타입 오류&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#api-호출-시-인자-개수-오류&quot; id=&quot;markdown-toc-api-호출-시-인자-개수-오류&quot;&gt;API 호출 시 인자 개수 오류&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#wrap-up&quot; id=&quot;markdown-toc-wrap-up&quot;&gt;Wrap-Up&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;오늘은 JavaScript에서 함수 사용 시 주의할 부분에 대해 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;JavaScript는 동적 타입이면서 함수로의 인자 전달이 유연하기 때문에 사용에 주의가 요구됩니다.&lt;/p&gt;

&lt;h2 id=&quot;중복-정의&quot;&gt;중복 정의&lt;/h2&gt;

&lt;p&gt;Java에서는 함수를 중복 정의하면 에러가 발생합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/deepscan/assets/images/duplicate-method-in-java.png&quot; alt=&quot;Duplicate method in Java&quot; /&gt;&lt;/p&gt;

&lt;p&gt;하지만 JavaScript에서는 함수를 중복으로 정의해도 에러가 발생하지 않고 대신 마지막 함수만 유효하게 사용됩니다.
이에 대한 사례는 &lt;a href=&quot;/deepscan/2016/07/unused-codes-1&quot;&gt;사용되지 않는 코드&lt;/a&gt;를 참고하세요.&lt;/p&gt;

&lt;h2 id=&quot;호출-인자-누락&quot;&gt;호출 인자 누락&lt;/h2&gt;

&lt;p&gt;호출자(caller)가 함수에 인자를 전달하지 않았는데 함수 내에서 해당 인자를 사용하는 경우입니다.&lt;/p&gt;

&lt;p&gt;다음의 예를 보죠.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;checkDateFormat&lt;/code&gt; 함수를 두 개의 인자 &lt;code class=&quot;highlighter-rouge&quot;&gt;date&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;datePattern&lt;/code&gt;으로 호출합니다.&lt;/p&gt;

    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setCondition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;rowId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;date&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getCellEditingValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;input&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;rowId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;startDate&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$tr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;checkDateFormat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;datePattern&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;date is not vaild.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;호출된 &lt;code class=&quot;highlighter-rouge&quot;&gt;checkDateFormat&lt;/code&gt; 함수에서는 위에서 전달되지 않은 &lt;code class=&quot;highlighter-rouge&quot;&gt;dateName&lt;/code&gt; 인자를 사용합니다.&lt;/p&gt;

    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;checkDateFormat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;dt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dateFormat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dateName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isValid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ValidatorFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getDateFormatValidator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;dateFormat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isValid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;dt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dateName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;' : 일자 형식이 잘못되었습니다.'&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그 결과 undefined 값과 문자열이 결합하여 유효하지 않은 문자열이 사용자에게 노출되므로 해당 인자에 대한 처리(null 체크나 기본값 설정)가 필요합니다.&lt;/p&gt;

&lt;h2 id=&quot;호출-인자의-속성-누락&quot;&gt;호출 인자의 속성 누락&lt;/h2&gt;

&lt;p&gt;호출자가 함수에 전달한 인자에 없는 속성을 함수 내에서 사용하는 경우입니다.&lt;/p&gt;

&lt;p&gt;다음의 예를 보죠.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fn_detailPopup&lt;/code&gt; 함수를 호출하는 두 개의 실행 경로 1)과 2)가 있습니다. 1)의 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;argsVo.statusCodeId&lt;/code&gt;가 설정되지 않은 채로 호출합니다.&lt;/p&gt;

    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;colName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;indexOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testSeverity&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;argsVo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;flag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;SEVERITY&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;argsVo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;severityCodeId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;colName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testSeverity&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;fn_detailPopup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;argsVo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;colName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;indexOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;statusCodeId&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;argsVo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;flag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;STATUS&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;argsVo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;statusCodeId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;colName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;statusCodeId&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;fn_detailPopup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;argsVo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;호출된 &lt;code class=&quot;highlighter-rouge&quot;&gt;fn_detailPopup&lt;/code&gt; 함수에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;argvVo&lt;/code&gt; 인자의 설정되지 않은 &lt;code class=&quot;highlighter-rouge&quot;&gt;statusCodeId&lt;/code&gt; 속성을 사용합니다.&lt;/p&gt;

    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fn_detailPopup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;argsVo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&amp;amp;severityCode='&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;argsVo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;severityCodeId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&amp;amp;statusCodeId='&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;argsVo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;statusCodeId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그 결과 &lt;code class=&quot;highlighter-rouge&quot;&gt;statusCodeId&lt;/code&gt; 파라미터가 “undefined”라는 문자열로 서버에 전달되므로 서버에서 이에 대한 처리가 필요할 수 있습니다.
따라서 클라이언트 측에서 해당 속성 존재 여부를 서버 전달 전에 명확하게 체크하는 것이 좋습니다.&lt;/p&gt;

&lt;h2 id=&quot;api-호출-시-인자-타입-오류&quot;&gt;API 호출 시 인자 타입 오류&lt;/h2&gt;

&lt;p&gt;JavaScript built-in 함수나 DOM API 함수는 정해진 타입의 인자가 있어서 잘못된 타입의 인자로 호출하는 경우 TypeError가 발생합니다.&lt;/p&gt;

&lt;p&gt;가령 아래 코드 실행 시 &lt;code class=&quot;highlighter-rouge&quot;&gt;TypeError: Argument 1 of Node.appendChild is not an object.&lt;/code&gt; 에러가 발생합니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'foo'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;제가 개발 중인 솔루션에서는 built-in 함수와 DOM API 함수 모델링을 통해 인자 타입 정보를 내장하여 &lt;strong&gt;실행 전에 소스 레벨에서&lt;/strong&gt; 아래와 같이 검출할 수 있습니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;first argument type of Node.prototype.appendChild() API must be Node DOM instance object.&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;api-호출-시-인자-개수-오류&quot;&gt;API 호출 시 인자 개수 오류&lt;/h2&gt;

&lt;p&gt;JavaScript built-in 함수나 DOM API 함수는 잘못된 개수의 인자로 호출하는 경우 TypeError가 발생할 수 있습니다.&lt;/p&gt;

&lt;p&gt;가령 아래 코드 실행 시 &lt;code class=&quot;highlighter-rouge&quot;&gt;TypeError: Not enough arguments to Document.getElementById.&lt;/code&gt; 에러가 발생합니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;개발 중인 솔루션에서는 built-in 함수와 DOM API 함수 모델링을 통해 아래와 같이 검출됩니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;number of arguments of Document.prototype.getElementById() API must be 1&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap-Up&lt;/h2&gt;

&lt;p&gt;이상 JavaScript 함수 사용에 대해 알아보았습니다.&lt;/p&gt;

&lt;p&gt;다른 언어와 다른 JavaScript 특성을 이해하고 함수 사용에 주의하세요.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;JavaScript는 함수 오버로딩을 지원하지 않으므로 함수 정의를 중복하지 않도록 한다.&lt;/li&gt;
  &lt;li&gt;다양한 실행 경로에서 인자 및 인자 속성 정의가 잘 전달되는지 점검한다. 필요한 경우 함수 내에서 인자 및 속성에 대한 유효성 검사를 하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  
  <entry>
    <title>JavaScript 코드 리뷰 - 코드 리뷰 사례로 알아보는 좋은 JavaScript 코드</title>
    <link href="/deepscan/2016/09/code-review-2?utm_source=RSS&amp;utm_medium=RSS&amp;utm_campaign=/2016/09/code-review-2"/>
    <updated>2016-09-01T10:00:00+00:00</updated>
    <id>/deepscan/2016/09/code-review-2</id>
    <content type="html">&lt;p&gt;오늘은 &lt;a href=&quot;/deepscan/2016/08/code-review-1&quot;&gt;코드 리뷰 문화&lt;/a&gt;에 이어 실제로 코드 리뷰를 하면서 개선된 코드 사례를 몇 가지 공유합니다.&lt;/p&gt;

&lt;p&gt;라이브러리의 활용, 좋은 코드를 위한 리팩토링과 같이 작지만 유용하다고 생각했던 사례들을 코드 및 실제 코멘트와 함께 정리해 보도록 하겠습니다.&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#라이브러리의-활용&quot; id=&quot;markdown-toc-라이브러리의-활용&quot;&gt;라이브러리의 활용&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#underscore&quot; id=&quot;markdown-toc-underscore&quot;&gt;Underscore&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#urijs&quot; id=&quot;markdown-toc-urijs&quot;&gt;URI.js&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#promise&quot; id=&quot;markdown-toc-promise&quot;&gt;Promise&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#return과-throw의-사용&quot; id=&quot;markdown-toc-return과-throw의-사용&quot;&gt;return과 throw의 사용&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#reject-처리&quot; id=&quot;markdown-toc-reject-처리&quot;&gt;reject 처리&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#promisify-및-bind&quot; id=&quot;markdown-toc-promisify-및-bind&quot;&gt;Promisify 및 bind&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#all&quot; id=&quot;markdown-toc-all&quot;&gt;all&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#문서화&quot; id=&quot;markdown-toc-문서화&quot;&gt;문서화&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#javascript-일반&quot; id=&quot;markdown-toc-javascript-일반&quot;&gt;JavaScript 일반&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#이벤트-처리&quot; id=&quot;markdown-toc-이벤트-처리&quot;&gt;이벤트 처리&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#배열의-join&quot; id=&quot;markdown-toc-배열의-join&quot;&gt;배열의 join&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#jsonparse-에러-처리&quot; id=&quot;markdown-toc-jsonparse-에러-처리&quot;&gt;JSON.parse 에러 처리&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ux&quot; id=&quot;markdown-toc-ux&quot;&gt;UX&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#linter-적용&quot; id=&quot;markdown-toc-linter-적용&quot;&gt;linter 적용&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#읽기-쉬운-코드&quot; id=&quot;markdown-toc-읽기-쉬운-코드&quot;&gt;읽기 쉬운 코드&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#작은-함수&quot; id=&quot;markdown-toc-작은-함수&quot;&gt;작은 함수&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#커밋-메시지&quot; id=&quot;markdown-toc-커밋-메시지&quot;&gt;커밋 메시지&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#wrap-up&quot; id=&quot;markdown-toc-wrap-up&quot;&gt;Wrap-Up&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#references&quot; id=&quot;markdown-toc-references&quot;&gt;References&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;라이브러리의-활용&quot;&gt;라이브러리의 활용&lt;/h2&gt;

&lt;h3 id=&quot;underscore&quot;&gt;Underscore&lt;/h3&gt;

&lt;p&gt;Underscore나 Lodash 같은 라이브러리를 잘 활용하면 같은 기능을 더 간결한 코드로 구현할 수 있습니다.
팀에서 “Underscore 라이브러리를 잘 쓰면 점수(score)를 받을 수 있다”는 우스갯소리를 한 적도 있을 정도로요.&lt;/p&gt;

&lt;p&gt;Underscore나 Lodash는 객체나 컬렉션을 다룰 때 유용하니 &lt;a href=&quot;https://lodash.com/docs&quot;&gt;API 레퍼런스&lt;/a&gt;를 참고해서 잘 활용하면 좋습니다. 특히 컬렉션을 loop 할 일이 많은 경우 &lt;a href=&quot;http://joelhooks.com/blog/2014/02/06/stop-writing-for-loops-start-using-underscorejs/&quot;&gt;_.forIn, _.map 등을 적절히 사용&lt;/a&gt;하면 좋겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;pluck&quot;&gt;pluck&lt;/h4&gt;

&lt;p&gt;아래와 같은 json 데이터로부터 “mobile”과 “wearable”이 포함된 배열을 반환하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;getProfiles&lt;/code&gt; 함수의 리뷰를 보죠.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;mobile-2.4.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;s2&quot;&gt;&quot;profile&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;mobile&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;mobile-2.3.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;s2&quot;&gt;&quot;profile&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;mobile&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;wearable-2.3.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;s2&quot;&gt;&quot;profile&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;wearable&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;wearable-2.3.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;s2&quot;&gt;&quot;profile&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;wearable&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;JavaScript 객체를 순환하면서 ‘profile’ 키의 값을 얻어야 하고, 배열 중 중복되는 값은 제외해야 하죠.
이렇게 구현한 최초 코드가 왼쪽이고 해당 커밋에 달린 리뷰 코멘트입니다. (“Done”은 요청자가 리뷰에 따라 수정을 완료했을 경우 올리는 코멘트)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://lodash.com/docs#map&quot;&gt;pluck&lt;/a&gt;&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;은 지정된 속성의 값만 쏙 뽑아주므로 리뷰대로 수정하면 원하는 기능이 단 한 줄로 구현됩니다.&lt;/p&gt;

&lt;table class=&quot;compare&quot;&gt;
&lt;tr&gt;&lt;td&gt;
&lt;pre class=&quot;line-numbers&quot; data-line=&quot;3-7&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function getProfiles() {
    return getPlatforms().then(function (platforms) {
        var profiles = _.reduce(platforms, function (result, platform) {
            result.push(platform.profile);
            return result;
        }, []);
        return _.uniq(profiles);
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;return _.uniq(_.pluck(platforms, ‘profile’));&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class=&quot;quotes&quot;&gt;
  &lt;p&gt;Done&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/td&gt;&lt;td&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function getProfiles() {
    return getPlatforms().then(function (platforms) {
        return _.uniq(_.pluck(platforms, 'profile'));
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;h4 id=&quot;last&quot;&gt;last&lt;/h4&gt;

&lt;p&gt;배열의 마지막 요소를 얻을 때 사용할 수 있습니다.&lt;/p&gt;

&lt;table class=&quot;compare&quot;&gt;
&lt;tr&gt;&lt;td&gt;
&lt;pre class=&quot;line-numbers&quot; data-line=&quot;2,9&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function getLastAnalysis(project) {
    if (project &amp;amp;&amp;amp; project.analyses &amp;amp;&amp;amp; project.analyses.length &amp;gt;= 0) {
        return project.analyses[project.analyses.length - 1];
    }

    return null;
}

var lastAnalysis = getLastAnalysis(this.content);
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;[-1]인 경우가 생길 것 같은데요?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;_.last(this.content)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/td&gt;&lt;td&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var lastAnalysis, project = this.content;
if (project &amp;amp;&amp;amp; project.analyses) {
    lastAnalysis = _.last(project.analyses);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;단순한 로직이지만 경계값 체크를 놓치기 쉽죠. 소위 ‘바퀴를 재발명’하지 말고 검증된 라이브러리를 활용하는 것이 코드의 간결성과 예외 처리에 도움이 됩니다.
참고로 &lt;a href=&quot;https://lodash.com/docs#last&quot;&gt;last&lt;/a&gt;의 코드는 아래와 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;some&quot;&gt;some&lt;/h4&gt;

&lt;p&gt;배열에서 특정 요소의 존재 여부를 파악할 때 유용한 &lt;a href=&quot;https://lodash.com/docs#some&quot;&gt;some&lt;/a&gt;입니다.&lt;/p&gt;

&lt;p&gt;아래는 배열에 어떤 값이 존재하지 않을 때만 배열에 추가하는 코드인데, 보통 많이 하는 loop을 통한 존재 여부 체크 없이도 배열의 각 요소를 인자로 받아 true/false를 반환하는 함수(predicate)만 넘겨 줌으로써 더 간결하게 구현됩니다.&lt;/p&gt;

&lt;table class=&quot;compare&quot;&gt;
&lt;tr&gt;&lt;td&gt;
&lt;pre class=&quot;line-numbers&quot; data-line=&quot;2-11&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;addModel: function (modelName, model) {
    var exist = false;

    for (i = 0, length = cModels.length; i &amp;lt; length; i++) {
        cModel = cModels[i];

        if (cModel.isEqual(model)) {
            exist = true;
            break;
        }
    }

    if (!exist) {
        cModels.push(model);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;td&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;addModel: function (modelName, model) {
    var exist = _.some(cModels, model.isEqual.bind(model));

    if (!exist) {
        cModels.push(model);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;아래와 같이 하면 더 깔끔하겠네요
&lt;pre&gt;
var exist = _.some(cModels, model.isEqual.bind(model));
&lt;/pre&gt;
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;h4 id=&quot;debounce&quot;&gt;debounce&lt;/h4&gt;

&lt;p&gt;비용이 많이 드는 함수(서버 요청, 느린 I/O 등)의 빈번한 호출은 &lt;a href=&quot;https://lodash.com/docs#debounce&quot;&gt;debounce&lt;/a&gt;를 통해 호출을 제한시킬 수 있는지 검토할 필요가 있습니다.&lt;/p&gt;

&lt;p&gt;입력 값에 따라 서버 파일을 검색하는 기능의 구현을 보죠.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/deepscan/assets/images/code-review-18.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아래 코드의 &lt;code class=&quot;highlighter-rouge&quot;&gt;search&lt;/code&gt; 함수가 서버의 파일 목록을 요청하는데 REST API를 통한 네트워크 요청이면서 서버 I/O가 필요하므로 꽤 무겁습니다. 이를 오른쪽과 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;debounce&lt;/code&gt;를 적용해 수정하면 사용자 키 입력마다 매번 호출되지 않고 0.3초 동안에는 한 번만(마지막 함수 호출만) 호출되므로 보다 효율적입니다.&lt;/p&gt;

&lt;table class=&quot;compare&quot;&gt;
&lt;tr&gt;&lt;td&gt;
&lt;pre class=&quot;line-numbers&quot; data-line=&quot;2&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;this.$input.on('keyup', function (e) {
    search();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;td&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// to avoid costly search call for each user input
var searchDebounced = _.debounce(search, 300);

this.$input.on('keyup', function (e) {
    searchDebounced();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;입력할 때마다 search api가 너무 많이 불릴 수 있을 것 같네요. debounce를 쓰면 좋겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class=&quot;quotes&quot;&gt;
  &lt;p&gt;debounce 적용했습니다. 좋은 함수네요^^&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;urijs&quot;&gt;URI.js&lt;/h3&gt;

&lt;p&gt;URL을 다룰 때는 &lt;a href=&quot;https://medialize.github.io/URI.js/&quot;&gt;URI.js&lt;/a&gt; 모듈을 사용합니다.
프로토콜, 호스트, 경로 정보를 쉽게 얻을 수 있고 파싱 같이 URL 처리에 필요한 기능들이 모두 제공되므로 URI.js 객체를 생성하고 이를 이용하는 것이 좋습니다.&lt;/p&gt;

&lt;table class=&quot;compare&quot;&gt;
&lt;tr&gt;&lt;td&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var protocol = 'http://';
var hostName = app.getHost();
if (hostName.startsWith('fs')) {
    hostName = hostName.split('.');
    hostName.shift();
    hostName = hostName.join('.');
}

this.definitionUrl = protocol + hostName + '/sample-type-info.json';
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;td&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function getSampleServerAddress() {
    var uriObj = URI(conf.appServer);
    uriObj.pathname('sample-type-info.json');

    return uriObj.toString();
}

this.definitionUrl = getSampleServerAddress();
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;
함수로 빼서 로직에 이름을 주세요. 그리고 url을 다룰 때는 항상 URIjs 모듈을 이용하세요.&lt;br /&gt;
protocol도 하드코딩 되어서는 안 됩니다.
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;h2 id=&quot;promise&quot;&gt;Promise&lt;/h2&gt;

&lt;p&gt;Promise를 활용하면 비동기 프로그래밍에서의 어지러운 콜백 흐름을 동기 프로그래밍처럼 간결하게 표현할 수 있습니다.
최신 브라우저에서 대부분 지원되기도 하지만, &lt;a href=&quot;http://bluebirdjs.com/docs/getting-started.html&quot;&gt;bluebird&lt;/a&gt; 라이브러리를 통해서도 바로 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;Promise 사용이 익숙지 않아 자주 리뷰된 내용 위주로 정리해 봅니다.&lt;/p&gt;

&lt;h3 id=&quot;return과-throw의-사용&quot;&gt;return과 throw의 사용&lt;/h3&gt;

&lt;p&gt;Promise의 장점은 비동기 프로그래밍을 개발자들에게 익숙한 동기 프로그래밍처럼 할 수 있게 해 주는 것이라고 생각합니다.
기존의 비동기 콜백을 정상적인 return과 에러 상황에서의 throw로 쓸 수 있다는 것이죠.&lt;/p&gt;

&lt;p&gt;Promise에서 어떤 값을 반환하거나 예외를 던지면 그렇게 resolved 혹은 rejected 되므로 굳이 &lt;code class=&quot;highlighter-rouge&quot;&gt;Promise.reject&lt;/code&gt;를 사용할 이유가 없습니다.&lt;/p&gt;

&lt;table class=&quot;compare&quot;&gt;
&lt;tr&gt;&lt;td&gt;
&lt;pre class=&quot;line-numbers&quot; data-line=&quot;5&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;return dbProject.$saveAsync(data)
    .then(function (context) {
        return ...;
    }).catch(function (error) {
        return Promise.reject(new Error(error));
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;td&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;return dbProject.$saveAsync(data)
    .then(function (context) {
        return ...;
    }).catch(function (error) {
        throw new Error(error);
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;return Promise.reject() 보다 throw 직접 사용&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;table class=&quot;compare&quot;&gt;
&lt;tr&gt;&lt;td&gt;
&lt;pre class=&quot;line-numbers&quot; data-line=&quot;2-5&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;return new Promise(function (resolve, reject) {
    if (widgetElement.nodeName.toLowerCase() !== TAG_NAME.WIDGET) {
        errorInfos.push(ERROR_MESSSAGE.WRONG_ROOT);
        return reject(errorInfos);
    }

    if (profileElements.length &amp;lt; 1) {
        errorInfos.push(ERROR_MESSSAGE.NOT_EXIST_PROFILE);
        return reject(errorInfos);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;td&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function checkWrongRootNode(node) {
    if (node.nodeName.toLowerCase() !== TAG_NAME.WIDGET) {
        errorInfos.push(ERROR_MESSSAGE.WRONG_ROOT);
        throw errorInfos;
    }
}

return new Promise(function (resolve, reject) {
    checkWrongRootNode(widgetElement);
    checkWrongProfileNode(widgetElement);
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;reject를 쓰지 않고 throw를 쓰고 promise 함수 바깥으로 빼면 아래와 같이 promise 함수를 작게 만들 수 있겠습니다.
&lt;pre&gt;
return new Promise(function (resolve, reject) {
  checkXX1();
  checkXX2();
  ...
&lt;/pre&gt;
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;마찬가지로 then에 주는 함수가 그냥 값을 반환하면 그 값으로 resolve 되는 Promise가 만들어집니다.&lt;/p&gt;

&lt;table class=&quot;compare&quot;&gt;
&lt;tr&gt;&lt;td&gt;
&lt;pre class=&quot;line-numbers&quot; data-line=&quot;2-5&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function getDevicePath(result) {
    return new Promise(function (resolve) {
        result.devicePath = ...;
        resolve(result);
    });
}

return packageCommands.packageProject(path)
                      .then(getDevicePath)
                      .catch(handlePackageError);
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;td&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function getDevicePath(result) {
    result.devicePath = ...;
    return result;
}

return packageCommands.packageProject(path)
                      .then(getDevicePath)
                      .catch(handlePackageError);
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;onFulfilled에서 promise를 만들어서 리턴해도 되지만 그냥 값을 리턴하면 그 값으로 resolve 된 promise가 만들어집니다. 따라서 아래와 같이 쓰면 됩니다.
&lt;pre&gt;
  function getDP(result) {
    ...
    return result;
  }
&lt;/pre&gt;
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class=&quot;quotes&quot;&gt;
  &lt;p&gt;회의 때 들은 내용인데 막상 Promise를 쓰려니 잘 적용이 안 되네요, then의 첫 번째 파라미터는 그냥 값을 리턴하는 함수여도 chaining이 되는 거군요. 처리했습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;table class=&quot;compare&quot;&gt;
&lt;tr&gt;&lt;td&gt;
&lt;pre class=&quot;line-numbers&quot; data-line=&quot;2-18&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;Validator.validate = function (profile) {
    return new Promise(function (resolve) {
        Platform.getPlatforms()
                .then(function (platforms) {
                    var matched = _.filter(platforms, function (p) {
                        return p.getProfile() === profile;
                    });

                    if (matched.length &amp;gt; 0) {
                        resolve(true);
                    } else {
                        resolve(false);
                    }
                })
                .catch(function (err) {
                    resolve(false);
                });
    });
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;td&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;Validator.validate = function (profile) {
    return Platform.getPlatforms()
                   .then(function (platforms) {
                       var matched = _.filter(platforms, function (p) {
                           return p.getProfile() === profile;
                       });

                       if (matched.length &amp;gt; 0) {
                           return true;
                       } else {
                           return false;
                       }
                    });
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;굳이 new Promise를 할 필요가 없습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;reject-처리&quot;&gt;reject 처리&lt;/h3&gt;

&lt;p&gt;Promise나 Deferred를 사용할 때 성공 콜백만 정의할 경우 문제가 발생할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getViableItems&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;menuItems&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;deferred&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Deferred&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;updateViableItems&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isWebProject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;menuItems&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...;&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;deferred&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;menuItems&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isWebProject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;projectPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;updateViableItems&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;deferred&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 dojo의 Deferred 객체를 사용하는데, reject 상황에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;menuItems&lt;/code&gt; 배열이 반환되지 않아 메뉴 표시에 문제가 있었습니다.
Promise라면 finally를 써야 할 상황이고, Deferred에서는 실패 콜백을 항상 같이 쓰거나 then 다음에 또 then을 써서 최종 반환 값이 유실되지 않도록 할 필요가 있겠습니다.&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getViableItems&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;menuItems&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;deferred&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Deferred&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;updateViableItems&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isWebProject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;menuItems&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...;&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;deferred&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;menuItems&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isWebProject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;projectPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;updateViableItems&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;c1&quot;&gt;// Should return items although in case of reject (invalid configuration, etc.)&lt;/span&gt;
              &lt;span class=&quot;nx&quot;&gt;deferred&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;itemsForProject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;deferred&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;promisify-및-bind&quot;&gt;Promisify 및 bind&lt;/h3&gt;

&lt;p&gt;기존의 콜백을 Promise로 변환하기 위한 new Promise() 코드는 대부분 필요 없습니다.
bluebird 등의 라이브러리를 사용하면 promisify()를 이용해 쉽게 변환되기 때문입니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 아래와 같은 콜백 함수가 이미 있다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Promise.promisify(fs.getQuotaLimit)&lt;/code&gt; 같이 Promise로 변환해서 사용할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;FileSystem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getQuotaLimit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;restApi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;ajaxCall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;conf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fsApiBaseUrl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'/limit/'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fsid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ensureAuthorize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;restApi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만, 이 경우 bind를 고려해야 합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;self.fsid&lt;/code&gt;(즉 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; 객체의 &lt;code class=&quot;highlighter-rouge&quot;&gt;fsid&lt;/code&gt;)를 사용하는 위 코드를 그냥 promisify 하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;가 호출자가 되므로 정상적으로 동작하지 않습니다. 따라서 오른쪽 코드와 같이 적절한 객체로 bind 해서 promisify 해야 합니다.&lt;/p&gt;

&lt;table class=&quot;compare&quot;&gt;
&lt;tr&gt;&lt;td&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var getQuotaLimit = Promise.promisify(fs.getQuotaLimit);
getQuotaLimit().then(function (limit) {
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;td&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var getQuotaLimit = Promise.promisify(fs.getQuotaLimit.bind(fs));
getQuotaLimit().then(function (limit) {
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;all&quot;&gt;all&lt;/h3&gt;

&lt;p&gt;순서대로 실행할 필요가 없는 일은 &lt;a href=&quot;http://bluebirdjs.com/docs/api/promise.all.html&quot;&gt;all&lt;/a&gt;을 통해 병렬 수행하면 성능 향상이 있을 수 있습니다.&lt;/p&gt;

&lt;table class=&quot;compare&quot;&gt;
&lt;tr&gt;&lt;td&gt;
&lt;pre class=&quot;line-numbers&quot; data-line=&quot;1-3&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;readFileAsync(path, 'blob')
    .then(_pushPackageFileStep)
    .then(_pushCertFileStep);
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;td&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;readFileAsync(path, 'blob')
    .then(_uploadStep);

function _uploadStep() {
    return Promise.all([_pushPackageFileStep(), _pushCertFileStep()]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;패키지 파일을 올리는 것과 Cert 파일을 올리는 것은 동시에 진행해도 되므로 all([pushPackage, pushCert])로 하면 약간의 성능 향상이 있을 수도 있겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;문서화&quot;&gt;문서화&lt;/h3&gt;

&lt;p&gt;Promise는 하나의 값을 갖고 성공하거나(fulfilled with a single fulfillment value) 혹은 하나의 예외를 갖고 실패하거나(rejected with a single rejection reason) 둘 중 하나이므로 문서(jsdoc)에 이를 기록하는 것이 좋습니다.&lt;/p&gt;

&lt;p&gt;적어도 아래와 같이 성공 시에 어떤 값을 반환하는지 적어 주는 것이 좋은 습관이라 할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;cm&quot;&gt;/**
     * Get supported profiles
     *
     * @return {Promise} - a promise that is resolved with the array of supported profile names
     */&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getProfiles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getPlatforms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;platforms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;uniq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pluck&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;platforms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'profile'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;javascript-일반&quot;&gt;JavaScript 일반&lt;/h2&gt;

&lt;h3 id=&quot;이벤트-처리&quot;&gt;이벤트 처리&lt;/h3&gt;

&lt;p&gt;동적으로 생성되는 DOM 엘리먼트에 대해 이벤트 핸들러를 추가해야 할 경우가 있습니다.&lt;/p&gt;

&lt;p&gt;패널(panel) 내에 리스트로 하나씩 내용과 버튼이 추가되고 이 버튼에 이벤트를 붙이는 경우를 생각해 보죠.
보통 버튼마다 이벤트 핸들러를 추가하는 식으로 구현하는데, 이것보다는 event delegation을 이용하는 것이 좋습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;부모 엘리먼트가 event를 처리하므로 추가되는 버튼마다 이벤트 리스너를 추가할 필요가 없습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이벤트 핸들러의 수가 감소하므로 메모리 효율적입니다. 버튼 삭제 시 리스너의 unbind를 신경 쓰지 않아도 됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table class=&quot;compare&quot;&gt;
&lt;tr&gt;&lt;td&gt;
&lt;pre class=&quot;line-numbers&quot; data-line=&quot;4-6&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;_.forEach(pages, function (page) {
    var $button = $(ownerPageButtonTemplate());
    $page.append($button);
    $button.on('click', function () {
        topic.publish('editor/open', filePath);
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;td&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;panel.elements.$panel.on('click', 'button', function () {
    topic.publish('editor/open', $(this).attr('data-path'));
});

_.forEach(pages, function (page) {
    var $button = $(ownerPageButtonTemplate());
    $page.append($button);
    $button.attr('data-path', filePath);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;
동적으로 생성/삭제되는 element의 event handler는 delegated event로 처리하는 게 낫겠습니다.&lt;br /&gt;
http://api.jquery.com/on/&lt;br /&gt;
ex)
&lt;pre&gt;
$button.attr('data-path', filePath); // 버튼마다
&lt;/pre&gt;
&lt;pre&gt;
$(pagesPanel).on('click', 'button', function () { // 한 번만
  topic.publish('editor/open', $(this).attr('data-path');
});
&lt;/pre&gt;
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;배열의-join&quot;&gt;배열의 join&lt;/h3&gt;

&lt;p&gt;배열의 값들을 문자열로 만들 필요가 있을 때 배열의 기본(built-in) 함수인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join&quot;&gt;join&lt;/a&gt;을 활용하는 것이 좋습니다.&lt;/p&gt;

&lt;table class=&quot;compare&quot;&gt;
&lt;tr&gt;&lt;td&gt;
&lt;pre class=&quot;line-numbers&quot; data-line=&quot;1-4&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;_.forEach(params.uids, function (uid) {
    configContents += '&quot;URI:uid=' + uid + '&quot;,';
});
configContents = configContents.substring(0, configContents.length - 1) + '\n';
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;td&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var uids = _.map(params.uids, function (uid) {
    return '&quot;URI:uid=' + uid + '&quot;';
}).join(',');
configContents += uids + '\n';
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;_.map(duids, function (d) { return &quot;URI..&quot; + duid; }).join(',') 하면 더 깔끔할 것 같습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;jsonparse-에러-처리&quot;&gt;JSON.parse 에러 처리&lt;/h3&gt;

&lt;p&gt;서버로부터 받은 JSON 문자열의 파싱을 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;JSON.parse&lt;/code&gt;를 자주 사용하는데 이때 try/catch 사용을 권장합니다.&lt;/p&gt;

&lt;table class=&quot;compare&quot;&gt;
&lt;tr&gt;&lt;td&gt;
&lt;pre class=&quot;line-numbers&quot; data-line=&quot;3&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;$.ajax({
    success: function (data) {
        data = JSON.parse(data);
        if (data.result === 'ok') {
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;td&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;$.ajax({
    success: function (data) {
        try {
            data = JSON.parse(data);
            if (data.result === 'ok') {
            }
        } catch (e) {
            console.error('Failed to parse a response', e);
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;JSON.parse error 처리가 필요해 보입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;h2 id=&quot;ux&quot;&gt;UX&lt;/h2&gt;

&lt;p&gt;보통은 리뷰를 통해 로직을 체크하게 되지만 UI나 사용성도 대상이 됩니다.
저는 해당 커밋을 cherry-pick 해서 실제로 돌려 보고 화면 구성이나 메시지/레이블에 대해서도 리뷰를 하는 편인데요, 아예 &lt;a href=&quot;http://tech.kakao.com/2016/02/04/code-review/&quot;&gt;미리보기 서버&lt;/a&gt;를 도입해서 개발 중이거나 개발이 막 끝난 기능을 실제로 사용하면서 기획자나 product owner에게 사용성에 대한 피드백을 받는 것이 유용한 것 같습니다.&lt;/p&gt;

&lt;p&gt;일관된 사용성을 위해 몇 가지 규칙을 정하고 이에 따라 리뷰를 하면 됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;어떤 대상을 선택해서 액션을 취하는 경우 더블클릭으로 해당 액션이 실행되어야 한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;라디오 버튼 같은 form element는 레이블(label)을 눌러도 선택되게 한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다이얼로그는 Esc 키로 닫을 수 있어야 한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다이얼로그의 버튼 배치는 OK, Cancel 순서로 한다.&lt;/p&gt;

    &lt;p&gt;참고로 웹 개발과는 조금 다르지만 데스크톱 어플리케이션의 경우 OS 플랫폼마다 버튼 배치에 대한 UX 철학이 다르다고 합니다. Windows는 OK가 먼저 나오고(&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn742500.aspx&quot;&gt;Right-align the buttons and use this order (from left to right): OK, Cancel, and Apply.&lt;/a&gt;) Mac과 Ubuntu에서는 실제 액션을 유발하는 버튼을 나중에 둔다고(&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/UserExperience/Conceptual/OSXHIGuidelines/WindowDialogs.html&quot;&gt;A button that initiates an action is furthest to the right.&lt;/a&gt;) 하네요.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://uxmovement.com/wp-content/uploads/2011/05/efficient-task-flow.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table class=&quot;compare&quot;&gt;
&lt;tr&gt;&lt;td&gt;
&lt;pre class=&quot;line-numbers&quot; data-line=&quot;1-3&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;grid.on('.dgrid-row:click', function (event) {
    dialog.targetObject = grid.row(event).data;
}),
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;td&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;grid.on('.dgrid-row:dblclick', function () {
    dialog.onClickOkButton();
}),
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;더블클릭하면 바로 실행까지 되어야 합니다. 사용성 관점에서 매우 중요합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;table class=&quot;compare&quot;&gt;
&lt;tr&gt;&lt;td&gt;
&lt;pre class=&quot;line-numbers&quot; data-line=&quot;5&quot;&gt;&lt;code class=&quot;language-markup&quot;&gt;&amp;lt;div class='rcw-content-table-label rcw-table-col'&amp;gt;
    &amp;lt;input type='radio'/&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class='rcw-content-table-value rcw-table-col'&amp;gt;
    &amp;lt;span&amp;gt;Target dialog&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;td&gt;
&lt;pre&gt;&lt;code class=&quot;language-markup&quot;&gt;&amp;lt;div class='rcw-content-table-label rcw-table-col'&amp;gt;
    &amp;lt;input type='radio' id='radio-targetdialog'/&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class='rcw-content-table-value rcw-table-col'&amp;gt;
    &amp;lt;label for='radio-targetdialog'&amp;gt;Target dialog&amp;lt;/label&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;&amp;lt;label for&amp;gt;로는 안 되는 건가요?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;h2 id=&quot;linter-적용&quot;&gt;linter 적용&lt;/h2&gt;

&lt;p&gt;팀에서 jshint, eslint 등의 linter를 적용하기로 했다면 개발자들이 사용하는 에디터에서 바로 체크되어야 하고, &lt;a href=&quot;/deepscan/2016/08/code-review-1#section-17&quot;&gt;커밋된 코드에서도 자동으로 수행되어&lt;/a&gt; 그 결과를 리뷰어가 볼 수 있어야 합니다.&lt;/p&gt;

&lt;p&gt;아래는 개발자가 리팩토링 과정 중에 실수로 require의 alias를 &lt;code class=&quot;highlighter-rouge&quot;&gt;WizardPage&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;WizardPAge&lt;/code&gt;로 변경하면서 jshint 에러가 발생한 상황이고, 단순 컨벤션 에러를 넘어 기능 수행이 되지 않았을 심각한 버그입니다.&lt;/p&gt;

&lt;div class=&quot;image-wrapper&quot;&gt;
  
      &lt;img src=&quot;https://cimfalab.github.io/deepscan//assets/images/code-review-20.png&quot; alt=&quot;jshint 에러&quot; /&gt;
  
  
      &lt;p class=&quot;image-caption&quot;&gt;jshint 에러: 실행에 문제가 있는 상황&lt;/p&gt;
  
&lt;/div&gt;

&lt;table class=&quot;compare&quot;&gt;
&lt;tr&gt;&lt;td&gt;
&lt;pre class=&quot;line-numbers&quot; data-start=&quot;468&quot; data-line=&quot;1&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;page = new WizardPage(pageParams);

return page;
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;td&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;
Convention check 바랍니다. line 468, char 20: 'WizardPage' is not defined.&lt;br /&gt;
이거 verify하고 올리신 건가요?
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class=&quot;quotes&quot;&gt;
  &lt;p&gt;패치 셋 올리기 전에 제대로 실행해서 확인을 안 했네요 죄송합니다. 이번 패치 셋 올릴 때는 실행해보고 올렸습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;h2 id=&quot;읽기-쉬운-코드&quot;&gt;읽기 쉬운 코드&lt;/h2&gt;

&lt;h3 id=&quot;작은-함수&quot;&gt;작은 함수&lt;/h3&gt;

&lt;p&gt;함수는 작게, 한 가지 일만 잘하게 그리고 이름을 서술적으로 써야 합니다.&lt;/p&gt;

&lt;p&gt;아래 두 코드를 비교해 보면 오른쪽 코드가 더 쉽게 읽히죠? 명시적인 함수 이름을 써서 주석도 제거된 것을 알 수 있습니다.&lt;/p&gt;

&lt;table class=&quot;compare&quot;&gt;
&lt;tr&gt;&lt;td&gt;
&lt;pre class=&quot;line-numbers&quot; data-line=&quot;5-14&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;if (model) {
    manifest = model.getContents();

    if (manifest) {
        // Diff with formatted xml string and saved one
        if (model.serialize() === persistenceContents) {
            return false;
        } else {
            if (!isContentChanged()) {
                return false;
            }

            return true;
        }
    } else {
        return false;
    }
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;td&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;if (model) {
    if (isFormatContentChanged()) {
        return isNonFormatContentChanged();
    } else {
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;뭔가 좀 더 의미 있는 이름을 붙여서 빼면 좋겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class=&quot;quotes&quot;&gt;
  &lt;p&gt;Done&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;
아주 좋아졌네요.&lt;br /&gt;
return isFCC() &amp;amp;&amp;amp; isNFCC(); 하는 게 좀 더 보기 쉬운 것 같네요. 일단 이 change는 여기서 마무리하도록 하죠.
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;커밋-메시지&quot;&gt;커밋 메시지&lt;/h3&gt;

&lt;p&gt;커밋 메시지는 코드를 왜 변경했는지 알 수 있게 구체적으로 쓰여야 합니다.
하지만 무엇을 위한 커밋인지 전혀 드러내지 못하는 메시지들이 많았죠.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;server: statistics 버그 수정&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;server: fix a missing column bug.&lt;/code&gt;, …&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;statistics 버그는 무엇을 의미하는지: SQL 문제로 통계 데이터가 아예 나오지 않거나 일부 누락되었나? 아예 잘못된 통계 데이터를 주고 있었나? 통계 페이지에서 사용되는 export 기능이 동작하지 않았나? 심각도 관점에서 이 버그는 당장 반영이 필요한 hot-fix 성격인가 아니면 특정 환경에서만 발생하는 예외적인 버그인가?&lt;/li&gt;
  &lt;li&gt;column이란 무엇을 의미하는지: DB 칼럼? 테이블 칼럼?&lt;/li&gt;
  &lt;li&gt;DB 칼럼이라면 해당 칼럼이 빠져서 어떤 문제가 있었는지 그리고 왜 빠졌는지&lt;/li&gt;
  &lt;li&gt;DB 칼럼을 추가하기 위해 무엇을 수정했는지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;리뷰어와 다시 그 코드를 보게 될 미래의 나를 위해서는 버그 원인, 수정 내용과 패치 영향 등의 사항을 구체적으로 적는 습관을 갖는 것이 좋습니다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;a href=&quot;/deepscan/2016/08/code-review-1#section-18&quot;&gt;영어로 쓰는 게 원칙&lt;/a&gt;이었는데 리뷰하다 보면 아무래도 영 어색한 표현들이나 개발자 개인의 잘못된 영어 습관이 보이게 됩니다.&lt;/p&gt;

&lt;p&gt;팀 리뷰에서 수집된 잘못된 습관들을 분류해 보았습니다. 누구는 전치사 다음에 동사가 올 수 없다는 것도 몰랐다나 뭐라나^^;&lt;/p&gt;

&lt;p&gt;(잘못된 수동태; 웬만하면 능동태로)&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Before&lt;/th&gt;
      &lt;th&gt;After&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Error results &lt;em&gt;are print&lt;/em&gt; in popup dialog.&lt;/td&gt;
      &lt;td&gt;Error results &lt;em&gt;are printed&lt;/em&gt; in popup dialog.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Datasource &lt;em&gt;not unregist&lt;/em&gt; when file deleted&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Unregister&lt;/em&gt; datasource when file is deleted&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;This commit &lt;em&gt;is resolve to&lt;/em&gt; problem.&lt;/td&gt;
      &lt;td&gt;This commit &lt;em&gt;resolves&lt;/em&gt; problem.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;(과도한 명사 연결)&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Before&lt;/th&gt;
      &lt;th&gt;After&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;If the configuration is changed, &lt;em&gt;reset message output&lt;/em&gt;.&lt;/td&gt;
      &lt;td&gt;If the configuration is changed, &lt;em&gt;reset message is printed in Output view&lt;/em&gt;.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Tooltip added in &lt;em&gt;non schema validation target widget&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;Tooltip, &lt;em&gt;displaying non-schema validation result&lt;/em&gt;, added to widget&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fix &lt;em&gt;to editor content sync logic&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;fix &lt;em&gt;a problem (that) sync logic between editors does not work properly&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;(잘못된 동사 연결/사용)&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Before&lt;/th&gt;
      &lt;th&gt;After&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;add enable&lt;/em&gt; import wizard plugins&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;enable&lt;/em&gt; Import Wizard plugins&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;fix get github-token&lt;/em&gt; in setting page&lt;/td&gt;
      &lt;td&gt;fix &lt;em&gt;to get GitHub token&lt;/em&gt; in setting page&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;don’t changing&lt;/em&gt; the device view &lt;em&gt;force&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;don’t change&lt;/em&gt; the device view &lt;em&gt;forcefully&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;support &lt;em&gt;for open&lt;/em&gt; the simulator&lt;/td&gt;
      &lt;td&gt;support &lt;em&gt;for opening&lt;/em&gt; the simulator&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;basic UI &lt;em&gt;define&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;basic UI &lt;em&gt;defined&lt;/em&gt; 혹은 &lt;em&gt;define&lt;/em&gt; basic UI&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1. &lt;em&gt;project file copy&lt;/em&gt; to temporary directory&lt;br /&gt;2. &lt;em&gt;project select&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;1. &lt;em&gt;copy project file&lt;/em&gt; to temporary directory&lt;br /&gt;2. &lt;em&gt;select project&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;(인칭, 단수/복수)&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Before&lt;/th&gt;
      &lt;th&gt;After&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Because import logic &lt;em&gt;create&lt;/em&gt; temporary files,&lt;/td&gt;
      &lt;td&gt;Because import logic &lt;em&gt;creates&lt;/em&gt; temporary files,&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;so &lt;em&gt;these temporary resource are&lt;/em&gt; removed&lt;/td&gt;
      &lt;td&gt;so &lt;em&gt;these temporary resources are&lt;/em&gt; removed&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap-Up&lt;/h2&gt;

&lt;p&gt;코드 리뷰에 의한 개선 사례를 유용하다고 느꼈던 것들 위주로 정리해 보았습니다.&lt;/p&gt;

&lt;p&gt;정리를 다시 해 보니, 컨텍스트 전환이 자주 일어나고 다른 사람의 코드를 읽는 것이 생각보다 어려워 부담이 되기도 하는 코드 리뷰이지만 리뷰를 통해 전보다 지식이 쌓이고 다양한 관점에서 생각해 볼 수 있다는 것이 큰 장점이라는 생각이 다시 한 번 듭니다.&lt;/p&gt;

&lt;p&gt;또 사람이 수행해야 하는 리뷰의 부담을 줄여 주는 도구가 더 유용해질 것이므로 현행 linter보다 더 좋은 JavaScript 정적 분석기를 개발하고자 하는 제 목표도 좀 더 확고해지는 것 같습니다. :)&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.slideshare.net/domenicdenicola/promises-promises&quot;&gt;Promises, Promises&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://lodash.com/docs&quot;&gt;lodash documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;Lodash 최신 버전(4.x)에서는 map으로 대치되었네요. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/17346506/how-to-execute-common-code-after-a-dojo-deferred-object-is-resolved-or-rejected&quot;&gt;How to execute common code after a Dojo Deferred object is resolved or rejected?&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  
  <entry>
    <title>JavaScript 코드 리뷰 - 코드 리뷰 문화</title>
    <link href="/deepscan/2016/08/code-review-1?utm_source=RSS&amp;utm_medium=RSS&amp;utm_campaign=/2016/08/code-review-1"/>
    <updated>2016-08-22T10:00:00+00:00</updated>
    <id>/deepscan/2016/08/code-review-1</id>
    <content type="html">&lt;p&gt;여러분의 팀에서는 코드 리뷰(code review)를 하시나요?&lt;/p&gt;

&lt;p&gt;코드 리뷰 도구나 현장 사례 공유가 많아지면서 코드 리뷰를 수행하는 개발팀들이 늘어나고 있는 것 같습니다. 좋은 현상이죠. :)&lt;/p&gt;

&lt;p&gt;제가 일하는 팀에서도 JavaScript로 웹 개발을 하면서 코드 리뷰를 상시 수행해 왔는데요, 그간 코드 리뷰를 하면서 다양하게 제안된 JavaScript의 코드 개선 사례나 팁을 공유하려고 합니다.&lt;/p&gt;

&lt;p&gt;우선 오늘은 코드 리뷰 자체에 대해 리뷰를 수행하면서 느낀 점들 위주로 정리해 보도록 하겠습니다.&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#코드-리뷰&quot; id=&quot;markdown-toc-코드-리뷰&quot;&gt;코드 리뷰&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#코드-리뷰는-문화다&quot; id=&quot;markdown-toc-코드-리뷰는-문화다&quot;&gt;코드 리뷰는 문화다&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#코드-리뷰의-효과&quot; id=&quot;markdown-toc-코드-리뷰의-효과&quot;&gt;코드 리뷰의 효과&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#빨리-가려면-혼자-가고-멀리-가려면-함께-가라&quot; id=&quot;markdown-toc-빨리-가려면-혼자-가고-멀리-가려면-함께-가라&quot;&gt;빨리 가려면 혼자 가고, 멀리 가려면 함께 가라&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#인간에게는-모두의-장점이-있다&quot; id=&quot;markdown-toc-인간에게는-모두의-장점이-있다&quot;&gt;인간에게는 모두의 장점이 있다&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#조직은-개발자의-성장을-바란다&quot; id=&quot;markdown-toc-조직은-개발자의-성장을-바란다&quot;&gt;조직은 개발자의 성장을 바란다&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#코드-리뷰하기&quot; id=&quot;markdown-toc-코드-리뷰하기&quot;&gt;코드 리뷰하기&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#겸손하고-정중하게-리뷰하기&quot; id=&quot;markdown-toc-겸손하고-정중하게-리뷰하기&quot;&gt;겸손하고 정중하게 리뷰하기&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#적극적으로-리뷰하기&quot; id=&quot;markdown-toc-적극적으로-리뷰하기&quot;&gt;적극적으로 리뷰하기&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#논리적인-근거로-리뷰하기&quot; id=&quot;markdown-toc-논리적인-근거로-리뷰하기&quot;&gt;논리적인 근거로 리뷰하기&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#도구-선정&quot; id=&quot;markdown-toc-도구-선정&quot;&gt;도구 선정&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#작게-자주-올리는-것이-좋다&quot; id=&quot;markdown-toc-작게-자주-올리는-것이-좋다&quot;&gt;작게 자주 올리는 것이 좋다&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#리뷰-정책&quot; id=&quot;markdown-toc-리뷰-정책&quot;&gt;리뷰 정책&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#컨벤션-체크&quot; id=&quot;markdown-toc-컨벤션-체크&quot;&gt;컨벤션 체크&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#리뷰-언어&quot; id=&quot;markdown-toc-리뷰-언어&quot;&gt;리뷰 언어&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#wrap-up&quot; id=&quot;markdown-toc-wrap-up&quot;&gt;Wrap-Up&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#references&quot; id=&quot;markdown-toc-references&quot;&gt;References&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;코드-리뷰&quot;&gt;코드 리뷰&lt;/h2&gt;
&lt;p&gt;코드 리뷰란 &lt;strong&gt;사람의 검토를 통해 코드상의 잠재적인 결함을 찾고 개선해 나가는 과정&lt;/strong&gt;이라 정의할 수 있겠습니다(참고로 요즘은 사람이 놓칠 수도 있고 또 사람이 굳이 검토할 필요가 없는 코드 컨벤션 성격의 결함들이 있으므로 리뷰 과정에 eslint 같은 linter를 통한 자동 검수가 들어가는 것이 추세입니다).&lt;/p&gt;

&lt;p&gt;코드 리뷰에는 다양한 &lt;a href=&quot;http://bcho.tistory.com/276&quot;&gt;기법들&lt;/a&gt;이 존재하는데, 여기에서는 팀 리뷰(team review) 중 온라인 코드 리뷰에 초점을 맞춰서 온라인 코드 리뷰 수행 시 고려할 사항들에 관해 얘기해 보겠습니다.&lt;/p&gt;

&lt;p&gt;아래부터는 코드를 작성하고 리뷰를 요청하는 사람(author)을 리뷰 요청자, 리뷰하는 사람(reviewer)을 리뷰어라 칭합니다.&lt;/p&gt;

&lt;h2 id=&quot;코드-리뷰는-문화다&quot;&gt;코드 리뷰는 문화다&lt;/h2&gt;

&lt;p&gt;팀에서 코드 리뷰를 수행하기 위해 가장 먼저 해야 할 일은 코드 리뷰를 ‘문화’로 받아들이는 것으로 생각합니다.&lt;/p&gt;

&lt;p&gt;문화란 무엇인가요?&lt;/p&gt;

&lt;p&gt;최근에 읽은 &amp;lt;스페이스 크로니클&amp;gt;이란 책에서는 문화란 어떤 집단이 더는 관심을 두지 않는 일을 행하는 것이라고 합니다. 즉 &lt;strong&gt;‘누구나 당연하게 생각하는 것’&lt;/strong&gt;이죠.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/deepscan/assets/images/code-review-00.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어 이탈리아의 슈퍼마켓에 가면 파스타 코너가 굉장히 다양하고 커서 여행객들이 놀라는데 막상 현지인들의 반응은 이렇다네요.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“파스타 코너인데 당연하죠.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;마찬가지로 &lt;strong&gt;코드 리뷰도 개발팀이라면 당연히 해야 하는 활동이라는 점에서 팀의 문화&lt;/strong&gt;에 속합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“개발팀인데 코드 리뷰는 당연하죠.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;코드 리뷰에 대해 거부감을 보이는 개발자가 있을 수 있는데, 제 생각에는 이걸 설득해야 한다는 것 자체가 사실 낭비인 것 같습니다. 애초에 서로의 문화가 맞지 않는다는 뜻이므로 처음부터 팀에서 배제하거나 코드 리뷰 활동을 정식 지표(KPI)로 삼아 기본 업무로 포함하는 게 좋을 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;코드-리뷰의-효과&quot;&gt;코드 리뷰의 효과&lt;/h2&gt;

&lt;p&gt;그렇다면 코드 리뷰는 왜 당연하게 해야 할까요?&lt;/p&gt;

&lt;p&gt;사람이 해야 하는 일이니 일정한 시간과 노력이 들게 되는 데 그만큼의 장점이 있어야 할 겁니다. 코드 리뷰로 얻을 수 있는 효과를 세 가지로 정리해 보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;빨리-가려면-혼자-가고-멀리-가려면-함께-가라&quot;&gt;빨리 가려면 혼자 가고, 멀리 가려면 함께 가라&lt;/h3&gt;
&lt;p&gt;리뷰를 거치면 리뷰어의 확인을 기다려야 하므로 리뷰를 거치지 않을 때보다 코드 머지가 늦어집니다.
그래서 일견 개발 속도가 느려지는 것처럼 보이는데 코드 품질이 좋아지기 때문에 장기적으로는 개발 시간이 감소하고 배포 속도는 빨라진다고 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;리뷰 요청자가 놓친 부분을 리뷰어가 짚어줄 수 있고,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;다른 모듈과의 인터페이스적인 측면 (“이렇게 수정하면 제 모듈이랑 깨질 것 같은데요.”)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;더 간단한 알고리즘 구현 (“바퀴를 재발명할 필요가 있을까요? 하물며 버그까지 있을 것 같은데요.”)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getLast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;project&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;analyses&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;analyses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;analyses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;analyses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;project.analyses[-1]인 경우가 생길 것 같네요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;_.last(project.analyses)를 쓰면 깔끔하지 않을까요?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;리뷰 요청자 입장에서는 리뷰를 받아야 하므로 아무래도 좀 더 신경을 쓰게 되죠.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;주석은 충분한가?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;로직 흐름은 명확한가?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;라이브러리를 추가했는데 라이센스 파일은 챙겼나?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;우리 팀장님은 같은 로직 두 번 쓰는 거 완전 싫어하는데 리팩토링해야 하나? 다른 데 이미 있나 찾아보자.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;팀 리뷰를 거쳐서 머지되었다는 심리적 안정감도 있죠, 나 혼자만의 잘못이 아니라는. (응?)&lt;/p&gt;

&lt;p&gt;하지만 리뷰가 비동기로 진행되므로 리뷰 요청자가 프로세스를 진행하지 못하는 경우가 생길 수 있습니다. 로컬에서 feature 브랜치로 따로 작업하고 Git rebase를 활용해서 리뷰된 커밋과 머지하면 굳이 리뷰 때문에 작업이 중단될 일은 없다고 생각하지만 실제로는 데모 일정의 압박, 브랜치 관리의 귀찮음, 일을 순서대로 처리하고 싶은 강박(“이 커밋 깔끔하게 머지시킨 후에 다른 일 하자”)이 있어서 리뷰가 병목이 되기도 합니다.&lt;/p&gt;

&lt;h3 id=&quot;인간에게는-모두의-장점이-있다&quot;&gt;인간에게는 모두의 장점이 있다&lt;/h3&gt;
&lt;p&gt;리뷰를 해 보니 이게 결국 사람의 일이라 리뷰어 각자의 특징이 드러납니다. :)&lt;/p&gt;

&lt;p&gt;가령 어떤 리뷰어는 컨벤션을 중점 체크하고, 어떤 리뷰어는 Promise 객체의 잘못된 사용을 잘 짚어 내며, 어떤 리뷰어는 웬 듣지도 못한 유용한 라이브러리를 불쑥 추천합니다.
중요하게 생각하는 그리고 코드를 볼 때 잘 걸러지는 부분이 각자 다르다는 것이죠.&lt;/p&gt;

&lt;p&gt;그만큼 다양한 방향에서 코드가 검토되니 코드가 계속 개선됩니다.&lt;/p&gt;

&lt;p&gt;제 장점은 뭐였을까요?
저는 아무래도 제품 관리의 역할이 있다 보니 UI나 사용자에게 보이는 레이블, 에러 메시지에 대해 주로 리뷰했었습니다. &lt;a href=&quot;http://story.pxd.co.kr/1128&quot;&gt;에러 메시지는 4H를 담고 있어야&lt;/a&gt; 하는데 이건 그냥 구색만 맞춘 개발자 영어잖아요!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/deepscan/assets/images/code-review-07.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;조직은-개발자의-성장을-바란다&quot;&gt;조직은 개발자의 성장을 바란다&lt;/h3&gt;
&lt;p&gt;개발자의 성장도 코드 리뷰나 페어 프로그래밍(pair programming)의 효과 중 하나인 것 같습니다.&lt;/p&gt;

&lt;p&gt;교육, 학회나 세미나 참여 등 성장의 기회에 대한 얘기를 보통 많이 하는데 코드 리뷰를 통해 다양한 리뷰어의 지식을 공유 받는 것, 다른 의견을 듣고 논리에 기반을 둔 토론으로 더 나은 결정을 끌어내는 경험을 쌓는 것, 같은 분야를 고민하는 사람들에게 받는 피드백을 통해 시간을 절약하는 것도 개발 조직이 제공할 수 있는 좋은 성장 기회라고 생각합니다.&lt;/p&gt;

&lt;p&gt;자신보다 더 낫거나 경험이 많은 개발자로부터 바로 배울 수 있고, 그렇게 코드에 대해 열린 마음으로 일하는 습관과 경험이 &lt;a href=&quot;http://seoz.egloos.com/4084364&quot;&gt;오픈 소스 기여&lt;/a&gt;의 시작이기도 할 테니까요.&lt;/p&gt;

&lt;h2 id=&quot;코드-리뷰하기&quot;&gt;코드 리뷰하기&lt;/h2&gt;

&lt;p&gt;코드 리뷰는 팀 활동이기 때문에 코드 리뷰를 수행하기에 앞서 팀원 전체가 동의하는 리뷰 규칙을 세우고 진행하는 것이 좋습니다.
리뷰 규칙을 정할 때 고려할 것들에 대해 알아봅니다.&lt;/p&gt;

&lt;h3 id=&quot;겸손하고-정중하게-리뷰하기&quot;&gt;겸손하고 정중하게 리뷰하기&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;리뷰어&lt;/td&gt;
      &lt;td&gt;자신의 리뷰가 정답이고 요청자의 코드는 틀렸다는 태도를 지양해야 합니다.&lt;br /&gt;사용자 요구사항을 만족하기만 한다면 틀린 코드가 아니고 &lt;strong&gt;더 좋은 코드(이해하기 쉽고, 효율적이고, 빠르고, 재사용 가능하며 깨끗한 코드)&lt;/strong&gt;가 있다는 생각으로 팀의 코드를 더 좋게 만들기 위해 겸손히 리뷰해야 합니다.&lt;br /&gt;리뷰어도 언제든 리뷰 요청자가 될 수 있으니까요.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;리뷰 요청자&lt;/td&gt;
      &lt;td&gt;리뷰를 열린 마음으로 받아들여야 합니다.&lt;br /&gt;리뷰는 ‘나’에 대한 비난이 아니라 ‘나 그리고 우리의 코드’에 대한 의견일 뿐입니다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이런 규칙을 정하고도 실제로 진행해 보면 결국 사람에게는 감정이라는 게 있어서 리뷰가 계속되고 오랫동안 머지되지 않으면(pending) 아무래도 심적으로 불편해지기 마련입니다. 어떤 사소한 꼬투리로 촉발되어 감정 소모적인 댓글들이 달리기도 하고요(이런 경우 감정이 없는 도구로써 컨벤션 체크를 자동화하거나 중재자가 리뷰어/요청자를 중재해서 불을 끌 필요가 있습니다).&lt;/p&gt;

&lt;p&gt;그래서 더욱 공격적이지 않은 겸손한 태도를 가지는 것이 중요합니다.
상대방을 존중하면서 ‘이렇게 해보면 어떨까요’, ‘이런 문제가 생기지 않을까요’라는 식으로 리뷰가 이루어져야 합니다.&lt;/p&gt;

&lt;p&gt;아무래도 감정적인 사람에 의해 진행되는 활동이다 보니 말이 참 아 다르고 어 다르더라고요.
가령 라이브러리를 사용하자고 아래와 같이 코멘트를 달았는데,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그리고 url을 다룰 때는 항상 URIjs 모듈을 이용하세요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;요청자의 피드백이 다음과 같았습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;URIjs가 언제 들어왔나요? 사용하는 곳이 리뷰어의 모듈뿐이군요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;코멘트를 단정적이지 않게 아래처럼 했으면 요청자 피드백이 더 긍정적이지 않았을까 하는 생각이 듭니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그리고 url을 다룰 때는 URIjs 모듈을 이용하시면 좋을 것 같습니다. 가령 이 코드는 URIjs를 사용하면 아래처럼 쓸 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;또, 후배 개발자가 선배 개발자의 코드에 대해 말하는 것을 어려워할 수 있는데 이것 역시 모두가 동등한 리뷰어이자 리뷰 요청자라는 인식을 하고 시작되어야 합니다.
팀장 시절에 리뷰 코멘트를 수십 개 받고 ‘이것들이..’ 했던 기억이 납니다만^^; 지금은 그렇게 적극적으로 리뷰에 참여해줬던 팀원들에 대한 고마움과 팀 문화에 대한 자부심이 더 크네요.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;비자아적 프로그래밍(Egoless Programming)&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul class=&quot;notice&quot;&gt;
  &lt;li&gt;당신이 실수하리라는 것을 받아들여라.&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;당신이 만든 코드는 당신이 아니다.&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;당신이 얼마나 많이 알고 있다고 해도, 항상 누군가는 더 많은 것을 알고 있다.&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;권위는 지위가 아니라 지식으로부터 나온다.&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;자신보다 많이 알지 못하는 사람이라 해도 존경과 인내로 대하라.&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;사람이 아니라 코드 그 자체를 비판하라.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;적극적으로-리뷰하기&quot;&gt;적극적으로 리뷰하기&lt;/h3&gt;

&lt;p&gt;리뷰는 어려운 것으로 생각하는 개발자들도 있는데, 아래처럼 가볍게 생각하는 것이 좋습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;코드를 읽다가 뭔가 맘에 걸린다, 찜찜하다.&lt;/li&gt;
  &lt;li&gt;참지 말고 거리낌 없이 이야기한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그래야 다양한 의견과 아이디어가 나오면서 코드가 개선되고 지식이 공유됩니다.
저도 “아 이거 쫌스러워 보일 텐데” 싶어 드래프트를 버린 경우도 꽤 있지만 대부분은 그냥 드르륵 적는데요, 요청자가 선별해서 잘 받아들였던 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;논리적인-근거로-리뷰하기&quot;&gt;논리적인 근거로 리뷰하기&lt;/h3&gt;

&lt;p&gt;적극적으로 하면서도 자신의 리뷰에 대해 논리적인 근거나 참조 레퍼런스가 있으면 더 좋습니다. 즉, 아래처럼 되는 거죠.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;코드를 읽다가 뭔가 맘에 걸린다, 찜찜하다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;왜 찜찜하지?&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;내가 생각한 게 맞는지 찾아보고 돌려보고 증명한다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;참지 말고 거리낌 없이 이야기한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;내가 알던 것이 맞는지 이렇게 코멘트를 남겨도 되는지 한 번 더 생각해 보는 과정에서 리뷰어도 자신의 지식을 점검하는 계기가 됩니다. Q&amp;amp;A 관계에서 질문하는 사람보다 답변하는 사람이 더 많이 배우게 된다는 그런 거죠.&lt;/p&gt;

&lt;p&gt;특히 웹 개발에 도움을 주는 온라인 서비스가 많으므로 이를 활용하는 것도 좋습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://httpbin.org&quot;&gt;httpbin.org&lt;/a&gt;나 &lt;a href=&quot;https://requestb.in/&quot;&gt;RequestBin&lt;/a&gt;과 같이 웹 서버를 따로 구동하지 않아도 HTTP 클라이언트의 테스트가 가능한 서비스:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/deepscan/assets/images/code-review-08.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://jsfiddle.net&quot;&gt;JSFiddle&lt;/a&gt;이나 &lt;a href=&quot;https://plnkr.co/&quot;&gt;Plunker&lt;/a&gt;와 같이 HTML/CSS/JavaScript 코드를 실행할 수 있는 서비스:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/deepscan/assets/images/code-review-09.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;도구-선정&quot;&gt;도구 선정&lt;/h3&gt;
&lt;p&gt;코드 리뷰를 위한 도구나 서비스는 매우 다양합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Gerrit이나 Phabricator 같은 오픈 소스 도구&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;상용 도구&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://smartbear.com/product/collaborator/overview/&quot;&gt;Collaborator&lt;/a&gt;나 &lt;a href=&quot;https://www.atlassian.com/software/crucible&quot;&gt;Crucible&lt;/a&gt; 같은 상용 도구입니다.
커밋 없이 리뷰할 수 있는 pre-review, IDE 연동, 자사 제품과의 연동(가령 Crucible은 Atlassian 사의 제품이어서 JIRA와 잘 연동된다고 합니다) 등 많은 편의 기능을 제공합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GitHub의 Pull Request&lt;/p&gt;

    &lt;p&gt;GitHub의 Pull Request(이하 PR)를 코드 리뷰 도구로 활용하는 방법입니다. 코드를 바로 머지하는 것이 아니라 fork 된 리파지토리 혹은 해당 리파지토리의 별도 브랜치에서 PR을 생성하고 이를 리뷰한 후에 머지합니다.&lt;/p&gt;

    &lt;p&gt;GitHub과 연계된 &lt;a href=&quot;https://reviewable.io/&quot;&gt;reviewable.io&lt;/a&gt;나 &lt;a href=&quot;https://www.review.ninja/&quot;&gt;ReviewNinja&lt;/a&gt; 같은 코드 리뷰 서비스도 있고요.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;제 경우에는 Git과 Gerrit이 전사 및 프로젝트 표준이어서 고민 없이 Gerrit을 통해 리뷰를 진행했는데 각 팀의 상황에 맞게 선정하시면 되겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;작게-자주-올리는-것이-좋다&quot;&gt;작게 자주 올리는 것이 좋다&lt;/h3&gt;

&lt;p&gt;&amp;lt;클린 코드&amp;gt;에서 말하는 좋은 코드의 조건이 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;코드는 작을수록 좋다. 함수나 클래스는 한 가지 일만 잘해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이와 마찬가지로 좋은 리뷰 요청의 조건은 &lt;strong&gt;작은 커밋을 자주 하는 것&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Frequent feedback on small ships&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;대량의 커밋을 한번 딱 올리지 말고 작은 커밋을 자주 올려야 리뷰어가 편하게 집중적으로 리뷰하고 피드백을 자주 줄 수 있다는 것이죠.&lt;/p&gt;

&lt;p&gt;아래는 팀에서 실제로 올라왔던 커밋과 그에 달린 리뷰입니다.&lt;/p&gt;

&lt;div class=&quot;image-wrapper&quot;&gt;
  
      &lt;img src=&quot;https://cimfalab.github.io/deepscan//assets/images/code-review-05.png&quot; alt=&quot;Too many codes&quot; /&gt;
  
  
      &lt;p class=&quot;image-caption&quot;&gt;하나로 커밋된 너무 많은 변화&lt;/p&gt;
  
&lt;/div&gt;

&lt;div class=&quot;image-wrapper&quot;&gt;
  
      &lt;img src=&quot;https://cimfalab.github.io/deepscan//assets/images/code-review-06.png&quot; alt=&quot;&quot; /&gt;
  
  
      &lt;p class=&quot;image-caption&quot;&gt;용감한 리뷰어들&lt;/p&gt;
  
&lt;/div&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;+3720, -2374 코드!!! 도전!!!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;우려하던 대로 거의 리뷰가 불가능한 수준의 커밋인데 리뷰가 됐네요. 최소한 파일 이름 변경은 따로 커밋되어야 했고 다른 부분들도 충분히 쪼개질 수 있을 것 같은데 한꺼번에 올라왔네요. 다음부터는 이런 커밋은 깔끔하게 -2 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;저는 솔직히 리뷰를 포기했는데 팀원들이 그 어려운 걸 해냈네요. ㅠ&lt;/p&gt;

&lt;p&gt;위 커밋의 경우 기능 추가, 로직 변경, 파일 이름 변경이 다 섞여서 올라왔었는데 별개 커밋으로 올렸어야 합니다.
실제로 커밋 목적과 관계없다면 스타일이나 포맷 변경도 나중에 code cleanup 같은 별도 목적의 커밋으로 올리는 것이 좋은 습관일 것입니다. 물론 리뷰어도 요청자가 수정한 내용에 대해서만 리뷰하는 것이 좋습니다, 다른 부분의 버그나 스타일을 고치고 싶더라도 말이죠.&lt;/p&gt;

&lt;p&gt;대안들&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;코드를 다 수정한 후에 커밋을 올릴 것이 아니라 일정 부분 수정할 때마다 커밋(patch set)을 올린다&lt;/p&gt;

    &lt;p&gt;완료된 최종 코드를 한번 커밋하는 것이 아니고 일정 부분 수정된 코드를 그날그날의 커밋으로 올립니다.
완료된 상태가 아니므로 리뷰를 요청하지(리뷰어를 추가하지) 않아도, 리뷰어가 시간 날 때 그나마 작은 단위로 변경을 확인할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;명시적인 리뷰 요청이 없어도 리뷰어가 코드 커밋 상황을 알 수 있기 때문인데요, Gerrit의 경우 Watched Projects에 관심 있는 프로젝트를 등록하면 커밋에 대한 메일을 받을 수 있고 또 Slack과 CI를 연동해서 Slack을 통해 커밋 상황을 메시지로 받을 수도 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;image-wrapper&quot;&gt;
  
      &lt;img src=&quot;https://cimfalab.github.io/deepscan//assets/images/code-review-01.png&quot; alt=&quot;Watched Projects&quot; /&gt;
  
  
      &lt;p class=&quot;image-caption&quot;&gt;Watched Projects&lt;/p&gt;
  
&lt;/div&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
  
      &lt;img src=&quot;https://cimfalab.github.io/deepscan//assets/images/code-review-03.png&quot; alt=&quot;Slack notification&quot; /&gt;
  
  
      &lt;p class=&quot;image-caption&quot;&gt;Bot message in the channel&lt;/p&gt;
  
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.outsider.ne.kr/1199&quot;&gt;이 글&lt;/a&gt;에서도 PR을 먼저 올리고 “WIP”와 “DONE”이라는 레이블을 추가하도록 해서 중간중간 점진적인 리뷰로 부담이 줄었다고 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;오프라인 리뷰의 요청&lt;/p&gt;

    &lt;p&gt;대량의 코드를 커밋할 수밖에 없을 때는 요청자가 오프라인 리뷰를 진행하는 것이 좋습니다.
오프라인 리뷰를 통해 코드 설계 목적, 주요 실행 흐름 등을 설명한 이후에 온라인 리뷰를 진행하면 리뷰가 수월할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;특히 어떤 주요 기능의 최초 커밋일 경우 대량일 확률이 높아 이때는 오프라인으로 진행하는 것을 권장했습니다.
오프라인 진행 시 해당 모듈 개발자가 발표자(Author)가 되어 &lt;a href=&quot;http://bcho.tistory.com/276&quot;&gt;다음의 일들을 수행&lt;/a&gt;합니다:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;발표할 내용을 간략하게 요약하여 리뷰 페이지 생성&lt;/li&gt;
      &lt;li&gt;리뷰 진행&lt;/li&gt;
      &lt;li&gt;작성 중인 코드를 IDE, vi 등을 통해 직접 리뷰
        &lt;ul&gt;
          &lt;li&gt;동료들의 이해를 위해 code folding 혹은 다이어그램 등을 활용해 주요 실행 흐름을 우선 설명한다.&lt;/li&gt;
          &lt;li&gt;그 이후 각 함수에 대한 세부 사항을 얘기한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;리뷰/피드백에 따른 액션 아이템 정리 및 수행/할당(JIRA 이슈 등록, 위키 정리 등)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;오프라인 리뷰는 준비, 참석, 수정 등 시간이 생각 외로 많이 걸려서(준비에 하루, 리뷰에서 도출된 개선 아이템 수정에 일주일 정도 걸렸던 적도..) 자주 수행되지는 못했는데, 정기적으로 하기보다는 스프린트 리뷰 이후 여분의 시간(slack day라고 불렀던) 등을 활용해 부정기 진행하는 게 현실적인 것 같습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그래도 역시 리뷰 요청자가 “Frequent feedback on small ships” 원칙을 항상 새기고 커밋을 잘게 쪼개서 올리는 것이 중요합니다. 리뷰어와 그리고 미래의 나를 위해.&lt;/p&gt;

&lt;h3 id=&quot;리뷰-정책&quot;&gt;리뷰 정책&lt;/h3&gt;

&lt;p&gt;머지(merge 혹은 submit), 리뷰 시간 등의 정책을 합의해서 팀의 규칙으로 정할 필요가 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;역할&quot;&gt;역할&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;리뷰 마스터(최종 점수를 주고 머지할 수 있는 사람)를 정한다.&lt;/li&gt;
  &lt;li&gt;리뷰 코멘트에 대한 최종 수정 결정은 요청자가 한다.&lt;/li&gt;
  &lt;li&gt;나는 &lt;strong&gt;언제든 리뷰어이거나 리뷰 요청자가 될 수 있으므로 상대방 관점에서 생각&lt;/strong&gt;하자.
    &lt;ul&gt;
      &lt;li&gt;리뷰 요청자: 리뷰어가 쉽게 리뷰할 수 있도록 &lt;a href=&quot;#section-11&quot;&gt;작은 커밋을 올리려고 노력&lt;/a&gt;한다. 리뷰 요청 전에 리뷰 시스템에서 자신이 커밋한 코드의 diff를 확인한다. 자신의 에디터에서는 보이지 않았던 문제- 가령 불필요한 공백 추가, 모듈의 require 순서, &lt;code class=&quot;highlighter-rouge&quot;&gt;if (true)&lt;/code&gt; 같이 테스트를 위해 임의로 삽입한 코드 등 -가 보일 것이다.&lt;/li&gt;
      &lt;li&gt;리뷰어: 리뷰 요청자가 변경한 부분에 대해서만 리뷰하고 무리한 강요를 하지 않는다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;리뷰어의 의도 표시&lt;/strong&gt;&lt;br /&gt;
정식 규칙은 아니었고 팀 내에서 암묵적으로 사용된 것인데, 코멘트를 달 때 리뷰어의 의도나 의지를 표시하는 다음 말들을 붙이는 것도 좋습니다.&lt;br /&gt;&lt;/p&gt;
    &lt;ul class=&quot;notice&quot;&gt;
      &lt;li&gt;(옵션): 꼭 수정할 필요는 없고 코멘트를 참고만 하세요&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;(향후): 이번 커밋에는 수정하지 말고 다음 커밋이나 향후 리팩토링할 때 참고하세요&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;(궁금): 꼭 코드와 관련된 것이 아니지만 궁금한 것이 있습니다&lt;br /&gt;
고쳐야 한다는 강제가 없어 요청자/리뷰어 모두의 부담이 덜어 지면서 활발한 리뷰에 도움이 되었던 것 같습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;리뷰-시간&quot;&gt;리뷰 시간&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;리뷰어는 코드 커밋 후 1일 이내에 리뷰한다. 리뷰 요청자는 기한 내에 리뷰되지 않으면 Slack을 통해 리뷰를 요청할 수 있다. 바쁜데 리뷰 요청해서 미안한 것이 아닌 리뷰 늦게 해 줘서 미안하게 되는 문화를 만들자.&lt;/li&gt;
  &lt;li&gt;온라인으로 커뮤니케이션이 여의치 않으면 온라인에서 길게 논쟁하지 말고 리뷰 마스터나 PL이 중재하여 당사자들이 문제를 해결할 수 있게 도와준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;리뷰-점수-및-머지-조건&quot;&gt;리뷰 점수 및 머지 조건&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;리뷰어가 X명 추가되어야 하며, 몇 점 이상을 획득해야 머지된다.
    &lt;ul&gt;
      &lt;li&gt;예를 들어,  +2 이상일 때 머지 가능하도록 Gerrit을 설정하고 2명 이상의 리뷰 &amp;amp; 합계 2점을 머지 조건으로 채택&lt;/li&gt;
      &lt;li&gt;새로운 패치 셋이 올라오면 이전에 획득한 점수를 무효로 할 것인지 고려할 것인지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;명확한 버그나 수정 사항이 발견되어 머지할 수 없는 코드로 판단되면 -1점을 준다.&lt;/li&gt;
  &lt;li&gt;jshint 자동 체크에서 실패하면 -1을 획득하며 리뷰어는 리뷰하지 않아도 된다.&lt;/li&gt;
  &lt;li&gt;모든 코드를 리뷰할 필요는 없고 모든 코드가 머지 조건을 만족할 필요도 없다.
    &lt;ul&gt;
      &lt;li&gt;단순한 UI 문자열 변경, 아이콘 파일 등의 리소스 추가, 버그 수정(hot fix) 등은 리뷰 마스터가 바로 머지할 수 있다.&lt;/li&gt;
      &lt;li&gt;실험적이거나 버려질 코드. 예를 들어, REST 서비스를 제공하는 서버가 있었는데 실시간 동작을 위해 곧 웹소켓으로 변경 예정이었습니다. 이 시점에 REST로 인터페이스 하는 클라이언트 코드의 리팩토링 커밋이 올라왔었는데, 굳이 리뷰할 필요가 없다는 의견이었죠.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p class=&quot;notice&quot;&gt;단, 리뷰를 느슨하게 하는 이 경우에도 컨벤션은 따라야 합니다.
별도 브랜치에서 실험적으로 진행하는 코드인데 굳이 따라야 하냐는 반박이 다른 팀에서 있었다고 하던데, 컨벤션은 따르라고 만든 것이기 때문에 전 솔직히 논쟁거리도 안 되는 문제라고 생각합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;코드 수정에 대한 최종 결정은 리뷰 요청자가 한다.&lt;/li&gt;
  &lt;li&gt;리뷰 요청자는 커밋 코드의 동작을 본인 로컬 환경이나 개발 서버에서 확인한 후 Verified 점수 1점을 주는 것이 좋다. 패치 셋(patch set)을 올리다 보면 개발자가 확인하지 않는 경우도 많고 컴파일 에러가 없는 JavaScript 특성상 오류를 알기가 어렵더군요.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/deepscan/assets/images/code-review-12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/deepscan/assets/images/code-review-13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;또, 모듈별 단위 테스트에 실패하면 리뷰하지 않는다 혹은 단위 테스트가 같이 올라오지 않으면 리뷰하지 않는다는 규칙을 세울 수 있습니다. 해보고 싶었는데 빡빡한 일정을 이유로 실행하지 못했었네요.&lt;/p&gt;

&lt;h4 id=&quot;리뷰-내용&quot;&gt;리뷰 내용&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;온라인으로 커뮤니케이션이 여의치 않으면 말이 글보다 효율적이므로 상대방의 자리로 가서 물어본다. 단, 어떤 합의를 했는지 코멘트로 남겨 두는 것이 좋다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리뷰어는 코드 내용이 잘 이해되지 않을 때 리뷰 요청자에게 찾아가 코드에 대한 설명을 듣는다. 이후 개발자가 이 설명을 주석으로 추가해 패치 셋을 올리는 것이 향후 유지보수에 도움이 된다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;/deepscan/assets/images/code-review-15.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;/deepscan/assets/images/code-review-16.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;주석 처리할 때는 TODO, FIXME 같은 레이블을 추가하는 게 좋다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;/deepscan/assets/images/code-review-14.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;외부에서 가져온 오픈 소스를 수정할 때는 버그에 관계된 것만 고친다.&lt;/p&gt;

    &lt;p&gt;버그 수정을 위해 외부에서 가져온(upstream) 오픈 소스를 고칠 때는 해당 버그에 관계된 부분만 고치는 것이 좋습니다.
간혹 버그와 관계없는 수정을 하는 경우(포맷 맞추기)가 있는데, 커밋과도 관계가 없고 오픈 소스에 패치를 보낼 때도 문제 될 수 있으므로 지양해야 합니다.&lt;/p&gt;

    &lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;버그 fix와 관계된 것이 아니라면 굳이 포맷팅/jshint 등을 위해서 원 upstream과 다르게 수정할 필요는 없을 것 같네요.&lt;/p&gt;
&lt;/blockquote&gt;
    &lt;blockquote class=&quot;quotes&quot;&gt;
  &lt;p&gt;기왕 한 거 다시 돌리기도 그렇네요. 큰 문제 없을 것으로 보입니다.&lt;/p&gt;
&lt;/blockquote&gt;
    &lt;blockquote class=&quot;quotes reviewer&quot;&gt;
  &lt;p&gt;jshint는 무시하시고, bugfix와 관련 없는 코드는 수고스럽더라도 되돌려놓는 게 좋겠습니다. upstream에 bug patch를 보낼 때도 문제가 될 것입니다.&lt;/p&gt;
&lt;/blockquote&gt;
    &lt;blockquote class=&quot;quotes&quot;&gt;
  &lt;p&gt;Done&lt;/p&gt;
&lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;컨벤션-체크&quot;&gt;컨벤션 체크&lt;/h3&gt;

&lt;p&gt;리뷰어가 컨벤션(code convention)을 지적하는 경우가 있는데 그렇게 좋은 신호는 아닙니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;리뷰어가 전반적인 로직/기능을 이해하지 못해서 컨벤션이나 일반적인 로직 리뷰만 함&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;명확히 수립된 컨벤션이 팀 내에 전파되지 않음&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컨벤션에 없는 스타일에 대한 지적은 &lt;a href=&quot;/deepscan/assets/images/code-review-17.jpg&quot;&gt;매우 민감&lt;/a&gt;한 문제. 가이드에 있다면 따라야 하지만, 그렇지 않은 경우는 개발자마다 스타일이 다르므로 코멘트하지 않는 게 좋습니다. 정 스타일을 용납(?)할 수 없으면 공론화해서 가이드에 포함해야 합니다. Promise-then의 indentation이 굉장히 민감하게 대두한 기억이 나네요^^;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table class=&quot;compare&quot;&gt;
&lt;tr&gt;&lt;th&gt;개행으로 이어지는 코드는 가이드에 따라 8칸 띄운다!&lt;/th&gt;&lt;th&gt;Promise-then은 로직이 연결되므로 해당 로직의 블록에 맞춘다!&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;
&lt;pre data-line=&quot;4-5&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function f() {
    function inner() {
        return getPerson1()
        .then(getPerson2)
        .then(getPerson3);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;td&gt;
&lt;pre data-line=&quot;4-5&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;function f() {
    function inner() {
        return getPerson1()
                   .then(getPerson2)
                   .then(getPerson3);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;사람에 의한 컨벤션 리뷰는 감정이 상하기 쉽고 주요 로직 리뷰의 시간을 빼앗으므로 기계가 하도록 자동화하는 게 좋습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;개발자가 Gerrit에 코드를 커밋한다.&lt;/li&gt;
  &lt;li&gt;코드 커밋 상황이 트리거(&lt;a href=&quot;https://wiki.jenkins-ci.org/display/JENKINS/Gerrit+Trigger&quot;&gt;Gerrit Trigger&lt;/a&gt;)가 되어 CI에서 빌드가 수행된다.&lt;/li&gt;
  &lt;li&gt;빌드에서 jshint나 eslint에 의한 체크를 수행한다.&lt;/li&gt;
  &lt;li&gt;체크 결과를 Gerrit의 코멘트로 등록한다. (Gerrit REST API 이용)&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;image-wrapper&quot;&gt;
  
      &lt;img src=&quot;https://cimfalab.github.io/deepscan//assets/images/code-review-10.png&quot; alt=&quot;Convention checking&quot; /&gt;
  
  
      &lt;p class=&quot;image-caption&quot;&gt;Gerrit comment for convention checking&lt;/p&gt;
  
&lt;/div&gt;
&lt;div class=&quot;image-wrapper&quot;&gt;
  
      &lt;img src=&quot;https://cimfalab.github.io/deepscan//assets/images/code-review-11.png&quot; alt=&quot;Convention checking&quot; /&gt;
  
  
      &lt;p class=&quot;image-caption&quot;&gt;Details for convention checking&lt;/p&gt;
  
&lt;/div&gt;

&lt;p&gt;컨벤션을 초기에 명확하게 수립하고 다듬어 가면서 해당 규칙을 linter 같은 도구의 룰로 만들고 코드 커밋 시마다 체크하도록 하는 것이 좋습니다.&lt;/p&gt;

&lt;p&gt;자동화하면 사람이 할 때처럼 놓치는 것도 없고 사람한테 지적당했을 때의 감정 상함이 없으며 리뷰어들의 시간을 아끼게 됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.slideshare.net/shinvee/ss-52215845&quot;&gt;도도와 파이썬: 좋은 선택과 나쁜 선택&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://ohgyun.com/551&quot;&gt;Git: Pull Request 가 들어오면 젠킨스로 테스트 돌리기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/32043227/how-to-integrate-eslint-with-jenkins&quot;&gt;How to integrate Eslint with jenkins?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;리뷰-언어&quot;&gt;리뷰 언어&lt;/h3&gt;
&lt;p&gt;리뷰 코멘트(comment) 작성을 한글로 할지 영어로 할지도 미리 정하는 것이 좋습니다.&lt;/p&gt;

&lt;p&gt;제 경우에는 커밋 메시지, 코드 주석은 영어로 하고 리뷰 코멘트는 한글로 하는 것을 선호합니다.
물론 리뷰 대상 코드가 외국 개발자와 협업 중인 것이라면 당연히 영어로 코멘트를 달아야겠지만, 그 외의 경우에는 한글로 작성하는 것이 좋다고 생각합니다.&lt;/p&gt;

&lt;p&gt;내부 개발에서 한글 코멘트를 사용하다가 영어로의 전환 얘기가 실제로 나왔었을 때 개발자들 사이에서 오갔던 의견들을 정리해 보았습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;영어 코멘트 선호
    &lt;ul&gt;
      &lt;li&gt;해외 개발자 협업이나 추후 오픈 소스화 가능성을 생각한다면 영문으로 작성해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;한글 코멘트 선호
    &lt;ul&gt;
      &lt;li&gt;한글 코멘트를 허용해보니 코멘트의 질이 달라지더라. 영어만 허용했을 때는 영어로 간단히 작성하기 어려운 내용의 경우 그냥 오프라인에서 직접 물어보게 되고 이력이 남지 않았는데 한글 허용이 되니 구체적으로 상세히 적을 수 있게 되어 온라인으로 의사소통이 잘 되고 이력도 잘 남아 다른 사람이 보고 참고하기에도 좋았다.&lt;/li&gt;
      &lt;li&gt;더 편하게 코멘트를 달게 되면서 개발자들에게 긍정적인 영향(리뷰의 선순환)을 미치고 있어 보인다.&lt;/li&gt;
      &lt;li&gt;개발자들의 영어 실력이 천차만별이라 영어만 허용 시 추가되는 비용이 생각보다 크다. 개발자들이 리뷰 코멘트나 답변을 영문으로 쓰면 문맥을 의도한 대로 전달하기 어렵고 머릿속에서 번역해서 써야 하므로 리뷰 시간이 더 걸린다.&lt;/li&gt;
      &lt;li&gt;향후 오픈 소스가 되더라도 외부 개발자들이 커밋 로그를 참고하지 예전의 리뷰 코멘트까지 보지는 않을 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;한글로 계속 작성해 오던 개발자들의 관성일 수도 있겠지만^^;
개발자들이 코드에 대해 편하게 얘기할 수 있다는 장점이 큰 것 같습니다.&lt;/p&gt;

&lt;p&gt;아 그리고 커밋 메시지는 제목과 내용을 통해 무엇을 수정하기 위한 커밋인지 잘 드러내야 합니다. 바람직한 커밋 메시지에 대해서는 &lt;a href=&quot;http://haruair.com/blog/2683&quot;&gt;이 글&lt;/a&gt;을 참고하세요.&lt;/p&gt;

&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap-Up&lt;/h2&gt;

&lt;p&gt;1년여간 코드 리뷰를 하면서 느꼈던 코드 리뷰 문화에 대해 정리해 보았습니다.&lt;/p&gt;

&lt;p&gt;여러분은 어떻게 리뷰하고 계신가요?
코드 리뷰는 ‘문화’이기 때문에 동료 개발자들을 존중하면서 시행착오도 거쳐 가며 팀 상황에 맞는 절차와 방법을 찾아 자연스럽게 정착시켜가야 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://sv-story.blogspot.kr/2013/04/blog-post_28.html&quot;&gt;이 글&lt;/a&gt;에도 있지만, &lt;strong&gt;코드 리뷰를 배우는 가장 좋은 방법은 코드 리뷰를 잘하는 사람에게 리뷰를 받는 것&lt;/strong&gt;이더라고요. 저도 팀원들의 다양한 리뷰를 받고 보고 또 동료의 코드를 리뷰하면서 많이 배웠고 큰 기술 기업에서나 하는 거라고 어렵게 생각했던 코드 리뷰에 대한 두려움이 없어진 것 같습니다.&lt;/p&gt;

&lt;p&gt;다음에는 코드 리뷰 동안에 수집된 JavaScript의 코드 개선 사례와 팁을 공유하겠습니다.&lt;/p&gt;

&lt;p&gt;Code wins arguments!&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.dramancompany.com/2016/05/%EB%93%9C%EB%9D%BC%EB%A7%88%EC%9D%98-pair-programming%EA%B3%BC-code-review-%EB%8F%84%EC%9E%85-%ED%9B%84%EA%B8%B0/&quot;&gt;드라마의 Pair Programming과 Code Review 도입 후기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://tech.kakao.com/2016/02/04/code-review/&quot;&gt;카카오스토리 팀의 코드 리뷰 도입 사례 - 코드 리뷰, 어디까지 해봤니?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://sv-story.blogspot.kr/2013/04/blog-post_28.html&quot;&gt;코드 리뷰는 어떻게 하나요?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://realm.io/kr/news/codereview-howto/&quot;&gt;GitHub의 Pull Request를 통한 코드리뷰&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.outsider.ne.kr/1199&quot;&gt;Pull Request를 이용한 개발 흐름을 적용해 보고 나서…&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  
  <entry>
    <title>오픈 소스 검증 사례 - Intel HTML5 Web Apps (2)</title>
    <link href="/deepscan/2016/08/intel-webapps-2?utm_source=RSS&amp;utm_medium=RSS&amp;utm_campaign=/2016/08/intel-webapps-2"/>
    <updated>2016-08-10T12:00:00+00:00</updated>
    <id>/deepscan/2016/08/intel-webapps-2</id>
    <content type="html">&lt;blockquote class=&quot;preface&quot;&gt;
  &lt;p&gt;오픈 소스 프로젝트의 코드 오류에 관한 시리즈입니다.&lt;/p&gt;

  &lt;p&gt;개발 중인 정적 분석기의 유용성 검증, 코드 오류 패턴 수집 등의 목적으로 JavaScript 기반의 오픈 소스 프로젝트를 분석기로 진단해 보게 되었고 공유할 만한 내용을 추려 시리즈로 연재합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;오늘은 지난 시간에 이어 Intel의 HTML5 Web Apps에 대해 3가지 사례를 추가적으로 소개하고 마무리하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로젝트명: HTML5 Web Apps&lt;/li&gt;
  &lt;li&gt;프로젝트 사이트: https://01.org/html5webapps&lt;/li&gt;
  &lt;li&gt;프로젝트 설명: 최신 웹 기술 전시용으로 HTML5, JavaScript 그리고 CSS3만으로 작성된 순수 웹앱 샘플을 제공합니다. 샘플은 게임, 유틸리티 등 다양한 종류로서 20개가 제공됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;annex&quot;&gt;Annex&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://01.org/html5webapps/online/annex/&quot;&gt;Annex&lt;/a&gt;는 바둑돌 게임입니다.
DOM 조작과 JavaScript로 구현된 AI 엔진을 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://01.org/sites/default/files/styles/webapp_screenshots/public/webapps/annex2.png?itok=y8Fl0cY_&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제가 개발 중인 JavaScript 정적 분석기로 해당 앱의 소스를 크롤링해서 분석해 보았습니다.
브라우저 호환성과 false alarm을 제외하면 다음과 같은 코드 오류가 있다고 나왔네요.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;For array, consider using for loop instead of for-in.&lt;/td&gt;
      &lt;td&gt;js/annex.js:49&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;‘return ret’ of Asynchronous Callback $.getJSON(“_locales/en/messages.json”, function (data) { … }).error has no effect.&lt;/td&gt;
      &lt;td&gt;js/dialogs.js:609&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;The value assigned to variable board is never used.&lt;/td&gt;
      &lt;td&gt;js/annex.js:454&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;배열에-대한-for-in-loop-사용&quot;&gt;배열에 대한 for-in loop 사용&lt;/h3&gt;
&lt;p class=&quot;notice&quot;&gt;&lt;strong&gt;js/annex.js:&lt;/strong&gt; For array, consider using for loop instead of for-in.&lt;/p&gt;

&lt;p&gt;배열에 for-in loop을 사용하는 것에 대해 경고하고 있습니다.&lt;/p&gt;

&lt;pre class=&quot;line-numbers&quot; data-start=&quot;47&quot; data-line=&quot;3&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;		init: function(play){
			this.playerNum = play || 1;
			for (var i in this.board){
				for (var j=0; j&amp;lt;this.bounder; j++){
					this.board[i][j] =  'board';
				}
			}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;배열에 대해 for-in loop 사용을 권장하지 않는 이유는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;for-in loop는 &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;나 배열의 &lt;code class=&quot;highlighter-rouge&quot;&gt;forEach&lt;/code&gt; 함수 대비 성능이 느립니다.&lt;/li&gt;
  &lt;li&gt;for-in loop에서 사용되는 변수(위 코드의 &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;)는 배열의 인덱스를 의미하는데 배열의 실제 아이템으로 혼동하기 쉽습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hasOwnProperty&lt;/code&gt; 체크를 항상 사용하는 것이 좋습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;아래 코드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;hasOwnProperty&lt;/code&gt; 체크가 필요한 상황을 보여줍니다.&lt;/p&gt;

&lt;pre class=&quot;line-numbers&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;Array.prototype.contains = function(value) {
    for (var key in this) {
        if (this[key] === value) {
            return true;
        }
    }
    return false;
};

var arr = [1, 2];
for (var i in arr) {
    console.log(i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for-in loop는 객체가 갖고 있는 prototype 객체의 속성들(위 코드의 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;contains&lt;/code&gt; 함수)까지 포함하기 때문에 출력 결과가 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0
1
contains
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;인덱스 0, 1 외에 contains가 포함되는