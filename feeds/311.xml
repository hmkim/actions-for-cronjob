<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The Pragmatic Programmer</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://eclatant.io/"/>
  <updated>2019-04-07T16:58:18.307Z</updated>
  <id>https://eclatant.io/</id>
  
  <author>
    <name>Jeewhan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>카카오와 네이버를 통한 소셜 로그인</title>
    <link href="https://eclatant.io/2019/04/08/2019-04-08-KakaoAndNaver/"/>
    <id>https://eclatant.io/2019/04/08/2019-04-08-KakaoAndNaver/</id>
    <published>2019-04-07T15:00:00.000Z</published>
    <updated>2019-04-07T16:58:18.307Z</updated>
    
    <content type="html"><![CDATA[<p>2월 말부터 정말 지독한 슬럼프? 번아웃?에 시달려왔다. 부디 이번에 작업했던 결과물들을 회고하는 과정을 통해 탈출할 수 있기를 바라는 마음으로 미뤄왔던 회고글을 작성해본다. 업무상 다급하게 진행했던 과정들이었기에 기재한 내용들에 대해 엄밀한 검증을 거치지 못하고 느낌만으로 작성하는 글이다.</p><hr><p>스프린트라고 말하기엔 민망한 긴 기간동안 소셜 로그인 기능을 추가하는 작업을 진행했다.</p><p>여러 Provider가 존재하겠지만, 이번에 진행했던 것은 카카오와 네이버를 통한 회원가입 및 로그인이었다.</p><p>카카오와 네이버는 기본적으로 SDK를 제공해주지만 둘은 여러 가지 측면에서 차이가 존재한다.</p><ol start="0"><li>신고제 VS 허가제<br>카카오는 신고제 느낌인데 비해 네아로(= 네이버 아이디로 로그인, 네이버 문서에도 나오는 명칭)는 개발 후에 검수를 거쳐서 심사를 통과해야만 사용할 수 있다.</li><li>Service URL, Callback URL<br>SDK를 통해 로그인 관련 정보를 Service URL과 Callback URL를 합친 주소로 받아오기 마련이다. 카카오는 Callback URL이 하나인 대신에 Service URL을 여러 개 사용할 수 있고, 네이버는 반대로 Service URL 하나와 여러 Callback URL을 사용할 수 있다. 실제로 구현해보면 카카오가 훨씬 더 편하다는 점을 알 수 있다. 로컬호스트로 개발할 때, 스테이징 서버를 배포했을 때, 프로덕션에 배포했을 때 모두를 지원할 수 있기 때문이다. 그에 비해서 네이버는 검수 요청을 하려면 기본적으로 배포를 해야 하고, 그렇게 되면 로컬호스트로는 이용할 수 없는 상태가 되어버린다. (또는 프로덕션에 배포했을 때도 마찬가지이다.) 네이버 + 로컬호스트 관련해서 몇 시간 정도 시행착오를 겪었던 지점이 있는데, Service URL을 반드시 <code>http://localhost:3000</code> 로 작성해야 기대한 방향대로 동작할 것이다. 설정하는 페이지에는 <code>서비스 URL: 실제 서비스하는 사이트 URL과 동일한지 확인 (www, 포트번호, http/https 구분 없이 도메인명만 정확히 입력)</code> 라고 나와있지만 실제로는 뒤에 포트도 기재되어야 한다.</li><li>SDK<br>네아로가 상대적으로 더 오래된 기능이어서 그런지, API와 문서화 모두 카카오만 기대에 부응하는 편이다. 네아로 관련 문서에서 튜토리얼은 2.0을 기준으로 설명하고 있는데, API 명세는 1.03을 기준으로 설명되어있다. 그 다음에 굳이 매번 API 사용 전에 반복적으로 new로 인스턴스를 생성하고 init method를 통해 초기화를 해주어야 하며, 로그인 버튼을 활용한 콜백 패턴 외에는 달리 Access Token을 받아올 방법을 찾을 수 없었다. 네이버/카카오를 통한 회원가입 뿐만 아니라  이미 가입된 계정에서의 연동도 지원해주어야 했는데, 네이버는 어쩔 수 없이 SDK에서 제공해주는 로그인 버튼을 숨겨두었다가 연동 설정 요청이 들어오면 숨겨둔 버튼을 클릭하여 redirect path에서 Access Token을 받아서 우리측 API에 보내주어야만 했다. 카카오는 초기화를 한 번만 해주면 되며, 연동의 경우에도 Kakao.Auth.login으로 바로 구현이 가능하다.</li><li>Flow<br>로그인 관련 정보를 받아오는 플로우에 있어서 차이가 존재한다. 네이버는 SDK를 통해 정보를 받아오면서 redirect path로 보내지지만, 카카오는 redirect path로 이동한 뒤에 요청해서 받아오는 플로우라고 기억한다. SocialSignupPage라는 Component 하나로 둘 모두 지원해주려고 했기 때문에 카카오는 SDK에서 제공해주는 로그인 버튼을 사용하지 않고, 카카오로 로그인 이라는 버튼을 클릭하면 redirect path로 직접 보낸 뒤 /naver 와 /kakao 중 kakao일 경우 SDK에서 제공해주는 함수(Kakao.Auth.login)를 이용하여 직접 Access Token을 받아오도록 하였다. (네이버는 플로우를 달리 커스텀할 수 있는 방법이 보이지 않았다.)</li><li>Mobile<br>카카오는 모두 쉽다고 생각했었지만 모바일에서 문제가 한 번 있었다. 데스크탑이라면 카카오 로그인을 끝내고  로그인 창이 꺼지고 Access Token을 알아서 받아오는 과정이 진행될텐데 모바일에서는 빈 탭이 띄워져있는 상태에서 멈춰져있고 Access Token도 받아와지지 않았다. 카카오 측에서 제공해주는 데모 페이지에서는 일어나지 않는 현상이고, 그곳에 있는 코드와 큰 차이가 없어서 원인을 파악하는데 시간을 많이 소모하였다. 결론적으로는 throughTalk라는 옵션을 false로 처리하면 해결이 된다. 이 옵션은 default: true인데 이때는 스키마를 통해 카카오톡을 불러오는 과정에서 뭔가 문제가 있어서 멈췄던 것으로 추측하고 있다. (운영체제가 업데이트되어서 관련 로직이 바뀌었는데 아직 대응이 안 되었다든지 등)</li></ol><p>이상이 현재 기억나는 카카오와 네이버 관련해서 겪었던 이슈들이다. 다음 글에서는 위 기능을 구현하는 과정에서 리팩토링을 하기 위해 어떤 구조를 택하게 되었고 TypeScript를 일부 도입하는 등 프로젝트와 관련된 내용들을 기술해보려고 한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2월 말부터 정말 지독한 슬럼프? 번아웃?에 시달려왔다. 부디 이번에 작업했던 결과물들을 회고하는 과정을 통해 탈출할 수 있기를 바라는 마음으로 미뤄왔던 회고글을 작성해본다. 업무상 다급하게 진행했던 과정들이었기에 기재한 내용들에 대해 엄밀한 검
      
    
    </summary>
    
      <category term="Dev" scheme="https://eclatant.io/categories/Dev/"/>
    
    
      <category term="Dev" scheme="https://eclatant.io/tags/Dev/"/>
    
  </entry>
  
  <entry>
    <title>리팩토링의 순서</title>
    <link href="https://eclatant.io/2019/02/25/2019-02-25-Refactoring-Order/"/>
    <id>https://eclatant.io/2019/02/25/2019-02-25-Refactoring-Order/</id>
    <published>2019-02-24T15:00:00.000Z</published>
    <updated>2019-02-24T15:54:40.449Z</updated>
    
    <content type="html"><![CDATA[<p>회사에서 맡게 된 두 가지 프로젝트가 있다.</p><p>하나는 잘못된 기술 스택과 당시의 악조건으로 인해 객관적(?)으로 심폐소생술이 어려워 새롭게 만들어야 한다.</p><p>나머지 하나는 React로 만들어져있고, 새롭게 만들 필요까지는 없으나 프로젝트 전체적으로 리팩토링을 해야 한다.</p><p>Redux로 되어있는 프로젝트이다.<br>하지만 오직 App component 하나에만 connect가 되어있고, 메서드의 다수는 데이터가 아닌 DOM의 className 등을 기반으로 조건처리가 되어있고, Page에 해당하는 component들은 1200 ~ 1500라인 정도 된다.<br>(React, Redux를 해본 사람들이라면 대략적으로 어떤 상태인지 짐작할 수 있으리라.)</p><p>머릿속에 떠오른 수많은 개선 아이디어들이 있었다. (아래는 그중 일부 예시이다.)</p><ul><li>Desktop과 Mobile로 나뉘어져있는 component의 공통점을 추출해서 중복을 없애고 같은 것들을 한 곳에서 처리하도록 한다</li><li>render method의 대부분이 html tag 그대로 기재되어있는 것들을 최대한 presentor로 분리해낸다</li><li>프로젝트 전반에 대한 도메인을 파악한다 <a href="https://adhrinae.github.io/posts/ui-as-an-afterthought-kr" target="_blank" rel="noopener">https://adhrinae.github.io/posts/ui-as-an-afterthought-kr</a></li><li>현재 너무나 많은 props를 주입받고 있고, 그것들에 대해 제대로 된 관리가 되어있지 않으므로 prop-types를 도입한다</li><li>API 문서가 부족한 부분에 대해 TypeScript를 통해 타이핑을 한다</li><li>Redux-saga를 도입해서 가독성을 높인다</li><li>Ducks 패턴을 도입해서 action types, action creators, reducer와 같이 레이어 단위로 나뉘어져있는 파일들을 도메인을 기준으로 나눈다</li><li>redux-batch 등을 활용해서 특정 action에서 dispatch가 여러 번 이루어지는 것을 방지한다</li><li>hooks를 사용해서 보다 간결한 component를 만든다</li><li>antd를 도입해서 전형적인 component들을 대체한다</li><li>…</li></ul><p>당연하게도(?) 테스트 코드는 없기 때문에, 기존 프로젝트가 깨지지 않는다는 것을 쉽게 확인할 수 있어야만 덜 걱정하며 배포할 수 있을 것이다.</p><p>그런 측면에서 점진적으로 개선시켜나가는 것은 대단히 중요하고, 어떠한 작업을 하든 의식적으로 대단히 작은 단위로 나누어 작업하면서 계속해서 확인하고, 그것을 commit으로 나누어 기록해야만 한다는 점은 이러한 작업의 대원칙일 것이다.</p><p>그 다음으로 고민했던 지점은 저 수많은 개선점들을 어떠한 순서로 행할 것인가였다.</p><p>처음에는 각각의 개선점이 가져다 줄 생산성과 그것을 위한 역생산성(비용)을 따져보려고 했었다. (역생산성과 관련하여 Redux와 TypeScript를 선호하지 않는데, 관련된 내용은 나중에 조금 더 경험이 쌓인 뒤에 작성해보려고 한다.)<br>또는 비용과 난이도가 낮은 것부터 해봐야겠다고 생각도 했었다.</p><p>하지만 특정 지점에 대해서 프로젝트 전체를 개선시키고 그 작업이 끝나면 다음 개선지점을 프로젝트에 적용하는 방식으로 진행하기에는 상황적으로 무리가 있다고 판단하였다.</p><p>그렇다면 주어지는 테스크를 수행해나가면서 그것과 관련된 부분에 대해서만이라도 <a href="https://johngrib.github.io/wiki/Boy-Scout-Rule/" target="_blank" rel="noopener">보이 스카웃 규칙</a>을 적용하는 수 밖에 없지 않은가.</p><p>그랬을 때 무엇부터 적용할지에 대해서 다시 고민해보고 내린 결론은 다음과 같았다.<br>(함수형에서 대표적으로 쓰이는 컬렉션 함수들을 예시로 들겠다.)</p><ol start="0"><li>Filter</li></ol><ul><li>기존 코드에서 쓰이지 않는 것들을 없애는 것을 최우선으로 한다. (이런 것들이 생긴 것은 아마도 <a href="https://zetawiki.com/wiki/YAGNI" target="_blank" rel="noopener">YAGNI</a> 때문일 것이다.) 왜냐하면 적용했을 때의 사이드이펙트도 가장 적을 것이고, 수행하는 것에 있어서도 가장 쉬울 것이기 때문이다.</li></ul><ol><li>Reduce</li></ol><ul><li>기존에 중복되어있거나 장황하게 되어있던 부분을 추상화한다. 이때의 접근방식은 기존 것을 유지한 상태로, 기존 것과 동일하다고 믿어지는(?) 추상물을 만들어서 교체해보았을 때 같은 결과가 나오면 그제서야 기존 것을 제거한다.</li></ul><ol start="2"><li>Map</li></ol><ul><li>기존 것과 같은 기능을 다르게 수행하는 것을 만든다. 비동기와 관련된 로직은 Saga가 아닌 Thunk로도 가능하다. 들어가는 비용은 적지 않은데 결과는 같으니, 내 스스로는 가독성이나 생산성이 개선된다고 생각하더라도 어느 지점에선 만족감만을 위한 작업일 가능성도 높으니 가장 후순위로 미룬다.</li></ul><p>현재는 고민을 끝낸지 얼마 되지 않았고, 그동안 리팩토링 등과 관련한 책들을 구매만 해두고 읽어보지 못해서 이론과 경험을 쌓아가며 더 나은 방법론을 만들어가려고 한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;회사에서 맡게 된 두 가지 프로젝트가 있다.&lt;/p&gt;
&lt;p&gt;하나는 잘못된 기술 스택과 당시의 악조건으로 인해 객관적(?)으로 심폐소생술이 어려워 새롭게 만들어야 한다.&lt;/p&gt;
&lt;p&gt;나머지 하나는 React로 만들어져있고, 새롭게 만들 필요까지는 없
      
    
    </summary>
    
      <category term="Dev" scheme="https://eclatant.io/categories/Dev/"/>
    
    
      <category term="Dev" scheme="https://eclatant.io/tags/Dev/"/>
    
  </entry>
  
  <entry>
    <title>루비 인터뷰 질문</title>
    <link href="https://eclatant.io/2019/02/23/2019-02-23-Ruby/"/>
    <id>https://eclatant.io/2019/02/23/2019-02-23-Ruby/</id>
    <published>2019-02-22T15:00:00.000Z</published>
    <updated>2019-02-23T16:40:51.267Z</updated>
    
    <content type="html"><![CDATA[<p>symbol과 string의 차이는 무엇인가요?</p><ul><li>symbol은 string과 다르게 불변 객체, heap 메모리에 생성되고 나면 동일한 객체로 재사용 가능, 따라서 성능 측면에서 유리</li><li>heap이란 구조화되지 않은 메모리영역, 실행 컨텍스트는 스택, 이벤트 루프는 큐로 관리</li></ul><p>self 는 무엇인가요?</p><ul><li>self는 소속객체를 가리킴, self를 이용해 만든 메서드는 클래스 메서드, 그렇지 않은 메서드는 인스턴스 메서드</li></ul><p>생성자(constructor)을 사용하는 방법은 무엇인가요?</p><ul><li>initialize</li></ul><p>Ruby가 dynamic programming language 임을 나타내는 특징들은 무엇인가요?</p><ul><li>런타임시에 클래스에 멤버 변수, 메서드 추가 삭제 재정의 등이 가능</li></ul><p>동적인 함수명을 실행(invoke) 하는 방법을 설명하세요.</p><ul><li>send</li></ul><p>||= 의 역할은 무엇인가요?</p><ul><li>a ||= b의 경우, a가 falsy value일 경우, a에 b를 할당</li></ul><p>Class와 Module 의 차이는 무엇인가요?</p><ul><li>목적, 클래스는 인스턴스를 만들기 위해서, 모듈은 메서드를 제공해주기 위함</li></ul><p>조건연산자 중 and 와 &amp;&amp; 의 차이는 무엇인가요?</p><ul><li>기능상 동일하나 and가 우선순위가 낮음</li></ul><p>Block, Proc, Lambda 의 차이가 무엇인가요?</p><ul><li>Proc : 익명함수(절차)를 담은 객체, .call()을 통해 호출가능 (기명함수와 차이가 존재)</li><li>Lambda : Proc 객체를 생성하는 방법, 인자 개수 준수, return과 break가 익명 함수 안으로 한정</li><li>Block : do ~ end 사이의 코드, 메서드에 블록을 넘겨주면 yield로 실행 가능, &amp; operator를 통해 지역 변수 대신 블록에 대한 참조를 인자로 전달 가능, return과 break가 블록 안으로 한정</li></ul><p>외부 파일을 참조하는 require, load, include, extend의 차이는 무엇인가요?</p><ul><li>load는 매번 새롭게 파일을 불러옴</li><li>require는 최초 한 번만 파일을 불러옴</li><li>include는 모듈의 메서드들을 인스턴스 메서드로 불러옴</li><li>extend는 모듈의 메서드들을 클래스 메서드로 불러옴</li></ul><p>clone과 dup, deep_dup의 차이는 무엇인가요?</p><ul><li>clone은 object 및 내부 상태를 복사하지만, dup는 새로운 인스턴스를 반환받음<ul><li>While clone is used to duplicate an object, including its internal state, dup typically uses the class of the descendant object to create the new instance.</li></ul></li><li>clone/dup의 shallow copy와 달리, deep_dup는 deep copy가 가능함</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;symbol과 string의 차이는 무엇인가요?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;symbol은 string과 다르게 불변 객체, heap 메모리에 생성되고 나면 동일한 객체로 재사용 가능, 따라서 성능 측면에서 유리&lt;/li&gt;
&lt;li&gt;heap이란 구조화되지
      
    
    </summary>
    
      <category term="Ruby" scheme="https://eclatant.io/categories/Ruby/"/>
    
    
      <category term="Ruby" scheme="https://eclatant.io/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>코딩 인터뷰 완전 분석</title>
    <link href="https://eclatant.io/2019/02/16/2019-02-16-CtCI/"/>
    <id>https://eclatant.io/2019/02/16/2019-02-16-CtCI/</id>
    <published>2019-02-15T15:00:00.000Z</published>
    <updated>2019-02-16T10:44:48.032Z</updated>
    
    <content type="html"><![CDATA[<h2>면접관련</h2><h3>면접에서의 평가기준</h3><h4>분석 능력</h4><ul><li>문제를 푸는 데 도움을 많이 받았나?</li><li>최적화를 얼마나 했나?</li><li>문제를 푸는 데 시간이 얼마나 소요됐나?</li><li>디자인/설계를 할 때에 문제의 체계를 제대로 세우고 다양한 방법에 대한 장단점을 생각해 봤는가?</li></ul><h4>코딩 능력</h4><ul><li>알고리즘을 적절한 코드로 표현할 수 있나?</li><li>깔끔하고 잘 구성되어 있나?</li><li>가능한 에러에 대해 생각해 봤나?</li><li>코드 스타일은 훌륭한가?</li></ul><h4>기술적 지식 및 컴퓨터 과학 기본</h4><ul><li>컴퓨터 과학 및 관련 기술에 대한 기본기가 출중한가?</li></ul><h4>경험</h4><ul><li>과거에 기술적 결정을 해본 적이 있는가?</li><li>흥미롭고 도전적인 프로젝트를 해본 적이 있는가?</li><li>진취성, 결단성, 그 외 다른 중요한 요소를 내보인 적이 있는가?</li></ul><h4>문화와 얼마나 맞는지 / 의사소통능력</h4><ul><li>지원자의 성격과 가치가 회사에 잘 맞는가? 면접관과 의사 소통이 잘 되었는가?</li></ul><p>a^3 + b^3 = C^3 + d^3을 만족하는 1,000 이하의 자연수를 모두 찾기</p><h3>이력서의 프로젝트에 대한 설명</h3><h4>Y를 구현해서 X를 성취했고, 그 결과 Z를 이루었다</h4><ul><li>무엇을 했는지, 어떻게 했는지, 그리고 결과는 어떠하였는지를 적으라. 이상적으로는, 결과를 가급적 ‘측정 가능한’ 형태로 제시하는 것이 좋다.<ul><li>“분산 캐시를 구현해서 오브젝트 렌더링 시간을 75% 줄였고,그 결과 로그인 시간을 10% 경감할 수 있었다</li><li>“wincliff에 기반한 새로운 비교 알고리즘을 구현한 결과, 평균 비교 정확도를 1.2에서 1.5로 개선했다</li></ul></li></ul><h4>질문에 대한 답변</h4><ul><li>행위 문제에 구조적으로 대답을 할 때 널리 쓰이는 두가지 방법이 있다. 유용한 정보 우선 (nugget first)과 S,A,R이다. 이 두 기술은 개별적으로 사용할 수도 있고, 같이 사용할 수도 있다.</li><li>유용한 정보우선<ul><li>유용한 정보(nugget)를 우선적으로 전달한다는 것은, 서두에 답변의 내용을 간결히 요약하는 것을 말한다.</li></ul></li><li>S.A.R<ul><li>상황, 행위, 결과 접근법 즉 S.A.R.(Situation, Action, Result) 접근법은 상황을 요 약하는 것으로부터 출발하여, 여러분이 어떤 행동을 했는지를 설명하고, 그 결과를 기술하는 접근법이다</li></ul></li><li>취했던 행동에 대해 논하라<ul><li>대부분의 모든 경우에 ‘행동’이 이야기 에서 가장 중요한 부분이다. 하지만 너무나도 많은 사람이 그 당시 상황에 대해서는 쉼 없이 말을 늘어 놓지만 취했던 행동에 대해서는 아주 간단하게 언급하고 넘어간다. 그러지 말고 어떤 행동을 취했는지 갚이 있게 설명하라. 어떤 행동을 취했는지 가능한 여러 부분으로 나누어 말하라. 예를들어 “다음 세 가지 행동을 취했습니다. 우선,저는 -” 같은 방식으로 설명하면 충분히 깊이있는 설명을 할 수 있다.</li></ul></li></ul><p><img src="http://slideplayer.com/5041115/16/images/6/Examples+of+Algorithms+and+their+big-O+complexity.jpg" alt="img"></p><h3>시간복잡도</h3><ul><li>점근적 실행 시간</li><li>그 중에서 Big O 표기법은 점근적 시간의 상한을 뜻한다<ul><li>계산 복잡도를 그래프로 나타내었을 때, 최악의 경우에도 알고리즘의 계산 복잡도에 비교했을 때 같거나 그보다 높은 곳에 위치할 그래프이기에 상한이라 칭한다</li><li><a href="https://ratsgo.github.io/data%20structure&amp;algorithm/2017/09/13/asymptotic/" target="_blank" rel="noopener">점근적 표기법</a></li></ul></li><li>업계에선 Big O 표기법을 Big theta, 즉 수행 시간에 딱 맞추어 표기하려고 하는 경향이 있다</li><li>대부분의 알고리즘은 최악의 경우와 평균적인 경우가 같다</li></ul><h3>공간복잡도</h3><ul><li>시간복잡도와 평행선을 이룸</li><li>재귀 호출에 쓰이는 스택 공간도 포함됨<ul><li>꼬리 재귀 호출을 충족한다면 해당되지 않는다</li></ul></li></ul><h3>상수항은 무시하라, 지배적이지 않은 항을 무시하라</h3><ul><li>Big O 표기법은 데이터의 증가에 따른 점근적 실행 시간의 변화증가율을 나타내기 위한 것이므로 무시한다</li><li>O(N)이 언제나 O(2N)보다 나은 것은 아니다<ul><li>big-O는 단순히 증가하는 비율을 나타내는 개념이므로, 특수한 입력에 한해 O(N) 코드가 O(1) 코드보다 빠르게 동작하는 것은 매우 가능성 있는 얘기다.</li></ul></li></ul><h3>여러 부분으로 이루어진 알고리즘: 덧셈 VS 곱셈</h3><ul><li>A일을 모두 마치고 B일을 해야 한다면 A + B</li><li>A일을 할 때마다 B일을 해야 한다면 A * B</li></ul><h3>상환시간</h3><ul><li>ArrayList의 경우, 배열의 용량이 꽉 찼을 때, 기존보다 크기가 두 배 더 큰 배열을 만든 뒤, 이전 배열의 모든 원소를 새 배열로 복사한다, 이때 삽입 연산의 수행 시간은 기존의 모든 원소를 새 배열로 복사해야 하기에 O(N)이 소요된다, 그러나 배열에 가용 공간이 존재할 때 삽입 연산은 O(1)이 걸린다, 위 두 가지 경우를 포함한 전체 수행 시간을 따져볼 때 상환 시간이라는 개념을 이용한다, 최악의 경우는 가끔 발생하지만 해당 수행 시간을 나머지 경우에서 분할 상환한다는 개념이다, 위 케이스에서 배열의 크기가 2의 배수일 때 원소 삽입 연산에 O(N)이 소요된다, 이러한 N의 합은 X개의 원소를 삽입할 때 2X만큼 걸리므로 이를 분할 상환하면 삽입 한 번에 필요한 시간은 O(1)이다</li></ul><h3>log N 수행 시간</h3><ul><li>대표적인 케이스는 이진 탐색이다</li><li>탐색할 때마다 원소의 개수가 절반씩 줄어든다면, 수행 시간은 O(log N)일 가능성이 크다</li></ul><h3>재귀적으로 수행 시간 구하기</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> f(n - <span class="number">1</span>) + f(n - <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># return 1 if n &lt;= 1 else f(n - 1) + f(n - 1)</span></span><br></pre></td></tr></table></figure><ul><li>위 케이스의 수행 시간은 O(2^N)이다</li><li>트리의 깊이가 N이고, 각 노드는 두 개의 자식 노드를 가지고 있으므로 깊이가 깊어질 때마다 이전보다 두 배 더 많이 호출하게 되기 때문이다</li><li>다수의 호출로 이루어진 재귀 함수에서 수행 시간은 보통 O(분기^깊이)이다, 분기란 재귀 함수가 자신을 재호출하는 횟수를 뜻함</li><li>상수항 또는 로그의 밑과 다르게 지수의 밑은 무시하면 안 된다다</li><li>위 케이스의 공간복잡도는 O(N)이다</li></ul><h3>예제 및 연습 문제</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(array)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    product = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">        sum += array[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array)):</span><br><span class="line">        product *= array[i]</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"<span class="subst">&#123;sum&#125;</span>, <span class="subst">&#123;product&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">foo([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) <span class="comment"># O(N)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printPairs</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array)):</span><br><span class="line">            print(<span class="string">f"<span class="subst">&#123;array[i]&#125;</span>, <span class="subst">&#123;array[j]&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">printPairs([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) <span class="comment"># O(N^2)</span></span><br></pre></td></tr></table></figure><p>총 수행 시간을 헤아리는 것 외에도, 위 코드가 무엇을 의미하는지 살펴보는 것을 통해 구할 수도 있다<br>위의 코드는 모든 쌍을 출력하는 코드이다, 그러므로 쌍의 총 개수인 N^2과 동일</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnorderedPairs</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(array)):</span><br><span class="line">            print(<span class="string">f"<span class="subst">&#123;array[i]&#125;</span>, <span class="subst">&#123;array[j]&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">printUnorderedPairs([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) <span class="comment"># O(N^2)</span></span><br></pre></td></tr></table></figure><p>반복 횟수 세어보기, 코드가 무엇을 의미하는가, 결과를 그림으로 표현, 평균을 이용</p><p>반복 횟수의 합 : 1부터 N-1까지의 합은 N(N-1)/2<br>코드의 의미, 그림으로 표현 : 전체 쌍(사각형)의 절반<br>평균을 이용 =&gt; 바깥 루프는 N번, 안쪽 루프는 평균값으로 N/2<br>(1 ~ 10의 평균이 5이듯이 1 ~ N의 평균은 N/2이므로)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnorderedPairs2</span><span class="params">(array_a, array_b)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array_a)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array_b)):</span><br><span class="line">            <span class="keyword">if</span> array_a[i] &lt; array_b[j]:</span><br><span class="line">                print(<span class="string">f"<span class="subst">&#123;array_a[i]&#125;</span>, <span class="subst">&#123;array_b[j]&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">printUnorderedPairs2([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]) <span class="comment"># O(A*B)</span></span><br></pre></td></tr></table></figure><p>두 배열 각각의 크기를 알 수 없으므로, 크기를 모두 고려해야 하므로 O(A*B)이다</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnorderedPairs3</span><span class="params">(array_a, array_b)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array_a)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array_b)):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">                print(<span class="string">f"<span class="subst">&#123;array_a[i], &#123;array_b[i]&#125;</span>&#125;"</span>)</span><br><span class="line"></span><br><span class="line">printUnorderedPairs3([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]) <span class="comment"># O(A*B)</span></span><br></pre></td></tr></table></figure><p>100000은 상수항이므로 Big O에 영향을 미치지 못한다</p><p>P74</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array) // <span class="number">2</span>):</span><br><span class="line">        other = len(array) - i - <span class="number">1</span></span><br><span class="line">        array[i], array[other] = array[other], array[i]</span><br><span class="line"></span><br><span class="line">reverse([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) <span class="comment"># O(N)</span></span><br></pre></td></tr></table></figure><p>배열의 절반만 살펴본다고 해서 (반복횟수가 N의 절반이라고 해서) Big O에 영향을 끼치는 것은 아니다</p><p>P &lt; N/2 일 때, O(N+P) 는 O(N) (N이 지배적인 항이므로)<br>O(2N)은 O(N)<br>O(N + logN)은 O(N)<br>O(N+M)은 N과 M의 관계를 알 수 없다면 O(N+M)으로 표기해야 함</p><p>P75<br>여러 개의 문자열로 구성된 배열이 주어졌을 때, 각각의 문자열을 먼저 정렬하고<br>그 다음에 전체 문자열을 사전순으로 다시 정렬하는 알고리즘의 수행시간은 어떠하겠는가?<br>각 문자열을 정렬 =&gt; O(NlogN)<br>모든 문자열을 정렬 =&gt; O(N*NlogN)<br>전체 문자열을 사전순으로 정렬 =&gt; O(NlogN) 추가<br>따라서 O(N^2logN + NlogN)이므로 O(N^2logN)이다 는 완전히 잘못된 분석!</p><p>서로 다른 N을 혼용해서 쓰니까 위와 같은 오류를 범하게 된다<br>문자열의 길이를 나타낼 때와 배열의 길이를 나타낼 때를 구분하여 사용했어야 한다</p><p>변수 N을 사용하지 않거나 N이 가리키는 것이 명백한 경우에만 사용하라<br>연상 가능한 이름을 사용해서 새로운 변수를 정의하라</p><p>가장 길이가 긴 문자열의 길이를 s라 하자<br>배열의 길이를 a라 하자<br>각 문자열을 정렬하는데 O(slogs)<br>a개의 문자열이므로 O(a * slogs)</p><p>전체 문자열을 사전순으로 정렬해야 함, 총 a개의 문자열이 있어서 O(aloga)가<br>필요하다고 생각할 수 있지만, 문자열을 비교하는 시간도 고려해야 한다<br>두 문자열을 비교하는데 O(s)가 소요되며, 비교를 O(aloga)번 해야 하므로<br>결론적으로 O(s<em>aloga)가 소요됨<br>위 두 부분을 합치면 전체 시간 복잡도는 O(a</em>s(logs + loga))가 된다</p><p>P76</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumNode</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> node == <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> sumNode(node.left) + node.value + sum(node.right)</span><br></pre></td></tr></table></figure><p>균형 이진 탐색 트리에서 모든 노드의 값을 더하는 코드<br>이진 탐색 트리라는 이유로 log가 있을 것이라 착각해선 안 된다</p><p>코드가 무엇을 의미하는가<br>트리의 모든 노드를 방문해서 합을 구하는 것이므로, 노드의 개수와 선형 관계<br>O(N)</p><p>재귀호출 패턴 분석<br>재귀함수에 분기가 여러 개 존재할 때, 일반적으로 O(분기^깊이)가 된다<br>트리의 깊이는 N개에 대해 logN이다<br>분기가 2라면 2^logN이므로 O(N)이 된다</p><p>P77<br>N이 소수를 확인하려면 N의 제곱근까지만 확인해보면 된다</p><p>어떤 수의 제곱근이란 그 수가 갖는 약수들 중에 자신을 제외하고 가장 큰 수 라고 볼 수 있을 것 같아요.<br>소수라는게 1과 자기자신만을 약수로 가져야 하는데 또 다른 약수를 갖게 되면 안되는거니까 제곱근으로도 나누어 떨어지면 소수가 될 수 없는것이죠.<br>또한 제곱근 이상의 수로 나누게 되면 제곱근으로 나누었을 때보다 작은 몫을 결과로 반환하게 되서 제곱근 이하의 수로 나누었던 계산들을 반복하게 됩니다.<br>어떤 수를 2부터 제곱근까지의 수로 나눈다는 것을 그 수를 자신을 제외한 제수들로 나누었을 때 가질 수 있는 몫의 최소값(2)부터<br>최대값(제곱근)까지로 나눠 보는 것이라 생각하면 이해가 빠를 것 같아요.<br>수 25에서 제곱근 5는 25가 가질 수 있는 몫의 최대값입니다.<br>그리고 그 이상의 수로 나누었을 때는 제곱근(5) 이하의 값들을 몫으로 반환하기 때문에 2부터 4까지 나누는 계산과 같게 되서 의미가 없습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i ** <span class="number">2</span> &lt;= n:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>시간 복잡도는 O(√N)</p><p>P78</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * factorial(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>O(N)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(s, prefix=<span class="string">""</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">        print(prefix)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            rem = s[<span class="number">0</span>:i] + s[i+<span class="number">1</span>:]</span><br><span class="line">            permutation(rem, prefix + s[i])</span><br></pre></td></tr></table></figure><p>O(N^2 * N!)</p><p>순열의 종류가 모두 출력되니, O(N!)<br>순열을 조합하기 위해서 N개의 글자만큼의 호출이 필요하므로 O(N)<br>매 for문마다 문자열을 재조립하거나, 출력하는 것과 같은 O(N) 연산 소요</p><p>P79</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p>O(2^N)<br>재귀 호출 = 분기^깊이<br>재귀 호출이 여러 번 발생하면 지수 시간 알고리즘일 가능성이 큼</p><p>P80</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allFib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;i&#125;</span>: <span class="subst">&#123;fib(i)&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>O(2^N)</p><p>fib는 O(2^N)이 맞다, 그러나 전체 걸리는 시간은 O(N*2^N)이 아니다<br>그 이유는 각각의 호출시마다 N이 변화하기 때문이다<br>등비수열의 합공식에 따라 O(2^N+1)이 되므로 O(2^N)이다</p><p>P81</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allFib</span><span class="params">(n)</span>:</span></span><br><span class="line">    memo = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;i&#125;</span>: <span class="subst">&#123;fib(i, memo)&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n, memo)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>: <span class="keyword">return</span> memo[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">elif</span> len(memo) &gt; n <span class="keyword">or</span> n == <span class="number">1</span>: <span class="keyword">return</span> memo[n]</span><br><span class="line">    memo.append(fib(n<span class="number">-1</span>, memo) + fib(n<span class="number">-2</span>, memo))</span><br><span class="line">    <span class="keyword">return</span> memo[n]</span><br></pre></td></tr></table></figure><p>O(N)</p><p>상수 시간의 일을 N번 반복한다 (캐시값을 찾아서 더한 뒤 그 결과를 캐시 배열에 저장하고 반환)</p><p>P82</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">powers_of_2</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        print(n)</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        prev = powers_of_2(n // <span class="number">2</span>)</span><br><span class="line">        curr = prev * <span class="number">2</span></span><br><span class="line">        print(curr)</span><br><span class="line">        <span class="keyword">return</span> curr</span><br></pre></td></tr></table></figure><p>O(logN)</p><p>1이 될 때까지 절반씩 나누므로 log<br>해당 코드의 목적을 생각해보면, 1부터 n사이의 모든 2의 승수를 계산하고 출력하므로 함수의 호출 횟수는 승수의 개수와 동일하다<br>n이 커질수록 수행 시간이 어떻게 바뀌는가? n의 크기가 두 배가 될 때 호출 횟수가 한 번 증가한다 (2^x = n, x = logN)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P83</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(b):</span><br><span class="line">        sum += a</span><br><span class="line"><span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><p>O(N)</p><p>P84</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> b &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> b == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> a * power(a, b - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>O(N)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mod</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> b &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    div = a / b</span><br><span class="line">    <span class="keyword">return</span> a - div * b</span><br></pre></td></tr></table></figure><p>O(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">div</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    sum = b</span><br><span class="line">    <span class="keyword">while</span> sum &lt;= a:</span><br><span class="line">        sum += b</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>O(a/b)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrt</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sqrt_helper(n, <span class="number">1</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrt_helper</span><span class="params">(n, mi, ma)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> ma &lt; mi: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    guess = (mi + ma) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> guess * guess == n: <span class="keyword">return</span> guess</span><br><span class="line">    <span class="keyword">elif</span> guess * guess &lt; n: <span class="keyword">return</span> sqrt_helper(n, guess + <span class="number">1</span>, ma)</span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> sqrt_helper(n, mi, guess - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>O(logN)</p><p>P85</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrt</span><span class="params">(n)</span>:</span></span><br><span class="line">    guess = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> guess * guess &lt;= n:</span><br><span class="line">        <span class="keyword">if</span> guess * guess == n:</span><br><span class="line">            <span class="keyword">return</span> guess</span><br><span class="line">        guess += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>O(√N)</p><p>이진 탐색 트리가 균형 잡혀있지 않을 때, 원소를 찾는데 걸리는 최악의 경우<br>O(N)</p><p>이진 트리가 이진 탐색 트리가 아닐 때 시간 복잡도<br>O(N)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyArray</span><span class="params">(array)</span>:</span></span><br><span class="line">    copy = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array:</span><br><span class="line">        copy = appendToNew(copy, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> copy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">appendToNew</span><span class="params">(array, value)</span>:</span></span><br><span class="line">    bigger = [<span class="number">0</span>] * len(array)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">        bigger[i] = array[i]</span><br><span class="line"></span><br><span class="line">    bigger.append(value)</span><br><span class="line">    <span class="keyword">return</span> bigger</span><br></pre></td></tr></table></figure><p>O(N^2)</p><p>P86</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumDigits</span><span class="params">(n)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        sum += n % <span class="number">10</span></span><br><span class="line">        n //= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><p>O(logN)</p><p><a href="https://github.com/careercup/CtCI-6th-Edition/blob/master/Java/Introduction/Big_O/Q_11.java" target="_blank" rel="noopener">https://github.com/careercup/CtCI-6th-Edition/blob/master/Java/Introduction/Big_O/Q_11.java</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">numChars = <span class="number">26</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printSortedStrings</span><span class="params">(remaining, prefix=<span class="string">""</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> remaining == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> isInOrder(prefix):</span><br><span class="line">            print(prefix)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numChars):</span><br><span class="line">            c = ithLetter(i)</span><br><span class="line">            printSortedStrings(remaing - <span class="number">1</span>, prefix + c)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isInOrder</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">        prev = ithLetter(s[i<span class="number">-1</span>])</span><br><span class="line">        curr = ithLetter(s[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> prev &gt; curr:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ithLetter</span><span class="params">(i)</span>:</span></span><br><span class="line">    return ?</span><br></pre></td></tr></table></figure><p><a href="https://github.com/careercup/CtCI-6th-Edition/blob/master/Java/Introduction/Big_O/Q_12.java" target="_blank" rel="noopener">https://github.com/careercup/CtCI-6th-Edition/blob/master/Java/Introduction/Big_O/Q_12.java</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    mergesort(b)</span><br><span class="line">    intersect = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> a:</span><br><span class="line">        <span class="keyword">if</span> binarySearch(b, x) &gt;= <span class="number">0</span>:</span><br><span class="line">            intersect += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> intersect</span><br></pre></td></tr></table></figure><hr><h2>기술적 문제</h2><h3>문제를 풀 때</h3><ul><li>직접 풀도록 노력하라</li><li>코드를 종이에 적어라</li><li>코드를 테스트하라 : 기본 조건, 오류 발생 조건 등을 종이에서 전부 테스트</li><li>종이에 적은 코드를 그대로 컴퓨터로 옮긴 뒤 실제로 실행해보라</li></ul><h3>알고 있어야 할 것들</h3><ul><li>자료구조 : 연결리스트, 트리, 그래프, 스택, 큐, 힙, 해시테이블</li><li>알고리즘 : BFS, DFS, 이진탐색, 병합 정렬, 퀵 정렬</li><li>개념 : 비트 조작, 메모리(스택 VS 힙), 재귀, 다이나믹 프로그래밍, Big O</li></ul><h3>문제 접근법</h3><p><img src="https://image.slidesharecdn.com/crackingtheskills-handoutsmerged-151005235406-lva1-app6891/95/cracking-the-interview-skills-coding-soft-skills-product-management-handouts-1-638.jpg?cb=1444089359" alt="img"></p><ul><li>경청하기</li><li>예제를 직접 그려보기<ul><li>명확한 예제</li><li>충분히 큰 예제</li><li>일반적인 예제</li></ul></li><li>무식한 방법으로 일단 해보기</li><li>최적화<ul><li>간과한 정보가 있는가?</li><li>새로운 예제</li><li>잘못된 방식으로 검증</li><li>시간과 공간의 실익</li><li>정보를 미리 계산</li><li>해시테이블</li><li>가능한 최선의 수행 시간(Best Conceivable Runtime)</li></ul></li><li>검토하기</li><li>코드 작성하기<ul><li>모듈화된 코드</li><li>에러를 검증</li><li>적절한 자료구조</li><li>좋은 변수명</li></ul></li><li>테스트<ul><li>면접관에게 각 행에 대해 설명한다는 생각으로 머릿속으로 돌려보는 테스트</li><li>평소와 다르게 동작하는 부분을 유심히 살펴보기</li><li>버그가 자주 발생하는 부분을 유심히 살펴보기</li><li>작은 규모의 테스트</li><li>특별한 경우를 테스트</li></ul></li></ul><h3>최적화 및 문제풀이 기술</h3><h4>BUD를 찾으라</h4><ul><li>병목현상(Bottlenecks)<ul><li>어떤 부분 때문에 알고리즘이 느려지는 경우</li><li>반복적으로 수행하는 부분이 여러 개 있는 경우(해시테이블)</li></ul></li><li>불필요한 작업(Unnecessary Work)<ul><li>더이상 루프를 돌 필요가 없다면 탈출</li><li>가능한 값이 하나 뿐이라면 산출</li></ul></li><li>중복되는 작업(Duplicated Work)<ul><li>해시테이블</li></ul></li></ul><h4>직접 풀어보라, Do It Yourself</h4><ul><li>질문을 받으면 실제 예제를 통해 직관적으로 문제를 풀어 나가려는 노력을 하라</li><li>직관적으로 수행한 최적화 방식을 잘 이해하고 코드로 설계할 때 반영하라</li></ul><h4>단순화, 일반화하라</h4><ul><li>제약조건을 단순화하거나 변형시켜라</li><li>단순화된 버전의 문제를 푼다</li><li>단순화된 문제의 알고리즘이 완성되면 보다 복잡한 형태로 다듬는다</li></ul><h4>초기 사례로부터 확장하기</h4><ul><li>초기 사례(n = 1 등)을 풀고 구해 놓은 해법으로 n = 3 혹은 n = 4와 같은 케이스에 적용해나간다</li><li>재귀 알고리즘으로 구현되는 경우가 많다</li></ul><h4>자료구조 브레인스토밍</h4><ul><li>연결리스트 -&gt; 배열 -&gt; 이진트리 -&gt; 힙</li><li>연결리스트 : 정렬하거나 특정 인덱스에 바로 접근해야 하는 경우에 취약하다</li><li>이진트리 : 순서를 유지하는데 강점이 있다</li></ul><h4>가능한 최선의 수행 시간(Best Conceivable Runtime)</h4><ul><li>수행 시간을 이용해서 어떤 부분을 줄일 수 있는지 힌트를 생각해보라</li><li>시간복잡도를 더 최적화할 수 없다면 공간복잡도를 개선해보자</li><li>자신이 짠 알고리즘에 대해서 질문을 던질 수 있어야 한다</li></ul><h4>좋은 코드의 속성</h4><ul><li>정확도</li><li>효율성(시간과 공간)</li><li>간략화</li><li>가독성</li><li>관리 가능성</li></ul><p>탈락시 <code>다음 기회를 위해 어떻게 준비하면 좋을지 얘기해주실 수 있나요?</code> 라고 질문해보라</p><hr><h2>해시테이블</h2><p>효율적인 탐색을 위해 key를 value에 대응시킨 자료구조</p><p>연결리스트와 해시 코드 함수를 통해 구현 가능</p><p>키와 값을 해시테이블에 넣을 때는 다음의 과정을 거친다<br>(키는 무한한데, 키의 자료형인 int의 개수는 유한하므로 서로 다른 두 개의 키가 같은 인덱스를 가리킬 수도 있다, 연결리스트를 이용하는 이유는 서로 다른 두 개의 키가 같은 해시 코드 또는 서로 다른 두 개의 해시 코드가 같은 인덱스를 가리키는 충돌에 대비하기 위해서이다)</p><ol><li>주어진 키의 해시 코드를 계산</li><li>해시 코드를 이용해 배열의 인덱스를 구한다 (hash(key) % array_length 와 같은 방식)</li><li>배열의 각 인덱스에는 키와 값으로 이루어진 연결리스트에서 키에 상응하는 값을 탐색</li></ol><p>충돌이 자주 발생한다면, worst case runtime은 O(N)이 된다</p><p>일반적으로는 충돌이 최소화된 경우를 가정하는데 이 경우에는 O(1)</p><p><img src="https://user-images.githubusercontent.com/14256139/39124151-56f1a7ea-4735-11e8-843d-3a03d3598246.png" alt="img"></p><p>균형 이진 탐색 트리로도 구현할 수 있으며, 이 경우에는 O(logN)이 된다고 한다, TODO</p><h2>ArrayList와 가변 크기 배열</h2><p>Java와 같이 배열의 길이가 고정되어 있는 언어에서 길이가 동적으로 변하는 자료구조가 필요할 때 사용한다</p><p>통상적으로 배열이 가득 차는 순간, 기존 배열의 크기를 두 배로 늘린다,<br>이 때는 O(N)이지만 자주 발생하는 상황이 아니므로 각 삽입은 평균적으로 O(1)이 소요된다</p><h2>String Builder</h2><p>ArrayList, StringBuilder 모두 array를 들고 있다</p><p>처음에 기본적으로 ArrayList는 크기 5개 짜리 array를, StringBuilder는 16개 짜리를 만든다</p><p>둘 모두 배열의 용량이 가득 차면 Capacity를 두 배로 늘리는 동작을 수행한다</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;면접관련&lt;/h2&gt;
&lt;h3&gt;면접에서의 평가기준&lt;/h3&gt;
&lt;h4&gt;분석 능력&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;문제를 푸는 데 도움을 많이 받았나?&lt;/li&gt;
&lt;li&gt;최적화를 얼마나 했나?&lt;/li&gt;
&lt;li&gt;문제를 푸는 데 시간이 얼마나 소요됐나?&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="CtCI" scheme="https://eclatant.io/categories/CtCI/"/>
    
    
      <category term="CtCI" scheme="https://eclatant.io/tags/CtCI/"/>
    
  </entry>
  
  <entry>
    <title>프론트엔드 입문자를 위한 사전 체크리스트</title>
    <link href="https://eclatant.io/2019/01/28/2019-01-28-Before-CodeReview/"/>
    <id>https://eclatant.io/2019/01/28/2019-01-28-Before-CodeReview/</id>
    <published>2019-01-27T15:00:00.000Z</published>
    <updated>2019-01-27T16:37:37.324Z</updated>
    
    <content type="html"><![CDATA[<p>최근에 지인의 부탁으로 코드 리뷰를 해드릴 기회가 있었다.</p><p>내 실력이나 의견에 대한 자신감이 있어서는 전혀 아니었고, 지금보다도 개발에 덜 익숙했던 시절에 누군가의 피드백이 너무나 절실했던 시절이 있었기에 응하게 되었다.</p><p>지인 분께 드렸던 피드백들이 특정 프로젝트에 국한되는 내용들이 아니라고 생각되어 글을 작성하게 되었다.</p><p>개인의 취향과도 밀접하게 맞닿아있는 내용들도 많아서 조심스럽지만, 주니어 개발자인 필자의 주관적인 의견에 불과하다.</p><h3 id="Prettier-ESLint-적용"><a href="#Prettier-ESLint-적용" class="headerlink" title="Prettier, ESLint 적용"></a><a href="https://prettier.io/" target="_blank" rel="noopener">Prettier</a>, <a href="https://eslint.org/" target="_blank" rel="noopener">ESLint</a> 적용</h3><p>개인적으로 코드에서 가장 추구해야 하는 가치는 가독성이라고 항상 생각합니다.</p><p>그런 점에서 코드의 가독성을 높여줄 수 있는 툴을 활용하는 것은 필수에 가깝다고 생각하고 있습니다.</p><p>제 개인적으로는 파이썬으로 프로그래밍을 시작해서인지 굉장히 당연하게 받아들였던 부분인데, 많은 초심자 분들은 필요성을 못 느끼시는 영역인 것 같기도 합니다.</p><p><a href="https://www.youtube.com/watch?v=ya78lQi5vVI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=ya78lQi5vVI</a></p><p>영상에서는 마치 Visual Studio Code의 Extension인 것처럼 소개되었는데, VSCode에서만 사용할 수 있거나 하지는 않습니다.</p><p>설정 관련해서는 아래 페이지를 참고하시면 될 것 같습니다.</p><ul><li><a href="https://velog.io/@velopert/eslint-and-prettier-in-react" target="_blank" rel="noopener">https://velog.io/@velopert/eslint-and-prettier-in-react</a></li></ul><p>자바스크립트 관련 유명한 컨벤션 중 하나인 airbnb style guide도 꼭 읽어볼만 하다고 생각합니다.</p><p><a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">https://github.com/airbnb/javascript</a></p><hr><h3 id="변수를-선언할-때-var-let-const-키워드를-생략하지는-않았는가"><a href="#변수를-선언할-때-var-let-const-키워드를-생략하지는-않았는가" class="headerlink" title="변수를 선언할 때 var, let, const 키워드를 생략하지는 않았는가?"></a>변수를 선언할 때 var, let, const 키워드를 생략하지는 않았는가?</h3><p>(또는 변수에 할당할 때 this를 생략하지는 않았는가?)</p><p>설령 현재 코드가 동작이 제대로 되는 것처럼 보일지라도, 정확한 대상을 지정한 결과가 아니라면 나중에는 문제가 발생하기 마련입니다.</p><p>키워드 없이 선언하게 되면 전역변수가 되며, 전역변수의 문제점은 실제로 관련해서 문제를 겪다보면 왜 지양해야 하는지 느끼실 수 있을 것이라 생각합니다.<br>(객체의 프로퍼티인데 <code>this.</code> 없이 참조하는 것도 문제가 발생합니다.)</p><p>또한 var, let, const 등의 차이에 대해 명확히 인지할 필요가 있습니다. <a href="https://blueshw.github.io/2017/03/28/ES-var-VS-const-VS-let/" target="_blank" rel="noopener">참고자료 예시</a></p><p>this의 경우, 인터뷰 단골 질문이며 관련해서 call, apply, bind, arrow function 등과 연결되지만 초심자가 우선적으로 공부할 대상은 아닐 수 있습니다.</p><hr><h3 id="언어-내장-메소드로-해결할-수-있는가"><a href="#언어-내장-메소드로-해결할-수-있는가" class="headerlink" title="언어 내장 메소드로 해결할 수 있는가?"></a>언어 내장 메소드로 해결할 수 있는가?</h3><p>보통 가장 많이 사용하게 될 자료구조 중 하나는 배열일 것이라고 생각합니다.</p><p>배열에는 다양한 메소드들이 있고, 가능하다면 최대한 언어에 내장되어있는 메소드로 해결하는 것이 좋습니다.</p><p>이렇게 생각하는 이유는 두 가지입니다.</p><p>하나는 0번에서 말했듯이 가독성 측면입니다.</p><p>문화권에서 원어민들이 사용하는 적합한 어휘를 사용하는 것이 소통에 좋듯이,</p><p>특정 프로그래밍 언어에 익숙한 사람들은 해당 자료구조의 메소드명만 보고도 이 로직이 어떻게 흘러갈지 금방 파악할 수 있습니다.</p><p>그렇지 않고 필요이상으로 for문 등으로 코드가 구성되어있다면, 같은 의미를 전달하기 위해서 더 많은 노력이 필요할 것입니다.</p><p>두 번째로는 퍼포먼스 측면입니다.</p><p>브라우저가 업데이트되어가면서 언어 자체의 퍼포먼스는 미세하게나마 계속 좋아질텐데 내가 임의로 구현한 로직일 경우 이러한 혜택을 덜 받을 수 밖에 없을 것입니다.</p><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_blank" rel="noopener">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/some</a></p><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/includes" target="_blank" rel="noopener">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/includes</a></p><p>이러한 다양한 메소드들이 존재하니, 언어에서 기본적으로 제공해주는 메소드들은 최대한 눈에 익혀두고, 나중에 필요할 때 다시 찾아서 사용해보는 것을 반복하는 것을 추천합니다.</p><hr><h3 id="적절한-자료구조를-사용하고-있는가"><a href="#적절한-자료구조를-사용하고-있는가" class="headerlink" title="적절한 자료구조를 사용하고 있는가?"></a>적절한 자료구조를 사용하고 있는가?</h3><p>대표적인 예시로 배열은 특정 데이터의 포함여부를 검사하기 위해서는 최악의 경우 배열 전체를 순회해야만 합니다.</p><p>따라서 특정 데이터 전체를 조회하면서 앞선 탐색에서 지금 탐색 중인 것과 같은 데이터가 존재했었는지 등을 검사하는데 있어서 배열은 적합하지 않습니다.</p><p>어떨 때는 배열이 좋고, 어떨 때는 객체가 좋고 하는 부분들은 충분히 고민해볼만한 포인트라고 생각됩니다.</p><hr><h3 id="중복이-존재하지는-않은가"><a href="#중복이-존재하지는-않은가" class="headerlink" title="중복이 존재하지는 않은가?"></a>중복이 존재하지는 않은가?</h3><p>만약 내가 하려는 로직이 동일하게 2~3번 반복된다면 함수로 추상화시켜서 반복을 줄일 수 있을 것입니다.</p><p>이 외에도 어떤 로직과 어떤 로직이 매우 비슷한데 사소한 1~2곳이 다르다면 그 부분을 제외한 영역은 중복을 줄일 수 있을지 고민해보는 것도 매우 좋을 것 같습니다.</p><hr><h3 id="Primitive-Type과-Reference-Type의-차이점을-알고-있는가"><a href="#Primitive-Type과-Reference-Type의-차이점을-알고-있는가" class="headerlink" title="Primitive Type과 Reference Type의 차이점을 알고 있는가?"></a>Primitive Type과 Reference Type의 차이점을 알고 있는가?</h3><p>JavaScript에는 6가지 Primitive Type이 존재하고, 그 외에는 모두 Reference Type입니다.</p><p>함수에 인수로 넘기고 return으로 받는 과정에서 분명한 차이가 존재하므로 꼭 제대로 이해하고 있어야만 하는 포인트입니다.</p><hr><h3 id="Event-Delegation에-대해-이해하고-있는가"><a href="#Event-Delegation에-대해-이해하고-있는가" class="headerlink" title="Event Delegation에 대해 이해하고 있는가?"></a>Event Delegation에 대해 이해하고 있는가?</h3><p>면접에 빈번하게 나오는 질문입니다.</p><p>어떠한 영역을 클릭하면 화면에 어떠한 변화가 일어나는 등의 구현을 하는 과정에서 필수적으로 사용되는 테크닉이므로</p><p>Event Delegation, Capturing, Bubbling 등은 꼭 이해하고 넘어가시길 권하고 싶습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;최근에 지인의 부탁으로 코드 리뷰를 해드릴 기회가 있었다.&lt;/p&gt;
&lt;p&gt;내 실력이나 의견에 대한 자신감이 있어서는 전혀 아니었고, 지금보다도 개발에 덜 익숙했던 시절에 누군가의 피드백이 너무나 절실했던 시절이 있었기에 응하게 되었다.&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="Dev" scheme="https://eclatant.io/categories/Dev/"/>
    
    
      <category term="Dev" scheme="https://eclatant.io/tags/Dev/"/>
    
  </entry>
  
  <entry>
    <title>Web Dev Curriculum</title>
    <link href="https://eclatant.io/2018/12/13/2018-12-13-WebDev/"/>
    <id>https://eclatant.io/2018/12/13/2018-12-13-WebDev/</id>
    <published>2018-12-12T15:00:00.000Z</published>
    <updated>2018-12-12T10:50:30.358Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://github.com/Knowre-Dev/WebDevCurriculum" target="_blank" rel="noopener">Knowre web development curriculum 2018</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;a href=&quot;https://github.com/Knowre-Dev/WebDevCurriculum&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Knowre web development curriculum 2018&lt;/a&gt;&lt;/h1&gt;

      
    
    </summary>
    
      <category term="Dev" scheme="https://eclatant.io/categories/Dev/"/>
    
    
      <category term="Dev" scheme="https://eclatant.io/tags/Dev/"/>
    
  </entry>
  
  <entry>
    <title>Async</title>
    <link href="https://eclatant.io/2018/12/10/2018-12-10-Async/"/>
    <id>https://eclatant.io/2018/12/10/2018-12-10-Async/</id>
    <published>2018-12-09T15:00:00.000Z</published>
    <updated>2018-12-10T07:34:13.372Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Async-비동기"><a href="#Async-비동기" class="headerlink" title="Async (= 비동기)"></a>Async (= 비동기)</h2><p>Async란 무엇인가? Sub routine이 callback을 통해 값을 반환하는 것이다</p><p>IO와 같은 작업들을 후순위로 미루어 렌더링이 끊이지 않게 하고, 퍼포먼스 밸런싱이 좋아지도록 한다 (Blocking을 없애기 위함)</p><p>비동기를 처리하기 위한 값을 만들고 우리가 원하는 시점에 꺼낼 수 있다는 것이 핵심이다</p><p>순번이 없는 애들, 봉화대 전송이 아니어도 되는 경우는 이렇게 구현해야 하며, API 설계시에도 이런 방식으로 가능하도록 요청해야 한다</p><p>Promise는 호출 제어권, 일관된 API을 가지며, 의존관계가 없을 때 여러 이점을 가지기 때문이다</p><h3 id="Promise-async-await"><a href="#Promise-async-await" class="headerlink" title="Promise, async/await"></a>Promise, async/await</h3><p>Async 연산을 다루는 객체이며, 값이 되기로 약속된 값이다</p><p>기존에는 Async를 콜백 패턴을 통해 결과가 실행되기 위한 조건과 그에 따른 핸들러 함수를 넘겨주는 방식이었다</p><p>하지만 이렇게 되면 Async끼리 순서상 의존성을 가질 경우 아래와 같은 그림이 될 수 밖에 없었다</p><p><img src="https://cdn-images-1.medium.com/max/823/1*Co0gr64Uo5kSg89ukFD2dw.jpeg" alt="img"></p><p>Promise는 위의 callback hell을 개선하는 것이 목표는 아니지만, 결과적으로 가독성의 향상을 가져오는 것도 사실이다</p><p>하지만 Promise가 보다 의미있는 지점들이 더 있다</p><p>기존의 콜백 패턴의 경우 이벤트 핸들러가 언제 호출될지 정말로 알 수 없으며, 이벤트 발생 시점이 곧 호출시점으로 이어지기 때문에 개발자가 Flow에 대해 조절할 수 있는 부분이 없다</p><p>그러나 Promise는 그렇지 않다, Promise를 선언해놓으면 then을 하지 않더라도 call stack이 비워진 시점에 수행될 것이고, 후에 then을 하게 되면 resolve 여부에 따라 바로 수행되거나 resolve가 될 때까지 기다리게 될 것이다 (Pending -&gt; Fulfilled)</p><p>이러한 지점은 Promise에 대한 제대로 된 이해없이 async/await으로 곧장 넘어가게 되면 쉽게 간과할 수 있는 부분들이다, 비동기를 기다리기 위해서 무조건적으로 await을 사용할 것이 아니라 먼저 then 없이 선언하는 것을 통해 작업이 수행되도록 하고, 해당 비동기 로직과 의존성이 없는 작업들을 먼저 수행하고, 의존성이 발생한 지점에는 then이든 await이든 활용하여 기다린 후 해당 작업이 수행되도록 하는 것이 훨씬 좋은 전략이라고 생각된다</p><p>왜냐하면 브라우저의 렌더링도 다른 자바스크립트 로직들과 함께 싱글 스레드의 call stack을 통해 처리될 것이므로 이러한 유연성을 갖출 수 있다는 것은 보다 유려한 UI/UX를 만들 수 있도록 해줄 것이기 때문이다</p><p>그렇게 했을 때만 비동기라는 이름에 걸맞게, 왼쪽이 아닌 오른쪽과 같이 처리할 수 있다</p><p><img src="http://www.nextree.co.kr/content/images/2016/09/syhan_140320_node1_031-1024x369.png" alt="img"></p><p>async : executor가 내장된 generator<br>await : executor와 상호작용하는 yield의 결과를 받아옴<br>async await = generator + promise<br>async는 promise로 await을 소비<br>await는 봉화대 로직이기 때문에, 병렬성을 처리하려면 Promise.all 에 걸어주면 된다</p><p>또한 async는 Promise로 래핑된 값을 반환한다 (return 값은 then을 통해 넘겨받을 수 있다), 따라서 new Promise 또는 Promise.resolve() 외에도 async function를 통해서도 Promise를 만들어낼 수 있다</p><p>await은 다음에 나오는 문의 값이 Promise라면 fulfill된 값, 그렇지 않다면 해당 값을 <code>resolved Promise</code>로 변환시킨다</p><p>async/await을 사용했을 때 유용한 케이스는 resolved value를 변수에 담고자 할 때, 에러 처리, 조건문, 디버깅 등이다 (<a href="https://engineering.huiseoul.com/자바스크립트는-어떻게-작동하는가-이벤트-루프와-비동기-프로그래밍의-부상-async-await을-이용한-코딩-팁-다섯-가지-df65ffb4e7e" target="_blank" rel="noopener">자바스크립트는 어떻게 작동하는가: 이벤트 루프와 비동기 프로그래밍의 부상, async/await을 이용한 코딩 팁 다섯 가지</a>)</p><p>여러 Promise들이 모두 완료되길 기다려야 한다면 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" target="_blank" rel="noopener">Promise.all()</a>를, 타임아웃과 같은 처리를 하고 싶다면 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" target="_blank" rel="noopener">Promise.race()</a>를 활용하면 된다</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md" target="_blank" rel="noopener">States and Fates</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Using_promises" target="_blank" rel="noopener">Using promises</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener">async function</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="noopener">await</a></li><li><a href="https://medium.com/@kiwanjung/번역-async-await-를-사용하기-전에-promise를-이해하기-955dbac2c4a4" target="_blank" rel="noopener">async/await 를 사용하기 전에 promise를 이해하기</a></li><li><a href="https://www.youtube.com/watch?v=j0Viy3v97gY" target="_blank" rel="noopener">자바스크립트 개념잡기: 콜백 함수의 동기적 실행과 비동기적 실행</a></li><li><a href="https://www.youtube.com/watch?v=CA5EDD4Hjz4" target="_blank" rel="noopener">자바스크립트 promise? 나도 써보자, 기본 개념부터~</a></li><li><a href="https://www.youtube.com/watch?v=JzXjB6L99N4" target="_blank" rel="noopener">자바스크립트 async / await? 나도 써보자, 기본 개념부터~</a></li><li><a href="https://medium.com/@nemo1275/callback이-뭐죠-5f3c0cc4efce" target="_blank" rel="noopener">Callback이 뭐죠?</a></li><li><a href="https://medium.com/@nemo1275/promise가-뭐죠-fdf7de2bc0bf" target="_blank" rel="noopener">Promise가 뭐죠?</a></li><li><a href="https://medium.com/@nemo1275/await가-뭐죠-1332622df251" target="_blank" rel="noopener">await가 뭐죠?</a></li><li><a href="https://joshua1988.github.io/web-development/javascript/javascript-asynchronous-operation/" target="_blank" rel="noopener">자바스크립트 비동기 처리와 콜백 함수</a></li><li><a href="https://joshua1988.github.io/web-development/javascript/promise-for-beginners/" target="_blank" rel="noopener">자바스크립트 Promise 쉽게 이해하기</a></li><li><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261" target="_blank" rel="noopener">Master the JavaScript Interview: What is a Promise?</a></li><li><a href="http://satisfactoryplace.tistory.com/18" target="_blank" rel="noopener">콜백 함수(Callback)의 정확한 의미는 무엇일까?</a></li><li><a href="http://www.ktword.co.kr/abbr_view.php?m_temp1=3581" target="_blank" rel="noopener">Callback</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Async-비동기&quot;&gt;&lt;a href=&quot;#Async-비동기&quot; class=&quot;headerlink&quot; title=&quot;Async (= 비동기)&quot;&gt;&lt;/a&gt;Async (= 비동기)&lt;/h2&gt;&lt;p&gt;Async란 무엇인가? Sub routine이 callback
      
    
    </summary>
    
      <category term="JS" scheme="https://eclatant.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://eclatant.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Block, NonBlock, Sync, Async</title>
    <link href="https://eclatant.io/2018/12/09/2018-12-09-Block-NonBlock-Sync-Async/"/>
    <id>https://eclatant.io/2018/12/09/2018-12-09-Block-NonBlock-Sync-Async/</id>
    <published>2018-12-08T15:00:00.000Z</published>
    <updated>2018-12-10T07:31:00.175Z</updated>
    
    <content type="html"><![CDATA[<p>Block : Flow를 막고 있는 것 / NonBlock : Sub routine이 즉시 Flow 제어권을 내놓는 것</p><p>Blocking에 대한 요구사항은 내가 만들고자 하는 애플리케이션이 속한 업계마다 다를 것, 전화통화를 처리해야 한다면 Blocking에 대한 요구사항이 대단히 높을 것, 이 외에도 브라우저는 5초 등 OS 레벨에서 제한을 두는 경우도 있다, Blocking 시에는 멈춰져있지만 OS에서 제어하는 영역 내에서 실행되는 코드들은 OS가 강제 중단이 얼마든지 가능하다, 스마트폰에서 전화가 오면 그 어떤 동작보다 우선할 수 있는 것도 동일한 원리, Window에서 blue screen이 뜨는 것은 애플리케이션을 잘못 만든 경우인 것이 다반사이고, MacOS에서는 OS에서 제어할 수 있는 영역만 쓸 수 있게 하므로 권한이 제한되어있어 그런 경우가 없어 보이는 것일 뿐이다</p><p>Blocking Function 여부는 우리가 함수에 어떤 인자를 전달하느냐에 따라 블록킹 현상이 심해지느냐에 달려있다</p><p>weakset 자료구조를 사용하면 담겨있는 값의 개수와 무관하게 값이 담겨있는지 여부를 확인하는데 소요되는 비용이 같으므로 이런 식의 접근 방법이 필요할 것</p><p>일부가 Blocking Function인 것만으로도 애플리케이션 전체가 Blocking에 빠질 수 있다, Blocking의 조합으로 인한 결과는 예측할 수 없다</p><p>안타깝게도 우리가 짜는 대부분의 로직은 흔히 Blocking이기 마련이다</p><p>엔터프라이즈 레벨을 지향한다는 것의 첫 걸음은 하나의 함수를 짤 때라도 Blocking Function이 아니도록 하는 것</p><p>배열 순회, 정렬은 배열 크기에 따라, DOM 순회는 DOM의 하위구조에 따라, 이미지 프로세싱은 이미지 크기에 따라 Blocking을 유발할 것</p><p>개발자가 되기 위해 6년에 걸쳐서 의사가 된다는 마음가짐으로 임한다면 함부로 Blocking Function을 짜지 못할 것</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">v</span> =&gt;</span> other(something(v), v * <span class="number">2</span>); f(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>위와 같은 코드가 있을 때, Blocking 여부를 예측할 수 있는가?</p><p>Blocking으로 인한 에러는 로그를 찍어보기도 전에 애플리케이션이 죽기 때문에 파악하기도 대단히 어려울 것</p><p>Blocking 회피방법</p><ul><li>시분한 운영체제의 동시 실행 : 순차적인 실행에 비해 컨텍스트 스위칭으로 인해 훨씬 오래 걸림</li><li>자바스크립트 쓰레드<ul><li>자바스크립트는 싱글 쓰레드라고 알려져있지만 그렇지 않다, UI와 자바스크립트를 처리하는 쓰레드가 싱글일 뿐, 하지만 현대의 대부분 OS는 UI를 변경하거나 메인 스크립트를 구동하는 쓰레드를 싱글 쓰레드로 제약한다, 그리고 그 해당 쓰레드를 감시한다</li><li>HTML5 스펙에는 우리가 직접 Background로 사용할 수 있는 Web Worker Thread가 존재함</li><li>자바스크립트 쓰레드는 무한루프를 돌고 있고 배열을 바라보고 있다, 해당 배열에 쌓이는 명령들에 언제 실행되어야 할지에 대한 프레임이 붙는다, 루프가 한 번 돌 때마다 1틱이 진행된다, 그러므로 메인 쓰레드는 명령큐에 있는 프레임들을 실행할 뿐이고, 그 외 쓰레드들에서 명령큐에 명령들을 프레임에 따라 담아둔다, 이러한 패턴을 서스펜션 패턴이라고 부른다, 다수의 공급자 쓰레드와 소비자 쓰레드를 나누어 중간에 명령큐와 같은 쿠션층을 만들어서 공급자는 쓰기만 하고 소비자는 해당하는 프레임마다 꺼내서 읽기(소비 및 명령 수행)만 한다, 따라서 메인 쓰레드가 하나의 명령을 꺼내서 처리하는 시간이 5초 이내여야 한다, 자바스크립트에서는 기본적으로 회피방식은 타임슬라이싱을 통해 여러 쓰레드에 스프레드시키는 것</li></ul></li></ul><p>Sync, Async</p><p>Sync : Sub-routine이 값을 반환함 / Async : Sub routine이 callback을 통해 값을 반환함</p><p>Blocking과 NonBlock은 Flow상으로는 동기적으로 수행되므로 큰 혼란이 없는 반면에 Sync, Async는 Flow를 어긋나게 만드므로 이해하기 쉽지 않다</p><p>Sync 코드 예시 (Sync NonBlock 의 결과값을 조사하는 것도 NonBlock해야 한다)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) sum += i;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// NonBlock</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result = &#123; <span class="attr">isComplete</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  requestAnimationFrame(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) sum += i;</span><br><span class="line">    result.isComplete = <span class="literal">true</span>;</span><br><span class="line">    result.value = sum;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = sum(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (result.isComplete) &#123;</span><br><span class="line">    clearInterval(id);</span><br><span class="line">    <span class="built_in">console</span>.log(result.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>Async 코드 예시 (Async라고 해서 Block을 일으키지 않는 것이 아니다, 우리의 요구사항 내에 얼마나 빨리 Flow를 반환해주는지가 중요)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">n, f</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) sum += i;</span><br><span class="line">  f(sum);</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">100</span>, <span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span>); <span class="comment">// 출력 순서 55 -&gt; 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NonBlock</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">  requestAnimationFrame(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) sum += i;</span><br><span class="line">    f(sum);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">10</span>, <span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span>); <span class="comment">// 출력 순서 123 -&gt; 55</span></span><br></pre></td></tr></table></figure><p>위 네 가지 중에서 최악의 경우는 Async Block이다, Blocking을 일으키면서 직접적인 return도 하지 않기 때문이다, 테스트나 디버깅도 매우 어려워진다</p><p>Async의 경우 코드가 널뛰기에 가독성이 떨어지므로 Promise 등을 사용해서 chaining을 하여 Flow를 인식하기 편하도록 한다, Modern API는 Non Block시에 콜백을 리턴하는 것이 아니라 Promise를 리턴하는 것도 동일한 사유이지만, 결국 콜백을 리턴하는 것과 같은 맥락에 있다 (콜백과 달리 반쯤 제어권을 가져올 수 있다는 점에서는 분명한 차이가 존재한다)</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://www.youtube.com/watch?v=BJtPmXiFnS4" target="_blank" rel="noopener">코드스피츠77 - ES6+ 기초편 5회차</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Block : Flow를 막고 있는 것 / NonBlock : Sub routine이 즉시 Flow 제어권을 내놓는 것&lt;/p&gt;
&lt;p&gt;Blocking에 대한 요구사항은 내가 만들고자 하는 애플리케이션이 속한 업계마다 다를 것, 전화통화를 처리해야 
      
    
    </summary>
    
      <category term="JS" scheme="https://eclatant.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://eclatant.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Cookie || Web Storage</title>
    <link href="https://eclatant.io/2018/12/09/2018-12-09-Cookie-Web-Storage/"/>
    <id>https://eclatant.io/2018/12/09/2018-12-09-Cookie-Web-Storage/</id>
    <published>2018-12-08T15:00:00.000Z</published>
    <updated>2018-12-09T14:55:53.436Z</updated>
    
    <content type="html"><![CDATA[<h3 id="쿠키-로컬스토리지-세션스토리지"><a href="#쿠키-로컬스토리지-세션스토리지" class="headerlink" title="쿠키, 로컬스토리지, 세션스토리지"></a>쿠키, 로컬스토리지, 세션스토리지</h3><h4 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h4><p>우선 Cookie와 Web Storage 두 가지로 나뉘지만 그 이전에 사용해야 하는 이유가 중요할 것이다</p><p>HTTP 프로토콜 특징상 Stateless이므로 상태 정보를 유지하지 않는다</p><p>그러나 웹 애플리케이션을 만들다보면 로그인과 같이 상태 정보가 필요한 때가 있다 (세션 관리, 개인화, 트래킹)</p><h4 id="How"><a href="#How" class="headerlink" title="How?"></a>How?</h4><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p>client local에 저장되는 key/value로 이루어진 file이다</p><p>요청시 cookie가 없다면 webpage를 response로 받으면서 cookie를 client local에 저장하고, 요청시 cookie가 있다면 request에 Cookie header를 통해 cookie도 함께 전송한다</p><p>response header에 Set-Cookie 속성을 이용하면 쿠키를 만들 수 있다</p><p>단점</p><ul><li>총 300개까지 cookie를 저장할 수 있고, 하나의 도메인당 20개의 값만 가질 수 있으며 하나당 4kb만 저장할 수 있다</li><li>매 HTTP 요청마다 포함되어 전달되므로 퍼포먼스상 좋지는 않다</li><li>별도의 암호화 없이 전달되므로 감청을 당할시 위험할 수 있다</li></ul><h5 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h5><p>cookie와 달리 서버로 자동 전송되지 않는다</p><p>local storage와 session storage의 차이는 데이터가 소멸하는 시점이다, session storage는 세션이 종료되면 즉 브라우저의 탭이 꺼지면 데이터가 사라지지만 local storage는 별도로 삭제하거나 브라우저에 의해 비활성화되지 않는다면 사용가능하다</p><p>각각 window에 포함되어있는 localStorage 와 sessionStorage 를 통해 활용할 수 있다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'myCat'</span>, <span class="string">'Tom'</span>);</span><br><span class="line"></span><br><span class="line">sessionStorage.setItem(<span class="string">'myCat'</span>, <span class="string">'Tom'</span>);</span><br><span class="line">sessionStorage.getItem(<span class="string">"autosave"</span>)</span><br></pre></td></tr></table></figure><p>참고 사이트</p><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Cookies#세션_쿠키" target="_blank" rel="noopener">MDN HTTP 쿠키</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API" target="_blank" rel="noopener">Web Storage API 사용하기</a></li><li><a href="https://jeong-pro.tistory.com/80" target="_blank" rel="noopener">쿠키와 세션의 차이, 용도, 사용법(cookie,session)</a></li><li><a href="https://isme2n.github.io/devlog/2017/06/21/storage-cookie/" target="_blank" rel="noopener">로컬스토리지, 세션스토리지 그리고 쿠키</a></li><li><a href="https://www.zerocho.com/category/HTML/post/5918515b1ed39f00182d3048" target="_blank" rel="noopener">로컬스토리지, 세션스토리지</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;쿠키-로컬스토리지-세션스토리지&quot;&gt;&lt;a href=&quot;#쿠키-로컬스토리지-세션스토리지&quot; class=&quot;headerlink&quot; title=&quot;쿠키, 로컬스토리지, 세션스토리지&quot;&gt;&lt;/a&gt;쿠키, 로컬스토리지, 세션스토리지&lt;/h3&gt;&lt;h4 id=&quot;Why&quot;&gt;
      
    
    </summary>
    
      <category term="Dev" scheme="https://eclatant.io/categories/Dev/"/>
    
    
      <category term="Dev" scheme="https://eclatant.io/tags/Dev/"/>
    
  </entry>
  
  <entry>
    <title>이벤트 델리게이션</title>
    <link href="https://eclatant.io/2018/12/09/2018-12-09-Event-Delegation/"/>
    <id>https://eclatant.io/2018/12/09/2018-12-09-Event-Delegation/</id>
    <published>2018-12-08T15:00:00.000Z</published>
    <updated>2018-12-10T03:46:41.543Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h3><ul><li>Javascript Event<ul><li>addEventListener<ul><li>Event Delegation</li></ul></li><li>Event Bubbling, Event Capturing<ul><li>Event Object</li></ul></li><li>Event Target</li></ul></li></ul><hr><h3 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h3><p>SPA 이전 웹사이트들에서 자바스크립트의 중요한 역할은 웹사이트의 동작을 구현하는 것입니다. 여기서 말하는 동작은 애니메이션이 아닌, 동적인 상호작용을 뜻합니다. (애니메이션은 CSS3의 역할이라고 생각합니다.)</p><p>위와 같은 동적인 상호작용을 <code>Event</code>라고 지칭합니다. 사용자의 이벤트 요청을 받아들이기 위해서는 사용자의 이벤트 요청을 받아들이기 위한 장치를 마련해두어야 합니다.</p><p>이를 위한 가장 일반적인 방법이 <code>addEventListener()</code>입니다. <code>addEventListener()</code>의 대상이 될 수 있는 <code>EventTarget</code>은 <code>Element</code>, <code>Document</code>, <code>Window</code>와 같은 이벤트를 지원하는 객체입니다. 일반적으로는 <code>document.querySelector()</code>를 통해 특정 <code>Element</code>를 지칭하여 <code>addEventListener()</code>를 호출합니다.</p><p>IE9부터 사용 가능한 <code>addEventListener()</code>는 다음과 같은 인자를 갖고 있습니다. <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener">addEventListener MDN</a></p><p><code>type</code>, <code>listener</code>, <code>options || useCapture</code>, <code>wantsUntrusted</code></p><ul><li><code>type</code></li></ul><p><code>EventTarget</code>에 어떤 <code>Event</code>가 일어났을 때, <code>listener parameter</code>를 호출할지 결정하는 문자열입니다. 어떤 종류가 있는지는 다음 페이지에서 확인할 수 있습니다. <a href="https://developer.mozilla.org/en-US/docs/Web/Events" target="_blank" rel="noopener">Event reference MDN</a> 일반적으로 많이 사용하는 것은 <code>click</code>, <code>load</code> 등입니다.</p><ul><li><code>listener()</code></li></ul><p><code>type</code>에서 정의한 <code>event</code>가 발생했을 때 호출될 객체입니다. 일반적으로 자바스크립트 함수로 합니다. 이 함수를 웹 브라우저가 호출하면서 인수로 <code>Event</code> 객체를 넘겨줍니다. 이 인자를 일반적으로 <code>e</code> 또는 <code>event</code>로 정의합니다. 가장 많이 사용하는 것은 <code>Event</code> 의 target property입니다.</p><p><code>listener</code>가 <code>return false</code>를 반환할 경우, <code>preventDefault()</code>를 한 것과 동일한 효과를 보입니다. <code>preventDefault()</code>는 해당 <code>Node</code>의 기본 동작을 막는 함수입니다. 예를 들어 <code>&lt;a&gt;</code>에서 <code>EventListener</code>가 호출되었을 때는 <code>listener</code>와 더불어 <code>&lt;a&gt;</code>의 본래 역할인 URL 연결도 수행하는데, 이를 막을 수 있습니다.</p><ul><li><code>options</code> <code>||</code>  <code>useCapture</code></li></ul><p>인수가 <code>object</code>이면 options를, <code>boolean</code>을 넘겨주면 useCapture로 인식합니다. <a href="https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#eventlisteneroptions" target="_blank" rel="noopener">WICG Link</a></p><ul><li><code>useCaputre</code>일 때 (default <code>false</code>)</li></ul><p>이 인자는 <code>Capture Phase</code>일 때의 <code>Event</code> 수신 여부를 결정합니다.</p><p>false일 경우 이벤트가 발생한 <code>node</code>로부터 <code>window</code>까지 <code>Event</code>가 전파되는 시점에 <code>Event</code>를 받게 됩니다. <code>Event Bubbling</code>이라고 합니다.</p><p>true일 경우 <code>Window</code>부터 이벤트가 발생한 <code>node</code>까지 <code>Event</code>가 전파되는 시점에 <code>Event</code>를 받게 됩니다. 이것을 <code>Event Capturing</code>이라고 합니다.</p><ul><li><code>options</code>일 때</li></ul><p><code>capture</code>: <code>Capturing</code> 유무</p><p><code>once</code>: <code>true</code>를 넘겨주면, <code>EventListener</code>를 일회성으로 만들 수 있습니다.</p><p><code>passive</code>: <code>listener</code>에서의 <code>preventDefault</code> 호출 허용 여부를 결정합니다.</p><p><code>mozSystemGroup</code></p><p><img src="https://www.w3.org/TR/DOM-Level-3-Events/images/eventflow.svg" alt="img"></p><p><a href="https://codepen.io/jeewhan/pen/XeaXGJ" target="_blank" rel="noopener">Codepen 예제</a></p><hr><p>그렇다면 왜 이벤트 위임을 해야 하는가?</p><p>하나의 부모 <code>Node</code> 밑에 있는 자식 <code>Node</code>들이 있다고 가정해보겠습니다. 해당 자식 <code>Node</code>들은 모두 동일한 <code>Event</code>를 발생시키길 기대합니다.</p><p>이벤트 위임을 하지 않을 경우, 자식 <code>Node</code>마다 <code>Event Listener</code>를 추가해주어야 하는 것은 물론, 이후에 자식 <code>Node</code>가 늘어날 때마다 <code>Event Listener</code>도 추가해주어야 합니다. 이렇게 하게 되면 성능도 안 좋겠지만, 프로그래머 입장에서도 매우 번거롭습니다.</p><p>그래서 자식 <code>Node</code>마다 <code>Event Listener</code>를 부여하지 않고, 그들의 부모 <code>Node</code>에게만 <code>Event Listener</code>를 부여하고, 자식에서 발생하는 <code>Event</code>를 받아 처리하도록 하는 것을  이벤트 위임이라고 합니다. 그러면 자식 <code>Node</code>가 늘어날 때마다 <code>Event Listener</code>를 늘릴 필요없이 부모의 <code>Event Listener</code>의 <code>listener</code>에 분기 처리만 해주면 됩니다.</p><p>이벤트 위임에는 당연히 이벤트 전파가 전제되어 있습니다. 따라서 프로그래머가 의도한 방향대로 동작하게 하려면 이벤트 전파를 제어할 수 있어야 합니다. 그러기 위해서 <code>stopPropagation()</code> <code>stopImmediatePropagation()</code> 를 사용할 수 있습니다.</p><ul><li><code>stopPropagation()</code><br><code>Event</code>가 <code>Parent Node</code>로 전파되지 않도록 합니다. 이 함수의 적용 시점은 <code>Bubbling Phase</code>이기에, <code>Capture</code>와는 무관합니다.</li></ul><ul><li><code>stopImmediatePropagation()</code><br><code>stopPropagation()</code>와 더불어 <code>Sibling Node</code>에게도 <code>Event</code>가 전달되지 않도록 합니다.</li></ul><hr><p>Capture Phase 관련해서 착각해서는 안 되는 점은 위 그림에서 td tag에 있는 event listener는 도착한 시점에만 발생한다는 점입니다. td가 아닌 tr을 클릭했을 경우 td에 대한 capturing option의 event listener일지라도 호출되지 않습니다. 다만 tr 관련해서 td에 이벤트 위임을 해두었다면 td를 클릭하는 것만으로도 td의 event listener가 호출되겠지만, event target이 td일 것이므로 tr의 event handler는 호출되지 않을 것입니다.</p><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="http://programmingsummaries.tistory.com/313" target="_blank" rel="noopener">Javascript에서 이벤트 전파를 중단하는 네 가지 방법</a></li><li><a href="https://github.com/nhnent/fe.javascript/wiki/August-22-August-26,-2016" target="_blank" rel="noopener">왜 이벤트 위임(delegation)을 해야 하는가?</a></li><li><a href="http://poiemaweb.com/js-event" target="_blank" rel="noopener">PoiemaWeb Javascript Event</a></li></ul><p>관련하여 매우 좋은 글이 있어 공유해봅니다</p><p><a href="https://joshua1988.github.io/web-development/javascript/event-propagation-delegation/" target="_blank" rel="noopener">이벤트 버블링, 이벤트 캡처 그리고 이벤트 위임까지</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Concept&quot;&gt;&lt;a href=&quot;#Concept&quot; class=&quot;headerlink&quot; title=&quot;Concept&quot;&gt;&lt;/a&gt;Concept&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Javascript Event&lt;ul&gt;
&lt;li&gt;addEventListener&lt;ul
      
    
    </summary>
    
      <category term="JS" scheme="https://eclatant.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://eclatant.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>이번 주에 접했던 것들 #3 : 18-12-02</title>
    <link href="https://eclatant.io/2018/12/02/2018-12-02-WeeklyHistory/"/>
    <id>https://eclatant.io/2018/12/02/2018-12-02-WeeklyHistory/</id>
    <published>2018-12-01T15:00:00.000Z</published>
    <updated>2018-12-02T13:59:47.908Z</updated>
    
    <content type="html"><![CDATA[<h3 id="WebStorm"><a href="#WebStorm" class="headerlink" title="WebStorm"></a>WebStorm</h3><p>JSX 관련 설정은 XML 형식에서 가져온다</p><p>알트탭을 통해 화면 전환을 했을 때 file watcher가 자동 저장을 하지 않도록 하려면 save files on frame deactivation 를 해제해야 한다</p><p>cmd + delete 를 통해 라인이 삭제되는 것이 아니라 VSCode와 같이 내용만 사라지고 라인이 유지되길 원한다면 keymap에서 Delete Line이 아닌 Delete to Line Start 으로 수정해야 한다</p><p>node.js의 require 나 jest의 describe 관련하여 undefined 표시가 나온다면, Language &amp; Frameworks &gt; JavaScript &gt; Libraries 에서 DOWNLOAD 해보길 권한다</p><h3 id="프론트엔드-개발자-취업을-위해-숙지해야-할-키워드들"><a href="#프론트엔드-개발자-취업을-위해-숙지해야-할-키워드들" class="headerlink" title="프론트엔드 개발자 취업을 위해 숙지해야 할 키워드들"></a>프론트엔드 개발자 취업을 위해 숙지해야 할 키워드들</h3><p>조만간 아래 키워드들을 포함하여 글을 작성해볼 생각이다</p><ul><li>이력 또는 선택 관련 사유 (개인의 커리어, 기술 스택 모두)</li><li>this</li><li>closure + 단점</li><li>currying</li><li>Pure Function</li><li>First Class Function</li><li>Higher Order Function</li><li>Webpack</li><li>Latency</li><li>Lazy Loading</li><li>setTimeout + console.log</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;WebStorm&quot;&gt;&lt;a href=&quot;#WebStorm&quot; class=&quot;headerlink&quot; title=&quot;WebStorm&quot;&gt;&lt;/a&gt;WebStorm&lt;/h3&gt;&lt;p&gt;JSX 관련 설정은 XML 형식에서 가져온다&lt;/p&gt;
&lt;p&gt;알트탭을 통해 화면 전환을
      
    
    </summary>
    
      <category term="Dev" scheme="https://eclatant.io/categories/Dev/"/>
    
    
      <category term="Dev" scheme="https://eclatant.io/tags/Dev/"/>
    
  </entry>
  
  <entry>
    <title>Moida-FE #0 : 18-11-26</title>
    <link href="https://eclatant.io/2018/11/26/2018-11-26-MoidaFE-0/"/>
    <id>https://eclatant.io/2018/11/26/2018-11-26-MoidaFE-0/</id>
    <published>2018-11-25T15:00:00.000Z</published>
    <updated>2018-11-25T17:11:58.929Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>프로젝트 진행중에는 수필 형식으로 개발일지를 남기게 될 것 같고, 개발이 어느 정도 완료된 뒤에 독자를 위한 형식의 글을 작성할 예정입니다.</p></blockquote><p>여러 가지 동인들로 인해 지인 분(이하 동료 분)과 사이드 프로젝트를 하기로 하였다.</p><p><a href="https://ppss.kr/archives/16682" target="_blank" rel="noopener">글쓰기가 안 되는 분들을 위한 4단계 작문법</a> 을 보면서 많은 것을 내려놓기로 결심하였고, 코딩이든 기획이든 시작은 정신병자처럼 해야 한다고 되내이고 있다. (글 내내 나올 정신병자 라는 표현은 여기서 가져왔다.)</p><p>내 좁은 이해로는 애자일에서 추구하는 방향도 비슷할 것이라 생각하고, 예전에 인상 깊게 보았던 아티클인 <a href="https://medium.com/@hongkevin/개발을-시작-할-때-알면-좋은-것들-c769cddfd993" target="_blank" rel="noopener">[개발을 시작]할 때 알면 좋은 것들</a> 도 마찬가지 의미로 이해되었다.</p><p>그래서 예전과 다르게 생각난 그대로, 일단 기획안을 작성하고 동료 분께 공유를 했다.</p><hr><h3 id="Moida"><a href="#Moida" class="headerlink" title="Moida"></a>Moida</h3><p>글쓰기 || 스터디 모임 플랫폼</p><p>RSS를 통해 글을 받아온다</p><p>받아온 정보를 가로 형태의 배너를 통해 보여준다</p><p>지나간 글을 편하게 볼 수 있도록 각종 필터</p><p>게시물 별로 댓글 작성이 가능하다</p><p>게시물 별로 체크리스트 작성이 가능하다</p><ul><li>체크리스트는 익명으로 이루어진다</li><li>항목은 성윤님의 가이드를 따른다 (Yes or No, 충족 || 개선필요)</li><li>항목별 평균과 작성자의 체크사항을 보여준다</li><li>자기 자신도 작성해야 한다</li><li>어느 시점에 작성했는지도 함께 기록하여 어느 버전을 보고 작성한 것인지 유추할 수 있도록 한다</li></ul><p>같은 조이면 댓글과 피드백을 필수로 달도록, 달지 않은 것을 상단에 계속 노출시킨다</p><p>글 제출 주기를 설정할 수 있으며 이 일정은 구글 캘린더로 export할 수 있다</p><p>대시보드를 통해 내가 속한 그룹(글또) / 파티(프론트엔드) 관련 정보를 볼 수 있다</p><p>페이스북 로그인</p><p>디파짓 정산 기능</p><p>별도의 랜딩페이지 없고, 페이스북 로그인으로만 지원할 것이니 로그인/회원가입 페이지 불필요</p><p>화면은 메인(+ 체크리스트 폼 모달), 대시보드</p><p>네비바 : 글, 대시보드, 로그인/회원가입 || 로그아웃</p><p>디자인은 이 사이트와 유사한 형태 (사진 제외)</p><ul><li><a href="https://blog.digitalocean.com/" target="_blank" rel="noopener">The DigitalOcean Blog</a></li><li><a href="https://flipboard.com/" target="_blank" rel="noopener">Flipboard</a></li></ul><hr><p>다행히 요구사항이 재미있다는 피드백이 왔다.</p><p>여태까지 해왔던 타인과 함께 하는 모든 프로젝트에서 생겼던 문제들은 모두 커뮤니케이션이었지, 능력과 관련한 부분이 아니었음을 다시 한 번 떠올리게 되었다.</p><p>사람들은 엄청난 퀄리티의 무엇인가를 내게 기대하지 않으며, 따라서 내가 할 수 있는 최선은 늦지 않게 그들에게 내 생각을 전달하는 것이다.</p><p>또한 내가 정신병자라고 생각하는 퀄리티일지라도, 엄청난 사회적 문제가 생길 정도는 아니다.</p><p>원래 꼭 만들고 싶었던 프로젝트 주제를 자신이 없어서 몇 달이나 미루다가 누군가가 만들어서 출시했을 때를 떠올려보면, 만약 처음부터 일단 만들어보는 시도를 했다면 지금 뭔가는 분명 달라졌을 것이다.</p><p>그러니 무엇이든 퀄리티보단 우선 미루지 않고 시도하는 것에 최우선 순위를 두자.</p><hr><p>What을 조금 정했으니 How가 중요할 것이다.</p><p>Vanila로 만들까 라는 생각을 0.5초 정도 했었던 것 같은데, Why를 떠올려보고 바로 생각을 접고 React로 정했다.</p><p>이 프로젝트를 하는 Why는 무엇인가? FE개발자가 되기 위한, 훈련과 포트폴리오이다.</p><p>사실 내 개인의 만족을 위해서는 기존에 만들던 FP Library를 좀 더 이어서 작업하는 것이 더 좋았을 것이다.</p><p>그런데 인생을 돌이켜보니 +를 늘리는 것보다는 -를 줄이는 것이 더 중요하더라.</p><p>최인철 교수에 따르면 행복의 3요소는 자유, 유능, 관계 라고 한다. <a href="https://www.youtube.com/watch?v=f7OLwHFz4MU" target="_blank" rel="noopener">행복에 관하여</a></p><p>나는 여기에서 유능이 가장 선행되어야 하고, 유능해야 자유와 관계를 가질 수 있다고 생각한다.</p><p>그렇다면 내가 쌓고 싶은 실력이 개발자 커뮤니티에서 메이저가 아니라면 타인을 설득하는데 힘이 너무 많이 들 것이므로 지금 내 시점에는 어울리지 않을 것이다.</p><p>그렇다면 일반적인 JD에서 가장 많이 언급되는 것을 우선적으로 충족시켜야 할 것이다.</p><p>그러면 자연스럽게 기술 스택이 정해진다. React, Redux, Redux-Saga</p><p>개인적으로 사용 경험은 Mobx-State-Tree만 있고, 해당 기술에서 불만사항을 느껴본 적이 없고 심지어 MST가 Redux보다 좋다고 생각한다. 또한 작년에 Redux가 너무 어려워서 포기했었다. 하지만 그럼에도 대부분의 회사에선 Redux를 사용하므로 내 선호는 그다지 중요하지 않을 것이다. (이렇게 된 것은 순전히 출시 시점과 그에 따른 관성 때문이라고 생각한다.)</p><p>Redux-Saga이냐 Redux-Observable이냐도 마찬가지다. 물론 나중에 면접관이 물어보았을 때 <code>JD에 많이 나와서..</code> 라고 답할 수는 없으므로 <a href="https://shift.infinite.red/redux-observable-epics-vs-redux-sagas-8e53610c0eda" target="_blank" rel="noopener">Redux-Observable Epics vs Redux-Sagas</a> 와 같은 아티클을 통해 저 기술들이 가지고 있는 캐치프라이즈나 핵심적 컨셉 등에 대한 이해는 필요할 것이지만, 가장 실질적인 이유는 회사에서 그나마 많이 쓰더라 이다. (당신이 사용해본 Redux 미들웨어는 무엇인가요? 그 Redux 미들웨어를 사용한 이유는 무엇인가요?)</p><hr><p>멘토로 모시는 분 중 한 분이 내게 이런 말씀을 하셨다.</p><p><code>정보수집을 멈추고 개발에 전념하시면 실력이 금방 느실 것입니다.</code></p><p>평소에 나는 정신병자처럼 하지 못하는 사람이기에 정보수집만 하고 실제 행동으로 옮기지 못하는 사람이었는데, 이번 프로젝트는 시행착오 자체를 줄이기 보다는 시행착오를 경험하는 것에 포커싱을 두자고 생각했다.</p><p>그래서 전과 달리 너무 많은 아티클을 미리 참고하지는 않으려고 한다.</p><p>이번 주는 아래 아티클들을 접했다.</p><p><a href="https://eclatant.io/2018/11/25/2018-11-25-SearchHistory/">이번 주에 검색했던 것들 #2 : 18-11-25</a></p><p>다음 주 목표는 아래와 같다.</p><ul><li><p>[ ] <a href="https://github.com/Knowre-Dev/WebDevCurriculum" target="_blank" rel="noopener">Knowre web development curriculum 2018</a></p></li><li><p>[ ] 프론트엔드 개발 시작하기 HTML ~ CSS</p></li><li><p>[ ] <a href="https://velog.io/@velopert/react-component-styling" target="_blank" rel="noopener">다양한 방식의 리액트 컴포넌트 스타일링 방식 CSS, Sass, CSS Module, styled-components</a></p></li><li><p>[ ] <a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener">React Router</a></p></li><li><p>[ ] <a href="https://velog.io/@velopert/react-hooks" target="_blank" rel="noopener">리액트의 새로운 기능, Hooks 알아보기</a></p></li><li><p>[ ] <a href="https://velopert.com/3591" target="_blank" rel="noopener">React + Redux 앱 테스트</a></p></li><li><p>[ ] <a href="https://velopert.com/3587" target="_blank" rel="noopener">Jest, Enzyme 을 통한 리액트 컴포넌트 유닛 테스팅</a></p></li><li><p>[ ] <a href="https://www.slideshare.net/OKJSP/okkycon-120498066" target="_blank" rel="noopener">테알못 신입은 어떻게 테스트를 시작했을까?</a></p></li><li><p>[ ] <a href="https://velopert.com/3537" target="_blank" rel="noopener">컴포넌트에 날개를 달아줘, 리액트 Higher-order Component (HoC)</a></p></li><li><p>[ ] <a href="https://velopert.com/3401" target="_blank" rel="noopener">리덕스 미들웨어, 그리고 비동기 작업 (외부데이터 연동)</a></p></li><li><p>[ ] <a href="https://github.com/reactkr/learn-react-in-korean/blob/master/translated/deal-with-async-process-by-redux-saga.md" target="_blank" rel="noopener">redux-saga로 비동기처리와 분투하다</a></p></li><li><p>[ ] <a href="https://youtu.be/UxpREAHZ7Ck?list=PLZl3coZhX98oeg76bUDTagfySnBJin3FE" target="_blank" rel="noopener">Redux-Saga - 제너레이터, 사이드이펙트, 채널</a></p></li></ul><p>음.. 적고 나니 원래의 나로 돌아왔다는 것을 깨달았다. -_-;</p><p>우선 다음 주에 실제로 얼마나 소화하는지를 보고 자체적인 개선을 해보도록 하자.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;프로젝트 진행중에는 수필 형식으로 개발일지를 남기게 될 것 같고, 개발이 어느 정도 완료된 뒤에 독자를 위한 형식의 글을 작성할 예정입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;여러 가지 동인들로 인해 지인 분(이하 동료
      
    
    </summary>
    
      <category term="Dev" scheme="https://eclatant.io/categories/Dev/"/>
    
    
      <category term="Dev" scheme="https://eclatant.io/tags/Dev/"/>
    
  </entry>
  
  <entry>
    <title>이번 주에 접했던 것들 #2 : 18-11-25</title>
    <link href="https://eclatant.io/2018/11/25/2018-11-25-WeeklyHistory/"/>
    <id>https://eclatant.io/2018/11/25/2018-11-25-WeeklyHistory/</id>
    <published>2018-11-24T15:00:00.000Z</published>
    <updated>2018-12-02T13:15:31.013Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ESLint-Prettier"><a href="#ESLint-Prettier" class="headerlink" title="ESLint, Prettier"></a>ESLint, Prettier</h3><p><a href="https://velog.io/@velopert/eslint-and-prettier-in-react" target="_blank" rel="noopener">리액트 프로젝트에 ESLint 와 Prettier 끼얹기</a></p><p>결론 : 위 글을 따라가면 VSCode 사용시에 리액트 프로젝트에 ESLint 와 Prettier를 수월하게 설정할 수 있다</p><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p><a href="https://velog.io/@velopert/redux-or-mobx" target="_blank" rel="noopener">상태 관리 라이브러리의 미학: Redux 또는 MobX 를 통한 상태 관리</a></p><p><a href="https://velog.io/@velopert/Redux-1-소개-및-개념정리-zxjlta8ywt" target="_blank" rel="noopener">Redux (1) 소개 및 개념정리</a></p><p><a href="https://velog.io/@velopert/Redux-2-리액트-없이-쓰는-리덕스-cijltabbd7" target="_blank" rel="noopener">Redux (2) 리액트 없이 쓰는 리덕스</a></p><p><a href="https://velog.io/@velopert/Redux-3-리덕스를-리액트와-함께-사용하기-nvjltahf5e" target="_blank" rel="noopener">Redux (3) 리덕스를 리액트와 함께 사용하기</a></p><p><a href="https://velog.io/@velopert/20180908-1909-작성됨-etjltaigd1" target="_blank" rel="noopener">Redux (4) Immutable.js 혹은 Immer.js 를 사용한 더 쉬운 불변성 관리</a></p><p>결론<br>위 글을 통해 Redux가 어떤 방식의 코드 베이스를 가지고 가는지 이해할 수 있다<br>Redux에 대해 좀 더 깊이있는 설명을 원한다면 다른 자료들을 함께 참고해야겠지만, 실용적으로 빠르게 이해 및 입문해서 사용하고자 한다면 최고의 자료일 것</p><h3 id="Redux-middleware"><a href="#Redux-middleware" class="headerlink" title="Redux-middleware"></a>Redux-middleware</h3><p><a href="https://shift.infinite.red/redux-observable-epics-vs-redux-sagas-8e53610c0eda" target="_blank" rel="noopener">Redux-Observable Epics vs Redux-Sagas</a></p><p>결론<br>저자의 의견은 Redux-Saga, 이 글까지만 읽어보았을 때는 내 생각도 동일하다<br>다른 글들도 좀 더 많이 읽어보고 어느 미들웨어를 선택하든 왜? 에 대한 답을 찾아야 할 것</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ESLint-Prettier&quot;&gt;&lt;a href=&quot;#ESLint-Prettier&quot; class=&quot;headerlink&quot; title=&quot;ESLint, Prettier&quot;&gt;&lt;/a&gt;ESLint, Prettier&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https:/
      
    
    </summary>
    
      <category term="Dev" scheme="https://eclatant.io/categories/Dev/"/>
    
    
      <category term="Dev" scheme="https://eclatant.io/tags/Dev/"/>
    
  </entry>
  
  <entry>
    <title>이번 주에 접했던 것들 #1 : 18-11-18</title>
    <link href="https://eclatant.io/2018/11/18/2018-11-18-WeeklyHistory/"/>
    <id>https://eclatant.io/2018/11/18/2018-11-18-WeeklyHistory/</id>
    <published>2018-11-17T15:00:00.000Z</published>
    <updated>2018-12-02T13:15:18.706Z</updated>
    
    <content type="html"><![CDATA[<h3 id="자바스크립트-Form-객체에-직접-접근"><a href="#자바스크립트-Form-객체에-직접-접근" class="headerlink" title="자바스크립트 : Form 객체에 직접 접근"></a>자바스크립트 : Form 객체에 직접 접근</h3><p><a href="https://developer.mozilla.org/ko/docs/Web/API/Document/forms" target="_blank" rel="noopener">Document.forms</a></p><p>결론 : documents.forms를 통해 현재 document에 존재하는 Form element들이 담긴 collection 을 반환받을 수 있다</p><h3 id="자바스크립트-Symbol-gt-String"><a href="#자바스크립트-Symbol-gt-String" class="headerlink" title="자바스크립트 : Symbol -&gt; String"></a>자바스크립트 : Symbol -&gt; String</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/description" target="_blank" rel="noopener">Symbol.prototype.description</a></p><p>결론 : Math.floor를 사용하세요</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>(<span class="string">"desc"</span>).description); <span class="comment">// "desc"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.iterator.description); <span class="comment">// "Symbol.iterator"</span></span><br></pre></td></tr></table></figure><h3 id="자바스크립트-Object에서-key와-value를-동시에-얻고-싶을-때"><a href="#자바스크립트-Object에서-key와-value를-동시에-얻고-싶을-때" class="headerlink" title="자바스크립트 : Object에서 key와 value를 동시에 얻고 싶을 때"></a>자바스크립트 : Object에서 key와 value를 동시에 얻고 싶을 때</h3><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank" rel="noopener">Object.entries()</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj)); <span class="comment">// [ ['foo', 'bar'], ['baz', 42] ]</span></span><br></pre></td></tr></table></figure><p>주의사항 : forEach, map, filter, reduce 등과 달리 k, v 조합이다</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;자바스크립트-Form-객체에-직접-접근&quot;&gt;&lt;a href=&quot;#자바스크립트-Form-객체에-직접-접근&quot; class=&quot;headerlink&quot; title=&quot;자바스크립트 : Form 객체에 직접 접근&quot;&gt;&lt;/a&gt;자바스크립트 : Form 객체에 직접 
      
    
    </summary>
    
      <category term="Dev" scheme="https://eclatant.io/categories/Dev/"/>
    
    
      <category term="Dev" scheme="https://eclatant.io/tags/Dev/"/>
    
  </entry>
  
  <entry>
    <title>글쓰기 시작</title>
    <link href="https://eclatant.io/2018/11/11/2018-11-11-Start/"/>
    <id>https://eclatant.io/2018/11/11/2018-11-11-Start/</id>
    <published>2018-11-10T15:00:00.000Z</published>
    <updated>2018-11-11T12:25:12.140Z</updated>
    
    <content type="html"><![CDATA[<p>올해 초에 작성했던, 글쓰기 시작 다짐글을 다시 읽어보았다.</p><p>다짐을 지키지 못했다..</p><p>내용 중 일부는 다음과 같았다.</p><hr><p>최근에 읽은 아티클 중에 관련하여 글쓰기와 관련하여 가장 인상적이었던 것은 <a href="https://ppss.kr/archives/16682" target="_blank" rel="noopener">글쓰기가 안 되는 분들을 위한 4단계 작문법</a> 이었다.</p><p>위 내용을 보고 여태까지 글쓰기가 힘들었던 것은 정신병자 단계를 거치지 않고 판사와 같은 마음으로 바라보고 있었기 때문이라는 것을 느꼈다.</p><p>그러다보면 이터레이션 주기가 길어지고, 따라서 성공할 수가 없었던 것이다.</p><p>앞으로 최대한 편안한 마음으로 좋은 글이 아닌, 그저 지각하지 않고 제때 제출하는 것만을 목표로 써보려고 한다.</p><p>그 과정에서 다른 분들과 많이 교류하며 글쓰기 외에도 많은 것들을 얻어갈 수 있기를 바란다.</p><hr><p>이번에도 정말 동일한 마음이다.</p><p>이루지 못했던 이유는 무엇인가?</p><p>늘 그렇듯 너무 부담스러워했던 탓이다.</p><p>그러지 않기 위해선 어떻게 할 수 있는가?</p><p>매일 단 한 문장이라도 써야 한다.</p><p>부담스러운 마음에 멈칫하며 미루면 순식간에 마감일이 찾아온다.</p><p>글 퀄리티가 낮아서 부끄러운 것보다 제출시점을 지키지 못하는 것을 부끄러워하자.</p><p>모든 부담을 내려놓고 편안하게 그러나 꾸준히 하자.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;올해 초에 작성했던, 글쓰기 시작 다짐글을 다시 읽어보았다.&lt;/p&gt;
&lt;p&gt;다짐을 지키지 못했다..&lt;/p&gt;
&lt;p&gt;내용 중 일부는 다음과 같았다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;최근에 읽은 아티클 중에 관련하여 글쓰기와 관련하여 가장 인상적이었던 것은 &lt;a 
      
    
    </summary>
    
      <category term="Essay" scheme="https://eclatant.io/categories/Essay/"/>
    
    
      <category term="Essay" scheme="https://eclatant.io/tags/Essay/"/>
    
  </entry>
  
  <entry>
    <title>이번 주에 접했던 것들 #0 : 18-11-11</title>
    <link href="https://eclatant.io/2018/11/11/2018-11-11-WeeklyHistory/"/>
    <id>https://eclatant.io/2018/11/11/2018-11-11-WeeklyHistory/</id>
    <published>2018-11-10T15:00:00.000Z</published>
    <updated>2018-12-02T13:15:02.836Z</updated>
    
    <content type="html"><![CDATA[<p>몇 달 동안 자바스크립트 및 알고리즘 문제 풀이를 쉬고 있다가, 다시 시작했다</p><p>생각보다 잊어버린 것들이 많았어서 좌절스럽기도 했지만, 그래도 다시 열심히 해보자</p><h3 id="자바스크립트-Integer-gt-String-String-value-vs-value-toString"><a href="#자바스크립트-Integer-gt-String-String-value-vs-value-toString" class="headerlink" title="자바스크립트 : Integer -&gt; String, String(value) vs value.toString()"></a>자바스크립트 : Integer -&gt; String, String(value) vs value.toString()</h3><p><a href="http://2ality.com/2012/03/converting-to-string.html" target="_blank" rel="noopener">Converting a value to string in JavaScript</a></p><p>결론 : value가 undefined || null 일 수 있으니 String(value)를 사용하라</p><h3 id="자바스크립트-String-gt-Integer-parseInt-vs-Math-floor"><a href="#자바스크립트-String-gt-Integer-parseInt-vs-Math-floor" class="headerlink" title="자바스크립트 : String -&gt; Integer, parseInt vs Math.floor"></a>자바스크립트 : String -&gt; Integer, parseInt vs Math.floor</h3><p><a href="http://2ality.com/2013/01/parseint.html" target="_blank" rel="noopener">parseInt() doesn’t always correctly convert to integer</a></p><p>결론 : Math.floor를 사용하세요</p><h3 id="자바스크립트-String-gt-Array-split-은-기대와-다른-동작"><a href="#자바스크립트-String-gt-Array-split-은-기대와-다른-동작" class="headerlink" title="자바스크립트 : String -&gt; Array, split()은 기대와 다른 동작"></a>자바스크립트 : String -&gt; Array, split()은 기대와 다른 동작</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split" target="_blank" rel="noopener">String.prototype.split()</a></p><p><code>str.split([separator[, limit]])</code>, 새로운 문자열을 리턴</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hello"</span>.split(); <span class="comment">// ["hello"]</span></span><br><span class="line"><span class="string">"hello"</span>.split(<span class="string">""</span>); <span class="comment">// ["h", "e", "l", "l", "o"]</span></span><br><span class="line"><span class="string">"hello"</span>.split(<span class="string">""</span>, <span class="number">3</span>); <span class="comment">// ["h", "e", "l"]</span></span><br></pre></td></tr></table></figure><p>관련 주의사항 : <a href="https://stackoverflow.com/a/34717402" target="_blank" rel="noopener">How do you get a string to a character array in JavaScript?</a></p><p>결론 : ES6를 사용해도 된다면, […str] || Array.from(str) 을 사용하자</p><h3 id="자바스크립트-String-반복"><a href="#자바스크립트-String-반복" class="headerlink" title="자바스크립트 : String 반복"></a>자바스크립트 : String 반복</h3><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/repeat" target="_blank" rel="noopener">String.prototype.repeat()</a> ES6</p><p><code>str.repeat(count)</code>, 새로운 문자열을 리턴</p><p>count는 양의 정수여야 한다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>.repeat(<span class="number">-1</span>);   <span class="comment">// RangeError</span></span><br><span class="line"><span class="string">'abc'</span>.repeat(<span class="number">0</span>);    <span class="comment">// ''</span></span><br><span class="line"><span class="string">'abc'</span>.repeat(<span class="number">1</span>);    <span class="comment">// 'abc'</span></span><br><span class="line"><span class="string">'abc'</span>.repeat(<span class="number">2</span>);    <span class="comment">// 'abcabc'</span></span><br><span class="line"><span class="string">'abc'</span>.repeat(<span class="number">3.5</span>);  <span class="comment">// 'abcabcabc' (count will be converted to integer)</span></span><br></pre></td></tr></table></figure><p>만약 반복한 결과를 Array로 돌려받고 싶다면?</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill" target="_blank" rel="noopener">Array.prototype.fill()</a> ES6</p><p><code>arr.fill(value[, start[, end]])</code>, 부수효과를 일으키는 함수</p><p>순차적으로 증가하는 숫자가 담긴 배열이 필요하다면?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...Array(<span class="number">5</span> + <span class="number">1</span>).keys()].slice(<span class="number">1</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h3 id="자바스크립트-배열이-특정-길이인지-여부"><a href="#자바스크립트-배열이-특정-길이인지-여부" class="headerlink" title="자바스크립트 : 배열이 특정 길이인지 여부"></a>자바스크립트 : 배열이 특정 길이인지 여부</h3><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/includes" target="_blank" rel="noopener">Array.prototype.includes()</a> ES7</p><p><code>arr.includes(searchElement[, fromIndex])</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">4</span>, <span class="number">6</span>].includes([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// true</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">6</span>].includes([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="자바스크립트-배열-요소중-최대값-구하기"><a href="#자바스크립트-배열-요소중-최대값-구하기" class="headerlink" title="자바스크립트 : 배열 요소중 최대값 구하기"></a>자바스크립트 : 배열 요소중 최대값 구하기</h3><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Math/max" target="_blank" rel="noopener">Math.max()</a></p><p><code>Math.max([값1[, 값2[, ...]]])</code></p><p>만약 인수 중 하나라도 숫자로 변환하지 못한다면 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/NaN" target="_blank" rel="noopener"><code>NaN</code></a>로 반환합니다.</p><p>만약 아무 요소도 주어지지 않았다면 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/-Infinity" target="_blank" rel="noopener"><code>-Infinity</code></a>로 반환합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, numberArray);</span><br><span class="line"><span class="built_in">Math</span>.max(...numberArray);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;몇 달 동안 자바스크립트 및 알고리즘 문제 풀이를 쉬고 있다가, 다시 시작했다&lt;/p&gt;
&lt;p&gt;생각보다 잊어버린 것들이 많았어서 좌절스럽기도 했지만, 그래도 다시 열심히 해보자&lt;/p&gt;
&lt;h3 id=&quot;자바스크립트-Integer-gt-String-Str
      
    
    </summary>
    
      <category term="Dev" scheme="https://eclatant.io/categories/Dev/"/>
    
    
      <category term="Dev" scheme="https://eclatant.io/tags/Dev/"/>
    
  </entry>
  
  <entry>
    <title>The Real TDD</title>
    <link href="https://eclatant.io/2018/10/18/2018-10-18-RealTDD/"/>
    <id>https://eclatant.io/2018/10/18/2018-10-18-RealTDD/</id>
    <published>2018-10-17T15:00:00.000Z</published>
    <updated>2018-10-18T17:09:35.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-Real-TDD"><a href="#The-Real-TDD" class="headerlink" title="The Real TDD"></a>The Real TDD</h1><p>테스트 하기 쉬운 코드란?</p><ul><li>순수함수와 같이, 동일 인풋에 동일 아웃풋 (데이터베이스를 조회해야 한다면 항상 같은 값을 리턴받을 것이라 기대하기 힘들 것)<ul><li>Deterministic</li></ul></li><li><p>외부상태를 변경하지 않는 코드</p><ul><li>No side effects</li></ul></li><li><p>유효성 검사</p><ul><li>TDD 맛보기<ul><li>Arrange, Act, Assert</li><li>테스트를 만족하는 만큼만 구현하라</li><li>부가적 코드들은 테스트 커버리지에 포함되지 않을 것</li><li>점진적 구현의 효과도 상실</li></ul></li></ul></li><li>등록된 좌석 수를 디비에서 불러오기<ul><li>테스트하기 힘듬</li><li>테스트하기 쉬운 코드와 어려운 코드를 분리하자<ul><li>간단한 연산을 테스트하기 위해 테스트 데이터 필요</li><li>녹색과 빨간색을 분리하자 (안 그러면 녹색도 테스트하기 어려운 상황)</li><li>디비에서 받아와야 하는 정보는 파라미터로 분리하거나 프로퍼티를 참조</li></ul></li><li>두 부류의 코드는 어디에서 만나야 하나?<ul><li>테스트하기 어려운 코드를 호출해서 사용해야 한다면 호출하는 코드도 테스트하기 어려울 것</li><li>그러니 분리해서 최대한 가장자리에서 만나도록 하자 (테스트하기 어려운 여파가 최대한 덜 미치도록)</li><li>예외 : 로깅, 퍼사드</li></ul></li><li>두 부류가 만나는 가장자리는 어떻게 테스트하나?<ul><li>수동테스트<ul><li>자동화테스트가 불필요할 정도로 간단한 경우</li></ul></li><li>자동테스트<ul><li>작성된 코드 사용을 강제할 수 있나?<ul><li>실제 클래스 대신 목 사용을 위해 이음새(Seam)가 필요<ul><li>인터페이스</li><li>추상클래스</li><li>보철메소드(?)</li></ul></li><li>목을 만들고 생성자에게 넘겨주고, 메소드 내에서 입력받은 인풋을 프로퍼티에 할당하도록 하고 그것을 메소드 실행 후에 assert로 검증</li><li>목 사용으로 작성된 코드 사용을 강제할 수 있다</li><li>하지만 생각해볼 포인트<ul><li>목 사용은 행위 검증<ul><li>행위가 호출되었는가</li><li>불필요한 추상화 유발 가능성</li><li>구현되지 않은 코드에 의존 가능</li><li>아웃사이드인 기법</li></ul></li><li>목 사용하지 않는 것은 상태 검증<ul><li>결과값이 무엇인가</li><li>불필요한 추상화 필요없음</li><li>구현된 코드에만 의존</li><li>인사이드아웃 기법</li></ul></li><li>목 사용의 문제점<ul><li>목을 남발할 가능성이 크다</li><li>적정 수의 목 사용에 대한 답을 찾기 어렵다</li><li>상태 검증으로 돌아가보자</li></ul></li><li>상태검증 문제 극복 방안<ul><li>사후 테스트를 하자</li><li>구현된 코드를 사용하지 않고 굳이 어려운 길을 택할 필요가 없다</li><li>목 사용도 비용이다</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li>요청 좌석 수가 가능한지 판단</li><li>등록 정보 저장<ul><li>테스트하기 힘듬</li></ul></li><li><p>HTTP response</p><p>두 부류의 코드를 분리해서 각각 테스트<br>가장자리에서 맞물려 돌아가는 코드는 주로 수동테스트<br>jwchung.github.io/testing-oh-my<br>테스트 코드가 단순하기에 테스트 코드에 대한 테스트 코드를 작성하지 않듯이 단순하고 실수할 가능성이 낮은 부분에 대해 많은 비용을 들이려하지 않는다<br>두 부류 코드를 섞어 넣고 테스트가 어렵다고 포기하지 마세요</p><p>프라이빗 메소드는 어떻게 테스트?</p></li><li><p>테스트 대상 코드와 테스트 코드의 접촉 면적은 작을수록 좋습니다</p><ul><li>한 가지 메소드를 건들여서 가는게 좋습니다</li><li><p>어떤 것은 퍼블릭 메소드로 할 것인가?</p><p>레거시 코드에 대해서는 어떻게 하는가?</p></li></ul></li><li>목업이 필요할 상황</li><li>레거시 코드와 결합도를 낮춰라</li><li>새로 생성된 코드에 테스트를 가할 것</li><li><p>케릭터라이제이션 테스트</p><ul><li>요구사항만 적어놓고 테스트</li><li><p>테스트 안전망을 두고 리팩토링</p><hr><p>의식적인 연습으로 TDD, 리팩토링 연습하기</p><p>왜 해야 하는지 왜 중요한지는 알고 있다는 가정하에 시작</p><p>비중 : TDD &lt; 리팩토링</p><p>리팩토링을 이야기하는 것도 TDD에 관련된 이야기일 수 밖에 없음</p><p>의식적인 연습이란?<br>의식적인 연습으로 TDD, 리팩토링 연습 과정</p><p>연습을 많이 한다고 잘 할 수 있는가?</p><p>테스트하기 쉬운 코드와 어려운 코드를 보는 눈<br>테스트하기 어려운 코드를 테스트하기 쉬운 코드로 설계하는 감</p><p>많은 수련과 연습이 필요하다</p><p>효과적으로 연습하려면?</p><p>1만 시간의 재발견<br>아마추어와 프로의 결정적 차이</p></li></ul></li><li>목적 의식 있는 연습에 얼마나 많은 시간을 투자하는가?</li><li><p>7원칙</p><ul><li>컴포트존 벗어나기, 현재 능력보다 살짝 넘어가는 작업 지속적 시도</li><li>명확하고 구체적인 목표</li><li>피드백과 피드백에 따른 행동 변경을 수반</li><li><p>기존 습득한 기술의 특정 부분을 집중적으로 개선하고 수정하는 과정 (한 번에 너무 여러 가지를 개선하려고 하지 말 것)</p><p>의식적인 연습을 통한 효과적 개선</p><p>단위 테스트 연습</p></li></ul></li><li>TDD보다 단위 테스트부터 연습하라</li><li>내가 사용하고 있는 API 사용법을 익히기 위한 학습 테스트부터 시작, 인풋과 아웃풋이 명확한 유틸성 메소드에 대한 연습</li><li><p>의도하는데로 잘 동작하는가?</p><p>알고리즘을 학습한다면 알고리즘 구현에 대한 검증을 단위 테스트로 한다, 인풋 아웃풋이 명확해서 테스트하기 수월</p><p>TDD 연습</p><p>지켜야 할 원칙 : 회사 프로젝트에 연습하지 말고 토이 프로젝트를 활용해 연습하자<br>프로덕션 코드는 도입하기가 어렵기 때문에 처음부터 시도하기엔 어려울 것</p><p>어떤 인풋이 들어오면 어떤 아웃풋이 나올지를 미리 정의하고 시작해야 감이 잡힐 것</p><p>테스트 fails, 테스트 passes 까지만 연습해보자</p><p>테스트 코드를 먼저 만드는 것만해도 쉽지 않을 것</p><p>난이도가 낮거나 자신에게 익숙한 문제로 시자가는 것을 추천</p><p>리팩토링 연습</p><p>메소드 분리</p></li><li>모든 프로그래머가 갖춰야 할 기본 역량</li><li>한 메소드에 오직 한 단계의 들여쓰기만 한다, 그 이상은 메소드로 분리</li><li>else를 쓰지 않는다</li><li>한 가지 일만 해도록 하기<ul><li>섬은 스트링을 인트로 바꾸는 과정도 포함하고 있다</li></ul></li><li>로컬 변수가 정말 필요한가?</li><li><p>컴포즈 메소드 패턴 (동등한 수준의 메소드로 분리)</p><ul><li><p>연습할 때는 극단적으로 해야 느끼는 것과 인사이트가 생겨난다</p><p>한 번에 한 가지 명확하고 구체적인 목표를 가지고 연습하라, 한 번이 모든 원칙을 지키면서 리팩토링을 하려고 하면 너무 어렵다, 여유가 없으면 창의적일 수 없음<br>메소드 라인 수 제한을 15 -&gt; 10 -&gt; 8 라인</p></li></ul></li><li><p>설계에 대한 인사이트가 생긴다</p><p>클래스 분리</p></li><li>모든 원시값과 문자열을 포장한다(클래스로 추출하라)<ul><li>Validate이 보장된 클래스</li></ul></li><li>일급 콜렉션을 사용</li><li><p>3개 이상의 인스턴스 메소드가 있는 클래스를 쓰지 않는다</p><ul><li>객체 설계 연습을 정말 많이 하게 되어요</li><li><p>정량적인 연습을 계속 해보세요</p><p>토이 프로젝트 난이도 높이기</p></li></ul></li><li><p>점진적으로 요구사항이 높은 프로그램</p><ul><li>게임</li><li>의존관계가 없는 것</li><li>약간은 복잡한 로직이 있는 프로그램</li><li>로또</li><li>사다리 타기</li><li>볼링게임 점수판</li><li>체스게임</li><li><p>지뢰첮기</p><p>의존 관계 추가를 통한 난이도 높이기</p></li></ul></li><li>의존 관계가 필요한 프로젝트</li><li><p>이때 필요한 역량은 설계 역량, 테스트 하기 쉬운 코드와 어려운 코드를 분리하는 역량</p><p>한 단계 더 나아간 연습</p></li><li>컴파일 에러 최소화</li><li>ATDD 기반으로 응용 애플리케이션 개발</li><li><p>레거시 애플리케이션에 테스트 코드 추가해 리팩토링하기</p><ul><li><p>갈수록 유지보수역량이 뛰어난 사람이 필요할 것이다</p><p>구체적인 목표 연습 찾기</p></li></ul></li><li>소트웍스 앤솔러지<ul><li>객체지향 생활체조 원칙</li></ul></li><li><p>클린코드</p><ul><li>메소드 인수 개수 줄이기(2개 이하)</li><li><p>클래스 크기를 최대한 작게 만들어서 가독성을 확보</p><p>여유, 같은 과제를 반복적으로 구현할 수 있는 인내력, 꾸준히 도전할 수 있는 용기</p><p>컴포트존 극복 노하우</p></li></ul></li><li>경력이 쌓일수록 어렵다</li><li>삶에 여유와 에너지가 있어야 한다</li><li><p>남들이 하는 것을 다 하면서 성장하긴 어렵다, 일정 시간 몰입의 시간이 필요하다</p><p>테스트 코드를 빡빡하게 짜놓을수록 요구사항의 변경시에 발목을 잡는데 노하우가 있는가?</p></li><li>요구사항 변경이 문제가 아니라 설계를 잘못했기에 테스트 코드의 변화가 많아진 것이다</li><li><p>나중에 개선할 수 있는 타이밍이라는 것은 오지 않는다</p><hr><p>Test driven development for code quality</p><p>Overview of TDD<br>The three rules of TDD<br>TDD 이점</p></li><li>테스트 자동화의 장점<ul><li>개발 생산성 향상<ul><li>보통 테스트를 위한 오버헤드와 실제 구현에 드는 리소스를 1:1로 본다</li><li>이펙티브 유닛 테스팅: 어 가이드 포 자바 디벨로퍼스</li></ul></li></ul></li><li><p>테스트 우선의 이점</p><ul><li><p>코드 품질 향상</p><p>Think more about TDD</p><p>코드 퀄리티 : Titanic diemma / jonathan bloom seen versus the unseen</p><p>인터널 퀄리티 + 익스터널 퀄리티</p><p>The seven axes of code quality from sonarcube</p><p>Success with TDD</p><hr><p>테스트 시작하기</p><p>테스트를 할 때는 프로덕션 코드는 건들이지 않는다<br>리팩토링할 때는 테스트 코드는 수정하지 않는다</p><p>not.toThrowError</p><p>테스트가 단언하고 있는 내용이 사용자에게 중요한 가치를 주는 것인가?<br>비즈니스와 관련된 버그인가?<br>유지해서 얻는 이득보다 관리 비용이 더 큰 테스트는 아닌가?<br>중 하나라도 해당하면 테스트하지 않음</p><p>DOM 구조는 변화가 자주 있기 때문에 해당 사항을 고려한 테스트 코드를 짠다</p><p>고민사항</p></li></ul></li><li>픽스쳐 관리</li><li><p>함수로 계속 분리하는게 옳은 방식인가?</p><ul><li>추상화 수준이 낮아서 클라이언트에서 구체적인 내용을 알아야만 사용할 수 있는 것</li><li><p>높은 응집, 낮은 결합 중 낮은 결합만 달성한 것</p><p><a href="mailto:irinso93@gmail.com" target="_blank" rel="noopener">irinso93@gmail.com</a></p><hr><p>테스트 코드는 프로젝트 코드가 사용되는 최초의 장소이며 고객이다</p><p>모든 역사는 테스트 코드부터 시작된다</p><p>숨겨진 본질</p></li><li>낮은 추상화</li><li>들쭉날쭉한 추상화</li><li>끊어진 논리</li><li>알 수 없는 의도<br>욕심쟁이</li><li>테스트가 실패하는 이유는 오직 단 하나여야 함</li><li>하나의 테스트는 오직 한 가지만 검사해야 한다(SRP)<br>인지능력의 과부화</li><li>흩어진 코드와 데이터</li><li>매직넘버<br>깨지기 쉬운 것들</li><li>높은 결합</li><li><p>낮은 응집</p><p>테스트를 이해하려면 그것의 환경을 이해해야 한다</p><p>추상이란?<br>문맥 위에서 오직 관심 있는 것들에 대해서만 집중하여 명확하게 하는 것</p><p>테스트 코드의 의도가 명시적이 될 수 있도록 프로덕션 코드를 개선해나간다</p><p>테스트 코드도 프로덕션 코드의 일부라고 바라보자</p><p>테스트는 과정 수련 스승 거울 제품이다<br>억지로 먼저 하지 마라, 건강하게 하라, 두려워하지 마라, 즐거워해라</p><p>테스트가 우리를 가르쳐줘요</p><p>테스트 코드를 리팩토링하고 피쳐를 추가할 여유가 없다면, 격리를 시켜서 내가 추가해야 할 코드의 사이즈를 줄여놓고 그 부분에 대해서만 진행을 한다</p><hr><p>사이언스 vs 엔지니어링 짤방</p><p>엔지니어링 : 과학과 예산 간의 균형점</p><p>중요한 것은 목표 달성이지, How가 중요하진 않을 수 있다</p><p>과학자가 아니기에 TDD가 문제 해결에 도움이 되면 하고, 아니면 안 한다</p><p>준비가 되지 않았다면 TDD가 아닌 방식으로 먼저 목표를 달성하고, 그 이후에 준비가 되가는만큼 도입해야 한다</p><p>우리가 보호해야 하는 것 = 도메인</p><p>제어할 수 없는 외부 세계를 다루려고 하지 않는다</p></li></ul></li><li>실세계</li><li>인프라</li><li>외부 서비스</li><li><p>레거시</p><p>낮은 결합, 높은 응집, 도메인 모델 보호</p><p>설계를 테스트하라<br>코드가 이루려는 가치를 테스트하라</p></li><li>Stub 간접적인 입력 spy 간접적인 출력</li><li><p>위를 사용해야 하는 것은 구체적인 구현을 알아야 하는 테스트일 가능성이 높다</p><p>정보 숨김 information hiding</p></li><li><p>어려운 설계 결정과 변경될 가능성이 높은 설계 결정들을 다른 모듈로부터 숨기는 것</p><p>테스트 코드가 구현을 아는 것이 아니라 인터페이스를 테스트해야 한다</p><p>어디까지가 인터페이스고 임플리테이션인가?</p><p>레거시와 함께 살기</p><p>어댑터 레이어를 통해 새로 작성하는 코드는 깨끗함을 유지, 해당 레이어는 테스트하지 않고 매뉴얼 테스트로도 테스트 가능하도록 단순하게 짠다</p><p>점진<br>반복<br>Fail-Fast</p><p>가설<br>실험<br>검증</p><p>계획<br>실행<br>평가</p><p>보통은 바로 실험이나 실행만 한다</p><p>팀 내 목표와 지식에 대한 공유 문화가 매우 중요</p><p>스프링과 도메인 모델이 강결합되어있는 것 아닌가, 이러면 도메인 모델이 보호받지 못한다</p><p>도메인 모델, 중요한 코드일수록 플랫폼에서 독립적이어야 한다</p><p>플랫폼 -&gt; 모듈 -&gt; 서비스 -&gt; 비즈니스 로직</p><p>View, View Model, Model</p><p>사용자에게 어떤 가치를 전달할 것인가?<br>두루뭉실하게 해서는 안 된다</p><p>화이트보드를 통해 설계를 하는 것을 통해 목표와 목적을 공유할 수 있습니다</p><p>목적 달성을 위해선 시스템에 어떤 변경이 필요한가?</p><p>소프트웨어 변경은 어떤 세부 작업들이 있는가?<br>각 작업들은 어떤 순서로 진행되어야 하는가?<br>각 작업들은 누가 담당하는가?</p><p>ATDD + TDD<br>ATDD Red -&gt; unit test red -&gt; green -&gt; refactor -&gt; ATDD green</p><p>이 작업에는 어떤 코드 변경(커밋)이 필요한가?</p><p>작업을 구체적으로 설계하고 실제로 내가 했을 때와의 간극을 끊임없이 검증해서 내가 사전적으로 놓친 것을 파악해야 할 것</p><p>그린 단계에서는 방금 작성한 코드 뿐 아니라 모든 테스트가 통과해야만 한다</p><p>레드 단계의 에러 메시지를 살피지 않으면 테스트가 완성되지 않은 상태에서 그린으로 넘어가려고 할 수 있으니 주의할 것</p><p>피드백</p></li><li>단위 테스팅</li><li>코드 리뷰</li><li>기능 테스킹</li><li>수동 테스팅</li><li><p>사용자 반응 수집</p><p>코딩만 페어 프로그래밍을 하는 것이 아니라 테스크를 처리하는 과정까지 모두 페어링을 하였음</p><p>유저 스토리를 비즈니스팀에서 러프하게 주면, 화이트보드에 그림을 그려보면서 검증, 초기 분석을 가지고 목록화, 어싸인되지 않은 유저스토리를 가져간다, 분석해서 어떤 코드를 작성해야하는지 판단하여 기재하여 리뷰를 요청하고, 테스크를 혼자 또는 나누어 진행할 수 있게 분배, 분배 후 페어링 또는 개별 분석을 통해 진행</p><p>통합 테스트<br>단위 테스트만으로는 불안감이 해소되지 않는다<br>단위 테스트는 다 성공하는데 기능 테스트는 깨지는 때<br>조합이 잘 되었는지 확인이 필요<br>외부 서비스 같은 경우에는 페이크 서비스를 만들어서 잘 결합하는지 확인</p><hr><p>패널토크</p><p>TDD가 왜 더 나은가? 어떻게 납득시킬 수 있는가?</p><p>수많은 방법론 중에 왜 TDD인가?</p></li><li>테스트 코드를 짜면 프로덕션 코드에 대해 애정이 생기고 섬세하게 다루게 된다</li><li><p>가장 빠른 피드백을 준다</p><p>프로그램의 본질은 구현체인데, 본질적 가치가 아닌 테스트나 리팩토링 등을 납득시킬 수 있는가?</p></li><li>굉장히 외롭습니다, 퀄리티를 위해 테스트를 한다, 설계적인 관점에 이점을 준다, 프로덕션에 영향을 주는 방법이다, 의사가 멸균을 하듯이 자연스럽게 이루어져야 하는 과정이다</li><li>주니어 개발자라면 다른 이를 설득하지 말고 내 만족을 위해서 하세요 그런데 내가 만들어놓은 코드에 대해 타인이 궁금해하면 전파하면 된다고 생각합니다, 전파에 너무 집착하지 마세요, 의사결정자가 되었을 때 가치있는 소프트웨어를 만드는데 필요하다는 확신이 들면 도입하면 좋겠어요</li><li>피드백을 빠르게 받는게 직무탈진율을 낮춘다, 삶의 퀄리티를 높여줍니다, TDD가 어디서부터 생긴 것인가? 애자일에서 발생한 것, 애자일한 환경이 갖춰졌을 때 TDD가 중요할 수 있다, 애자일에서는 개발을 사회적 활동으로 봅니다, 어떻게 하면 같이 할 수 있을까를 고민해봐야 합니다, 애자일은 모든 것이 모호한 상황에서 시도하는 곳이기에 다 준비되고 시작할 때 한다는 것은 애자일하지 않은 것일 수 있다, 주니어일 때 남들과 TDD를 같이 하기 수월할 수 있다</li><li>팀원들이 문제를 계속해서 끌어내도록 환경을 만들어서 팀원들로부터 짝 프로그래밍 등을 하자고 제안하도록 만든다, 팀장이 아닌 팀원이 드라이빙하도록 해서 하나씩 변화를 만들어간다, 팀원일 때는 변화를 만들어내기 위한 잽을 던지는 근육을 만들어야 시니어가 되었을 때 변화를 도입할 수 있다고 생각합니다</li><li><p>애자일을 도입할 때 애자일하게 도입하지 않는 경우가 많습니다, 마찬가지로 TDD도 점진적으로 도입시킬 수 있도록 작게 나누어서 도입시키고, TDD는 테스트의 순서가 대단히 중요한데 작지만 에센스한 것을 선택해야 합니다, 작은 것을 하되 에센스가 무엇인지 찾아야 합니다, 동료 개발자들의 문제 의식일 수도 있는 등 작지만 중요한게 무엇일까에 대한 생각을 해보는 것이 중요할 것 같습니다</p><p>코드 커버리지를 어떤 기준으로?</p></li><li><p>매트릭스 자체에 집중하면 원래 얻고자 하는 것을 잃는 경우가 많습니다, 테스트 품질 자체도 대단히 중요합니다, 지표가 정해지면 그 지표만을 위한 테스트 케이스들이 만들어질테니 좋지 않다고 봅니다, 쉽지 않지만 테스트 커버리지에 집착하지 않는게 중요하고 실제 프로덕션 코드에 대한 이해를 높인다는 관점으로 접근하면 좋겠습니다, TDD 자체에 집착하지 말고 새로운 문제 등일 때 아직 명확하지 않을 때 조건과 인풋 아웃풋을 다듬어가면서 가야 할 때는 TDD에게 문제 해결방안을 얻어가면 좋겠습니다</p><p>신입이 TDD 공부할 때 추천 콘텐츠</p></li><li>페어 프로그래밍 후 혼자 연습, 정진욱님 블로그 정주행</li><li>아트 오브 유닛 테스팅 -&gt; XUnit patterns(Arrange가 대단히 어려운데, 테스트에서 일어나는 모든 상황이 정리되어있습니다, 케이스를 선택할 수 있었습니다) -&gt; goos</li><li>테스트 주도 개발, 리팩토링</li><li>유튜브에 리팩토링이나 TDD 관련 카타 라고 검색하면 굉장히 많이 나옵니다</li><li><p>TDD는 종합예술같은 것이에요, 모든 것들이 결집되어 나타나는 산출물이기 때문에 한 번에 얻어내긴 어려우실 거에요, 테스트가 주는 이점을 많이 느끼고 그것을 바탕으로 성장하는게 필요합니다</p><p>도메인 모델과 스프링의 접점을 왜 줄여야 하는가?</p></li><li>새로 나오는 좋은 도구와 플랫폼이 나와도 옮겨갈 수 없다, 중요한 도메인 모델이 덜 중요한 플랫폼에 종속하도록 하는 것은 좋은 결정이 아니라고 생각합니다</li><li>스프링이나 데이터베이스 기반이 아니라 순수 언어 기반으로 프로그래밍 연습을 하고 변경을 최소화하면서 외부 세계와의 접점을 늘려가세요, 많은 프로그래머들이 프레임워크 기반으로 연습을 하다보니까 순수한 언어 기반 연습을 잘 안하게 되는데 그것을 하고 나서 프레임워크로 가보면 또 다른 인사이트를 느낄 수 있습니다</li><li>도메인 모델, DTO, 퍼시스턴트 오브젝트 등으로 모두 분리할 수 있는가, 복잡하지 않을 때는 공유하는게 이점이 있을 것</li><li>도메인 모델에 로직이 있어야 하는데 스프링 영역으로 내려오면 테스트가 힘들어집니다, 객체지향적 사고를 해야 합니다</li><li>DDD에서 도메인과 기술을 구분하는 것에는 동의하지만, 프레임워크가 도메인에 침투되는 것은 어쩔 수 없지만 얼마나 최소화하느냐 그리고 우리 상황에 얼마나 맞게 할 수 있느냐가 중요합니다, 무조건적인 분리를 이루려고 하면 또 잃는게 많을 수 있습니다</li><li><p>자바가 아닌 스프링으로 시작하는 것에 대한 저항감을 가지고 있는 것이 주니어 입장에서 좋겠습니다</p><p>레거시에 도입</p></li><li>그냥 두는 것이 방법이라고 생각합니다, 비즈니스적으로 이유가 없다면, 있을 때도 변경을 최소화하는게 필요하다고 생각합니다, 레거시에는 하지 않고 새로운 것을 도입할 때 하는게 좋다고 생각합니다, 최소한 변경하는 것은 또 디자인의 문제입니다</li><li>레거시가 방대한데 우리는 그 곳에서 또 살아야 합니다, 방치할 수는 없습니다, 팀 문화가 괜찮다면 점진적으로 리팩토링해나가야죠, 전체적으로 문화를 만들어야만 전체적인 리팩토링을 이룰 수 있다고 생각합니다</li><li>레거시와 친하게 지내세요, 착한 레거시도 있어요, 잘 나눠줘야되어요, 나쁜 레거시는 잘 인정해주어야 되어요, 그와 소통하는 인터페이스만 잘 만들어주면 되는 거에요, 비즈니스를 위해 일을 해야 합니다, 잘 일하고 있는 착한 레거시를 가만히 둡시다</li><li>개발자들은 ROI를 항상 생각해야 합니다, 그렇지 않으면 무의미한 것에 매몰될 수 있습니다, 3000라인 17중첩 일주일에 한 두 번 수정하면서 if문 추가 대마왕 7천라인 얘는 3천라인, 소마왕 해결하고 싶은데 도와줄 수 있냐, 2~3시간 만에 50라인으로 줄였어요, 모두가 공감하고 있었고 그래서 수정했기 때문에 계속 혜택을 누리게 되면 동참하게 되어요, 그냥 레거시를 다 적으로 생각하지 말고, 모두 ROI를 기반으로 판단하시면 항상 복리효과를 누리실 수 있을 것이라 생각합니다–</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;The-Real-TDD&quot;&gt;&lt;a href=&quot;#The-Real-TDD&quot; class=&quot;headerlink&quot; title=&quot;The Real TDD&quot;&gt;&lt;/a&gt;The Real TDD&lt;/h1&gt;&lt;p&gt;테스트 하기 쉬운 코드란?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;순수
      
    
    </summary>
    
    
      <category term="TDD" scheme="https://eclatant.io/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>코드스피츠 3기 함수와 OOP - 3강</title>
    <link href="https://eclatant.io/2018/09/20/CodeSpitz-3-3/"/>
    <id>https://eclatant.io/2018/09/20/CodeSpitz-3-3/</id>
    <published>2018-09-19T15:00:00.000Z</published>
    <updated>2018-09-20T17:10:42.245Z</updated>
    
    <content type="html"><![CDATA[<p>어플리케이션을 짤 때, 대부분의 경우는 인식하여 구조화해서 프로그래밍 해야 하는 경우가 대부분</p><p>HTML 파서를 짤려면 HTML 을 보고 구조적으로 분석해야 함</p><p>구조화를 무한히 하면 무한한 케이스가 될 뿐, 구조화의 목표는 단순한 원리의 조합이나 창발을 통해서 설명할 수 있고자 하는 것</p><p>A = <tag>BODY</tag></p><p>B = <tag></tag></p><p>C = TEXT</p><p>BODY = (A | B | C)N</p><p>위와 같이 간단한 원리로 압축하여 그것의 창발로 현상을 설명할 수 있어야, 알고리즘도 간단한 만큼만 구현할 수 있다</p><p>HTML 을 장황하게 설명하면, 장황함을 커버하는 알고리즘을 짜야 한다</p><p>현상을 보고 구조적이고 재귀적인 형태의 파악을 할 수 있는가? 데이터 구조를 만들어 낼 수 있는가? 가 핵심이다</p><p>내부 구성요소로부터 응용 구성요소로 확장하는 것을 BNF 정의방식이라고 함</p><p>A 는 BODY 를 가지고 있는데 BODY 는 A 를 가지고 있을 수 있으므로 재귀가 시작됨</p><p>재귀적인 센스가 없다면 위와 같이 사물을 바라보기가 어렵다</p><p>재귀적으로 짜지 않으면 모든 케이스를 다 처리하기 위한 조건문이 필요해진다</p><p>재귀적으로 처리하는 과제를 수행해보게 되면, 그 다음부터는 해당 계열의 문제를 해결할 수 있고 그러면 사물을 그렇게 바라볼 수 있게 되고, 그렇게 되면 많은 부분들을 개발할 수 있게 됨</p><p>케이스가 확정적인 것만 구현할 수 있다면 초급개발자, 케이스가 재귀적이면서 복합적인 상황들을 처리할 수 있다면 중급개발자</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parser = <span class="function"><span class="params">input</span> =&gt;</span> &#123;</span><br><span class="line">  input = input.trim();</span><br><span class="line">  <span class="keyword">const</span> result = &#123; <span class="attr">name</span>: <span class="string">"ROOT"</span>, <span class="attr">type</span>: <span class="string">"node"</span>, <span class="attr">children</span>: [] &#125;;</span><br><span class="line">  <span class="keyword">const</span> stack = [&#123; <span class="attr">tag</span>: result &#125;];</span><br><span class="line">  <span class="keyword">let</span> curr,</span><br><span class="line">    i = <span class="number">0</span>,</span><br><span class="line">    j = input.length;</span><br><span class="line">  <span class="keyword">while</span> ((curr = stack.pop())) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>함수를 디자인할 때는 인풋값과 리턴값을 디자인하는 것입니다</p><p>이 함수가 무엇을 하는지는 어떤 시그니처를 가지고 있느냐에 달려있습니다</p><p>parser 가 동작하는 방향은 children 을 어떻게 채우느냐에 달려있습니다</p><p>텍스트 덩어리는 구조적인 객체화를 시켜서 리턴하고 싶습니다</p><p>일차원 루프로는 순환적인 문제를 풀 수 없습니다</p><p>스택 수준을 오갈 수 있어야지만 일관된 루프로 처리할 수 있습니다</p><p>대상을 처리하는 것은 하나의 알고리즘이지만, 대상을 바꾸려면 스택을 오가야 하기 때문입니다</p><p>그래서 스택 구조가 바깥에 있고, 안에 알고리즘 구조가 있는 식으로 구현되어있습니다</p><p>현재 처리중인 스택을 curr 라고 부르기로 합니다</p><p>stack 은 전체 stack 루프를 위한 것입니다</p><p>tag 라는 것은 가상의 DOM 객체를 의미합니다</p><p>동적으로 루프가 변하는 루프를 짜봐야 합니다</p><p>안에 있는 이너루프는 j 값이 확정적입니다, 이 루프는 중간에 변하지 않습니다</p><p>그에 비해서 스택 루프는 루프회수가 얼마나 될지 결정되지 않았습니다</p><p>이너루프에서 스택에 변하면 루프회수가 늘어나거나 줄어듭니다, 따라서 동적 계획에 따른 루프입니다</p><p>계획되지 않은 루프는 위험하다고 생각하시면 안 됩니다</p><p>고급루프는 모두 런타임에서 루프회수가 변합니다</p><p>input 값에 따라 루프회수가 변합니다</p><p>동적 계획에 따른 루프 : 루프를 결정하는 요인이 이너루프를 돌면서 변할 수 있는 루프</p><p>중급 이상에서는 오히려 이런 루프가 기본입니다</p><p>루프를 돌 때, 무한루프가 될 수 있으니 안정적으로 확정루프가 될 수 있는지 확인하고 루프를 쓰라는 것은 모두 주니어들만을 위한 이야기입니다</p><p>실제로 루프회수가 얼마나 될지는 루프를 돌다가 깨닫는 경우가 많습니다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parser = <span class="function"><span class="params">input</span> =&gt;</span> &#123;</span><br><span class="line">  input = input.trim();</span><br><span class="line">  <span class="keyword">const</span> result = &#123; <span class="attr">name</span>: <span class="string">"ROOT"</span>, <span class="attr">type</span>: <span class="string">"node"</span>, <span class="attr">children</span>: [] &#125;;</span><br><span class="line">  <span class="keyword">const</span> stack = [&#123; <span class="attr">tag</span>: result &#125;];</span><br><span class="line">  <span class="keyword">let</span> curr,</span><br><span class="line">    i = <span class="number">0</span>,</span><br><span class="line">    j = input.length;</span><br><span class="line">  <span class="keyword">while</span> ((curr = stack.pop())) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">const</span> cursor = i;</span><br><span class="line">      <span class="keyword">if</span> (input[cursor] === <span class="string">"&lt;"</span>) &#123;</span><br><span class="line">        <span class="comment">// A, B의 경우</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// C의 경우</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>처음부터 끝까지 쭉 훑는 것을 스캐너라고 부른다</p><p>이너루프는 받아온 문자열을 처음부터 끝까지 도는 것이니 스캐너이다</p><p>이너루프안에서 로직계산시에 i 를 건들일 수 있는데 i 는 루프를 결정하는 것이므로 위험하므로 i 를 cursor 에 대입함</p><p>&lt;로 시작하면 태그로 볼 수 있다, 태그가 아니라면 C 즉 TEXT 타입이다</p><p>C 가 더 쉬우니 TEXT 처리부터 진행한다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parser = <span class="function"><span class="params">input</span> =&gt;</span> &#123;</span><br><span class="line">  input = input.trim();</span><br><span class="line">  <span class="keyword">const</span> result = &#123; <span class="attr">name</span>: <span class="string">"ROOT"</span>, <span class="attr">type</span>: <span class="string">"node"</span>, <span class="attr">children</span>: [] &#125;;</span><br><span class="line">  <span class="keyword">const</span> stack = [&#123; <span class="attr">tag</span>: result &#125;];</span><br><span class="line">  <span class="keyword">let</span> curr,</span><br><span class="line">    i = <span class="number">0</span>,</span><br><span class="line">    j = input.length;</span><br><span class="line">  <span class="keyword">while</span> ((curr = stack.pop())) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">const</span> cursor = i;</span><br><span class="line">      <span class="keyword">if</span> (input[cursor] === <span class="string">"&lt;"</span>) &#123;</span><br><span class="line">        <span class="comment">// A, B의 경우</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> idx = input.indexOf(<span class="string">"&lt;"</span>, cursor);</span><br><span class="line">        curr.tag.children.push(&#123;</span><br><span class="line">          type: <span class="string">"text"</span>,</span><br><span class="line">          text: input.substring(cursor, idx)</span><br><span class="line">        &#125;);</span><br><span class="line">        i = idx;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  a</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span>&gt;</span>b<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  c</span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span>/&gt;</span></span><br><span class="line">  d</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;div&gt;</code> 뒤부터 <code>&lt;a&gt;</code> 앞까지는 모두 텍스트로 볼 수 있다</p><p>현재 바라보고 있는 스택에 있는 tag 의 자식에 텍스트 노드를 집어넣는다</p><p>그리고 그것을 처리해준 뒤 시점으로 i 를 이동시킨다</p><p>읽기에도 사용하고 쓰기에도 사용하면 혼란스러울 수 있으니<br>읽기 즉 조회 용도로 cursor 를 만들어서 알고리즘에서 사용하고,<br>실제로 인덱스를 옮겨야 하는 이벤트 시점에만 i 를 업데이트한다</p><p>코드가 별 것 아닐 때 역할을 인식해야 한다</p><p>이 역할은 독립적인가?</p><p>&lt;를 찾기 직전까지를 묶어서 텍스트 노드로 만들어서 현재 스택의 자식으로 넣어준다 라는 알고리즘이 역할상 독립적입니다</p><p>그렇다면 즉시 함수화 시킨다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> textNode = <span class="function">(<span class="params">input, cursor, curr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> idx = input.indexOf(<span class="string">"&lt;"</span>, cursor);</span><br><span class="line">  curr.tag.children.push(&#123;</span><br><span class="line">    type: <span class="string">"text"</span>,</span><br><span class="line">    text: input.substring(cursor, idx)</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> idx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>역할이 분리된 순간 즉시 함수로 간다, 코드 관리를 위해서</p><p>나중에 텍스트 노드에 더 많은 기능을 넣고 싶으면 함수만 수정하면 된다</p><p>단 cursor 나 curr 는 지역변수가 아니다, 그렇기에 인자로 받을 수 밖에 없다</p><p>코드를 그대로 보내고 모자란 것들을 인자로 만든다</p><p>바깥 쪽에 있는 프리미티브 변수를 갱신해야 할 때는 return 을 사용하여 바깥 쪽에서 갱신하도록 함</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> textNode = <span class="function">(<span class="params">input, cursor, curr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> idx = input.indexOf(<span class="string">"&lt;"</span>, cursor);</span><br><span class="line">  curr.tag.children.push(&#123;</span><br><span class="line">    type: <span class="string">"text"</span>,</span><br><span class="line">    text: input.substring(cursor, idx)</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> idx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parser = <span class="function"><span class="params">input</span> =&gt;</span> &#123;</span><br><span class="line">  input = input.trim();</span><br><span class="line">  <span class="keyword">const</span> result = &#123; <span class="attr">name</span>: <span class="string">"ROOT"</span>, <span class="attr">type</span>: <span class="string">"node"</span>, <span class="attr">children</span>: [] &#125;;</span><br><span class="line">  <span class="keyword">const</span> stack = [&#123; <span class="attr">tag</span>: result &#125;];</span><br><span class="line">  <span class="keyword">let</span> curr,</span><br><span class="line">    i = <span class="number">0</span>,</span><br><span class="line">    j = input.length;</span><br><span class="line">  <span class="keyword">while</span> ((curr = stack.pop())) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">const</span> cursor = i;</span><br><span class="line">      <span class="keyword">if</span> (input[cursor] === <span class="string">"&lt;"</span>) &#123;</span><br><span class="line">        <span class="comment">// A, B의 경우</span></span><br><span class="line">      &#125; <span class="keyword">else</span> i = textNode(input, cursor, curr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>역할을 인식한 순간 함수화를 하지 못하면 끝장이다, 겉잡을 수 없게 된다</p><p>이 시점에 분리해야지만 가능하다, 나중에 뜯어서 분리하려고 하면 새로 짜는 수 밖에 없다</p><p>이미 너무 많이 오염되어있을 것, 인식하자마자 바꿔야 한다</p><p>input 과 cursor 는 값에 의한 복사니까 문제없지만 curr 는 객체이니 나쁜 것은 아닌가?</p><p>나쁘다, 그러나 방지하려면 curr 를 받지 않고 idx 와 텍스트 노드 객체를 함께 담아 배열로 리턴하여 바깥 쪽에서 하나는 i 를, 하나는 curr 를 수정하는 식으로 구현할 수도 있다</p><p>코드는 응집성을 가지면서 결합도를 낮춰야 한다, 그 밸런스를 맞춰야 한다, 둘 모두를 추구할 수는 없다</p><p>여기서는 응집성을 추구한 것, 항상 선택의 기로에 서게 됩니다</p><p>만약 위처럼 curr 를 받지 않으면 응집성과 의존성 모두 낮아진다</p><p>항상 의사결정을 할 수 밖에 없습니다,</p><p>밸런스를 어떻게 지킬 것이냐는 상황에 따라 다르기 때문에 그 센스를 갖기가 어려워서 좋은 개발자가 되기 힘든 것이다</p><p>실무에서는 정답을 하나로 정할 수 없습니다, 항상 밸런스 문제가 있습니다</p><p>&lt; 라는 weak 한 것에 의존하여 분기처리를 해도 되는가? HTML 도 그렇다</p><p>그래서 &lt;으로 이스케이프하지 않으면 &lt;를 발동 트리거로 쓸 수 없다</p><p>닫는 태그(&gt;)는 발동 트리거가 아니기 때문에 무관하다</p><p>이런 parser 들을 구현하다보면 separator 혹은 token 이라고 불리는 문자열들이 만들어지기 마련이다</p><p>얘네들은 값으로 쓰고 싶다면 이스케이프 처리가 필요하다</p><p>중요한 요령은 무조건 쉬운 것부터 처리한다는 것</p><p>왜 그런가? 쉬운 코드는 의존성이 낮고 독립된 기능일 가능성이 높습니다</p><p>쉬운 것부터 구현해야 그것을 의존하는 다른 코드를 짜기가 수월합니다</p><p>복잡한 것부터 짜면 자기 것인줄 알았던 부분이 공유되어야 하는 부분도 크고,</p><p>남에게 의존할 것이 있었는데 자기가 처리하게 되면서 중복도 생겨나곤 합니다</p><p>되도록이면 쉬운 것부터 짜야 합니다</p><p>그래야지 더 견고하고 의존성이 낮은 모듈로부터 의존성 높은 모듈을 짜나갈 수 있습니다</p><p>항상 쉬운 것부터 짜세요</p><p>&lt; 로 발동되는 케이스는 열린 태그, 닫힌 태그, self 종료 태그(<img>) 세 가지로 나눌 수 있습니다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> textNode = <span class="function">(<span class="params">input, cursor, curr</span>) =&gt;</span> &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parser = <span class="function"><span class="params">input</span> =&gt;</span> &#123;</span><br><span class="line">  input = input.trim();</span><br><span class="line">  <span class="keyword">const</span> result = &#123; <span class="attr">name</span>: <span class="string">"ROOT"</span>, <span class="attr">type</span>: <span class="string">"node"</span>, <span class="attr">children</span>: [] &#125;;</span><br><span class="line">  <span class="keyword">const</span> stack = [&#123; <span class="attr">tag</span>: result &#125;];</span><br><span class="line">  <span class="keyword">let</span> curr,</span><br><span class="line">    i = <span class="number">0</span>,</span><br><span class="line">    j = input.length;</span><br><span class="line">  <span class="keyword">while</span> ((curr = stack.pop())) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">const</span> cursor = i;</span><br><span class="line">      <span class="keyword">if</span> (input[cursor] === <span class="string">"&lt;"</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> idx = input.indexOf(<span class="string">'&gt;'</span>, cursor);</span><br><span class="line">        i = idx + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> i = textNode(input, cursor, curr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>indexOf 의 두 번째 인자를 주지 않으면 우리가 의도한 곳을 찾지 못할 것입니다</p><p>세 가지 케이스 중에 무엇인지와 무관하게 그 다음 번 i 가 무엇인지는 확정지을 수 있습니다</p><p>A 와 B 케이스의 공통점은 &lt;로 시작해서 &gt;로 끝난다는 것, 즉 태그이다</p><p>코드를 잘 짜면 코드를 읽을 수 있습니다</p><p>케이스의 공통점을 찾아서 먼저 처리해준다, 코드가 중복되지 않도록</p><p>이렇게 바라보지 않으면 똑같은 행동을 세 번 처리하게 되고 나중에 중복을 제거하기가 어려워진다</p><p>그럴 것이면 미리 눈을 훈련해서 공통점을 추출할 수 있도록 하는 수 밖에 없습니다</p><p>가볍게 보지 말고, 함부로 보지 말고, 더 깊게 바라보세요</p><p>얘네들은 분명 친척일거야 라는 관점으로-</p><p>똑같은 애들부터 찾아서 처리해야 합니다</p><p>남들이 짠 코드에도 많은 고민과 의도가 숨겨져있을 것이라 생각하고 바라보셔야 합니다</p><p>오픈소스나 프로개발자들이 짠 코드에는 굉장히 많은 메타포가 숨어있습니다</p><p>언어 사용에 익숙한 사람들에게는 그것이 읽힙니다</p><p>한국어로 다양하게 노란색을 표현해도 뉘앙스를 느끼시듯이 언어에 익숙해지면 코드를 보고 뉘앙스를 느낍니다 똑같이</p><p>그러려면 여러분들이 뉘앙스를 표현할만큼 언어를 깊이 써야 합니다</p><p>코드에 다 의도가 있습니다</p><p><div> 와 <img>는 태그를 연다는 공통점이 있습니다, 는 외톨이</div></p><p>태그를 열면 어떤 일이 일어나야 하는가? 태그가 닫힐 때까지의 그 이후 내용들은 모두 해당 태그의 자식이 되어야 함</p><p>물론 <img>는 열리자마자 닫혀서 그 이후 태그들에게 내용들이 향해야 곳에 주지 않지만, 열어서 새로운 태그를 만들어냈다는 점은 동일</p><p>사물을 보고 데이터 애널리시스를 하는데 추상화된 공통점과 재귀적인 로직을 발견하는 것이 우리의 몫입니다</p><p>그것을 못하면 코드는 계속 길어지고 if 로 분기만 하게 됩니다</p><p>단위테스트를 만들거나 TDD 를 해도 나쁜 개발자는 나쁜 데이터 애널리시스를 하고 나쁜 로직을 짰기 때문에</p><p>테스트 케이스를 100 개 만들면 100 개의 케이스가 통과한 것만 증명하지, 101 번째 케이스에 문제가 없다는 것을 증명하지 못합니다</p><p>원래 코드가 나쁘거나 설계가 잘못 되었으면 TDD 를 해도 소용이 없다</p><p>TDD 를 도입하는 것과 데이터를 바라보거나 추상적인 로직을 이해하는 것은 별개의 문제이다</p><p>어차피 데이터 애널리시스를 잘못하면 무엇을 해도 나쁜 코드가 나온다</p><p>좋은 코드를 짜는 비밀은 TDD 에 있는 것이 아니라 데이터를 이해하고 재귀적인 로직을 찾아내거나 추상화된 공통점을 찾아낼 수 있는지 역할을 이해하는지 여부에 달려있다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> textNode = <span class="function">(<span class="params">input, cursor, curr</span>) =&gt;</span> &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parser = <span class="function"><span class="params">input</span> =&gt;</span> &#123;</span><br><span class="line">  input = input.trim();</span><br><span class="line">  <span class="keyword">const</span> result = &#123; <span class="attr">name</span>: <span class="string">"ROOT"</span>, <span class="attr">type</span>: <span class="string">"node"</span>, <span class="attr">children</span>: [] &#125;;</span><br><span class="line">  <span class="keyword">const</span> stack = [&#123; <span class="attr">tag</span>: result &#125;];</span><br><span class="line">  <span class="keyword">let</span> curr,</span><br><span class="line">    i = <span class="number">0</span>,</span><br><span class="line">    j = input.length;</span><br><span class="line">  <span class="keyword">while</span> ((curr = stack.pop())) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">const</span> cursor = i;</span><br><span class="line">      <span class="keyword">if</span> (input[cursor] === <span class="string">"&lt;"</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> idx = input.indexOf(<span class="string">'&gt;'</span>, cursor);</span><br><span class="line">        i = idx + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (input[cursor + <span class="number">1</span>] === <span class="string">'/'</span>) &#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (input[idx - <span class="number">1</span>] === <span class="string">'/'</span>) &#123;&#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> i = textNode(input, cursor, curr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>input[cursor + 1] === &#39;/&#39;</code>는  케이스</p><p>그 뒤에 <code>input[idx - 1] === &#39;/&#39;</code> 여부로 <img> (true)와 <div> (false)를 나눈다</div></p><p>멘탈 모델이 그려지면, 코드로도 똑같이 표현되는 것이 정상이에요, 그래야 유지보수를 할 수 있습니다</p><p>그렇기 때문에 주석이 불필요합니다</p><p>그럼에도 주석이 필요하다고 느낀다면 개발자를 그만 둘 때입니다</p><p>여는 태그는 닫는 태그를 알아야 하고, 닫는 태그는 여는 태그를 알아야 하니, <img>부터 구현하도록 합니다</p><p>현실 세계를 인식해서 그 현실 세계를 해결할 코드를 짠다면 반대로 현실 세계에 대입해도 코드가 정확히 매핑되어야 합니다</p><p>바른 데이터 애널리시스를 했다면 코드는 거의 매핑이다, 어렵지 않습니다</p><p>여러분들이 알고리즘을 짜는데 어려움을 겪거나 애플리케이션을 못 만들어내겠다면 데이터 애널리시스에 실패한 것입니다</p><p>데이터 애널리시스를 잘 했으면 바로 매핑됩니다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> textNode = <span class="function">(<span class="params">input, cursor, curr</span>) =&gt;</span> &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parser = <span class="function"><span class="params">input</span> =&gt;</span> &#123;</span><br><span class="line">  input = input.trim();</span><br><span class="line">  <span class="keyword">const</span> result = &#123; <span class="attr">name</span>: <span class="string">"ROOT"</span>, <span class="attr">type</span>: <span class="string">"node"</span>, <span class="attr">children</span>: [] &#125;;</span><br><span class="line">  <span class="keyword">const</span> stack = [&#123; <span class="attr">tag</span>: result &#125;];</span><br><span class="line">  <span class="keyword">let</span> curr,</span><br><span class="line">    i = <span class="number">0</span>,</span><br><span class="line">    j = input.length;</span><br><span class="line">  <span class="keyword">while</span> ((curr = stack.pop())) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">const</span> cursor = i;</span><br><span class="line">      <span class="keyword">if</span> (input[cursor] === <span class="string">"&lt;"</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> idx = input.indexOf(<span class="string">'&gt;'</span>, cursor);</span><br><span class="line">        i = idx + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (input[cursor + <span class="number">1</span>] === <span class="string">'/'</span>) &#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> name, isClose;</span><br><span class="line">          <span class="keyword">if</span> (input[idx - <span class="number">1</span>] === <span class="string">'/'</span>) &#123;</span><br><span class="line">            name = input.substring(cursor + <span class="number">1</span>, idx - <span class="number">1</span>), isClose = <span class="literal">true</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            name = input.substring(cursor + <span class="number">1</span>, idx), isClose = <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> i = textNode(input, cursor, curr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>대응되도록 똑같은 쌍을 만들어줍니다, 느껴지는 차이를 그대로 코드로 옮겨온 것입니다, 한국어를 코드로 번역하는 과정</p><p>정확하게 한국어로 상황을 인식할 수 있다면 코드는 그냥 번역하면 됩니다</p><p>번역할 때 뉘앙스를 줘라, if else 라는 두 가지 이지선다를 주고 이지선다가 똑같이 동형으로 똑같은 리듬이 느껴지는 것을 원했습니다</p><p>조건에 따라 약간의 차이가 존재한다는 뉘앙스가 전달되어야 합니다</p><p>문학적인 표현이 필요한게 아니라, 데이터 애널리시스에 대한 관점을 정확하게 표현하는 것은 유지보수를 위해 항상 필요합니다</p><p>섬세하다고 느껴지시면 맞습니다, 고급 개발자들은 언어에 익숙하기 때문에 섬세하게 짭니다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> idx = input.indexOf(<span class="string">"&gt;"</span>, cursor);</span><br><span class="line">i = idx + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (input[cursor + <span class="number">1</span>] === <span class="string">"/"</span>) &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name, isClose;</span><br><span class="line">  <span class="keyword">if</span> (input[idx - <span class="number">1</span>] === <span class="string">"/"</span>) &#123;</span><br><span class="line">    (name = input.substring(cursor + <span class="number">1</span>, idx - <span class="number">1</span>)), (isClose = <span class="literal">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    (name = input.substring(cursor + <span class="number">1</span>, idx)), (isClose = <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> tag = &#123; name, <span class="attr">type</span>: <span class="string">"node"</span>, <span class="attr">children</span>: [] &#125;;</span><br><span class="line">  curr.tag.children.push(tag);</span><br><span class="line">  <span class="keyword">if</span> (!isClose) &#123;</span><br><span class="line">    stack.push(&#123; tag, <span class="attr">back</span>: curr &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>차이점을 처리했다면 더이상 차이를 케이스로 인식하지 않아도 됩니다</p><p>원래 케이스였던 것을 값으로 흡수한 뒤에는 더이상 케이스를 인식하지 않고 값을 사용하는 일반화된 알고리즘이 나옵니다</p><p>메모리와 연산은 교환됩니다</p><p>차이를 일으키는 연산을 메모리로 흡수한 다음에, 메모리를 가리키는 하나의 연산만 기술하면 됩니다</p><p>name 을 화이트리스트라고 부릅니다, 함수의 인자를 필터링해서 안정적인 조건을 만든다든지 서버에서 내려준 JSON 을 View 가 소비하기 좋게 바꾼다는지 등</p><p>알고리즘은 그러한 복잡성을 모두 제거하고 복잡성이 모두 제거되어 안정화된 상태에서 화이트리스트를 가지고 알고리즘을 하나만 구현하는 것이 제일 최선이다</p><p>알고리즘으로 함부로 돌입하지 말고, 화이트리스트 작성에 굉장히 공을 많이 들인 다음에 완전히 정제되어있는 화이트리스트용 알고리즘만 하나 구현하시는 것이 최선입니다, 가장 유지보수도 수월합니다</p><p>번역층을 거치면 화이트리스트를 기반으로 이 알고리즘은 잘 동작할 것이라고 보장됩니다</p><p>stack 에 push 후 break 를 하는 것은 마치 함수를 호출할 때 리턴포인트를 알고 끝나면 그곳으로 돌아가는 것의 수동 버전과 같습니다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> elementNode = <span class="function">(<span class="params">input, cursor, idx, curr, stack</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name, isClose;</span><br><span class="line">  <span class="keyword">if</span> (input[idx - <span class="number">1</span>] === <span class="string">'/'</span>) &#123;</span><br><span class="line">    name = input.substring(cursor + <span class="number">1</span>, idx - <span class="number">1</span>), isClose = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    name = input.substring(cursor + <span class="number">1</span>, idx), isClose = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> tag = &#123;name, <span class="attr">type</span>: <span class="string">'node'</span>, <span class="attr">children</span>: []&#125;;</span><br><span class="line">  curr.tag.children.push(tag);</span><br><span class="line">  <span class="keyword">if</span> (!isClose) &#123;</span><br><span class="line">    stack.push(&#123; tag, <span class="attr">back</span>: curr &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> textNode = <span class="function">(<span class="params">input, cursor, curr</span>) =&gt;</span> &#123;...&#125;;</span><br><span class="line"><span class="keyword">const</span> parser = <span class="function"><span class="params">input</span> =&gt;</span> &#123;</span><br><span class="line">  input = input.trim();</span><br><span class="line">  <span class="keyword">const</span> result = &#123; <span class="attr">name</span>: <span class="string">'ROOT'</span>, <span class="attr">type</span>: <span class="string">'node'</span>, <span class="attr">children</span>: [] &#125;, stack = [&#123; <span class="attr">tag</span>: result &#125;];</span><br><span class="line">  <span class="keyword">let</span> curr, i = <span class="number">0</span>, j = input.length;</span><br><span class="line">  <span class="keyword">while</span> (curr = stack.pop()) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">const</span> cursor = i;</span><br><span class="line">      <span class="keyword">if</span> (input[cursor] === <span class="string">'&lt;'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> idx = input.indexOf(<span class="string">'&gt;'</span>, cursor);</span><br><span class="line">        i = idx + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (input[cursor + <span class="number">1</span>] === <span class="string">'/'</span>) &#123;</span><br><span class="line">          curr = curr.back;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (elementNode(input, cursor, idx, curr, stack)) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> i = textNode(input, cursor, curr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>break 는 외부 제어 통제이므로 elementNode 함수 안에서 통제할 수 없으므로 flag 변수로 리턴해줍니다</p><p>코드의 가독성은 어떻게 확보하는가?</p><p>변수명, 코드컨벤션 등으로 가독성이 확보되지 않습니다</p><p>알고리즘, 수학적 함수, 연산 등은 어렵습니다</p><p>컴퓨터가 연산해야 할 것을 머리속으로 생각하면서 읽어야 하기 때문입니다</p><p>어떤 코드가 읽기 쉬운가? 역할에게 위임하는 코드</p><p>역할을 인식해서 역할에게 위임하는 코드를 짜야 합니다, 오직 그것만이 쉽게 합니다</p><p>알고리즘 등은 원래 무조건 어렵습니다</p><p>적절한 역할모델로 위임되어서 그것들간의 통신과 협업만 볼 수 있는 코드가 가독성 높은 코드입니다</p><p>console.log(parser(<code>&lt;div&gt;a&lt;a&gt;b&lt;/a&gt;c&lt;img/&gt;d&lt;/div&gt;</code>));</p><p>HTML 에서 태그간 엔터만 쳐도 텍스트노드가 생성됩니다</p><p>HTML 압축은 DOM 의 렌더링 대상을 줄여줄 수 있게 됩니다</p><p>CSS, JS 압축보다 HTML 압축을 하면 생성되는 노드수를 줄일 수 있다, 브라우저 부하를 줄일 수 있습니다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> elementNode = <span class="function">(<span class="params">input, cursor, idx, curr, stack</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> isClose = input[idx - <span class="number">1</span>] === <span class="string">"/"</span>;</span><br><span class="line">  <span class="keyword">const</span> tag = &#123;</span><br><span class="line">    name: input.substring(cursor + <span class="number">1</span>, idx - (isClose ? <span class="number">1</span> : <span class="number">0</span>)),</span><br><span class="line">    type: <span class="string">"node"</span>,</span><br><span class="line">    children: []</span><br><span class="line">  &#125;;</span><br><span class="line">  curr.tag.children.push(tag);</span><br><span class="line">  <span class="keyword">if</span> (!isClose) &#123;</span><br><span class="line">    stack.push(&#123; tag, <span class="attr">back</span>: curr &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>중복된 코드를 줄이는 수준은 우리의 수준에 달려있어요</p><p>켄트벡이 말하길, 중복은 제거하는게 아니라 발견하는 것이라 했습니다</p><p>프로그래머의 수준에 따라서 코드 수준의 중복, 아키텍처 수준의 중복, 데이터 상의 중복 등을 깨닫게 됩니다</p><p>궁극적으로 개발 중복을 다 인식하게 되면, 개발을 모두 직접 짜는 행위가 없어지고 솔루션화 됩니다</p><p>처음에는 케이스 바이 케이스로 코드로 만들다가 공통되는 부분들이 자동으로 처리되다가 나중에는 코드로 구현할 것이 하나도 없이 명령만으로 다 되게끔 바뀝니다</p><p>코드를 이따금씩 바라보면서 중복이 보일 때마다 내 실력이 올라갔구나 라고 느끼시면 됩니다</p><p>코드 수준의 중복을 바라보는 것과 아키텍처 수준의 중복을 발견해내는 것이 동시에 올라가는 것이 아니라 따로 따로 훈련해야 올라가게 되어있습니다</p><p>코드 수준의 중복에 대한 이해는 언어에 대한 바른 이해와 문법적인 해박한 사용방법에 대해 이해할수록 높일 수 있습니다</p><p>의미를 훼손하지 않고 줄였음에도 초보자들에게는 암호처럼 보일 수 있습니다</p><p>왜냐하면 초보자들은 언어를 네이티브처럼 쓰지 않기 때문입니다</p><p>아키텍처 레벨은 역할 관계를 인식하고, 책임이 어디까지 닿아있는지, 얼마나 확장가능성이 있는지 등을 보는 눈에서부터 어디가 중복이고 어디를 레이어로 나눌지에 대한 눈이 생겨야 합니다</p><p>데이터 중복은 전통적인 RDB 에 있는 정규화를 비롯해서 다양한 데이터에 대한 중복을 제거하는 안정적인 로직들이 많이 있습니다</p><p>제가 코드를 인정하는 기준은 딱 하나에요, 컴퓨터가 인정하면 나도 인정</p><p>여러분들이 남의 코드를 바라보면서 스트레스를 받는 이유는, 자꾸 비이성적인 것들이 프레임처럼 작용해서 가로막고 있어서 코드를 못 읽게 만들기 때문입니다</p><p>심리적인 장벽이 힘들게 만듭니다</p><p>남의 코드를 바라보면서 내가 원하는 스타일이 아니면 힘들게 여기는 것입니다</p><p>심리적인 장벽을 없애고 선입견을 내려놓고 바라보면 그냥 보입니다</p><p>사람들은 자기 코드를 인정해주고 잘 돌아가지 않는 부분에 대해서 조언을 해주거나 더 좋은 코드가 되기 위한 알고리즘을 제안해주는 사람을 따르기 마련입니다</p><p>여러분들이 선입견을 버리지 않으면 그렇지 못한 사람이 될 것입니다</p><p>코드는 잘 동작하고 바른 로직으로 되어있으면 다 바른 코드입니다</p><p>스타일은 별로 중요하지 않습니다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> textNode = <span class="function">(<span class="params">input, cursor, curr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> idx = input.indexOf(<span class="string">"&lt;"</span>, cursor);</span><br><span class="line">  curr.tag.children.push(&#123;</span><br><span class="line">    type: <span class="string">"text"</span>,</span><br><span class="line">    text: input.substring(cursor, idx)</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> idx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> elementNode = <span class="function">(<span class="params">input, cursor, idx, curr, stack</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> isClose = input[idx - <span class="number">1</span>] === <span class="string">"/"</span>;</span><br><span class="line">  <span class="keyword">const</span> tag = &#123;</span><br><span class="line">    name: input.substring(cursor + <span class="number">1</span>, idx - (isClose ? <span class="number">1</span> : <span class="number">0</span>)),</span><br><span class="line">    type: <span class="string">"node"</span>,</span><br><span class="line">    children: []</span><br><span class="line">  &#125;;</span><br><span class="line">  curr.tag.children.push(tag);</span><br><span class="line">  <span class="keyword">if</span> (!isClose) &#123;</span><br><span class="line">    stack.push(&#123; tag, <span class="attr">back</span>: curr &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parser = <span class="function"><span class="params">input</span> =&gt;</span> &#123;</span><br><span class="line">  input = input.trim();</span><br><span class="line">  <span class="keyword">const</span> result = &#123; <span class="attr">name</span>: <span class="string">"ROOT"</span>, <span class="attr">type</span>: <span class="string">"node"</span>, <span class="attr">children</span>: [] &#125;,</span><br><span class="line">    stack = [&#123; <span class="attr">tag</span>: result &#125;];</span><br><span class="line">  <span class="keyword">let</span> curr,</span><br><span class="line">    i = <span class="number">0</span>,</span><br><span class="line">    j = input.length;</span><br><span class="line">  <span class="keyword">while</span> ((curr = stack.pop())) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">const</span> cursor = i;</span><br><span class="line">      <span class="keyword">if</span> (input[cursor] === <span class="string">"&lt;"</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> idx = input.indexOf(<span class="string">"&gt;"</span>, cursor);</span><br><span class="line">        i = idx + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (input[cursor + <span class="number">1</span>] === <span class="string">"/"</span>) &#123;</span><br><span class="line">          curr = curr.back;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (elementNode(input, cursor, idx, curr, stack)) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> i = textNode(input, cursor, curr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(parser(<span class="string">`&lt;div&gt;a&lt;a&gt;b&lt;/a&gt;c&lt;img/&gt;d&lt;/div&gt;`</span>));</span><br></pre></td></tr></table></figure><p>HTML 은 멀티 스택 상황이 발생하지 않습니다, 컨텍스트가 동시에 두 개가 진행되지 않습니다, 이런 경우에는 스택 배열이 필요없고 하나의 변수에서만 교체해주면 됩니다, 하지만 많은 경우에는 여러 개를 동시에 유지하면서 따로 따로 주기를 가지고 컨텍스트가 교체되곤 합니다, 지금은 curr 하나만 가지고 있으면 됩니다</p><p>코드를 만드는데 차이는 디테일에서 생겨납니다, 오늘까지 해서 함수를 배우신 것입니다, 게다가 함수형 프로그래밍은 다루지 않았고, 루틴을 다루는 방법만 배운 것입니다, 루틴에 먼저 익숙해지는 것이야말로 중급개발자로 가는 기본이고, 루틴에 익숙하지 않은 사람은 객체구조를 만들어도 어차피 엉망으로 만들게 되어있습니다</p><p>Q0. 위 구조를 꼬리물기 최적화되는 재귀로 바꿀 수는 없는가? (위를 2 단 루프로 구성한 것은 stack point 를 인식해서 재귀함수로 만들기 더 쉬우시라는 의미였다, 이너루프만 함수로 만들면 되기 때문에)</p><p>Q1. stack 을 벗어날 때는 바깥 쪽 stack 으로 나가지 않으면서 왜 stack 을 추가할 때는 바깥 쪽 stack 으로 나갔다가 들어오지? stack 구조를 모두 지우고 curr 를 교체하는 것만으로 구현할 수 있지 않은가?</p><p>Q2. JSON 문자열을 받아 JSON Object 를 리턴해주는 JSON Parser, HTML 에서의 C 타입에 해당하는 것이 string, integer, boolean, null 인 것, 그리고 object 시작하면 object 닫아야 하고, array 시작했으면 array 닫아야 함, “ 안에 중괄호나 대괄호가 있으면 그저 문자입니다, HTML 와 달리 이스케이프를 지원해주어야 합니다</p><p>Q3. 속성이 포함된 html 을 파싱하기 <code>&lt;div style=&quot;background:red&quot; class=&quot;test&quot;&gt;...&lt;/div&gt;</code> 이런 식으로 태그 안의 여러 속성을 각 노드에서 attribute 라는 별도의 배열에 저장하기</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;어플리케이션을 짤 때, 대부분의 경우는 인식하여 구조화해서 프로그래밍 해야 하는 경우가 대부분&lt;/p&gt;
&lt;p&gt;HTML 파서를 짤려면 HTML 을 보고 구조적으로 분석해야 함&lt;/p&gt;
&lt;p&gt;구조화를 무한히 하면 무한한 케이스가 될 뿐, 구조화의 목표는
      
    
    </summary>
    
      <category term="Dev" scheme="https://eclatant.io/categories/Dev/"/>
    
    
      <category term="Dev" scheme="https://eclatant.io/tags/Dev/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 교과서</title>
    <link href="https://eclatant.io/2018/08/12/NodeJS-TextBook/"/>
    <id>https://eclatant.io/2018/08/12/NodeJS-TextBook/</id>
    <published>2018-08-11T15:00:00.000Z</published>
    <updated>2018-12-10T09:48:32.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1장-Node-js-시작하기"><a href="#1장-Node-js-시작하기" class="headerlink" title="1장 Node.js 시작하기"></a>1장 Node.js 시작하기</h2><p>Node.js란 무엇인가?</p><p>Node.js, JavaScript Runtime Environment</p><p>런타임은 특정 언어로 만든 프로그램들을 실행할 수 있는 환경</p><p>따라서 는 자바스크립트를 웹 브라우저 밖에서 실행할 수 있게 해주는 환경</p><p>Node.js는 두 가지 버전 체계를 운영함, LTS(Long Term Support) / Current</p><p>LTS의 대상이 되는 버전은 짝수버전이며, LTS 스케쥴은 여기에서 확인할 수 있다 <a href="https://github.com/nodejs/Release#release-schedule" target="_blank" rel="noopener">Link</a></p><p>Node.js 설치 방법은 다양하나, 여러 가지 버전을 동시에 관리해야 한다면 <a href="https://github.com/nodenv/nodenv" target="_blank" rel="noopener">nodenv</a> 를 추천함</p><p>Node.js 내부 구조는 Node.js Core Library, Node.js Bindings, V8(자바스크립트 엔진), libuv(비동기 I/O) 로 되어있다고 함</p><p>Node.js는 libuv 라이브러리를 통해 이벤트 기반, 논 블록킹 I/O 모델을 차용했다고 하는데, 두 가지는 각각 어떤 의미인가?</p><hr><p>이벤트 루프에 대해서는 다음 두 개념을 이해한 뒤 아티클을 읽어보는 것이 가장 좋을 것이라 생각한다</p><p>프로세스란 운영체제에서 할당하는 자원의 단위이다</p><p>스레드는 프로세스 내에서 실행되는 흐름의 단위이다, 하나의 프로세스는 스레드를 여러 개 가지며 부모 프로세스의 자원을 공유할 수 있어서 같은 메모리에 접근할 수 있다</p><p><a href="https://meetup.toast.com/posts/89" target="_blank" rel="noopener">자바스크립트와 이벤트 루프</a></p><hr><p>논 블록킹 I/O에 대해 이해하기 위해서 Blocking, NonBlocking, Sync, Async 에 대해 살펴보자</p><ul><li><a href="https://eclatant.io/2018/12/09/2018-12-09-Block-NonBlock-Sync-Async/">Block, NonBlock, Sync, Async</a></li></ul><hr><h2 id="2장-알아두어야-할-자바스크립트"><a href="#2장-알아두어야-할-자바스크립트" class="headerlink" title="2장 알아두어야 할 자바스크립트"></a>2장 알아두어야 할 자바스크립트</h2><h3 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015+"></a>ES2015+</h3><h4 id="const-let"><a href="#const-let" class="headerlink" title="const, let"></a>const, let</h4><p>var와 달리 block scope이고 재선언이 불가능하고 hoisting이 이루어지지만 TDZ가 존재한다는 점이 중요하다</p><p>또한 let과 const는 재할당 가능 여부에 따라 차이가 존재한다</p><p>마지막으로 const 변수에 담긴 것이 Primitive가 아닌 Reference Type일 경우 Immutable하다고 볼 수 없다</p><p>어떠한 객체가 가진 주소값은 동일할지라도 해당 객체에 담긴 값들은 바뀔 수 있기 때문이다</p><ul><li><a href="https://jaeyeophan.github.io/2017/04/18/let-const/" target="_blank" rel="noopener">1. let &amp; const</a></li><li><a href="https://poiemaweb.com/es6-block-scope" target="_blank" rel="noopener">let, const와 블록 레벨 스코프</a></li><li><a href="https://medium.com/korbit-engineering/let과-const는-호이스팅-될까-72fcf2fac365" target="_blank" rel="noopener">let과 const는 호이스팅 될까?</a></li></ul><h4 id="템플릿-문자열"><a href="#템플릿-문자열" class="headerlink" title="템플릿 문자열"></a>템플릿 문자열</h4><p><code>${variable}</code> 형태의 string interpolation 또는 template substitution는 어렵지 않지만,  훨씬 어렵고 소중한 부분은 tagged templates이다, reduce와 결합하면 템플릿 엔진 부럽지 않게 만들 수 있다</p><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates" target="_blank" rel="noopener">Tagged templates</a></li><li><a href="http://hacks.mozilla.or.kr/2015/08/es6-in-depth-template-strings-2/" target="_blank" rel="noopener">ES6 In Depth: 템플릿 문자열</a></li></ul><h4 id="화살표-함수"><a href="#화살표-함수" class="headerlink" title="화살표 함수"></a>화살표 함수</h4><p>단순 문법을 넘어서서 함수와 결정적 차이는 책에 나오는 this binding 이외에도 prototype와 arguments이다</p><p>인자의 정보를 받아오고 싶다면 Rest parameter를 사용하거나, scope chain을 통해 상위 함수(당연히 이 함수는 화살표 함수가 아니어야 한다)의 arguments를 참조해야 한다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="built_in">console</span>.log(...args);</span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">hoc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)();</span><br></pre></td></tr></table></figure><ul><li><a href="https://poiemaweb.com/es6-arrow-function#42-prototype" target="_blank" rel="noopener">화살표 함수 - prototype</a></li><li><a href="http://hacks.mozilla.or.kr/2015/08/es6-in-depth-rest-parameters-and-defaults/" target="_blank" rel="noopener">ES6 In Depth: 레스트 파라메터와 디폴트 파라메터</a></li></ul><h4 id="비구조화-할당"><a href="#비구조화-할당" class="headerlink" title="비구조화 할당"></a>비구조화 할당</h4><ul><li><a href="http://hacks.mozilla.or.kr/2015/09/es6-in-depth-destructuring/" target="_blank" rel="noopener">ES6 In Depth: 디스트럭처링(Destructuring)</a></li></ul><h4 id="프로미스"><a href="#프로미스" class="headerlink" title="프로미스"></a>프로미스</h4><p>비동기 연산을 다루는 객체이다</p><ul><li><a href="https://eclatant.io/2018/12/10/2018-12-10-Async/">Async</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1장-Node-js-시작하기&quot;&gt;&lt;a href=&quot;#1장-Node-js-시작하기&quot; class=&quot;headerlink&quot; title=&quot;1장 Node.js 시작하기&quot;&gt;&lt;/a&gt;1장 Node.js 시작하기&lt;/h2&gt;&lt;p&gt;Node.js란 무엇인가?&lt;/p&gt;
      
    
    </summary>
    
      <category term="node" scheme="https://eclatant.io/categories/node/"/>
    
    
      <category term="n